// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;

/// See [`BatchDeleteReadSetInput`](crate::input::BatchDeleteReadSetInput).
pub mod batch_delete_read_set_input {
    
    /// A builder for [`BatchDeleteReadSetInput`](crate::input::BatchDeleteReadSetInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) sequence_store_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `ids`.
        ///
        /// To override the contents of this collection use [`set_ids`](Self::set_ids).
        ///
        /// <p>The read sets' IDs.</p>
        pub fn ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.ids.unwrap_or_default();
                            v.push(input.into());
                            self.ids = Some(v);
                            self
        }
        /// <p>The read sets' IDs.</p>
        pub fn set_ids(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.ids = input; self
        }
        /// <p>The read sets' sequence store ID.</p>
        pub fn sequence_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sequence_store_id = Some(input.into());
            self
        }
        /// <p>The read sets' sequence store ID.</p>
        pub fn set_sequence_store_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sequence_store_id = input; self
        }
        /// Consumes the builder and constructs a [`BatchDeleteReadSetInput`](crate::input::BatchDeleteReadSetInput).
        pub fn build(self) -> Result<crate::input::BatchDeleteReadSetInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::BatchDeleteReadSetInput {
                    ids: self.ids
                    ,
                    sequence_store_id: self.sequence_store_id
                    ,
                }
            )
        }
    }
    
    
}
impl BatchDeleteReadSetInput {
    /// Consumes the builder and constructs an Operation<[`BatchDeleteReadSet`](crate::operation::BatchDeleteReadSet)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::BatchDeleteReadSet, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::BatchDeleteReadSetInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_1 = &_input.sequence_store_id;
                let input_1 = input_1.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("sequence_store_id", "cannot be empty or unset"))?;
                let sequence_store_id = aws_smithy_http::label::fmt_string(input_1, aws_smithy_http::label::EncodingStrategy::Default);
                if sequence_store_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("sequence_store_id", "cannot be empty or unset"))
                            }
                write!(output, "/sequencestore/{sequenceStoreId}/readset/batch/delete", sequenceStoreId = sequence_store_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::BatchDeleteReadSetInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_batch_delete_read_set(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("control-storage-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::BatchDeleteReadSet::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("BatchDeleteReadSet", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`BatchDeleteReadSetInput`](crate::input::BatchDeleteReadSetInput).
    pub fn builder() -> crate::input::batch_delete_read_set_input::Builder {
        crate::input::batch_delete_read_set_input::Builder::default()
    }
}

/// See [`CancelAnnotationImportJobInput`](crate::input::CancelAnnotationImportJobInput).
pub mod cancel_annotation_import_job_input {
    
    /// A builder for [`CancelAnnotationImportJobInput`](crate::input::CancelAnnotationImportJobInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The job's ID.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The job's ID.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input; self
        }
        /// Consumes the builder and constructs a [`CancelAnnotationImportJobInput`](crate::input::CancelAnnotationImportJobInput).
        pub fn build(self) -> Result<crate::input::CancelAnnotationImportJobInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CancelAnnotationImportJobInput {
                    job_id: self.job_id
                    ,
                }
            )
        }
    }
    
    
}
impl CancelAnnotationImportJobInput {
    /// Consumes the builder and constructs an Operation<[`CancelAnnotationImportJob`](crate::operation::CancelAnnotationImportJob)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CancelAnnotationImportJob, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CancelAnnotationImportJobInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_2 = &_input.job_id;
                let input_2 = input_2.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("job_id", "cannot be empty or unset"))?;
                let job_id = aws_smithy_http::label::fmt_string(input_2, aws_smithy_http::label::EncodingStrategy::Default);
                if job_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("job_id", "cannot be empty or unset"))
                            }
                write!(output, "/import/annotation/{jobId}", jobId = job_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CancelAnnotationImportJobInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("analytics-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CancelAnnotationImportJob::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CancelAnnotationImportJob", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CancelAnnotationImportJobInput`](crate::input::CancelAnnotationImportJobInput).
    pub fn builder() -> crate::input::cancel_annotation_import_job_input::Builder {
        crate::input::cancel_annotation_import_job_input::Builder::default()
    }
}

/// See [`CancelRunInput`](crate::input::CancelRunInput).
pub mod cancel_run_input {
    
    /// A builder for [`CancelRunInput`](crate::input::CancelRunInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The run's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The run's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// Consumes the builder and constructs a [`CancelRunInput`](crate::input::CancelRunInput).
        pub fn build(self) -> Result<crate::input::CancelRunInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CancelRunInput {
                    id: self.id
                    ,
                }
            )
        }
    }
    
    
}
impl CancelRunInput {
    /// Consumes the builder and constructs an Operation<[`CancelRun`](crate::operation::CancelRun)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CancelRun, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CancelRunInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_3 = &_input.id;
                let input_3 = input_3.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))?;
                let id = aws_smithy_http::label::fmt_string(input_3, aws_smithy_http::label::EncodingStrategy::Default);
                if id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))
                            }
                write!(output, "/run/{id}/cancel", id = id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CancelRunInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("workflows-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CancelRun::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CancelRun", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CancelRunInput`](crate::input::CancelRunInput).
    pub fn builder() -> crate::input::cancel_run_input::Builder {
        crate::input::cancel_run_input::Builder::default()
    }
}

/// See [`CancelVariantImportJobInput`](crate::input::CancelVariantImportJobInput).
pub mod cancel_variant_import_job_input {
    
    /// A builder for [`CancelVariantImportJobInput`](crate::input::CancelVariantImportJobInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The job's ID.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The job's ID.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input; self
        }
        /// Consumes the builder and constructs a [`CancelVariantImportJobInput`](crate::input::CancelVariantImportJobInput).
        pub fn build(self) -> Result<crate::input::CancelVariantImportJobInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CancelVariantImportJobInput {
                    job_id: self.job_id
                    ,
                }
            )
        }
    }
    
    
}
impl CancelVariantImportJobInput {
    /// Consumes the builder and constructs an Operation<[`CancelVariantImportJob`](crate::operation::CancelVariantImportJob)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CancelVariantImportJob, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CancelVariantImportJobInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_4 = &_input.job_id;
                let input_4 = input_4.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("job_id", "cannot be empty or unset"))?;
                let job_id = aws_smithy_http::label::fmt_string(input_4, aws_smithy_http::label::EncodingStrategy::Default);
                if job_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("job_id", "cannot be empty or unset"))
                            }
                write!(output, "/import/variant/{jobId}", jobId = job_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CancelVariantImportJobInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("analytics-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CancelVariantImportJob::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CancelVariantImportJob", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CancelVariantImportJobInput`](crate::input::CancelVariantImportJobInput).
    pub fn builder() -> crate::input::cancel_variant_import_job_input::Builder {
        crate::input::cancel_variant_import_job_input::Builder::default()
    }
}

/// See [`CreateAnnotationStoreInput`](crate::input::CreateAnnotationStoreInput).
pub mod create_annotation_store_input {
    
    /// A builder for [`CreateAnnotationStoreInput`](crate::input::CreateAnnotationStoreInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) reference: std::option::Option<crate::model::ReferenceItem>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
        pub(crate) sse_config: std::option::Option<crate::model::SseConfig>,
        pub(crate) store_format: std::option::Option<crate::model::StoreFormat>,
        pub(crate) store_options: std::option::Option<crate::model::StoreOptions>,
    }
    impl Builder {
        /// <p>The genome reference for the store's annotations.</p>
        pub fn reference(mut self, input: crate::model::ReferenceItem) -> Self {
            self.reference = Some(input);
            self
        }
        /// <p>The genome reference for the store's annotations.</p>
        pub fn set_reference(mut self, input: std::option::Option<crate::model::ReferenceItem>) -> Self {
            self.reference = input; self
        }
        /// <p>A name for the store.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A name for the store.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>A description for the store.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description for the store.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Tags for the store.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>Tags for the store.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// <p>Server-side encryption (SSE) settings for the store.</p>
        pub fn sse_config(mut self, input: crate::model::SseConfig) -> Self {
            self.sse_config = Some(input);
            self
        }
        /// <p>Server-side encryption (SSE) settings for the store.</p>
        pub fn set_sse_config(mut self, input: std::option::Option<crate::model::SseConfig>) -> Self {
            self.sse_config = input; self
        }
        /// <p>The annotation file format of the store.</p>
        pub fn store_format(mut self, input: crate::model::StoreFormat) -> Self {
            self.store_format = Some(input);
            self
        }
        /// <p>The annotation file format of the store.</p>
        pub fn set_store_format(mut self, input: std::option::Option<crate::model::StoreFormat>) -> Self {
            self.store_format = input; self
        }
        /// <p>File parsing options for the annotation store.</p>
        pub fn store_options(mut self, input: crate::model::StoreOptions) -> Self {
            self.store_options = Some(input);
            self
        }
        /// <p>File parsing options for the annotation store.</p>
        pub fn set_store_options(mut self, input: std::option::Option<crate::model::StoreOptions>) -> Self {
            self.store_options = input; self
        }
        /// Consumes the builder and constructs a [`CreateAnnotationStoreInput`](crate::input::CreateAnnotationStoreInput).
        pub fn build(self) -> Result<crate::input::CreateAnnotationStoreInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateAnnotationStoreInput {
                    reference: self.reference
                    ,
                    name: self.name
                    ,
                    description: self.description
                    ,
                    tags: self.tags
                    ,
                    sse_config: self.sse_config
                    ,
                    store_format: self.store_format
                    ,
                    store_options: self.store_options
                    ,
                }
            )
        }
    }
    
    
}
impl CreateAnnotationStoreInput {
    /// Consumes the builder and constructs an Operation<[`CreateAnnotationStore`](crate::operation::CreateAnnotationStore)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateAnnotationStore, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateAnnotationStoreInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/annotationStore").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateAnnotationStoreInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_annotation_store(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("analytics-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateAnnotationStore::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateAnnotationStore", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateAnnotationStoreInput`](crate::input::CreateAnnotationStoreInput).
    pub fn builder() -> crate::input::create_annotation_store_input::Builder {
        crate::input::create_annotation_store_input::Builder::default()
    }
}

/// See [`CreateReferenceStoreInput`](crate::input::CreateReferenceStoreInput).
pub mod create_reference_store_input {
    
    /// A builder for [`CreateReferenceStoreInput`](crate::input::CreateReferenceStoreInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) sse_config: std::option::Option<crate::model::SseConfig>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A name for the store.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A name for the store.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>A description for the store.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description for the store.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// <p>Server-side encryption (SSE) settings for the store.</p>
        pub fn sse_config(mut self, input: crate::model::SseConfig) -> Self {
            self.sse_config = Some(input);
            self
        }
        /// <p>Server-side encryption (SSE) settings for the store.</p>
        pub fn set_sse_config(mut self, input: std::option::Option<crate::model::SseConfig>) -> Self {
            self.sse_config = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Tags for the store.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>Tags for the store.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// <p>To ensure that requests don't run multiple times, specify a unique token for each request.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>To ensure that requests don't run multiple times, specify a unique token for each request.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// Consumes the builder and constructs a [`CreateReferenceStoreInput`](crate::input::CreateReferenceStoreInput).
        pub fn build(self) -> Result<crate::input::CreateReferenceStoreInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateReferenceStoreInput {
                    name: self.name
                    ,
                    description: self.description
                    ,
                    sse_config: self.sse_config
                    ,
                    tags: self.tags
                    ,
                    client_token: self.client_token
                    ,
                }
            )
        }
    }
    
    
}
impl CreateReferenceStoreInput {
    /// Consumes the builder and constructs an Operation<[`CreateReferenceStore`](crate::operation::CreateReferenceStore)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateReferenceStore, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateReferenceStoreInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/referencestore").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateReferenceStoreInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_reference_store(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("control-storage-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateReferenceStore::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateReferenceStore", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateReferenceStoreInput`](crate::input::CreateReferenceStoreInput).
    pub fn builder() -> crate::input::create_reference_store_input::Builder {
        crate::input::create_reference_store_input::Builder::default()
    }
}

/// See [`CreateRunGroupInput`](crate::input::CreateRunGroupInput).
pub mod create_run_group_input {
    
    /// A builder for [`CreateRunGroupInput`](crate::input::CreateRunGroupInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) max_cpus: std::option::Option<i32>,
        pub(crate) max_runs: std::option::Option<i32>,
        pub(crate) max_duration: std::option::Option<i32>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
        pub(crate) request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A name for the group.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A name for the group.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>The maximum number of CPUs to use in the group.</p>
        pub fn max_cpus(mut self, input: i32) -> Self {
            self.max_cpus = Some(input);
            self
        }
        /// <p>The maximum number of CPUs to use in the group.</p>
        pub fn set_max_cpus(mut self, input: std::option::Option<i32>) -> Self {
            self.max_cpus = input; self
        }
        /// <p>The maximum number of concurrent runs for the group.</p>
        pub fn max_runs(mut self, input: i32) -> Self {
            self.max_runs = Some(input);
            self
        }
        /// <p>The maximum number of concurrent runs for the group.</p>
        pub fn set_max_runs(mut self, input: std::option::Option<i32>) -> Self {
            self.max_runs = input; self
        }
        /// <p>A max duration for the group.</p>
        pub fn max_duration(mut self, input: i32) -> Self {
            self.max_duration = Some(input);
            self
        }
        /// <p>A max duration for the group.</p>
        pub fn set_max_duration(mut self, input: std::option::Option<i32>) -> Self {
            self.max_duration = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Tags for the group.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>Tags for the group.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// <p>A request ID for the group.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>A request ID for the group.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input; self
        }
        /// Consumes the builder and constructs a [`CreateRunGroupInput`](crate::input::CreateRunGroupInput).
        pub fn build(self) -> Result<crate::input::CreateRunGroupInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateRunGroupInput {
                    name: self.name
                    ,
                    max_cpus: self.max_cpus
                    ,
                    max_runs: self.max_runs
                    ,
                    max_duration: self.max_duration
                    ,
                    tags: self.tags
                    ,
                    request_id: self.request_id
                    ,
                }
            )
        }
    }
    
    
}
impl CreateRunGroupInput {
    /// Consumes the builder and constructs an Operation<[`CreateRunGroup`](crate::operation::CreateRunGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateRunGroup, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.request_id.is_none() {
                                self.request_id = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::input::CreateRunGroupInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/runGroup").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateRunGroupInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_run_group(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("workflows-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateRunGroup::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateRunGroup", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateRunGroupInput`](crate::input::CreateRunGroupInput).
    pub fn builder() -> crate::input::create_run_group_input::Builder {
        crate::input::create_run_group_input::Builder::default()
    }
}

/// See [`CreateSequenceStoreInput`](crate::input::CreateSequenceStoreInput).
pub mod create_sequence_store_input {
    
    /// A builder for [`CreateSequenceStoreInput`](crate::input::CreateSequenceStoreInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) sse_config: std::option::Option<crate::model::SseConfig>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A name for the store.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A name for the store.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>A description for the store.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description for the store.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// <p>Server-side encryption (SSE) settings for the store.</p>
        pub fn sse_config(mut self, input: crate::model::SseConfig) -> Self {
            self.sse_config = Some(input);
            self
        }
        /// <p>Server-side encryption (SSE) settings for the store.</p>
        pub fn set_sse_config(mut self, input: std::option::Option<crate::model::SseConfig>) -> Self {
            self.sse_config = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Tags for the store.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>Tags for the store.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// <p>To ensure that requests don't run multiple times, specify a unique token for each request.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>To ensure that requests don't run multiple times, specify a unique token for each request.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// Consumes the builder and constructs a [`CreateSequenceStoreInput`](crate::input::CreateSequenceStoreInput).
        pub fn build(self) -> Result<crate::input::CreateSequenceStoreInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateSequenceStoreInput {
                    name: self.name
                    ,
                    description: self.description
                    ,
                    sse_config: self.sse_config
                    ,
                    tags: self.tags
                    ,
                    client_token: self.client_token
                    ,
                }
            )
        }
    }
    
    
}
impl CreateSequenceStoreInput {
    /// Consumes the builder and constructs an Operation<[`CreateSequenceStore`](crate::operation::CreateSequenceStore)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateSequenceStore, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateSequenceStoreInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/sequencestore").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateSequenceStoreInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_sequence_store(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("control-storage-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateSequenceStore::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateSequenceStore", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateSequenceStoreInput`](crate::input::CreateSequenceStoreInput).
    pub fn builder() -> crate::input::create_sequence_store_input::Builder {
        crate::input::create_sequence_store_input::Builder::default()
    }
}

/// See [`CreateVariantStoreInput`](crate::input::CreateVariantStoreInput).
pub mod create_variant_store_input {
    
    /// A builder for [`CreateVariantStoreInput`](crate::input::CreateVariantStoreInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) reference: std::option::Option<crate::model::ReferenceItem>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
        pub(crate) sse_config: std::option::Option<crate::model::SseConfig>,
    }
    impl Builder {
        /// <p>The genome reference for the store's variants.</p>
        pub fn reference(mut self, input: crate::model::ReferenceItem) -> Self {
            self.reference = Some(input);
            self
        }
        /// <p>The genome reference for the store's variants.</p>
        pub fn set_reference(mut self, input: std::option::Option<crate::model::ReferenceItem>) -> Self {
            self.reference = input; self
        }
        /// <p>A name for the store.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A name for the store.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>A description for the store.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description for the store.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Tags for the store.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>Tags for the store.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// <p>Server-side encryption (SSE) settings for the store.</p>
        pub fn sse_config(mut self, input: crate::model::SseConfig) -> Self {
            self.sse_config = Some(input);
            self
        }
        /// <p>Server-side encryption (SSE) settings for the store.</p>
        pub fn set_sse_config(mut self, input: std::option::Option<crate::model::SseConfig>) -> Self {
            self.sse_config = input; self
        }
        /// Consumes the builder and constructs a [`CreateVariantStoreInput`](crate::input::CreateVariantStoreInput).
        pub fn build(self) -> Result<crate::input::CreateVariantStoreInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateVariantStoreInput {
                    reference: self.reference
                    ,
                    name: self.name
                    ,
                    description: self.description
                    ,
                    tags: self.tags
                    ,
                    sse_config: self.sse_config
                    ,
                }
            )
        }
    }
    
    
}
impl CreateVariantStoreInput {
    /// Consumes the builder and constructs an Operation<[`CreateVariantStore`](crate::operation::CreateVariantStore)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateVariantStore, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateVariantStoreInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/variantStore").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateVariantStoreInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_variant_store(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("analytics-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateVariantStore::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateVariantStore", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateVariantStoreInput`](crate::input::CreateVariantStoreInput).
    pub fn builder() -> crate::input::create_variant_store_input::Builder {
        crate::input::create_variant_store_input::Builder::default()
    }
}

/// See [`CreateWorkflowInput`](crate::input::CreateWorkflowInput).
pub mod create_workflow_input {
    
    /// A builder for [`CreateWorkflowInput`](crate::input::CreateWorkflowInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) engine: std::option::Option<crate::model::WorkflowEngine>,
        pub(crate) definition_zip: std::option::Option<aws_smithy_types::Blob>,
        pub(crate) definition_uri: std::option::Option<std::string::String>,
        pub(crate) main: std::option::Option<std::string::String>,
        pub(crate) parameter_template: std::option::Option<std::collections::HashMap<std::string::String, crate::model::WorkflowParameter>>,
        pub(crate) storage_capacity: std::option::Option<i32>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
        pub(crate) request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A name for the workflow.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A name for the workflow.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>A description for the workflow.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description for the workflow.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// <p>An engine for the workflow.</p>
        pub fn engine(mut self, input: crate::model::WorkflowEngine) -> Self {
            self.engine = Some(input);
            self
        }
        /// <p>An engine for the workflow.</p>
        pub fn set_engine(mut self, input: std::option::Option<crate::model::WorkflowEngine>) -> Self {
            self.engine = input; self
        }
        /// <p>A ZIP archive for the workflow.</p>
        pub fn definition_zip(mut self, input: aws_smithy_types::Blob) -> Self {
            self.definition_zip = Some(input);
            self
        }
        /// <p>A ZIP archive for the workflow.</p>
        pub fn set_definition_zip(mut self, input: std::option::Option<aws_smithy_types::Blob>) -> Self {
            self.definition_zip = input; self
        }
        /// <p>The URI of a definition for the workflow.</p>
        pub fn definition_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.definition_uri = Some(input.into());
            self
        }
        /// <p>The URI of a definition for the workflow.</p>
        pub fn set_definition_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.definition_uri = input; self
        }
        /// <p>The path of the main definition file for the workflow.</p>
        pub fn main(mut self, input: impl Into<std::string::String>) -> Self {
            self.main = Some(input.into());
            self
        }
        /// <p>The path of the main definition file for the workflow.</p>
        pub fn set_main(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.main = input; self
        }
        /// Adds a key-value pair to `parameter_template`.
        ///
        /// To override the contents of this collection use [`set_parameter_template`](Self::set_parameter_template).
        ///
        /// <p>A parameter template for the workflow.</p>
        pub fn parameter_template(mut self, k: impl Into<std::string::String>, v: crate::model::WorkflowParameter) -> Self {
            let mut hash_map = self.parameter_template.unwrap_or_default();
                            hash_map.insert(k.into(), v);
                            self.parameter_template = Some(hash_map);
                            self
        }
        /// <p>A parameter template for the workflow.</p>
        pub fn set_parameter_template(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, crate::model::WorkflowParameter>>) -> Self {
            self.parameter_template = input; self
        }
        /// <p>A storage capacity for the workflow.</p>
        pub fn storage_capacity(mut self, input: i32) -> Self {
            self.storage_capacity = Some(input);
            self
        }
        /// <p>A storage capacity for the workflow.</p>
        pub fn set_storage_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.storage_capacity = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Tags for the workflow.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>Tags for the workflow.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// <p>A request ID for the workflow.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>A request ID for the workflow.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input; self
        }
        /// Consumes the builder and constructs a [`CreateWorkflowInput`](crate::input::CreateWorkflowInput).
        pub fn build(self) -> Result<crate::input::CreateWorkflowInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateWorkflowInput {
                    name: self.name
                    ,
                    description: self.description
                    ,
                    engine: self.engine
                    ,
                    definition_zip: self.definition_zip
                    ,
                    definition_uri: self.definition_uri
                    ,
                    main: self.main
                    ,
                    parameter_template: self.parameter_template
                    ,
                    storage_capacity: self.storage_capacity
                    ,
                    tags: self.tags
                    ,
                    request_id: self.request_id
                    ,
                }
            )
        }
    }
    
    
}
impl CreateWorkflowInput {
    /// Consumes the builder and constructs an Operation<[`CreateWorkflow`](crate::operation::CreateWorkflow)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateWorkflow, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.request_id.is_none() {
                                self.request_id = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::input::CreateWorkflowInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/workflow").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateWorkflowInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_workflow(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("workflows-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateWorkflow::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateWorkflow", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateWorkflowInput`](crate::input::CreateWorkflowInput).
    pub fn builder() -> crate::input::create_workflow_input::Builder {
        crate::input::create_workflow_input::Builder::default()
    }
}

/// See [`DeleteAnnotationStoreInput`](crate::input::DeleteAnnotationStoreInput).
pub mod delete_annotation_store_input {
    
    /// A builder for [`DeleteAnnotationStoreInput`](crate::input::DeleteAnnotationStoreInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) force: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The store's name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The store's name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>Whether to force deletion.</p>
        pub fn force(mut self, input: bool) -> Self {
            self.force = Some(input);
            self
        }
        /// <p>Whether to force deletion.</p>
        pub fn set_force(mut self, input: std::option::Option<bool>) -> Self {
            self.force = input; self
        }
        /// Consumes the builder and constructs a [`DeleteAnnotationStoreInput`](crate::input::DeleteAnnotationStoreInput).
        pub fn build(self) -> Result<crate::input::DeleteAnnotationStoreInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteAnnotationStoreInput {
                    name: self.name
                    ,
                    force: self.force
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteAnnotationStoreInput {
    /// Consumes the builder and constructs an Operation<[`DeleteAnnotationStore`](crate::operation::DeleteAnnotationStore)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteAnnotationStore, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteAnnotationStoreInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_5 = &_input.name;
                let input_5 = input_5.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("name", "cannot be empty or unset"))?;
                let name = aws_smithy_http::label::fmt_string(input_5, aws_smithy_http::label::EncodingStrategy::Default);
                if name.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("name", "cannot be empty or unset"))
                            }
                write!(output, "/annotationStore/{name}", name = name).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::DeleteAnnotationStoreInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_6) = &_input.force {
                    if *inner_6 {
                        query.push_kv("force", aws_smithy_types::primitive::Encoder::from(*inner_6).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteAnnotationStoreInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("analytics-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteAnnotationStore::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteAnnotationStore", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteAnnotationStoreInput`](crate::input::DeleteAnnotationStoreInput).
    pub fn builder() -> crate::input::delete_annotation_store_input::Builder {
        crate::input::delete_annotation_store_input::Builder::default()
    }
}

/// See [`DeleteReferenceInput`](crate::input::DeleteReferenceInput).
pub mod delete_reference_input {
    
    /// A builder for [`DeleteReferenceInput`](crate::input::DeleteReferenceInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) reference_store_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The reference's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The reference's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// <p>The reference's store ID.</p>
        pub fn reference_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.reference_store_id = Some(input.into());
            self
        }
        /// <p>The reference's store ID.</p>
        pub fn set_reference_store_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.reference_store_id = input; self
        }
        /// Consumes the builder and constructs a [`DeleteReferenceInput`](crate::input::DeleteReferenceInput).
        pub fn build(self) -> Result<crate::input::DeleteReferenceInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteReferenceInput {
                    id: self.id
                    ,
                    reference_store_id: self.reference_store_id
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteReferenceInput {
    /// Consumes the builder and constructs an Operation<[`DeleteReference`](crate::operation::DeleteReference)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteReference, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteReferenceInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_7 = &_input.reference_store_id;
                let input_7 = input_7.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("reference_store_id", "cannot be empty or unset"))?;
                let reference_store_id = aws_smithy_http::label::fmt_string(input_7, aws_smithy_http::label::EncodingStrategy::Default);
                if reference_store_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("reference_store_id", "cannot be empty or unset"))
                            }
                let input_8 = &_input.id;
                let input_8 = input_8.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))?;
                let id = aws_smithy_http::label::fmt_string(input_8, aws_smithy_http::label::EncodingStrategy::Default);
                if id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))
                            }
                write!(output, "/referencestore/{referenceStoreId}/reference/{id}", referenceStoreId = reference_store_id, id = id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteReferenceInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("control-storage-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteReference::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteReference", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteReferenceInput`](crate::input::DeleteReferenceInput).
    pub fn builder() -> crate::input::delete_reference_input::Builder {
        crate::input::delete_reference_input::Builder::default()
    }
}

/// See [`DeleteReferenceStoreInput`](crate::input::DeleteReferenceStoreInput).
pub mod delete_reference_store_input {
    
    /// A builder for [`DeleteReferenceStoreInput`](crate::input::DeleteReferenceStoreInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The store's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The store's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// Consumes the builder and constructs a [`DeleteReferenceStoreInput`](crate::input::DeleteReferenceStoreInput).
        pub fn build(self) -> Result<crate::input::DeleteReferenceStoreInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteReferenceStoreInput {
                    id: self.id
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteReferenceStoreInput {
    /// Consumes the builder and constructs an Operation<[`DeleteReferenceStore`](crate::operation::DeleteReferenceStore)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteReferenceStore, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteReferenceStoreInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_9 = &_input.id;
                let input_9 = input_9.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))?;
                let id = aws_smithy_http::label::fmt_string(input_9, aws_smithy_http::label::EncodingStrategy::Default);
                if id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))
                            }
                write!(output, "/referencestore/{id}", id = id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteReferenceStoreInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("control-storage-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteReferenceStore::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteReferenceStore", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteReferenceStoreInput`](crate::input::DeleteReferenceStoreInput).
    pub fn builder() -> crate::input::delete_reference_store_input::Builder {
        crate::input::delete_reference_store_input::Builder::default()
    }
}

/// See [`DeleteRunInput`](crate::input::DeleteRunInput).
pub mod delete_run_input {
    
    /// A builder for [`DeleteRunInput`](crate::input::DeleteRunInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The run's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The run's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// Consumes the builder and constructs a [`DeleteRunInput`](crate::input::DeleteRunInput).
        pub fn build(self) -> Result<crate::input::DeleteRunInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteRunInput {
                    id: self.id
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteRunInput {
    /// Consumes the builder and constructs an Operation<[`DeleteRun`](crate::operation::DeleteRun)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteRun, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteRunInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_10 = &_input.id;
                let input_10 = input_10.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))?;
                let id = aws_smithy_http::label::fmt_string(input_10, aws_smithy_http::label::EncodingStrategy::Default);
                if id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))
                            }
                write!(output, "/run/{id}", id = id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteRunInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("workflows-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteRun::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteRun", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteRunInput`](crate::input::DeleteRunInput).
    pub fn builder() -> crate::input::delete_run_input::Builder {
        crate::input::delete_run_input::Builder::default()
    }
}

/// See [`DeleteRunGroupInput`](crate::input::DeleteRunGroupInput).
pub mod delete_run_group_input {
    
    /// A builder for [`DeleteRunGroupInput`](crate::input::DeleteRunGroupInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The run group's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The run group's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// Consumes the builder and constructs a [`DeleteRunGroupInput`](crate::input::DeleteRunGroupInput).
        pub fn build(self) -> Result<crate::input::DeleteRunGroupInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteRunGroupInput {
                    id: self.id
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteRunGroupInput {
    /// Consumes the builder and constructs an Operation<[`DeleteRunGroup`](crate::operation::DeleteRunGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteRunGroup, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteRunGroupInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_11 = &_input.id;
                let input_11 = input_11.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))?;
                let id = aws_smithy_http::label::fmt_string(input_11, aws_smithy_http::label::EncodingStrategy::Default);
                if id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))
                            }
                write!(output, "/runGroup/{id}", id = id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteRunGroupInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("workflows-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteRunGroup::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteRunGroup", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteRunGroupInput`](crate::input::DeleteRunGroupInput).
    pub fn builder() -> crate::input::delete_run_group_input::Builder {
        crate::input::delete_run_group_input::Builder::default()
    }
}

/// See [`DeleteSequenceStoreInput`](crate::input::DeleteSequenceStoreInput).
pub mod delete_sequence_store_input {
    
    /// A builder for [`DeleteSequenceStoreInput`](crate::input::DeleteSequenceStoreInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The sequence store's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The sequence store's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// Consumes the builder and constructs a [`DeleteSequenceStoreInput`](crate::input::DeleteSequenceStoreInput).
        pub fn build(self) -> Result<crate::input::DeleteSequenceStoreInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteSequenceStoreInput {
                    id: self.id
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteSequenceStoreInput {
    /// Consumes the builder and constructs an Operation<[`DeleteSequenceStore`](crate::operation::DeleteSequenceStore)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteSequenceStore, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteSequenceStoreInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_12 = &_input.id;
                let input_12 = input_12.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))?;
                let id = aws_smithy_http::label::fmt_string(input_12, aws_smithy_http::label::EncodingStrategy::Default);
                if id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))
                            }
                write!(output, "/sequencestore/{id}", id = id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteSequenceStoreInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("control-storage-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteSequenceStore::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteSequenceStore", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteSequenceStoreInput`](crate::input::DeleteSequenceStoreInput).
    pub fn builder() -> crate::input::delete_sequence_store_input::Builder {
        crate::input::delete_sequence_store_input::Builder::default()
    }
}

/// See [`DeleteVariantStoreInput`](crate::input::DeleteVariantStoreInput).
pub mod delete_variant_store_input {
    
    /// A builder for [`DeleteVariantStoreInput`](crate::input::DeleteVariantStoreInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) force: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The store's name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The store's name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>Whether to force deletion.</p>
        pub fn force(mut self, input: bool) -> Self {
            self.force = Some(input);
            self
        }
        /// <p>Whether to force deletion.</p>
        pub fn set_force(mut self, input: std::option::Option<bool>) -> Self {
            self.force = input; self
        }
        /// Consumes the builder and constructs a [`DeleteVariantStoreInput`](crate::input::DeleteVariantStoreInput).
        pub fn build(self) -> Result<crate::input::DeleteVariantStoreInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteVariantStoreInput {
                    name: self.name
                    ,
                    force: self.force
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteVariantStoreInput {
    /// Consumes the builder and constructs an Operation<[`DeleteVariantStore`](crate::operation::DeleteVariantStore)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteVariantStore, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteVariantStoreInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_13 = &_input.name;
                let input_13 = input_13.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("name", "cannot be empty or unset"))?;
                let name = aws_smithy_http::label::fmt_string(input_13, aws_smithy_http::label::EncodingStrategy::Default);
                if name.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("name", "cannot be empty or unset"))
                            }
                write!(output, "/variantStore/{name}", name = name).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::DeleteVariantStoreInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_14) = &_input.force {
                    if *inner_14 {
                        query.push_kv("force", aws_smithy_types::primitive::Encoder::from(*inner_14).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteVariantStoreInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("analytics-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteVariantStore::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteVariantStore", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteVariantStoreInput`](crate::input::DeleteVariantStoreInput).
    pub fn builder() -> crate::input::delete_variant_store_input::Builder {
        crate::input::delete_variant_store_input::Builder::default()
    }
}

/// See [`DeleteWorkflowInput`](crate::input::DeleteWorkflowInput).
pub mod delete_workflow_input {
    
    /// A builder for [`DeleteWorkflowInput`](crate::input::DeleteWorkflowInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The workflow's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The workflow's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// Consumes the builder and constructs a [`DeleteWorkflowInput`](crate::input::DeleteWorkflowInput).
        pub fn build(self) -> Result<crate::input::DeleteWorkflowInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteWorkflowInput {
                    id: self.id
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteWorkflowInput {
    /// Consumes the builder and constructs an Operation<[`DeleteWorkflow`](crate::operation::DeleteWorkflow)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteWorkflow, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteWorkflowInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_15 = &_input.id;
                let input_15 = input_15.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))?;
                let id = aws_smithy_http::label::fmt_string(input_15, aws_smithy_http::label::EncodingStrategy::Default);
                if id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))
                            }
                write!(output, "/workflow/{id}", id = id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteWorkflowInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("workflows-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteWorkflow::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteWorkflow", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteWorkflowInput`](crate::input::DeleteWorkflowInput).
    pub fn builder() -> crate::input::delete_workflow_input::Builder {
        crate::input::delete_workflow_input::Builder::default()
    }
}

/// See [`GetAnnotationImportJobInput`](crate::input::GetAnnotationImportJobInput).
pub mod get_annotation_import_job_input {
    
    /// A builder for [`GetAnnotationImportJobInput`](crate::input::GetAnnotationImportJobInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The job's ID.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The job's ID.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input; self
        }
        /// Consumes the builder and constructs a [`GetAnnotationImportJobInput`](crate::input::GetAnnotationImportJobInput).
        pub fn build(self) -> Result<crate::input::GetAnnotationImportJobInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetAnnotationImportJobInput {
                    job_id: self.job_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetAnnotationImportJobInput {
    /// Consumes the builder and constructs an Operation<[`GetAnnotationImportJob`](crate::operation::GetAnnotationImportJob)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetAnnotationImportJob, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetAnnotationImportJobInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_16 = &_input.job_id;
                let input_16 = input_16.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("job_id", "cannot be empty or unset"))?;
                let job_id = aws_smithy_http::label::fmt_string(input_16, aws_smithy_http::label::EncodingStrategy::Default);
                if job_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("job_id", "cannot be empty or unset"))
                            }
                write!(output, "/import/annotation/{jobId}", jobId = job_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetAnnotationImportJobInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("analytics-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetAnnotationImportJob::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetAnnotationImportJob", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetAnnotationImportJobInput`](crate::input::GetAnnotationImportJobInput).
    pub fn builder() -> crate::input::get_annotation_import_job_input::Builder {
        crate::input::get_annotation_import_job_input::Builder::default()
    }
}

/// See [`GetAnnotationStoreInput`](crate::input::GetAnnotationStoreInput).
pub mod get_annotation_store_input {
    
    /// A builder for [`GetAnnotationStoreInput`](crate::input::GetAnnotationStoreInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The store's name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The store's name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// Consumes the builder and constructs a [`GetAnnotationStoreInput`](crate::input::GetAnnotationStoreInput).
        pub fn build(self) -> Result<crate::input::GetAnnotationStoreInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetAnnotationStoreInput {
                    name: self.name
                    ,
                }
            )
        }
    }
    
    
}
impl GetAnnotationStoreInput {
    /// Consumes the builder and constructs an Operation<[`GetAnnotationStore`](crate::operation::GetAnnotationStore)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetAnnotationStore, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetAnnotationStoreInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_17 = &_input.name;
                let input_17 = input_17.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("name", "cannot be empty or unset"))?;
                let name = aws_smithy_http::label::fmt_string(input_17, aws_smithy_http::label::EncodingStrategy::Default);
                if name.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("name", "cannot be empty or unset"))
                            }
                write!(output, "/annotationStore/{name}", name = name).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetAnnotationStoreInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("analytics-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetAnnotationStore::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetAnnotationStore", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetAnnotationStoreInput`](crate::input::GetAnnotationStoreInput).
    pub fn builder() -> crate::input::get_annotation_store_input::Builder {
        crate::input::get_annotation_store_input::Builder::default()
    }
}

/// See [`GetReadSetInput`](crate::input::GetReadSetInput).
pub mod get_read_set_input {
    
    /// A builder for [`GetReadSetInput`](crate::input::GetReadSetInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) sequence_store_id: std::option::Option<std::string::String>,
        pub(crate) file: std::option::Option<crate::model::ReadSetFile>,
        pub(crate) part_number: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The read set's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The read set's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// <p>The read set's sequence store ID.</p>
        pub fn sequence_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sequence_store_id = Some(input.into());
            self
        }
        /// <p>The read set's sequence store ID.</p>
        pub fn set_sequence_store_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sequence_store_id = input; self
        }
        /// <p>The file to retrieve.</p>
        pub fn file(mut self, input: crate::model::ReadSetFile) -> Self {
            self.file = Some(input);
            self
        }
        /// <p>The file to retrieve.</p>
        pub fn set_file(mut self, input: std::option::Option<crate::model::ReadSetFile>) -> Self {
            self.file = input; self
        }
        /// <p>The part number to retrieve.</p>
        pub fn part_number(mut self, input: i32) -> Self {
            self.part_number = Some(input);
            self
        }
        /// <p>The part number to retrieve.</p>
        pub fn set_part_number(mut self, input: std::option::Option<i32>) -> Self {
            self.part_number = input; self
        }
        /// Consumes the builder and constructs a [`GetReadSetInput`](crate::input::GetReadSetInput).
        pub fn build(self) -> Result<crate::input::GetReadSetInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetReadSetInput {
                    id: self.id
                    ,
                    sequence_store_id: self.sequence_store_id
                    ,
                    file: self.file
                    ,
                    part_number: self.part_number
                    ,
                }
            )
        }
    }
    
    
}
impl GetReadSetInput {
    /// Consumes the builder and constructs an Operation<[`GetReadSet`](crate::operation::GetReadSet)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetReadSet, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetReadSetInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_18 = &_input.sequence_store_id;
                let input_18 = input_18.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("sequence_store_id", "cannot be empty or unset"))?;
                let sequence_store_id = aws_smithy_http::label::fmt_string(input_18, aws_smithy_http::label::EncodingStrategy::Default);
                if sequence_store_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("sequence_store_id", "cannot be empty or unset"))
                            }
                let input_19 = &_input.id;
                let input_19 = input_19.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))?;
                let id = aws_smithy_http::label::fmt_string(input_19, aws_smithy_http::label::EncodingStrategy::Default);
                if id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))
                            }
                write!(output, "/sequencestore/{sequenceStoreId}/readset/{id}", sequenceStoreId = sequence_store_id, id = id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::GetReadSetInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_20) = &_input.file {
                     {
                        query.push_kv("file", &aws_smithy_http::query::fmt_string(&inner_20));
                    }
                }
                let inner_21 = &_input.part_number;
                let inner_21 = inner_21.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("part_number", "cannot be empty or unset"))?;
                query.push_kv("partNumber", aws_smithy_types::primitive::Encoder::from(*inner_21).encode());
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetReadSetInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("storage-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetReadSet::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetReadSet", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetReadSetInput`](crate::input::GetReadSetInput).
    pub fn builder() -> crate::input::get_read_set_input::Builder {
        crate::input::get_read_set_input::Builder::default()
    }
}

/// See [`GetReadSetActivationJobInput`](crate::input::GetReadSetActivationJobInput).
pub mod get_read_set_activation_job_input {
    
    /// A builder for [`GetReadSetActivationJobInput`](crate::input::GetReadSetActivationJobInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) sequence_store_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The job's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The job's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// <p>The job's sequence store ID.</p>
        pub fn sequence_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sequence_store_id = Some(input.into());
            self
        }
        /// <p>The job's sequence store ID.</p>
        pub fn set_sequence_store_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sequence_store_id = input; self
        }
        /// Consumes the builder and constructs a [`GetReadSetActivationJobInput`](crate::input::GetReadSetActivationJobInput).
        pub fn build(self) -> Result<crate::input::GetReadSetActivationJobInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetReadSetActivationJobInput {
                    id: self.id
                    ,
                    sequence_store_id: self.sequence_store_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetReadSetActivationJobInput {
    /// Consumes the builder and constructs an Operation<[`GetReadSetActivationJob`](crate::operation::GetReadSetActivationJob)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetReadSetActivationJob, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetReadSetActivationJobInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_22 = &_input.sequence_store_id;
                let input_22 = input_22.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("sequence_store_id", "cannot be empty or unset"))?;
                let sequence_store_id = aws_smithy_http::label::fmt_string(input_22, aws_smithy_http::label::EncodingStrategy::Default);
                if sequence_store_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("sequence_store_id", "cannot be empty or unset"))
                            }
                let input_23 = &_input.id;
                let input_23 = input_23.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))?;
                let id = aws_smithy_http::label::fmt_string(input_23, aws_smithy_http::label::EncodingStrategy::Default);
                if id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))
                            }
                write!(output, "/sequencestore/{sequenceStoreId}/activationjob/{id}", sequenceStoreId = sequence_store_id, id = id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetReadSetActivationJobInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("control-storage-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetReadSetActivationJob::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetReadSetActivationJob", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetReadSetActivationJobInput`](crate::input::GetReadSetActivationJobInput).
    pub fn builder() -> crate::input::get_read_set_activation_job_input::Builder {
        crate::input::get_read_set_activation_job_input::Builder::default()
    }
}

/// See [`GetReadSetExportJobInput`](crate::input::GetReadSetExportJobInput).
pub mod get_read_set_export_job_input {
    
    /// A builder for [`GetReadSetExportJobInput`](crate::input::GetReadSetExportJobInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sequence_store_id: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The job's sequence store ID.</p>
        pub fn sequence_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sequence_store_id = Some(input.into());
            self
        }
        /// <p>The job's sequence store ID.</p>
        pub fn set_sequence_store_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sequence_store_id = input; self
        }
        /// <p>The job's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The job's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// Consumes the builder and constructs a [`GetReadSetExportJobInput`](crate::input::GetReadSetExportJobInput).
        pub fn build(self) -> Result<crate::input::GetReadSetExportJobInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetReadSetExportJobInput {
                    sequence_store_id: self.sequence_store_id
                    ,
                    id: self.id
                    ,
                }
            )
        }
    }
    
    
}
impl GetReadSetExportJobInput {
    /// Consumes the builder and constructs an Operation<[`GetReadSetExportJob`](crate::operation::GetReadSetExportJob)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetReadSetExportJob, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetReadSetExportJobInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_24 = &_input.sequence_store_id;
                let input_24 = input_24.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("sequence_store_id", "cannot be empty or unset"))?;
                let sequence_store_id = aws_smithy_http::label::fmt_string(input_24, aws_smithy_http::label::EncodingStrategy::Default);
                if sequence_store_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("sequence_store_id", "cannot be empty or unset"))
                            }
                let input_25 = &_input.id;
                let input_25 = input_25.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))?;
                let id = aws_smithy_http::label::fmt_string(input_25, aws_smithy_http::label::EncodingStrategy::Default);
                if id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))
                            }
                write!(output, "/sequencestore/{sequenceStoreId}/exportjob/{id}", sequenceStoreId = sequence_store_id, id = id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetReadSetExportJobInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("control-storage-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetReadSetExportJob::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetReadSetExportJob", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetReadSetExportJobInput`](crate::input::GetReadSetExportJobInput).
    pub fn builder() -> crate::input::get_read_set_export_job_input::Builder {
        crate::input::get_read_set_export_job_input::Builder::default()
    }
}

/// See [`GetReadSetImportJobInput`](crate::input::GetReadSetImportJobInput).
pub mod get_read_set_import_job_input {
    
    /// A builder for [`GetReadSetImportJobInput`](crate::input::GetReadSetImportJobInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) sequence_store_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The job's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The job's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// <p>The job's sequence store ID.</p>
        pub fn sequence_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sequence_store_id = Some(input.into());
            self
        }
        /// <p>The job's sequence store ID.</p>
        pub fn set_sequence_store_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sequence_store_id = input; self
        }
        /// Consumes the builder and constructs a [`GetReadSetImportJobInput`](crate::input::GetReadSetImportJobInput).
        pub fn build(self) -> Result<crate::input::GetReadSetImportJobInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetReadSetImportJobInput {
                    id: self.id
                    ,
                    sequence_store_id: self.sequence_store_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetReadSetImportJobInput {
    /// Consumes the builder and constructs an Operation<[`GetReadSetImportJob`](crate::operation::GetReadSetImportJob)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetReadSetImportJob, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetReadSetImportJobInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_26 = &_input.sequence_store_id;
                let input_26 = input_26.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("sequence_store_id", "cannot be empty or unset"))?;
                let sequence_store_id = aws_smithy_http::label::fmt_string(input_26, aws_smithy_http::label::EncodingStrategy::Default);
                if sequence_store_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("sequence_store_id", "cannot be empty or unset"))
                            }
                let input_27 = &_input.id;
                let input_27 = input_27.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))?;
                let id = aws_smithy_http::label::fmt_string(input_27, aws_smithy_http::label::EncodingStrategy::Default);
                if id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))
                            }
                write!(output, "/sequencestore/{sequenceStoreId}/importjob/{id}", sequenceStoreId = sequence_store_id, id = id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetReadSetImportJobInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("control-storage-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetReadSetImportJob::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetReadSetImportJob", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetReadSetImportJobInput`](crate::input::GetReadSetImportJobInput).
    pub fn builder() -> crate::input::get_read_set_import_job_input::Builder {
        crate::input::get_read_set_import_job_input::Builder::default()
    }
}

/// See [`GetReadSetMetadataInput`](crate::input::GetReadSetMetadataInput).
pub mod get_read_set_metadata_input {
    
    /// A builder for [`GetReadSetMetadataInput`](crate::input::GetReadSetMetadataInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) sequence_store_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The read set's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The read set's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// <p>The read set's sequence store ID.</p>
        pub fn sequence_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sequence_store_id = Some(input.into());
            self
        }
        /// <p>The read set's sequence store ID.</p>
        pub fn set_sequence_store_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sequence_store_id = input; self
        }
        /// Consumes the builder and constructs a [`GetReadSetMetadataInput`](crate::input::GetReadSetMetadataInput).
        pub fn build(self) -> Result<crate::input::GetReadSetMetadataInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetReadSetMetadataInput {
                    id: self.id
                    ,
                    sequence_store_id: self.sequence_store_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetReadSetMetadataInput {
    /// Consumes the builder and constructs an Operation<[`GetReadSetMetadata`](crate::operation::GetReadSetMetadata)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetReadSetMetadata, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetReadSetMetadataInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_28 = &_input.sequence_store_id;
                let input_28 = input_28.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("sequence_store_id", "cannot be empty or unset"))?;
                let sequence_store_id = aws_smithy_http::label::fmt_string(input_28, aws_smithy_http::label::EncodingStrategy::Default);
                if sequence_store_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("sequence_store_id", "cannot be empty or unset"))
                            }
                let input_29 = &_input.id;
                let input_29 = input_29.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))?;
                let id = aws_smithy_http::label::fmt_string(input_29, aws_smithy_http::label::EncodingStrategy::Default);
                if id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))
                            }
                write!(output, "/sequencestore/{sequenceStoreId}/readset/{id}/metadata", sequenceStoreId = sequence_store_id, id = id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetReadSetMetadataInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("control-storage-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetReadSetMetadata::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetReadSetMetadata", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetReadSetMetadataInput`](crate::input::GetReadSetMetadataInput).
    pub fn builder() -> crate::input::get_read_set_metadata_input::Builder {
        crate::input::get_read_set_metadata_input::Builder::default()
    }
}

/// See [`GetReferenceInput`](crate::input::GetReferenceInput).
pub mod get_reference_input {
    
    /// A builder for [`GetReferenceInput`](crate::input::GetReferenceInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) reference_store_id: std::option::Option<std::string::String>,
        pub(crate) range: std::option::Option<std::string::String>,
        pub(crate) part_number: std::option::Option<i32>,
        pub(crate) file: std::option::Option<crate::model::ReferenceFile>,
    }
    impl Builder {
        /// <p>The reference's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The reference's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// <p>The reference's store ID.</p>
        pub fn reference_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.reference_store_id = Some(input.into());
            self
        }
        /// <p>The reference's store ID.</p>
        pub fn set_reference_store_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.reference_store_id = input; self
        }
        /// <p>The range to retrieve.</p>
        pub fn range(mut self, input: impl Into<std::string::String>) -> Self {
            self.range = Some(input.into());
            self
        }
        /// <p>The range to retrieve.</p>
        pub fn set_range(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.range = input; self
        }
        /// <p>The part number to retrieve.</p>
        pub fn part_number(mut self, input: i32) -> Self {
            self.part_number = Some(input);
            self
        }
        /// <p>The part number to retrieve.</p>
        pub fn set_part_number(mut self, input: std::option::Option<i32>) -> Self {
            self.part_number = input; self
        }
        /// <p>The file to retrieve.</p>
        pub fn file(mut self, input: crate::model::ReferenceFile) -> Self {
            self.file = Some(input);
            self
        }
        /// <p>The file to retrieve.</p>
        pub fn set_file(mut self, input: std::option::Option<crate::model::ReferenceFile>) -> Self {
            self.file = input; self
        }
        /// Consumes the builder and constructs a [`GetReferenceInput`](crate::input::GetReferenceInput).
        pub fn build(self) -> Result<crate::input::GetReferenceInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetReferenceInput {
                    id: self.id
                    ,
                    reference_store_id: self.reference_store_id
                    ,
                    range: self.range
                    ,
                    part_number: self.part_number
                    ,
                    file: self.file
                    ,
                }
            )
        }
    }
    
    
}
impl GetReferenceInput {
    /// Consumes the builder and constructs an Operation<[`GetReference`](crate::operation::GetReference)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetReference, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetReferenceInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_30 = &_input.reference_store_id;
                let input_30 = input_30.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("reference_store_id", "cannot be empty or unset"))?;
                let reference_store_id = aws_smithy_http::label::fmt_string(input_30, aws_smithy_http::label::EncodingStrategy::Default);
                if reference_store_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("reference_store_id", "cannot be empty or unset"))
                            }
                let input_31 = &_input.id;
                let input_31 = input_31.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))?;
                let id = aws_smithy_http::label::fmt_string(input_31, aws_smithy_http::label::EncodingStrategy::Default);
                if id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))
                            }
                write!(output, "/referencestore/{referenceStoreId}/reference/{id}", referenceStoreId = reference_store_id, id = id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::GetReferenceInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_32 = &_input.part_number;
                let inner_32 = inner_32.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("part_number", "cannot be empty or unset"))?;
                query.push_kv("partNumber", aws_smithy_types::primitive::Encoder::from(*inner_32).encode());
                if let Some(inner_33) = &_input.file {
                     {
                        query.push_kv("file", &aws_smithy_http::query::fmt_string(&inner_33));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetReferenceInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_get_reference(input, builder)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("storage-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetReference::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetReference", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetReferenceInput`](crate::input::GetReferenceInput).
    pub fn builder() -> crate::input::get_reference_input::Builder {
        crate::input::get_reference_input::Builder::default()
    }
}

/// See [`GetReferenceImportJobInput`](crate::input::GetReferenceImportJobInput).
pub mod get_reference_import_job_input {
    
    /// A builder for [`GetReferenceImportJobInput`](crate::input::GetReferenceImportJobInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) reference_store_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The job's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The job's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// <p>The job's reference store ID.</p>
        pub fn reference_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.reference_store_id = Some(input.into());
            self
        }
        /// <p>The job's reference store ID.</p>
        pub fn set_reference_store_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.reference_store_id = input; self
        }
        /// Consumes the builder and constructs a [`GetReferenceImportJobInput`](crate::input::GetReferenceImportJobInput).
        pub fn build(self) -> Result<crate::input::GetReferenceImportJobInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetReferenceImportJobInput {
                    id: self.id
                    ,
                    reference_store_id: self.reference_store_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetReferenceImportJobInput {
    /// Consumes the builder and constructs an Operation<[`GetReferenceImportJob`](crate::operation::GetReferenceImportJob)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetReferenceImportJob, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetReferenceImportJobInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_34 = &_input.reference_store_id;
                let input_34 = input_34.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("reference_store_id", "cannot be empty or unset"))?;
                let reference_store_id = aws_smithy_http::label::fmt_string(input_34, aws_smithy_http::label::EncodingStrategy::Default);
                if reference_store_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("reference_store_id", "cannot be empty or unset"))
                            }
                let input_35 = &_input.id;
                let input_35 = input_35.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))?;
                let id = aws_smithy_http::label::fmt_string(input_35, aws_smithy_http::label::EncodingStrategy::Default);
                if id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))
                            }
                write!(output, "/referencestore/{referenceStoreId}/importjob/{id}", referenceStoreId = reference_store_id, id = id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetReferenceImportJobInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("control-storage-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetReferenceImportJob::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetReferenceImportJob", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetReferenceImportJobInput`](crate::input::GetReferenceImportJobInput).
    pub fn builder() -> crate::input::get_reference_import_job_input::Builder {
        crate::input::get_reference_import_job_input::Builder::default()
    }
}

/// See [`GetReferenceMetadataInput`](crate::input::GetReferenceMetadataInput).
pub mod get_reference_metadata_input {
    
    /// A builder for [`GetReferenceMetadataInput`](crate::input::GetReferenceMetadataInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) reference_store_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The reference's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The reference's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// <p>The reference's reference store ID.</p>
        pub fn reference_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.reference_store_id = Some(input.into());
            self
        }
        /// <p>The reference's reference store ID.</p>
        pub fn set_reference_store_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.reference_store_id = input; self
        }
        /// Consumes the builder and constructs a [`GetReferenceMetadataInput`](crate::input::GetReferenceMetadataInput).
        pub fn build(self) -> Result<crate::input::GetReferenceMetadataInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetReferenceMetadataInput {
                    id: self.id
                    ,
                    reference_store_id: self.reference_store_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetReferenceMetadataInput {
    /// Consumes the builder and constructs an Operation<[`GetReferenceMetadata`](crate::operation::GetReferenceMetadata)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetReferenceMetadata, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetReferenceMetadataInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_36 = &_input.reference_store_id;
                let input_36 = input_36.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("reference_store_id", "cannot be empty or unset"))?;
                let reference_store_id = aws_smithy_http::label::fmt_string(input_36, aws_smithy_http::label::EncodingStrategy::Default);
                if reference_store_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("reference_store_id", "cannot be empty or unset"))
                            }
                let input_37 = &_input.id;
                let input_37 = input_37.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))?;
                let id = aws_smithy_http::label::fmt_string(input_37, aws_smithy_http::label::EncodingStrategy::Default);
                if id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))
                            }
                write!(output, "/referencestore/{referenceStoreId}/reference/{id}/metadata", referenceStoreId = reference_store_id, id = id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetReferenceMetadataInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("control-storage-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetReferenceMetadata::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetReferenceMetadata", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetReferenceMetadataInput`](crate::input::GetReferenceMetadataInput).
    pub fn builder() -> crate::input::get_reference_metadata_input::Builder {
        crate::input::get_reference_metadata_input::Builder::default()
    }
}

/// See [`GetReferenceStoreInput`](crate::input::GetReferenceStoreInput).
pub mod get_reference_store_input {
    
    /// A builder for [`GetReferenceStoreInput`](crate::input::GetReferenceStoreInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The store's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The store's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// Consumes the builder and constructs a [`GetReferenceStoreInput`](crate::input::GetReferenceStoreInput).
        pub fn build(self) -> Result<crate::input::GetReferenceStoreInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetReferenceStoreInput {
                    id: self.id
                    ,
                }
            )
        }
    }
    
    
}
impl GetReferenceStoreInput {
    /// Consumes the builder and constructs an Operation<[`GetReferenceStore`](crate::operation::GetReferenceStore)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetReferenceStore, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetReferenceStoreInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_38 = &_input.id;
                let input_38 = input_38.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))?;
                let id = aws_smithy_http::label::fmt_string(input_38, aws_smithy_http::label::EncodingStrategy::Default);
                if id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))
                            }
                write!(output, "/referencestore/{id}", id = id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetReferenceStoreInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("control-storage-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetReferenceStore::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetReferenceStore", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetReferenceStoreInput`](crate::input::GetReferenceStoreInput).
    pub fn builder() -> crate::input::get_reference_store_input::Builder {
        crate::input::get_reference_store_input::Builder::default()
    }
}

/// See [`GetRunInput`](crate::input::GetRunInput).
pub mod get_run_input {
    
    /// A builder for [`GetRunInput`](crate::input::GetRunInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) export: std::option::Option<std::vec::Vec<crate::model::RunExport>>,
    }
    impl Builder {
        /// <p>The run's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The run's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// Appends an item to `export`.
        ///
        /// To override the contents of this collection use [`set_export`](Self::set_export).
        ///
        /// <p>The run's export format.</p>
        pub fn export(mut self, input: crate::model::RunExport) -> Self {
            let mut v = self.export.unwrap_or_default();
                            v.push(input);
                            self.export = Some(v);
                            self
        }
        /// <p>The run's export format.</p>
        pub fn set_export(mut self, input: std::option::Option<std::vec::Vec<crate::model::RunExport>>) -> Self {
            self.export = input; self
        }
        /// Consumes the builder and constructs a [`GetRunInput`](crate::input::GetRunInput).
        pub fn build(self) -> Result<crate::input::GetRunInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetRunInput {
                    id: self.id
                    ,
                    export: self.export
                    ,
                }
            )
        }
    }
    
    
}
impl GetRunInput {
    /// Consumes the builder and constructs an Operation<[`GetRun`](crate::operation::GetRun)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetRun, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetRunInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_39 = &_input.id;
                let input_39 = input_39.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))?;
                let id = aws_smithy_http::label::fmt_string(input_39, aws_smithy_http::label::EncodingStrategy::Default);
                if id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))
                            }
                write!(output, "/run/{id}", id = id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::GetRunInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_40) = &_input.export {
                     {
                        for inner_41 in inner_40 {
                            query.push_kv("export", &aws_smithy_http::query::fmt_string(&inner_41));
                        }
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetRunInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("workflows-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetRun::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetRun", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetRunInput`](crate::input::GetRunInput).
    pub fn builder() -> crate::input::get_run_input::Builder {
        crate::input::get_run_input::Builder::default()
    }
}

/// See [`GetRunGroupInput`](crate::input::GetRunGroupInput).
pub mod get_run_group_input {
    
    /// A builder for [`GetRunGroupInput`](crate::input::GetRunGroupInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The group's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The group's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// Consumes the builder and constructs a [`GetRunGroupInput`](crate::input::GetRunGroupInput).
        pub fn build(self) -> Result<crate::input::GetRunGroupInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetRunGroupInput {
                    id: self.id
                    ,
                }
            )
        }
    }
    
    
}
impl GetRunGroupInput {
    /// Consumes the builder and constructs an Operation<[`GetRunGroup`](crate::operation::GetRunGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetRunGroup, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetRunGroupInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_42 = &_input.id;
                let input_42 = input_42.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))?;
                let id = aws_smithy_http::label::fmt_string(input_42, aws_smithy_http::label::EncodingStrategy::Default);
                if id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))
                            }
                write!(output, "/runGroup/{id}", id = id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetRunGroupInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("workflows-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetRunGroup::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetRunGroup", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetRunGroupInput`](crate::input::GetRunGroupInput).
    pub fn builder() -> crate::input::get_run_group_input::Builder {
        crate::input::get_run_group_input::Builder::default()
    }
}

/// See [`GetRunTaskInput`](crate::input::GetRunTaskInput).
pub mod get_run_task_input {
    
    /// A builder for [`GetRunTaskInput`](crate::input::GetRunTaskInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) task_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The task's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The task's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// <p>The task's ID.</p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_id = Some(input.into());
            self
        }
        /// <p>The task's ID.</p>
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_id = input; self
        }
        /// Consumes the builder and constructs a [`GetRunTaskInput`](crate::input::GetRunTaskInput).
        pub fn build(self) -> Result<crate::input::GetRunTaskInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetRunTaskInput {
                    id: self.id
                    ,
                    task_id: self.task_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetRunTaskInput {
    /// Consumes the builder and constructs an Operation<[`GetRunTask`](crate::operation::GetRunTask)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetRunTask, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetRunTaskInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_43 = &_input.id;
                let input_43 = input_43.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))?;
                let id = aws_smithy_http::label::fmt_string(input_43, aws_smithy_http::label::EncodingStrategy::Default);
                if id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))
                            }
                let input_44 = &_input.task_id;
                let input_44 = input_44.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("task_id", "cannot be empty or unset"))?;
                let task_id = aws_smithy_http::label::fmt_string(input_44, aws_smithy_http::label::EncodingStrategy::Default);
                if task_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("task_id", "cannot be empty or unset"))
                            }
                write!(output, "/run/{id}/task/{taskId}", id = id, taskId = task_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetRunTaskInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("workflows-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetRunTask::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetRunTask", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetRunTaskInput`](crate::input::GetRunTaskInput).
    pub fn builder() -> crate::input::get_run_task_input::Builder {
        crate::input::get_run_task_input::Builder::default()
    }
}

/// See [`GetSequenceStoreInput`](crate::input::GetSequenceStoreInput).
pub mod get_sequence_store_input {
    
    /// A builder for [`GetSequenceStoreInput`](crate::input::GetSequenceStoreInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The store's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The store's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// Consumes the builder and constructs a [`GetSequenceStoreInput`](crate::input::GetSequenceStoreInput).
        pub fn build(self) -> Result<crate::input::GetSequenceStoreInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetSequenceStoreInput {
                    id: self.id
                    ,
                }
            )
        }
    }
    
    
}
impl GetSequenceStoreInput {
    /// Consumes the builder and constructs an Operation<[`GetSequenceStore`](crate::operation::GetSequenceStore)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetSequenceStore, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetSequenceStoreInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_45 = &_input.id;
                let input_45 = input_45.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))?;
                let id = aws_smithy_http::label::fmt_string(input_45, aws_smithy_http::label::EncodingStrategy::Default);
                if id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))
                            }
                write!(output, "/sequencestore/{id}", id = id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetSequenceStoreInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("control-storage-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetSequenceStore::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetSequenceStore", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetSequenceStoreInput`](crate::input::GetSequenceStoreInput).
    pub fn builder() -> crate::input::get_sequence_store_input::Builder {
        crate::input::get_sequence_store_input::Builder::default()
    }
}

/// See [`GetVariantImportJobInput`](crate::input::GetVariantImportJobInput).
pub mod get_variant_import_job_input {
    
    /// A builder for [`GetVariantImportJobInput`](crate::input::GetVariantImportJobInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The job's ID.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The job's ID.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input; self
        }
        /// Consumes the builder and constructs a [`GetVariantImportJobInput`](crate::input::GetVariantImportJobInput).
        pub fn build(self) -> Result<crate::input::GetVariantImportJobInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetVariantImportJobInput {
                    job_id: self.job_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetVariantImportJobInput {
    /// Consumes the builder and constructs an Operation<[`GetVariantImportJob`](crate::operation::GetVariantImportJob)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetVariantImportJob, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetVariantImportJobInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_46 = &_input.job_id;
                let input_46 = input_46.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("job_id", "cannot be empty or unset"))?;
                let job_id = aws_smithy_http::label::fmt_string(input_46, aws_smithy_http::label::EncodingStrategy::Default);
                if job_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("job_id", "cannot be empty or unset"))
                            }
                write!(output, "/import/variant/{jobId}", jobId = job_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetVariantImportJobInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("analytics-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetVariantImportJob::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetVariantImportJob", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetVariantImportJobInput`](crate::input::GetVariantImportJobInput).
    pub fn builder() -> crate::input::get_variant_import_job_input::Builder {
        crate::input::get_variant_import_job_input::Builder::default()
    }
}

/// See [`GetVariantStoreInput`](crate::input::GetVariantStoreInput).
pub mod get_variant_store_input {
    
    /// A builder for [`GetVariantStoreInput`](crate::input::GetVariantStoreInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The store's name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The store's name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// Consumes the builder and constructs a [`GetVariantStoreInput`](crate::input::GetVariantStoreInput).
        pub fn build(self) -> Result<crate::input::GetVariantStoreInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetVariantStoreInput {
                    name: self.name
                    ,
                }
            )
        }
    }
    
    
}
impl GetVariantStoreInput {
    /// Consumes the builder and constructs an Operation<[`GetVariantStore`](crate::operation::GetVariantStore)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetVariantStore, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetVariantStoreInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_47 = &_input.name;
                let input_47 = input_47.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("name", "cannot be empty or unset"))?;
                let name = aws_smithy_http::label::fmt_string(input_47, aws_smithy_http::label::EncodingStrategy::Default);
                if name.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("name", "cannot be empty or unset"))
                            }
                write!(output, "/variantStore/{name}", name = name).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetVariantStoreInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("analytics-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetVariantStore::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetVariantStore", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetVariantStoreInput`](crate::input::GetVariantStoreInput).
    pub fn builder() -> crate::input::get_variant_store_input::Builder {
        crate::input::get_variant_store_input::Builder::default()
    }
}

/// See [`GetWorkflowInput`](crate::input::GetWorkflowInput).
pub mod get_workflow_input {
    
    /// A builder for [`GetWorkflowInput`](crate::input::GetWorkflowInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::WorkflowType>,
        pub(crate) export: std::option::Option<std::vec::Vec<crate::model::WorkflowExport>>,
    }
    impl Builder {
        /// <p>The workflow's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The workflow's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// <p>The workflow's type.</p>
        pub fn r#type(mut self, input: crate::model::WorkflowType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The workflow's type.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::WorkflowType>) -> Self {
            self.r#type = input; self
        }
        /// Appends an item to `export`.
        ///
        /// To override the contents of this collection use [`set_export`](Self::set_export).
        ///
        /// <p>The export format for the workflow.</p>
        pub fn export(mut self, input: crate::model::WorkflowExport) -> Self {
            let mut v = self.export.unwrap_or_default();
                            v.push(input);
                            self.export = Some(v);
                            self
        }
        /// <p>The export format for the workflow.</p>
        pub fn set_export(mut self, input: std::option::Option<std::vec::Vec<crate::model::WorkflowExport>>) -> Self {
            self.export = input; self
        }
        /// Consumes the builder and constructs a [`GetWorkflowInput`](crate::input::GetWorkflowInput).
        pub fn build(self) -> Result<crate::input::GetWorkflowInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetWorkflowInput {
                    id: self.id
                    ,
                    r#type: self.r#type
                    ,
                    export: self.export
                    ,
                }
            )
        }
    }
    
    
}
impl GetWorkflowInput {
    /// Consumes the builder and constructs an Operation<[`GetWorkflow`](crate::operation::GetWorkflow)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetWorkflow, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetWorkflowInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_48 = &_input.id;
                let input_48 = input_48.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))?;
                let id = aws_smithy_http::label::fmt_string(input_48, aws_smithy_http::label::EncodingStrategy::Default);
                if id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))
                            }
                write!(output, "/workflow/{id}", id = id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::GetWorkflowInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_49) = &_input.r#type {
                     {
                        query.push_kv("type", &aws_smithy_http::query::fmt_string(&inner_49));
                    }
                }
                if let Some(inner_50) = &_input.export {
                     {
                        for inner_51 in inner_50 {
                            query.push_kv("export", &aws_smithy_http::query::fmt_string(&inner_51));
                        }
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetWorkflowInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("workflows-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetWorkflow::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetWorkflow", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetWorkflowInput`](crate::input::GetWorkflowInput).
    pub fn builder() -> crate::input::get_workflow_input::Builder {
        crate::input::get_workflow_input::Builder::default()
    }
}

/// See [`ListAnnotationImportJobsInput`](crate::input::ListAnnotationImportJobsInput).
pub mod list_annotation_import_jobs_input {
    
    /// A builder for [`ListAnnotationImportJobsInput`](crate::input::ListAnnotationImportJobsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) filter: std::option::Option<crate::model::ListAnnotationImportJobsFilter>,
    }
    impl Builder {
        /// <p>The maximum number of jobs to return in one page of results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of jobs to return in one page of results.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Appends an item to `ids`.
        ///
        /// To override the contents of this collection use [`set_ids`](Self::set_ids).
        ///
        /// <p>IDs of annotation import jobs to retrieve.</p>
        pub fn ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.ids.unwrap_or_default();
                            v.push(input.into());
                            self.ids = Some(v);
                            self
        }
        /// <p>IDs of annotation import jobs to retrieve.</p>
        pub fn set_ids(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.ids = input; self
        }
        /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>A filter to apply to the list.</p>
        pub fn filter(mut self, input: crate::model::ListAnnotationImportJobsFilter) -> Self {
            self.filter = Some(input);
            self
        }
        /// <p>A filter to apply to the list.</p>
        pub fn set_filter(mut self, input: std::option::Option<crate::model::ListAnnotationImportJobsFilter>) -> Self {
            self.filter = input; self
        }
        /// Consumes the builder and constructs a [`ListAnnotationImportJobsInput`](crate::input::ListAnnotationImportJobsInput).
        pub fn build(self) -> Result<crate::input::ListAnnotationImportJobsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListAnnotationImportJobsInput {
                    max_results: self.max_results
                    ,
                    ids: self.ids
                    ,
                    next_token: self.next_token
                    ,
                    filter: self.filter
                    ,
                }
            )
        }
    }
    
    
}
impl ListAnnotationImportJobsInput {
    /// Consumes the builder and constructs an Operation<[`ListAnnotationImportJobs`](crate::operation::ListAnnotationImportJobs)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListAnnotationImportJobs, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListAnnotationImportJobsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/import/annotations").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListAnnotationImportJobsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_52) = &_input.max_results {
                    if *inner_52 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_52).encode());
                    }
                }
                if let Some(inner_53) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_53));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListAnnotationImportJobsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_list_annotation_import_jobs(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("analytics-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListAnnotationImportJobs::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListAnnotationImportJobs", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListAnnotationImportJobsInput`](crate::input::ListAnnotationImportJobsInput).
    pub fn builder() -> crate::input::list_annotation_import_jobs_input::Builder {
        crate::input::list_annotation_import_jobs_input::Builder::default()
    }
}

/// See [`ListAnnotationStoresInput`](crate::input::ListAnnotationStoresInput).
pub mod list_annotation_stores_input {
    
    /// A builder for [`ListAnnotationStoresInput`](crate::input::ListAnnotationStoresInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) filter: std::option::Option<crate::model::ListAnnotationStoresFilter>,
    }
    impl Builder {
        /// Appends an item to `ids`.
        ///
        /// To override the contents of this collection use [`set_ids`](Self::set_ids).
        ///
        /// <p>IDs of stores to list.</p>
        pub fn ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.ids.unwrap_or_default();
                            v.push(input.into());
                            self.ids = Some(v);
                            self
        }
        /// <p>IDs of stores to list.</p>
        pub fn set_ids(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.ids = input; self
        }
        /// <p>The maximum number of stores to return in one page of results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of stores to return in one page of results.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>A filter to apply to the list.</p>
        pub fn filter(mut self, input: crate::model::ListAnnotationStoresFilter) -> Self {
            self.filter = Some(input);
            self
        }
        /// <p>A filter to apply to the list.</p>
        pub fn set_filter(mut self, input: std::option::Option<crate::model::ListAnnotationStoresFilter>) -> Self {
            self.filter = input; self
        }
        /// Consumes the builder and constructs a [`ListAnnotationStoresInput`](crate::input::ListAnnotationStoresInput).
        pub fn build(self) -> Result<crate::input::ListAnnotationStoresInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListAnnotationStoresInput {
                    ids: self.ids
                    ,
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                    filter: self.filter
                    ,
                }
            )
        }
    }
    
    
}
impl ListAnnotationStoresInput {
    /// Consumes the builder and constructs an Operation<[`ListAnnotationStores`](crate::operation::ListAnnotationStores)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListAnnotationStores, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListAnnotationStoresInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/annotationStores").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListAnnotationStoresInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_54) = &_input.max_results {
                    if *inner_54 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_54).encode());
                    }
                }
                if let Some(inner_55) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_55));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListAnnotationStoresInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_list_annotation_stores(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("analytics-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListAnnotationStores::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListAnnotationStores", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListAnnotationStoresInput`](crate::input::ListAnnotationStoresInput).
    pub fn builder() -> crate::input::list_annotation_stores_input::Builder {
        crate::input::list_annotation_stores_input::Builder::default()
    }
}

/// See [`ListReadSetActivationJobsInput`](crate::input::ListReadSetActivationJobsInput).
pub mod list_read_set_activation_jobs_input {
    
    /// A builder for [`ListReadSetActivationJobsInput`](crate::input::ListReadSetActivationJobsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sequence_store_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) filter: std::option::Option<crate::model::ActivateReadSetFilter>,
    }
    impl Builder {
        /// <p>The read set's sequence store ID.</p>
        pub fn sequence_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sequence_store_id = Some(input.into());
            self
        }
        /// <p>The read set's sequence store ID.</p>
        pub fn set_sequence_store_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sequence_store_id = input; self
        }
        /// <p>The maximum number of read set activation jobs to return in one page of results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of read set activation jobs to return in one page of results.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>A filter to apply to the list.</p>
        pub fn filter(mut self, input: crate::model::ActivateReadSetFilter) -> Self {
            self.filter = Some(input);
            self
        }
        /// <p>A filter to apply to the list.</p>
        pub fn set_filter(mut self, input: std::option::Option<crate::model::ActivateReadSetFilter>) -> Self {
            self.filter = input; self
        }
        /// Consumes the builder and constructs a [`ListReadSetActivationJobsInput`](crate::input::ListReadSetActivationJobsInput).
        pub fn build(self) -> Result<crate::input::ListReadSetActivationJobsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListReadSetActivationJobsInput {
                    sequence_store_id: self.sequence_store_id
                    ,
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                    filter: self.filter
                    ,
                }
            )
        }
    }
    
    
}
impl ListReadSetActivationJobsInput {
    /// Consumes the builder and constructs an Operation<[`ListReadSetActivationJobs`](crate::operation::ListReadSetActivationJobs)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListReadSetActivationJobs, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListReadSetActivationJobsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_56 = &_input.sequence_store_id;
                let input_56 = input_56.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("sequence_store_id", "cannot be empty or unset"))?;
                let sequence_store_id = aws_smithy_http::label::fmt_string(input_56, aws_smithy_http::label::EncodingStrategy::Default);
                if sequence_store_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("sequence_store_id", "cannot be empty or unset"))
                            }
                write!(output, "/sequencestore/{sequenceStoreId}/activationjobs", sequenceStoreId = sequence_store_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListReadSetActivationJobsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_57) = &_input.max_results {
                    if *inner_57 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_57).encode());
                    }
                }
                if let Some(inner_58) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_58));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListReadSetActivationJobsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_list_read_set_activation_jobs(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("control-storage-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListReadSetActivationJobs::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListReadSetActivationJobs", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListReadSetActivationJobsInput`](crate::input::ListReadSetActivationJobsInput).
    pub fn builder() -> crate::input::list_read_set_activation_jobs_input::Builder {
        crate::input::list_read_set_activation_jobs_input::Builder::default()
    }
}

/// See [`ListReadSetExportJobsInput`](crate::input::ListReadSetExportJobsInput).
pub mod list_read_set_export_jobs_input {
    
    /// A builder for [`ListReadSetExportJobsInput`](crate::input::ListReadSetExportJobsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sequence_store_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) filter: std::option::Option<crate::model::ExportReadSetFilter>,
    }
    impl Builder {
        /// <p>The jobs' sequence store ID.</p>
        pub fn sequence_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sequence_store_id = Some(input.into());
            self
        }
        /// <p>The jobs' sequence store ID.</p>
        pub fn set_sequence_store_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sequence_store_id = input; self
        }
        /// <p>The maximum number of jobs to return in one page of results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of jobs to return in one page of results.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>A filter to apply to the list.</p>
        pub fn filter(mut self, input: crate::model::ExportReadSetFilter) -> Self {
            self.filter = Some(input);
            self
        }
        /// <p>A filter to apply to the list.</p>
        pub fn set_filter(mut self, input: std::option::Option<crate::model::ExportReadSetFilter>) -> Self {
            self.filter = input; self
        }
        /// Consumes the builder and constructs a [`ListReadSetExportJobsInput`](crate::input::ListReadSetExportJobsInput).
        pub fn build(self) -> Result<crate::input::ListReadSetExportJobsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListReadSetExportJobsInput {
                    sequence_store_id: self.sequence_store_id
                    ,
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                    filter: self.filter
                    ,
                }
            )
        }
    }
    
    
}
impl ListReadSetExportJobsInput {
    /// Consumes the builder and constructs an Operation<[`ListReadSetExportJobs`](crate::operation::ListReadSetExportJobs)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListReadSetExportJobs, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListReadSetExportJobsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_59 = &_input.sequence_store_id;
                let input_59 = input_59.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("sequence_store_id", "cannot be empty or unset"))?;
                let sequence_store_id = aws_smithy_http::label::fmt_string(input_59, aws_smithy_http::label::EncodingStrategy::Default);
                if sequence_store_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("sequence_store_id", "cannot be empty or unset"))
                            }
                write!(output, "/sequencestore/{sequenceStoreId}/exportjobs", sequenceStoreId = sequence_store_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListReadSetExportJobsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_60) = &_input.max_results {
                    if *inner_60 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_60).encode());
                    }
                }
                if let Some(inner_61) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_61));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListReadSetExportJobsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_list_read_set_export_jobs(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("control-storage-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListReadSetExportJobs::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListReadSetExportJobs", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListReadSetExportJobsInput`](crate::input::ListReadSetExportJobsInput).
    pub fn builder() -> crate::input::list_read_set_export_jobs_input::Builder {
        crate::input::list_read_set_export_jobs_input::Builder::default()
    }
}

/// See [`ListReadSetImportJobsInput`](crate::input::ListReadSetImportJobsInput).
pub mod list_read_set_import_jobs_input {
    
    /// A builder for [`ListReadSetImportJobsInput`](crate::input::ListReadSetImportJobsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) sequence_store_id: std::option::Option<std::string::String>,
        pub(crate) filter: std::option::Option<crate::model::ImportReadSetFilter>,
    }
    impl Builder {
        /// <p>The maximum number of jobs to return in one page of results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of jobs to return in one page of results.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>The jobs' sequence store ID.</p>
        pub fn sequence_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sequence_store_id = Some(input.into());
            self
        }
        /// <p>The jobs' sequence store ID.</p>
        pub fn set_sequence_store_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sequence_store_id = input; self
        }
        /// <p>A filter to apply to the list.</p>
        pub fn filter(mut self, input: crate::model::ImportReadSetFilter) -> Self {
            self.filter = Some(input);
            self
        }
        /// <p>A filter to apply to the list.</p>
        pub fn set_filter(mut self, input: std::option::Option<crate::model::ImportReadSetFilter>) -> Self {
            self.filter = input; self
        }
        /// Consumes the builder and constructs a [`ListReadSetImportJobsInput`](crate::input::ListReadSetImportJobsInput).
        pub fn build(self) -> Result<crate::input::ListReadSetImportJobsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListReadSetImportJobsInput {
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                    sequence_store_id: self.sequence_store_id
                    ,
                    filter: self.filter
                    ,
                }
            )
        }
    }
    
    
}
impl ListReadSetImportJobsInput {
    /// Consumes the builder and constructs an Operation<[`ListReadSetImportJobs`](crate::operation::ListReadSetImportJobs)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListReadSetImportJobs, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListReadSetImportJobsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_62 = &_input.sequence_store_id;
                let input_62 = input_62.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("sequence_store_id", "cannot be empty or unset"))?;
                let sequence_store_id = aws_smithy_http::label::fmt_string(input_62, aws_smithy_http::label::EncodingStrategy::Default);
                if sequence_store_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("sequence_store_id", "cannot be empty or unset"))
                            }
                write!(output, "/sequencestore/{sequenceStoreId}/importjobs", sequenceStoreId = sequence_store_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListReadSetImportJobsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_63) = &_input.max_results {
                    if *inner_63 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_63).encode());
                    }
                }
                if let Some(inner_64) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_64));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListReadSetImportJobsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_list_read_set_import_jobs(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("control-storage-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListReadSetImportJobs::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListReadSetImportJobs", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListReadSetImportJobsInput`](crate::input::ListReadSetImportJobsInput).
    pub fn builder() -> crate::input::list_read_set_import_jobs_input::Builder {
        crate::input::list_read_set_import_jobs_input::Builder::default()
    }
}

/// See [`ListReadSetsInput`](crate::input::ListReadSetsInput).
pub mod list_read_sets_input {
    
    /// A builder for [`ListReadSetsInput`](crate::input::ListReadSetsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sequence_store_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) filter: std::option::Option<crate::model::ReadSetFilter>,
    }
    impl Builder {
        /// <p>The jobs' sequence store ID.</p>
        pub fn sequence_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sequence_store_id = Some(input.into());
            self
        }
        /// <p>The jobs' sequence store ID.</p>
        pub fn set_sequence_store_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sequence_store_id = input; self
        }
        /// <p>The maximum number of read sets to return in one page of results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of read sets to return in one page of results.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>A filter to apply to the list.</p>
        pub fn filter(mut self, input: crate::model::ReadSetFilter) -> Self {
            self.filter = Some(input);
            self
        }
        /// <p>A filter to apply to the list.</p>
        pub fn set_filter(mut self, input: std::option::Option<crate::model::ReadSetFilter>) -> Self {
            self.filter = input; self
        }
        /// Consumes the builder and constructs a [`ListReadSetsInput`](crate::input::ListReadSetsInput).
        pub fn build(self) -> Result<crate::input::ListReadSetsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListReadSetsInput {
                    sequence_store_id: self.sequence_store_id
                    ,
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                    filter: self.filter
                    ,
                }
            )
        }
    }
    
    
}
impl ListReadSetsInput {
    /// Consumes the builder and constructs an Operation<[`ListReadSets`](crate::operation::ListReadSets)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListReadSets, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListReadSetsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_65 = &_input.sequence_store_id;
                let input_65 = input_65.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("sequence_store_id", "cannot be empty or unset"))?;
                let sequence_store_id = aws_smithy_http::label::fmt_string(input_65, aws_smithy_http::label::EncodingStrategy::Default);
                if sequence_store_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("sequence_store_id", "cannot be empty or unset"))
                            }
                write!(output, "/sequencestore/{sequenceStoreId}/readsets", sequenceStoreId = sequence_store_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListReadSetsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_66) = &_input.max_results {
                    if *inner_66 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_66).encode());
                    }
                }
                if let Some(inner_67) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_67));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListReadSetsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_list_read_sets(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("control-storage-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListReadSets::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListReadSets", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListReadSetsInput`](crate::input::ListReadSetsInput).
    pub fn builder() -> crate::input::list_read_sets_input::Builder {
        crate::input::list_read_sets_input::Builder::default()
    }
}

/// See [`ListReferenceImportJobsInput`](crate::input::ListReferenceImportJobsInput).
pub mod list_reference_import_jobs_input {
    
    /// A builder for [`ListReferenceImportJobsInput`](crate::input::ListReferenceImportJobsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) reference_store_id: std::option::Option<std::string::String>,
        pub(crate) filter: std::option::Option<crate::model::ImportReferenceFilter>,
    }
    impl Builder {
        /// <p>The maximum number of jobs to return in one page of results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of jobs to return in one page of results.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>The job's reference store ID.</p>
        pub fn reference_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.reference_store_id = Some(input.into());
            self
        }
        /// <p>The job's reference store ID.</p>
        pub fn set_reference_store_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.reference_store_id = input; self
        }
        /// <p>A filter to apply to the list.</p>
        pub fn filter(mut self, input: crate::model::ImportReferenceFilter) -> Self {
            self.filter = Some(input);
            self
        }
        /// <p>A filter to apply to the list.</p>
        pub fn set_filter(mut self, input: std::option::Option<crate::model::ImportReferenceFilter>) -> Self {
            self.filter = input; self
        }
        /// Consumes the builder and constructs a [`ListReferenceImportJobsInput`](crate::input::ListReferenceImportJobsInput).
        pub fn build(self) -> Result<crate::input::ListReferenceImportJobsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListReferenceImportJobsInput {
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                    reference_store_id: self.reference_store_id
                    ,
                    filter: self.filter
                    ,
                }
            )
        }
    }
    
    
}
impl ListReferenceImportJobsInput {
    /// Consumes the builder and constructs an Operation<[`ListReferenceImportJobs`](crate::operation::ListReferenceImportJobs)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListReferenceImportJobs, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListReferenceImportJobsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_68 = &_input.reference_store_id;
                let input_68 = input_68.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("reference_store_id", "cannot be empty or unset"))?;
                let reference_store_id = aws_smithy_http::label::fmt_string(input_68, aws_smithy_http::label::EncodingStrategy::Default);
                if reference_store_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("reference_store_id", "cannot be empty or unset"))
                            }
                write!(output, "/referencestore/{referenceStoreId}/importjobs", referenceStoreId = reference_store_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListReferenceImportJobsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_69) = &_input.max_results {
                    if *inner_69 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_69).encode());
                    }
                }
                if let Some(inner_70) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_70));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListReferenceImportJobsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_list_reference_import_jobs(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("control-storage-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListReferenceImportJobs::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListReferenceImportJobs", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListReferenceImportJobsInput`](crate::input::ListReferenceImportJobsInput).
    pub fn builder() -> crate::input::list_reference_import_jobs_input::Builder {
        crate::input::list_reference_import_jobs_input::Builder::default()
    }
}

/// See [`ListReferencesInput`](crate::input::ListReferencesInput).
pub mod list_references_input {
    
    /// A builder for [`ListReferencesInput`](crate::input::ListReferencesInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) reference_store_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) filter: std::option::Option<crate::model::ReferenceFilter>,
    }
    impl Builder {
        /// <p>The references' reference store ID.</p>
        pub fn reference_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.reference_store_id = Some(input.into());
            self
        }
        /// <p>The references' reference store ID.</p>
        pub fn set_reference_store_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.reference_store_id = input; self
        }
        /// <p>The maximum number of references to return in one page of results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of references to return in one page of results.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>A filter to apply to the list.</p>
        pub fn filter(mut self, input: crate::model::ReferenceFilter) -> Self {
            self.filter = Some(input);
            self
        }
        /// <p>A filter to apply to the list.</p>
        pub fn set_filter(mut self, input: std::option::Option<crate::model::ReferenceFilter>) -> Self {
            self.filter = input; self
        }
        /// Consumes the builder and constructs a [`ListReferencesInput`](crate::input::ListReferencesInput).
        pub fn build(self) -> Result<crate::input::ListReferencesInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListReferencesInput {
                    reference_store_id: self.reference_store_id
                    ,
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                    filter: self.filter
                    ,
                }
            )
        }
    }
    
    
}
impl ListReferencesInput {
    /// Consumes the builder and constructs an Operation<[`ListReferences`](crate::operation::ListReferences)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListReferences, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListReferencesInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_71 = &_input.reference_store_id;
                let input_71 = input_71.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("reference_store_id", "cannot be empty or unset"))?;
                let reference_store_id = aws_smithy_http::label::fmt_string(input_71, aws_smithy_http::label::EncodingStrategy::Default);
                if reference_store_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("reference_store_id", "cannot be empty or unset"))
                            }
                write!(output, "/referencestore/{referenceStoreId}/references", referenceStoreId = reference_store_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListReferencesInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_72) = &_input.max_results {
                    if *inner_72 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_72).encode());
                    }
                }
                if let Some(inner_73) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_73));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListReferencesInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_list_references(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("control-storage-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListReferences::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListReferences", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListReferencesInput`](crate::input::ListReferencesInput).
    pub fn builder() -> crate::input::list_references_input::Builder {
        crate::input::list_references_input::Builder::default()
    }
}

/// See [`ListReferenceStoresInput`](crate::input::ListReferenceStoresInput).
pub mod list_reference_stores_input {
    
    /// A builder for [`ListReferenceStoresInput`](crate::input::ListReferenceStoresInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) filter: std::option::Option<crate::model::ReferenceStoreFilter>,
    }
    impl Builder {
        /// <p>The maximum number of stores to return in one page of results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of stores to return in one page of results.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>A filter to apply to the list.</p>
        pub fn filter(mut self, input: crate::model::ReferenceStoreFilter) -> Self {
            self.filter = Some(input);
            self
        }
        /// <p>A filter to apply to the list.</p>
        pub fn set_filter(mut self, input: std::option::Option<crate::model::ReferenceStoreFilter>) -> Self {
            self.filter = input; self
        }
        /// Consumes the builder and constructs a [`ListReferenceStoresInput`](crate::input::ListReferenceStoresInput).
        pub fn build(self) -> Result<crate::input::ListReferenceStoresInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListReferenceStoresInput {
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                    filter: self.filter
                    ,
                }
            )
        }
    }
    
    
}
impl ListReferenceStoresInput {
    /// Consumes the builder and constructs an Operation<[`ListReferenceStores`](crate::operation::ListReferenceStores)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListReferenceStores, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListReferenceStoresInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/referencestores").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListReferenceStoresInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_74) = &_input.max_results {
                    if *inner_74 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_74).encode());
                    }
                }
                if let Some(inner_75) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_75));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListReferenceStoresInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_list_reference_stores(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("control-storage-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListReferenceStores::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListReferenceStores", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListReferenceStoresInput`](crate::input::ListReferenceStoresInput).
    pub fn builder() -> crate::input::list_reference_stores_input::Builder {
        crate::input::list_reference_stores_input::Builder::default()
    }
}

/// See [`ListRunGroupsInput`](crate::input::ListRunGroupsInput).
pub mod list_run_groups_input {
    
    /// A builder for [`ListRunGroupsInput`](crate::input::ListRunGroupsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) starting_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The run groups' name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The run groups' name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
        pub fn starting_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.starting_token = Some(input.into());
            self
        }
        /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
        pub fn set_starting_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.starting_token = input; self
        }
        /// <p>The maximum number of run groups to return in one page of results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of run groups to return in one page of results.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`ListRunGroupsInput`](crate::input::ListRunGroupsInput).
        pub fn build(self) -> Result<crate::input::ListRunGroupsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListRunGroupsInput {
                    name: self.name
                    ,
                    starting_token: self.starting_token
                    ,
                    max_results: self.max_results
                    ,
                }
            )
        }
    }
    
    
}
impl ListRunGroupsInput {
    /// Consumes the builder and constructs an Operation<[`ListRunGroups`](crate::operation::ListRunGroups)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListRunGroups, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListRunGroupsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/runGroup").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListRunGroupsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_76) = &_input.name {
                     {
                        query.push_kv("name", &aws_smithy_http::query::fmt_string(&inner_76));
                    }
                }
                if let Some(inner_77) = &_input.starting_token {
                     {
                        query.push_kv("startingToken", &aws_smithy_http::query::fmt_string(&inner_77));
                    }
                }
                if let Some(inner_78) = &_input.max_results {
                    if *inner_78 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_78).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListRunGroupsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("workflows-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListRunGroups::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListRunGroups", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListRunGroupsInput`](crate::input::ListRunGroupsInput).
    pub fn builder() -> crate::input::list_run_groups_input::Builder {
        crate::input::list_run_groups_input::Builder::default()
    }
}

/// See [`ListRunsInput`](crate::input::ListRunsInput).
pub mod list_runs_input {
    
    /// A builder for [`ListRunsInput`](crate::input::ListRunsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) run_group_id: std::option::Option<std::string::String>,
        pub(crate) starting_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Filter the list by run name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Filter the list by run name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>Filter the list by run group ID.</p>
        pub fn run_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.run_group_id = Some(input.into());
            self
        }
        /// <p>Filter the list by run group ID.</p>
        pub fn set_run_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.run_group_id = input; self
        }
        /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
        pub fn starting_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.starting_token = Some(input.into());
            self
        }
        /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
        pub fn set_starting_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.starting_token = input; self
        }
        /// <p>The maximum number of runs to return in one page of results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of runs to return in one page of results.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`ListRunsInput`](crate::input::ListRunsInput).
        pub fn build(self) -> Result<crate::input::ListRunsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListRunsInput {
                    name: self.name
                    ,
                    run_group_id: self.run_group_id
                    ,
                    starting_token: self.starting_token
                    ,
                    max_results: self.max_results
                    ,
                }
            )
        }
    }
    
    
}
impl ListRunsInput {
    /// Consumes the builder and constructs an Operation<[`ListRuns`](crate::operation::ListRuns)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListRuns, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListRunsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/run").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListRunsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_79) = &_input.name {
                     {
                        query.push_kv("name", &aws_smithy_http::query::fmt_string(&inner_79));
                    }
                }
                if let Some(inner_80) = &_input.run_group_id {
                     {
                        query.push_kv("runGroupId", &aws_smithy_http::query::fmt_string(&inner_80));
                    }
                }
                if let Some(inner_81) = &_input.starting_token {
                     {
                        query.push_kv("startingToken", &aws_smithy_http::query::fmt_string(&inner_81));
                    }
                }
                if let Some(inner_82) = &_input.max_results {
                    if *inner_82 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_82).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListRunsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("workflows-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListRuns::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListRuns", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListRunsInput`](crate::input::ListRunsInput).
    pub fn builder() -> crate::input::list_runs_input::Builder {
        crate::input::list_runs_input::Builder::default()
    }
}

/// See [`ListRunTasksInput`](crate::input::ListRunTasksInput).
pub mod list_run_tasks_input {
    
    /// A builder for [`ListRunTasksInput`](crate::input::ListRunTasksInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::TaskStatus>,
        pub(crate) starting_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The run's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The run's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// <p>Filter the list by status.</p>
        pub fn status(mut self, input: crate::model::TaskStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Filter the list by status.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::TaskStatus>) -> Self {
            self.status = input; self
        }
        /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
        pub fn starting_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.starting_token = Some(input.into());
            self
        }
        /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
        pub fn set_starting_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.starting_token = input; self
        }
        /// <p>The maximum number of run tasks to return in one page of results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of run tasks to return in one page of results.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`ListRunTasksInput`](crate::input::ListRunTasksInput).
        pub fn build(self) -> Result<crate::input::ListRunTasksInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListRunTasksInput {
                    id: self.id
                    ,
                    status: self.status
                    ,
                    starting_token: self.starting_token
                    ,
                    max_results: self.max_results
                    ,
                }
            )
        }
    }
    
    
}
impl ListRunTasksInput {
    /// Consumes the builder and constructs an Operation<[`ListRunTasks`](crate::operation::ListRunTasks)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListRunTasks, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListRunTasksInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_83 = &_input.id;
                let input_83 = input_83.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))?;
                let id = aws_smithy_http::label::fmt_string(input_83, aws_smithy_http::label::EncodingStrategy::Default);
                if id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))
                            }
                write!(output, "/run/{id}/task", id = id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListRunTasksInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_84) = &_input.status {
                     {
                        query.push_kv("status", &aws_smithy_http::query::fmt_string(&inner_84));
                    }
                }
                if let Some(inner_85) = &_input.starting_token {
                     {
                        query.push_kv("startingToken", &aws_smithy_http::query::fmt_string(&inner_85));
                    }
                }
                if let Some(inner_86) = &_input.max_results {
                    if *inner_86 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_86).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListRunTasksInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("workflows-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListRunTasks::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListRunTasks", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListRunTasksInput`](crate::input::ListRunTasksInput).
    pub fn builder() -> crate::input::list_run_tasks_input::Builder {
        crate::input::list_run_tasks_input::Builder::default()
    }
}

/// See [`ListSequenceStoresInput`](crate::input::ListSequenceStoresInput).
pub mod list_sequence_stores_input {
    
    /// A builder for [`ListSequenceStoresInput`](crate::input::ListSequenceStoresInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) filter: std::option::Option<crate::model::SequenceStoreFilter>,
    }
    impl Builder {
        /// <p>The maximum number of stores to return in one page of results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of stores to return in one page of results.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>A filter to apply to the list.</p>
        pub fn filter(mut self, input: crate::model::SequenceStoreFilter) -> Self {
            self.filter = Some(input);
            self
        }
        /// <p>A filter to apply to the list.</p>
        pub fn set_filter(mut self, input: std::option::Option<crate::model::SequenceStoreFilter>) -> Self {
            self.filter = input; self
        }
        /// Consumes the builder and constructs a [`ListSequenceStoresInput`](crate::input::ListSequenceStoresInput).
        pub fn build(self) -> Result<crate::input::ListSequenceStoresInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListSequenceStoresInput {
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                    filter: self.filter
                    ,
                }
            )
        }
    }
    
    
}
impl ListSequenceStoresInput {
    /// Consumes the builder and constructs an Operation<[`ListSequenceStores`](crate::operation::ListSequenceStores)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListSequenceStores, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListSequenceStoresInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/sequencestores").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListSequenceStoresInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_87) = &_input.max_results {
                    if *inner_87 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_87).encode());
                    }
                }
                if let Some(inner_88) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_88));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListSequenceStoresInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_list_sequence_stores(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("control-storage-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListSequenceStores::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListSequenceStores", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListSequenceStoresInput`](crate::input::ListSequenceStoresInput).
    pub fn builder() -> crate::input::list_sequence_stores_input::Builder {
        crate::input::list_sequence_stores_input::Builder::default()
    }
}

/// See [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
pub mod list_tags_for_resource_input {
    
    /// A builder for [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The resource's ARN.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The resource's ARN.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input; self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
        pub fn build(self) -> Result<crate::input::ListTagsForResourceInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListTagsForResourceInput {
                    resource_arn: self.resource_arn
                    ,
                }
            )
        }
    }
    
    
}
impl ListTagsForResourceInput {
    /// Consumes the builder and constructs an Operation<[`ListTagsForResource`](crate::operation::ListTagsForResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListTagsForResource, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListTagsForResourceInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_89 = &_input.resource_arn;
                let input_89 = input_89.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("resource_arn", "cannot be empty or unset"))?;
                let resource_arn = aws_smithy_http::label::fmt_string(input_89, aws_smithy_http::label::EncodingStrategy::Default);
                if resource_arn.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("resource_arn", "cannot be empty or unset"))
                            }
                write!(output, "/tags/{resourceArn}", resourceArn = resource_arn).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListTagsForResourceInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("tags-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListTagsForResource::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListTagsForResource", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
}

/// See [`ListVariantImportJobsInput`](crate::input::ListVariantImportJobsInput).
pub mod list_variant_import_jobs_input {
    
    /// A builder for [`ListVariantImportJobsInput`](crate::input::ListVariantImportJobsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) filter: std::option::Option<crate::model::ListVariantImportJobsFilter>,
    }
    impl Builder {
        /// <p>The maximum number of import jobs to return in one page of results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of import jobs to return in one page of results.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Appends an item to `ids`.
        ///
        /// To override the contents of this collection use [`set_ids`](Self::set_ids).
        ///
        /// <p>A list of job IDs.</p>
        pub fn ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.ids.unwrap_or_default();
                            v.push(input.into());
                            self.ids = Some(v);
                            self
        }
        /// <p>A list of job IDs.</p>
        pub fn set_ids(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.ids = input; self
        }
        /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>A filter to apply to the list.</p>
        pub fn filter(mut self, input: crate::model::ListVariantImportJobsFilter) -> Self {
            self.filter = Some(input);
            self
        }
        /// <p>A filter to apply to the list.</p>
        pub fn set_filter(mut self, input: std::option::Option<crate::model::ListVariantImportJobsFilter>) -> Self {
            self.filter = input; self
        }
        /// Consumes the builder and constructs a [`ListVariantImportJobsInput`](crate::input::ListVariantImportJobsInput).
        pub fn build(self) -> Result<crate::input::ListVariantImportJobsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListVariantImportJobsInput {
                    max_results: self.max_results
                    ,
                    ids: self.ids
                    ,
                    next_token: self.next_token
                    ,
                    filter: self.filter
                    ,
                }
            )
        }
    }
    
    
}
impl ListVariantImportJobsInput {
    /// Consumes the builder and constructs an Operation<[`ListVariantImportJobs`](crate::operation::ListVariantImportJobs)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListVariantImportJobs, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListVariantImportJobsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/import/variants").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListVariantImportJobsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_90) = &_input.max_results {
                    if *inner_90 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_90).encode());
                    }
                }
                if let Some(inner_91) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_91));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListVariantImportJobsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_list_variant_import_jobs(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("analytics-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListVariantImportJobs::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListVariantImportJobs", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListVariantImportJobsInput`](crate::input::ListVariantImportJobsInput).
    pub fn builder() -> crate::input::list_variant_import_jobs_input::Builder {
        crate::input::list_variant_import_jobs_input::Builder::default()
    }
}

/// See [`ListVariantStoresInput`](crate::input::ListVariantStoresInput).
pub mod list_variant_stores_input {
    
    /// A builder for [`ListVariantStoresInput`](crate::input::ListVariantStoresInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) filter: std::option::Option<crate::model::ListVariantStoresFilter>,
    }
    impl Builder {
        /// <p>The maximum number of stores to return in one page of results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of stores to return in one page of results.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Appends an item to `ids`.
        ///
        /// To override the contents of this collection use [`set_ids`](Self::set_ids).
        ///
        /// <p>A list of store IDs.</p>
        pub fn ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.ids.unwrap_or_default();
                            v.push(input.into());
                            self.ids = Some(v);
                            self
        }
        /// <p>A list of store IDs.</p>
        pub fn set_ids(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.ids = input; self
        }
        /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>A filter to apply to the list.</p>
        pub fn filter(mut self, input: crate::model::ListVariantStoresFilter) -> Self {
            self.filter = Some(input);
            self
        }
        /// <p>A filter to apply to the list.</p>
        pub fn set_filter(mut self, input: std::option::Option<crate::model::ListVariantStoresFilter>) -> Self {
            self.filter = input; self
        }
        /// Consumes the builder and constructs a [`ListVariantStoresInput`](crate::input::ListVariantStoresInput).
        pub fn build(self) -> Result<crate::input::ListVariantStoresInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListVariantStoresInput {
                    max_results: self.max_results
                    ,
                    ids: self.ids
                    ,
                    next_token: self.next_token
                    ,
                    filter: self.filter
                    ,
                }
            )
        }
    }
    
    
}
impl ListVariantStoresInput {
    /// Consumes the builder and constructs an Operation<[`ListVariantStores`](crate::operation::ListVariantStores)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListVariantStores, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListVariantStoresInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/variantStores").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListVariantStoresInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_92) = &_input.max_results {
                    if *inner_92 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_92).encode());
                    }
                }
                if let Some(inner_93) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_93));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListVariantStoresInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_list_variant_stores(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("analytics-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListVariantStores::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListVariantStores", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListVariantStoresInput`](crate::input::ListVariantStoresInput).
    pub fn builder() -> crate::input::list_variant_stores_input::Builder {
        crate::input::list_variant_stores_input::Builder::default()
    }
}

/// See [`ListWorkflowsInput`](crate::input::ListWorkflowsInput).
pub mod list_workflows_input {
    
    /// A builder for [`ListWorkflowsInput`](crate::input::ListWorkflowsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::WorkflowType>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) starting_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The workflows' type.</p>
        pub fn r#type(mut self, input: crate::model::WorkflowType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The workflows' type.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::WorkflowType>) -> Self {
            self.r#type = input; self
        }
        /// <p>The workflows' name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The workflows' name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
        pub fn starting_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.starting_token = Some(input.into());
            self
        }
        /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
        pub fn set_starting_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.starting_token = input; self
        }
        /// <p>The maximum number of workflows to return in one page of results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of workflows to return in one page of results.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`ListWorkflowsInput`](crate::input::ListWorkflowsInput).
        pub fn build(self) -> Result<crate::input::ListWorkflowsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListWorkflowsInput {
                    r#type: self.r#type
                    ,
                    name: self.name
                    ,
                    starting_token: self.starting_token
                    ,
                    max_results: self.max_results
                    ,
                }
            )
        }
    }
    
    
}
impl ListWorkflowsInput {
    /// Consumes the builder and constructs an Operation<[`ListWorkflows`](crate::operation::ListWorkflows)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListWorkflows, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListWorkflowsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/workflow").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListWorkflowsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_94) = &_input.r#type {
                     {
                        query.push_kv("type", &aws_smithy_http::query::fmt_string(&inner_94));
                    }
                }
                if let Some(inner_95) = &_input.name {
                     {
                        query.push_kv("name", &aws_smithy_http::query::fmt_string(&inner_95));
                    }
                }
                if let Some(inner_96) = &_input.starting_token {
                     {
                        query.push_kv("startingToken", &aws_smithy_http::query::fmt_string(&inner_96));
                    }
                }
                if let Some(inner_97) = &_input.max_results {
                    if *inner_97 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_97).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListWorkflowsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("workflows-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListWorkflows::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListWorkflows", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListWorkflowsInput`](crate::input::ListWorkflowsInput).
    pub fn builder() -> crate::input::list_workflows_input::Builder {
        crate::input::list_workflows_input::Builder::default()
    }
}

/// See [`StartAnnotationImportJobInput`](crate::input::StartAnnotationImportJobInput).
pub mod start_annotation_import_job_input {
    
    /// A builder for [`StartAnnotationImportJobInput`](crate::input::StartAnnotationImportJobInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) destination_name: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) items: std::option::Option<std::vec::Vec<crate::model::AnnotationImportItemSource>>,
        pub(crate) format_options: std::option::Option<crate::model::FormatOptions>,
        pub(crate) run_left_normalization: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>A destination annotation store for the job.</p>
        pub fn destination_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_name = Some(input.into());
            self
        }
        /// <p>A destination annotation store for the job.</p>
        pub fn set_destination_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.destination_name = input; self
        }
        /// <p>A service role for the job.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>A service role for the job.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input; self
        }
        /// Appends an item to `items`.
        ///
        /// To override the contents of this collection use [`set_items`](Self::set_items).
        ///
        /// <p>Items to import.</p>
        pub fn items(mut self, input: crate::model::AnnotationImportItemSource) -> Self {
            let mut v = self.items.unwrap_or_default();
                            v.push(input);
                            self.items = Some(v);
                            self
        }
        /// <p>Items to import.</p>
        pub fn set_items(mut self, input: std::option::Option<std::vec::Vec<crate::model::AnnotationImportItemSource>>) -> Self {
            self.items = input; self
        }
        /// <p>Formatting options for the annotation file.</p>
        pub fn format_options(mut self, input: crate::model::FormatOptions) -> Self {
            self.format_options = Some(input);
            self
        }
        /// <p>Formatting options for the annotation file.</p>
        pub fn set_format_options(mut self, input: std::option::Option<crate::model::FormatOptions>) -> Self {
            self.format_options = input; self
        }
        /// <p>The job's left normalization setting.</p>
        pub fn run_left_normalization(mut self, input: bool) -> Self {
            self.run_left_normalization = Some(input);
            self
        }
        /// <p>The job's left normalization setting.</p>
        pub fn set_run_left_normalization(mut self, input: std::option::Option<bool>) -> Self {
            self.run_left_normalization = input; self
        }
        /// Consumes the builder and constructs a [`StartAnnotationImportJobInput`](crate::input::StartAnnotationImportJobInput).
        pub fn build(self) -> Result<crate::input::StartAnnotationImportJobInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::StartAnnotationImportJobInput {
                    destination_name: self.destination_name
                    ,
                    role_arn: self.role_arn
                    ,
                    items: self.items
                    ,
                    format_options: self.format_options
                    ,
                    run_left_normalization: self.run_left_normalization
                    ,
                }
            )
        }
    }
    
    
}
impl StartAnnotationImportJobInput {
    /// Consumes the builder and constructs an Operation<[`StartAnnotationImportJob`](crate::operation::StartAnnotationImportJob)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::StartAnnotationImportJob, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::StartAnnotationImportJobInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/import/annotation").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::StartAnnotationImportJobInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_start_annotation_import_job(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("analytics-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::StartAnnotationImportJob::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("StartAnnotationImportJob", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`StartAnnotationImportJobInput`](crate::input::StartAnnotationImportJobInput).
    pub fn builder() -> crate::input::start_annotation_import_job_input::Builder {
        crate::input::start_annotation_import_job_input::Builder::default()
    }
}

/// See [`StartReadSetActivationJobInput`](crate::input::StartReadSetActivationJobInput).
pub mod start_read_set_activation_job_input {
    
    /// A builder for [`StartReadSetActivationJobInput`](crate::input::StartReadSetActivationJobInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sequence_store_id: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) sources: std::option::Option<std::vec::Vec<crate::model::StartReadSetActivationJobSourceItem>>,
    }
    impl Builder {
        /// <p>The read set's sequence store ID.</p>
        pub fn sequence_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sequence_store_id = Some(input.into());
            self
        }
        /// <p>The read set's sequence store ID.</p>
        pub fn set_sequence_store_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sequence_store_id = input; self
        }
        /// <p>To ensure that jobs don't run multiple times, specify a unique token for each job.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>To ensure that jobs don't run multiple times, specify a unique token for each job.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// Appends an item to `sources`.
        ///
        /// To override the contents of this collection use [`set_sources`](Self::set_sources).
        ///
        /// <p>The job's sources.</p>
        pub fn sources(mut self, input: crate::model::StartReadSetActivationJobSourceItem) -> Self {
            let mut v = self.sources.unwrap_or_default();
                            v.push(input);
                            self.sources = Some(v);
                            self
        }
        /// <p>The job's sources.</p>
        pub fn set_sources(mut self, input: std::option::Option<std::vec::Vec<crate::model::StartReadSetActivationJobSourceItem>>) -> Self {
            self.sources = input; self
        }
        /// Consumes the builder and constructs a [`StartReadSetActivationJobInput`](crate::input::StartReadSetActivationJobInput).
        pub fn build(self) -> Result<crate::input::StartReadSetActivationJobInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::StartReadSetActivationJobInput {
                    sequence_store_id: self.sequence_store_id
                    ,
                    client_token: self.client_token
                    ,
                    sources: self.sources
                    ,
                }
            )
        }
    }
    
    
}
impl StartReadSetActivationJobInput {
    /// Consumes the builder and constructs an Operation<[`StartReadSetActivationJob`](crate::operation::StartReadSetActivationJob)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::StartReadSetActivationJob, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::StartReadSetActivationJobInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_98 = &_input.sequence_store_id;
                let input_98 = input_98.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("sequence_store_id", "cannot be empty or unset"))?;
                let sequence_store_id = aws_smithy_http::label::fmt_string(input_98, aws_smithy_http::label::EncodingStrategy::Default);
                if sequence_store_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("sequence_store_id", "cannot be empty or unset"))
                            }
                write!(output, "/sequencestore/{sequenceStoreId}/activationjob", sequenceStoreId = sequence_store_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::StartReadSetActivationJobInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_start_read_set_activation_job(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("control-storage-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::StartReadSetActivationJob::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("StartReadSetActivationJob", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`StartReadSetActivationJobInput`](crate::input::StartReadSetActivationJobInput).
    pub fn builder() -> crate::input::start_read_set_activation_job_input::Builder {
        crate::input::start_read_set_activation_job_input::Builder::default()
    }
}

/// See [`StartReadSetExportJobInput`](crate::input::StartReadSetExportJobInput).
pub mod start_read_set_export_job_input {
    
    /// A builder for [`StartReadSetExportJobInput`](crate::input::StartReadSetExportJobInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sequence_store_id: std::option::Option<std::string::String>,
        pub(crate) destination: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) sources: std::option::Option<std::vec::Vec<crate::model::ExportReadSet>>,
    }
    impl Builder {
        /// <p>The read set's sequence store ID.</p>
        pub fn sequence_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sequence_store_id = Some(input.into());
            self
        }
        /// <p>The read set's sequence store ID.</p>
        pub fn set_sequence_store_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sequence_store_id = input; self
        }
        /// <p>A location for exported files in Amazon S3.</p>
        pub fn destination(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination = Some(input.into());
            self
        }
        /// <p>A location for exported files in Amazon S3.</p>
        pub fn set_destination(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.destination = input; self
        }
        /// <p>A service role for the job.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>A service role for the job.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input; self
        }
        /// <p>To ensure that jobs don't run multiple times, specify a unique token for each job.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>To ensure that jobs don't run multiple times, specify a unique token for each job.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// Appends an item to `sources`.
        ///
        /// To override the contents of this collection use [`set_sources`](Self::set_sources).
        ///
        /// <p>Sources for the job.</p>
        pub fn sources(mut self, input: crate::model::ExportReadSet) -> Self {
            let mut v = self.sources.unwrap_or_default();
                            v.push(input);
                            self.sources = Some(v);
                            self
        }
        /// <p>Sources for the job.</p>
        pub fn set_sources(mut self, input: std::option::Option<std::vec::Vec<crate::model::ExportReadSet>>) -> Self {
            self.sources = input; self
        }
        /// Consumes the builder and constructs a [`StartReadSetExportJobInput`](crate::input::StartReadSetExportJobInput).
        pub fn build(self) -> Result<crate::input::StartReadSetExportJobInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::StartReadSetExportJobInput {
                    sequence_store_id: self.sequence_store_id
                    ,
                    destination: self.destination
                    ,
                    role_arn: self.role_arn
                    ,
                    client_token: self.client_token
                    ,
                    sources: self.sources
                    ,
                }
            )
        }
    }
    
    
}
impl StartReadSetExportJobInput {
    /// Consumes the builder and constructs an Operation<[`StartReadSetExportJob`](crate::operation::StartReadSetExportJob)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::StartReadSetExportJob, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::StartReadSetExportJobInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_99 = &_input.sequence_store_id;
                let input_99 = input_99.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("sequence_store_id", "cannot be empty or unset"))?;
                let sequence_store_id = aws_smithy_http::label::fmt_string(input_99, aws_smithy_http::label::EncodingStrategy::Default);
                if sequence_store_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("sequence_store_id", "cannot be empty or unset"))
                            }
                write!(output, "/sequencestore/{sequenceStoreId}/exportjob", sequenceStoreId = sequence_store_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::StartReadSetExportJobInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_start_read_set_export_job(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("control-storage-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::StartReadSetExportJob::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("StartReadSetExportJob", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`StartReadSetExportJobInput`](crate::input::StartReadSetExportJobInput).
    pub fn builder() -> crate::input::start_read_set_export_job_input::Builder {
        crate::input::start_read_set_export_job_input::Builder::default()
    }
}

/// See [`StartReadSetImportJobInput`](crate::input::StartReadSetImportJobInput).
pub mod start_read_set_import_job_input {
    
    /// A builder for [`StartReadSetImportJobInput`](crate::input::StartReadSetImportJobInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sequence_store_id: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) sources: std::option::Option<std::vec::Vec<crate::model::StartReadSetImportJobSourceItem>>,
    }
    impl Builder {
        /// <p>The read set's sequence store ID.</p>
        pub fn sequence_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sequence_store_id = Some(input.into());
            self
        }
        /// <p>The read set's sequence store ID.</p>
        pub fn set_sequence_store_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sequence_store_id = input; self
        }
        /// <p>A service role for the job.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>A service role for the job.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input; self
        }
        /// <p>To ensure that jobs don't run multiple times, specify a unique token for each job.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>To ensure that jobs don't run multiple times, specify a unique token for each job.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// Appends an item to `sources`.
        ///
        /// To override the contents of this collection use [`set_sources`](Self::set_sources).
        ///
        /// <p>Source files to import.</p>
        pub fn sources(mut self, input: crate::model::StartReadSetImportJobSourceItem) -> Self {
            let mut v = self.sources.unwrap_or_default();
                            v.push(input);
                            self.sources = Some(v);
                            self
        }
        /// <p>Source files to import.</p>
        pub fn set_sources(mut self, input: std::option::Option<std::vec::Vec<crate::model::StartReadSetImportJobSourceItem>>) -> Self {
            self.sources = input; self
        }
        /// Consumes the builder and constructs a [`StartReadSetImportJobInput`](crate::input::StartReadSetImportJobInput).
        pub fn build(self) -> Result<crate::input::StartReadSetImportJobInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::StartReadSetImportJobInput {
                    sequence_store_id: self.sequence_store_id
                    ,
                    role_arn: self.role_arn
                    ,
                    client_token: self.client_token
                    ,
                    sources: self.sources
                    ,
                }
            )
        }
    }
    
    
}
impl StartReadSetImportJobInput {
    /// Consumes the builder and constructs an Operation<[`StartReadSetImportJob`](crate::operation::StartReadSetImportJob)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::StartReadSetImportJob, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::StartReadSetImportJobInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_100 = &_input.sequence_store_id;
                let input_100 = input_100.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("sequence_store_id", "cannot be empty or unset"))?;
                let sequence_store_id = aws_smithy_http::label::fmt_string(input_100, aws_smithy_http::label::EncodingStrategy::Default);
                if sequence_store_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("sequence_store_id", "cannot be empty or unset"))
                            }
                write!(output, "/sequencestore/{sequenceStoreId}/importjob", sequenceStoreId = sequence_store_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::StartReadSetImportJobInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_start_read_set_import_job(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("control-storage-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::StartReadSetImportJob::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("StartReadSetImportJob", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`StartReadSetImportJobInput`](crate::input::StartReadSetImportJobInput).
    pub fn builder() -> crate::input::start_read_set_import_job_input::Builder {
        crate::input::start_read_set_import_job_input::Builder::default()
    }
}

/// See [`StartReferenceImportJobInput`](crate::input::StartReferenceImportJobInput).
pub mod start_reference_import_job_input {
    
    /// A builder for [`StartReferenceImportJobInput`](crate::input::StartReferenceImportJobInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) reference_store_id: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) sources: std::option::Option<std::vec::Vec<crate::model::StartReferenceImportJobSourceItem>>,
    }
    impl Builder {
        /// <p>The job's reference store ID.</p>
        pub fn reference_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.reference_store_id = Some(input.into());
            self
        }
        /// <p>The job's reference store ID.</p>
        pub fn set_reference_store_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.reference_store_id = input; self
        }
        /// <p>A service role for the job.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>A service role for the job.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input; self
        }
        /// <p>To ensure that jobs don't run multiple times, specify a unique token for each job.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>To ensure that jobs don't run multiple times, specify a unique token for each job.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// Appends an item to `sources`.
        ///
        /// To override the contents of this collection use [`set_sources`](Self::set_sources).
        ///
        /// <p>Sources for the job.</p>
        pub fn sources(mut self, input: crate::model::StartReferenceImportJobSourceItem) -> Self {
            let mut v = self.sources.unwrap_or_default();
                            v.push(input);
                            self.sources = Some(v);
                            self
        }
        /// <p>Sources for the job.</p>
        pub fn set_sources(mut self, input: std::option::Option<std::vec::Vec<crate::model::StartReferenceImportJobSourceItem>>) -> Self {
            self.sources = input; self
        }
        /// Consumes the builder and constructs a [`StartReferenceImportJobInput`](crate::input::StartReferenceImportJobInput).
        pub fn build(self) -> Result<crate::input::StartReferenceImportJobInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::StartReferenceImportJobInput {
                    reference_store_id: self.reference_store_id
                    ,
                    role_arn: self.role_arn
                    ,
                    client_token: self.client_token
                    ,
                    sources: self.sources
                    ,
                }
            )
        }
    }
    
    
}
impl StartReferenceImportJobInput {
    /// Consumes the builder and constructs an Operation<[`StartReferenceImportJob`](crate::operation::StartReferenceImportJob)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::StartReferenceImportJob, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::StartReferenceImportJobInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_101 = &_input.reference_store_id;
                let input_101 = input_101.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("reference_store_id", "cannot be empty or unset"))?;
                let reference_store_id = aws_smithy_http::label::fmt_string(input_101, aws_smithy_http::label::EncodingStrategy::Default);
                if reference_store_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("reference_store_id", "cannot be empty or unset"))
                            }
                write!(output, "/referencestore/{referenceStoreId}/importjob", referenceStoreId = reference_store_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::StartReferenceImportJobInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_start_reference_import_job(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("control-storage-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::StartReferenceImportJob::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("StartReferenceImportJob", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`StartReferenceImportJobInput`](crate::input::StartReferenceImportJobInput).
    pub fn builder() -> crate::input::start_reference_import_job_input::Builder {
        crate::input::start_reference_import_job_input::Builder::default()
    }
}

/// See [`StartRunInput`](crate::input::StartRunInput).
pub mod start_run_input {
    
    /// A builder for [`StartRunInput`](crate::input::StartRunInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workflow_id: std::option::Option<std::string::String>,
        pub(crate) workflow_type: std::option::Option<crate::model::WorkflowType>,
        pub(crate) run_id: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) run_group_id: std::option::Option<std::string::String>,
        pub(crate) priority: std::option::Option<i32>,
        pub(crate) parameters: std::option::Option<aws_smithy_types::Document>,
        pub(crate) storage_capacity: std::option::Option<i32>,
        pub(crate) output_uri: std::option::Option<std::string::String>,
        pub(crate) log_level: std::option::Option<crate::model::RunLogLevel>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
        pub(crate) request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The run's workflow ID.</p>
        pub fn workflow_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workflow_id = Some(input.into());
            self
        }
        /// <p>The run's workflow ID.</p>
        pub fn set_workflow_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workflow_id = input; self
        }
        /// <p>The run's workflows type.</p>
        pub fn workflow_type(mut self, input: crate::model::WorkflowType) -> Self {
            self.workflow_type = Some(input);
            self
        }
        /// <p>The run's workflows type.</p>
        pub fn set_workflow_type(mut self, input: std::option::Option<crate::model::WorkflowType>) -> Self {
            self.workflow_type = input; self
        }
        /// <p>The run's ID.</p>
        pub fn run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.run_id = Some(input.into());
            self
        }
        /// <p>The run's ID.</p>
        pub fn set_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.run_id = input; self
        }
        /// <p>A service role for the run.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>A service role for the run.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input; self
        }
        /// <p>A name for the run.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A name for the run.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>The run's group ID.</p>
        pub fn run_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.run_group_id = Some(input.into());
            self
        }
        /// <p>The run's group ID.</p>
        pub fn set_run_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.run_group_id = input; self
        }
        /// <p>A priority for the run.</p>
        pub fn priority(mut self, input: i32) -> Self {
            self.priority = Some(input);
            self
        }
        /// <p>A priority for the run.</p>
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.priority = input; self
        }
        /// <p>Parameters for the run.</p>
        pub fn parameters(mut self, input: aws_smithy_types::Document) -> Self {
            self.parameters = Some(input);
            self
        }
        /// <p>Parameters for the run.</p>
        pub fn set_parameters(mut self, input: std::option::Option<aws_smithy_types::Document>) -> Self {
            self.parameters = input; self
        }
        /// <p>A storage capacity for the run.</p>
        pub fn storage_capacity(mut self, input: i32) -> Self {
            self.storage_capacity = Some(input);
            self
        }
        /// <p>A storage capacity for the run.</p>
        pub fn set_storage_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.storage_capacity = input; self
        }
        /// <p>An output URI for the run.</p>
        pub fn output_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_uri = Some(input.into());
            self
        }
        /// <p>An output URI for the run.</p>
        pub fn set_output_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.output_uri = input; self
        }
        /// <p>A log level for the run.</p>
        pub fn log_level(mut self, input: crate::model::RunLogLevel) -> Self {
            self.log_level = Some(input);
            self
        }
        /// <p>A log level for the run.</p>
        pub fn set_log_level(mut self, input: std::option::Option<crate::model::RunLogLevel>) -> Self {
            self.log_level = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Tags for the run.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>Tags for the run.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// <p>A request ID for the run.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>A request ID for the run.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input; self
        }
        /// Consumes the builder and constructs a [`StartRunInput`](crate::input::StartRunInput).
        pub fn build(self) -> Result<crate::input::StartRunInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::StartRunInput {
                    workflow_id: self.workflow_id
                    ,
                    workflow_type: self.workflow_type
                    ,
                    run_id: self.run_id
                    ,
                    role_arn: self.role_arn
                    ,
                    name: self.name
                    ,
                    run_group_id: self.run_group_id
                    ,
                    priority: self.priority
                    ,
                    parameters: self.parameters
                    ,
                    storage_capacity: self.storage_capacity
                    ,
                    output_uri: self.output_uri
                    ,
                    log_level: self.log_level
                    ,
                    tags: self.tags
                    ,
                    request_id: self.request_id
                    ,
                }
            )
        }
    }
    
    
}
impl StartRunInput {
    /// Consumes the builder and constructs an Operation<[`StartRun`](crate::operation::StartRun)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::StartRun, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.request_id.is_none() {
                                self.request_id = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::input::StartRunInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/run").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::StartRunInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_start_run(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("workflows-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::StartRun::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("StartRun", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`StartRunInput`](crate::input::StartRunInput).
    pub fn builder() -> crate::input::start_run_input::Builder {
        crate::input::start_run_input::Builder::default()
    }
}

/// See [`StartVariantImportJobInput`](crate::input::StartVariantImportJobInput).
pub mod start_variant_import_job_input {
    
    /// A builder for [`StartVariantImportJobInput`](crate::input::StartVariantImportJobInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) destination_name: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) items: std::option::Option<std::vec::Vec<crate::model::VariantImportItemSource>>,
        pub(crate) run_left_normalization: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The destination variant store for the job.</p>
        pub fn destination_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_name = Some(input.into());
            self
        }
        /// <p>The destination variant store for the job.</p>
        pub fn set_destination_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.destination_name = input; self
        }
        /// <p>A service role for the job.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>A service role for the job.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input; self
        }
        /// Appends an item to `items`.
        ///
        /// To override the contents of this collection use [`set_items`](Self::set_items).
        ///
        /// <p>Items to import.</p>
        pub fn items(mut self, input: crate::model::VariantImportItemSource) -> Self {
            let mut v = self.items.unwrap_or_default();
                            v.push(input);
                            self.items = Some(v);
                            self
        }
        /// <p>Items to import.</p>
        pub fn set_items(mut self, input: std::option::Option<std::vec::Vec<crate::model::VariantImportItemSource>>) -> Self {
            self.items = input; self
        }
        /// <p>The job's left normalization setting.</p>
        pub fn run_left_normalization(mut self, input: bool) -> Self {
            self.run_left_normalization = Some(input);
            self
        }
        /// <p>The job's left normalization setting.</p>
        pub fn set_run_left_normalization(mut self, input: std::option::Option<bool>) -> Self {
            self.run_left_normalization = input; self
        }
        /// Consumes the builder and constructs a [`StartVariantImportJobInput`](crate::input::StartVariantImportJobInput).
        pub fn build(self) -> Result<crate::input::StartVariantImportJobInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::StartVariantImportJobInput {
                    destination_name: self.destination_name
                    ,
                    role_arn: self.role_arn
                    ,
                    items: self.items
                    ,
                    run_left_normalization: self.run_left_normalization
                    ,
                }
            )
        }
    }
    
    
}
impl StartVariantImportJobInput {
    /// Consumes the builder and constructs an Operation<[`StartVariantImportJob`](crate::operation::StartVariantImportJob)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::StartVariantImportJob, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::StartVariantImportJobInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/import/variant").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::StartVariantImportJobInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_start_variant_import_job(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("analytics-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::StartVariantImportJob::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("StartVariantImportJob", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`StartVariantImportJobInput`](crate::input::StartVariantImportJobInput).
    pub fn builder() -> crate::input::start_variant_import_job_input::Builder {
        crate::input::start_variant_import_job_input::Builder::default()
    }
}

/// See [`TagResourceInput`](crate::input::TagResourceInput).
pub mod tag_resource_input {
    
    /// A builder for [`TagResourceInput`](crate::input::TagResourceInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    }
    impl Builder {
        /// <p>The resource's ARN.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The resource's ARN.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Tags for the resource.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>Tags for the resource.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`TagResourceInput`](crate::input::TagResourceInput).
        pub fn build(self) -> Result<crate::input::TagResourceInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::TagResourceInput {
                    resource_arn: self.resource_arn
                    ,
                    tags: self.tags
                    ,
                }
            )
        }
    }
    
    
}
impl TagResourceInput {
    /// Consumes the builder and constructs an Operation<[`TagResource`](crate::operation::TagResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::TagResource, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::TagResourceInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_102 = &_input.resource_arn;
                let input_102 = input_102.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("resource_arn", "cannot be empty or unset"))?;
                let resource_arn = aws_smithy_http::label::fmt_string(input_102, aws_smithy_http::label::EncodingStrategy::Default);
                if resource_arn.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("resource_arn", "cannot be empty or unset"))
                            }
                write!(output, "/tags/{resourceArn}", resourceArn = resource_arn).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::TagResourceInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_tag_resource(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("tags-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::TagResource::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("TagResource", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput).
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
}

/// See [`UntagResourceInput`](crate::input::UntagResourceInput).
pub mod untag_resource_input {
    
    /// A builder for [`UntagResourceInput`](crate::input::UntagResourceInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The resource's ARN.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The resource's ARN.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input; self
        }
        /// Appends an item to `tag_keys`.
        ///
        /// To override the contents of this collection use [`set_tag_keys`](Self::set_tag_keys).
        ///
        /// <p>Keys of tags to remove.</p>
        pub fn tag_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
                            v.push(input.into());
                            self.tag_keys = Some(v);
                            self
        }
        /// <p>Keys of tags to remove.</p>
        pub fn set_tag_keys(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.tag_keys = input; self
        }
        /// Consumes the builder and constructs a [`UntagResourceInput`](crate::input::UntagResourceInput).
        pub fn build(self) -> Result<crate::input::UntagResourceInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UntagResourceInput {
                    resource_arn: self.resource_arn
                    ,
                    tag_keys: self.tag_keys
                    ,
                }
            )
        }
    }
    
    
}
impl UntagResourceInput {
    /// Consumes the builder and constructs an Operation<[`UntagResource`](crate::operation::UntagResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UntagResource, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UntagResourceInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_103 = &_input.resource_arn;
                let input_103 = input_103.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("resource_arn", "cannot be empty or unset"))?;
                let resource_arn = aws_smithy_http::label::fmt_string(input_103, aws_smithy_http::label::EncodingStrategy::Default);
                if resource_arn.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("resource_arn", "cannot be empty or unset"))
                            }
                write!(output, "/tags/{resourceArn}", resourceArn = resource_arn).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::UntagResourceInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_104 = &_input.tag_keys;
                let inner_104 = inner_104.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("tag_keys", "cannot be empty or unset"))?;
                for inner_105 in inner_104 {
                    query.push_kv("tagKeys", &aws_smithy_http::query::fmt_string(&inner_105));
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UntagResourceInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("tags-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UntagResource::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UntagResource", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput).
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
}

/// See [`UpdateAnnotationStoreInput`](crate::input::UpdateAnnotationStoreInput).
pub mod update_annotation_store_input {
    
    /// A builder for [`UpdateAnnotationStoreInput`](crate::input::UpdateAnnotationStoreInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A name for the store.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A name for the store.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>A description for the store.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description for the store.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// Consumes the builder and constructs a [`UpdateAnnotationStoreInput`](crate::input::UpdateAnnotationStoreInput).
        pub fn build(self) -> Result<crate::input::UpdateAnnotationStoreInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateAnnotationStoreInput {
                    name: self.name
                    ,
                    description: self.description
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateAnnotationStoreInput {
    /// Consumes the builder and constructs an Operation<[`UpdateAnnotationStore`](crate::operation::UpdateAnnotationStore)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateAnnotationStore, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateAnnotationStoreInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_106 = &_input.name;
                let input_106 = input_106.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("name", "cannot be empty or unset"))?;
                let name = aws_smithy_http::label::fmt_string(input_106, aws_smithy_http::label::EncodingStrategy::Default);
                if name.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("name", "cannot be empty or unset"))
                            }
                write!(output, "/annotationStore/{name}", name = name).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateAnnotationStoreInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_annotation_store(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("analytics-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateAnnotationStore::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateAnnotationStore", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateAnnotationStoreInput`](crate::input::UpdateAnnotationStoreInput).
    pub fn builder() -> crate::input::update_annotation_store_input::Builder {
        crate::input::update_annotation_store_input::Builder::default()
    }
}

/// See [`UpdateRunGroupInput`](crate::input::UpdateRunGroupInput).
pub mod update_run_group_input {
    
    /// A builder for [`UpdateRunGroupInput`](crate::input::UpdateRunGroupInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) max_cpus: std::option::Option<i32>,
        pub(crate) max_runs: std::option::Option<i32>,
        pub(crate) max_duration: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The group's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The group's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// <p>A name for the group.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A name for the group.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>The maximum number of CPUs to use.</p>
        pub fn max_cpus(mut self, input: i32) -> Self {
            self.max_cpus = Some(input);
            self
        }
        /// <p>The maximum number of CPUs to use.</p>
        pub fn set_max_cpus(mut self, input: std::option::Option<i32>) -> Self {
            self.max_cpus = input; self
        }
        /// <p>The maximum number of concurrent runs for the group.</p>
        pub fn max_runs(mut self, input: i32) -> Self {
            self.max_runs = Some(input);
            self
        }
        /// <p>The maximum number of concurrent runs for the group.</p>
        pub fn set_max_runs(mut self, input: std::option::Option<i32>) -> Self {
            self.max_runs = input; self
        }
        /// <p>The maximum amount of time to run.</p>
        pub fn max_duration(mut self, input: i32) -> Self {
            self.max_duration = Some(input);
            self
        }
        /// <p>The maximum amount of time to run.</p>
        pub fn set_max_duration(mut self, input: std::option::Option<i32>) -> Self {
            self.max_duration = input; self
        }
        /// Consumes the builder and constructs a [`UpdateRunGroupInput`](crate::input::UpdateRunGroupInput).
        pub fn build(self) -> Result<crate::input::UpdateRunGroupInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateRunGroupInput {
                    id: self.id
                    ,
                    name: self.name
                    ,
                    max_cpus: self.max_cpus
                    ,
                    max_runs: self.max_runs
                    ,
                    max_duration: self.max_duration
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateRunGroupInput {
    /// Consumes the builder and constructs an Operation<[`UpdateRunGroup`](crate::operation::UpdateRunGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateRunGroup, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateRunGroupInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_107 = &_input.id;
                let input_107 = input_107.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))?;
                let id = aws_smithy_http::label::fmt_string(input_107, aws_smithy_http::label::EncodingStrategy::Default);
                if id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))
                            }
                write!(output, "/runGroup/{id}", id = id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateRunGroupInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_run_group(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("workflows-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateRunGroup::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateRunGroup", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateRunGroupInput`](crate::input::UpdateRunGroupInput).
    pub fn builder() -> crate::input::update_run_group_input::Builder {
        crate::input::update_run_group_input::Builder::default()
    }
}

/// See [`UpdateVariantStoreInput`](crate::input::UpdateVariantStoreInput).
pub mod update_variant_store_input {
    
    /// A builder for [`UpdateVariantStoreInput`](crate::input::UpdateVariantStoreInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A name for the store.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A name for the store.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>A description for the store.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description for the store.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// Consumes the builder and constructs a [`UpdateVariantStoreInput`](crate::input::UpdateVariantStoreInput).
        pub fn build(self) -> Result<crate::input::UpdateVariantStoreInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateVariantStoreInput {
                    name: self.name
                    ,
                    description: self.description
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateVariantStoreInput {
    /// Consumes the builder and constructs an Operation<[`UpdateVariantStore`](crate::operation::UpdateVariantStore)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateVariantStore, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateVariantStoreInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_108 = &_input.name;
                let input_108 = input_108.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("name", "cannot be empty or unset"))?;
                let name = aws_smithy_http::label::fmt_string(input_108, aws_smithy_http::label::EncodingStrategy::Default);
                if name.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("name", "cannot be empty or unset"))
                            }
                write!(output, "/variantStore/{name}", name = name).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateVariantStoreInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_variant_store(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("analytics-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateVariantStore::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateVariantStore", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateVariantStoreInput`](crate::input::UpdateVariantStoreInput).
    pub fn builder() -> crate::input::update_variant_store_input::Builder {
        crate::input::update_variant_store_input::Builder::default()
    }
}

/// See [`UpdateWorkflowInput`](crate::input::UpdateWorkflowInput).
pub mod update_workflow_input {
    
    /// A builder for [`UpdateWorkflowInput`](crate::input::UpdateWorkflowInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The workflow's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The workflow's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// <p>A name for the workflow.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A name for the workflow.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>A description for the workflow.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description for the workflow.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// Consumes the builder and constructs a [`UpdateWorkflowInput`](crate::input::UpdateWorkflowInput).
        pub fn build(self) -> Result<crate::input::UpdateWorkflowInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateWorkflowInput {
                    id: self.id
                    ,
                    name: self.name
                    ,
                    description: self.description
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateWorkflowInput {
    /// Consumes the builder and constructs an Operation<[`UpdateWorkflow`](crate::operation::UpdateWorkflow)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateWorkflow, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateWorkflowInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_109 = &_input.id;
                let input_109 = input_109.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))?;
                let id = aws_smithy_http::label::fmt_string(input_109, aws_smithy_http::label::EncodingStrategy::Default);
                if id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))
                            }
                write!(output, "/workflow/{id}", id = id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateWorkflowInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_workflow(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("workflows-")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateWorkflow::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateWorkflow", "omics"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateWorkflowInput`](crate::input::UpdateWorkflowInput).
    pub fn builder() -> crate::input::update_workflow_input::Builder {
        crate::input::update_workflow_input::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListWorkflowsInput  {
    /// <p>The workflows' type.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::WorkflowType>,
    /// <p>The workflows' name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
    #[doc(hidden)]
    pub starting_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of workflows to return in one page of results.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListWorkflowsInput {
    /// <p>The workflows' type.</p>
    pub fn r#type(&self) -> std::option::Option<& crate::model::WorkflowType> {
        self.r#type.as_ref()
    }
    /// <p>The workflows' name.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
    pub fn starting_token(&self) -> std::option::Option<& str> {
        self.starting_token.as_deref()
    }
    /// <p>The maximum number of workflows to return in one page of results.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateWorkflowInput  {
    /// <p>A name for the workflow.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A description for the workflow.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>An engine for the workflow.</p>
    #[doc(hidden)]
    pub engine: std::option::Option<crate::model::WorkflowEngine>,
    /// <p>A ZIP archive for the workflow.</p>
    #[doc(hidden)]
    pub definition_zip: std::option::Option<aws_smithy_types::Blob>,
    /// <p>The URI of a definition for the workflow.</p>
    #[doc(hidden)]
    pub definition_uri: std::option::Option<std::string::String>,
    /// <p>The path of the main definition file for the workflow.</p>
    #[doc(hidden)]
    pub main: std::option::Option<std::string::String>,
    /// <p>A parameter template for the workflow.</p>
    #[doc(hidden)]
    pub parameter_template: std::option::Option<std::collections::HashMap<std::string::String, crate::model::WorkflowParameter>>,
    /// <p>A storage capacity for the workflow.</p>
    #[doc(hidden)]
    pub storage_capacity: std::option::Option<i32>,
    /// <p>Tags for the workflow.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A request ID for the workflow.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
}
impl CreateWorkflowInput {
    /// <p>A name for the workflow.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>A description for the workflow.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p>An engine for the workflow.</p>
    pub fn engine(&self) -> std::option::Option<& crate::model::WorkflowEngine> {
        self.engine.as_ref()
    }
    /// <p>A ZIP archive for the workflow.</p>
    pub fn definition_zip(&self) -> std::option::Option<& aws_smithy_types::Blob> {
        self.definition_zip.as_ref()
    }
    /// <p>The URI of a definition for the workflow.</p>
    pub fn definition_uri(&self) -> std::option::Option<& str> {
        self.definition_uri.as_deref()
    }
    /// <p>The path of the main definition file for the workflow.</p>
    pub fn main(&self) -> std::option::Option<& str> {
        self.main.as_deref()
    }
    /// <p>A parameter template for the workflow.</p>
    pub fn parameter_template(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, crate::model::WorkflowParameter>> {
        self.parameter_template.as_ref()
    }
    /// <p>A storage capacity for the workflow.</p>
    pub fn storage_capacity(&self) -> std::option::Option<i32> {
        self.storage_capacity
    }
    /// <p>Tags for the workflow.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
    /// <p>A request ID for the workflow.</p>
    pub fn request_id(&self) -> std::option::Option<& str> {
        self.request_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteWorkflowInput  {
    /// <p>The workflow's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl DeleteWorkflowInput {
    /// <p>The workflow's ID.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateWorkflowInput  {
    /// <p>The workflow's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>A name for the workflow.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A description for the workflow.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
}
impl UpdateWorkflowInput {
    /// <p>The workflow's ID.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
    /// <p>A name for the workflow.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>A description for the workflow.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetWorkflowInput  {
    /// <p>The workflow's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The workflow's type.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::WorkflowType>,
    /// <p>The export format for the workflow.</p>
    #[doc(hidden)]
    pub export: std::option::Option<std::vec::Vec<crate::model::WorkflowExport>>,
}
impl GetWorkflowInput {
    /// <p>The workflow's ID.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
    /// <p>The workflow's type.</p>
    pub fn r#type(&self) -> std::option::Option<& crate::model::WorkflowType> {
        self.r#type.as_ref()
    }
    /// <p>The export format for the workflow.</p>
    pub fn export(&self) -> std::option::Option<& [crate::model::WorkflowExport]> {
        self.export.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListVariantStoresInput  {
    /// <p>The maximum number of stores to return in one page of results.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>A list of store IDs.</p>
    #[doc(hidden)]
    pub ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>A filter to apply to the list.</p>
    #[doc(hidden)]
    pub filter: std::option::Option<crate::model::ListVariantStoresFilter>,
}
impl ListVariantStoresInput {
    /// <p>The maximum number of stores to return in one page of results.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>A list of store IDs.</p>
    pub fn ids(&self) -> std::option::Option<& [std::string::String]> {
        self.ids.as_deref()
    }
    /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>A filter to apply to the list.</p>
    pub fn filter(&self) -> std::option::Option<& crate::model::ListVariantStoresFilter> {
        self.filter.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateVariantStoreInput  {
    /// <p>The genome reference for the store's variants.</p>
    #[doc(hidden)]
    pub reference: std::option::Option<crate::model::ReferenceItem>,
    /// <p>A name for the store.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A description for the store.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Tags for the store.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Server-side encryption (SSE) settings for the store.</p>
    #[doc(hidden)]
    pub sse_config: std::option::Option<crate::model::SseConfig>,
}
impl CreateVariantStoreInput {
    /// <p>The genome reference for the store's variants.</p>
    pub fn reference(&self) -> std::option::Option<& crate::model::ReferenceItem> {
        self.reference.as_ref()
    }
    /// <p>A name for the store.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>A description for the store.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p>Tags for the store.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
    /// <p>Server-side encryption (SSE) settings for the store.</p>
    pub fn sse_config(&self) -> std::option::Option<& crate::model::SseConfig> {
        self.sse_config.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteVariantStoreInput  {
    /// <p>The store's name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Whether to force deletion.</p>
    #[doc(hidden)]
    pub force: std::option::Option<bool>,
}
impl DeleteVariantStoreInput {
    /// <p>The store's name.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>Whether to force deletion.</p>
    pub fn force(&self) -> std::option::Option<bool> {
        self.force
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateVariantStoreInput  {
    /// <p>A name for the store.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A description for the store.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
}
impl UpdateVariantStoreInput {
    /// <p>A name for the store.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>A description for the store.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetVariantStoreInput  {
    /// <p>The store's name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl GetVariantStoreInput {
    /// <p>The store's name.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListVariantImportJobsInput  {
    /// <p>The maximum number of import jobs to return in one page of results.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>A list of job IDs.</p>
    #[doc(hidden)]
    pub ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>A filter to apply to the list.</p>
    #[doc(hidden)]
    pub filter: std::option::Option<crate::model::ListVariantImportJobsFilter>,
}
impl ListVariantImportJobsInput {
    /// <p>The maximum number of import jobs to return in one page of results.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>A list of job IDs.</p>
    pub fn ids(&self) -> std::option::Option<& [std::string::String]> {
        self.ids.as_deref()
    }
    /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>A filter to apply to the list.</p>
    pub fn filter(&self) -> std::option::Option<& crate::model::ListVariantImportJobsFilter> {
        self.filter.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StartVariantImportJobInput  {
    /// <p>The destination variant store for the job.</p>
    #[doc(hidden)]
    pub destination_name: std::option::Option<std::string::String>,
    /// <p>A service role for the job.</p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>Items to import.</p>
    #[doc(hidden)]
    pub items: std::option::Option<std::vec::Vec<crate::model::VariantImportItemSource>>,
    /// <p>The job's left normalization setting.</p>
    #[doc(hidden)]
    pub run_left_normalization: std::option::Option<bool>,
}
impl StartVariantImportJobInput {
    /// <p>The destination variant store for the job.</p>
    pub fn destination_name(&self) -> std::option::Option<& str> {
        self.destination_name.as_deref()
    }
    /// <p>A service role for the job.</p>
    pub fn role_arn(&self) -> std::option::Option<& str> {
        self.role_arn.as_deref()
    }
    /// <p>Items to import.</p>
    pub fn items(&self) -> std::option::Option<& [crate::model::VariantImportItemSource]> {
        self.items.as_deref()
    }
    /// <p>The job's left normalization setting.</p>
    pub fn run_left_normalization(&self) -> std::option::Option<bool> {
        self.run_left_normalization
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CancelVariantImportJobInput  {
    /// <p>The job's ID.</p>
    #[doc(hidden)]
    pub job_id: std::option::Option<std::string::String>,
}
impl CancelVariantImportJobInput {
    /// <p>The job's ID.</p>
    pub fn job_id(&self) -> std::option::Option<& str> {
        self.job_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetVariantImportJobInput  {
    /// <p>The job's ID.</p>
    #[doc(hidden)]
    pub job_id: std::option::Option<std::string::String>,
}
impl GetVariantImportJobInput {
    /// <p>The job's ID.</p>
    pub fn job_id(&self) -> std::option::Option<& str> {
        self.job_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UntagResourceInput  {
    /// <p>The resource's ARN.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>Keys of tags to remove.</p>
    #[doc(hidden)]
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl UntagResourceInput {
    /// <p>The resource's ARN.</p>
    pub fn resource_arn(&self) -> std::option::Option<& str> {
        self.resource_arn.as_deref()
    }
    /// <p>Keys of tags to remove.</p>
    pub fn tag_keys(&self) -> std::option::Option<& [std::string::String]> {
        self.tag_keys.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TagResourceInput  {
    /// <p>The resource's ARN.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>Tags for the resource.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl TagResourceInput {
    /// <p>The resource's ARN.</p>
    pub fn resource_arn(&self) -> std::option::Option<& str> {
        self.resource_arn.as_deref()
    }
    /// <p>Tags for the resource.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListTagsForResourceInput  {
    /// <p>The resource's ARN.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
}
impl ListTagsForResourceInput {
    /// <p>The resource's ARN.</p>
    pub fn resource_arn(&self) -> std::option::Option<& str> {
        self.resource_arn.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StartReadSetImportJobInput  {
    /// <p>The read set's sequence store ID.</p>
    #[doc(hidden)]
    pub sequence_store_id: std::option::Option<std::string::String>,
    /// <p>A service role for the job.</p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>To ensure that jobs don't run multiple times, specify a unique token for each job.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
    /// <p>Source files to import.</p>
    #[doc(hidden)]
    pub sources: std::option::Option<std::vec::Vec<crate::model::StartReadSetImportJobSourceItem>>,
}
impl StartReadSetImportJobInput {
    /// <p>The read set's sequence store ID.</p>
    pub fn sequence_store_id(&self) -> std::option::Option<& str> {
        self.sequence_store_id.as_deref()
    }
    /// <p>A service role for the job.</p>
    pub fn role_arn(&self) -> std::option::Option<& str> {
        self.role_arn.as_deref()
    }
    /// <p>To ensure that jobs don't run multiple times, specify a unique token for each job.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
    /// <p>Source files to import.</p>
    pub fn sources(&self) -> std::option::Option<& [crate::model::StartReadSetImportJobSourceItem]> {
        self.sources.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StartReadSetExportJobInput  {
    /// <p>The read set's sequence store ID.</p>
    #[doc(hidden)]
    pub sequence_store_id: std::option::Option<std::string::String>,
    /// <p>A location for exported files in Amazon S3.</p>
    #[doc(hidden)]
    pub destination: std::option::Option<std::string::String>,
    /// <p>A service role for the job.</p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>To ensure that jobs don't run multiple times, specify a unique token for each job.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
    /// <p>Sources for the job.</p>
    #[doc(hidden)]
    pub sources: std::option::Option<std::vec::Vec<crate::model::ExportReadSet>>,
}
impl StartReadSetExportJobInput {
    /// <p>The read set's sequence store ID.</p>
    pub fn sequence_store_id(&self) -> std::option::Option<& str> {
        self.sequence_store_id.as_deref()
    }
    /// <p>A location for exported files in Amazon S3.</p>
    pub fn destination(&self) -> std::option::Option<& str> {
        self.destination.as_deref()
    }
    /// <p>A service role for the job.</p>
    pub fn role_arn(&self) -> std::option::Option<& str> {
        self.role_arn.as_deref()
    }
    /// <p>To ensure that jobs don't run multiple times, specify a unique token for each job.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
    /// <p>Sources for the job.</p>
    pub fn sources(&self) -> std::option::Option<& [crate::model::ExportReadSet]> {
        self.sources.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StartReadSetActivationJobInput  {
    /// <p>The read set's sequence store ID.</p>
    #[doc(hidden)]
    pub sequence_store_id: std::option::Option<std::string::String>,
    /// <p>To ensure that jobs don't run multiple times, specify a unique token for each job.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
    /// <p>The job's sources.</p>
    #[doc(hidden)]
    pub sources: std::option::Option<std::vec::Vec<crate::model::StartReadSetActivationJobSourceItem>>,
}
impl StartReadSetActivationJobInput {
    /// <p>The read set's sequence store ID.</p>
    pub fn sequence_store_id(&self) -> std::option::Option<& str> {
        self.sequence_store_id.as_deref()
    }
    /// <p>To ensure that jobs don't run multiple times, specify a unique token for each job.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
    /// <p>The job's sources.</p>
    pub fn sources(&self) -> std::option::Option<& [crate::model::StartReadSetActivationJobSourceItem]> {
        self.sources.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListReadSetImportJobsInput  {
    /// <p>The maximum number of jobs to return in one page of results.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The jobs' sequence store ID.</p>
    #[doc(hidden)]
    pub sequence_store_id: std::option::Option<std::string::String>,
    /// <p>A filter to apply to the list.</p>
    #[doc(hidden)]
    pub filter: std::option::Option<crate::model::ImportReadSetFilter>,
}
impl ListReadSetImportJobsInput {
    /// <p>The maximum number of jobs to return in one page of results.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>The jobs' sequence store ID.</p>
    pub fn sequence_store_id(&self) -> std::option::Option<& str> {
        self.sequence_store_id.as_deref()
    }
    /// <p>A filter to apply to the list.</p>
    pub fn filter(&self) -> std::option::Option<& crate::model::ImportReadSetFilter> {
        self.filter.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListReadSetExportJobsInput  {
    /// <p>The jobs' sequence store ID.</p>
    #[doc(hidden)]
    pub sequence_store_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of jobs to return in one page of results.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>A filter to apply to the list.</p>
    #[doc(hidden)]
    pub filter: std::option::Option<crate::model::ExportReadSetFilter>,
}
impl ListReadSetExportJobsInput {
    /// <p>The jobs' sequence store ID.</p>
    pub fn sequence_store_id(&self) -> std::option::Option<& str> {
        self.sequence_store_id.as_deref()
    }
    /// <p>The maximum number of jobs to return in one page of results.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>A filter to apply to the list.</p>
    pub fn filter(&self) -> std::option::Option<& crate::model::ExportReadSetFilter> {
        self.filter.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListReadSetActivationJobsInput  {
    /// <p>The read set's sequence store ID.</p>
    #[doc(hidden)]
    pub sequence_store_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of read set activation jobs to return in one page of results.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>A filter to apply to the list.</p>
    #[doc(hidden)]
    pub filter: std::option::Option<crate::model::ActivateReadSetFilter>,
}
impl ListReadSetActivationJobsInput {
    /// <p>The read set's sequence store ID.</p>
    pub fn sequence_store_id(&self) -> std::option::Option<& str> {
        self.sequence_store_id.as_deref()
    }
    /// <p>The maximum number of read set activation jobs to return in one page of results.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>A filter to apply to the list.</p>
    pub fn filter(&self) -> std::option::Option<& crate::model::ActivateReadSetFilter> {
        self.filter.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetReadSetImportJobInput  {
    /// <p>The job's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The job's sequence store ID.</p>
    #[doc(hidden)]
    pub sequence_store_id: std::option::Option<std::string::String>,
}
impl GetReadSetImportJobInput {
    /// <p>The job's ID.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
    /// <p>The job's sequence store ID.</p>
    pub fn sequence_store_id(&self) -> std::option::Option<& str> {
        self.sequence_store_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetReadSetExportJobInput  {
    /// <p>The job's sequence store ID.</p>
    #[doc(hidden)]
    pub sequence_store_id: std::option::Option<std::string::String>,
    /// <p>The job's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl GetReadSetExportJobInput {
    /// <p>The job's sequence store ID.</p>
    pub fn sequence_store_id(&self) -> std::option::Option<& str> {
        self.sequence_store_id.as_deref()
    }
    /// <p>The job's ID.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetReadSetActivationJobInput  {
    /// <p>The job's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The job's sequence store ID.</p>
    #[doc(hidden)]
    pub sequence_store_id: std::option::Option<std::string::String>,
}
impl GetReadSetActivationJobInput {
    /// <p>The job's ID.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
    /// <p>The job's sequence store ID.</p>
    pub fn sequence_store_id(&self) -> std::option::Option<& str> {
        self.sequence_store_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListSequenceStoresInput  {
    /// <p>The maximum number of stores to return in one page of results.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>A filter to apply to the list.</p>
    #[doc(hidden)]
    pub filter: std::option::Option<crate::model::SequenceStoreFilter>,
}
impl ListSequenceStoresInput {
    /// <p>The maximum number of stores to return in one page of results.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>A filter to apply to the list.</p>
    pub fn filter(&self) -> std::option::Option<& crate::model::SequenceStoreFilter> {
        self.filter.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateSequenceStoreInput  {
    /// <p>A name for the store.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A description for the store.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Server-side encryption (SSE) settings for the store.</p>
    #[doc(hidden)]
    pub sse_config: std::option::Option<crate::model::SseConfig>,
    /// <p>Tags for the store.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>To ensure that requests don't run multiple times, specify a unique token for each request.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl CreateSequenceStoreInput {
    /// <p>A name for the store.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>A description for the store.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p>Server-side encryption (SSE) settings for the store.</p>
    pub fn sse_config(&self) -> std::option::Option<& crate::model::SseConfig> {
        self.sse_config.as_ref()
    }
    /// <p>Tags for the store.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
    /// <p>To ensure that requests don't run multiple times, specify a unique token for each request.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteSequenceStoreInput  {
    /// <p>The sequence store's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl DeleteSequenceStoreInput {
    /// <p>The sequence store's ID.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetSequenceStoreInput  {
    /// <p>The store's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl GetSequenceStoreInput {
    /// <p>The store's ID.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetReadSetInput  {
    /// <p>The read set's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The read set's sequence store ID.</p>
    #[doc(hidden)]
    pub sequence_store_id: std::option::Option<std::string::String>,
    /// <p>The file to retrieve.</p>
    #[doc(hidden)]
    pub file: std::option::Option<crate::model::ReadSetFile>,
    /// <p>The part number to retrieve.</p>
    #[doc(hidden)]
    pub part_number: std::option::Option<i32>,
}
impl GetReadSetInput {
    /// <p>The read set's ID.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
    /// <p>The read set's sequence store ID.</p>
    pub fn sequence_store_id(&self) -> std::option::Option<& str> {
        self.sequence_store_id.as_deref()
    }
    /// <p>The file to retrieve.</p>
    pub fn file(&self) -> std::option::Option<& crate::model::ReadSetFile> {
        self.file.as_ref()
    }
    /// <p>The part number to retrieve.</p>
    pub fn part_number(&self) -> std::option::Option<i32> {
        self.part_number
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchDeleteReadSetInput  {
    /// <p>The read sets' IDs.</p>
    #[doc(hidden)]
    pub ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The read sets' sequence store ID.</p>
    #[doc(hidden)]
    pub sequence_store_id: std::option::Option<std::string::String>,
}
impl BatchDeleteReadSetInput {
    /// <p>The read sets' IDs.</p>
    pub fn ids(&self) -> std::option::Option<& [std::string::String]> {
        self.ids.as_deref()
    }
    /// <p>The read sets' sequence store ID.</p>
    pub fn sequence_store_id(&self) -> std::option::Option<& str> {
        self.sequence_store_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListReadSetsInput  {
    /// <p>The jobs' sequence store ID.</p>
    #[doc(hidden)]
    pub sequence_store_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of read sets to return in one page of results.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>A filter to apply to the list.</p>
    #[doc(hidden)]
    pub filter: std::option::Option<crate::model::ReadSetFilter>,
}
impl ListReadSetsInput {
    /// <p>The jobs' sequence store ID.</p>
    pub fn sequence_store_id(&self) -> std::option::Option<& str> {
        self.sequence_store_id.as_deref()
    }
    /// <p>The maximum number of read sets to return in one page of results.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>A filter to apply to the list.</p>
    pub fn filter(&self) -> std::option::Option<& crate::model::ReadSetFilter> {
        self.filter.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetReadSetMetadataInput  {
    /// <p>The read set's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The read set's sequence store ID.</p>
    #[doc(hidden)]
    pub sequence_store_id: std::option::Option<std::string::String>,
}
impl GetReadSetMetadataInput {
    /// <p>The read set's ID.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
    /// <p>The read set's sequence store ID.</p>
    pub fn sequence_store_id(&self) -> std::option::Option<& str> {
        self.sequence_store_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CancelRunInput  {
    /// <p>The run's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl CancelRunInput {
    /// <p>The run's ID.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListRunsInput  {
    /// <p>Filter the list by run name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Filter the list by run group ID.</p>
    #[doc(hidden)]
    pub run_group_id: std::option::Option<std::string::String>,
    /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
    #[doc(hidden)]
    pub starting_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of runs to return in one page of results.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListRunsInput {
    /// <p>Filter the list by run name.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>Filter the list by run group ID.</p>
    pub fn run_group_id(&self) -> std::option::Option<& str> {
        self.run_group_id.as_deref()
    }
    /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
    pub fn starting_token(&self) -> std::option::Option<& str> {
        self.starting_token.as_deref()
    }
    /// <p>The maximum number of runs to return in one page of results.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StartRunInput  {
    /// <p>The run's workflow ID.</p>
    #[doc(hidden)]
    pub workflow_id: std::option::Option<std::string::String>,
    /// <p>The run's workflows type.</p>
    #[doc(hidden)]
    pub workflow_type: std::option::Option<crate::model::WorkflowType>,
    /// <p>The run's ID.</p>
    #[doc(hidden)]
    pub run_id: std::option::Option<std::string::String>,
    /// <p>A service role for the run.</p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>A name for the run.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The run's group ID.</p>
    #[doc(hidden)]
    pub run_group_id: std::option::Option<std::string::String>,
    /// <p>A priority for the run.</p>
    #[doc(hidden)]
    pub priority: std::option::Option<i32>,
    /// <p>Parameters for the run.</p>
    #[doc(hidden)]
    pub parameters: std::option::Option<aws_smithy_types::Document>,
    /// <p>A storage capacity for the run.</p>
    #[doc(hidden)]
    pub storage_capacity: std::option::Option<i32>,
    /// <p>An output URI for the run.</p>
    #[doc(hidden)]
    pub output_uri: std::option::Option<std::string::String>,
    /// <p>A log level for the run.</p>
    #[doc(hidden)]
    pub log_level: std::option::Option<crate::model::RunLogLevel>,
    /// <p>Tags for the run.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A request ID for the run.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
}
impl StartRunInput {
    /// <p>The run's workflow ID.</p>
    pub fn workflow_id(&self) -> std::option::Option<& str> {
        self.workflow_id.as_deref()
    }
    /// <p>The run's workflows type.</p>
    pub fn workflow_type(&self) -> std::option::Option<& crate::model::WorkflowType> {
        self.workflow_type.as_ref()
    }
    /// <p>The run's ID.</p>
    pub fn run_id(&self) -> std::option::Option<& str> {
        self.run_id.as_deref()
    }
    /// <p>A service role for the run.</p>
    pub fn role_arn(&self) -> std::option::Option<& str> {
        self.role_arn.as_deref()
    }
    /// <p>A name for the run.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>The run's group ID.</p>
    pub fn run_group_id(&self) -> std::option::Option<& str> {
        self.run_group_id.as_deref()
    }
    /// <p>A priority for the run.</p>
    pub fn priority(&self) -> std::option::Option<i32> {
        self.priority
    }
    /// <p>Parameters for the run.</p>
    pub fn parameters(&self) -> std::option::Option<& aws_smithy_types::Document> {
        self.parameters.as_ref()
    }
    /// <p>A storage capacity for the run.</p>
    pub fn storage_capacity(&self) -> std::option::Option<i32> {
        self.storage_capacity
    }
    /// <p>An output URI for the run.</p>
    pub fn output_uri(&self) -> std::option::Option<& str> {
        self.output_uri.as_deref()
    }
    /// <p>A log level for the run.</p>
    pub fn log_level(&self) -> std::option::Option<& crate::model::RunLogLevel> {
        self.log_level.as_ref()
    }
    /// <p>Tags for the run.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
    /// <p>A request ID for the run.</p>
    pub fn request_id(&self) -> std::option::Option<& str> {
        self.request_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteRunInput  {
    /// <p>The run's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl DeleteRunInput {
    /// <p>The run's ID.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetRunInput  {
    /// <p>The run's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The run's export format.</p>
    #[doc(hidden)]
    pub export: std::option::Option<std::vec::Vec<crate::model::RunExport>>,
}
impl GetRunInput {
    /// <p>The run's ID.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
    /// <p>The run's export format.</p>
    pub fn export(&self) -> std::option::Option<& [crate::model::RunExport]> {
        self.export.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListRunTasksInput  {
    /// <p>The run's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>Filter the list by status.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::TaskStatus>,
    /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
    #[doc(hidden)]
    pub starting_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of run tasks to return in one page of results.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListRunTasksInput {
    /// <p>The run's ID.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
    /// <p>Filter the list by status.</p>
    pub fn status(&self) -> std::option::Option<& crate::model::TaskStatus> {
        self.status.as_ref()
    }
    /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
    pub fn starting_token(&self) -> std::option::Option<& str> {
        self.starting_token.as_deref()
    }
    /// <p>The maximum number of run tasks to return in one page of results.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetRunTaskInput  {
    /// <p>The task's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The task's ID.</p>
    #[doc(hidden)]
    pub task_id: std::option::Option<std::string::String>,
}
impl GetRunTaskInput {
    /// <p>The task's ID.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
    /// <p>The task's ID.</p>
    pub fn task_id(&self) -> std::option::Option<& str> {
        self.task_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListRunGroupsInput  {
    /// <p>The run groups' name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
    #[doc(hidden)]
    pub starting_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of run groups to return in one page of results.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListRunGroupsInput {
    /// <p>The run groups' name.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
    pub fn starting_token(&self) -> std::option::Option<& str> {
        self.starting_token.as_deref()
    }
    /// <p>The maximum number of run groups to return in one page of results.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateRunGroupInput  {
    /// <p>A name for the group.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The maximum number of CPUs to use in the group.</p>
    #[doc(hidden)]
    pub max_cpus: std::option::Option<i32>,
    /// <p>The maximum number of concurrent runs for the group.</p>
    #[doc(hidden)]
    pub max_runs: std::option::Option<i32>,
    /// <p>A max duration for the group.</p>
    #[doc(hidden)]
    pub max_duration: std::option::Option<i32>,
    /// <p>Tags for the group.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A request ID for the group.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
}
impl CreateRunGroupInput {
    /// <p>A name for the group.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>The maximum number of CPUs to use in the group.</p>
    pub fn max_cpus(&self) -> std::option::Option<i32> {
        self.max_cpus
    }
    /// <p>The maximum number of concurrent runs for the group.</p>
    pub fn max_runs(&self) -> std::option::Option<i32> {
        self.max_runs
    }
    /// <p>A max duration for the group.</p>
    pub fn max_duration(&self) -> std::option::Option<i32> {
        self.max_duration
    }
    /// <p>Tags for the group.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
    /// <p>A request ID for the group.</p>
    pub fn request_id(&self) -> std::option::Option<& str> {
        self.request_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteRunGroupInput  {
    /// <p>The run group's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl DeleteRunGroupInput {
    /// <p>The run group's ID.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateRunGroupInput  {
    /// <p>The group's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>A name for the group.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The maximum number of CPUs to use.</p>
    #[doc(hidden)]
    pub max_cpus: std::option::Option<i32>,
    /// <p>The maximum number of concurrent runs for the group.</p>
    #[doc(hidden)]
    pub max_runs: std::option::Option<i32>,
    /// <p>The maximum amount of time to run.</p>
    #[doc(hidden)]
    pub max_duration: std::option::Option<i32>,
}
impl UpdateRunGroupInput {
    /// <p>The group's ID.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
    /// <p>A name for the group.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>The maximum number of CPUs to use.</p>
    pub fn max_cpus(&self) -> std::option::Option<i32> {
        self.max_cpus
    }
    /// <p>The maximum number of concurrent runs for the group.</p>
    pub fn max_runs(&self) -> std::option::Option<i32> {
        self.max_runs
    }
    /// <p>The maximum amount of time to run.</p>
    pub fn max_duration(&self) -> std::option::Option<i32> {
        self.max_duration
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetRunGroupInput  {
    /// <p>The group's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl GetRunGroupInput {
    /// <p>The group's ID.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StartReferenceImportJobInput  {
    /// <p>The job's reference store ID.</p>
    #[doc(hidden)]
    pub reference_store_id: std::option::Option<std::string::String>,
    /// <p>A service role for the job.</p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>To ensure that jobs don't run multiple times, specify a unique token for each job.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
    /// <p>Sources for the job.</p>
    #[doc(hidden)]
    pub sources: std::option::Option<std::vec::Vec<crate::model::StartReferenceImportJobSourceItem>>,
}
impl StartReferenceImportJobInput {
    /// <p>The job's reference store ID.</p>
    pub fn reference_store_id(&self) -> std::option::Option<& str> {
        self.reference_store_id.as_deref()
    }
    /// <p>A service role for the job.</p>
    pub fn role_arn(&self) -> std::option::Option<& str> {
        self.role_arn.as_deref()
    }
    /// <p>To ensure that jobs don't run multiple times, specify a unique token for each job.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
    /// <p>Sources for the job.</p>
    pub fn sources(&self) -> std::option::Option<& [crate::model::StartReferenceImportJobSourceItem]> {
        self.sources.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListReferenceImportJobsInput  {
    /// <p>The maximum number of jobs to return in one page of results.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The job's reference store ID.</p>
    #[doc(hidden)]
    pub reference_store_id: std::option::Option<std::string::String>,
    /// <p>A filter to apply to the list.</p>
    #[doc(hidden)]
    pub filter: std::option::Option<crate::model::ImportReferenceFilter>,
}
impl ListReferenceImportJobsInput {
    /// <p>The maximum number of jobs to return in one page of results.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>The job's reference store ID.</p>
    pub fn reference_store_id(&self) -> std::option::Option<& str> {
        self.reference_store_id.as_deref()
    }
    /// <p>A filter to apply to the list.</p>
    pub fn filter(&self) -> std::option::Option<& crate::model::ImportReferenceFilter> {
        self.filter.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetReferenceImportJobInput  {
    /// <p>The job's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The job's reference store ID.</p>
    #[doc(hidden)]
    pub reference_store_id: std::option::Option<std::string::String>,
}
impl GetReferenceImportJobInput {
    /// <p>The job's ID.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
    /// <p>The job's reference store ID.</p>
    pub fn reference_store_id(&self) -> std::option::Option<& str> {
        self.reference_store_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListReferenceStoresInput  {
    /// <p>The maximum number of stores to return in one page of results.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>A filter to apply to the list.</p>
    #[doc(hidden)]
    pub filter: std::option::Option<crate::model::ReferenceStoreFilter>,
}
impl ListReferenceStoresInput {
    /// <p>The maximum number of stores to return in one page of results.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>A filter to apply to the list.</p>
    pub fn filter(&self) -> std::option::Option<& crate::model::ReferenceStoreFilter> {
        self.filter.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateReferenceStoreInput  {
    /// <p>A name for the store.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A description for the store.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Server-side encryption (SSE) settings for the store.</p>
    #[doc(hidden)]
    pub sse_config: std::option::Option<crate::model::SseConfig>,
    /// <p>Tags for the store.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>To ensure that requests don't run multiple times, specify a unique token for each request.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl CreateReferenceStoreInput {
    /// <p>A name for the store.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>A description for the store.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p>Server-side encryption (SSE) settings for the store.</p>
    pub fn sse_config(&self) -> std::option::Option<& crate::model::SseConfig> {
        self.sse_config.as_ref()
    }
    /// <p>Tags for the store.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
    /// <p>To ensure that requests don't run multiple times, specify a unique token for each request.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteReferenceStoreInput  {
    /// <p>The store's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl DeleteReferenceStoreInput {
    /// <p>The store's ID.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetReferenceStoreInput  {
    /// <p>The store's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl GetReferenceStoreInput {
    /// <p>The store's ID.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetReferenceInput  {
    /// <p>The reference's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The reference's store ID.</p>
    #[doc(hidden)]
    pub reference_store_id: std::option::Option<std::string::String>,
    /// <p>The range to retrieve.</p>
    #[doc(hidden)]
    pub range: std::option::Option<std::string::String>,
    /// <p>The part number to retrieve.</p>
    #[doc(hidden)]
    pub part_number: std::option::Option<i32>,
    /// <p>The file to retrieve.</p>
    #[doc(hidden)]
    pub file: std::option::Option<crate::model::ReferenceFile>,
}
impl GetReferenceInput {
    /// <p>The reference's ID.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
    /// <p>The reference's store ID.</p>
    pub fn reference_store_id(&self) -> std::option::Option<& str> {
        self.reference_store_id.as_deref()
    }
    /// <p>The range to retrieve.</p>
    pub fn range(&self) -> std::option::Option<& str> {
        self.range.as_deref()
    }
    /// <p>The part number to retrieve.</p>
    pub fn part_number(&self) -> std::option::Option<i32> {
        self.part_number
    }
    /// <p>The file to retrieve.</p>
    pub fn file(&self) -> std::option::Option<& crate::model::ReferenceFile> {
        self.file.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListReferencesInput  {
    /// <p>The references' reference store ID.</p>
    #[doc(hidden)]
    pub reference_store_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of references to return in one page of results.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>A filter to apply to the list.</p>
    #[doc(hidden)]
    pub filter: std::option::Option<crate::model::ReferenceFilter>,
}
impl ListReferencesInput {
    /// <p>The references' reference store ID.</p>
    pub fn reference_store_id(&self) -> std::option::Option<& str> {
        self.reference_store_id.as_deref()
    }
    /// <p>The maximum number of references to return in one page of results.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>A filter to apply to the list.</p>
    pub fn filter(&self) -> std::option::Option<& crate::model::ReferenceFilter> {
        self.filter.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteReferenceInput  {
    /// <p>The reference's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The reference's store ID.</p>
    #[doc(hidden)]
    pub reference_store_id: std::option::Option<std::string::String>,
}
impl DeleteReferenceInput {
    /// <p>The reference's ID.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
    /// <p>The reference's store ID.</p>
    pub fn reference_store_id(&self) -> std::option::Option<& str> {
        self.reference_store_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetReferenceMetadataInput  {
    /// <p>The reference's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The reference's reference store ID.</p>
    #[doc(hidden)]
    pub reference_store_id: std::option::Option<std::string::String>,
}
impl GetReferenceMetadataInput {
    /// <p>The reference's ID.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
    /// <p>The reference's reference store ID.</p>
    pub fn reference_store_id(&self) -> std::option::Option<& str> {
        self.reference_store_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListAnnotationStoresInput  {
    /// <p>IDs of stores to list.</p>
    #[doc(hidden)]
    pub ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The maximum number of stores to return in one page of results.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>A filter to apply to the list.</p>
    #[doc(hidden)]
    pub filter: std::option::Option<crate::model::ListAnnotationStoresFilter>,
}
impl ListAnnotationStoresInput {
    /// <p>IDs of stores to list.</p>
    pub fn ids(&self) -> std::option::Option<& [std::string::String]> {
        self.ids.as_deref()
    }
    /// <p>The maximum number of stores to return in one page of results.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>A filter to apply to the list.</p>
    pub fn filter(&self) -> std::option::Option<& crate::model::ListAnnotationStoresFilter> {
        self.filter.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateAnnotationStoreInput  {
    /// <p>The genome reference for the store's annotations.</p>
    #[doc(hidden)]
    pub reference: std::option::Option<crate::model::ReferenceItem>,
    /// <p>A name for the store.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A description for the store.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Tags for the store.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Server-side encryption (SSE) settings for the store.</p>
    #[doc(hidden)]
    pub sse_config: std::option::Option<crate::model::SseConfig>,
    /// <p>The annotation file format of the store.</p>
    #[doc(hidden)]
    pub store_format: std::option::Option<crate::model::StoreFormat>,
    /// <p>File parsing options for the annotation store.</p>
    #[doc(hidden)]
    pub store_options: std::option::Option<crate::model::StoreOptions>,
}
impl CreateAnnotationStoreInput {
    /// <p>The genome reference for the store's annotations.</p>
    pub fn reference(&self) -> std::option::Option<& crate::model::ReferenceItem> {
        self.reference.as_ref()
    }
    /// <p>A name for the store.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>A description for the store.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p>Tags for the store.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
    /// <p>Server-side encryption (SSE) settings for the store.</p>
    pub fn sse_config(&self) -> std::option::Option<& crate::model::SseConfig> {
        self.sse_config.as_ref()
    }
    /// <p>The annotation file format of the store.</p>
    pub fn store_format(&self) -> std::option::Option<& crate::model::StoreFormat> {
        self.store_format.as_ref()
    }
    /// <p>File parsing options for the annotation store.</p>
    pub fn store_options(&self) -> std::option::Option<& crate::model::StoreOptions> {
        self.store_options.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteAnnotationStoreInput  {
    /// <p>The store's name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Whether to force deletion.</p>
    #[doc(hidden)]
    pub force: std::option::Option<bool>,
}
impl DeleteAnnotationStoreInput {
    /// <p>The store's name.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>Whether to force deletion.</p>
    pub fn force(&self) -> std::option::Option<bool> {
        self.force
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateAnnotationStoreInput  {
    /// <p>A name for the store.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A description for the store.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
}
impl UpdateAnnotationStoreInput {
    /// <p>A name for the store.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>A description for the store.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetAnnotationStoreInput  {
    /// <p>The store's name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl GetAnnotationStoreInput {
    /// <p>The store's name.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListAnnotationImportJobsInput  {
    /// <p>The maximum number of jobs to return in one page of results.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>IDs of annotation import jobs to retrieve.</p>
    #[doc(hidden)]
    pub ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>A filter to apply to the list.</p>
    #[doc(hidden)]
    pub filter: std::option::Option<crate::model::ListAnnotationImportJobsFilter>,
}
impl ListAnnotationImportJobsInput {
    /// <p>The maximum number of jobs to return in one page of results.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>IDs of annotation import jobs to retrieve.</p>
    pub fn ids(&self) -> std::option::Option<& [std::string::String]> {
        self.ids.as_deref()
    }
    /// <p>Specify the pagination token from a previous request to retrieve the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>A filter to apply to the list.</p>
    pub fn filter(&self) -> std::option::Option<& crate::model::ListAnnotationImportJobsFilter> {
        self.filter.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StartAnnotationImportJobInput  {
    /// <p>A destination annotation store for the job.</p>
    #[doc(hidden)]
    pub destination_name: std::option::Option<std::string::String>,
    /// <p>A service role for the job.</p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>Items to import.</p>
    #[doc(hidden)]
    pub items: std::option::Option<std::vec::Vec<crate::model::AnnotationImportItemSource>>,
    /// <p>Formatting options for the annotation file.</p>
    #[doc(hidden)]
    pub format_options: std::option::Option<crate::model::FormatOptions>,
    /// <p>The job's left normalization setting.</p>
    #[doc(hidden)]
    pub run_left_normalization: std::option::Option<bool>,
}
impl StartAnnotationImportJobInput {
    /// <p>A destination annotation store for the job.</p>
    pub fn destination_name(&self) -> std::option::Option<& str> {
        self.destination_name.as_deref()
    }
    /// <p>A service role for the job.</p>
    pub fn role_arn(&self) -> std::option::Option<& str> {
        self.role_arn.as_deref()
    }
    /// <p>Items to import.</p>
    pub fn items(&self) -> std::option::Option<& [crate::model::AnnotationImportItemSource]> {
        self.items.as_deref()
    }
    /// <p>Formatting options for the annotation file.</p>
    pub fn format_options(&self) -> std::option::Option<& crate::model::FormatOptions> {
        self.format_options.as_ref()
    }
    /// <p>The job's left normalization setting.</p>
    pub fn run_left_normalization(&self) -> std::option::Option<bool> {
        self.run_left_normalization
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CancelAnnotationImportJobInput  {
    /// <p>The job's ID.</p>
    #[doc(hidden)]
    pub job_id: std::option::Option<std::string::String>,
}
impl CancelAnnotationImportJobInput {
    /// <p>The job's ID.</p>
    pub fn job_id(&self) -> std::option::Option<& str> {
        self.job_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetAnnotationImportJobInput  {
    /// <p>The job's ID.</p>
    #[doc(hidden)]
    pub job_id: std::option::Option<std::string::String>,
}
impl GetAnnotationImportJobInput {
    /// <p>The job's ID.</p>
    pub fn job_id(&self) -> std::option::Option<& str> {
        self.job_id.as_deref()
    }
}

