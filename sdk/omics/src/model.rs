// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A workflow.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WorkflowListItem {
    /// <p>The workflow's ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The workflow's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The workflow's name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The workflow's status.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::WorkflowStatus>,
    /// <p>The workflow's type.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::WorkflowType>,
    /// <p>The workflow's digest.</p>
    #[doc(hidden)]
    pub digest: std::option::Option<std::string::String>,
    /// <p>When the workflow was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl WorkflowListItem {
    /// <p>The workflow's ARN.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The workflow's ID.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The workflow's name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The workflow's status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::WorkflowStatus> {
        self.status.as_ref()
    }
    /// <p>The workflow's type.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::WorkflowType> {
        self.r#type.as_ref()
    }
    /// <p>The workflow's digest.</p>
    pub fn digest(&self) -> std::option::Option<&str> {
        self.digest.as_deref()
    }
    /// <p>When the workflow was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
}
impl WorkflowListItem {
    /// Creates a new builder-style object to manufacture [`WorkflowListItem`](crate::model::WorkflowListItem).
    pub fn builder() -> crate::model::workflow_list_item::Builder {
        crate::model::workflow_list_item::Builder::default()
    }
}

/// See [`WorkflowListItem`](crate::model::WorkflowListItem).
pub mod workflow_list_item {

    /// A builder for [`WorkflowListItem`](crate::model::WorkflowListItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::WorkflowStatus>,
        pub(crate) r#type: std::option::Option<crate::model::WorkflowType>,
        pub(crate) digest: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The workflow's ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The workflow's ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The workflow's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The workflow's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The workflow's name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The workflow's name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The workflow's status.</p>
        pub fn status(mut self, input: crate::model::WorkflowStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The workflow's status.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::WorkflowStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The workflow's type.</p>
        pub fn r#type(mut self, input: crate::model::WorkflowType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The workflow's type.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::WorkflowType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The workflow's digest.</p>
        pub fn digest(mut self, input: impl Into<std::string::String>) -> Self {
            self.digest = Some(input.into());
            self
        }
        /// <p>The workflow's digest.</p>
        pub fn set_digest(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.digest = input;
            self
        }
        /// <p>When the workflow was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the workflow was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkflowListItem`](crate::model::WorkflowListItem).
        pub fn build(self) -> crate::model::WorkflowListItem {
            crate::model::WorkflowListItem {
                arn: self.arn,
                id: self.id,
                name: self.name,
                status: self.status,
                r#type: self.r#type,
                digest: self.digest,
                creation_time: self.creation_time,
            }
        }
    }
}

/// When writing a match expression against `WorkflowType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let workflowtype = unimplemented!();
/// match workflowtype {
///     WorkflowType::Private => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `workflowtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `WorkflowType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `WorkflowType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `WorkflowType::NewFeature` is defined.
/// Specifically, when `workflowtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `WorkflowType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WorkflowType {
    #[allow(missing_docs)] // documentation missing in model
    Private,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for WorkflowType {
    fn from(s: &str) -> Self {
        match s {
            "PRIVATE" => WorkflowType::Private,
            other => WorkflowType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for WorkflowType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WorkflowType::from(s))
    }
}
impl WorkflowType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WorkflowType::Private => "PRIVATE",
            WorkflowType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["PRIVATE"]
    }
}
impl AsRef<str> for WorkflowType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `WorkflowStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let workflowstatus = unimplemented!();
/// match workflowstatus {
///     WorkflowStatus::Active => { /* ... */ },
///     WorkflowStatus::Creating => { /* ... */ },
///     WorkflowStatus::Deleted => { /* ... */ },
///     WorkflowStatus::Failed => { /* ... */ },
///     WorkflowStatus::Updating => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `workflowstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `WorkflowStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `WorkflowStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `WorkflowStatus::NewFeature` is defined.
/// Specifically, when `workflowstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `WorkflowStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WorkflowStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for WorkflowStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => WorkflowStatus::Active,
            "CREATING" => WorkflowStatus::Creating,
            "DELETED" => WorkflowStatus::Deleted,
            "FAILED" => WorkflowStatus::Failed,
            "UPDATING" => WorkflowStatus::Updating,
            other => WorkflowStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for WorkflowStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WorkflowStatus::from(s))
    }
}
impl WorkflowStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WorkflowStatus::Active => "ACTIVE",
            WorkflowStatus::Creating => "CREATING",
            WorkflowStatus::Deleted => "DELETED",
            WorkflowStatus::Failed => "FAILED",
            WorkflowStatus::Updating => "UPDATING",
            WorkflowStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "CREATING", "DELETED", "FAILED", "UPDATING"]
    }
}
impl AsRef<str> for WorkflowStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A workflow parameter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WorkflowParameter {
    /// <p>The parameter's description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Whether the parameter is optional.</p>
    #[doc(hidden)]
    pub optional: std::option::Option<bool>,
}
impl WorkflowParameter {
    /// <p>The parameter's description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Whether the parameter is optional.</p>
    pub fn optional(&self) -> std::option::Option<bool> {
        self.optional
    }
}
impl WorkflowParameter {
    /// Creates a new builder-style object to manufacture [`WorkflowParameter`](crate::model::WorkflowParameter).
    pub fn builder() -> crate::model::workflow_parameter::Builder {
        crate::model::workflow_parameter::Builder::default()
    }
}

/// See [`WorkflowParameter`](crate::model::WorkflowParameter).
pub mod workflow_parameter {

    /// A builder for [`WorkflowParameter`](crate::model::WorkflowParameter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) optional: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The parameter's description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The parameter's description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Whether the parameter is optional.</p>
        pub fn optional(mut self, input: bool) -> Self {
            self.optional = Some(input);
            self
        }
        /// <p>Whether the parameter is optional.</p>
        pub fn set_optional(mut self, input: std::option::Option<bool>) -> Self {
            self.optional = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkflowParameter`](crate::model::WorkflowParameter).
        pub fn build(self) -> crate::model::WorkflowParameter {
            crate::model::WorkflowParameter {
                description: self.description,
                optional: self.optional,
            }
        }
    }
}

/// When writing a match expression against `WorkflowEngine`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let workflowengine = unimplemented!();
/// match workflowengine {
///     WorkflowEngine::Nextflow => { /* ... */ },
///     WorkflowEngine::Wdl => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `workflowengine` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `WorkflowEngine::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `WorkflowEngine::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `WorkflowEngine::NewFeature` is defined.
/// Specifically, when `workflowengine` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `WorkflowEngine::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WorkflowEngine {
    #[allow(missing_docs)] // documentation missing in model
    Nextflow,
    #[allow(missing_docs)] // documentation missing in model
    Wdl,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for WorkflowEngine {
    fn from(s: &str) -> Self {
        match s {
            "NEXTFLOW" => WorkflowEngine::Nextflow,
            "WDL" => WorkflowEngine::Wdl,
            other => WorkflowEngine::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for WorkflowEngine {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WorkflowEngine::from(s))
    }
}
impl WorkflowEngine {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WorkflowEngine::Nextflow => "NEXTFLOW",
            WorkflowEngine::Wdl => "WDL",
            WorkflowEngine::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["NEXTFLOW", "WDL"]
    }
}
impl AsRef<str> for WorkflowEngine {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `WorkflowExport`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let workflowexport = unimplemented!();
/// match workflowexport {
///     WorkflowExport::Definition => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `workflowexport` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `WorkflowExport::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `WorkflowExport::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `WorkflowExport::NewFeature` is defined.
/// Specifically, when `workflowexport` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `WorkflowExport::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WorkflowExport {
    #[allow(missing_docs)] // documentation missing in model
    Definition,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for WorkflowExport {
    fn from(s: &str) -> Self {
        match s {
            "DEFINITION" => WorkflowExport::Definition,
            other => WorkflowExport::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for WorkflowExport {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WorkflowExport::from(s))
    }
}
impl WorkflowExport {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WorkflowExport::Definition => "DEFINITION",
            WorkflowExport::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DEFINITION"]
    }
}
impl AsRef<str> for WorkflowExport {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A variant store.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VariantStoreItem {
    /// <p>The store's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The store's genome reference.</p>
    #[doc(hidden)]
    pub reference: std::option::Option<crate::model::ReferenceItem>,
    /// <p>The store's status.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::StoreStatus>,
    /// <p>The store's ARN.</p>
    #[doc(hidden)]
    pub store_arn: std::option::Option<std::string::String>,
    /// <p>The store's name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The store's description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The store's server-side encryption (SSE) settings.</p>
    #[doc(hidden)]
    pub sse_config: std::option::Option<crate::model::SseConfig>,
    /// <p>When the store was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>When the store was updated.</p>
    #[doc(hidden)]
    pub update_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The store's status message.</p>
    #[doc(hidden)]
    pub status_message: std::option::Option<std::string::String>,
    /// <p>The store's size in bytes.</p>
    #[doc(hidden)]
    pub store_size_bytes: std::option::Option<i64>,
}
impl VariantStoreItem {
    /// <p>The store's ID.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The store's genome reference.</p>
    pub fn reference(&self) -> std::option::Option<&crate::model::ReferenceItem> {
        self.reference.as_ref()
    }
    /// <p>The store's status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::StoreStatus> {
        self.status.as_ref()
    }
    /// <p>The store's ARN.</p>
    pub fn store_arn(&self) -> std::option::Option<&str> {
        self.store_arn.as_deref()
    }
    /// <p>The store's name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The store's description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The store's server-side encryption (SSE) settings.</p>
    pub fn sse_config(&self) -> std::option::Option<&crate::model::SseConfig> {
        self.sse_config.as_ref()
    }
    /// <p>When the store was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>When the store was updated.</p>
    pub fn update_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.update_time.as_ref()
    }
    /// <p>The store's status message.</p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
    /// <p>The store's size in bytes.</p>
    pub fn store_size_bytes(&self) -> std::option::Option<i64> {
        self.store_size_bytes
    }
}
impl VariantStoreItem {
    /// Creates a new builder-style object to manufacture [`VariantStoreItem`](crate::model::VariantStoreItem).
    pub fn builder() -> crate::model::variant_store_item::Builder {
        crate::model::variant_store_item::Builder::default()
    }
}

/// See [`VariantStoreItem`](crate::model::VariantStoreItem).
pub mod variant_store_item {

    /// A builder for [`VariantStoreItem`](crate::model::VariantStoreItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) reference: std::option::Option<crate::model::ReferenceItem>,
        pub(crate) status: std::option::Option<crate::model::StoreStatus>,
        pub(crate) store_arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) sse_config: std::option::Option<crate::model::SseConfig>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) store_size_bytes: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The store's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The store's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The store's genome reference.</p>
        pub fn reference(mut self, input: crate::model::ReferenceItem) -> Self {
            self.reference = Some(input);
            self
        }
        /// <p>The store's genome reference.</p>
        pub fn set_reference(
            mut self,
            input: std::option::Option<crate::model::ReferenceItem>,
        ) -> Self {
            self.reference = input;
            self
        }
        /// <p>The store's status.</p>
        pub fn status(mut self, input: crate::model::StoreStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The store's status.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::StoreStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p>The store's ARN.</p>
        pub fn store_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.store_arn = Some(input.into());
            self
        }
        /// <p>The store's ARN.</p>
        pub fn set_store_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.store_arn = input;
            self
        }
        /// <p>The store's name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The store's name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The store's description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The store's description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The store's server-side encryption (SSE) settings.</p>
        pub fn sse_config(mut self, input: crate::model::SseConfig) -> Self {
            self.sse_config = Some(input);
            self
        }
        /// <p>The store's server-side encryption (SSE) settings.</p>
        pub fn set_sse_config(
            mut self,
            input: std::option::Option<crate::model::SseConfig>,
        ) -> Self {
            self.sse_config = input;
            self
        }
        /// <p>When the store was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the store was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>When the store was updated.</p>
        pub fn update_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_time = Some(input);
            self
        }
        /// <p>When the store was updated.</p>
        pub fn set_update_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.update_time = input;
            self
        }
        /// <p>The store's status message.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>The store's status message.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>The store's size in bytes.</p>
        pub fn store_size_bytes(mut self, input: i64) -> Self {
            self.store_size_bytes = Some(input);
            self
        }
        /// <p>The store's size in bytes.</p>
        pub fn set_store_size_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.store_size_bytes = input;
            self
        }
        /// Consumes the builder and constructs a [`VariantStoreItem`](crate::model::VariantStoreItem).
        pub fn build(self) -> crate::model::VariantStoreItem {
            crate::model::VariantStoreItem {
                id: self.id,
                reference: self.reference,
                status: self.status,
                store_arn: self.store_arn,
                name: self.name,
                description: self.description,
                sse_config: self.sse_config,
                creation_time: self.creation_time,
                update_time: self.update_time,
                status_message: self.status_message,
                store_size_bytes: self.store_size_bytes,
            }
        }
    }
}

/// <p>Server-side encryption (SSE) settings for a store.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SseConfig {
    /// <p>The encryption type.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::EncryptionType>,
    /// <p>An encryption key ARN.</p>
    #[doc(hidden)]
    pub key_arn: std::option::Option<std::string::String>,
}
impl SseConfig {
    /// <p>The encryption type.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::EncryptionType> {
        self.r#type.as_ref()
    }
    /// <p>An encryption key ARN.</p>
    pub fn key_arn(&self) -> std::option::Option<&str> {
        self.key_arn.as_deref()
    }
}
impl SseConfig {
    /// Creates a new builder-style object to manufacture [`SseConfig`](crate::model::SseConfig).
    pub fn builder() -> crate::model::sse_config::Builder {
        crate::model::sse_config::Builder::default()
    }
}

/// See [`SseConfig`](crate::model::SseConfig).
pub mod sse_config {

    /// A builder for [`SseConfig`](crate::model::SseConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::EncryptionType>,
        pub(crate) key_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The encryption type.</p>
        pub fn r#type(mut self, input: crate::model::EncryptionType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The encryption type.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::EncryptionType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>An encryption key ARN.</p>
        pub fn key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_arn = Some(input.into());
            self
        }
        /// <p>An encryption key ARN.</p>
        pub fn set_key_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`SseConfig`](crate::model::SseConfig).
        pub fn build(self) -> crate::model::SseConfig {
            crate::model::SseConfig {
                r#type: self.r#type,
                key_arn: self.key_arn,
            }
        }
    }
}

/// When writing a match expression against `EncryptionType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let encryptiontype = unimplemented!();
/// match encryptiontype {
///     EncryptionType::Kms => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `encryptiontype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EncryptionType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EncryptionType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EncryptionType::NewFeature` is defined.
/// Specifically, when `encryptiontype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EncryptionType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EncryptionType {
    /// KMS
    Kms,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EncryptionType {
    fn from(s: &str) -> Self {
        match s {
            "KMS" => EncryptionType::Kms,
            other => EncryptionType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for EncryptionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EncryptionType::from(s))
    }
}
impl EncryptionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EncryptionType::Kms => "KMS",
            EncryptionType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["KMS"]
    }
}
impl AsRef<str> for EncryptionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `StoreStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let storestatus = unimplemented!();
/// match storestatus {
///     StoreStatus::Active => { /* ... */ },
///     StoreStatus::Creating => { /* ... */ },
///     StoreStatus::Deleting => { /* ... */ },
///     StoreStatus::Failed => { /* ... */ },
///     StoreStatus::Updating => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `storestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StoreStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StoreStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StoreStatus::NewFeature` is defined.
/// Specifically, when `storestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StoreStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StoreStatus {
    /// The Store is active
    Active,
    /// The Store is being created
    Creating,
    /// The Store is deleting
    Deleting,
    /// The Store creation failed
    Failed,
    /// The Store is updating
    Updating,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StoreStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => StoreStatus::Active,
            "CREATING" => StoreStatus::Creating,
            "DELETING" => StoreStatus::Deleting,
            "FAILED" => StoreStatus::Failed,
            "UPDATING" => StoreStatus::Updating,
            other => StoreStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for StoreStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StoreStatus::from(s))
    }
}
impl StoreStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StoreStatus::Active => "ACTIVE",
            StoreStatus::Creating => "CREATING",
            StoreStatus::Deleting => "DELETING",
            StoreStatus::Failed => "FAILED",
            StoreStatus::Updating => "UPDATING",
            StoreStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "CREATING", "DELETING", "FAILED", "UPDATING"]
    }
}
impl AsRef<str> for StoreStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A genome reference.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum ReferenceItem {
    /// <p>The reference's ARN.</p>
    ReferenceArn(std::string::String),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl ReferenceItem {
    #[allow(irrefutable_let_patterns)]
    /// Tries to convert the enum instance into [`ReferenceArn`](crate::model::ReferenceItem::ReferenceArn), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_reference_arn(&self) -> std::result::Result<&std::string::String, &Self> {
        if let ReferenceItem::ReferenceArn(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`ReferenceArn`](crate::model::ReferenceItem::ReferenceArn).
    pub fn is_reference_arn(&self) -> bool {
        self.as_reference_arn().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>A filter for variant stores.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListVariantStoresFilter {
    /// <p>A status to filter on.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::StoreStatus>,
}
impl ListVariantStoresFilter {
    /// <p>A status to filter on.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::StoreStatus> {
        self.status.as_ref()
    }
}
impl ListVariantStoresFilter {
    /// Creates a new builder-style object to manufacture [`ListVariantStoresFilter`](crate::model::ListVariantStoresFilter).
    pub fn builder() -> crate::model::list_variant_stores_filter::Builder {
        crate::model::list_variant_stores_filter::Builder::default()
    }
}

/// See [`ListVariantStoresFilter`](crate::model::ListVariantStoresFilter).
pub mod list_variant_stores_filter {

    /// A builder for [`ListVariantStoresFilter`](crate::model::ListVariantStoresFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::StoreStatus>,
    }
    impl Builder {
        /// <p>A status to filter on.</p>
        pub fn status(mut self, input: crate::model::StoreStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>A status to filter on.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::StoreStatus>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`ListVariantStoresFilter`](crate::model::ListVariantStoresFilter).
        pub fn build(self) -> crate::model::ListVariantStoresFilter {
            crate::model::ListVariantStoresFilter {
                status: self.status,
            }
        }
    }
}

/// <p>A variant import job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VariantImportJobItem {
    /// <p>The job's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The job's destination variant store.</p>
    #[doc(hidden)]
    pub destination_name: std::option::Option<std::string::String>,
    /// <p>The job's service role ARN.</p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The job's status.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::JobStatus>,
    /// <p>When the job was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>When the job was updated.</p>
    #[doc(hidden)]
    pub update_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>When the job completed.</p>
    #[doc(hidden)]
    pub completion_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The job's left normalization setting.</p>
    #[doc(hidden)]
    pub run_left_normalization: bool,
}
impl VariantImportJobItem {
    /// <p>The job's ID.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The job's destination variant store.</p>
    pub fn destination_name(&self) -> std::option::Option<&str> {
        self.destination_name.as_deref()
    }
    /// <p>The job's service role ARN.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>The job's status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.status.as_ref()
    }
    /// <p>When the job was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>When the job was updated.</p>
    pub fn update_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.update_time.as_ref()
    }
    /// <p>When the job completed.</p>
    pub fn completion_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.completion_time.as_ref()
    }
    /// <p>The job's left normalization setting.</p>
    pub fn run_left_normalization(&self) -> bool {
        self.run_left_normalization
    }
}
impl VariantImportJobItem {
    /// Creates a new builder-style object to manufacture [`VariantImportJobItem`](crate::model::VariantImportJobItem).
    pub fn builder() -> crate::model::variant_import_job_item::Builder {
        crate::model::variant_import_job_item::Builder::default()
    }
}

/// See [`VariantImportJobItem`](crate::model::VariantImportJobItem).
pub mod variant_import_job_item {

    /// A builder for [`VariantImportJobItem`](crate::model::VariantImportJobItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) destination_name: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::JobStatus>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) completion_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) run_left_normalization: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The job's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The job's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The job's destination variant store.</p>
        pub fn destination_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_name = Some(input.into());
            self
        }
        /// <p>The job's destination variant store.</p>
        pub fn set_destination_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_name = input;
            self
        }
        /// <p>The job's service role ARN.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The job's service role ARN.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>The job's status.</p>
        pub fn status(mut self, input: crate::model::JobStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The job's status.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::JobStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p>When the job was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the job was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>When the job was updated.</p>
        pub fn update_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_time = Some(input);
            self
        }
        /// <p>When the job was updated.</p>
        pub fn set_update_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.update_time = input;
            self
        }
        /// <p>When the job completed.</p>
        pub fn completion_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.completion_time = Some(input);
            self
        }
        /// <p>When the job completed.</p>
        pub fn set_completion_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.completion_time = input;
            self
        }
        /// <p>The job's left normalization setting.</p>
        pub fn run_left_normalization(mut self, input: bool) -> Self {
            self.run_left_normalization = Some(input);
            self
        }
        /// <p>The job's left normalization setting.</p>
        pub fn set_run_left_normalization(mut self, input: std::option::Option<bool>) -> Self {
            self.run_left_normalization = input;
            self
        }
        /// Consumes the builder and constructs a [`VariantImportJobItem`](crate::model::VariantImportJobItem).
        pub fn build(self) -> crate::model::VariantImportJobItem {
            crate::model::VariantImportJobItem {
                id: self.id,
                destination_name: self.destination_name,
                role_arn: self.role_arn,
                status: self.status,
                creation_time: self.creation_time,
                update_time: self.update_time,
                completion_time: self.completion_time,
                run_left_normalization: self.run_left_normalization.unwrap_or_default(),
            }
        }
    }
}

/// When writing a match expression against `JobStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let jobstatus = unimplemented!();
/// match jobstatus {
///     JobStatus::Cancelled => { /* ... */ },
///     JobStatus::Completed => { /* ... */ },
///     JobStatus::Failed => { /* ... */ },
///     JobStatus::InProgress => { /* ... */ },
///     JobStatus::Submitted => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `jobstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `JobStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `JobStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `JobStatus::NewFeature` is defined.
/// Specifically, when `jobstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `JobStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum JobStatus {
    /// The Job was cancelled
    Cancelled,
    /// The Job has completed
    Completed,
    /// The Job failed
    Failed,
    /// The Job is executing
    InProgress,
    /// The Job has been submitted to run
    Submitted,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for JobStatus {
    fn from(s: &str) -> Self {
        match s {
            "CANCELLED" => JobStatus::Cancelled,
            "COMPLETED" => JobStatus::Completed,
            "FAILED" => JobStatus::Failed,
            "IN_PROGRESS" => JobStatus::InProgress,
            "SUBMITTED" => JobStatus::Submitted,
            other => JobStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for JobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(JobStatus::from(s))
    }
}
impl JobStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            JobStatus::Cancelled => "CANCELLED",
            JobStatus::Completed => "COMPLETED",
            JobStatus::Failed => "FAILED",
            JobStatus::InProgress => "IN_PROGRESS",
            JobStatus::Submitted => "SUBMITTED",
            JobStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CANCELLED",
            "COMPLETED",
            "FAILED",
            "IN_PROGRESS",
            "SUBMITTED",
        ]
    }
}
impl AsRef<str> for JobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A filter for variant import jobs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListVariantImportJobsFilter {
    /// <p>A status to filter on.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::JobStatus>,
    /// <p>A store name to filter on.</p>
    #[doc(hidden)]
    pub store_name: std::option::Option<std::string::String>,
}
impl ListVariantImportJobsFilter {
    /// <p>A status to filter on.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.status.as_ref()
    }
    /// <p>A store name to filter on.</p>
    pub fn store_name(&self) -> std::option::Option<&str> {
        self.store_name.as_deref()
    }
}
impl ListVariantImportJobsFilter {
    /// Creates a new builder-style object to manufacture [`ListVariantImportJobsFilter`](crate::model::ListVariantImportJobsFilter).
    pub fn builder() -> crate::model::list_variant_import_jobs_filter::Builder {
        crate::model::list_variant_import_jobs_filter::Builder::default()
    }
}

/// See [`ListVariantImportJobsFilter`](crate::model::ListVariantImportJobsFilter).
pub mod list_variant_import_jobs_filter {

    /// A builder for [`ListVariantImportJobsFilter`](crate::model::ListVariantImportJobsFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::JobStatus>,
        pub(crate) store_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A status to filter on.</p>
        pub fn status(mut self, input: crate::model::JobStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>A status to filter on.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::JobStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p>A store name to filter on.</p>
        pub fn store_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.store_name = Some(input.into());
            self
        }
        /// <p>A store name to filter on.</p>
        pub fn set_store_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.store_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ListVariantImportJobsFilter`](crate::model::ListVariantImportJobsFilter).
        pub fn build(self) -> crate::model::ListVariantImportJobsFilter {
            crate::model::ListVariantImportJobsFilter {
                status: self.status,
                store_name: self.store_name,
            }
        }
    }
}

/// <p>A imported variant item's source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VariantImportItemSource {
    /// <p>The source file's location in Amazon S3.</p>
    #[doc(hidden)]
    pub source: std::option::Option<std::string::String>,
}
impl VariantImportItemSource {
    /// <p>The source file's location in Amazon S3.</p>
    pub fn source(&self) -> std::option::Option<&str> {
        self.source.as_deref()
    }
}
impl VariantImportItemSource {
    /// Creates a new builder-style object to manufacture [`VariantImportItemSource`](crate::model::VariantImportItemSource).
    pub fn builder() -> crate::model::variant_import_item_source::Builder {
        crate::model::variant_import_item_source::Builder::default()
    }
}

/// See [`VariantImportItemSource`](crate::model::VariantImportItemSource).
pub mod variant_import_item_source {

    /// A builder for [`VariantImportItemSource`](crate::model::VariantImportItemSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The source file's location in Amazon S3.</p>
        pub fn source(mut self, input: impl Into<std::string::String>) -> Self {
            self.source = Some(input.into());
            self
        }
        /// <p>The source file's location in Amazon S3.</p>
        pub fn set_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source = input;
            self
        }
        /// Consumes the builder and constructs a [`VariantImportItemSource`](crate::model::VariantImportItemSource).
        pub fn build(self) -> crate::model::VariantImportItemSource {
            crate::model::VariantImportItemSource {
                source: self.source,
            }
        }
    }
}

/// <p>Details about an imported variant item.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VariantImportItemDetail {
    /// <p>The source file's location in Amazon S3.</p>
    #[doc(hidden)]
    pub source: std::option::Option<std::string::String>,
    /// <p>The item's job status.</p>
    #[doc(hidden)]
    pub job_status: std::option::Option<crate::model::JobStatus>,
}
impl VariantImportItemDetail {
    /// <p>The source file's location in Amazon S3.</p>
    pub fn source(&self) -> std::option::Option<&str> {
        self.source.as_deref()
    }
    /// <p>The item's job status.</p>
    pub fn job_status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.job_status.as_ref()
    }
}
impl VariantImportItemDetail {
    /// Creates a new builder-style object to manufacture [`VariantImportItemDetail`](crate::model::VariantImportItemDetail).
    pub fn builder() -> crate::model::variant_import_item_detail::Builder {
        crate::model::variant_import_item_detail::Builder::default()
    }
}

/// See [`VariantImportItemDetail`](crate::model::VariantImportItemDetail).
pub mod variant_import_item_detail {

    /// A builder for [`VariantImportItemDetail`](crate::model::VariantImportItemDetail).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
    }
    impl Builder {
        /// <p>The source file's location in Amazon S3.</p>
        pub fn source(mut self, input: impl Into<std::string::String>) -> Self {
            self.source = Some(input.into());
            self
        }
        /// <p>The source file's location in Amazon S3.</p>
        pub fn set_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source = input;
            self
        }
        /// <p>The item's job status.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>The item's job status.</p>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// Consumes the builder and constructs a [`VariantImportItemDetail`](crate::model::VariantImportItemDetail).
        pub fn build(self) -> crate::model::VariantImportItemDetail {
            crate::model::VariantImportItemDetail {
                source: self.source,
                job_status: self.job_status,
            }
        }
    }
}

/// When writing a match expression against `ReadSetImportJobStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let readsetimportjobstatus = unimplemented!();
/// match readsetimportjobstatus {
///     ReadSetImportJobStatus::Cancelled => { /* ... */ },
///     ReadSetImportJobStatus::Cancelling => { /* ... */ },
///     ReadSetImportJobStatus::Completed => { /* ... */ },
///     ReadSetImportJobStatus::CompletedWithFailures => { /* ... */ },
///     ReadSetImportJobStatus::Failed => { /* ... */ },
///     ReadSetImportJobStatus::InProgress => { /* ... */ },
///     ReadSetImportJobStatus::Submitted => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `readsetimportjobstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ReadSetImportJobStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ReadSetImportJobStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ReadSetImportJobStatus::NewFeature` is defined.
/// Specifically, when `readsetimportjobstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ReadSetImportJobStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReadSetImportJobStatus {
    #[allow(missing_docs)] // documentation missing in model
    Cancelled,
    #[allow(missing_docs)] // documentation missing in model
    Cancelling,
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    CompletedWithFailures,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Submitted,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ReadSetImportJobStatus {
    fn from(s: &str) -> Self {
        match s {
            "CANCELLED" => ReadSetImportJobStatus::Cancelled,
            "CANCELLING" => ReadSetImportJobStatus::Cancelling,
            "COMPLETED" => ReadSetImportJobStatus::Completed,
            "COMPLETED_WITH_FAILURES" => ReadSetImportJobStatus::CompletedWithFailures,
            "FAILED" => ReadSetImportJobStatus::Failed,
            "IN_PROGRESS" => ReadSetImportJobStatus::InProgress,
            "SUBMITTED" => ReadSetImportJobStatus::Submitted,
            other => {
                ReadSetImportJobStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ReadSetImportJobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReadSetImportJobStatus::from(s))
    }
}
impl ReadSetImportJobStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReadSetImportJobStatus::Cancelled => "CANCELLED",
            ReadSetImportJobStatus::Cancelling => "CANCELLING",
            ReadSetImportJobStatus::Completed => "COMPLETED",
            ReadSetImportJobStatus::CompletedWithFailures => "COMPLETED_WITH_FAILURES",
            ReadSetImportJobStatus::Failed => "FAILED",
            ReadSetImportJobStatus::InProgress => "IN_PROGRESS",
            ReadSetImportJobStatus::Submitted => "SUBMITTED",
            ReadSetImportJobStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CANCELLED",
            "CANCELLING",
            "COMPLETED",
            "COMPLETED_WITH_FAILURES",
            "FAILED",
            "IN_PROGRESS",
            "SUBMITTED",
        ]
    }
}
impl AsRef<str> for ReadSetImportJobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A source for a read set import job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StartReadSetImportJobSourceItem {
    /// <p>The source files' location in Amazon S3.</p>
    #[doc(hidden)]
    pub source_files: std::option::Option<crate::model::SourceFiles>,
    /// <p>The source's file type.</p>
    #[doc(hidden)]
    pub source_file_type: std::option::Option<crate::model::FileType>,
    /// <p>The source's subject ID.</p>
    #[doc(hidden)]
    pub subject_id: std::option::Option<std::string::String>,
    /// <p>The source's sample ID.</p>
    #[doc(hidden)]
    pub sample_id: std::option::Option<std::string::String>,
    /// <p>Where the source originated.</p>
    #[doc(hidden)]
    pub generated_from: std::option::Option<std::string::String>,
    /// <p>The source's reference ARN.</p>
    #[doc(hidden)]
    pub reference_arn: std::option::Option<std::string::String>,
    /// <p>The source's name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The source's description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The source's tags.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl StartReadSetImportJobSourceItem {
    /// <p>The source files' location in Amazon S3.</p>
    pub fn source_files(&self) -> std::option::Option<&crate::model::SourceFiles> {
        self.source_files.as_ref()
    }
    /// <p>The source's file type.</p>
    pub fn source_file_type(&self) -> std::option::Option<&crate::model::FileType> {
        self.source_file_type.as_ref()
    }
    /// <p>The source's subject ID.</p>
    pub fn subject_id(&self) -> std::option::Option<&str> {
        self.subject_id.as_deref()
    }
    /// <p>The source's sample ID.</p>
    pub fn sample_id(&self) -> std::option::Option<&str> {
        self.sample_id.as_deref()
    }
    /// <p>Where the source originated.</p>
    pub fn generated_from(&self) -> std::option::Option<&str> {
        self.generated_from.as_deref()
    }
    /// <p>The source's reference ARN.</p>
    pub fn reference_arn(&self) -> std::option::Option<&str> {
        self.reference_arn.as_deref()
    }
    /// <p>The source's name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The source's description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The source's tags.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl StartReadSetImportJobSourceItem {
    /// Creates a new builder-style object to manufacture [`StartReadSetImportJobSourceItem`](crate::model::StartReadSetImportJobSourceItem).
    pub fn builder() -> crate::model::start_read_set_import_job_source_item::Builder {
        crate::model::start_read_set_import_job_source_item::Builder::default()
    }
}

/// See [`StartReadSetImportJobSourceItem`](crate::model::StartReadSetImportJobSourceItem).
pub mod start_read_set_import_job_source_item {

    /// A builder for [`StartReadSetImportJobSourceItem`](crate::model::StartReadSetImportJobSourceItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_files: std::option::Option<crate::model::SourceFiles>,
        pub(crate) source_file_type: std::option::Option<crate::model::FileType>,
        pub(crate) subject_id: std::option::Option<std::string::String>,
        pub(crate) sample_id: std::option::Option<std::string::String>,
        pub(crate) generated_from: std::option::Option<std::string::String>,
        pub(crate) reference_arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The source files' location in Amazon S3.</p>
        pub fn source_files(mut self, input: crate::model::SourceFiles) -> Self {
            self.source_files = Some(input);
            self
        }
        /// <p>The source files' location in Amazon S3.</p>
        pub fn set_source_files(
            mut self,
            input: std::option::Option<crate::model::SourceFiles>,
        ) -> Self {
            self.source_files = input;
            self
        }
        /// <p>The source's file type.</p>
        pub fn source_file_type(mut self, input: crate::model::FileType) -> Self {
            self.source_file_type = Some(input);
            self
        }
        /// <p>The source's file type.</p>
        pub fn set_source_file_type(
            mut self,
            input: std::option::Option<crate::model::FileType>,
        ) -> Self {
            self.source_file_type = input;
            self
        }
        /// <p>The source's subject ID.</p>
        pub fn subject_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subject_id = Some(input.into());
            self
        }
        /// <p>The source's subject ID.</p>
        pub fn set_subject_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subject_id = input;
            self
        }
        /// <p>The source's sample ID.</p>
        pub fn sample_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sample_id = Some(input.into());
            self
        }
        /// <p>The source's sample ID.</p>
        pub fn set_sample_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sample_id = input;
            self
        }
        /// <p>Where the source originated.</p>
        pub fn generated_from(mut self, input: impl Into<std::string::String>) -> Self {
            self.generated_from = Some(input.into());
            self
        }
        /// <p>Where the source originated.</p>
        pub fn set_generated_from(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.generated_from = input;
            self
        }
        /// <p>The source's reference ARN.</p>
        pub fn reference_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.reference_arn = Some(input.into());
            self
        }
        /// <p>The source's reference ARN.</p>
        pub fn set_reference_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reference_arn = input;
            self
        }
        /// <p>The source's name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The source's name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The source's description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The source's description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The source's tags.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The source's tags.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`StartReadSetImportJobSourceItem`](crate::model::StartReadSetImportJobSourceItem).
        pub fn build(self) -> crate::model::StartReadSetImportJobSourceItem {
            crate::model::StartReadSetImportJobSourceItem {
                source_files: self.source_files,
                source_file_type: self.source_file_type,
                subject_id: self.subject_id,
                sample_id: self.sample_id,
                generated_from: self.generated_from,
                reference_arn: self.reference_arn,
                name: self.name,
                description: self.description,
                tags: self.tags,
            }
        }
    }
}

/// When writing a match expression against `FileType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let filetype = unimplemented!();
/// match filetype {
///     FileType::Bam => { /* ... */ },
///     FileType::Cram => { /* ... */ },
///     FileType::Fastq => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `filetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FileType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FileType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FileType::NewFeature` is defined.
/// Specifically, when `filetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FileType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FileType {
    #[allow(missing_docs)] // documentation missing in model
    Bam,
    #[allow(missing_docs)] // documentation missing in model
    Cram,
    #[allow(missing_docs)] // documentation missing in model
    Fastq,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FileType {
    fn from(s: &str) -> Self {
        match s {
            "BAM" => FileType::Bam,
            "CRAM" => FileType::Cram,
            "FASTQ" => FileType::Fastq,
            other => FileType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for FileType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FileType::from(s))
    }
}
impl FileType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FileType::Bam => "BAM",
            FileType::Cram => "CRAM",
            FileType::Fastq => "FASTQ",
            FileType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["BAM", "CRAM", "FASTQ"]
    }
}
impl AsRef<str> for FileType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Source files for a sequence.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SourceFiles {
    /// <p>The location of the first file in Amazon S3.</p>
    #[doc(hidden)]
    pub source1: std::option::Option<std::string::String>,
    /// <p>The location of the second file in Amazon S3.</p>
    #[doc(hidden)]
    pub source2: std::option::Option<std::string::String>,
}
impl SourceFiles {
    /// <p>The location of the first file in Amazon S3.</p>
    pub fn source1(&self) -> std::option::Option<&str> {
        self.source1.as_deref()
    }
    /// <p>The location of the second file in Amazon S3.</p>
    pub fn source2(&self) -> std::option::Option<&str> {
        self.source2.as_deref()
    }
}
impl SourceFiles {
    /// Creates a new builder-style object to manufacture [`SourceFiles`](crate::model::SourceFiles).
    pub fn builder() -> crate::model::source_files::Builder {
        crate::model::source_files::Builder::default()
    }
}

/// See [`SourceFiles`](crate::model::SourceFiles).
pub mod source_files {

    /// A builder for [`SourceFiles`](crate::model::SourceFiles).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source1: std::option::Option<std::string::String>,
        pub(crate) source2: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The location of the first file in Amazon S3.</p>
        pub fn source1(mut self, input: impl Into<std::string::String>) -> Self {
            self.source1 = Some(input.into());
            self
        }
        /// <p>The location of the first file in Amazon S3.</p>
        pub fn set_source1(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source1 = input;
            self
        }
        /// <p>The location of the second file in Amazon S3.</p>
        pub fn source2(mut self, input: impl Into<std::string::String>) -> Self {
            self.source2 = Some(input.into());
            self
        }
        /// <p>The location of the second file in Amazon S3.</p>
        pub fn set_source2(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source2 = input;
            self
        }
        /// Consumes the builder and constructs a [`SourceFiles`](crate::model::SourceFiles).
        pub fn build(self) -> crate::model::SourceFiles {
            crate::model::SourceFiles {
                source1: self.source1,
                source2: self.source2,
            }
        }
    }
}

/// When writing a match expression against `ReadSetExportJobStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let readsetexportjobstatus = unimplemented!();
/// match readsetexportjobstatus {
///     ReadSetExportJobStatus::Cancelled => { /* ... */ },
///     ReadSetExportJobStatus::Cancelling => { /* ... */ },
///     ReadSetExportJobStatus::Completed => { /* ... */ },
///     ReadSetExportJobStatus::CompletedWithFailures => { /* ... */ },
///     ReadSetExportJobStatus::Failed => { /* ... */ },
///     ReadSetExportJobStatus::InProgress => { /* ... */ },
///     ReadSetExportJobStatus::Submitted => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `readsetexportjobstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ReadSetExportJobStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ReadSetExportJobStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ReadSetExportJobStatus::NewFeature` is defined.
/// Specifically, when `readsetexportjobstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ReadSetExportJobStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReadSetExportJobStatus {
    #[allow(missing_docs)] // documentation missing in model
    Cancelled,
    #[allow(missing_docs)] // documentation missing in model
    Cancelling,
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    CompletedWithFailures,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Submitted,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ReadSetExportJobStatus {
    fn from(s: &str) -> Self {
        match s {
            "CANCELLED" => ReadSetExportJobStatus::Cancelled,
            "CANCELLING" => ReadSetExportJobStatus::Cancelling,
            "COMPLETED" => ReadSetExportJobStatus::Completed,
            "COMPLETED_WITH_FAILURES" => ReadSetExportJobStatus::CompletedWithFailures,
            "FAILED" => ReadSetExportJobStatus::Failed,
            "IN_PROGRESS" => ReadSetExportJobStatus::InProgress,
            "SUBMITTED" => ReadSetExportJobStatus::Submitted,
            other => {
                ReadSetExportJobStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ReadSetExportJobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReadSetExportJobStatus::from(s))
    }
}
impl ReadSetExportJobStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReadSetExportJobStatus::Cancelled => "CANCELLED",
            ReadSetExportJobStatus::Cancelling => "CANCELLING",
            ReadSetExportJobStatus::Completed => "COMPLETED",
            ReadSetExportJobStatus::CompletedWithFailures => "COMPLETED_WITH_FAILURES",
            ReadSetExportJobStatus::Failed => "FAILED",
            ReadSetExportJobStatus::InProgress => "IN_PROGRESS",
            ReadSetExportJobStatus::Submitted => "SUBMITTED",
            ReadSetExportJobStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CANCELLED",
            "CANCELLING",
            "COMPLETED",
            "COMPLETED_WITH_FAILURES",
            "FAILED",
            "IN_PROGRESS",
            "SUBMITTED",
        ]
    }
}
impl AsRef<str> for ReadSetExportJobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A read set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExportReadSet {
    /// <p>The set's ID.</p>
    #[doc(hidden)]
    pub read_set_id: std::option::Option<std::string::String>,
}
impl ExportReadSet {
    /// <p>The set's ID.</p>
    pub fn read_set_id(&self) -> std::option::Option<&str> {
        self.read_set_id.as_deref()
    }
}
impl ExportReadSet {
    /// Creates a new builder-style object to manufacture [`ExportReadSet`](crate::model::ExportReadSet).
    pub fn builder() -> crate::model::export_read_set::Builder {
        crate::model::export_read_set::Builder::default()
    }
}

/// See [`ExportReadSet`](crate::model::ExportReadSet).
pub mod export_read_set {

    /// A builder for [`ExportReadSet`](crate::model::ExportReadSet).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) read_set_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The set's ID.</p>
        pub fn read_set_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.read_set_id = Some(input.into());
            self
        }
        /// <p>The set's ID.</p>
        pub fn set_read_set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.read_set_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ExportReadSet`](crate::model::ExportReadSet).
        pub fn build(self) -> crate::model::ExportReadSet {
            crate::model::ExportReadSet {
                read_set_id: self.read_set_id,
            }
        }
    }
}

/// When writing a match expression against `ReadSetActivationJobStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let readsetactivationjobstatus = unimplemented!();
/// match readsetactivationjobstatus {
///     ReadSetActivationJobStatus::Cancelled => { /* ... */ },
///     ReadSetActivationJobStatus::Cancelling => { /* ... */ },
///     ReadSetActivationJobStatus::Completed => { /* ... */ },
///     ReadSetActivationJobStatus::CompletedWithFailures => { /* ... */ },
///     ReadSetActivationJobStatus::Failed => { /* ... */ },
///     ReadSetActivationJobStatus::InProgress => { /* ... */ },
///     ReadSetActivationJobStatus::Submitted => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `readsetactivationjobstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ReadSetActivationJobStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ReadSetActivationJobStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ReadSetActivationJobStatus::NewFeature` is defined.
/// Specifically, when `readsetactivationjobstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ReadSetActivationJobStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReadSetActivationJobStatus {
    #[allow(missing_docs)] // documentation missing in model
    Cancelled,
    #[allow(missing_docs)] // documentation missing in model
    Cancelling,
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    CompletedWithFailures,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Submitted,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ReadSetActivationJobStatus {
    fn from(s: &str) -> Self {
        match s {
            "CANCELLED" => ReadSetActivationJobStatus::Cancelled,
            "CANCELLING" => ReadSetActivationJobStatus::Cancelling,
            "COMPLETED" => ReadSetActivationJobStatus::Completed,
            "COMPLETED_WITH_FAILURES" => ReadSetActivationJobStatus::CompletedWithFailures,
            "FAILED" => ReadSetActivationJobStatus::Failed,
            "IN_PROGRESS" => ReadSetActivationJobStatus::InProgress,
            "SUBMITTED" => ReadSetActivationJobStatus::Submitted,
            other => ReadSetActivationJobStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ReadSetActivationJobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReadSetActivationJobStatus::from(s))
    }
}
impl ReadSetActivationJobStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReadSetActivationJobStatus::Cancelled => "CANCELLED",
            ReadSetActivationJobStatus::Cancelling => "CANCELLING",
            ReadSetActivationJobStatus::Completed => "COMPLETED",
            ReadSetActivationJobStatus::CompletedWithFailures => "COMPLETED_WITH_FAILURES",
            ReadSetActivationJobStatus::Failed => "FAILED",
            ReadSetActivationJobStatus::InProgress => "IN_PROGRESS",
            ReadSetActivationJobStatus::Submitted => "SUBMITTED",
            ReadSetActivationJobStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CANCELLED",
            "CANCELLING",
            "COMPLETED",
            "COMPLETED_WITH_FAILURES",
            "FAILED",
            "IN_PROGRESS",
            "SUBMITTED",
        ]
    }
}
impl AsRef<str> for ReadSetActivationJobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A source for a read set activation job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StartReadSetActivationJobSourceItem {
    /// <p>The source's read set ID.</p>
    #[doc(hidden)]
    pub read_set_id: std::option::Option<std::string::String>,
}
impl StartReadSetActivationJobSourceItem {
    /// <p>The source's read set ID.</p>
    pub fn read_set_id(&self) -> std::option::Option<&str> {
        self.read_set_id.as_deref()
    }
}
impl StartReadSetActivationJobSourceItem {
    /// Creates a new builder-style object to manufacture [`StartReadSetActivationJobSourceItem`](crate::model::StartReadSetActivationJobSourceItem).
    pub fn builder() -> crate::model::start_read_set_activation_job_source_item::Builder {
        crate::model::start_read_set_activation_job_source_item::Builder::default()
    }
}

/// See [`StartReadSetActivationJobSourceItem`](crate::model::StartReadSetActivationJobSourceItem).
pub mod start_read_set_activation_job_source_item {

    /// A builder for [`StartReadSetActivationJobSourceItem`](crate::model::StartReadSetActivationJobSourceItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) read_set_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The source's read set ID.</p>
        pub fn read_set_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.read_set_id = Some(input.into());
            self
        }
        /// <p>The source's read set ID.</p>
        pub fn set_read_set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.read_set_id = input;
            self
        }
        /// Consumes the builder and constructs a [`StartReadSetActivationJobSourceItem`](crate::model::StartReadSetActivationJobSourceItem).
        pub fn build(self) -> crate::model::StartReadSetActivationJobSourceItem {
            crate::model::StartReadSetActivationJobSourceItem {
                read_set_id: self.read_set_id,
            }
        }
    }
}

/// <p>An import read set job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ImportReadSetJobItem {
    /// <p>The job's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The job's sequence store ID.</p>
    #[doc(hidden)]
    pub sequence_store_id: std::option::Option<std::string::String>,
    /// <p>The job's service role ARN.</p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The job's status.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ReadSetImportJobStatus>,
    /// <p>When the job was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>When the job completed.</p>
    #[doc(hidden)]
    pub completion_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl ImportReadSetJobItem {
    /// <p>The job's ID.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The job's sequence store ID.</p>
    pub fn sequence_store_id(&self) -> std::option::Option<&str> {
        self.sequence_store_id.as_deref()
    }
    /// <p>The job's service role ARN.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>The job's status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ReadSetImportJobStatus> {
        self.status.as_ref()
    }
    /// <p>When the job was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>When the job completed.</p>
    pub fn completion_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.completion_time.as_ref()
    }
}
impl ImportReadSetJobItem {
    /// Creates a new builder-style object to manufacture [`ImportReadSetJobItem`](crate::model::ImportReadSetJobItem).
    pub fn builder() -> crate::model::import_read_set_job_item::Builder {
        crate::model::import_read_set_job_item::Builder::default()
    }
}

/// See [`ImportReadSetJobItem`](crate::model::ImportReadSetJobItem).
pub mod import_read_set_job_item {

    /// A builder for [`ImportReadSetJobItem`](crate::model::ImportReadSetJobItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) sequence_store_id: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ReadSetImportJobStatus>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) completion_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The job's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The job's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The job's sequence store ID.</p>
        pub fn sequence_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sequence_store_id = Some(input.into());
            self
        }
        /// <p>The job's sequence store ID.</p>
        pub fn set_sequence_store_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sequence_store_id = input;
            self
        }
        /// <p>The job's service role ARN.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The job's service role ARN.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>The job's status.</p>
        pub fn status(mut self, input: crate::model::ReadSetImportJobStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The job's status.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ReadSetImportJobStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>When the job was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the job was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>When the job completed.</p>
        pub fn completion_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.completion_time = Some(input);
            self
        }
        /// <p>When the job completed.</p>
        pub fn set_completion_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.completion_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ImportReadSetJobItem`](crate::model::ImportReadSetJobItem).
        pub fn build(self) -> crate::model::ImportReadSetJobItem {
            crate::model::ImportReadSetJobItem {
                id: self.id,
                sequence_store_id: self.sequence_store_id,
                role_arn: self.role_arn,
                status: self.status,
                creation_time: self.creation_time,
                completion_time: self.completion_time,
            }
        }
    }
}

/// <p>A filter for import read set jobs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ImportReadSetFilter {
    /// <p>A status to filter on.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ReadSetImportJobStatus>,
    /// <p>The filter's start date.</p>
    #[doc(hidden)]
    pub created_after: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The filter's end date.</p>
    #[doc(hidden)]
    pub created_before: std::option::Option<aws_smithy_types::DateTime>,
}
impl ImportReadSetFilter {
    /// <p>A status to filter on.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ReadSetImportJobStatus> {
        self.status.as_ref()
    }
    /// <p>The filter's start date.</p>
    pub fn created_after(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_after.as_ref()
    }
    /// <p>The filter's end date.</p>
    pub fn created_before(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_before.as_ref()
    }
}
impl ImportReadSetFilter {
    /// Creates a new builder-style object to manufacture [`ImportReadSetFilter`](crate::model::ImportReadSetFilter).
    pub fn builder() -> crate::model::import_read_set_filter::Builder {
        crate::model::import_read_set_filter::Builder::default()
    }
}

/// See [`ImportReadSetFilter`](crate::model::ImportReadSetFilter).
pub mod import_read_set_filter {

    /// A builder for [`ImportReadSetFilter`](crate::model::ImportReadSetFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::ReadSetImportJobStatus>,
        pub(crate) created_after: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_before: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>A status to filter on.</p>
        pub fn status(mut self, input: crate::model::ReadSetImportJobStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>A status to filter on.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ReadSetImportJobStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The filter's start date.</p>
        pub fn created_after(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_after = Some(input);
            self
        }
        /// <p>The filter's start date.</p>
        pub fn set_created_after(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_after = input;
            self
        }
        /// <p>The filter's end date.</p>
        pub fn created_before(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_before = Some(input);
            self
        }
        /// <p>The filter's end date.</p>
        pub fn set_created_before(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_before = input;
            self
        }
        /// Consumes the builder and constructs a [`ImportReadSetFilter`](crate::model::ImportReadSetFilter).
        pub fn build(self) -> crate::model::ImportReadSetFilter {
            crate::model::ImportReadSetFilter {
                status: self.status,
                created_after: self.created_after,
                created_before: self.created_before,
            }
        }
    }
}

/// <p>Details about a read set export job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExportReadSetJobDetail {
    /// <p>The job's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The job's sequence store ID.</p>
    #[doc(hidden)]
    pub sequence_store_id: std::option::Option<std::string::String>,
    /// <p>The job's destination in Amazon S3.</p>
    #[doc(hidden)]
    pub destination: std::option::Option<std::string::String>,
    /// <p>The job's status.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ReadSetExportJobStatus>,
    /// <p>When the job was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>When the job completed.</p>
    #[doc(hidden)]
    pub completion_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl ExportReadSetJobDetail {
    /// <p>The job's ID.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The job's sequence store ID.</p>
    pub fn sequence_store_id(&self) -> std::option::Option<&str> {
        self.sequence_store_id.as_deref()
    }
    /// <p>The job's destination in Amazon S3.</p>
    pub fn destination(&self) -> std::option::Option<&str> {
        self.destination.as_deref()
    }
    /// <p>The job's status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ReadSetExportJobStatus> {
        self.status.as_ref()
    }
    /// <p>When the job was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>When the job completed.</p>
    pub fn completion_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.completion_time.as_ref()
    }
}
impl ExportReadSetJobDetail {
    /// Creates a new builder-style object to manufacture [`ExportReadSetJobDetail`](crate::model::ExportReadSetJobDetail).
    pub fn builder() -> crate::model::export_read_set_job_detail::Builder {
        crate::model::export_read_set_job_detail::Builder::default()
    }
}

/// See [`ExportReadSetJobDetail`](crate::model::ExportReadSetJobDetail).
pub mod export_read_set_job_detail {

    /// A builder for [`ExportReadSetJobDetail`](crate::model::ExportReadSetJobDetail).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) sequence_store_id: std::option::Option<std::string::String>,
        pub(crate) destination: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ReadSetExportJobStatus>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) completion_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The job's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The job's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The job's sequence store ID.</p>
        pub fn sequence_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sequence_store_id = Some(input.into());
            self
        }
        /// <p>The job's sequence store ID.</p>
        pub fn set_sequence_store_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sequence_store_id = input;
            self
        }
        /// <p>The job's destination in Amazon S3.</p>
        pub fn destination(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination = Some(input.into());
            self
        }
        /// <p>The job's destination in Amazon S3.</p>
        pub fn set_destination(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.destination = input;
            self
        }
        /// <p>The job's status.</p>
        pub fn status(mut self, input: crate::model::ReadSetExportJobStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The job's status.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ReadSetExportJobStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>When the job was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the job was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>When the job completed.</p>
        pub fn completion_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.completion_time = Some(input);
            self
        }
        /// <p>When the job completed.</p>
        pub fn set_completion_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.completion_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ExportReadSetJobDetail`](crate::model::ExportReadSetJobDetail).
        pub fn build(self) -> crate::model::ExportReadSetJobDetail {
            crate::model::ExportReadSetJobDetail {
                id: self.id,
                sequence_store_id: self.sequence_store_id,
                destination: self.destination,
                status: self.status,
                creation_time: self.creation_time,
                completion_time: self.completion_time,
            }
        }
    }
}

/// <p>An read set export job filter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExportReadSetFilter {
    /// <p>A status to filter on.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ReadSetExportJobStatus>,
    /// <p>The filter's start date.</p>
    #[doc(hidden)]
    pub created_after: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The filter's end date.</p>
    #[doc(hidden)]
    pub created_before: std::option::Option<aws_smithy_types::DateTime>,
}
impl ExportReadSetFilter {
    /// <p>A status to filter on.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ReadSetExportJobStatus> {
        self.status.as_ref()
    }
    /// <p>The filter's start date.</p>
    pub fn created_after(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_after.as_ref()
    }
    /// <p>The filter's end date.</p>
    pub fn created_before(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_before.as_ref()
    }
}
impl ExportReadSetFilter {
    /// Creates a new builder-style object to manufacture [`ExportReadSetFilter`](crate::model::ExportReadSetFilter).
    pub fn builder() -> crate::model::export_read_set_filter::Builder {
        crate::model::export_read_set_filter::Builder::default()
    }
}

/// See [`ExportReadSetFilter`](crate::model::ExportReadSetFilter).
pub mod export_read_set_filter {

    /// A builder for [`ExportReadSetFilter`](crate::model::ExportReadSetFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::ReadSetExportJobStatus>,
        pub(crate) created_after: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_before: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>A status to filter on.</p>
        pub fn status(mut self, input: crate::model::ReadSetExportJobStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>A status to filter on.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ReadSetExportJobStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The filter's start date.</p>
        pub fn created_after(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_after = Some(input);
            self
        }
        /// <p>The filter's start date.</p>
        pub fn set_created_after(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_after = input;
            self
        }
        /// <p>The filter's end date.</p>
        pub fn created_before(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_before = Some(input);
            self
        }
        /// <p>The filter's end date.</p>
        pub fn set_created_before(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_before = input;
            self
        }
        /// Consumes the builder and constructs a [`ExportReadSetFilter`](crate::model::ExportReadSetFilter).
        pub fn build(self) -> crate::model::ExportReadSetFilter {
            crate::model::ExportReadSetFilter {
                status: self.status,
                created_after: self.created_after,
                created_before: self.created_before,
            }
        }
    }
}

/// <p>A read set activation job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ActivateReadSetJobItem {
    /// <p>The job's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The job's sequence store ID.</p>
    #[doc(hidden)]
    pub sequence_store_id: std::option::Option<std::string::String>,
    /// <p>The job's status.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ReadSetActivationJobStatus>,
    /// <p>When the job was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>When the job completed.</p>
    #[doc(hidden)]
    pub completion_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl ActivateReadSetJobItem {
    /// <p>The job's ID.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The job's sequence store ID.</p>
    pub fn sequence_store_id(&self) -> std::option::Option<&str> {
        self.sequence_store_id.as_deref()
    }
    /// <p>The job's status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ReadSetActivationJobStatus> {
        self.status.as_ref()
    }
    /// <p>When the job was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>When the job completed.</p>
    pub fn completion_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.completion_time.as_ref()
    }
}
impl ActivateReadSetJobItem {
    /// Creates a new builder-style object to manufacture [`ActivateReadSetJobItem`](crate::model::ActivateReadSetJobItem).
    pub fn builder() -> crate::model::activate_read_set_job_item::Builder {
        crate::model::activate_read_set_job_item::Builder::default()
    }
}

/// See [`ActivateReadSetJobItem`](crate::model::ActivateReadSetJobItem).
pub mod activate_read_set_job_item {

    /// A builder for [`ActivateReadSetJobItem`](crate::model::ActivateReadSetJobItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) sequence_store_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ReadSetActivationJobStatus>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) completion_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The job's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The job's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The job's sequence store ID.</p>
        pub fn sequence_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sequence_store_id = Some(input.into());
            self
        }
        /// <p>The job's sequence store ID.</p>
        pub fn set_sequence_store_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sequence_store_id = input;
            self
        }
        /// <p>The job's status.</p>
        pub fn status(mut self, input: crate::model::ReadSetActivationJobStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The job's status.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ReadSetActivationJobStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>When the job was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the job was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>When the job completed.</p>
        pub fn completion_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.completion_time = Some(input);
            self
        }
        /// <p>When the job completed.</p>
        pub fn set_completion_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.completion_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ActivateReadSetJobItem`](crate::model::ActivateReadSetJobItem).
        pub fn build(self) -> crate::model::ActivateReadSetJobItem {
            crate::model::ActivateReadSetJobItem {
                id: self.id,
                sequence_store_id: self.sequence_store_id,
                status: self.status,
                creation_time: self.creation_time,
                completion_time: self.completion_time,
            }
        }
    }
}

/// <p>A read set activation job filter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ActivateReadSetFilter {
    /// <p>The filter's status.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ReadSetActivationJobStatus>,
    /// <p>The filter's start date.</p>
    #[doc(hidden)]
    pub created_after: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The filter's end date.</p>
    #[doc(hidden)]
    pub created_before: std::option::Option<aws_smithy_types::DateTime>,
}
impl ActivateReadSetFilter {
    /// <p>The filter's status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ReadSetActivationJobStatus> {
        self.status.as_ref()
    }
    /// <p>The filter's start date.</p>
    pub fn created_after(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_after.as_ref()
    }
    /// <p>The filter's end date.</p>
    pub fn created_before(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_before.as_ref()
    }
}
impl ActivateReadSetFilter {
    /// Creates a new builder-style object to manufacture [`ActivateReadSetFilter`](crate::model::ActivateReadSetFilter).
    pub fn builder() -> crate::model::activate_read_set_filter::Builder {
        crate::model::activate_read_set_filter::Builder::default()
    }
}

/// See [`ActivateReadSetFilter`](crate::model::ActivateReadSetFilter).
pub mod activate_read_set_filter {

    /// A builder for [`ActivateReadSetFilter`](crate::model::ActivateReadSetFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::ReadSetActivationJobStatus>,
        pub(crate) created_after: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_before: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The filter's status.</p>
        pub fn status(mut self, input: crate::model::ReadSetActivationJobStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The filter's status.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ReadSetActivationJobStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The filter's start date.</p>
        pub fn created_after(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_after = Some(input);
            self
        }
        /// <p>The filter's start date.</p>
        pub fn set_created_after(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_after = input;
            self
        }
        /// <p>The filter's end date.</p>
        pub fn created_before(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_before = Some(input);
            self
        }
        /// <p>The filter's end date.</p>
        pub fn set_created_before(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_before = input;
            self
        }
        /// Consumes the builder and constructs a [`ActivateReadSetFilter`](crate::model::ActivateReadSetFilter).
        pub fn build(self) -> crate::model::ActivateReadSetFilter {
            crate::model::ActivateReadSetFilter {
                status: self.status,
                created_after: self.created_after,
                created_before: self.created_before,
            }
        }
    }
}

/// <p>A source for an import read set job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ImportReadSetSourceItem {
    /// <p>The source files' location in Amazon S3.</p>
    #[doc(hidden)]
    pub source_files: std::option::Option<crate::model::SourceFiles>,
    /// <p>The source's file type.</p>
    #[doc(hidden)]
    pub source_file_type: std::option::Option<crate::model::FileType>,
    /// <p>The source's status.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ReadSetImportJobItemStatus>,
    /// <p>The source's status message.</p>
    #[doc(hidden)]
    pub status_message: std::option::Option<std::string::String>,
    /// <p>The source's subject ID.</p>
    #[doc(hidden)]
    pub subject_id: std::option::Option<std::string::String>,
    /// <p>The source's sample ID.</p>
    #[doc(hidden)]
    pub sample_id: std::option::Option<std::string::String>,
    /// <p>Where the source originated.</p>
    #[doc(hidden)]
    pub generated_from: std::option::Option<std::string::String>,
    /// <p>The source's genome reference ARN.</p>
    #[doc(hidden)]
    pub reference_arn: std::option::Option<std::string::String>,
    /// <p>The source's name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The source's description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The source's tags.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl ImportReadSetSourceItem {
    /// <p>The source files' location in Amazon S3.</p>
    pub fn source_files(&self) -> std::option::Option<&crate::model::SourceFiles> {
        self.source_files.as_ref()
    }
    /// <p>The source's file type.</p>
    pub fn source_file_type(&self) -> std::option::Option<&crate::model::FileType> {
        self.source_file_type.as_ref()
    }
    /// <p>The source's status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ReadSetImportJobItemStatus> {
        self.status.as_ref()
    }
    /// <p>The source's status message.</p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
    /// <p>The source's subject ID.</p>
    pub fn subject_id(&self) -> std::option::Option<&str> {
        self.subject_id.as_deref()
    }
    /// <p>The source's sample ID.</p>
    pub fn sample_id(&self) -> std::option::Option<&str> {
        self.sample_id.as_deref()
    }
    /// <p>Where the source originated.</p>
    pub fn generated_from(&self) -> std::option::Option<&str> {
        self.generated_from.as_deref()
    }
    /// <p>The source's genome reference ARN.</p>
    pub fn reference_arn(&self) -> std::option::Option<&str> {
        self.reference_arn.as_deref()
    }
    /// <p>The source's name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The source's description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The source's tags.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl ImportReadSetSourceItem {
    /// Creates a new builder-style object to manufacture [`ImportReadSetSourceItem`](crate::model::ImportReadSetSourceItem).
    pub fn builder() -> crate::model::import_read_set_source_item::Builder {
        crate::model::import_read_set_source_item::Builder::default()
    }
}

/// See [`ImportReadSetSourceItem`](crate::model::ImportReadSetSourceItem).
pub mod import_read_set_source_item {

    /// A builder for [`ImportReadSetSourceItem`](crate::model::ImportReadSetSourceItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_files: std::option::Option<crate::model::SourceFiles>,
        pub(crate) source_file_type: std::option::Option<crate::model::FileType>,
        pub(crate) status: std::option::Option<crate::model::ReadSetImportJobItemStatus>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) subject_id: std::option::Option<std::string::String>,
        pub(crate) sample_id: std::option::Option<std::string::String>,
        pub(crate) generated_from: std::option::Option<std::string::String>,
        pub(crate) reference_arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The source files' location in Amazon S3.</p>
        pub fn source_files(mut self, input: crate::model::SourceFiles) -> Self {
            self.source_files = Some(input);
            self
        }
        /// <p>The source files' location in Amazon S3.</p>
        pub fn set_source_files(
            mut self,
            input: std::option::Option<crate::model::SourceFiles>,
        ) -> Self {
            self.source_files = input;
            self
        }
        /// <p>The source's file type.</p>
        pub fn source_file_type(mut self, input: crate::model::FileType) -> Self {
            self.source_file_type = Some(input);
            self
        }
        /// <p>The source's file type.</p>
        pub fn set_source_file_type(
            mut self,
            input: std::option::Option<crate::model::FileType>,
        ) -> Self {
            self.source_file_type = input;
            self
        }
        /// <p>The source's status.</p>
        pub fn status(mut self, input: crate::model::ReadSetImportJobItemStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The source's status.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ReadSetImportJobItemStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The source's status message.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>The source's status message.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>The source's subject ID.</p>
        pub fn subject_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subject_id = Some(input.into());
            self
        }
        /// <p>The source's subject ID.</p>
        pub fn set_subject_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subject_id = input;
            self
        }
        /// <p>The source's sample ID.</p>
        pub fn sample_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sample_id = Some(input.into());
            self
        }
        /// <p>The source's sample ID.</p>
        pub fn set_sample_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sample_id = input;
            self
        }
        /// <p>Where the source originated.</p>
        pub fn generated_from(mut self, input: impl Into<std::string::String>) -> Self {
            self.generated_from = Some(input.into());
            self
        }
        /// <p>Where the source originated.</p>
        pub fn set_generated_from(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.generated_from = input;
            self
        }
        /// <p>The source's genome reference ARN.</p>
        pub fn reference_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.reference_arn = Some(input.into());
            self
        }
        /// <p>The source's genome reference ARN.</p>
        pub fn set_reference_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reference_arn = input;
            self
        }
        /// <p>The source's name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The source's name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The source's description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The source's description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The source's tags.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The source's tags.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ImportReadSetSourceItem`](crate::model::ImportReadSetSourceItem).
        pub fn build(self) -> crate::model::ImportReadSetSourceItem {
            crate::model::ImportReadSetSourceItem {
                source_files: self.source_files,
                source_file_type: self.source_file_type,
                status: self.status,
                status_message: self.status_message,
                subject_id: self.subject_id,
                sample_id: self.sample_id,
                generated_from: self.generated_from,
                reference_arn: self.reference_arn,
                name: self.name,
                description: self.description,
                tags: self.tags,
            }
        }
    }
}

/// When writing a match expression against `ReadSetImportJobItemStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let readsetimportjobitemstatus = unimplemented!();
/// match readsetimportjobitemstatus {
///     ReadSetImportJobItemStatus::Failed => { /* ... */ },
///     ReadSetImportJobItemStatus::Finished => { /* ... */ },
///     ReadSetImportJobItemStatus::InProgress => { /* ... */ },
///     ReadSetImportJobItemStatus::NotStarted => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `readsetimportjobitemstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ReadSetImportJobItemStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ReadSetImportJobItemStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ReadSetImportJobItemStatus::NewFeature` is defined.
/// Specifically, when `readsetimportjobitemstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ReadSetImportJobItemStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReadSetImportJobItemStatus {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Finished,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    NotStarted,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ReadSetImportJobItemStatus {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => ReadSetImportJobItemStatus::Failed,
            "FINISHED" => ReadSetImportJobItemStatus::Finished,
            "IN_PROGRESS" => ReadSetImportJobItemStatus::InProgress,
            "NOT_STARTED" => ReadSetImportJobItemStatus::NotStarted,
            other => ReadSetImportJobItemStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ReadSetImportJobItemStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReadSetImportJobItemStatus::from(s))
    }
}
impl ReadSetImportJobItemStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReadSetImportJobItemStatus::Failed => "FAILED",
            ReadSetImportJobItemStatus::Finished => "FINISHED",
            ReadSetImportJobItemStatus::InProgress => "IN_PROGRESS",
            ReadSetImportJobItemStatus::NotStarted => "NOT_STARTED",
            ReadSetImportJobItemStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FAILED", "FINISHED", "IN_PROGRESS", "NOT_STARTED"]
    }
}
impl AsRef<str> for ReadSetImportJobItemStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Details about a read set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExportReadSetDetail {
    /// <p>The set's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The set's status.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ReadSetExportJobItemStatus>,
    /// <p>The set's status message.</p>
    #[doc(hidden)]
    pub status_message: std::option::Option<std::string::String>,
}
impl ExportReadSetDetail {
    /// <p>The set's ID.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The set's status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ReadSetExportJobItemStatus> {
        self.status.as_ref()
    }
    /// <p>The set's status message.</p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
}
impl ExportReadSetDetail {
    /// Creates a new builder-style object to manufacture [`ExportReadSetDetail`](crate::model::ExportReadSetDetail).
    pub fn builder() -> crate::model::export_read_set_detail::Builder {
        crate::model::export_read_set_detail::Builder::default()
    }
}

/// See [`ExportReadSetDetail`](crate::model::ExportReadSetDetail).
pub mod export_read_set_detail {

    /// A builder for [`ExportReadSetDetail`](crate::model::ExportReadSetDetail).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ReadSetExportJobItemStatus>,
        pub(crate) status_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The set's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The set's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The set's status.</p>
        pub fn status(mut self, input: crate::model::ReadSetExportJobItemStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The set's status.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ReadSetExportJobItemStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The set's status message.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>The set's status message.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// Consumes the builder and constructs a [`ExportReadSetDetail`](crate::model::ExportReadSetDetail).
        pub fn build(self) -> crate::model::ExportReadSetDetail {
            crate::model::ExportReadSetDetail {
                id: self.id,
                status: self.status,
                status_message: self.status_message,
            }
        }
    }
}

/// When writing a match expression against `ReadSetExportJobItemStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let readsetexportjobitemstatus = unimplemented!();
/// match readsetexportjobitemstatus {
///     ReadSetExportJobItemStatus::Failed => { /* ... */ },
///     ReadSetExportJobItemStatus::Finished => { /* ... */ },
///     ReadSetExportJobItemStatus::InProgress => { /* ... */ },
///     ReadSetExportJobItemStatus::NotStarted => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `readsetexportjobitemstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ReadSetExportJobItemStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ReadSetExportJobItemStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ReadSetExportJobItemStatus::NewFeature` is defined.
/// Specifically, when `readsetexportjobitemstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ReadSetExportJobItemStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReadSetExportJobItemStatus {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Finished,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    NotStarted,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ReadSetExportJobItemStatus {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => ReadSetExportJobItemStatus::Failed,
            "FINISHED" => ReadSetExportJobItemStatus::Finished,
            "IN_PROGRESS" => ReadSetExportJobItemStatus::InProgress,
            "NOT_STARTED" => ReadSetExportJobItemStatus::NotStarted,
            other => ReadSetExportJobItemStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ReadSetExportJobItemStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReadSetExportJobItemStatus::from(s))
    }
}
impl ReadSetExportJobItemStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReadSetExportJobItemStatus::Failed => "FAILED",
            ReadSetExportJobItemStatus::Finished => "FINISHED",
            ReadSetExportJobItemStatus::InProgress => "IN_PROGRESS",
            ReadSetExportJobItemStatus::NotStarted => "NOT_STARTED",
            ReadSetExportJobItemStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FAILED", "FINISHED", "IN_PROGRESS", "NOT_STARTED"]
    }
}
impl AsRef<str> for ReadSetExportJobItemStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A source for a read set activation job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ActivateReadSetSourceItem {
    /// <p>The source's read set ID.</p>
    #[doc(hidden)]
    pub read_set_id: std::option::Option<std::string::String>,
    /// <p>The source's status.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ReadSetActivationJobItemStatus>,
    /// <p>The source's status message.</p>
    #[doc(hidden)]
    pub status_message: std::option::Option<std::string::String>,
}
impl ActivateReadSetSourceItem {
    /// <p>The source's read set ID.</p>
    pub fn read_set_id(&self) -> std::option::Option<&str> {
        self.read_set_id.as_deref()
    }
    /// <p>The source's status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ReadSetActivationJobItemStatus> {
        self.status.as_ref()
    }
    /// <p>The source's status message.</p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
}
impl ActivateReadSetSourceItem {
    /// Creates a new builder-style object to manufacture [`ActivateReadSetSourceItem`](crate::model::ActivateReadSetSourceItem).
    pub fn builder() -> crate::model::activate_read_set_source_item::Builder {
        crate::model::activate_read_set_source_item::Builder::default()
    }
}

/// See [`ActivateReadSetSourceItem`](crate::model::ActivateReadSetSourceItem).
pub mod activate_read_set_source_item {

    /// A builder for [`ActivateReadSetSourceItem`](crate::model::ActivateReadSetSourceItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) read_set_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ReadSetActivationJobItemStatus>,
        pub(crate) status_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The source's read set ID.</p>
        pub fn read_set_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.read_set_id = Some(input.into());
            self
        }
        /// <p>The source's read set ID.</p>
        pub fn set_read_set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.read_set_id = input;
            self
        }
        /// <p>The source's status.</p>
        pub fn status(mut self, input: crate::model::ReadSetActivationJobItemStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The source's status.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ReadSetActivationJobItemStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The source's status message.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>The source's status message.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// Consumes the builder and constructs a [`ActivateReadSetSourceItem`](crate::model::ActivateReadSetSourceItem).
        pub fn build(self) -> crate::model::ActivateReadSetSourceItem {
            crate::model::ActivateReadSetSourceItem {
                read_set_id: self.read_set_id,
                status: self.status,
                status_message: self.status_message,
            }
        }
    }
}

/// When writing a match expression against `ReadSetActivationJobItemStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let readsetactivationjobitemstatus = unimplemented!();
/// match readsetactivationjobitemstatus {
///     ReadSetActivationJobItemStatus::Failed => { /* ... */ },
///     ReadSetActivationJobItemStatus::Finished => { /* ... */ },
///     ReadSetActivationJobItemStatus::InProgress => { /* ... */ },
///     ReadSetActivationJobItemStatus::NotStarted => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `readsetactivationjobitemstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ReadSetActivationJobItemStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ReadSetActivationJobItemStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ReadSetActivationJobItemStatus::NewFeature` is defined.
/// Specifically, when `readsetactivationjobitemstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ReadSetActivationJobItemStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReadSetActivationJobItemStatus {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Finished,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    NotStarted,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ReadSetActivationJobItemStatus {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => ReadSetActivationJobItemStatus::Failed,
            "FINISHED" => ReadSetActivationJobItemStatus::Finished,
            "IN_PROGRESS" => ReadSetActivationJobItemStatus::InProgress,
            "NOT_STARTED" => ReadSetActivationJobItemStatus::NotStarted,
            other => ReadSetActivationJobItemStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ReadSetActivationJobItemStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReadSetActivationJobItemStatus::from(s))
    }
}
impl ReadSetActivationJobItemStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReadSetActivationJobItemStatus::Failed => "FAILED",
            ReadSetActivationJobItemStatus::Finished => "FINISHED",
            ReadSetActivationJobItemStatus::InProgress => "IN_PROGRESS",
            ReadSetActivationJobItemStatus::NotStarted => "NOT_STARTED",
            ReadSetActivationJobItemStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FAILED", "FINISHED", "IN_PROGRESS", "NOT_STARTED"]
    }
}
impl AsRef<str> for ReadSetActivationJobItemStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Details about a sequence store.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SequenceStoreDetail {
    /// <p>The store's ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The store's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The store's name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The store's description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The store's server-side encryption (SSE) settings.</p>
    #[doc(hidden)]
    pub sse_config: std::option::Option<crate::model::SseConfig>,
    /// <p>When the store was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl SequenceStoreDetail {
    /// <p>The store's ARN.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The store's ID.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The store's name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The store's description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The store's server-side encryption (SSE) settings.</p>
    pub fn sse_config(&self) -> std::option::Option<&crate::model::SseConfig> {
        self.sse_config.as_ref()
    }
    /// <p>When the store was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
}
impl SequenceStoreDetail {
    /// Creates a new builder-style object to manufacture [`SequenceStoreDetail`](crate::model::SequenceStoreDetail).
    pub fn builder() -> crate::model::sequence_store_detail::Builder {
        crate::model::sequence_store_detail::Builder::default()
    }
}

/// See [`SequenceStoreDetail`](crate::model::SequenceStoreDetail).
pub mod sequence_store_detail {

    /// A builder for [`SequenceStoreDetail`](crate::model::SequenceStoreDetail).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) sse_config: std::option::Option<crate::model::SseConfig>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The store's ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The store's ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The store's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The store's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The store's name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The store's name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The store's description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The store's description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The store's server-side encryption (SSE) settings.</p>
        pub fn sse_config(mut self, input: crate::model::SseConfig) -> Self {
            self.sse_config = Some(input);
            self
        }
        /// <p>The store's server-side encryption (SSE) settings.</p>
        pub fn set_sse_config(
            mut self,
            input: std::option::Option<crate::model::SseConfig>,
        ) -> Self {
            self.sse_config = input;
            self
        }
        /// <p>When the store was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the store was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// Consumes the builder and constructs a [`SequenceStoreDetail`](crate::model::SequenceStoreDetail).
        pub fn build(self) -> crate::model::SequenceStoreDetail {
            crate::model::SequenceStoreDetail {
                arn: self.arn,
                id: self.id,
                name: self.name,
                description: self.description,
                sse_config: self.sse_config,
                creation_time: self.creation_time,
            }
        }
    }
}

/// <p>A filter for a sequence store.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SequenceStoreFilter {
    /// <p>A name to filter on.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The filter's start date.</p>
    #[doc(hidden)]
    pub created_after: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The filter's end date.</p>
    #[doc(hidden)]
    pub created_before: std::option::Option<aws_smithy_types::DateTime>,
}
impl SequenceStoreFilter {
    /// <p>A name to filter on.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The filter's start date.</p>
    pub fn created_after(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_after.as_ref()
    }
    /// <p>The filter's end date.</p>
    pub fn created_before(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_before.as_ref()
    }
}
impl SequenceStoreFilter {
    /// Creates a new builder-style object to manufacture [`SequenceStoreFilter`](crate::model::SequenceStoreFilter).
    pub fn builder() -> crate::model::sequence_store_filter::Builder {
        crate::model::sequence_store_filter::Builder::default()
    }
}

/// See [`SequenceStoreFilter`](crate::model::SequenceStoreFilter).
pub mod sequence_store_filter {

    /// A builder for [`SequenceStoreFilter`](crate::model::SequenceStoreFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) created_after: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_before: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>A name to filter on.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A name to filter on.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The filter's start date.</p>
        pub fn created_after(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_after = Some(input);
            self
        }
        /// <p>The filter's start date.</p>
        pub fn set_created_after(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_after = input;
            self
        }
        /// <p>The filter's end date.</p>
        pub fn created_before(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_before = Some(input);
            self
        }
        /// <p>The filter's end date.</p>
        pub fn set_created_before(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_before = input;
            self
        }
        /// Consumes the builder and constructs a [`SequenceStoreFilter`](crate::model::SequenceStoreFilter).
        pub fn build(self) -> crate::model::SequenceStoreFilter {
            crate::model::SequenceStoreFilter {
                name: self.name,
                created_after: self.created_after,
                created_before: self.created_before,
            }
        }
    }
}

/// When writing a match expression against `ReadSetFile`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let readsetfile = unimplemented!();
/// match readsetfile {
///     ReadSetFile::Index => { /* ... */ },
///     ReadSetFile::Source1 => { /* ... */ },
///     ReadSetFile::Source2 => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `readsetfile` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ReadSetFile::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ReadSetFile::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ReadSetFile::NewFeature` is defined.
/// Specifically, when `readsetfile` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ReadSetFile::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReadSetFile {
    #[allow(missing_docs)] // documentation missing in model
    Index,
    #[allow(missing_docs)] // documentation missing in model
    Source1,
    #[allow(missing_docs)] // documentation missing in model
    Source2,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ReadSetFile {
    fn from(s: &str) -> Self {
        match s {
            "INDEX" => ReadSetFile::Index,
            "SOURCE1" => ReadSetFile::Source1,
            "SOURCE2" => ReadSetFile::Source2,
            other => ReadSetFile::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ReadSetFile {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReadSetFile::from(s))
    }
}
impl ReadSetFile {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReadSetFile::Index => "INDEX",
            ReadSetFile::Source1 => "SOURCE1",
            ReadSetFile::Source2 => "SOURCE2",
            ReadSetFile::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["INDEX", "SOURCE1", "SOURCE2"]
    }
}
impl AsRef<str> for ReadSetFile {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An error from a batch read set operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReadSetBatchError {
    /// <p>The error's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The error's code.</p>
    #[doc(hidden)]
    pub code: std::option::Option<std::string::String>,
    /// <p>The error's message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ReadSetBatchError {
    /// <p>The error's ID.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The error's code.</p>
    pub fn code(&self) -> std::option::Option<&str> {
        self.code.as_deref()
    }
    /// <p>The error's message.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl ReadSetBatchError {
    /// Creates a new builder-style object to manufacture [`ReadSetBatchError`](crate::model::ReadSetBatchError).
    pub fn builder() -> crate::model::read_set_batch_error::Builder {
        crate::model::read_set_batch_error::Builder::default()
    }
}

/// See [`ReadSetBatchError`](crate::model::ReadSetBatchError).
pub mod read_set_batch_error {

    /// A builder for [`ReadSetBatchError`](crate::model::ReadSetBatchError).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The error's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The error's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The error's code.</p>
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        /// <p>The error's code.</p>
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>The error's message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The error's message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ReadSetBatchError`](crate::model::ReadSetBatchError).
        pub fn build(self) -> crate::model::ReadSetBatchError {
            crate::model::ReadSetBatchError {
                id: self.id,
                code: self.code,
                message: self.message,
            }
        }
    }
}

/// <p>A read set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReadSetListItem {
    /// <p>The read set's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The read set's ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The read set's sequence store ID.</p>
    #[doc(hidden)]
    pub sequence_store_id: std::option::Option<std::string::String>,
    /// <p>The read set's subject ID.</p>
    #[doc(hidden)]
    pub subject_id: std::option::Option<std::string::String>,
    /// <p>The read set's sample ID.</p>
    #[doc(hidden)]
    pub sample_id: std::option::Option<std::string::String>,
    /// <p>The read set's status.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ReadSetStatus>,
    /// <p>The read set's name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The read set's description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The read set's genome reference ARN.</p>
    #[doc(hidden)]
    pub reference_arn: std::option::Option<std::string::String>,
    /// <p>The read set's file type.</p>
    #[doc(hidden)]
    pub file_type: std::option::Option<crate::model::FileType>,
    /// <p>Details about a sequence.</p>
    #[doc(hidden)]
    pub sequence_information: std::option::Option<crate::model::SequenceInformation>,
    /// <p>When the read set was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl ReadSetListItem {
    /// <p>The read set's ID.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The read set's ARN.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The read set's sequence store ID.</p>
    pub fn sequence_store_id(&self) -> std::option::Option<&str> {
        self.sequence_store_id.as_deref()
    }
    /// <p>The read set's subject ID.</p>
    pub fn subject_id(&self) -> std::option::Option<&str> {
        self.subject_id.as_deref()
    }
    /// <p>The read set's sample ID.</p>
    pub fn sample_id(&self) -> std::option::Option<&str> {
        self.sample_id.as_deref()
    }
    /// <p>The read set's status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ReadSetStatus> {
        self.status.as_ref()
    }
    /// <p>The read set's name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The read set's description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The read set's genome reference ARN.</p>
    pub fn reference_arn(&self) -> std::option::Option<&str> {
        self.reference_arn.as_deref()
    }
    /// <p>The read set's file type.</p>
    pub fn file_type(&self) -> std::option::Option<&crate::model::FileType> {
        self.file_type.as_ref()
    }
    /// <p>Details about a sequence.</p>
    pub fn sequence_information(&self) -> std::option::Option<&crate::model::SequenceInformation> {
        self.sequence_information.as_ref()
    }
    /// <p>When the read set was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
}
impl ReadSetListItem {
    /// Creates a new builder-style object to manufacture [`ReadSetListItem`](crate::model::ReadSetListItem).
    pub fn builder() -> crate::model::read_set_list_item::Builder {
        crate::model::read_set_list_item::Builder::default()
    }
}

/// See [`ReadSetListItem`](crate::model::ReadSetListItem).
pub mod read_set_list_item {

    /// A builder for [`ReadSetListItem`](crate::model::ReadSetListItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) sequence_store_id: std::option::Option<std::string::String>,
        pub(crate) subject_id: std::option::Option<std::string::String>,
        pub(crate) sample_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ReadSetStatus>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) reference_arn: std::option::Option<std::string::String>,
        pub(crate) file_type: std::option::Option<crate::model::FileType>,
        pub(crate) sequence_information: std::option::Option<crate::model::SequenceInformation>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The read set's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The read set's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The read set's ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The read set's ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The read set's sequence store ID.</p>
        pub fn sequence_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sequence_store_id = Some(input.into());
            self
        }
        /// <p>The read set's sequence store ID.</p>
        pub fn set_sequence_store_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sequence_store_id = input;
            self
        }
        /// <p>The read set's subject ID.</p>
        pub fn subject_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subject_id = Some(input.into());
            self
        }
        /// <p>The read set's subject ID.</p>
        pub fn set_subject_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subject_id = input;
            self
        }
        /// <p>The read set's sample ID.</p>
        pub fn sample_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sample_id = Some(input.into());
            self
        }
        /// <p>The read set's sample ID.</p>
        pub fn set_sample_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sample_id = input;
            self
        }
        /// <p>The read set's status.</p>
        pub fn status(mut self, input: crate::model::ReadSetStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The read set's status.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ReadSetStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The read set's name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The read set's name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The read set's description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The read set's description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The read set's genome reference ARN.</p>
        pub fn reference_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.reference_arn = Some(input.into());
            self
        }
        /// <p>The read set's genome reference ARN.</p>
        pub fn set_reference_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reference_arn = input;
            self
        }
        /// <p>The read set's file type.</p>
        pub fn file_type(mut self, input: crate::model::FileType) -> Self {
            self.file_type = Some(input);
            self
        }
        /// <p>The read set's file type.</p>
        pub fn set_file_type(mut self, input: std::option::Option<crate::model::FileType>) -> Self {
            self.file_type = input;
            self
        }
        /// <p>Details about a sequence.</p>
        pub fn sequence_information(mut self, input: crate::model::SequenceInformation) -> Self {
            self.sequence_information = Some(input);
            self
        }
        /// <p>Details about a sequence.</p>
        pub fn set_sequence_information(
            mut self,
            input: std::option::Option<crate::model::SequenceInformation>,
        ) -> Self {
            self.sequence_information = input;
            self
        }
        /// <p>When the read set was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the read set was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ReadSetListItem`](crate::model::ReadSetListItem).
        pub fn build(self) -> crate::model::ReadSetListItem {
            crate::model::ReadSetListItem {
                id: self.id,
                arn: self.arn,
                sequence_store_id: self.sequence_store_id,
                subject_id: self.subject_id,
                sample_id: self.sample_id,
                status: self.status,
                name: self.name,
                description: self.description,
                reference_arn: self.reference_arn,
                file_type: self.file_type,
                sequence_information: self.sequence_information,
                creation_time: self.creation_time,
            }
        }
    }
}

/// <p>Details about a sequence.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SequenceInformation {
    /// <p>The sequence's total read count.</p>
    #[doc(hidden)]
    pub total_read_count: std::option::Option<i64>,
    /// <p>The sequence's total base count.</p>
    #[doc(hidden)]
    pub total_base_count: std::option::Option<i64>,
    /// <p>Where the sequence originated.</p>
    #[doc(hidden)]
    pub generated_from: std::option::Option<std::string::String>,
    /// <p>The sequence's alignment setting.</p>
    #[doc(hidden)]
    pub alignment: std::option::Option<std::string::String>,
}
impl SequenceInformation {
    /// <p>The sequence's total read count.</p>
    pub fn total_read_count(&self) -> std::option::Option<i64> {
        self.total_read_count
    }
    /// <p>The sequence's total base count.</p>
    pub fn total_base_count(&self) -> std::option::Option<i64> {
        self.total_base_count
    }
    /// <p>Where the sequence originated.</p>
    pub fn generated_from(&self) -> std::option::Option<&str> {
        self.generated_from.as_deref()
    }
    /// <p>The sequence's alignment setting.</p>
    pub fn alignment(&self) -> std::option::Option<&str> {
        self.alignment.as_deref()
    }
}
impl SequenceInformation {
    /// Creates a new builder-style object to manufacture [`SequenceInformation`](crate::model::SequenceInformation).
    pub fn builder() -> crate::model::sequence_information::Builder {
        crate::model::sequence_information::Builder::default()
    }
}

/// See [`SequenceInformation`](crate::model::SequenceInformation).
pub mod sequence_information {

    /// A builder for [`SequenceInformation`](crate::model::SequenceInformation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) total_read_count: std::option::Option<i64>,
        pub(crate) total_base_count: std::option::Option<i64>,
        pub(crate) generated_from: std::option::Option<std::string::String>,
        pub(crate) alignment: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The sequence's total read count.</p>
        pub fn total_read_count(mut self, input: i64) -> Self {
            self.total_read_count = Some(input);
            self
        }
        /// <p>The sequence's total read count.</p>
        pub fn set_total_read_count(mut self, input: std::option::Option<i64>) -> Self {
            self.total_read_count = input;
            self
        }
        /// <p>The sequence's total base count.</p>
        pub fn total_base_count(mut self, input: i64) -> Self {
            self.total_base_count = Some(input);
            self
        }
        /// <p>The sequence's total base count.</p>
        pub fn set_total_base_count(mut self, input: std::option::Option<i64>) -> Self {
            self.total_base_count = input;
            self
        }
        /// <p>Where the sequence originated.</p>
        pub fn generated_from(mut self, input: impl Into<std::string::String>) -> Self {
            self.generated_from = Some(input.into());
            self
        }
        /// <p>Where the sequence originated.</p>
        pub fn set_generated_from(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.generated_from = input;
            self
        }
        /// <p>The sequence's alignment setting.</p>
        pub fn alignment(mut self, input: impl Into<std::string::String>) -> Self {
            self.alignment = Some(input.into());
            self
        }
        /// <p>The sequence's alignment setting.</p>
        pub fn set_alignment(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alignment = input;
            self
        }
        /// Consumes the builder and constructs a [`SequenceInformation`](crate::model::SequenceInformation).
        pub fn build(self) -> crate::model::SequenceInformation {
            crate::model::SequenceInformation {
                total_read_count: self.total_read_count,
                total_base_count: self.total_base_count,
                generated_from: self.generated_from,
                alignment: self.alignment,
            }
        }
    }
}

/// When writing a match expression against `ReadSetStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let readsetstatus = unimplemented!();
/// match readsetstatus {
///     ReadSetStatus::Activating => { /* ... */ },
///     ReadSetStatus::Active => { /* ... */ },
///     ReadSetStatus::Archived => { /* ... */ },
///     ReadSetStatus::Deleted => { /* ... */ },
///     ReadSetStatus::Deleting => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `readsetstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ReadSetStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ReadSetStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ReadSetStatus::NewFeature` is defined.
/// Specifically, when `readsetstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ReadSetStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReadSetStatus {
    #[allow(missing_docs)] // documentation missing in model
    Activating,
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Archived,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ReadSetStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVATING" => ReadSetStatus::Activating,
            "ACTIVE" => ReadSetStatus::Active,
            "ARCHIVED" => ReadSetStatus::Archived,
            "DELETED" => ReadSetStatus::Deleted,
            "DELETING" => ReadSetStatus::Deleting,
            other => ReadSetStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ReadSetStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReadSetStatus::from(s))
    }
}
impl ReadSetStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReadSetStatus::Activating => "ACTIVATING",
            ReadSetStatus::Active => "ACTIVE",
            ReadSetStatus::Archived => "ARCHIVED",
            ReadSetStatus::Deleted => "DELETED",
            ReadSetStatus::Deleting => "DELETING",
            ReadSetStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVATING", "ACTIVE", "ARCHIVED", "DELETED", "DELETING"]
    }
}
impl AsRef<str> for ReadSetStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A filter for read sets.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReadSetFilter {
    /// <p>A name to filter on.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A status to filter on.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ReadSetStatus>,
    /// <p>A genome reference ARN to filter on.</p>
    #[doc(hidden)]
    pub reference_arn: std::option::Option<std::string::String>,
    /// <p>The filter's start date.</p>
    #[doc(hidden)]
    pub created_after: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The filter's end date.</p>
    #[doc(hidden)]
    pub created_before: std::option::Option<aws_smithy_types::DateTime>,
}
impl ReadSetFilter {
    /// <p>A name to filter on.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A status to filter on.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ReadSetStatus> {
        self.status.as_ref()
    }
    /// <p>A genome reference ARN to filter on.</p>
    pub fn reference_arn(&self) -> std::option::Option<&str> {
        self.reference_arn.as_deref()
    }
    /// <p>The filter's start date.</p>
    pub fn created_after(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_after.as_ref()
    }
    /// <p>The filter's end date.</p>
    pub fn created_before(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_before.as_ref()
    }
}
impl ReadSetFilter {
    /// Creates a new builder-style object to manufacture [`ReadSetFilter`](crate::model::ReadSetFilter).
    pub fn builder() -> crate::model::read_set_filter::Builder {
        crate::model::read_set_filter::Builder::default()
    }
}

/// See [`ReadSetFilter`](crate::model::ReadSetFilter).
pub mod read_set_filter {

    /// A builder for [`ReadSetFilter`](crate::model::ReadSetFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ReadSetStatus>,
        pub(crate) reference_arn: std::option::Option<std::string::String>,
        pub(crate) created_after: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_before: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>A name to filter on.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A name to filter on.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A status to filter on.</p>
        pub fn status(mut self, input: crate::model::ReadSetStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>A status to filter on.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ReadSetStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>A genome reference ARN to filter on.</p>
        pub fn reference_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.reference_arn = Some(input.into());
            self
        }
        /// <p>A genome reference ARN to filter on.</p>
        pub fn set_reference_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reference_arn = input;
            self
        }
        /// <p>The filter's start date.</p>
        pub fn created_after(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_after = Some(input);
            self
        }
        /// <p>The filter's start date.</p>
        pub fn set_created_after(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_after = input;
            self
        }
        /// <p>The filter's end date.</p>
        pub fn created_before(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_before = Some(input);
            self
        }
        /// <p>The filter's end date.</p>
        pub fn set_created_before(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_before = input;
            self
        }
        /// Consumes the builder and constructs a [`ReadSetFilter`](crate::model::ReadSetFilter).
        pub fn build(self) -> crate::model::ReadSetFilter {
            crate::model::ReadSetFilter {
                name: self.name,
                status: self.status,
                reference_arn: self.reference_arn,
                created_after: self.created_after,
                created_before: self.created_before,
            }
        }
    }
}

/// <p>Files in a read set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReadSetFiles {
    /// <p>The location of the first file in Amazon S3.</p>
    #[doc(hidden)]
    pub source1: std::option::Option<crate::model::FileInformation>,
    /// <p>The location of the second file in Amazon S3.</p>
    #[doc(hidden)]
    pub source2: std::option::Option<crate::model::FileInformation>,
    /// <p>The files' index.</p>
    #[doc(hidden)]
    pub index: std::option::Option<crate::model::FileInformation>,
}
impl ReadSetFiles {
    /// <p>The location of the first file in Amazon S3.</p>
    pub fn source1(&self) -> std::option::Option<&crate::model::FileInformation> {
        self.source1.as_ref()
    }
    /// <p>The location of the second file in Amazon S3.</p>
    pub fn source2(&self) -> std::option::Option<&crate::model::FileInformation> {
        self.source2.as_ref()
    }
    /// <p>The files' index.</p>
    pub fn index(&self) -> std::option::Option<&crate::model::FileInformation> {
        self.index.as_ref()
    }
}
impl ReadSetFiles {
    /// Creates a new builder-style object to manufacture [`ReadSetFiles`](crate::model::ReadSetFiles).
    pub fn builder() -> crate::model::read_set_files::Builder {
        crate::model::read_set_files::Builder::default()
    }
}

/// See [`ReadSetFiles`](crate::model::ReadSetFiles).
pub mod read_set_files {

    /// A builder for [`ReadSetFiles`](crate::model::ReadSetFiles).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source1: std::option::Option<crate::model::FileInformation>,
        pub(crate) source2: std::option::Option<crate::model::FileInformation>,
        pub(crate) index: std::option::Option<crate::model::FileInformation>,
    }
    impl Builder {
        /// <p>The location of the first file in Amazon S3.</p>
        pub fn source1(mut self, input: crate::model::FileInformation) -> Self {
            self.source1 = Some(input);
            self
        }
        /// <p>The location of the first file in Amazon S3.</p>
        pub fn set_source1(
            mut self,
            input: std::option::Option<crate::model::FileInformation>,
        ) -> Self {
            self.source1 = input;
            self
        }
        /// <p>The location of the second file in Amazon S3.</p>
        pub fn source2(mut self, input: crate::model::FileInformation) -> Self {
            self.source2 = Some(input);
            self
        }
        /// <p>The location of the second file in Amazon S3.</p>
        pub fn set_source2(
            mut self,
            input: std::option::Option<crate::model::FileInformation>,
        ) -> Self {
            self.source2 = input;
            self
        }
        /// <p>The files' index.</p>
        pub fn index(mut self, input: crate::model::FileInformation) -> Self {
            self.index = Some(input);
            self
        }
        /// <p>The files' index.</p>
        pub fn set_index(
            mut self,
            input: std::option::Option<crate::model::FileInformation>,
        ) -> Self {
            self.index = input;
            self
        }
        /// Consumes the builder and constructs a [`ReadSetFiles`](crate::model::ReadSetFiles).
        pub fn build(self) -> crate::model::ReadSetFiles {
            crate::model::ReadSetFiles {
                source1: self.source1,
                source2: self.source2,
                index: self.index,
            }
        }
    }
}

/// <p>Details about a file.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FileInformation {
    /// <p>The file's total parts.</p>
    #[doc(hidden)]
    pub total_parts: std::option::Option<i32>,
    /// <p>The file's part size.</p>
    #[doc(hidden)]
    pub part_size: std::option::Option<i64>,
    /// <p>The file's content length.</p>
    #[doc(hidden)]
    pub content_length: std::option::Option<i64>,
}
impl FileInformation {
    /// <p>The file's total parts.</p>
    pub fn total_parts(&self) -> std::option::Option<i32> {
        self.total_parts
    }
    /// <p>The file's part size.</p>
    pub fn part_size(&self) -> std::option::Option<i64> {
        self.part_size
    }
    /// <p>The file's content length.</p>
    pub fn content_length(&self) -> std::option::Option<i64> {
        self.content_length
    }
}
impl FileInformation {
    /// Creates a new builder-style object to manufacture [`FileInformation`](crate::model::FileInformation).
    pub fn builder() -> crate::model::file_information::Builder {
        crate::model::file_information::Builder::default()
    }
}

/// See [`FileInformation`](crate::model::FileInformation).
pub mod file_information {

    /// A builder for [`FileInformation`](crate::model::FileInformation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) total_parts: std::option::Option<i32>,
        pub(crate) part_size: std::option::Option<i64>,
        pub(crate) content_length: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The file's total parts.</p>
        pub fn total_parts(mut self, input: i32) -> Self {
            self.total_parts = Some(input);
            self
        }
        /// <p>The file's total parts.</p>
        pub fn set_total_parts(mut self, input: std::option::Option<i32>) -> Self {
            self.total_parts = input;
            self
        }
        /// <p>The file's part size.</p>
        pub fn part_size(mut self, input: i64) -> Self {
            self.part_size = Some(input);
            self
        }
        /// <p>The file's part size.</p>
        pub fn set_part_size(mut self, input: std::option::Option<i64>) -> Self {
            self.part_size = input;
            self
        }
        /// <p>The file's content length.</p>
        pub fn content_length(mut self, input: i64) -> Self {
            self.content_length = Some(input);
            self
        }
        /// <p>The file's content length.</p>
        pub fn set_content_length(mut self, input: std::option::Option<i64>) -> Self {
            self.content_length = input;
            self
        }
        /// Consumes the builder and constructs a [`FileInformation`](crate::model::FileInformation).
        pub fn build(self) -> crate::model::FileInformation {
            crate::model::FileInformation {
                total_parts: self.total_parts,
                part_size: self.part_size,
                content_length: self.content_length,
            }
        }
    }
}

/// <p>A workflow run.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RunListItem {
    /// <p>The run's ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The run's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The run's status.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::RunStatus>,
    /// <p>The run's workflow ID.</p>
    #[doc(hidden)]
    pub workflow_id: std::option::Option<std::string::String>,
    /// <p>The run's name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The run's priority.</p>
    #[doc(hidden)]
    pub priority: std::option::Option<i32>,
    /// <p>The run's storage capacity.</p>
    #[doc(hidden)]
    pub storage_capacity: std::option::Option<i32>,
    /// <p>When the run was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>When the run started.</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>When the run stopped.</p>
    #[doc(hidden)]
    pub stop_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl RunListItem {
    /// <p>The run's ARN.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The run's ID.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The run's status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::RunStatus> {
        self.status.as_ref()
    }
    /// <p>The run's workflow ID.</p>
    pub fn workflow_id(&self) -> std::option::Option<&str> {
        self.workflow_id.as_deref()
    }
    /// <p>The run's name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The run's priority.</p>
    pub fn priority(&self) -> std::option::Option<i32> {
        self.priority
    }
    /// <p>The run's storage capacity.</p>
    pub fn storage_capacity(&self) -> std::option::Option<i32> {
        self.storage_capacity
    }
    /// <p>When the run was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>When the run started.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>When the run stopped.</p>
    pub fn stop_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.stop_time.as_ref()
    }
}
impl RunListItem {
    /// Creates a new builder-style object to manufacture [`RunListItem`](crate::model::RunListItem).
    pub fn builder() -> crate::model::run_list_item::Builder {
        crate::model::run_list_item::Builder::default()
    }
}

/// See [`RunListItem`](crate::model::RunListItem).
pub mod run_list_item {

    /// A builder for [`RunListItem`](crate::model::RunListItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::RunStatus>,
        pub(crate) workflow_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) priority: std::option::Option<i32>,
        pub(crate) storage_capacity: std::option::Option<i32>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) stop_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The run's ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The run's ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The run's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The run's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The run's status.</p>
        pub fn status(mut self, input: crate::model::RunStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The run's status.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::RunStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p>The run's workflow ID.</p>
        pub fn workflow_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workflow_id = Some(input.into());
            self
        }
        /// <p>The run's workflow ID.</p>
        pub fn set_workflow_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workflow_id = input;
            self
        }
        /// <p>The run's name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The run's name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The run's priority.</p>
        pub fn priority(mut self, input: i32) -> Self {
            self.priority = Some(input);
            self
        }
        /// <p>The run's priority.</p>
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.priority = input;
            self
        }
        /// <p>The run's storage capacity.</p>
        pub fn storage_capacity(mut self, input: i32) -> Self {
            self.storage_capacity = Some(input);
            self
        }
        /// <p>The run's storage capacity.</p>
        pub fn set_storage_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.storage_capacity = input;
            self
        }
        /// <p>When the run was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the run was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>When the run started.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>When the run started.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>When the run stopped.</p>
        pub fn stop_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.stop_time = Some(input);
            self
        }
        /// <p>When the run stopped.</p>
        pub fn set_stop_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.stop_time = input;
            self
        }
        /// Consumes the builder and constructs a [`RunListItem`](crate::model::RunListItem).
        pub fn build(self) -> crate::model::RunListItem {
            crate::model::RunListItem {
                arn: self.arn,
                id: self.id,
                status: self.status,
                workflow_id: self.workflow_id,
                name: self.name,
                priority: self.priority,
                storage_capacity: self.storage_capacity,
                creation_time: self.creation_time,
                start_time: self.start_time,
                stop_time: self.stop_time,
            }
        }
    }
}

/// When writing a match expression against `RunStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let runstatus = unimplemented!();
/// match runstatus {
///     RunStatus::Cancelled => { /* ... */ },
///     RunStatus::Completed => { /* ... */ },
///     RunStatus::Deleted => { /* ... */ },
///     RunStatus::Failed => { /* ... */ },
///     RunStatus::Pending => { /* ... */ },
///     RunStatus::Running => { /* ... */ },
///     RunStatus::Starting => { /* ... */ },
///     RunStatus::Stopping => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `runstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RunStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RunStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RunStatus::NewFeature` is defined.
/// Specifically, when `runstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RunStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RunStatus {
    #[allow(missing_docs)] // documentation missing in model
    Cancelled,
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    #[allow(missing_docs)] // documentation missing in model
    Starting,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RunStatus {
    fn from(s: &str) -> Self {
        match s {
            "CANCELLED" => RunStatus::Cancelled,
            "COMPLETED" => RunStatus::Completed,
            "DELETED" => RunStatus::Deleted,
            "FAILED" => RunStatus::Failed,
            "PENDING" => RunStatus::Pending,
            "RUNNING" => RunStatus::Running,
            "STARTING" => RunStatus::Starting,
            "STOPPING" => RunStatus::Stopping,
            other => RunStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for RunStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RunStatus::from(s))
    }
}
impl RunStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RunStatus::Cancelled => "CANCELLED",
            RunStatus::Completed => "COMPLETED",
            RunStatus::Deleted => "DELETED",
            RunStatus::Failed => "FAILED",
            RunStatus::Pending => "PENDING",
            RunStatus::Running => "RUNNING",
            RunStatus::Starting => "STARTING",
            RunStatus::Stopping => "STOPPING",
            RunStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CANCELLED",
            "COMPLETED",
            "DELETED",
            "FAILED",
            "PENDING",
            "RUNNING",
            "STARTING",
            "STOPPING",
        ]
    }
}
impl AsRef<str> for RunStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `RunLogLevel`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let runloglevel = unimplemented!();
/// match runloglevel {
///     RunLogLevel::All => { /* ... */ },
///     RunLogLevel::Error => { /* ... */ },
///     RunLogLevel::Fatal => { /* ... */ },
///     RunLogLevel::Off => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `runloglevel` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RunLogLevel::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RunLogLevel::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RunLogLevel::NewFeature` is defined.
/// Specifically, when `runloglevel` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RunLogLevel::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RunLogLevel {
    #[allow(missing_docs)] // documentation missing in model
    All,
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    Fatal,
    #[allow(missing_docs)] // documentation missing in model
    Off,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RunLogLevel {
    fn from(s: &str) -> Self {
        match s {
            "ALL" => RunLogLevel::All,
            "ERROR" => RunLogLevel::Error,
            "FATAL" => RunLogLevel::Fatal,
            "OFF" => RunLogLevel::Off,
            other => RunLogLevel::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for RunLogLevel {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RunLogLevel::from(s))
    }
}
impl RunLogLevel {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RunLogLevel::All => "ALL",
            RunLogLevel::Error => "ERROR",
            RunLogLevel::Fatal => "FATAL",
            RunLogLevel::Off => "OFF",
            RunLogLevel::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALL", "ERROR", "FATAL", "OFF"]
    }
}
impl AsRef<str> for RunLogLevel {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `RunExport`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let runexport = unimplemented!();
/// match runexport {
///     RunExport::Definition => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `runexport` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RunExport::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RunExport::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RunExport::NewFeature` is defined.
/// Specifically, when `runexport` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RunExport::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RunExport {
    #[allow(missing_docs)] // documentation missing in model
    Definition,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RunExport {
    fn from(s: &str) -> Self {
        match s {
            "DEFINITION" => RunExport::Definition,
            other => RunExport::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for RunExport {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RunExport::from(s))
    }
}
impl RunExport {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RunExport::Definition => "DEFINITION",
            RunExport::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DEFINITION"]
    }
}
impl AsRef<str> for RunExport {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A workflow run task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TaskListItem {
    /// <p>The task's ID.</p>
    #[doc(hidden)]
    pub task_id: std::option::Option<std::string::String>,
    /// <p>The task's status.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::TaskStatus>,
    /// <p>The task's name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The task's CPU count.</p>
    #[doc(hidden)]
    pub cpus: std::option::Option<i32>,
    /// <p>The task's memory.</p>
    #[doc(hidden)]
    pub memory: std::option::Option<i32>,
    /// <p>When the task was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>When the task started.</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>When the task stopped.</p>
    #[doc(hidden)]
    pub stop_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl TaskListItem {
    /// <p>The task's ID.</p>
    pub fn task_id(&self) -> std::option::Option<&str> {
        self.task_id.as_deref()
    }
    /// <p>The task's status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::TaskStatus> {
        self.status.as_ref()
    }
    /// <p>The task's name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The task's CPU count.</p>
    pub fn cpus(&self) -> std::option::Option<i32> {
        self.cpus
    }
    /// <p>The task's memory.</p>
    pub fn memory(&self) -> std::option::Option<i32> {
        self.memory
    }
    /// <p>When the task was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>When the task started.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>When the task stopped.</p>
    pub fn stop_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.stop_time.as_ref()
    }
}
impl TaskListItem {
    /// Creates a new builder-style object to manufacture [`TaskListItem`](crate::model::TaskListItem).
    pub fn builder() -> crate::model::task_list_item::Builder {
        crate::model::task_list_item::Builder::default()
    }
}

/// See [`TaskListItem`](crate::model::TaskListItem).
pub mod task_list_item {

    /// A builder for [`TaskListItem`](crate::model::TaskListItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) task_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::TaskStatus>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) cpus: std::option::Option<i32>,
        pub(crate) memory: std::option::Option<i32>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) stop_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The task's ID.</p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_id = Some(input.into());
            self
        }
        /// <p>The task's ID.</p>
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_id = input;
            self
        }
        /// <p>The task's status.</p>
        pub fn status(mut self, input: crate::model::TaskStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The task's status.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::TaskStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p>The task's name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The task's name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The task's CPU count.</p>
        pub fn cpus(mut self, input: i32) -> Self {
            self.cpus = Some(input);
            self
        }
        /// <p>The task's CPU count.</p>
        pub fn set_cpus(mut self, input: std::option::Option<i32>) -> Self {
            self.cpus = input;
            self
        }
        /// <p>The task's memory.</p>
        pub fn memory(mut self, input: i32) -> Self {
            self.memory = Some(input);
            self
        }
        /// <p>The task's memory.</p>
        pub fn set_memory(mut self, input: std::option::Option<i32>) -> Self {
            self.memory = input;
            self
        }
        /// <p>When the task was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the task was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>When the task started.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>When the task started.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>When the task stopped.</p>
        pub fn stop_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.stop_time = Some(input);
            self
        }
        /// <p>When the task stopped.</p>
        pub fn set_stop_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.stop_time = input;
            self
        }
        /// Consumes the builder and constructs a [`TaskListItem`](crate::model::TaskListItem).
        pub fn build(self) -> crate::model::TaskListItem {
            crate::model::TaskListItem {
                task_id: self.task_id,
                status: self.status,
                name: self.name,
                cpus: self.cpus,
                memory: self.memory,
                creation_time: self.creation_time,
                start_time: self.start_time,
                stop_time: self.stop_time,
            }
        }
    }
}

/// When writing a match expression against `TaskStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let taskstatus = unimplemented!();
/// match taskstatus {
///     TaskStatus::Cancelled => { /* ... */ },
///     TaskStatus::Completed => { /* ... */ },
///     TaskStatus::Failed => { /* ... */ },
///     TaskStatus::Pending => { /* ... */ },
///     TaskStatus::Running => { /* ... */ },
///     TaskStatus::Starting => { /* ... */ },
///     TaskStatus::Stopping => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `taskstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TaskStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TaskStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TaskStatus::NewFeature` is defined.
/// Specifically, when `taskstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TaskStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TaskStatus {
    #[allow(missing_docs)] // documentation missing in model
    Cancelled,
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    #[allow(missing_docs)] // documentation missing in model
    Starting,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TaskStatus {
    fn from(s: &str) -> Self {
        match s {
            "CANCELLED" => TaskStatus::Cancelled,
            "COMPLETED" => TaskStatus::Completed,
            "FAILED" => TaskStatus::Failed,
            "PENDING" => TaskStatus::Pending,
            "RUNNING" => TaskStatus::Running,
            "STARTING" => TaskStatus::Starting,
            "STOPPING" => TaskStatus::Stopping,
            other => TaskStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for TaskStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TaskStatus::from(s))
    }
}
impl TaskStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TaskStatus::Cancelled => "CANCELLED",
            TaskStatus::Completed => "COMPLETED",
            TaskStatus::Failed => "FAILED",
            TaskStatus::Pending => "PENDING",
            TaskStatus::Running => "RUNNING",
            TaskStatus::Starting => "STARTING",
            TaskStatus::Stopping => "STOPPING",
            TaskStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CANCELLED",
            "COMPLETED",
            "FAILED",
            "PENDING",
            "RUNNING",
            "STARTING",
            "STOPPING",
        ]
    }
}
impl AsRef<str> for TaskStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A run group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RunGroupListItem {
    /// <p>The group's ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The group's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The group's name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The group's maximum CPU count setting.</p>
    #[doc(hidden)]
    pub max_cpus: std::option::Option<i32>,
    /// <p>The group's maximum concurrent run setting.</p>
    #[doc(hidden)]
    pub max_runs: std::option::Option<i32>,
    /// <p>The group's maximum duration setting.</p>
    #[doc(hidden)]
    pub max_duration: std::option::Option<i32>,
    /// <p>When the group was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl RunGroupListItem {
    /// <p>The group's ARN.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The group's ID.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The group's name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The group's maximum CPU count setting.</p>
    pub fn max_cpus(&self) -> std::option::Option<i32> {
        self.max_cpus
    }
    /// <p>The group's maximum concurrent run setting.</p>
    pub fn max_runs(&self) -> std::option::Option<i32> {
        self.max_runs
    }
    /// <p>The group's maximum duration setting.</p>
    pub fn max_duration(&self) -> std::option::Option<i32> {
        self.max_duration
    }
    /// <p>When the group was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
}
impl RunGroupListItem {
    /// Creates a new builder-style object to manufacture [`RunGroupListItem`](crate::model::RunGroupListItem).
    pub fn builder() -> crate::model::run_group_list_item::Builder {
        crate::model::run_group_list_item::Builder::default()
    }
}

/// See [`RunGroupListItem`](crate::model::RunGroupListItem).
pub mod run_group_list_item {

    /// A builder for [`RunGroupListItem`](crate::model::RunGroupListItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) max_cpus: std::option::Option<i32>,
        pub(crate) max_runs: std::option::Option<i32>,
        pub(crate) max_duration: std::option::Option<i32>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The group's ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The group's ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The group's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The group's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The group's name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The group's name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The group's maximum CPU count setting.</p>
        pub fn max_cpus(mut self, input: i32) -> Self {
            self.max_cpus = Some(input);
            self
        }
        /// <p>The group's maximum CPU count setting.</p>
        pub fn set_max_cpus(mut self, input: std::option::Option<i32>) -> Self {
            self.max_cpus = input;
            self
        }
        /// <p>The group's maximum concurrent run setting.</p>
        pub fn max_runs(mut self, input: i32) -> Self {
            self.max_runs = Some(input);
            self
        }
        /// <p>The group's maximum concurrent run setting.</p>
        pub fn set_max_runs(mut self, input: std::option::Option<i32>) -> Self {
            self.max_runs = input;
            self
        }
        /// <p>The group's maximum duration setting.</p>
        pub fn max_duration(mut self, input: i32) -> Self {
            self.max_duration = Some(input);
            self
        }
        /// <p>The group's maximum duration setting.</p>
        pub fn set_max_duration(mut self, input: std::option::Option<i32>) -> Self {
            self.max_duration = input;
            self
        }
        /// <p>When the group was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the group was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// Consumes the builder and constructs a [`RunGroupListItem`](crate::model::RunGroupListItem).
        pub fn build(self) -> crate::model::RunGroupListItem {
            crate::model::RunGroupListItem {
                arn: self.arn,
                id: self.id,
                name: self.name,
                max_cpus: self.max_cpus,
                max_runs: self.max_runs,
                max_duration: self.max_duration,
                creation_time: self.creation_time,
            }
        }
    }
}

/// When writing a match expression against `ReferenceImportJobStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let referenceimportjobstatus = unimplemented!();
/// match referenceimportjobstatus {
///     ReferenceImportJobStatus::Cancelled => { /* ... */ },
///     ReferenceImportJobStatus::Cancelling => { /* ... */ },
///     ReferenceImportJobStatus::Completed => { /* ... */ },
///     ReferenceImportJobStatus::CompletedWithFailures => { /* ... */ },
///     ReferenceImportJobStatus::Failed => { /* ... */ },
///     ReferenceImportJobStatus::InProgress => { /* ... */ },
///     ReferenceImportJobStatus::Submitted => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `referenceimportjobstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ReferenceImportJobStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ReferenceImportJobStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ReferenceImportJobStatus::NewFeature` is defined.
/// Specifically, when `referenceimportjobstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ReferenceImportJobStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReferenceImportJobStatus {
    #[allow(missing_docs)] // documentation missing in model
    Cancelled,
    #[allow(missing_docs)] // documentation missing in model
    Cancelling,
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    CompletedWithFailures,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Submitted,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ReferenceImportJobStatus {
    fn from(s: &str) -> Self {
        match s {
            "CANCELLED" => ReferenceImportJobStatus::Cancelled,
            "CANCELLING" => ReferenceImportJobStatus::Cancelling,
            "COMPLETED" => ReferenceImportJobStatus::Completed,
            "COMPLETED_WITH_FAILURES" => ReferenceImportJobStatus::CompletedWithFailures,
            "FAILED" => ReferenceImportJobStatus::Failed,
            "IN_PROGRESS" => ReferenceImportJobStatus::InProgress,
            "SUBMITTED" => ReferenceImportJobStatus::Submitted,
            other => ReferenceImportJobStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ReferenceImportJobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReferenceImportJobStatus::from(s))
    }
}
impl ReferenceImportJobStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReferenceImportJobStatus::Cancelled => "CANCELLED",
            ReferenceImportJobStatus::Cancelling => "CANCELLING",
            ReferenceImportJobStatus::Completed => "COMPLETED",
            ReferenceImportJobStatus::CompletedWithFailures => "COMPLETED_WITH_FAILURES",
            ReferenceImportJobStatus::Failed => "FAILED",
            ReferenceImportJobStatus::InProgress => "IN_PROGRESS",
            ReferenceImportJobStatus::Submitted => "SUBMITTED",
            ReferenceImportJobStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CANCELLED",
            "CANCELLING",
            "COMPLETED",
            "COMPLETED_WITH_FAILURES",
            "FAILED",
            "IN_PROGRESS",
            "SUBMITTED",
        ]
    }
}
impl AsRef<str> for ReferenceImportJobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A source for a reference import job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StartReferenceImportJobSourceItem {
    /// <p>The source file's location in Amazon S3.</p>
    #[doc(hidden)]
    pub source_file: std::option::Option<std::string::String>,
    /// <p>The source's name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The source's description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The source's tags.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl StartReferenceImportJobSourceItem {
    /// <p>The source file's location in Amazon S3.</p>
    pub fn source_file(&self) -> std::option::Option<&str> {
        self.source_file.as_deref()
    }
    /// <p>The source's name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The source's description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The source's tags.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl StartReferenceImportJobSourceItem {
    /// Creates a new builder-style object to manufacture [`StartReferenceImportJobSourceItem`](crate::model::StartReferenceImportJobSourceItem).
    pub fn builder() -> crate::model::start_reference_import_job_source_item::Builder {
        crate::model::start_reference_import_job_source_item::Builder::default()
    }
}

/// See [`StartReferenceImportJobSourceItem`](crate::model::StartReferenceImportJobSourceItem).
pub mod start_reference_import_job_source_item {

    /// A builder for [`StartReferenceImportJobSourceItem`](crate::model::StartReferenceImportJobSourceItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_file: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The source file's location in Amazon S3.</p>
        pub fn source_file(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_file = Some(input.into());
            self
        }
        /// <p>The source file's location in Amazon S3.</p>
        pub fn set_source_file(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_file = input;
            self
        }
        /// <p>The source's name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The source's name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The source's description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The source's description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The source's tags.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The source's tags.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`StartReferenceImportJobSourceItem`](crate::model::StartReferenceImportJobSourceItem).
        pub fn build(self) -> crate::model::StartReferenceImportJobSourceItem {
            crate::model::StartReferenceImportJobSourceItem {
                source_file: self.source_file,
                name: self.name,
                description: self.description,
                tags: self.tags,
            }
        }
    }
}

/// <p>An import reference job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ImportReferenceJobItem {
    /// <p>The job's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The job's reference store ID.</p>
    #[doc(hidden)]
    pub reference_store_id: std::option::Option<std::string::String>,
    /// <p>The job's service role ARN.</p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The job's status.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ReferenceImportJobStatus>,
    /// <p>When the job was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>When the job completed.</p>
    #[doc(hidden)]
    pub completion_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl ImportReferenceJobItem {
    /// <p>The job's ID.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The job's reference store ID.</p>
    pub fn reference_store_id(&self) -> std::option::Option<&str> {
        self.reference_store_id.as_deref()
    }
    /// <p>The job's service role ARN.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>The job's status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ReferenceImportJobStatus> {
        self.status.as_ref()
    }
    /// <p>When the job was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>When the job completed.</p>
    pub fn completion_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.completion_time.as_ref()
    }
}
impl ImportReferenceJobItem {
    /// Creates a new builder-style object to manufacture [`ImportReferenceJobItem`](crate::model::ImportReferenceJobItem).
    pub fn builder() -> crate::model::import_reference_job_item::Builder {
        crate::model::import_reference_job_item::Builder::default()
    }
}

/// See [`ImportReferenceJobItem`](crate::model::ImportReferenceJobItem).
pub mod import_reference_job_item {

    /// A builder for [`ImportReferenceJobItem`](crate::model::ImportReferenceJobItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) reference_store_id: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ReferenceImportJobStatus>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) completion_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The job's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The job's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The job's reference store ID.</p>
        pub fn reference_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.reference_store_id = Some(input.into());
            self
        }
        /// <p>The job's reference store ID.</p>
        pub fn set_reference_store_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reference_store_id = input;
            self
        }
        /// <p>The job's service role ARN.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The job's service role ARN.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>The job's status.</p>
        pub fn status(mut self, input: crate::model::ReferenceImportJobStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The job's status.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ReferenceImportJobStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>When the job was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the job was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>When the job completed.</p>
        pub fn completion_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.completion_time = Some(input);
            self
        }
        /// <p>When the job completed.</p>
        pub fn set_completion_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.completion_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ImportReferenceJobItem`](crate::model::ImportReferenceJobItem).
        pub fn build(self) -> crate::model::ImportReferenceJobItem {
            crate::model::ImportReferenceJobItem {
                id: self.id,
                reference_store_id: self.reference_store_id,
                role_arn: self.role_arn,
                status: self.status,
                creation_time: self.creation_time,
                completion_time: self.completion_time,
            }
        }
    }
}

/// <p>A filter for import references.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ImportReferenceFilter {
    /// <p>A status to filter on.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ReferenceImportJobStatus>,
    /// <p>The filter's start date.</p>
    #[doc(hidden)]
    pub created_after: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The filter's end date.</p>
    #[doc(hidden)]
    pub created_before: std::option::Option<aws_smithy_types::DateTime>,
}
impl ImportReferenceFilter {
    /// <p>A status to filter on.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ReferenceImportJobStatus> {
        self.status.as_ref()
    }
    /// <p>The filter's start date.</p>
    pub fn created_after(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_after.as_ref()
    }
    /// <p>The filter's end date.</p>
    pub fn created_before(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_before.as_ref()
    }
}
impl ImportReferenceFilter {
    /// Creates a new builder-style object to manufacture [`ImportReferenceFilter`](crate::model::ImportReferenceFilter).
    pub fn builder() -> crate::model::import_reference_filter::Builder {
        crate::model::import_reference_filter::Builder::default()
    }
}

/// See [`ImportReferenceFilter`](crate::model::ImportReferenceFilter).
pub mod import_reference_filter {

    /// A builder for [`ImportReferenceFilter`](crate::model::ImportReferenceFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::ReferenceImportJobStatus>,
        pub(crate) created_after: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_before: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>A status to filter on.</p>
        pub fn status(mut self, input: crate::model::ReferenceImportJobStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>A status to filter on.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ReferenceImportJobStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The filter's start date.</p>
        pub fn created_after(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_after = Some(input);
            self
        }
        /// <p>The filter's start date.</p>
        pub fn set_created_after(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_after = input;
            self
        }
        /// <p>The filter's end date.</p>
        pub fn created_before(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_before = Some(input);
            self
        }
        /// <p>The filter's end date.</p>
        pub fn set_created_before(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_before = input;
            self
        }
        /// Consumes the builder and constructs a [`ImportReferenceFilter`](crate::model::ImportReferenceFilter).
        pub fn build(self) -> crate::model::ImportReferenceFilter {
            crate::model::ImportReferenceFilter {
                status: self.status,
                created_after: self.created_after,
                created_before: self.created_before,
            }
        }
    }
}

/// <p>An genome reference source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ImportReferenceSourceItem {
    /// <p>The source file's location in Amazon S3.</p>
    #[doc(hidden)]
    pub source_file: std::option::Option<std::string::String>,
    /// <p>The source's status.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ReferenceImportJobItemStatus>,
    /// <p>The source's status message.</p>
    #[doc(hidden)]
    pub status_message: std::option::Option<std::string::String>,
    /// <p>The source's name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The source's description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The source's tags.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl ImportReferenceSourceItem {
    /// <p>The source file's location in Amazon S3.</p>
    pub fn source_file(&self) -> std::option::Option<&str> {
        self.source_file.as_deref()
    }
    /// <p>The source's status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ReferenceImportJobItemStatus> {
        self.status.as_ref()
    }
    /// <p>The source's status message.</p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
    /// <p>The source's name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The source's description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The source's tags.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl ImportReferenceSourceItem {
    /// Creates a new builder-style object to manufacture [`ImportReferenceSourceItem`](crate::model::ImportReferenceSourceItem).
    pub fn builder() -> crate::model::import_reference_source_item::Builder {
        crate::model::import_reference_source_item::Builder::default()
    }
}

/// See [`ImportReferenceSourceItem`](crate::model::ImportReferenceSourceItem).
pub mod import_reference_source_item {

    /// A builder for [`ImportReferenceSourceItem`](crate::model::ImportReferenceSourceItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_file: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ReferenceImportJobItemStatus>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The source file's location in Amazon S3.</p>
        pub fn source_file(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_file = Some(input.into());
            self
        }
        /// <p>The source file's location in Amazon S3.</p>
        pub fn set_source_file(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_file = input;
            self
        }
        /// <p>The source's status.</p>
        pub fn status(mut self, input: crate::model::ReferenceImportJobItemStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The source's status.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ReferenceImportJobItemStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The source's status message.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>The source's status message.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>The source's name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The source's name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The source's description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The source's description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The source's tags.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The source's tags.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ImportReferenceSourceItem`](crate::model::ImportReferenceSourceItem).
        pub fn build(self) -> crate::model::ImportReferenceSourceItem {
            crate::model::ImportReferenceSourceItem {
                source_file: self.source_file,
                status: self.status,
                status_message: self.status_message,
                name: self.name,
                description: self.description,
                tags: self.tags,
            }
        }
    }
}

/// When writing a match expression against `ReferenceImportJobItemStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let referenceimportjobitemstatus = unimplemented!();
/// match referenceimportjobitemstatus {
///     ReferenceImportJobItemStatus::Failed => { /* ... */ },
///     ReferenceImportJobItemStatus::Finished => { /* ... */ },
///     ReferenceImportJobItemStatus::InProgress => { /* ... */ },
///     ReferenceImportJobItemStatus::NotStarted => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `referenceimportjobitemstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ReferenceImportJobItemStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ReferenceImportJobItemStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ReferenceImportJobItemStatus::NewFeature` is defined.
/// Specifically, when `referenceimportjobitemstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ReferenceImportJobItemStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReferenceImportJobItemStatus {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Finished,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    NotStarted,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ReferenceImportJobItemStatus {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => ReferenceImportJobItemStatus::Failed,
            "FINISHED" => ReferenceImportJobItemStatus::Finished,
            "IN_PROGRESS" => ReferenceImportJobItemStatus::InProgress,
            "NOT_STARTED" => ReferenceImportJobItemStatus::NotStarted,
            other => ReferenceImportJobItemStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ReferenceImportJobItemStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReferenceImportJobItemStatus::from(s))
    }
}
impl ReferenceImportJobItemStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReferenceImportJobItemStatus::Failed => "FAILED",
            ReferenceImportJobItemStatus::Finished => "FINISHED",
            ReferenceImportJobItemStatus::InProgress => "IN_PROGRESS",
            ReferenceImportJobItemStatus::NotStarted => "NOT_STARTED",
            ReferenceImportJobItemStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FAILED", "FINISHED", "IN_PROGRESS", "NOT_STARTED"]
    }
}
impl AsRef<str> for ReferenceImportJobItemStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Details about a reference store.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReferenceStoreDetail {
    /// <p>The store's ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The store's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The store's name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The store's description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The store's server-side encryption (SSE) settings.</p>
    #[doc(hidden)]
    pub sse_config: std::option::Option<crate::model::SseConfig>,
    /// <p>When the store was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl ReferenceStoreDetail {
    /// <p>The store's ARN.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The store's ID.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The store's name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The store's description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The store's server-side encryption (SSE) settings.</p>
    pub fn sse_config(&self) -> std::option::Option<&crate::model::SseConfig> {
        self.sse_config.as_ref()
    }
    /// <p>When the store was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
}
impl ReferenceStoreDetail {
    /// Creates a new builder-style object to manufacture [`ReferenceStoreDetail`](crate::model::ReferenceStoreDetail).
    pub fn builder() -> crate::model::reference_store_detail::Builder {
        crate::model::reference_store_detail::Builder::default()
    }
}

/// See [`ReferenceStoreDetail`](crate::model::ReferenceStoreDetail).
pub mod reference_store_detail {

    /// A builder for [`ReferenceStoreDetail`](crate::model::ReferenceStoreDetail).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) sse_config: std::option::Option<crate::model::SseConfig>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The store's ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The store's ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The store's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The store's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The store's name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The store's name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The store's description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The store's description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The store's server-side encryption (SSE) settings.</p>
        pub fn sse_config(mut self, input: crate::model::SseConfig) -> Self {
            self.sse_config = Some(input);
            self
        }
        /// <p>The store's server-side encryption (SSE) settings.</p>
        pub fn set_sse_config(
            mut self,
            input: std::option::Option<crate::model::SseConfig>,
        ) -> Self {
            self.sse_config = input;
            self
        }
        /// <p>When the store was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the store was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ReferenceStoreDetail`](crate::model::ReferenceStoreDetail).
        pub fn build(self) -> crate::model::ReferenceStoreDetail {
            crate::model::ReferenceStoreDetail {
                arn: self.arn,
                id: self.id,
                name: self.name,
                description: self.description,
                sse_config: self.sse_config,
                creation_time: self.creation_time,
            }
        }
    }
}

/// <p>A filter for reference stores.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReferenceStoreFilter {
    /// <p>The name to filter on.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The filter's start date.</p>
    #[doc(hidden)]
    pub created_after: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The filter's end date.</p>
    #[doc(hidden)]
    pub created_before: std::option::Option<aws_smithy_types::DateTime>,
}
impl ReferenceStoreFilter {
    /// <p>The name to filter on.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The filter's start date.</p>
    pub fn created_after(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_after.as_ref()
    }
    /// <p>The filter's end date.</p>
    pub fn created_before(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_before.as_ref()
    }
}
impl ReferenceStoreFilter {
    /// Creates a new builder-style object to manufacture [`ReferenceStoreFilter`](crate::model::ReferenceStoreFilter).
    pub fn builder() -> crate::model::reference_store_filter::Builder {
        crate::model::reference_store_filter::Builder::default()
    }
}

/// See [`ReferenceStoreFilter`](crate::model::ReferenceStoreFilter).
pub mod reference_store_filter {

    /// A builder for [`ReferenceStoreFilter`](crate::model::ReferenceStoreFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) created_after: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_before: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The name to filter on.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name to filter on.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The filter's start date.</p>
        pub fn created_after(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_after = Some(input);
            self
        }
        /// <p>The filter's start date.</p>
        pub fn set_created_after(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_after = input;
            self
        }
        /// <p>The filter's end date.</p>
        pub fn created_before(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_before = Some(input);
            self
        }
        /// <p>The filter's end date.</p>
        pub fn set_created_before(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_before = input;
            self
        }
        /// Consumes the builder and constructs a [`ReferenceStoreFilter`](crate::model::ReferenceStoreFilter).
        pub fn build(self) -> crate::model::ReferenceStoreFilter {
            crate::model::ReferenceStoreFilter {
                name: self.name,
                created_after: self.created_after,
                created_before: self.created_before,
            }
        }
    }
}

/// When writing a match expression against `ReferenceFile`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let referencefile = unimplemented!();
/// match referencefile {
///     ReferenceFile::Index => { /* ... */ },
///     ReferenceFile::Source => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `referencefile` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ReferenceFile::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ReferenceFile::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ReferenceFile::NewFeature` is defined.
/// Specifically, when `referencefile` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ReferenceFile::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReferenceFile {
    #[allow(missing_docs)] // documentation missing in model
    Index,
    #[allow(missing_docs)] // documentation missing in model
    Source,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ReferenceFile {
    fn from(s: &str) -> Self {
        match s {
            "INDEX" => ReferenceFile::Index,
            "SOURCE" => ReferenceFile::Source,
            other => ReferenceFile::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ReferenceFile {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReferenceFile::from(s))
    }
}
impl ReferenceFile {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReferenceFile::Index => "INDEX",
            ReferenceFile::Source => "SOURCE",
            ReferenceFile::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["INDEX", "SOURCE"]
    }
}
impl AsRef<str> for ReferenceFile {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A genome reference.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReferenceListItem {
    /// <p>The reference's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The reference's ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The reference's store ID.</p>
    #[doc(hidden)]
    pub reference_store_id: std::option::Option<std::string::String>,
    /// <p>The reference's MD5 checksum.</p>
    #[doc(hidden)]
    pub md5: std::option::Option<std::string::String>,
    /// <p>The reference's status.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ReferenceStatus>,
    /// <p>The reference's name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The reference's description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>When the reference was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>When the reference was updated.</p>
    #[doc(hidden)]
    pub update_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl ReferenceListItem {
    /// <p>The reference's ID.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The reference's ARN.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The reference's store ID.</p>
    pub fn reference_store_id(&self) -> std::option::Option<&str> {
        self.reference_store_id.as_deref()
    }
    /// <p>The reference's MD5 checksum.</p>
    pub fn md5(&self) -> std::option::Option<&str> {
        self.md5.as_deref()
    }
    /// <p>The reference's status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ReferenceStatus> {
        self.status.as_ref()
    }
    /// <p>The reference's name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The reference's description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>When the reference was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>When the reference was updated.</p>
    pub fn update_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.update_time.as_ref()
    }
}
impl ReferenceListItem {
    /// Creates a new builder-style object to manufacture [`ReferenceListItem`](crate::model::ReferenceListItem).
    pub fn builder() -> crate::model::reference_list_item::Builder {
        crate::model::reference_list_item::Builder::default()
    }
}

/// See [`ReferenceListItem`](crate::model::ReferenceListItem).
pub mod reference_list_item {

    /// A builder for [`ReferenceListItem`](crate::model::ReferenceListItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) reference_store_id: std::option::Option<std::string::String>,
        pub(crate) md5: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ReferenceStatus>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The reference's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The reference's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The reference's ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The reference's ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The reference's store ID.</p>
        pub fn reference_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.reference_store_id = Some(input.into());
            self
        }
        /// <p>The reference's store ID.</p>
        pub fn set_reference_store_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reference_store_id = input;
            self
        }
        /// <p>The reference's MD5 checksum.</p>
        pub fn md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.md5 = Some(input.into());
            self
        }
        /// <p>The reference's MD5 checksum.</p>
        pub fn set_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.md5 = input;
            self
        }
        /// <p>The reference's status.</p>
        pub fn status(mut self, input: crate::model::ReferenceStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The reference's status.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ReferenceStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The reference's name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The reference's name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The reference's description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The reference's description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>When the reference was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the reference was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>When the reference was updated.</p>
        pub fn update_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_time = Some(input);
            self
        }
        /// <p>When the reference was updated.</p>
        pub fn set_update_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.update_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ReferenceListItem`](crate::model::ReferenceListItem).
        pub fn build(self) -> crate::model::ReferenceListItem {
            crate::model::ReferenceListItem {
                id: self.id,
                arn: self.arn,
                reference_store_id: self.reference_store_id,
                md5: self.md5,
                status: self.status,
                name: self.name,
                description: self.description,
                creation_time: self.creation_time,
                update_time: self.update_time,
            }
        }
    }
}

/// When writing a match expression against `ReferenceStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let referencestatus = unimplemented!();
/// match referencestatus {
///     ReferenceStatus::Active => { /* ... */ },
///     ReferenceStatus::Deleted => { /* ... */ },
///     ReferenceStatus::Deleting => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `referencestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ReferenceStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ReferenceStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ReferenceStatus::NewFeature` is defined.
/// Specifically, when `referencestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ReferenceStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReferenceStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ReferenceStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => ReferenceStatus::Active,
            "DELETED" => ReferenceStatus::Deleted,
            "DELETING" => ReferenceStatus::Deleting,
            other => ReferenceStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ReferenceStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReferenceStatus::from(s))
    }
}
impl ReferenceStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReferenceStatus::Active => "ACTIVE",
            ReferenceStatus::Deleted => "DELETED",
            ReferenceStatus::Deleting => "DELETING",
            ReferenceStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "DELETED", "DELETING"]
    }
}
impl AsRef<str> for ReferenceStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A filter for references.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReferenceFilter {
    /// <p>A name to filter on.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>An MD5 checksum to filter on.</p>
    #[doc(hidden)]
    pub md5: std::option::Option<std::string::String>,
    /// <p>The filter's start date.</p>
    #[doc(hidden)]
    pub created_after: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The filter's end date.</p>
    #[doc(hidden)]
    pub created_before: std::option::Option<aws_smithy_types::DateTime>,
}
impl ReferenceFilter {
    /// <p>A name to filter on.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>An MD5 checksum to filter on.</p>
    pub fn md5(&self) -> std::option::Option<&str> {
        self.md5.as_deref()
    }
    /// <p>The filter's start date.</p>
    pub fn created_after(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_after.as_ref()
    }
    /// <p>The filter's end date.</p>
    pub fn created_before(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_before.as_ref()
    }
}
impl ReferenceFilter {
    /// Creates a new builder-style object to manufacture [`ReferenceFilter`](crate::model::ReferenceFilter).
    pub fn builder() -> crate::model::reference_filter::Builder {
        crate::model::reference_filter::Builder::default()
    }
}

/// See [`ReferenceFilter`](crate::model::ReferenceFilter).
pub mod reference_filter {

    /// A builder for [`ReferenceFilter`](crate::model::ReferenceFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) md5: std::option::Option<std::string::String>,
        pub(crate) created_after: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_before: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>A name to filter on.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A name to filter on.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>An MD5 checksum to filter on.</p>
        pub fn md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.md5 = Some(input.into());
            self
        }
        /// <p>An MD5 checksum to filter on.</p>
        pub fn set_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.md5 = input;
            self
        }
        /// <p>The filter's start date.</p>
        pub fn created_after(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_after = Some(input);
            self
        }
        /// <p>The filter's start date.</p>
        pub fn set_created_after(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_after = input;
            self
        }
        /// <p>The filter's end date.</p>
        pub fn created_before(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_before = Some(input);
            self
        }
        /// <p>The filter's end date.</p>
        pub fn set_created_before(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_before = input;
            self
        }
        /// Consumes the builder and constructs a [`ReferenceFilter`](crate::model::ReferenceFilter).
        pub fn build(self) -> crate::model::ReferenceFilter {
            crate::model::ReferenceFilter {
                name: self.name,
                md5: self.md5,
                created_after: self.created_after,
                created_before: self.created_before,
            }
        }
    }
}

/// <p>A set of genome reference files.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReferenceFiles {
    /// <p>The source file's location in Amazon S3.</p>
    #[doc(hidden)]
    pub source: std::option::Option<crate::model::FileInformation>,
    /// <p>The files' index.</p>
    #[doc(hidden)]
    pub index: std::option::Option<crate::model::FileInformation>,
}
impl ReferenceFiles {
    /// <p>The source file's location in Amazon S3.</p>
    pub fn source(&self) -> std::option::Option<&crate::model::FileInformation> {
        self.source.as_ref()
    }
    /// <p>The files' index.</p>
    pub fn index(&self) -> std::option::Option<&crate::model::FileInformation> {
        self.index.as_ref()
    }
}
impl ReferenceFiles {
    /// Creates a new builder-style object to manufacture [`ReferenceFiles`](crate::model::ReferenceFiles).
    pub fn builder() -> crate::model::reference_files::Builder {
        crate::model::reference_files::Builder::default()
    }
}

/// See [`ReferenceFiles`](crate::model::ReferenceFiles).
pub mod reference_files {

    /// A builder for [`ReferenceFiles`](crate::model::ReferenceFiles).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source: std::option::Option<crate::model::FileInformation>,
        pub(crate) index: std::option::Option<crate::model::FileInformation>,
    }
    impl Builder {
        /// <p>The source file's location in Amazon S3.</p>
        pub fn source(mut self, input: crate::model::FileInformation) -> Self {
            self.source = Some(input);
            self
        }
        /// <p>The source file's location in Amazon S3.</p>
        pub fn set_source(
            mut self,
            input: std::option::Option<crate::model::FileInformation>,
        ) -> Self {
            self.source = input;
            self
        }
        /// <p>The files' index.</p>
        pub fn index(mut self, input: crate::model::FileInformation) -> Self {
            self.index = Some(input);
            self
        }
        /// <p>The files' index.</p>
        pub fn set_index(
            mut self,
            input: std::option::Option<crate::model::FileInformation>,
        ) -> Self {
            self.index = input;
            self
        }
        /// Consumes the builder and constructs a [`ReferenceFiles`](crate::model::ReferenceFiles).
        pub fn build(self) -> crate::model::ReferenceFiles {
            crate::model::ReferenceFiles {
                source: self.source,
                index: self.index,
            }
        }
    }
}

/// <p>An annotation store.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AnnotationStoreItem {
    /// <p>The store's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The store's genome reference.</p>
    #[doc(hidden)]
    pub reference: std::option::Option<crate::model::ReferenceItem>,
    /// <p>The store's status.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::StoreStatus>,
    /// <p>The store's ARN.</p>
    #[doc(hidden)]
    pub store_arn: std::option::Option<std::string::String>,
    /// <p>The store's name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The store's file format.</p>
    #[doc(hidden)]
    pub store_format: std::option::Option<crate::model::StoreFormat>,
    /// <p>The store's description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The store's server-side encryption (SSE) settings.</p>
    #[doc(hidden)]
    pub sse_config: std::option::Option<crate::model::SseConfig>,
    /// <p>The store's creation time.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>When the store was updated.</p>
    #[doc(hidden)]
    pub update_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The store's status message.</p>
    #[doc(hidden)]
    pub status_message: std::option::Option<std::string::String>,
    /// <p>The store's size in bytes.</p>
    #[doc(hidden)]
    pub store_size_bytes: std::option::Option<i64>,
}
impl AnnotationStoreItem {
    /// <p>The store's ID.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The store's genome reference.</p>
    pub fn reference(&self) -> std::option::Option<&crate::model::ReferenceItem> {
        self.reference.as_ref()
    }
    /// <p>The store's status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::StoreStatus> {
        self.status.as_ref()
    }
    /// <p>The store's ARN.</p>
    pub fn store_arn(&self) -> std::option::Option<&str> {
        self.store_arn.as_deref()
    }
    /// <p>The store's name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The store's file format.</p>
    pub fn store_format(&self) -> std::option::Option<&crate::model::StoreFormat> {
        self.store_format.as_ref()
    }
    /// <p>The store's description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The store's server-side encryption (SSE) settings.</p>
    pub fn sse_config(&self) -> std::option::Option<&crate::model::SseConfig> {
        self.sse_config.as_ref()
    }
    /// <p>The store's creation time.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>When the store was updated.</p>
    pub fn update_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.update_time.as_ref()
    }
    /// <p>The store's status message.</p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
    /// <p>The store's size in bytes.</p>
    pub fn store_size_bytes(&self) -> std::option::Option<i64> {
        self.store_size_bytes
    }
}
impl AnnotationStoreItem {
    /// Creates a new builder-style object to manufacture [`AnnotationStoreItem`](crate::model::AnnotationStoreItem).
    pub fn builder() -> crate::model::annotation_store_item::Builder {
        crate::model::annotation_store_item::Builder::default()
    }
}

/// See [`AnnotationStoreItem`](crate::model::AnnotationStoreItem).
pub mod annotation_store_item {

    /// A builder for [`AnnotationStoreItem`](crate::model::AnnotationStoreItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) reference: std::option::Option<crate::model::ReferenceItem>,
        pub(crate) status: std::option::Option<crate::model::StoreStatus>,
        pub(crate) store_arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) store_format: std::option::Option<crate::model::StoreFormat>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) sse_config: std::option::Option<crate::model::SseConfig>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) store_size_bytes: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The store's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The store's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The store's genome reference.</p>
        pub fn reference(mut self, input: crate::model::ReferenceItem) -> Self {
            self.reference = Some(input);
            self
        }
        /// <p>The store's genome reference.</p>
        pub fn set_reference(
            mut self,
            input: std::option::Option<crate::model::ReferenceItem>,
        ) -> Self {
            self.reference = input;
            self
        }
        /// <p>The store's status.</p>
        pub fn status(mut self, input: crate::model::StoreStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The store's status.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::StoreStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p>The store's ARN.</p>
        pub fn store_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.store_arn = Some(input.into());
            self
        }
        /// <p>The store's ARN.</p>
        pub fn set_store_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.store_arn = input;
            self
        }
        /// <p>The store's name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The store's name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The store's file format.</p>
        pub fn store_format(mut self, input: crate::model::StoreFormat) -> Self {
            self.store_format = Some(input);
            self
        }
        /// <p>The store's file format.</p>
        pub fn set_store_format(
            mut self,
            input: std::option::Option<crate::model::StoreFormat>,
        ) -> Self {
            self.store_format = input;
            self
        }
        /// <p>The store's description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The store's description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The store's server-side encryption (SSE) settings.</p>
        pub fn sse_config(mut self, input: crate::model::SseConfig) -> Self {
            self.sse_config = Some(input);
            self
        }
        /// <p>The store's server-side encryption (SSE) settings.</p>
        pub fn set_sse_config(
            mut self,
            input: std::option::Option<crate::model::SseConfig>,
        ) -> Self {
            self.sse_config = input;
            self
        }
        /// <p>The store's creation time.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The store's creation time.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>When the store was updated.</p>
        pub fn update_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_time = Some(input);
            self
        }
        /// <p>When the store was updated.</p>
        pub fn set_update_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.update_time = input;
            self
        }
        /// <p>The store's status message.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>The store's status message.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>The store's size in bytes.</p>
        pub fn store_size_bytes(mut self, input: i64) -> Self {
            self.store_size_bytes = Some(input);
            self
        }
        /// <p>The store's size in bytes.</p>
        pub fn set_store_size_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.store_size_bytes = input;
            self
        }
        /// Consumes the builder and constructs a [`AnnotationStoreItem`](crate::model::AnnotationStoreItem).
        pub fn build(self) -> crate::model::AnnotationStoreItem {
            crate::model::AnnotationStoreItem {
                id: self.id,
                reference: self.reference,
                status: self.status,
                store_arn: self.store_arn,
                name: self.name,
                store_format: self.store_format,
                description: self.description,
                sse_config: self.sse_config,
                creation_time: self.creation_time,
                update_time: self.update_time,
                status_message: self.status_message,
                store_size_bytes: self.store_size_bytes,
            }
        }
    }
}

/// When writing a match expression against `StoreFormat`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let storeformat = unimplemented!();
/// match storeformat {
///     StoreFormat::Gff => { /* ... */ },
///     StoreFormat::Tsv => { /* ... */ },
///     StoreFormat::Vcf => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `storeformat` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StoreFormat::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StoreFormat::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StoreFormat::NewFeature` is defined.
/// Specifically, when `storeformat` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StoreFormat::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StoreFormat {
    /// GFF3 Format
    Gff,
    /// TSV Format
    Tsv,
    /// VCF Format
    Vcf,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StoreFormat {
    fn from(s: &str) -> Self {
        match s {
            "GFF" => StoreFormat::Gff,
            "TSV" => StoreFormat::Tsv,
            "VCF" => StoreFormat::Vcf,
            other => StoreFormat::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for StoreFormat {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StoreFormat::from(s))
    }
}
impl StoreFormat {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StoreFormat::Gff => "GFF",
            StoreFormat::Tsv => "TSV",
            StoreFormat::Vcf => "VCF",
            StoreFormat::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["GFF", "TSV", "VCF"]
    }
}
impl AsRef<str> for StoreFormat {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A filter for annotation stores.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListAnnotationStoresFilter {
    /// <p>A status to filter on.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::StoreStatus>,
}
impl ListAnnotationStoresFilter {
    /// <p>A status to filter on.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::StoreStatus> {
        self.status.as_ref()
    }
}
impl ListAnnotationStoresFilter {
    /// Creates a new builder-style object to manufacture [`ListAnnotationStoresFilter`](crate::model::ListAnnotationStoresFilter).
    pub fn builder() -> crate::model::list_annotation_stores_filter::Builder {
        crate::model::list_annotation_stores_filter::Builder::default()
    }
}

/// See [`ListAnnotationStoresFilter`](crate::model::ListAnnotationStoresFilter).
pub mod list_annotation_stores_filter {

    /// A builder for [`ListAnnotationStoresFilter`](crate::model::ListAnnotationStoresFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::StoreStatus>,
    }
    impl Builder {
        /// <p>A status to filter on.</p>
        pub fn status(mut self, input: crate::model::StoreStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>A status to filter on.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::StoreStatus>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`ListAnnotationStoresFilter`](crate::model::ListAnnotationStoresFilter).
        pub fn build(self) -> crate::model::ListAnnotationStoresFilter {
            crate::model::ListAnnotationStoresFilter {
                status: self.status,
            }
        }
    }
}

/// <p>Settings for a store.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum StoreOptions {
    /// <p>File settings for a TSV store.</p>
    TsvStoreOptions(crate::model::TsvStoreOptions),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl StoreOptions {
    #[allow(irrefutable_let_patterns)]
    /// Tries to convert the enum instance into [`TsvStoreOptions`](crate::model::StoreOptions::TsvStoreOptions), extracting the inner [`TsvStoreOptions`](crate::model::TsvStoreOptions).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_tsv_store_options(
        &self,
    ) -> std::result::Result<&crate::model::TsvStoreOptions, &Self> {
        if let StoreOptions::TsvStoreOptions(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`TsvStoreOptions`](crate::model::StoreOptions::TsvStoreOptions).
    pub fn is_tsv_store_options(&self) -> bool {
        self.as_tsv_store_options().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>File settings for a TSV store.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TsvStoreOptions {
    /// <p>The store's annotation type.</p>
    #[doc(hidden)]
    pub annotation_type: std::option::Option<crate::model::AnnotationType>,
    /// <p>The store's header key to column name mapping.</p>
    #[doc(hidden)]
    pub format_to_header: std::option::Option<
        std::collections::HashMap<crate::model::FormatToHeaderKey, std::string::String>,
    >,
    /// <p>The store's schema.</p>
    #[doc(hidden)]
    pub schema: std::option::Option<
        std::vec::Vec<
            std::collections::HashMap<std::string::String, crate::model::SchemaValueType>,
        >,
    >,
}
impl TsvStoreOptions {
    /// <p>The store's annotation type.</p>
    pub fn annotation_type(&self) -> std::option::Option<&crate::model::AnnotationType> {
        self.annotation_type.as_ref()
    }
    /// <p>The store's header key to column name mapping.</p>
    pub fn format_to_header(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<crate::model::FormatToHeaderKey, std::string::String>,
    > {
        self.format_to_header.as_ref()
    }
    /// <p>The store's schema.</p>
    pub fn schema(
        &self,
    ) -> std::option::Option<
        &[std::collections::HashMap<std::string::String, crate::model::SchemaValueType>],
    > {
        self.schema.as_deref()
    }
}
impl TsvStoreOptions {
    /// Creates a new builder-style object to manufacture [`TsvStoreOptions`](crate::model::TsvStoreOptions).
    pub fn builder() -> crate::model::tsv_store_options::Builder {
        crate::model::tsv_store_options::Builder::default()
    }
}

/// See [`TsvStoreOptions`](crate::model::TsvStoreOptions).
pub mod tsv_store_options {

    /// A builder for [`TsvStoreOptions`](crate::model::TsvStoreOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) annotation_type: std::option::Option<crate::model::AnnotationType>,
        pub(crate) format_to_header: std::option::Option<
            std::collections::HashMap<crate::model::FormatToHeaderKey, std::string::String>,
        >,
        pub(crate) schema: std::option::Option<
            std::vec::Vec<
                std::collections::HashMap<std::string::String, crate::model::SchemaValueType>,
            >,
        >,
    }
    impl Builder {
        /// <p>The store's annotation type.</p>
        pub fn annotation_type(mut self, input: crate::model::AnnotationType) -> Self {
            self.annotation_type = Some(input);
            self
        }
        /// <p>The store's annotation type.</p>
        pub fn set_annotation_type(
            mut self,
            input: std::option::Option<crate::model::AnnotationType>,
        ) -> Self {
            self.annotation_type = input;
            self
        }
        /// Adds a key-value pair to `format_to_header`.
        ///
        /// To override the contents of this collection use [`set_format_to_header`](Self::set_format_to_header).
        ///
        /// <p>The store's header key to column name mapping.</p>
        pub fn format_to_header(
            mut self,
            k: crate::model::FormatToHeaderKey,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.format_to_header.unwrap_or_default();
            hash_map.insert(k, v.into());
            self.format_to_header = Some(hash_map);
            self
        }
        /// <p>The store's header key to column name mapping.</p>
        pub fn set_format_to_header(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<crate::model::FormatToHeaderKey, std::string::String>,
            >,
        ) -> Self {
            self.format_to_header = input;
            self
        }
        /// Appends an item to `schema`.
        ///
        /// To override the contents of this collection use [`set_schema`](Self::set_schema).
        ///
        /// <p>The store's schema.</p>
        pub fn schema(
            mut self,
            input: std::collections::HashMap<std::string::String, crate::model::SchemaValueType>,
        ) -> Self {
            let mut v = self.schema.unwrap_or_default();
            v.push(input);
            self.schema = Some(v);
            self
        }
        /// <p>The store's schema.</p>
        pub fn set_schema(
            mut self,
            input: std::option::Option<
                std::vec::Vec<
                    std::collections::HashMap<std::string::String, crate::model::SchemaValueType>,
                >,
            >,
        ) -> Self {
            self.schema = input;
            self
        }
        /// Consumes the builder and constructs a [`TsvStoreOptions`](crate::model::TsvStoreOptions).
        pub fn build(self) -> crate::model::TsvStoreOptions {
            crate::model::TsvStoreOptions {
                annotation_type: self.annotation_type,
                format_to_header: self.format_to_header,
                schema: self.schema,
            }
        }
    }
}

/// When writing a match expression against `SchemaValueType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let schemavaluetype = unimplemented!();
/// match schemavaluetype {
///     SchemaValueType::Boolean => { /* ... */ },
///     SchemaValueType::Double => { /* ... */ },
///     SchemaValueType::Float => { /* ... */ },
///     SchemaValueType::Int => { /* ... */ },
///     SchemaValueType::Long => { /* ... */ },
///     SchemaValueType::String => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `schemavaluetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SchemaValueType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SchemaValueType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SchemaValueType::NewFeature` is defined.
/// Specifically, when `schemavaluetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SchemaValueType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SchemaValueType {
    /// BOOLEAN type
    Boolean,
    /// DOUBLE type
    Double,
    /// FLOAT type
    Float,
    /// INT type
    Int,
    /// LONG type
    Long,
    /// STRING type
    String,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SchemaValueType {
    fn from(s: &str) -> Self {
        match s {
            "BOOLEAN" => SchemaValueType::Boolean,
            "DOUBLE" => SchemaValueType::Double,
            "FLOAT" => SchemaValueType::Float,
            "INT" => SchemaValueType::Int,
            "LONG" => SchemaValueType::Long,
            "STRING" => SchemaValueType::String,
            other => SchemaValueType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SchemaValueType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SchemaValueType::from(s))
    }
}
impl SchemaValueType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SchemaValueType::Boolean => "BOOLEAN",
            SchemaValueType::Double => "DOUBLE",
            SchemaValueType::Float => "FLOAT",
            SchemaValueType::Int => "INT",
            SchemaValueType::Long => "LONG",
            SchemaValueType::String => "STRING",
            SchemaValueType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["BOOLEAN", "DOUBLE", "FLOAT", "INT", "LONG", "STRING"]
    }
}
impl AsRef<str> for SchemaValueType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `FormatToHeaderKey`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let formattoheaderkey = unimplemented!();
/// match formattoheaderkey {
///     FormatToHeaderKey::Alt => { /* ... */ },
///     FormatToHeaderKey::Chr => { /* ... */ },
///     FormatToHeaderKey::End => { /* ... */ },
///     FormatToHeaderKey::Pos => { /* ... */ },
///     FormatToHeaderKey::Ref => { /* ... */ },
///     FormatToHeaderKey::Start => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `formattoheaderkey` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FormatToHeaderKey::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FormatToHeaderKey::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FormatToHeaderKey::NewFeature` is defined.
/// Specifically, when `formattoheaderkey` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FormatToHeaderKey::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FormatToHeaderKey {
    #[allow(missing_docs)] // documentation missing in model
    Alt,
    #[allow(missing_docs)] // documentation missing in model
    Chr,
    #[allow(missing_docs)] // documentation missing in model
    End,
    #[allow(missing_docs)] // documentation missing in model
    Pos,
    #[allow(missing_docs)] // documentation missing in model
    Ref,
    #[allow(missing_docs)] // documentation missing in model
    Start,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FormatToHeaderKey {
    fn from(s: &str) -> Self {
        match s {
            "ALT" => FormatToHeaderKey::Alt,
            "CHR" => FormatToHeaderKey::Chr,
            "END" => FormatToHeaderKey::End,
            "POS" => FormatToHeaderKey::Pos,
            "REF" => FormatToHeaderKey::Ref,
            "START" => FormatToHeaderKey::Start,
            other => {
                FormatToHeaderKey::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for FormatToHeaderKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FormatToHeaderKey::from(s))
    }
}
impl FormatToHeaderKey {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FormatToHeaderKey::Alt => "ALT",
            FormatToHeaderKey::Chr => "CHR",
            FormatToHeaderKey::End => "END",
            FormatToHeaderKey::Pos => "POS",
            FormatToHeaderKey::Ref => "REF",
            FormatToHeaderKey::Start => "START",
            FormatToHeaderKey::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALT", "CHR", "END", "POS", "REF", "START"]
    }
}
impl AsRef<str> for FormatToHeaderKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `AnnotationType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let annotationtype = unimplemented!();
/// match annotationtype {
///     AnnotationType::ChrPos => { /* ... */ },
///     AnnotationType::ChrPosRefAlt => { /* ... */ },
///     AnnotationType::ChrStartEndOneBase => { /* ... */ },
///     AnnotationType::ChrStartEndRefAltOneBase => { /* ... */ },
///     AnnotationType::ChrStartEndRefAltZeroBase => { /* ... */ },
///     AnnotationType::ChrStartEndZeroBase => { /* ... */ },
///     AnnotationType::Generic => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `annotationtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AnnotationType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AnnotationType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AnnotationType::NewFeature` is defined.
/// Specifically, when `annotationtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AnnotationType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AnnotationType {
    /// Contains contig and 1-base position
    ChrPos,
    /// Contains contig, 1-base position, ref and alt allele information
    ChrPosRefAlt,
    /// Contains contig, start, and end positions. Coordinates are 1-based
    ChrStartEndOneBase,
    /// Contains contig, start, end, ref and alt allele information. Coordinates are 1-based
    ChrStartEndRefAltOneBase,
    /// Contains contig, start, end, ref and alt allele information. Coordinates are 0-based
    ChrStartEndRefAltZeroBase,
    /// Contains contig, start, and end positions. Coordinates are 0-based
    ChrStartEndZeroBase,
    /// Generic text file. No genomic information
    Generic,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AnnotationType {
    fn from(s: &str) -> Self {
        match s {
            "CHR_POS" => AnnotationType::ChrPos,
            "CHR_POS_REF_ALT" => AnnotationType::ChrPosRefAlt,
            "CHR_START_END_ONE_BASE" => AnnotationType::ChrStartEndOneBase,
            "CHR_START_END_REF_ALT_ONE_BASE" => AnnotationType::ChrStartEndRefAltOneBase,
            "CHR_START_END_REF_ALT_ZERO_BASE" => AnnotationType::ChrStartEndRefAltZeroBase,
            "CHR_START_END_ZERO_BASE" => AnnotationType::ChrStartEndZeroBase,
            "GENERIC" => AnnotationType::Generic,
            other => AnnotationType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AnnotationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AnnotationType::from(s))
    }
}
impl AnnotationType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AnnotationType::ChrPos => "CHR_POS",
            AnnotationType::ChrPosRefAlt => "CHR_POS_REF_ALT",
            AnnotationType::ChrStartEndOneBase => "CHR_START_END_ONE_BASE",
            AnnotationType::ChrStartEndRefAltOneBase => "CHR_START_END_REF_ALT_ONE_BASE",
            AnnotationType::ChrStartEndRefAltZeroBase => "CHR_START_END_REF_ALT_ZERO_BASE",
            AnnotationType::ChrStartEndZeroBase => "CHR_START_END_ZERO_BASE",
            AnnotationType::Generic => "GENERIC",
            AnnotationType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CHR_POS",
            "CHR_POS_REF_ALT",
            "CHR_START_END_ONE_BASE",
            "CHR_START_END_REF_ALT_ONE_BASE",
            "CHR_START_END_REF_ALT_ZERO_BASE",
            "CHR_START_END_ZERO_BASE",
            "GENERIC",
        ]
    }
}
impl AsRef<str> for AnnotationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An annotation import job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AnnotationImportJobItem {
    /// <p>The job's ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The job's destination annotation store.</p>
    #[doc(hidden)]
    pub destination_name: std::option::Option<std::string::String>,
    /// <p>The job's service role ARN.</p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The job's status.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::JobStatus>,
    /// <p>When the job was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>When the job was updated.</p>
    #[doc(hidden)]
    pub update_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>When the job completed.</p>
    #[doc(hidden)]
    pub completion_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The job's left normalization setting.</p>
    #[doc(hidden)]
    pub run_left_normalization: bool,
}
impl AnnotationImportJobItem {
    /// <p>The job's ID.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The job's destination annotation store.</p>
    pub fn destination_name(&self) -> std::option::Option<&str> {
        self.destination_name.as_deref()
    }
    /// <p>The job's service role ARN.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>The job's status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.status.as_ref()
    }
    /// <p>When the job was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>When the job was updated.</p>
    pub fn update_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.update_time.as_ref()
    }
    /// <p>When the job completed.</p>
    pub fn completion_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.completion_time.as_ref()
    }
    /// <p>The job's left normalization setting.</p>
    pub fn run_left_normalization(&self) -> bool {
        self.run_left_normalization
    }
}
impl AnnotationImportJobItem {
    /// Creates a new builder-style object to manufacture [`AnnotationImportJobItem`](crate::model::AnnotationImportJobItem).
    pub fn builder() -> crate::model::annotation_import_job_item::Builder {
        crate::model::annotation_import_job_item::Builder::default()
    }
}

/// See [`AnnotationImportJobItem`](crate::model::AnnotationImportJobItem).
pub mod annotation_import_job_item {

    /// A builder for [`AnnotationImportJobItem`](crate::model::AnnotationImportJobItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) destination_name: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::JobStatus>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) completion_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) run_left_normalization: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The job's ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The job's ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The job's destination annotation store.</p>
        pub fn destination_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_name = Some(input.into());
            self
        }
        /// <p>The job's destination annotation store.</p>
        pub fn set_destination_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_name = input;
            self
        }
        /// <p>The job's service role ARN.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The job's service role ARN.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>The job's status.</p>
        pub fn status(mut self, input: crate::model::JobStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The job's status.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::JobStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p>When the job was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>When the job was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>When the job was updated.</p>
        pub fn update_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_time = Some(input);
            self
        }
        /// <p>When the job was updated.</p>
        pub fn set_update_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.update_time = input;
            self
        }
        /// <p>When the job completed.</p>
        pub fn completion_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.completion_time = Some(input);
            self
        }
        /// <p>When the job completed.</p>
        pub fn set_completion_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.completion_time = input;
            self
        }
        /// <p>The job's left normalization setting.</p>
        pub fn run_left_normalization(mut self, input: bool) -> Self {
            self.run_left_normalization = Some(input);
            self
        }
        /// <p>The job's left normalization setting.</p>
        pub fn set_run_left_normalization(mut self, input: std::option::Option<bool>) -> Self {
            self.run_left_normalization = input;
            self
        }
        /// Consumes the builder and constructs a [`AnnotationImportJobItem`](crate::model::AnnotationImportJobItem).
        pub fn build(self) -> crate::model::AnnotationImportJobItem {
            crate::model::AnnotationImportJobItem {
                id: self.id,
                destination_name: self.destination_name,
                role_arn: self.role_arn,
                status: self.status,
                creation_time: self.creation_time,
                update_time: self.update_time,
                completion_time: self.completion_time,
                run_left_normalization: self.run_left_normalization.unwrap_or_default(),
            }
        }
    }
}

/// <p>A filter for annotation import jobs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListAnnotationImportJobsFilter {
    /// <p>A status to filter on.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::JobStatus>,
    /// <p>A store name to filter on.</p>
    #[doc(hidden)]
    pub store_name: std::option::Option<std::string::String>,
}
impl ListAnnotationImportJobsFilter {
    /// <p>A status to filter on.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.status.as_ref()
    }
    /// <p>A store name to filter on.</p>
    pub fn store_name(&self) -> std::option::Option<&str> {
        self.store_name.as_deref()
    }
}
impl ListAnnotationImportJobsFilter {
    /// Creates a new builder-style object to manufacture [`ListAnnotationImportJobsFilter`](crate::model::ListAnnotationImportJobsFilter).
    pub fn builder() -> crate::model::list_annotation_import_jobs_filter::Builder {
        crate::model::list_annotation_import_jobs_filter::Builder::default()
    }
}

/// See [`ListAnnotationImportJobsFilter`](crate::model::ListAnnotationImportJobsFilter).
pub mod list_annotation_import_jobs_filter {

    /// A builder for [`ListAnnotationImportJobsFilter`](crate::model::ListAnnotationImportJobsFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::JobStatus>,
        pub(crate) store_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A status to filter on.</p>
        pub fn status(mut self, input: crate::model::JobStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>A status to filter on.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::JobStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p>A store name to filter on.</p>
        pub fn store_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.store_name = Some(input.into());
            self
        }
        /// <p>A store name to filter on.</p>
        pub fn set_store_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.store_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ListAnnotationImportJobsFilter`](crate::model::ListAnnotationImportJobsFilter).
        pub fn build(self) -> crate::model::ListAnnotationImportJobsFilter {
            crate::model::ListAnnotationImportJobsFilter {
                status: self.status,
                store_name: self.store_name,
            }
        }
    }
}

/// <p>Formatting options for a file.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum FormatOptions {
    /// <p>Options for a TSV file.</p>
    TsvOptions(crate::model::TsvOptions),
    /// <p>Options for a VCF file.</p>
    VcfOptions(crate::model::VcfOptions),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl FormatOptions {
    /// Tries to convert the enum instance into [`TsvOptions`](crate::model::FormatOptions::TsvOptions), extracting the inner [`TsvOptions`](crate::model::TsvOptions).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_tsv_options(&self) -> std::result::Result<&crate::model::TsvOptions, &Self> {
        if let FormatOptions::TsvOptions(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`TsvOptions`](crate::model::FormatOptions::TsvOptions).
    pub fn is_tsv_options(&self) -> bool {
        self.as_tsv_options().is_ok()
    }
    /// Tries to convert the enum instance into [`VcfOptions`](crate::model::FormatOptions::VcfOptions), extracting the inner [`VcfOptions`](crate::model::VcfOptions).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_vcf_options(&self) -> std::result::Result<&crate::model::VcfOptions, &Self> {
        if let FormatOptions::VcfOptions(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`VcfOptions`](crate::model::FormatOptions::VcfOptions).
    pub fn is_vcf_options(&self) -> bool {
        self.as_vcf_options().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Formatting options for a VCF file.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VcfOptions {
    /// <p>The file's ignore qual field setting.</p>
    #[doc(hidden)]
    pub ignore_qual_field: std::option::Option<bool>,
    /// <p>The file's ignore filter field setting.</p>
    #[doc(hidden)]
    pub ignore_filter_field: std::option::Option<bool>,
}
impl VcfOptions {
    /// <p>The file's ignore qual field setting.</p>
    pub fn ignore_qual_field(&self) -> std::option::Option<bool> {
        self.ignore_qual_field
    }
    /// <p>The file's ignore filter field setting.</p>
    pub fn ignore_filter_field(&self) -> std::option::Option<bool> {
        self.ignore_filter_field
    }
}
impl VcfOptions {
    /// Creates a new builder-style object to manufacture [`VcfOptions`](crate::model::VcfOptions).
    pub fn builder() -> crate::model::vcf_options::Builder {
        crate::model::vcf_options::Builder::default()
    }
}

/// See [`VcfOptions`](crate::model::VcfOptions).
pub mod vcf_options {

    /// A builder for [`VcfOptions`](crate::model::VcfOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ignore_qual_field: std::option::Option<bool>,
        pub(crate) ignore_filter_field: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The file's ignore qual field setting.</p>
        pub fn ignore_qual_field(mut self, input: bool) -> Self {
            self.ignore_qual_field = Some(input);
            self
        }
        /// <p>The file's ignore qual field setting.</p>
        pub fn set_ignore_qual_field(mut self, input: std::option::Option<bool>) -> Self {
            self.ignore_qual_field = input;
            self
        }
        /// <p>The file's ignore filter field setting.</p>
        pub fn ignore_filter_field(mut self, input: bool) -> Self {
            self.ignore_filter_field = Some(input);
            self
        }
        /// <p>The file's ignore filter field setting.</p>
        pub fn set_ignore_filter_field(mut self, input: std::option::Option<bool>) -> Self {
            self.ignore_filter_field = input;
            self
        }
        /// Consumes the builder and constructs a [`VcfOptions`](crate::model::VcfOptions).
        pub fn build(self) -> crate::model::VcfOptions {
            crate::model::VcfOptions {
                ignore_qual_field: self.ignore_qual_field,
                ignore_filter_field: self.ignore_filter_field,
            }
        }
    }
}

/// <p>Formatting options for a TSV file.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TsvOptions {
    /// <p>The file's read options.</p>
    #[doc(hidden)]
    pub read_options: std::option::Option<crate::model::ReadOptions>,
}
impl TsvOptions {
    /// <p>The file's read options.</p>
    pub fn read_options(&self) -> std::option::Option<&crate::model::ReadOptions> {
        self.read_options.as_ref()
    }
}
impl TsvOptions {
    /// Creates a new builder-style object to manufacture [`TsvOptions`](crate::model::TsvOptions).
    pub fn builder() -> crate::model::tsv_options::Builder {
        crate::model::tsv_options::Builder::default()
    }
}

/// See [`TsvOptions`](crate::model::TsvOptions).
pub mod tsv_options {

    /// A builder for [`TsvOptions`](crate::model::TsvOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) read_options: std::option::Option<crate::model::ReadOptions>,
    }
    impl Builder {
        /// <p>The file's read options.</p>
        pub fn read_options(mut self, input: crate::model::ReadOptions) -> Self {
            self.read_options = Some(input);
            self
        }
        /// <p>The file's read options.</p>
        pub fn set_read_options(
            mut self,
            input: std::option::Option<crate::model::ReadOptions>,
        ) -> Self {
            self.read_options = input;
            self
        }
        /// Consumes the builder and constructs a [`TsvOptions`](crate::model::TsvOptions).
        pub fn build(self) -> crate::model::TsvOptions {
            crate::model::TsvOptions {
                read_options: self.read_options,
            }
        }
    }
}

/// <p>Read options for an annotation import job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReadOptions {
    /// <p>The file's field separator.</p>
    #[doc(hidden)]
    pub sep: std::option::Option<std::string::String>,
    /// <p>The file's encoding.</p>
    #[doc(hidden)]
    pub encoding: std::option::Option<std::string::String>,
    /// <p>The file's quote character.</p>
    #[doc(hidden)]
    pub quote: std::option::Option<std::string::String>,
    /// <p>Whether all values need to be quoted, or just those that contain quotes.</p>
    #[doc(hidden)]
    pub quote_all: bool,
    /// <p>A character for escaping quotes in the file.</p>
    #[doc(hidden)]
    pub escape: std::option::Option<std::string::String>,
    /// <p>Whether quotes need to be escaped in the file.</p>
    #[doc(hidden)]
    pub escape_quotes: bool,
    /// <p>The file's comment character.</p>
    #[doc(hidden)]
    pub comment: std::option::Option<std::string::String>,
    /// <p>Whether the file has a header row.</p>
    #[doc(hidden)]
    pub header: bool,
    /// <p>A line separator for the file.</p>
    #[doc(hidden)]
    pub line_sep: std::option::Option<std::string::String>,
}
impl ReadOptions {
    /// <p>The file's field separator.</p>
    pub fn sep(&self) -> std::option::Option<&str> {
        self.sep.as_deref()
    }
    /// <p>The file's encoding.</p>
    pub fn encoding(&self) -> std::option::Option<&str> {
        self.encoding.as_deref()
    }
    /// <p>The file's quote character.</p>
    pub fn quote(&self) -> std::option::Option<&str> {
        self.quote.as_deref()
    }
    /// <p>Whether all values need to be quoted, or just those that contain quotes.</p>
    pub fn quote_all(&self) -> bool {
        self.quote_all
    }
    /// <p>A character for escaping quotes in the file.</p>
    pub fn escape(&self) -> std::option::Option<&str> {
        self.escape.as_deref()
    }
    /// <p>Whether quotes need to be escaped in the file.</p>
    pub fn escape_quotes(&self) -> bool {
        self.escape_quotes
    }
    /// <p>The file's comment character.</p>
    pub fn comment(&self) -> std::option::Option<&str> {
        self.comment.as_deref()
    }
    /// <p>Whether the file has a header row.</p>
    pub fn header(&self) -> bool {
        self.header
    }
    /// <p>A line separator for the file.</p>
    pub fn line_sep(&self) -> std::option::Option<&str> {
        self.line_sep.as_deref()
    }
}
impl ReadOptions {
    /// Creates a new builder-style object to manufacture [`ReadOptions`](crate::model::ReadOptions).
    pub fn builder() -> crate::model::read_options::Builder {
        crate::model::read_options::Builder::default()
    }
}

/// See [`ReadOptions`](crate::model::ReadOptions).
pub mod read_options {

    /// A builder for [`ReadOptions`](crate::model::ReadOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sep: std::option::Option<std::string::String>,
        pub(crate) encoding: std::option::Option<std::string::String>,
        pub(crate) quote: std::option::Option<std::string::String>,
        pub(crate) quote_all: std::option::Option<bool>,
        pub(crate) escape: std::option::Option<std::string::String>,
        pub(crate) escape_quotes: std::option::Option<bool>,
        pub(crate) comment: std::option::Option<std::string::String>,
        pub(crate) header: std::option::Option<bool>,
        pub(crate) line_sep: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The file's field separator.</p>
        pub fn sep(mut self, input: impl Into<std::string::String>) -> Self {
            self.sep = Some(input.into());
            self
        }
        /// <p>The file's field separator.</p>
        pub fn set_sep(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sep = input;
            self
        }
        /// <p>The file's encoding.</p>
        pub fn encoding(mut self, input: impl Into<std::string::String>) -> Self {
            self.encoding = Some(input.into());
            self
        }
        /// <p>The file's encoding.</p>
        pub fn set_encoding(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.encoding = input;
            self
        }
        /// <p>The file's quote character.</p>
        pub fn quote(mut self, input: impl Into<std::string::String>) -> Self {
            self.quote = Some(input.into());
            self
        }
        /// <p>The file's quote character.</p>
        pub fn set_quote(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.quote = input;
            self
        }
        /// <p>Whether all values need to be quoted, or just those that contain quotes.</p>
        pub fn quote_all(mut self, input: bool) -> Self {
            self.quote_all = Some(input);
            self
        }
        /// <p>Whether all values need to be quoted, or just those that contain quotes.</p>
        pub fn set_quote_all(mut self, input: std::option::Option<bool>) -> Self {
            self.quote_all = input;
            self
        }
        /// <p>A character for escaping quotes in the file.</p>
        pub fn escape(mut self, input: impl Into<std::string::String>) -> Self {
            self.escape = Some(input.into());
            self
        }
        /// <p>A character for escaping quotes in the file.</p>
        pub fn set_escape(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.escape = input;
            self
        }
        /// <p>Whether quotes need to be escaped in the file.</p>
        pub fn escape_quotes(mut self, input: bool) -> Self {
            self.escape_quotes = Some(input);
            self
        }
        /// <p>Whether quotes need to be escaped in the file.</p>
        pub fn set_escape_quotes(mut self, input: std::option::Option<bool>) -> Self {
            self.escape_quotes = input;
            self
        }
        /// <p>The file's comment character.</p>
        pub fn comment(mut self, input: impl Into<std::string::String>) -> Self {
            self.comment = Some(input.into());
            self
        }
        /// <p>The file's comment character.</p>
        pub fn set_comment(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.comment = input;
            self
        }
        /// <p>Whether the file has a header row.</p>
        pub fn header(mut self, input: bool) -> Self {
            self.header = Some(input);
            self
        }
        /// <p>Whether the file has a header row.</p>
        pub fn set_header(mut self, input: std::option::Option<bool>) -> Self {
            self.header = input;
            self
        }
        /// <p>A line separator for the file.</p>
        pub fn line_sep(mut self, input: impl Into<std::string::String>) -> Self {
            self.line_sep = Some(input.into());
            self
        }
        /// <p>A line separator for the file.</p>
        pub fn set_line_sep(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.line_sep = input;
            self
        }
        /// Consumes the builder and constructs a [`ReadOptions`](crate::model::ReadOptions).
        pub fn build(self) -> crate::model::ReadOptions {
            crate::model::ReadOptions {
                sep: self.sep,
                encoding: self.encoding,
                quote: self.quote,
                quote_all: self.quote_all.unwrap_or_default(),
                escape: self.escape,
                escape_quotes: self.escape_quotes.unwrap_or_default(),
                comment: self.comment,
                header: self.header.unwrap_or_default(),
                line_sep: self.line_sep,
            }
        }
    }
}

/// <p>A source for an annotation import job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AnnotationImportItemSource {
    /// <p>The source file's location in Amazon S3.</p>
    #[doc(hidden)]
    pub source: std::option::Option<std::string::String>,
}
impl AnnotationImportItemSource {
    /// <p>The source file's location in Amazon S3.</p>
    pub fn source(&self) -> std::option::Option<&str> {
        self.source.as_deref()
    }
}
impl AnnotationImportItemSource {
    /// Creates a new builder-style object to manufacture [`AnnotationImportItemSource`](crate::model::AnnotationImportItemSource).
    pub fn builder() -> crate::model::annotation_import_item_source::Builder {
        crate::model::annotation_import_item_source::Builder::default()
    }
}

/// See [`AnnotationImportItemSource`](crate::model::AnnotationImportItemSource).
pub mod annotation_import_item_source {

    /// A builder for [`AnnotationImportItemSource`](crate::model::AnnotationImportItemSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The source file's location in Amazon S3.</p>
        pub fn source(mut self, input: impl Into<std::string::String>) -> Self {
            self.source = Some(input.into());
            self
        }
        /// <p>The source file's location in Amazon S3.</p>
        pub fn set_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source = input;
            self
        }
        /// Consumes the builder and constructs a [`AnnotationImportItemSource`](crate::model::AnnotationImportItemSource).
        pub fn build(self) -> crate::model::AnnotationImportItemSource {
            crate::model::AnnotationImportItemSource {
                source: self.source,
            }
        }
    }
}

/// <p>Details about an imported annotation item.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AnnotationImportItemDetail {
    /// <p>The source file's location in Amazon S3.</p>
    #[doc(hidden)]
    pub source: std::option::Option<std::string::String>,
    /// <p>The item's job status.</p>
    #[doc(hidden)]
    pub job_status: std::option::Option<crate::model::JobStatus>,
}
impl AnnotationImportItemDetail {
    /// <p>The source file's location in Amazon S3.</p>
    pub fn source(&self) -> std::option::Option<&str> {
        self.source.as_deref()
    }
    /// <p>The item's job status.</p>
    pub fn job_status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.job_status.as_ref()
    }
}
impl AnnotationImportItemDetail {
    /// Creates a new builder-style object to manufacture [`AnnotationImportItemDetail`](crate::model::AnnotationImportItemDetail).
    pub fn builder() -> crate::model::annotation_import_item_detail::Builder {
        crate::model::annotation_import_item_detail::Builder::default()
    }
}

/// See [`AnnotationImportItemDetail`](crate::model::AnnotationImportItemDetail).
pub mod annotation_import_item_detail {

    /// A builder for [`AnnotationImportItemDetail`](crate::model::AnnotationImportItemDetail).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
    }
    impl Builder {
        /// <p>The source file's location in Amazon S3.</p>
        pub fn source(mut self, input: impl Into<std::string::String>) -> Self {
            self.source = Some(input.into());
            self
        }
        /// <p>The source file's location in Amazon S3.</p>
        pub fn set_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source = input;
            self
        }
        /// <p>The item's job status.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>The item's job status.</p>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// Consumes the builder and constructs a [`AnnotationImportItemDetail`](crate::model::AnnotationImportItemDetail).
        pub fn build(self) -> crate::model::AnnotationImportItemDetail {
            crate::model::AnnotationImportItemDetail {
                source: self.source,
                job_status: self.job_status,
            }
        }
    }
}
