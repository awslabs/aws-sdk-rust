// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Read options for an annotation import job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReadOptions {
    /// <p>The file's field separator.</p>
    #[doc(hidden)]
    pub sep: std::option::Option<std::string::String>,
    /// <p>The file's encoding.</p>
    #[doc(hidden)]
    pub encoding: std::option::Option<std::string::String>,
    /// <p>The file's quote character.</p>
    #[doc(hidden)]
    pub quote: std::option::Option<std::string::String>,
    /// <p>Whether all values need to be quoted, or just those that contain quotes.</p>
    #[doc(hidden)]
    pub quote_all: bool,
    /// <p>A character for escaping quotes in the file.</p>
    #[doc(hidden)]
    pub escape: std::option::Option<std::string::String>,
    /// <p>Whether quotes need to be escaped in the file.</p>
    #[doc(hidden)]
    pub escape_quotes: bool,
    /// <p>The file's comment character.</p>
    #[doc(hidden)]
    pub comment: std::option::Option<std::string::String>,
    /// <p>Whether the file has a header row.</p>
    #[doc(hidden)]
    pub header: bool,
    /// <p>A line separator for the file.</p>
    #[doc(hidden)]
    pub line_sep: std::option::Option<std::string::String>,
}
impl ReadOptions {
    /// <p>The file's field separator.</p>
    pub fn sep(&self) -> std::option::Option<&str> {
        self.sep.as_deref()
    }
    /// <p>The file's encoding.</p>
    pub fn encoding(&self) -> std::option::Option<&str> {
        self.encoding.as_deref()
    }
    /// <p>The file's quote character.</p>
    pub fn quote(&self) -> std::option::Option<&str> {
        self.quote.as_deref()
    }
    /// <p>Whether all values need to be quoted, or just those that contain quotes.</p>
    pub fn quote_all(&self) -> bool {
        self.quote_all
    }
    /// <p>A character for escaping quotes in the file.</p>
    pub fn escape(&self) -> std::option::Option<&str> {
        self.escape.as_deref()
    }
    /// <p>Whether quotes need to be escaped in the file.</p>
    pub fn escape_quotes(&self) -> bool {
        self.escape_quotes
    }
    /// <p>The file's comment character.</p>
    pub fn comment(&self) -> std::option::Option<&str> {
        self.comment.as_deref()
    }
    /// <p>Whether the file has a header row.</p>
    pub fn header(&self) -> bool {
        self.header
    }
    /// <p>A line separator for the file.</p>
    pub fn line_sep(&self) -> std::option::Option<&str> {
        self.line_sep.as_deref()
    }
}
impl ReadOptions {
    /// Creates a new builder-style object to manufacture [`ReadOptions`](crate::types::ReadOptions).
    pub fn builder() -> crate::types::builders::ReadOptionsBuilder {
        crate::types::builders::ReadOptionsBuilder::default()
    }
}

/// A builder for [`ReadOptions`](crate::types::ReadOptions).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct ReadOptionsBuilder {
    pub(crate) sep: std::option::Option<std::string::String>,
    pub(crate) encoding: std::option::Option<std::string::String>,
    pub(crate) quote: std::option::Option<std::string::String>,
    pub(crate) quote_all: std::option::Option<bool>,
    pub(crate) escape: std::option::Option<std::string::String>,
    pub(crate) escape_quotes: std::option::Option<bool>,
    pub(crate) comment: std::option::Option<std::string::String>,
    pub(crate) header: std::option::Option<bool>,
    pub(crate) line_sep: std::option::Option<std::string::String>,
}
impl ReadOptionsBuilder {
    /// <p>The file's field separator.</p>
    pub fn sep(mut self, input: impl Into<std::string::String>) -> Self {
        self.sep = Some(input.into());
        self
    }
    /// <p>The file's field separator.</p>
    pub fn set_sep(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.sep = input;
        self
    }
    /// <p>The file's encoding.</p>
    pub fn encoding(mut self, input: impl Into<std::string::String>) -> Self {
        self.encoding = Some(input.into());
        self
    }
    /// <p>The file's encoding.</p>
    pub fn set_encoding(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.encoding = input;
        self
    }
    /// <p>The file's quote character.</p>
    pub fn quote(mut self, input: impl Into<std::string::String>) -> Self {
        self.quote = Some(input.into());
        self
    }
    /// <p>The file's quote character.</p>
    pub fn set_quote(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.quote = input;
        self
    }
    /// <p>Whether all values need to be quoted, or just those that contain quotes.</p>
    pub fn quote_all(mut self, input: bool) -> Self {
        self.quote_all = Some(input);
        self
    }
    /// <p>Whether all values need to be quoted, or just those that contain quotes.</p>
    pub fn set_quote_all(mut self, input: std::option::Option<bool>) -> Self {
        self.quote_all = input;
        self
    }
    /// <p>A character for escaping quotes in the file.</p>
    pub fn escape(mut self, input: impl Into<std::string::String>) -> Self {
        self.escape = Some(input.into());
        self
    }
    /// <p>A character for escaping quotes in the file.</p>
    pub fn set_escape(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.escape = input;
        self
    }
    /// <p>Whether quotes need to be escaped in the file.</p>
    pub fn escape_quotes(mut self, input: bool) -> Self {
        self.escape_quotes = Some(input);
        self
    }
    /// <p>Whether quotes need to be escaped in the file.</p>
    pub fn set_escape_quotes(mut self, input: std::option::Option<bool>) -> Self {
        self.escape_quotes = input;
        self
    }
    /// <p>The file's comment character.</p>
    pub fn comment(mut self, input: impl Into<std::string::String>) -> Self {
        self.comment = Some(input.into());
        self
    }
    /// <p>The file's comment character.</p>
    pub fn set_comment(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.comment = input;
        self
    }
    /// <p>Whether the file has a header row.</p>
    pub fn header(mut self, input: bool) -> Self {
        self.header = Some(input);
        self
    }
    /// <p>Whether the file has a header row.</p>
    pub fn set_header(mut self, input: std::option::Option<bool>) -> Self {
        self.header = input;
        self
    }
    /// <p>A line separator for the file.</p>
    pub fn line_sep(mut self, input: impl Into<std::string::String>) -> Self {
        self.line_sep = Some(input.into());
        self
    }
    /// <p>A line separator for the file.</p>
    pub fn set_line_sep(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.line_sep = input;
        self
    }
    /// Consumes the builder and constructs a [`ReadOptions`](crate::types::ReadOptions).
    pub fn build(self) -> crate::types::ReadOptions {
        crate::types::ReadOptions {
            sep: self.sep,
            encoding: self.encoding,
            quote: self.quote,
            quote_all: self.quote_all.unwrap_or_default(),
            escape: self.escape,
            escape_quotes: self.escape_quotes.unwrap_or_default(),
            comment: self.comment,
            header: self.header.unwrap_or_default(),
            line_sep: self.line_sep,
        }
    }
}
