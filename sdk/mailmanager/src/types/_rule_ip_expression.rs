// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>An IP address expression matching certain IP addresses within a given range of IP addresses.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct RuleIpExpression {
    /// <p>The IP address to evaluate in this condition.</p>
    pub evaluate: ::std::option::Option<crate::types::RuleIpToEvaluate>,
    /// <p>The operator to evaluate the IP address.</p>
    pub operator: crate::types::RuleIpOperator,
    /// <p>The IP CIDR blocks in format "x.y.z.w/n" (eg 10.0.0.0/8) to match with the email's IP address. For the operator CIDR_MATCHES, if multiple values are given, they are evaluated as an OR. That is, if the IP address is contained within any of the given CIDR ranges, the condition is deemed to match. For NOT_CIDR_MATCHES, if multiple CIDR ranges are given, the condition is deemed to match if the IP address is not contained in any of the given CIDR ranges.</p>
    pub values: ::std::vec::Vec<::std::string::String>,
}
impl RuleIpExpression {
    /// <p>The IP address to evaluate in this condition.</p>
    pub fn evaluate(&self) -> ::std::option::Option<&crate::types::RuleIpToEvaluate> {
        self.evaluate.as_ref()
    }
    /// <p>The operator to evaluate the IP address.</p>
    pub fn operator(&self) -> &crate::types::RuleIpOperator {
        &self.operator
    }
    /// <p>The IP CIDR blocks in format "x.y.z.w/n" (eg 10.0.0.0/8) to match with the email's IP address. For the operator CIDR_MATCHES, if multiple values are given, they are evaluated as an OR. That is, if the IP address is contained within any of the given CIDR ranges, the condition is deemed to match. For NOT_CIDR_MATCHES, if multiple CIDR ranges are given, the condition is deemed to match if the IP address is not contained in any of the given CIDR ranges.</p>
    pub fn values(&self) -> &[::std::string::String] {
        use std::ops::Deref;
        self.values.deref()
    }
}
impl RuleIpExpression {
    /// Creates a new builder-style object to manufacture [`RuleIpExpression`](crate::types::RuleIpExpression).
    pub fn builder() -> crate::types::builders::RuleIpExpressionBuilder {
        crate::types::builders::RuleIpExpressionBuilder::default()
    }
}

/// A builder for [`RuleIpExpression`](crate::types::RuleIpExpression).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct RuleIpExpressionBuilder {
    pub(crate) evaluate: ::std::option::Option<crate::types::RuleIpToEvaluate>,
    pub(crate) operator: ::std::option::Option<crate::types::RuleIpOperator>,
    pub(crate) values: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
}
impl RuleIpExpressionBuilder {
    /// <p>The IP address to evaluate in this condition.</p>
    /// This field is required.
    pub fn evaluate(mut self, input: crate::types::RuleIpToEvaluate) -> Self {
        self.evaluate = ::std::option::Option::Some(input);
        self
    }
    /// <p>The IP address to evaluate in this condition.</p>
    pub fn set_evaluate(mut self, input: ::std::option::Option<crate::types::RuleIpToEvaluate>) -> Self {
        self.evaluate = input;
        self
    }
    /// <p>The IP address to evaluate in this condition.</p>
    pub fn get_evaluate(&self) -> &::std::option::Option<crate::types::RuleIpToEvaluate> {
        &self.evaluate
    }
    /// <p>The operator to evaluate the IP address.</p>
    /// This field is required.
    pub fn operator(mut self, input: crate::types::RuleIpOperator) -> Self {
        self.operator = ::std::option::Option::Some(input);
        self
    }
    /// <p>The operator to evaluate the IP address.</p>
    pub fn set_operator(mut self, input: ::std::option::Option<crate::types::RuleIpOperator>) -> Self {
        self.operator = input;
        self
    }
    /// <p>The operator to evaluate the IP address.</p>
    pub fn get_operator(&self) -> &::std::option::Option<crate::types::RuleIpOperator> {
        &self.operator
    }
    /// Appends an item to `values`.
    ///
    /// To override the contents of this collection use [`set_values`](Self::set_values).
    ///
    /// <p>The IP CIDR blocks in format "x.y.z.w/n" (eg 10.0.0.0/8) to match with the email's IP address. For the operator CIDR_MATCHES, if multiple values are given, they are evaluated as an OR. That is, if the IP address is contained within any of the given CIDR ranges, the condition is deemed to match. For NOT_CIDR_MATCHES, if multiple CIDR ranges are given, the condition is deemed to match if the IP address is not contained in any of the given CIDR ranges.</p>
    pub fn values(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.values.unwrap_or_default();
        v.push(input.into());
        self.values = ::std::option::Option::Some(v);
        self
    }
    /// <p>The IP CIDR blocks in format "x.y.z.w/n" (eg 10.0.0.0/8) to match with the email's IP address. For the operator CIDR_MATCHES, if multiple values are given, they are evaluated as an OR. That is, if the IP address is contained within any of the given CIDR ranges, the condition is deemed to match. For NOT_CIDR_MATCHES, if multiple CIDR ranges are given, the condition is deemed to match if the IP address is not contained in any of the given CIDR ranges.</p>
    pub fn set_values(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.values = input;
        self
    }
    /// <p>The IP CIDR blocks in format "x.y.z.w/n" (eg 10.0.0.0/8) to match with the email's IP address. For the operator CIDR_MATCHES, if multiple values are given, they are evaluated as an OR. That is, if the IP address is contained within any of the given CIDR ranges, the condition is deemed to match. For NOT_CIDR_MATCHES, if multiple CIDR ranges are given, the condition is deemed to match if the IP address is not contained in any of the given CIDR ranges.</p>
    pub fn get_values(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.values
    }
    /// Consumes the builder and constructs a [`RuleIpExpression`](crate::types::RuleIpExpression).
    /// This method will fail if any of the following fields are not set:
    /// - [`operator`](crate::types::builders::RuleIpExpressionBuilder::operator)
    /// - [`values`](crate::types::builders::RuleIpExpressionBuilder::values)
    pub fn build(self) -> ::std::result::Result<crate::types::RuleIpExpression, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::RuleIpExpression {
            evaluate: self.evaluate,
            operator: self.operator.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "operator",
                    "operator was not specified but it is required when building RuleIpExpression",
                )
            })?,
            values: self.values.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "values",
                    "values was not specified but it is required when building RuleIpExpression",
                )
            })?,
        })
    }
}
