// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A string expression is evaluated against strings or substrings of the email.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct RuleStringExpression {
    /// <p>The string to evaluate in a string condition expression.</p>
    pub evaluate: ::std::option::Option<crate::types::RuleStringToEvaluate>,
    /// <p>The matching operator for a string condition expression.</p>
    pub operator: crate::types::RuleStringOperator,
    /// <p>The string(s) to be evaluated in a string condition expression. For all operators, except for NOT_EQUALS, if multiple values are given, the values are processed as an OR. That is, if any of the values match the email's string using the given operator, the condition is deemed to match. However, for NOT_EQUALS, the condition is only deemed to match if none of the given strings match the email's string.</p>
    pub values: ::std::vec::Vec<::std::string::String>,
}
impl RuleStringExpression {
    /// <p>The string to evaluate in a string condition expression.</p>
    pub fn evaluate(&self) -> ::std::option::Option<&crate::types::RuleStringToEvaluate> {
        self.evaluate.as_ref()
    }
    /// <p>The matching operator for a string condition expression.</p>
    pub fn operator(&self) -> &crate::types::RuleStringOperator {
        &self.operator
    }
    /// <p>The string(s) to be evaluated in a string condition expression. For all operators, except for NOT_EQUALS, if multiple values are given, the values are processed as an OR. That is, if any of the values match the email's string using the given operator, the condition is deemed to match. However, for NOT_EQUALS, the condition is only deemed to match if none of the given strings match the email's string.</p>
    pub fn values(&self) -> &[::std::string::String] {
        use std::ops::Deref;
        self.values.deref()
    }
}
impl RuleStringExpression {
    /// Creates a new builder-style object to manufacture [`RuleStringExpression`](crate::types::RuleStringExpression).
    pub fn builder() -> crate::types::builders::RuleStringExpressionBuilder {
        crate::types::builders::RuleStringExpressionBuilder::default()
    }
}

/// A builder for [`RuleStringExpression`](crate::types::RuleStringExpression).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct RuleStringExpressionBuilder {
    pub(crate) evaluate: ::std::option::Option<crate::types::RuleStringToEvaluate>,
    pub(crate) operator: ::std::option::Option<crate::types::RuleStringOperator>,
    pub(crate) values: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
}
impl RuleStringExpressionBuilder {
    /// <p>The string to evaluate in a string condition expression.</p>
    /// This field is required.
    pub fn evaluate(mut self, input: crate::types::RuleStringToEvaluate) -> Self {
        self.evaluate = ::std::option::Option::Some(input);
        self
    }
    /// <p>The string to evaluate in a string condition expression.</p>
    pub fn set_evaluate(mut self, input: ::std::option::Option<crate::types::RuleStringToEvaluate>) -> Self {
        self.evaluate = input;
        self
    }
    /// <p>The string to evaluate in a string condition expression.</p>
    pub fn get_evaluate(&self) -> &::std::option::Option<crate::types::RuleStringToEvaluate> {
        &self.evaluate
    }
    /// <p>The matching operator for a string condition expression.</p>
    /// This field is required.
    pub fn operator(mut self, input: crate::types::RuleStringOperator) -> Self {
        self.operator = ::std::option::Option::Some(input);
        self
    }
    /// <p>The matching operator for a string condition expression.</p>
    pub fn set_operator(mut self, input: ::std::option::Option<crate::types::RuleStringOperator>) -> Self {
        self.operator = input;
        self
    }
    /// <p>The matching operator for a string condition expression.</p>
    pub fn get_operator(&self) -> &::std::option::Option<crate::types::RuleStringOperator> {
        &self.operator
    }
    /// Appends an item to `values`.
    ///
    /// To override the contents of this collection use [`set_values`](Self::set_values).
    ///
    /// <p>The string(s) to be evaluated in a string condition expression. For all operators, except for NOT_EQUALS, if multiple values are given, the values are processed as an OR. That is, if any of the values match the email's string using the given operator, the condition is deemed to match. However, for NOT_EQUALS, the condition is only deemed to match if none of the given strings match the email's string.</p>
    pub fn values(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.values.unwrap_or_default();
        v.push(input.into());
        self.values = ::std::option::Option::Some(v);
        self
    }
    /// <p>The string(s) to be evaluated in a string condition expression. For all operators, except for NOT_EQUALS, if multiple values are given, the values are processed as an OR. That is, if any of the values match the email's string using the given operator, the condition is deemed to match. However, for NOT_EQUALS, the condition is only deemed to match if none of the given strings match the email's string.</p>
    pub fn set_values(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.values = input;
        self
    }
    /// <p>The string(s) to be evaluated in a string condition expression. For all operators, except for NOT_EQUALS, if multiple values are given, the values are processed as an OR. That is, if any of the values match the email's string using the given operator, the condition is deemed to match. However, for NOT_EQUALS, the condition is only deemed to match if none of the given strings match the email's string.</p>
    pub fn get_values(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.values
    }
    /// Consumes the builder and constructs a [`RuleStringExpression`](crate::types::RuleStringExpression).
    /// This method will fail if any of the following fields are not set:
    /// - [`operator`](crate::types::builders::RuleStringExpressionBuilder::operator)
    /// - [`values`](crate::types::builders::RuleStringExpressionBuilder::values)
    pub fn build(self) -> ::std::result::Result<crate::types::RuleStringExpression, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::RuleStringExpression {
            evaluate: self.evaluate,
            operator: self.operator.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "operator",
                    "operator was not specified but it is required when building RuleStringExpression",
                )
            })?,
            values: self.values.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "values",
                    "values was not specified but it is required when building RuleStringExpression",
                )
            })?,
        })
    }
}
