// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The collection of computing resources from which an endpoint is created.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Workgroup {
    /// <p>The unique identifier of the workgroup.</p>
    #[doc(hidden)]
    pub workgroup_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) that links to the workgroup.</p>
    #[doc(hidden)]
    pub workgroup_arn: std::option::Option<std::string::String>,
    /// <p>The name of the workgroup.</p>
    #[doc(hidden)]
    pub workgroup_name: std::option::Option<std::string::String>,
    /// <p>The namespace the workgroup is associated with.</p>
    #[doc(hidden)]
    pub namespace_name: std::option::Option<std::string::String>,
    /// <p>The base data warehouse capacity of the workgroup in Redshift Processing Units (RPUs).</p>
    #[doc(hidden)]
    pub base_capacity: std::option::Option<i32>,
    /// <p>The value that specifies whether to enable enhanced virtual private cloud (VPC) routing, which forces Amazon Redshift Serverless to route traffic through your VPC.</p>
    #[doc(hidden)]
    pub enhanced_vpc_routing: std::option::Option<bool>,
    /// <p>An array of parameters to set for finer control over a database. The options are <code>datestyle</code>, <code>enable_user_activity_logging</code>, <code>query_group</code>, <code>search_path</code>, and <code>max_query_execution_time</code>.</p>
    #[doc(hidden)]
    pub config_parameters: std::option::Option<std::vec::Vec<crate::model::ConfigParameter>>,
    /// <p>An array of security group IDs to associate with the workgroup.</p>
    #[doc(hidden)]
    pub security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>An array of subnet IDs the workgroup is associated with.</p>
    #[doc(hidden)]
    pub subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The status of the workgroup.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::WorkgroupStatus>,
    /// <p>The endpoint that is created from the workgroup.</p>
    #[doc(hidden)]
    pub endpoint: std::option::Option<crate::model::Endpoint>,
    /// <p>A value that specifies whether the workgroup can be accessible from a public network</p>
    #[doc(hidden)]
    pub publicly_accessible: std::option::Option<bool>,
    /// <p>The creation date of the workgroup.</p>
    #[doc(hidden)]
    pub creation_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The custom port to use when connecting to a workgroup. Valid port ranges are 5431-5455 and 8191-8215. The default is 5439.</p>
    #[doc(hidden)]
    pub port: std::option::Option<i32>,
}
impl Workgroup {
    /// <p>The unique identifier of the workgroup.</p>
    pub fn workgroup_id(&self) -> std::option::Option<&str> {
        self.workgroup_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) that links to the workgroup.</p>
    pub fn workgroup_arn(&self) -> std::option::Option<&str> {
        self.workgroup_arn.as_deref()
    }
    /// <p>The name of the workgroup.</p>
    pub fn workgroup_name(&self) -> std::option::Option<&str> {
        self.workgroup_name.as_deref()
    }
    /// <p>The namespace the workgroup is associated with.</p>
    pub fn namespace_name(&self) -> std::option::Option<&str> {
        self.namespace_name.as_deref()
    }
    /// <p>The base data warehouse capacity of the workgroup in Redshift Processing Units (RPUs).</p>
    pub fn base_capacity(&self) -> std::option::Option<i32> {
        self.base_capacity
    }
    /// <p>The value that specifies whether to enable enhanced virtual private cloud (VPC) routing, which forces Amazon Redshift Serverless to route traffic through your VPC.</p>
    pub fn enhanced_vpc_routing(&self) -> std::option::Option<bool> {
        self.enhanced_vpc_routing
    }
    /// <p>An array of parameters to set for finer control over a database. The options are <code>datestyle</code>, <code>enable_user_activity_logging</code>, <code>query_group</code>, <code>search_path</code>, and <code>max_query_execution_time</code>.</p>
    pub fn config_parameters(&self) -> std::option::Option<&[crate::model::ConfigParameter]> {
        self.config_parameters.as_deref()
    }
    /// <p>An array of security group IDs to associate with the workgroup.</p>
    pub fn security_group_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.security_group_ids.as_deref()
    }
    /// <p>An array of subnet IDs the workgroup is associated with.</p>
    pub fn subnet_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.subnet_ids.as_deref()
    }
    /// <p>The status of the workgroup.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::WorkgroupStatus> {
        self.status.as_ref()
    }
    /// <p>The endpoint that is created from the workgroup.</p>
    pub fn endpoint(&self) -> std::option::Option<&crate::model::Endpoint> {
        self.endpoint.as_ref()
    }
    /// <p>A value that specifies whether the workgroup can be accessible from a public network</p>
    pub fn publicly_accessible(&self) -> std::option::Option<bool> {
        self.publicly_accessible
    }
    /// <p>The creation date of the workgroup.</p>
    pub fn creation_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_date.as_ref()
    }
    /// <p>The custom port to use when connecting to a workgroup. Valid port ranges are 5431-5455 and 8191-8215. The default is 5439.</p>
    pub fn port(&self) -> std::option::Option<i32> {
        self.port
    }
}
/// See [`Workgroup`](crate::model::Workgroup).
pub mod workgroup {

    /// A builder for [`Workgroup`](crate::model::Workgroup).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workgroup_id: std::option::Option<std::string::String>,
        pub(crate) workgroup_arn: std::option::Option<std::string::String>,
        pub(crate) workgroup_name: std::option::Option<std::string::String>,
        pub(crate) namespace_name: std::option::Option<std::string::String>,
        pub(crate) base_capacity: std::option::Option<i32>,
        pub(crate) enhanced_vpc_routing: std::option::Option<bool>,
        pub(crate) config_parameters:
            std::option::Option<std::vec::Vec<crate::model::ConfigParameter>>,
        pub(crate) security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) status: std::option::Option<crate::model::WorkgroupStatus>,
        pub(crate) endpoint: std::option::Option<crate::model::Endpoint>,
        pub(crate) publicly_accessible: std::option::Option<bool>,
        pub(crate) creation_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) port: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The unique identifier of the workgroup.</p>
        pub fn workgroup_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workgroup_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the workgroup.</p>
        pub fn set_workgroup_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workgroup_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) that links to the workgroup.</p>
        pub fn workgroup_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.workgroup_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) that links to the workgroup.</p>
        pub fn set_workgroup_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.workgroup_arn = input;
            self
        }
        /// <p>The name of the workgroup.</p>
        pub fn workgroup_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.workgroup_name = Some(input.into());
            self
        }
        /// <p>The name of the workgroup.</p>
        pub fn set_workgroup_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.workgroup_name = input;
            self
        }
        /// <p>The namespace the workgroup is associated with.</p>
        pub fn namespace_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace_name = Some(input.into());
            self
        }
        /// <p>The namespace the workgroup is associated with.</p>
        pub fn set_namespace_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.namespace_name = input;
            self
        }
        /// <p>The base data warehouse capacity of the workgroup in Redshift Processing Units (RPUs).</p>
        pub fn base_capacity(mut self, input: i32) -> Self {
            self.base_capacity = Some(input);
            self
        }
        /// <p>The base data warehouse capacity of the workgroup in Redshift Processing Units (RPUs).</p>
        pub fn set_base_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.base_capacity = input;
            self
        }
        /// <p>The value that specifies whether to enable enhanced virtual private cloud (VPC) routing, which forces Amazon Redshift Serverless to route traffic through your VPC.</p>
        pub fn enhanced_vpc_routing(mut self, input: bool) -> Self {
            self.enhanced_vpc_routing = Some(input);
            self
        }
        /// <p>The value that specifies whether to enable enhanced virtual private cloud (VPC) routing, which forces Amazon Redshift Serverless to route traffic through your VPC.</p>
        pub fn set_enhanced_vpc_routing(mut self, input: std::option::Option<bool>) -> Self {
            self.enhanced_vpc_routing = input;
            self
        }
        /// Appends an item to `config_parameters`.
        ///
        /// To override the contents of this collection use [`set_config_parameters`](Self::set_config_parameters).
        ///
        /// <p>An array of parameters to set for finer control over a database. The options are <code>datestyle</code>, <code>enable_user_activity_logging</code>, <code>query_group</code>, <code>search_path</code>, and <code>max_query_execution_time</code>.</p>
        pub fn config_parameters(mut self, input: crate::model::ConfigParameter) -> Self {
            let mut v = self.config_parameters.unwrap_or_default();
            v.push(input);
            self.config_parameters = Some(v);
            self
        }
        /// <p>An array of parameters to set for finer control over a database. The options are <code>datestyle</code>, <code>enable_user_activity_logging</code>, <code>query_group</code>, <code>search_path</code>, and <code>max_query_execution_time</code>.</p>
        pub fn set_config_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ConfigParameter>>,
        ) -> Self {
            self.config_parameters = input;
            self
        }
        /// Appends an item to `security_group_ids`.
        ///
        /// To override the contents of this collection use [`set_security_group_ids`](Self::set_security_group_ids).
        ///
        /// <p>An array of security group IDs to associate with the workgroup.</p>
        pub fn security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.security_group_ids = Some(v);
            self
        }
        /// <p>An array of security group IDs to associate with the workgroup.</p>
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_ids = input;
            self
        }
        /// Appends an item to `subnet_ids`.
        ///
        /// To override the contents of this collection use [`set_subnet_ids`](Self::set_subnet_ids).
        ///
        /// <p>An array of subnet IDs the workgroup is associated with.</p>
        pub fn subnet_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnet_ids.unwrap_or_default();
            v.push(input.into());
            self.subnet_ids = Some(v);
            self
        }
        /// <p>An array of subnet IDs the workgroup is associated with.</p>
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnet_ids = input;
            self
        }
        /// <p>The status of the workgroup.</p>
        pub fn status(mut self, input: crate::model::WorkgroupStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the workgroup.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::WorkgroupStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The endpoint that is created from the workgroup.</p>
        pub fn endpoint(mut self, input: crate::model::Endpoint) -> Self {
            self.endpoint = Some(input);
            self
        }
        /// <p>The endpoint that is created from the workgroup.</p>
        pub fn set_endpoint(mut self, input: std::option::Option<crate::model::Endpoint>) -> Self {
            self.endpoint = input;
            self
        }
        /// <p>A value that specifies whether the workgroup can be accessible from a public network</p>
        pub fn publicly_accessible(mut self, input: bool) -> Self {
            self.publicly_accessible = Some(input);
            self
        }
        /// <p>A value that specifies whether the workgroup can be accessible from a public network</p>
        pub fn set_publicly_accessible(mut self, input: std::option::Option<bool>) -> Self {
            self.publicly_accessible = input;
            self
        }
        /// <p>The creation date of the workgroup.</p>
        pub fn creation_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_date = Some(input);
            self
        }
        /// <p>The creation date of the workgroup.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>The custom port to use when connecting to a workgroup. Valid port ranges are 5431-5455 and 8191-8215. The default is 5439.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        /// <p>The custom port to use when connecting to a workgroup. Valid port ranges are 5431-5455 and 8191-8215. The default is 5439.</p>
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        /// Consumes the builder and constructs a [`Workgroup`](crate::model::Workgroup).
        pub fn build(self) -> crate::model::Workgroup {
            crate::model::Workgroup {
                workgroup_id: self.workgroup_id,
                workgroup_arn: self.workgroup_arn,
                workgroup_name: self.workgroup_name,
                namespace_name: self.namespace_name,
                base_capacity: self.base_capacity,
                enhanced_vpc_routing: self.enhanced_vpc_routing,
                config_parameters: self.config_parameters,
                security_group_ids: self.security_group_ids,
                subnet_ids: self.subnet_ids,
                status: self.status,
                endpoint: self.endpoint,
                publicly_accessible: self.publicly_accessible,
                creation_date: self.creation_date,
                port: self.port,
            }
        }
    }
}
impl Workgroup {
    /// Creates a new builder-style object to manufacture [`Workgroup`](crate::model::Workgroup).
    pub fn builder() -> crate::model::workgroup::Builder {
        crate::model::workgroup::Builder::default()
    }
}

/// <p>The VPC endpoint object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Endpoint {
    /// <p>The DNS address of the VPC endpoint.</p>
    #[doc(hidden)]
    pub address: std::option::Option<std::string::String>,
    /// <p>The port that Amazon Redshift Serverless listens on.</p>
    #[doc(hidden)]
    pub port: std::option::Option<i32>,
    /// <p>An array of <code>VpcEndpoint</code> objects.</p>
    #[doc(hidden)]
    pub vpc_endpoints: std::option::Option<std::vec::Vec<crate::model::VpcEndpoint>>,
}
impl Endpoint {
    /// <p>The DNS address of the VPC endpoint.</p>
    pub fn address(&self) -> std::option::Option<&str> {
        self.address.as_deref()
    }
    /// <p>The port that Amazon Redshift Serverless listens on.</p>
    pub fn port(&self) -> std::option::Option<i32> {
        self.port
    }
    /// <p>An array of <code>VpcEndpoint</code> objects.</p>
    pub fn vpc_endpoints(&self) -> std::option::Option<&[crate::model::VpcEndpoint]> {
        self.vpc_endpoints.as_deref()
    }
}
/// See [`Endpoint`](crate::model::Endpoint).
pub mod endpoint {

    /// A builder for [`Endpoint`](crate::model::Endpoint).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) address: std::option::Option<std::string::String>,
        pub(crate) port: std::option::Option<i32>,
        pub(crate) vpc_endpoints: std::option::Option<std::vec::Vec<crate::model::VpcEndpoint>>,
    }
    impl Builder {
        /// <p>The DNS address of the VPC endpoint.</p>
        pub fn address(mut self, input: impl Into<std::string::String>) -> Self {
            self.address = Some(input.into());
            self
        }
        /// <p>The DNS address of the VPC endpoint.</p>
        pub fn set_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.address = input;
            self
        }
        /// <p>The port that Amazon Redshift Serverless listens on.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        /// <p>The port that Amazon Redshift Serverless listens on.</p>
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        /// Appends an item to `vpc_endpoints`.
        ///
        /// To override the contents of this collection use [`set_vpc_endpoints`](Self::set_vpc_endpoints).
        ///
        /// <p>An array of <code>VpcEndpoint</code> objects.</p>
        pub fn vpc_endpoints(mut self, input: crate::model::VpcEndpoint) -> Self {
            let mut v = self.vpc_endpoints.unwrap_or_default();
            v.push(input);
            self.vpc_endpoints = Some(v);
            self
        }
        /// <p>An array of <code>VpcEndpoint</code> objects.</p>
        pub fn set_vpc_endpoints(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VpcEndpoint>>,
        ) -> Self {
            self.vpc_endpoints = input;
            self
        }
        /// Consumes the builder and constructs a [`Endpoint`](crate::model::Endpoint).
        pub fn build(self) -> crate::model::Endpoint {
            crate::model::Endpoint {
                address: self.address,
                port: self.port,
                vpc_endpoints: self.vpc_endpoints,
            }
        }
    }
}
impl Endpoint {
    /// Creates a new builder-style object to manufacture [`Endpoint`](crate::model::Endpoint).
    pub fn builder() -> crate::model::endpoint::Builder {
        crate::model::endpoint::Builder::default()
    }
}

/// <p>The connection endpoint for connecting to Amazon Redshift Serverless through the proxy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VpcEndpoint {
    /// <p>The connection endpoint ID for connecting to Amazon Redshift Serverless.</p>
    #[doc(hidden)]
    pub vpc_endpoint_id: std::option::Option<std::string::String>,
    /// <p>The VPC identifier that the endpoint is associated with.</p>
    #[doc(hidden)]
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>One or more network interfaces of the endpoint. Also known as an interface endpoint.</p>
    #[doc(hidden)]
    pub network_interfaces: std::option::Option<std::vec::Vec<crate::model::NetworkInterface>>,
}
impl VpcEndpoint {
    /// <p>The connection endpoint ID for connecting to Amazon Redshift Serverless.</p>
    pub fn vpc_endpoint_id(&self) -> std::option::Option<&str> {
        self.vpc_endpoint_id.as_deref()
    }
    /// <p>The VPC identifier that the endpoint is associated with.</p>
    pub fn vpc_id(&self) -> std::option::Option<&str> {
        self.vpc_id.as_deref()
    }
    /// <p>One or more network interfaces of the endpoint. Also known as an interface endpoint.</p>
    pub fn network_interfaces(&self) -> std::option::Option<&[crate::model::NetworkInterface]> {
        self.network_interfaces.as_deref()
    }
}
/// See [`VpcEndpoint`](crate::model::VpcEndpoint).
pub mod vpc_endpoint {

    /// A builder for [`VpcEndpoint`](crate::model::VpcEndpoint).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vpc_endpoint_id: std::option::Option<std::string::String>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) network_interfaces:
            std::option::Option<std::vec::Vec<crate::model::NetworkInterface>>,
    }
    impl Builder {
        /// <p>The connection endpoint ID for connecting to Amazon Redshift Serverless.</p>
        pub fn vpc_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_endpoint_id = Some(input.into());
            self
        }
        /// <p>The connection endpoint ID for connecting to Amazon Redshift Serverless.</p>
        pub fn set_vpc_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpc_endpoint_id = input;
            self
        }
        /// <p>The VPC identifier that the endpoint is associated with.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        /// <p>The VPC identifier that the endpoint is associated with.</p>
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// Appends an item to `network_interfaces`.
        ///
        /// To override the contents of this collection use [`set_network_interfaces`](Self::set_network_interfaces).
        ///
        /// <p>One or more network interfaces of the endpoint. Also known as an interface endpoint.</p>
        pub fn network_interfaces(mut self, input: crate::model::NetworkInterface) -> Self {
            let mut v = self.network_interfaces.unwrap_or_default();
            v.push(input);
            self.network_interfaces = Some(v);
            self
        }
        /// <p>One or more network interfaces of the endpoint. Also known as an interface endpoint.</p>
        pub fn set_network_interfaces(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NetworkInterface>>,
        ) -> Self {
            self.network_interfaces = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcEndpoint`](crate::model::VpcEndpoint).
        pub fn build(self) -> crate::model::VpcEndpoint {
            crate::model::VpcEndpoint {
                vpc_endpoint_id: self.vpc_endpoint_id,
                vpc_id: self.vpc_id,
                network_interfaces: self.network_interfaces,
            }
        }
    }
}
impl VpcEndpoint {
    /// Creates a new builder-style object to manufacture [`VpcEndpoint`](crate::model::VpcEndpoint).
    pub fn builder() -> crate::model::vpc_endpoint::Builder {
        crate::model::vpc_endpoint::Builder::default()
    }
}

/// <p>Contains information about a network interface in an Amazon Redshift Serverless managed VPC endpoint. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NetworkInterface {
    /// <p>The unique identifier of the network interface.</p>
    #[doc(hidden)]
    pub network_interface_id: std::option::Option<std::string::String>,
    /// <p>The unique identifier of the subnet.</p>
    #[doc(hidden)]
    pub subnet_id: std::option::Option<std::string::String>,
    /// <p>The IPv4 address of the network interface within the subnet.</p>
    #[doc(hidden)]
    pub private_ip_address: std::option::Option<std::string::String>,
    /// <p>The availability Zone.</p>
    #[doc(hidden)]
    pub availability_zone: std::option::Option<std::string::String>,
}
impl NetworkInterface {
    /// <p>The unique identifier of the network interface.</p>
    pub fn network_interface_id(&self) -> std::option::Option<&str> {
        self.network_interface_id.as_deref()
    }
    /// <p>The unique identifier of the subnet.</p>
    pub fn subnet_id(&self) -> std::option::Option<&str> {
        self.subnet_id.as_deref()
    }
    /// <p>The IPv4 address of the network interface within the subnet.</p>
    pub fn private_ip_address(&self) -> std::option::Option<&str> {
        self.private_ip_address.as_deref()
    }
    /// <p>The availability Zone.</p>
    pub fn availability_zone(&self) -> std::option::Option<&str> {
        self.availability_zone.as_deref()
    }
}
/// See [`NetworkInterface`](crate::model::NetworkInterface).
pub mod network_interface {

    /// A builder for [`NetworkInterface`](crate::model::NetworkInterface).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) network_interface_id: std::option::Option<std::string::String>,
        pub(crate) subnet_id: std::option::Option<std::string::String>,
        pub(crate) private_ip_address: std::option::Option<std::string::String>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the network interface.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_interface_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the network interface.</p>
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_interface_id = input;
            self
        }
        /// <p>The unique identifier of the subnet.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the subnet.</p>
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_id = input;
            self
        }
        /// <p>The IPv4 address of the network interface within the subnet.</p>
        pub fn private_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_ip_address = Some(input.into());
            self
        }
        /// <p>The IPv4 address of the network interface within the subnet.</p>
        pub fn set_private_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_ip_address = input;
            self
        }
        /// <p>The availability Zone.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        /// <p>The availability Zone.</p>
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkInterface`](crate::model::NetworkInterface).
        pub fn build(self) -> crate::model::NetworkInterface {
            crate::model::NetworkInterface {
                network_interface_id: self.network_interface_id,
                subnet_id: self.subnet_id,
                private_ip_address: self.private_ip_address,
                availability_zone: self.availability_zone,
            }
        }
    }
}
impl NetworkInterface {
    /// Creates a new builder-style object to manufacture [`NetworkInterface`](crate::model::NetworkInterface).
    pub fn builder() -> crate::model::network_interface::Builder {
        crate::model::network_interface::Builder::default()
    }
}

/// When writing a match expression against `WorkgroupStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let workgroupstatus = unimplemented!();
/// match workgroupstatus {
///     WorkgroupStatus::Available => { /* ... */ },
///     WorkgroupStatus::Creating => { /* ... */ },
///     WorkgroupStatus::Deleting => { /* ... */ },
///     WorkgroupStatus::Modifying => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `workgroupstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `WorkgroupStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `WorkgroupStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `WorkgroupStatus::NewFeature` is defined.
/// Specifically, when `workgroupstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `WorkgroupStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WorkgroupStatus {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Modifying,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for WorkgroupStatus {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => WorkgroupStatus::Available,
            "CREATING" => WorkgroupStatus::Creating,
            "DELETING" => WorkgroupStatus::Deleting,
            "MODIFYING" => WorkgroupStatus::Modifying,
            other => WorkgroupStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for WorkgroupStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WorkgroupStatus::from(s))
    }
}
impl WorkgroupStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WorkgroupStatus::Available => "AVAILABLE",
            WorkgroupStatus::Creating => "CREATING",
            WorkgroupStatus::Deleting => "DELETING",
            WorkgroupStatus::Modifying => "MODIFYING",
            WorkgroupStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AVAILABLE", "CREATING", "DELETING", "MODIFYING"]
    }
}
impl AsRef<str> for WorkgroupStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An array of key-value pairs to set for advanced control over Amazon Redshift Serverless.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfigParameter {
    /// <p>The key of the parameter. The options are <code>datestyle</code>, <code>enable_user_activity_logging</code>, <code>query_group</code>, <code>search_path</code>, and <code>max_query_execution_time</code>.</p>
    #[doc(hidden)]
    pub parameter_key: std::option::Option<std::string::String>,
    /// <p>The value of the parameter to set.</p>
    #[doc(hidden)]
    pub parameter_value: std::option::Option<std::string::String>,
}
impl ConfigParameter {
    /// <p>The key of the parameter. The options are <code>datestyle</code>, <code>enable_user_activity_logging</code>, <code>query_group</code>, <code>search_path</code>, and <code>max_query_execution_time</code>.</p>
    pub fn parameter_key(&self) -> std::option::Option<&str> {
        self.parameter_key.as_deref()
    }
    /// <p>The value of the parameter to set.</p>
    pub fn parameter_value(&self) -> std::option::Option<&str> {
        self.parameter_value.as_deref()
    }
}
/// See [`ConfigParameter`](crate::model::ConfigParameter).
pub mod config_parameter {

    /// A builder for [`ConfigParameter`](crate::model::ConfigParameter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) parameter_key: std::option::Option<std::string::String>,
        pub(crate) parameter_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The key of the parameter. The options are <code>datestyle</code>, <code>enable_user_activity_logging</code>, <code>query_group</code>, <code>search_path</code>, and <code>max_query_execution_time</code>.</p>
        pub fn parameter_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter_key = Some(input.into());
            self
        }
        /// <p>The key of the parameter. The options are <code>datestyle</code>, <code>enable_user_activity_logging</code>, <code>query_group</code>, <code>search_path</code>, and <code>max_query_execution_time</code>.</p>
        pub fn set_parameter_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_key = input;
            self
        }
        /// <p>The value of the parameter to set.</p>
        pub fn parameter_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter_value = Some(input.into());
            self
        }
        /// <p>The value of the parameter to set.</p>
        pub fn set_parameter_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_value = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfigParameter`](crate::model::ConfigParameter).
        pub fn build(self) -> crate::model::ConfigParameter {
            crate::model::ConfigParameter {
                parameter_key: self.parameter_key,
                parameter_value: self.parameter_value,
            }
        }
    }
}
impl ConfigParameter {
    /// Creates a new builder-style object to manufacture [`ConfigParameter`](crate::model::ConfigParameter).
    pub fn builder() -> crate::model::config_parameter::Builder {
        crate::model::config_parameter::Builder::default()
    }
}

/// <p>A map of key-value pairs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Tag {
    /// <p>The key to use in the tag.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The value of the tag.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl Tag {
    /// <p>The key to use in the tag.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The value of the tag.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`Tag`](crate::model::Tag).
pub mod tag {

    /// A builder for [`Tag`](crate::model::Tag).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The key to use in the tag.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The key to use in the tag.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The value of the tag.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the tag.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag).
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag).
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// <p>The usage limit object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UsageLimit {
    /// <p>The identifier of the usage limit.</p>
    #[doc(hidden)]
    pub usage_limit_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the resource associated with the usage limit.</p>
    #[doc(hidden)]
    pub usage_limit_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) that identifies the Amazon Redshift Serverless resource.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Redshift Serverless feature to limit.</p>
    #[doc(hidden)]
    pub usage_type: std::option::Option<crate::model::UsageLimitUsageType>,
    /// <p>The limit amount. If time-based, this amount is in RPUs consumed per hour. If data-based, this amount is in terabytes (TB). The value must be a positive number.</p>
    #[doc(hidden)]
    pub amount: std::option::Option<i64>,
    /// <p>The time period that the amount applies to. A weekly period begins on Sunday. The default is monthly.</p>
    #[doc(hidden)]
    pub period: std::option::Option<crate::model::UsageLimitPeriod>,
    /// <p>The action that Amazon Redshift Serverless takes when the limit is reached.</p>
    #[doc(hidden)]
    pub breach_action: std::option::Option<crate::model::UsageLimitBreachAction>,
}
impl UsageLimit {
    /// <p>The identifier of the usage limit.</p>
    pub fn usage_limit_id(&self) -> std::option::Option<&str> {
        self.usage_limit_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the resource associated with the usage limit.</p>
    pub fn usage_limit_arn(&self) -> std::option::Option<&str> {
        self.usage_limit_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) that identifies the Amazon Redshift Serverless resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The Amazon Redshift Serverless feature to limit.</p>
    pub fn usage_type(&self) -> std::option::Option<&crate::model::UsageLimitUsageType> {
        self.usage_type.as_ref()
    }
    /// <p>The limit amount. If time-based, this amount is in RPUs consumed per hour. If data-based, this amount is in terabytes (TB). The value must be a positive number.</p>
    pub fn amount(&self) -> std::option::Option<i64> {
        self.amount
    }
    /// <p>The time period that the amount applies to. A weekly period begins on Sunday. The default is monthly.</p>
    pub fn period(&self) -> std::option::Option<&crate::model::UsageLimitPeriod> {
        self.period.as_ref()
    }
    /// <p>The action that Amazon Redshift Serverless takes when the limit is reached.</p>
    pub fn breach_action(&self) -> std::option::Option<&crate::model::UsageLimitBreachAction> {
        self.breach_action.as_ref()
    }
}
/// See [`UsageLimit`](crate::model::UsageLimit).
pub mod usage_limit {

    /// A builder for [`UsageLimit`](crate::model::UsageLimit).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) usage_limit_id: std::option::Option<std::string::String>,
        pub(crate) usage_limit_arn: std::option::Option<std::string::String>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) usage_type: std::option::Option<crate::model::UsageLimitUsageType>,
        pub(crate) amount: std::option::Option<i64>,
        pub(crate) period: std::option::Option<crate::model::UsageLimitPeriod>,
        pub(crate) breach_action: std::option::Option<crate::model::UsageLimitBreachAction>,
    }
    impl Builder {
        /// <p>The identifier of the usage limit.</p>
        pub fn usage_limit_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.usage_limit_id = Some(input.into());
            self
        }
        /// <p>The identifier of the usage limit.</p>
        pub fn set_usage_limit_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.usage_limit_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource associated with the usage limit.</p>
        pub fn usage_limit_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.usage_limit_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource associated with the usage limit.</p>
        pub fn set_usage_limit_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.usage_limit_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) that identifies the Amazon Redshift Serverless resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) that identifies the Amazon Redshift Serverless resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// <p>The Amazon Redshift Serverless feature to limit.</p>
        pub fn usage_type(mut self, input: crate::model::UsageLimitUsageType) -> Self {
            self.usage_type = Some(input);
            self
        }
        /// <p>The Amazon Redshift Serverless feature to limit.</p>
        pub fn set_usage_type(
            mut self,
            input: std::option::Option<crate::model::UsageLimitUsageType>,
        ) -> Self {
            self.usage_type = input;
            self
        }
        /// <p>The limit amount. If time-based, this amount is in RPUs consumed per hour. If data-based, this amount is in terabytes (TB). The value must be a positive number.</p>
        pub fn amount(mut self, input: i64) -> Self {
            self.amount = Some(input);
            self
        }
        /// <p>The limit amount. If time-based, this amount is in RPUs consumed per hour. If data-based, this amount is in terabytes (TB). The value must be a positive number.</p>
        pub fn set_amount(mut self, input: std::option::Option<i64>) -> Self {
            self.amount = input;
            self
        }
        /// <p>The time period that the amount applies to. A weekly period begins on Sunday. The default is monthly.</p>
        pub fn period(mut self, input: crate::model::UsageLimitPeriod) -> Self {
            self.period = Some(input);
            self
        }
        /// <p>The time period that the amount applies to. A weekly period begins on Sunday. The default is monthly.</p>
        pub fn set_period(
            mut self,
            input: std::option::Option<crate::model::UsageLimitPeriod>,
        ) -> Self {
            self.period = input;
            self
        }
        /// <p>The action that Amazon Redshift Serverless takes when the limit is reached.</p>
        pub fn breach_action(mut self, input: crate::model::UsageLimitBreachAction) -> Self {
            self.breach_action = Some(input);
            self
        }
        /// <p>The action that Amazon Redshift Serverless takes when the limit is reached.</p>
        pub fn set_breach_action(
            mut self,
            input: std::option::Option<crate::model::UsageLimitBreachAction>,
        ) -> Self {
            self.breach_action = input;
            self
        }
        /// Consumes the builder and constructs a [`UsageLimit`](crate::model::UsageLimit).
        pub fn build(self) -> crate::model::UsageLimit {
            crate::model::UsageLimit {
                usage_limit_id: self.usage_limit_id,
                usage_limit_arn: self.usage_limit_arn,
                resource_arn: self.resource_arn,
                usage_type: self.usage_type,
                amount: self.amount,
                period: self.period,
                breach_action: self.breach_action,
            }
        }
    }
}
impl UsageLimit {
    /// Creates a new builder-style object to manufacture [`UsageLimit`](crate::model::UsageLimit).
    pub fn builder() -> crate::model::usage_limit::Builder {
        crate::model::usage_limit::Builder::default()
    }
}

/// When writing a match expression against `UsageLimitBreachAction`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let usagelimitbreachaction = unimplemented!();
/// match usagelimitbreachaction {
///     UsageLimitBreachAction::Deactivate => { /* ... */ },
///     UsageLimitBreachAction::EmitMetric => { /* ... */ },
///     UsageLimitBreachAction::Log => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `usagelimitbreachaction` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `UsageLimitBreachAction::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `UsageLimitBreachAction::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `UsageLimitBreachAction::NewFeature` is defined.
/// Specifically, when `usagelimitbreachaction` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `UsageLimitBreachAction::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UsageLimitBreachAction {
    #[allow(missing_docs)] // documentation missing in model
    Deactivate,
    #[allow(missing_docs)] // documentation missing in model
    EmitMetric,
    #[allow(missing_docs)] // documentation missing in model
    Log,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for UsageLimitBreachAction {
    fn from(s: &str) -> Self {
        match s {
            "deactivate" => UsageLimitBreachAction::Deactivate,
            "emit-metric" => UsageLimitBreachAction::EmitMetric,
            "log" => UsageLimitBreachAction::Log,
            other => {
                UsageLimitBreachAction::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for UsageLimitBreachAction {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UsageLimitBreachAction::from(s))
    }
}
impl UsageLimitBreachAction {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UsageLimitBreachAction::Deactivate => "deactivate",
            UsageLimitBreachAction::EmitMetric => "emit-metric",
            UsageLimitBreachAction::Log => "log",
            UsageLimitBreachAction::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["deactivate", "emit-metric", "log"]
    }
}
impl AsRef<str> for UsageLimitBreachAction {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `UsageLimitPeriod`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let usagelimitperiod = unimplemented!();
/// match usagelimitperiod {
///     UsageLimitPeriod::Daily => { /* ... */ },
///     UsageLimitPeriod::Monthly => { /* ... */ },
///     UsageLimitPeriod::Weekly => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `usagelimitperiod` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `UsageLimitPeriod::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `UsageLimitPeriod::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `UsageLimitPeriod::NewFeature` is defined.
/// Specifically, when `usagelimitperiod` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `UsageLimitPeriod::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UsageLimitPeriod {
    #[allow(missing_docs)] // documentation missing in model
    Daily,
    #[allow(missing_docs)] // documentation missing in model
    Monthly,
    #[allow(missing_docs)] // documentation missing in model
    Weekly,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for UsageLimitPeriod {
    fn from(s: &str) -> Self {
        match s {
            "daily" => UsageLimitPeriod::Daily,
            "monthly" => UsageLimitPeriod::Monthly,
            "weekly" => UsageLimitPeriod::Weekly,
            other => UsageLimitPeriod::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for UsageLimitPeriod {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UsageLimitPeriod::from(s))
    }
}
impl UsageLimitPeriod {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UsageLimitPeriod::Daily => "daily",
            UsageLimitPeriod::Monthly => "monthly",
            UsageLimitPeriod::Weekly => "weekly",
            UsageLimitPeriod::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["daily", "monthly", "weekly"]
    }
}
impl AsRef<str> for UsageLimitPeriod {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `UsageLimitUsageType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let usagelimitusagetype = unimplemented!();
/// match usagelimitusagetype {
///     UsageLimitUsageType::CrossRegionDatasharing => { /* ... */ },
///     UsageLimitUsageType::ServerlessCompute => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `usagelimitusagetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `UsageLimitUsageType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `UsageLimitUsageType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `UsageLimitUsageType::NewFeature` is defined.
/// Specifically, when `usagelimitusagetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `UsageLimitUsageType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UsageLimitUsageType {
    #[allow(missing_docs)] // documentation missing in model
    CrossRegionDatasharing,
    #[allow(missing_docs)] // documentation missing in model
    ServerlessCompute,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for UsageLimitUsageType {
    fn from(s: &str) -> Self {
        match s {
            "cross-region-datasharing" => UsageLimitUsageType::CrossRegionDatasharing,
            "serverless-compute" => UsageLimitUsageType::ServerlessCompute,
            other => {
                UsageLimitUsageType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for UsageLimitUsageType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UsageLimitUsageType::from(s))
    }
}
impl UsageLimitUsageType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UsageLimitUsageType::CrossRegionDatasharing => "cross-region-datasharing",
            UsageLimitUsageType::ServerlessCompute => "serverless-compute",
            UsageLimitUsageType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["cross-region-datasharing", "serverless-compute"]
    }
}
impl AsRef<str> for UsageLimitUsageType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A snapshot object that contains databases.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Snapshot {
    /// <p>The name of the namepsace.</p>
    #[doc(hidden)]
    pub namespace_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the namespace the snapshot was created from.</p>
    #[doc(hidden)]
    pub namespace_arn: std::option::Option<std::string::String>,
    /// <p>The name of the snapshot.</p>
    #[doc(hidden)]
    pub snapshot_name: std::option::Option<std::string::String>,
    /// <p>The timestamp of when the snapshot was created.</p>
    #[doc(hidden)]
    pub snapshot_create_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The username of the database within a snapshot.</p>
    #[doc(hidden)]
    pub admin_username: std::option::Option<std::string::String>,
    /// <p>The status of the snapshot.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::SnapshotStatus>,
    /// <p>The unique identifier of the KMS key used to encrypt the snapshot.</p>
    #[doc(hidden)]
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>The owner Amazon Web Services; account of the snapshot.</p>
    #[doc(hidden)]
    pub owner_account: std::option::Option<std::string::String>,
    /// <p>The total size, in megabytes, of how big the snapshot is.</p>
    #[doc(hidden)]
    pub total_backup_size_in_mega_bytes: std::option::Option<f64>,
    /// <p>The size of the incremental backup in megabytes.</p>
    #[doc(hidden)]
    pub actual_incremental_backup_size_in_mega_bytes: std::option::Option<f64>,
    /// <p>The size in megabytes of the data that has been backed up to a snapshot.</p>
    #[doc(hidden)]
    pub backup_progress_in_mega_bytes: std::option::Option<f64>,
    /// <p>The rate at which data is backed up into a snapshot in megabytes per second.</p>
    #[doc(hidden)]
    pub current_backup_rate_in_mega_bytes_per_second: std::option::Option<f64>,
    /// <p>The estimated amount of seconds until the snapshot completes backup.</p>
    #[doc(hidden)]
    pub estimated_seconds_to_completion: std::option::Option<i64>,
    /// <p>The amount of time it took to back up data into a snapshot.</p>
    #[doc(hidden)]
    pub elapsed_time_in_seconds: std::option::Option<i64>,
    /// <p>The period of time, in days, of how long the snapshot is retained.</p>
    #[doc(hidden)]
    pub snapshot_retention_period: std::option::Option<i32>,
    /// <p>The amount of days until the snapshot is deleted.</p>
    #[doc(hidden)]
    pub snapshot_remaining_days: std::option::Option<i32>,
    /// <p>The timestamp of when data within the snapshot started getting retained.</p>
    #[doc(hidden)]
    pub snapshot_retention_start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The Amazon Resource Name (ARN) of the snapshot.</p>
    #[doc(hidden)]
    pub snapshot_arn: std::option::Option<std::string::String>,
    /// <p>All of the Amazon Web Services accounts that have access to restore a snapshot to a namespace.</p>
    #[doc(hidden)]
    pub accounts_with_restore_access: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>All of the Amazon Web Services accounts that have access to restore a snapshot to a provisioned cluster.</p>
    #[doc(hidden)]
    pub accounts_with_provisioned_restore_access:
        std::option::Option<std::vec::Vec<std::string::String>>,
}
impl Snapshot {
    /// <p>The name of the namepsace.</p>
    pub fn namespace_name(&self) -> std::option::Option<&str> {
        self.namespace_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the namespace the snapshot was created from.</p>
    pub fn namespace_arn(&self) -> std::option::Option<&str> {
        self.namespace_arn.as_deref()
    }
    /// <p>The name of the snapshot.</p>
    pub fn snapshot_name(&self) -> std::option::Option<&str> {
        self.snapshot_name.as_deref()
    }
    /// <p>The timestamp of when the snapshot was created.</p>
    pub fn snapshot_create_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.snapshot_create_time.as_ref()
    }
    /// <p>The username of the database within a snapshot.</p>
    pub fn admin_username(&self) -> std::option::Option<&str> {
        self.admin_username.as_deref()
    }
    /// <p>The status of the snapshot.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::SnapshotStatus> {
        self.status.as_ref()
    }
    /// <p>The unique identifier of the KMS key used to encrypt the snapshot.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
    /// <p>The owner Amazon Web Services; account of the snapshot.</p>
    pub fn owner_account(&self) -> std::option::Option<&str> {
        self.owner_account.as_deref()
    }
    /// <p>The total size, in megabytes, of how big the snapshot is.</p>
    pub fn total_backup_size_in_mega_bytes(&self) -> std::option::Option<f64> {
        self.total_backup_size_in_mega_bytes
    }
    /// <p>The size of the incremental backup in megabytes.</p>
    pub fn actual_incremental_backup_size_in_mega_bytes(&self) -> std::option::Option<f64> {
        self.actual_incremental_backup_size_in_mega_bytes
    }
    /// <p>The size in megabytes of the data that has been backed up to a snapshot.</p>
    pub fn backup_progress_in_mega_bytes(&self) -> std::option::Option<f64> {
        self.backup_progress_in_mega_bytes
    }
    /// <p>The rate at which data is backed up into a snapshot in megabytes per second.</p>
    pub fn current_backup_rate_in_mega_bytes_per_second(&self) -> std::option::Option<f64> {
        self.current_backup_rate_in_mega_bytes_per_second
    }
    /// <p>The estimated amount of seconds until the snapshot completes backup.</p>
    pub fn estimated_seconds_to_completion(&self) -> std::option::Option<i64> {
        self.estimated_seconds_to_completion
    }
    /// <p>The amount of time it took to back up data into a snapshot.</p>
    pub fn elapsed_time_in_seconds(&self) -> std::option::Option<i64> {
        self.elapsed_time_in_seconds
    }
    /// <p>The period of time, in days, of how long the snapshot is retained.</p>
    pub fn snapshot_retention_period(&self) -> std::option::Option<i32> {
        self.snapshot_retention_period
    }
    /// <p>The amount of days until the snapshot is deleted.</p>
    pub fn snapshot_remaining_days(&self) -> std::option::Option<i32> {
        self.snapshot_remaining_days
    }
    /// <p>The timestamp of when data within the snapshot started getting retained.</p>
    pub fn snapshot_retention_start_time(
        &self,
    ) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.snapshot_retention_start_time.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the snapshot.</p>
    pub fn snapshot_arn(&self) -> std::option::Option<&str> {
        self.snapshot_arn.as_deref()
    }
    /// <p>All of the Amazon Web Services accounts that have access to restore a snapshot to a namespace.</p>
    pub fn accounts_with_restore_access(&self) -> std::option::Option<&[std::string::String]> {
        self.accounts_with_restore_access.as_deref()
    }
    /// <p>All of the Amazon Web Services accounts that have access to restore a snapshot to a provisioned cluster.</p>
    pub fn accounts_with_provisioned_restore_access(
        &self,
    ) -> std::option::Option<&[std::string::String]> {
        self.accounts_with_provisioned_restore_access.as_deref()
    }
}
/// See [`Snapshot`](crate::model::Snapshot).
pub mod snapshot {

    /// A builder for [`Snapshot`](crate::model::Snapshot).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) namespace_name: std::option::Option<std::string::String>,
        pub(crate) namespace_arn: std::option::Option<std::string::String>,
        pub(crate) snapshot_name: std::option::Option<std::string::String>,
        pub(crate) snapshot_create_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) admin_username: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::SnapshotStatus>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) owner_account: std::option::Option<std::string::String>,
        pub(crate) total_backup_size_in_mega_bytes: std::option::Option<f64>,
        pub(crate) actual_incremental_backup_size_in_mega_bytes: std::option::Option<f64>,
        pub(crate) backup_progress_in_mega_bytes: std::option::Option<f64>,
        pub(crate) current_backup_rate_in_mega_bytes_per_second: std::option::Option<f64>,
        pub(crate) estimated_seconds_to_completion: std::option::Option<i64>,
        pub(crate) elapsed_time_in_seconds: std::option::Option<i64>,
        pub(crate) snapshot_retention_period: std::option::Option<i32>,
        pub(crate) snapshot_remaining_days: std::option::Option<i32>,
        pub(crate) snapshot_retention_start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) snapshot_arn: std::option::Option<std::string::String>,
        pub(crate) accounts_with_restore_access:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) accounts_with_provisioned_restore_access:
            std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the namepsace.</p>
        pub fn namespace_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace_name = Some(input.into());
            self
        }
        /// <p>The name of the namepsace.</p>
        pub fn set_namespace_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.namespace_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the namespace the snapshot was created from.</p>
        pub fn namespace_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the namespace the snapshot was created from.</p>
        pub fn set_namespace_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.namespace_arn = input;
            self
        }
        /// <p>The name of the snapshot.</p>
        pub fn snapshot_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_name = Some(input.into());
            self
        }
        /// <p>The name of the snapshot.</p>
        pub fn set_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.snapshot_name = input;
            self
        }
        /// <p>The timestamp of when the snapshot was created.</p>
        pub fn snapshot_create_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.snapshot_create_time = Some(input);
            self
        }
        /// <p>The timestamp of when the snapshot was created.</p>
        pub fn set_snapshot_create_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.snapshot_create_time = input;
            self
        }
        /// <p>The username of the database within a snapshot.</p>
        pub fn admin_username(mut self, input: impl Into<std::string::String>) -> Self {
            self.admin_username = Some(input.into());
            self
        }
        /// <p>The username of the database within a snapshot.</p>
        pub fn set_admin_username(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.admin_username = input;
            self
        }
        /// <p>The status of the snapshot.</p>
        pub fn status(mut self, input: crate::model::SnapshotStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the snapshot.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::SnapshotStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The unique identifier of the KMS key used to encrypt the snapshot.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the KMS key used to encrypt the snapshot.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>The owner Amazon Web Services; account of the snapshot.</p>
        pub fn owner_account(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_account = Some(input.into());
            self
        }
        /// <p>The owner Amazon Web Services; account of the snapshot.</p>
        pub fn set_owner_account(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.owner_account = input;
            self
        }
        /// <p>The total size, in megabytes, of how big the snapshot is.</p>
        pub fn total_backup_size_in_mega_bytes(mut self, input: f64) -> Self {
            self.total_backup_size_in_mega_bytes = Some(input);
            self
        }
        /// <p>The total size, in megabytes, of how big the snapshot is.</p>
        pub fn set_total_backup_size_in_mega_bytes(
            mut self,
            input: std::option::Option<f64>,
        ) -> Self {
            self.total_backup_size_in_mega_bytes = input;
            self
        }
        /// <p>The size of the incremental backup in megabytes.</p>
        pub fn actual_incremental_backup_size_in_mega_bytes(mut self, input: f64) -> Self {
            self.actual_incremental_backup_size_in_mega_bytes = Some(input);
            self
        }
        /// <p>The size of the incremental backup in megabytes.</p>
        pub fn set_actual_incremental_backup_size_in_mega_bytes(
            mut self,
            input: std::option::Option<f64>,
        ) -> Self {
            self.actual_incremental_backup_size_in_mega_bytes = input;
            self
        }
        /// <p>The size in megabytes of the data that has been backed up to a snapshot.</p>
        pub fn backup_progress_in_mega_bytes(mut self, input: f64) -> Self {
            self.backup_progress_in_mega_bytes = Some(input);
            self
        }
        /// <p>The size in megabytes of the data that has been backed up to a snapshot.</p>
        pub fn set_backup_progress_in_mega_bytes(
            mut self,
            input: std::option::Option<f64>,
        ) -> Self {
            self.backup_progress_in_mega_bytes = input;
            self
        }
        /// <p>The rate at which data is backed up into a snapshot in megabytes per second.</p>
        pub fn current_backup_rate_in_mega_bytes_per_second(mut self, input: f64) -> Self {
            self.current_backup_rate_in_mega_bytes_per_second = Some(input);
            self
        }
        /// <p>The rate at which data is backed up into a snapshot in megabytes per second.</p>
        pub fn set_current_backup_rate_in_mega_bytes_per_second(
            mut self,
            input: std::option::Option<f64>,
        ) -> Self {
            self.current_backup_rate_in_mega_bytes_per_second = input;
            self
        }
        /// <p>The estimated amount of seconds until the snapshot completes backup.</p>
        pub fn estimated_seconds_to_completion(mut self, input: i64) -> Self {
            self.estimated_seconds_to_completion = Some(input);
            self
        }
        /// <p>The estimated amount of seconds until the snapshot completes backup.</p>
        pub fn set_estimated_seconds_to_completion(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.estimated_seconds_to_completion = input;
            self
        }
        /// <p>The amount of time it took to back up data into a snapshot.</p>
        pub fn elapsed_time_in_seconds(mut self, input: i64) -> Self {
            self.elapsed_time_in_seconds = Some(input);
            self
        }
        /// <p>The amount of time it took to back up data into a snapshot.</p>
        pub fn set_elapsed_time_in_seconds(mut self, input: std::option::Option<i64>) -> Self {
            self.elapsed_time_in_seconds = input;
            self
        }
        /// <p>The period of time, in days, of how long the snapshot is retained.</p>
        pub fn snapshot_retention_period(mut self, input: i32) -> Self {
            self.snapshot_retention_period = Some(input);
            self
        }
        /// <p>The period of time, in days, of how long the snapshot is retained.</p>
        pub fn set_snapshot_retention_period(mut self, input: std::option::Option<i32>) -> Self {
            self.snapshot_retention_period = input;
            self
        }
        /// <p>The amount of days until the snapshot is deleted.</p>
        pub fn snapshot_remaining_days(mut self, input: i32) -> Self {
            self.snapshot_remaining_days = Some(input);
            self
        }
        /// <p>The amount of days until the snapshot is deleted.</p>
        pub fn set_snapshot_remaining_days(mut self, input: std::option::Option<i32>) -> Self {
            self.snapshot_remaining_days = input;
            self
        }
        /// <p>The timestamp of when data within the snapshot started getting retained.</p>
        pub fn snapshot_retention_start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.snapshot_retention_start_time = Some(input);
            self
        }
        /// <p>The timestamp of when data within the snapshot started getting retained.</p>
        pub fn set_snapshot_retention_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.snapshot_retention_start_time = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the snapshot.</p>
        pub fn snapshot_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the snapshot.</p>
        pub fn set_snapshot_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.snapshot_arn = input;
            self
        }
        /// Appends an item to `accounts_with_restore_access`.
        ///
        /// To override the contents of this collection use [`set_accounts_with_restore_access`](Self::set_accounts_with_restore_access).
        ///
        /// <p>All of the Amazon Web Services accounts that have access to restore a snapshot to a namespace.</p>
        pub fn accounts_with_restore_access(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.accounts_with_restore_access.unwrap_or_default();
            v.push(input.into());
            self.accounts_with_restore_access = Some(v);
            self
        }
        /// <p>All of the Amazon Web Services accounts that have access to restore a snapshot to a namespace.</p>
        pub fn set_accounts_with_restore_access(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.accounts_with_restore_access = input;
            self
        }
        /// Appends an item to `accounts_with_provisioned_restore_access`.
        ///
        /// To override the contents of this collection use [`set_accounts_with_provisioned_restore_access`](Self::set_accounts_with_provisioned_restore_access).
        ///
        /// <p>All of the Amazon Web Services accounts that have access to restore a snapshot to a provisioned cluster.</p>
        pub fn accounts_with_provisioned_restore_access(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self
                .accounts_with_provisioned_restore_access
                .unwrap_or_default();
            v.push(input.into());
            self.accounts_with_provisioned_restore_access = Some(v);
            self
        }
        /// <p>All of the Amazon Web Services accounts that have access to restore a snapshot to a provisioned cluster.</p>
        pub fn set_accounts_with_provisioned_restore_access(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.accounts_with_provisioned_restore_access = input;
            self
        }
        /// Consumes the builder and constructs a [`Snapshot`](crate::model::Snapshot).
        pub fn build(self) -> crate::model::Snapshot {
            crate::model::Snapshot {
                namespace_name: self.namespace_name,
                namespace_arn: self.namespace_arn,
                snapshot_name: self.snapshot_name,
                snapshot_create_time: self.snapshot_create_time,
                admin_username: self.admin_username,
                status: self.status,
                kms_key_id: self.kms_key_id,
                owner_account: self.owner_account,
                total_backup_size_in_mega_bytes: self.total_backup_size_in_mega_bytes,
                actual_incremental_backup_size_in_mega_bytes: self
                    .actual_incremental_backup_size_in_mega_bytes,
                backup_progress_in_mega_bytes: self.backup_progress_in_mega_bytes,
                current_backup_rate_in_mega_bytes_per_second: self
                    .current_backup_rate_in_mega_bytes_per_second,
                estimated_seconds_to_completion: self.estimated_seconds_to_completion,
                elapsed_time_in_seconds: self.elapsed_time_in_seconds,
                snapshot_retention_period: self.snapshot_retention_period,
                snapshot_remaining_days: self.snapshot_remaining_days,
                snapshot_retention_start_time: self.snapshot_retention_start_time,
                snapshot_arn: self.snapshot_arn,
                accounts_with_restore_access: self.accounts_with_restore_access,
                accounts_with_provisioned_restore_access: self
                    .accounts_with_provisioned_restore_access,
            }
        }
    }
}
impl Snapshot {
    /// Creates a new builder-style object to manufacture [`Snapshot`](crate::model::Snapshot).
    pub fn builder() -> crate::model::snapshot::Builder {
        crate::model::snapshot::Builder::default()
    }
}

/// When writing a match expression against `SnapshotStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let snapshotstatus = unimplemented!();
/// match snapshotstatus {
///     SnapshotStatus::Available => { /* ... */ },
///     SnapshotStatus::Cancelled => { /* ... */ },
///     SnapshotStatus::Copying => { /* ... */ },
///     SnapshotStatus::Creating => { /* ... */ },
///     SnapshotStatus::Deleted => { /* ... */ },
///     SnapshotStatus::Failed => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `snapshotstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SnapshotStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SnapshotStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SnapshotStatus::NewFeature` is defined.
/// Specifically, when `snapshotstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SnapshotStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SnapshotStatus {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Cancelled,
    #[allow(missing_docs)] // documentation missing in model
    Copying,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SnapshotStatus {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => SnapshotStatus::Available,
            "CANCELLED" => SnapshotStatus::Cancelled,
            "COPYING" => SnapshotStatus::Copying,
            "CREATING" => SnapshotStatus::Creating,
            "DELETED" => SnapshotStatus::Deleted,
            "FAILED" => SnapshotStatus::Failed,
            other => SnapshotStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SnapshotStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SnapshotStatus::from(s))
    }
}
impl SnapshotStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SnapshotStatus::Available => "AVAILABLE",
            SnapshotStatus::Cancelled => "CANCELLED",
            SnapshotStatus::Copying => "COPYING",
            SnapshotStatus::Creating => "CREATING",
            SnapshotStatus::Deleted => "DELETED",
            SnapshotStatus::Failed => "FAILED",
            SnapshotStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AVAILABLE",
            "CANCELLED",
            "COPYING",
            "CREATING",
            "DELETED",
            "FAILED",
        ]
    }
}
impl AsRef<str> for SnapshotStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about a table restore request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableRestoreStatus {
    /// <p>The ID of the RestoreTableFromSnapshot request.</p>
    #[doc(hidden)]
    pub table_restore_request_id: std::option::Option<std::string::String>,
    /// <p>A value that describes the current state of the table restore request. Possible values include <code>SUCCEEDED</code>, <code>FAILED</code>, <code>CANCELED</code>, <code>PENDING</code>, <code>IN_PROGRESS</code>.</p>
    #[doc(hidden)]
    pub status: std::option::Option<std::string::String>,
    /// <p>A description of the status of the table restore request. Status values include <code>SUCCEEDED</code>, <code>FAILED</code>, <code>CANCELED</code>, <code>PENDING</code>, <code>IN_PROGRESS</code>.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The time that the table restore request was made, in Universal Coordinated Time (UTC).</p>
    #[doc(hidden)]
    pub request_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The namespace of the table being restored from.</p>
    #[doc(hidden)]
    pub namespace_name: std::option::Option<std::string::String>,
    /// <p>The name of the workgroup being restored from.</p>
    #[doc(hidden)]
    pub workgroup_name: std::option::Option<std::string::String>,
    /// <p>The name of the snapshot being restored from.</p>
    #[doc(hidden)]
    pub snapshot_name: std::option::Option<std::string::String>,
    /// <p>The amount of data restored to the new table so far, in megabytes (MB).</p>
    #[doc(hidden)]
    pub progress_in_mega_bytes: std::option::Option<i64>,
    /// <p>The total amount of data to restore to the new table, in megabytes (MB).</p>
    #[doc(hidden)]
    pub total_data_in_mega_bytes: std::option::Option<i64>,
    /// <p>The name of the source database being restored from.</p>
    #[doc(hidden)]
    pub source_database_name: std::option::Option<std::string::String>,
    /// <p>The name of the source schema being restored from.</p>
    #[doc(hidden)]
    pub source_schema_name: std::option::Option<std::string::String>,
    /// <p>The name of the source table being restored from.</p>
    #[doc(hidden)]
    pub source_table_name: std::option::Option<std::string::String>,
    /// <p>The name of the database to restore to.</p>
    #[doc(hidden)]
    pub target_database_name: std::option::Option<std::string::String>,
    /// <p>The name of the schema to restore to.</p>
    #[doc(hidden)]
    pub target_schema_name: std::option::Option<std::string::String>,
    /// <p>The name of the table to create from the restore operation.</p>
    #[doc(hidden)]
    pub new_table_name: std::option::Option<std::string::String>,
}
impl TableRestoreStatus {
    /// <p>The ID of the RestoreTableFromSnapshot request.</p>
    pub fn table_restore_request_id(&self) -> std::option::Option<&str> {
        self.table_restore_request_id.as_deref()
    }
    /// <p>A value that describes the current state of the table restore request. Possible values include <code>SUCCEEDED</code>, <code>FAILED</code>, <code>CANCELED</code>, <code>PENDING</code>, <code>IN_PROGRESS</code>.</p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>A description of the status of the table restore request. Status values include <code>SUCCEEDED</code>, <code>FAILED</code>, <code>CANCELED</code>, <code>PENDING</code>, <code>IN_PROGRESS</code>.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>The time that the table restore request was made, in Universal Coordinated Time (UTC).</p>
    pub fn request_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.request_time.as_ref()
    }
    /// <p>The namespace of the table being restored from.</p>
    pub fn namespace_name(&self) -> std::option::Option<&str> {
        self.namespace_name.as_deref()
    }
    /// <p>The name of the workgroup being restored from.</p>
    pub fn workgroup_name(&self) -> std::option::Option<&str> {
        self.workgroup_name.as_deref()
    }
    /// <p>The name of the snapshot being restored from.</p>
    pub fn snapshot_name(&self) -> std::option::Option<&str> {
        self.snapshot_name.as_deref()
    }
    /// <p>The amount of data restored to the new table so far, in megabytes (MB).</p>
    pub fn progress_in_mega_bytes(&self) -> std::option::Option<i64> {
        self.progress_in_mega_bytes
    }
    /// <p>The total amount of data to restore to the new table, in megabytes (MB).</p>
    pub fn total_data_in_mega_bytes(&self) -> std::option::Option<i64> {
        self.total_data_in_mega_bytes
    }
    /// <p>The name of the source database being restored from.</p>
    pub fn source_database_name(&self) -> std::option::Option<&str> {
        self.source_database_name.as_deref()
    }
    /// <p>The name of the source schema being restored from.</p>
    pub fn source_schema_name(&self) -> std::option::Option<&str> {
        self.source_schema_name.as_deref()
    }
    /// <p>The name of the source table being restored from.</p>
    pub fn source_table_name(&self) -> std::option::Option<&str> {
        self.source_table_name.as_deref()
    }
    /// <p>The name of the database to restore to.</p>
    pub fn target_database_name(&self) -> std::option::Option<&str> {
        self.target_database_name.as_deref()
    }
    /// <p>The name of the schema to restore to.</p>
    pub fn target_schema_name(&self) -> std::option::Option<&str> {
        self.target_schema_name.as_deref()
    }
    /// <p>The name of the table to create from the restore operation.</p>
    pub fn new_table_name(&self) -> std::option::Option<&str> {
        self.new_table_name.as_deref()
    }
}
/// See [`TableRestoreStatus`](crate::model::TableRestoreStatus).
pub mod table_restore_status {

    /// A builder for [`TableRestoreStatus`](crate::model::TableRestoreStatus).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) table_restore_request_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) namespace_name: std::option::Option<std::string::String>,
        pub(crate) workgroup_name: std::option::Option<std::string::String>,
        pub(crate) snapshot_name: std::option::Option<std::string::String>,
        pub(crate) progress_in_mega_bytes: std::option::Option<i64>,
        pub(crate) total_data_in_mega_bytes: std::option::Option<i64>,
        pub(crate) source_database_name: std::option::Option<std::string::String>,
        pub(crate) source_schema_name: std::option::Option<std::string::String>,
        pub(crate) source_table_name: std::option::Option<std::string::String>,
        pub(crate) target_database_name: std::option::Option<std::string::String>,
        pub(crate) target_schema_name: std::option::Option<std::string::String>,
        pub(crate) new_table_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the RestoreTableFromSnapshot request.</p>
        pub fn table_restore_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.table_restore_request_id = Some(input.into());
            self
        }
        /// <p>The ID of the RestoreTableFromSnapshot request.</p>
        pub fn set_table_restore_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.table_restore_request_id = input;
            self
        }
        /// <p>A value that describes the current state of the table restore request. Possible values include <code>SUCCEEDED</code>, <code>FAILED</code>, <code>CANCELED</code>, <code>PENDING</code>, <code>IN_PROGRESS</code>.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>A value that describes the current state of the table restore request. Possible values include <code>SUCCEEDED</code>, <code>FAILED</code>, <code>CANCELED</code>, <code>PENDING</code>, <code>IN_PROGRESS</code>.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>A description of the status of the table restore request. Status values include <code>SUCCEEDED</code>, <code>FAILED</code>, <code>CANCELED</code>, <code>PENDING</code>, <code>IN_PROGRESS</code>.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A description of the status of the table restore request. Status values include <code>SUCCEEDED</code>, <code>FAILED</code>, <code>CANCELED</code>, <code>PENDING</code>, <code>IN_PROGRESS</code>.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The time that the table restore request was made, in Universal Coordinated Time (UTC).</p>
        pub fn request_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.request_time = Some(input);
            self
        }
        /// <p>The time that the table restore request was made, in Universal Coordinated Time (UTC).</p>
        pub fn set_request_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.request_time = input;
            self
        }
        /// <p>The namespace of the table being restored from.</p>
        pub fn namespace_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace_name = Some(input.into());
            self
        }
        /// <p>The namespace of the table being restored from.</p>
        pub fn set_namespace_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.namespace_name = input;
            self
        }
        /// <p>The name of the workgroup being restored from.</p>
        pub fn workgroup_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.workgroup_name = Some(input.into());
            self
        }
        /// <p>The name of the workgroup being restored from.</p>
        pub fn set_workgroup_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.workgroup_name = input;
            self
        }
        /// <p>The name of the snapshot being restored from.</p>
        pub fn snapshot_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_name = Some(input.into());
            self
        }
        /// <p>The name of the snapshot being restored from.</p>
        pub fn set_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.snapshot_name = input;
            self
        }
        /// <p>The amount of data restored to the new table so far, in megabytes (MB).</p>
        pub fn progress_in_mega_bytes(mut self, input: i64) -> Self {
            self.progress_in_mega_bytes = Some(input);
            self
        }
        /// <p>The amount of data restored to the new table so far, in megabytes (MB).</p>
        pub fn set_progress_in_mega_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.progress_in_mega_bytes = input;
            self
        }
        /// <p>The total amount of data to restore to the new table, in megabytes (MB).</p>
        pub fn total_data_in_mega_bytes(mut self, input: i64) -> Self {
            self.total_data_in_mega_bytes = Some(input);
            self
        }
        /// <p>The total amount of data to restore to the new table, in megabytes (MB).</p>
        pub fn set_total_data_in_mega_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.total_data_in_mega_bytes = input;
            self
        }
        /// <p>The name of the source database being restored from.</p>
        pub fn source_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_database_name = Some(input.into());
            self
        }
        /// <p>The name of the source database being restored from.</p>
        pub fn set_source_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_database_name = input;
            self
        }
        /// <p>The name of the source schema being restored from.</p>
        pub fn source_schema_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_schema_name = Some(input.into());
            self
        }
        /// <p>The name of the source schema being restored from.</p>
        pub fn set_source_schema_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_schema_name = input;
            self
        }
        /// <p>The name of the source table being restored from.</p>
        pub fn source_table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_table_name = Some(input.into());
            self
        }
        /// <p>The name of the source table being restored from.</p>
        pub fn set_source_table_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_table_name = input;
            self
        }
        /// <p>The name of the database to restore to.</p>
        pub fn target_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_database_name = Some(input.into());
            self
        }
        /// <p>The name of the database to restore to.</p>
        pub fn set_target_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.target_database_name = input;
            self
        }
        /// <p>The name of the schema to restore to.</p>
        pub fn target_schema_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_schema_name = Some(input.into());
            self
        }
        /// <p>The name of the schema to restore to.</p>
        pub fn set_target_schema_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.target_schema_name = input;
            self
        }
        /// <p>The name of the table to create from the restore operation.</p>
        pub fn new_table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.new_table_name = Some(input.into());
            self
        }
        /// <p>The name of the table to create from the restore operation.</p>
        pub fn set_new_table_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.new_table_name = input;
            self
        }
        /// Consumes the builder and constructs a [`TableRestoreStatus`](crate::model::TableRestoreStatus).
        pub fn build(self) -> crate::model::TableRestoreStatus {
            crate::model::TableRestoreStatus {
                table_restore_request_id: self.table_restore_request_id,
                status: self.status,
                message: self.message,
                request_time: self.request_time,
                namespace_name: self.namespace_name,
                workgroup_name: self.workgroup_name,
                snapshot_name: self.snapshot_name,
                progress_in_mega_bytes: self.progress_in_mega_bytes,
                total_data_in_mega_bytes: self.total_data_in_mega_bytes,
                source_database_name: self.source_database_name,
                source_schema_name: self.source_schema_name,
                source_table_name: self.source_table_name,
                target_database_name: self.target_database_name,
                target_schema_name: self.target_schema_name,
                new_table_name: self.new_table_name,
            }
        }
    }
}
impl TableRestoreStatus {
    /// Creates a new builder-style object to manufacture [`TableRestoreStatus`](crate::model::TableRestoreStatus).
    pub fn builder() -> crate::model::table_restore_status::Builder {
        crate::model::table_restore_status::Builder::default()
    }
}

/// <p>A collection of database objects and users.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Namespace {
    /// <p>The Amazon Resource Name (ARN) associated with a namespace.</p>
    #[doc(hidden)]
    pub namespace_arn: std::option::Option<std::string::String>,
    /// <p>The unique identifier of a namespace.</p>
    #[doc(hidden)]
    pub namespace_id: std::option::Option<std::string::String>,
    /// <p>The name of the namespace. Must be between 3-64 alphanumeric characters in lowercase, and it cannot be a reserved word. A list of reserved words can be found in <a href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p>
    #[doc(hidden)]
    pub namespace_name: std::option::Option<std::string::String>,
    /// <p>The username of the administrator for the first database created in the namespace.</p>
    #[doc(hidden)]
    pub admin_username: std::option::Option<std::string::String>,
    /// <p>The name of the first database created in the namespace.</p>
    #[doc(hidden)]
    pub db_name: std::option::Option<std::string::String>,
    /// <p>The ID of the Amazon Web Services Key Management Service key used to encrypt your data.</p>
    #[doc(hidden)]
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the IAM role to set as a default in the namespace.</p>
    #[doc(hidden)]
    pub default_iam_role_arn: std::option::Option<std::string::String>,
    /// <p>A list of IAM roles to associate with the namespace.</p>
    #[doc(hidden)]
    pub iam_roles: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The types of logs the namespace can export. Available export types are User log, Connection log, and User activity log.</p>
    #[doc(hidden)]
    pub log_exports: std::option::Option<std::vec::Vec<crate::model::LogExport>>,
    /// <p>The status of the namespace.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::NamespaceStatus>,
    /// <p>The date of when the namespace was created.</p>
    #[doc(hidden)]
    pub creation_date: std::option::Option<aws_smithy_types::DateTime>,
}
impl Namespace {
    /// <p>The Amazon Resource Name (ARN) associated with a namespace.</p>
    pub fn namespace_arn(&self) -> std::option::Option<&str> {
        self.namespace_arn.as_deref()
    }
    /// <p>The unique identifier of a namespace.</p>
    pub fn namespace_id(&self) -> std::option::Option<&str> {
        self.namespace_id.as_deref()
    }
    /// <p>The name of the namespace. Must be between 3-64 alphanumeric characters in lowercase, and it cannot be a reserved word. A list of reserved words can be found in <a href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p>
    pub fn namespace_name(&self) -> std::option::Option<&str> {
        self.namespace_name.as_deref()
    }
    /// <p>The username of the administrator for the first database created in the namespace.</p>
    pub fn admin_username(&self) -> std::option::Option<&str> {
        self.admin_username.as_deref()
    }
    /// <p>The name of the first database created in the namespace.</p>
    pub fn db_name(&self) -> std::option::Option<&str> {
        self.db_name.as_deref()
    }
    /// <p>The ID of the Amazon Web Services Key Management Service key used to encrypt your data.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the IAM role to set as a default in the namespace.</p>
    pub fn default_iam_role_arn(&self) -> std::option::Option<&str> {
        self.default_iam_role_arn.as_deref()
    }
    /// <p>A list of IAM roles to associate with the namespace.</p>
    pub fn iam_roles(&self) -> std::option::Option<&[std::string::String]> {
        self.iam_roles.as_deref()
    }
    /// <p>The types of logs the namespace can export. Available export types are User log, Connection log, and User activity log.</p>
    pub fn log_exports(&self) -> std::option::Option<&[crate::model::LogExport]> {
        self.log_exports.as_deref()
    }
    /// <p>The status of the namespace.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::NamespaceStatus> {
        self.status.as_ref()
    }
    /// <p>The date of when the namespace was created.</p>
    pub fn creation_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_date.as_ref()
    }
}
impl std::fmt::Debug for Namespace {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Namespace");
        formatter.field("namespace_arn", &self.namespace_arn);
        formatter.field("namespace_id", &self.namespace_id);
        formatter.field("namespace_name", &self.namespace_name);
        formatter.field("admin_username", &"*** Sensitive Data Redacted ***");
        formatter.field("db_name", &self.db_name);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("default_iam_role_arn", &self.default_iam_role_arn);
        formatter.field("iam_roles", &self.iam_roles);
        formatter.field("log_exports", &self.log_exports);
        formatter.field("status", &self.status);
        formatter.field("creation_date", &self.creation_date);
        formatter.finish()
    }
}
/// See [`Namespace`](crate::model::Namespace).
pub mod namespace {

    /// A builder for [`Namespace`](crate::model::Namespace).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) namespace_arn: std::option::Option<std::string::String>,
        pub(crate) namespace_id: std::option::Option<std::string::String>,
        pub(crate) namespace_name: std::option::Option<std::string::String>,
        pub(crate) admin_username: std::option::Option<std::string::String>,
        pub(crate) db_name: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) default_iam_role_arn: std::option::Option<std::string::String>,
        pub(crate) iam_roles: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) log_exports: std::option::Option<std::vec::Vec<crate::model::LogExport>>,
        pub(crate) status: std::option::Option<crate::model::NamespaceStatus>,
        pub(crate) creation_date: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) associated with a namespace.</p>
        pub fn namespace_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) associated with a namespace.</p>
        pub fn set_namespace_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.namespace_arn = input;
            self
        }
        /// <p>The unique identifier of a namespace.</p>
        pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of a namespace.</p>
        pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace_id = input;
            self
        }
        /// <p>The name of the namespace. Must be between 3-64 alphanumeric characters in lowercase, and it cannot be a reserved word. A list of reserved words can be found in <a href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p>
        pub fn namespace_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace_name = Some(input.into());
            self
        }
        /// <p>The name of the namespace. Must be between 3-64 alphanumeric characters in lowercase, and it cannot be a reserved word. A list of reserved words can be found in <a href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p>
        pub fn set_namespace_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.namespace_name = input;
            self
        }
        /// <p>The username of the administrator for the first database created in the namespace.</p>
        pub fn admin_username(mut self, input: impl Into<std::string::String>) -> Self {
            self.admin_username = Some(input.into());
            self
        }
        /// <p>The username of the administrator for the first database created in the namespace.</p>
        pub fn set_admin_username(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.admin_username = input;
            self
        }
        /// <p>The name of the first database created in the namespace.</p>
        pub fn db_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.db_name = Some(input.into());
            self
        }
        /// <p>The name of the first database created in the namespace.</p>
        pub fn set_db_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.db_name = input;
            self
        }
        /// <p>The ID of the Amazon Web Services Key Management Service key used to encrypt your data.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The ID of the Amazon Web Services Key Management Service key used to encrypt your data.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM role to set as a default in the namespace.</p>
        pub fn default_iam_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_iam_role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM role to set as a default in the namespace.</p>
        pub fn set_default_iam_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_iam_role_arn = input;
            self
        }
        /// Appends an item to `iam_roles`.
        ///
        /// To override the contents of this collection use [`set_iam_roles`](Self::set_iam_roles).
        ///
        /// <p>A list of IAM roles to associate with the namespace.</p>
        pub fn iam_roles(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.iam_roles.unwrap_or_default();
            v.push(input.into());
            self.iam_roles = Some(v);
            self
        }
        /// <p>A list of IAM roles to associate with the namespace.</p>
        pub fn set_iam_roles(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.iam_roles = input;
            self
        }
        /// Appends an item to `log_exports`.
        ///
        /// To override the contents of this collection use [`set_log_exports`](Self::set_log_exports).
        ///
        /// <p>The types of logs the namespace can export. Available export types are User log, Connection log, and User activity log.</p>
        pub fn log_exports(mut self, input: crate::model::LogExport) -> Self {
            let mut v = self.log_exports.unwrap_or_default();
            v.push(input);
            self.log_exports = Some(v);
            self
        }
        /// <p>The types of logs the namespace can export. Available export types are User log, Connection log, and User activity log.</p>
        pub fn set_log_exports(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LogExport>>,
        ) -> Self {
            self.log_exports = input;
            self
        }
        /// <p>The status of the namespace.</p>
        pub fn status(mut self, input: crate::model::NamespaceStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the namespace.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::NamespaceStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The date of when the namespace was created.</p>
        pub fn creation_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_date = Some(input);
            self
        }
        /// <p>The date of when the namespace was created.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// Consumes the builder and constructs a [`Namespace`](crate::model::Namespace).
        pub fn build(self) -> crate::model::Namespace {
            crate::model::Namespace {
                namespace_arn: self.namespace_arn,
                namespace_id: self.namespace_id,
                namespace_name: self.namespace_name,
                admin_username: self.admin_username,
                db_name: self.db_name,
                kms_key_id: self.kms_key_id,
                default_iam_role_arn: self.default_iam_role_arn,
                iam_roles: self.iam_roles,
                log_exports: self.log_exports,
                status: self.status,
                creation_date: self.creation_date,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("namespace_arn", &self.namespace_arn);
            formatter.field("namespace_id", &self.namespace_id);
            formatter.field("namespace_name", &self.namespace_name);
            formatter.field("admin_username", &"*** Sensitive Data Redacted ***");
            formatter.field("db_name", &self.db_name);
            formatter.field("kms_key_id", &self.kms_key_id);
            formatter.field("default_iam_role_arn", &self.default_iam_role_arn);
            formatter.field("iam_roles", &self.iam_roles);
            formatter.field("log_exports", &self.log_exports);
            formatter.field("status", &self.status);
            formatter.field("creation_date", &self.creation_date);
            formatter.finish()
        }
    }
}
impl Namespace {
    /// Creates a new builder-style object to manufacture [`Namespace`](crate::model::Namespace).
    pub fn builder() -> crate::model::namespace::Builder {
        crate::model::namespace::Builder::default()
    }
}

/// When writing a match expression against `NamespaceStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let namespacestatus = unimplemented!();
/// match namespacestatus {
///     NamespaceStatus::Available => { /* ... */ },
///     NamespaceStatus::Deleting => { /* ... */ },
///     NamespaceStatus::Modifying => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `namespacestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `NamespaceStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `NamespaceStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `NamespaceStatus::NewFeature` is defined.
/// Specifically, when `namespacestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `NamespaceStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NamespaceStatus {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Modifying,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for NamespaceStatus {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => NamespaceStatus::Available,
            "DELETING" => NamespaceStatus::Deleting,
            "MODIFYING" => NamespaceStatus::Modifying,
            other => NamespaceStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for NamespaceStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NamespaceStatus::from(s))
    }
}
impl NamespaceStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NamespaceStatus::Available => "AVAILABLE",
            NamespaceStatus::Deleting => "DELETING",
            NamespaceStatus::Modifying => "MODIFYING",
            NamespaceStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AVAILABLE", "DELETING", "MODIFYING"]
    }
}
impl AsRef<str> for NamespaceStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `LogExport`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let logexport = unimplemented!();
/// match logexport {
///     LogExport::ConnectionLog => { /* ... */ },
///     LogExport::UserActivityLog => { /* ... */ },
///     LogExport::UserLog => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `logexport` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LogExport::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LogExport::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LogExport::NewFeature` is defined.
/// Specifically, when `logexport` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LogExport::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LogExport {
    #[allow(missing_docs)] // documentation missing in model
    ConnectionLog,
    #[allow(missing_docs)] // documentation missing in model
    UserActivityLog,
    #[allow(missing_docs)] // documentation missing in model
    UserLog,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LogExport {
    fn from(s: &str) -> Self {
        match s {
            "connectionlog" => LogExport::ConnectionLog,
            "useractivitylog" => LogExport::UserActivityLog,
            "userlog" => LogExport::UserLog,
            other => LogExport::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for LogExport {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LogExport::from(s))
    }
}
impl LogExport {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LogExport::ConnectionLog => "connectionlog",
            LogExport::UserActivityLog => "useractivitylog",
            LogExport::UserLog => "userlog",
            LogExport::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["connectionlog", "useractivitylog", "userlog"]
    }
}
impl AsRef<str> for LogExport {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The automatically created recovery point of a namespace. Recovery points are created every 30 minutes and kept for 24 hours.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RecoveryPoint {
    /// <p>The unique identifier of the recovery point.</p>
    #[doc(hidden)]
    pub recovery_point_id: std::option::Option<std::string::String>,
    /// <p>The time the recovery point is created.</p>
    #[doc(hidden)]
    pub recovery_point_create_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The total size of the data in the recovery point in megabytes.</p>
    #[doc(hidden)]
    pub total_size_in_mega_bytes: std::option::Option<f64>,
    /// <p>The name of the namespace the recovery point is associated with.</p>
    #[doc(hidden)]
    pub namespace_name: std::option::Option<std::string::String>,
    /// <p>The name of the workgroup the recovery point is associated with.</p>
    #[doc(hidden)]
    pub workgroup_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the namespace the recovery point is associated with.</p>
    #[doc(hidden)]
    pub namespace_arn: std::option::Option<std::string::String>,
}
impl RecoveryPoint {
    /// <p>The unique identifier of the recovery point.</p>
    pub fn recovery_point_id(&self) -> std::option::Option<&str> {
        self.recovery_point_id.as_deref()
    }
    /// <p>The time the recovery point is created.</p>
    pub fn recovery_point_create_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.recovery_point_create_time.as_ref()
    }
    /// <p>The total size of the data in the recovery point in megabytes.</p>
    pub fn total_size_in_mega_bytes(&self) -> std::option::Option<f64> {
        self.total_size_in_mega_bytes
    }
    /// <p>The name of the namespace the recovery point is associated with.</p>
    pub fn namespace_name(&self) -> std::option::Option<&str> {
        self.namespace_name.as_deref()
    }
    /// <p>The name of the workgroup the recovery point is associated with.</p>
    pub fn workgroup_name(&self) -> std::option::Option<&str> {
        self.workgroup_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the namespace the recovery point is associated with.</p>
    pub fn namespace_arn(&self) -> std::option::Option<&str> {
        self.namespace_arn.as_deref()
    }
}
/// See [`RecoveryPoint`](crate::model::RecoveryPoint).
pub mod recovery_point {

    /// A builder for [`RecoveryPoint`](crate::model::RecoveryPoint).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) recovery_point_id: std::option::Option<std::string::String>,
        pub(crate) recovery_point_create_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) total_size_in_mega_bytes: std::option::Option<f64>,
        pub(crate) namespace_name: std::option::Option<std::string::String>,
        pub(crate) workgroup_name: std::option::Option<std::string::String>,
        pub(crate) namespace_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the recovery point.</p>
        pub fn recovery_point_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.recovery_point_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the recovery point.</p>
        pub fn set_recovery_point_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recovery_point_id = input;
            self
        }
        /// <p>The time the recovery point is created.</p>
        pub fn recovery_point_create_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.recovery_point_create_time = Some(input);
            self
        }
        /// <p>The time the recovery point is created.</p>
        pub fn set_recovery_point_create_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.recovery_point_create_time = input;
            self
        }
        /// <p>The total size of the data in the recovery point in megabytes.</p>
        pub fn total_size_in_mega_bytes(mut self, input: f64) -> Self {
            self.total_size_in_mega_bytes = Some(input);
            self
        }
        /// <p>The total size of the data in the recovery point in megabytes.</p>
        pub fn set_total_size_in_mega_bytes(mut self, input: std::option::Option<f64>) -> Self {
            self.total_size_in_mega_bytes = input;
            self
        }
        /// <p>The name of the namespace the recovery point is associated with.</p>
        pub fn namespace_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace_name = Some(input.into());
            self
        }
        /// <p>The name of the namespace the recovery point is associated with.</p>
        pub fn set_namespace_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.namespace_name = input;
            self
        }
        /// <p>The name of the workgroup the recovery point is associated with.</p>
        pub fn workgroup_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.workgroup_name = Some(input.into());
            self
        }
        /// <p>The name of the workgroup the recovery point is associated with.</p>
        pub fn set_workgroup_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.workgroup_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the namespace the recovery point is associated with.</p>
        pub fn namespace_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the namespace the recovery point is associated with.</p>
        pub fn set_namespace_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.namespace_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`RecoveryPoint`](crate::model::RecoveryPoint).
        pub fn build(self) -> crate::model::RecoveryPoint {
            crate::model::RecoveryPoint {
                recovery_point_id: self.recovery_point_id,
                recovery_point_create_time: self.recovery_point_create_time,
                total_size_in_mega_bytes: self.total_size_in_mega_bytes,
                namespace_name: self.namespace_name,
                workgroup_name: self.workgroup_name,
                namespace_arn: self.namespace_arn,
            }
        }
    }
}
impl RecoveryPoint {
    /// Creates a new builder-style object to manufacture [`RecoveryPoint`](crate::model::RecoveryPoint).
    pub fn builder() -> crate::model::recovery_point::Builder {
        crate::model::recovery_point::Builder::default()
    }
}

/// <p>Information about an Amazon Redshift Serverless VPC endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EndpointAccess {
    /// <p>The name of the VPC endpoint.</p>
    #[doc(hidden)]
    pub endpoint_name: std::option::Option<std::string::String>,
    /// <p>The status of the VPC endpoint.</p>
    #[doc(hidden)]
    pub endpoint_status: std::option::Option<std::string::String>,
    /// <p>The name of the workgroup associated with the endpoint.</p>
    #[doc(hidden)]
    pub workgroup_name: std::option::Option<std::string::String>,
    /// <p>The time that the endpoint was created.</p>
    #[doc(hidden)]
    pub endpoint_create_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The port number on which Amazon Redshift Serverless accepts incoming connections.</p>
    #[doc(hidden)]
    pub port: std::option::Option<i32>,
    /// <p>The DNS address of the endpoint.</p>
    #[doc(hidden)]
    pub address: std::option::Option<std::string::String>,
    /// <p>The unique identifier of subnets where Amazon Redshift Serverless choose to deploy the VPC endpoint.</p>
    #[doc(hidden)]
    pub subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The security groups associated with the endpoint.</p>
    #[doc(hidden)]
    pub vpc_security_groups:
        std::option::Option<std::vec::Vec<crate::model::VpcSecurityGroupMembership>>,
    /// <p>The connection endpoint for connecting to Amazon Redshift Serverless.</p>
    #[doc(hidden)]
    pub vpc_endpoint: std::option::Option<crate::model::VpcEndpoint>,
    /// <p>The Amazon Resource Name (ARN) of the VPC endpoint.</p>
    #[doc(hidden)]
    pub endpoint_arn: std::option::Option<std::string::String>,
}
impl EndpointAccess {
    /// <p>The name of the VPC endpoint.</p>
    pub fn endpoint_name(&self) -> std::option::Option<&str> {
        self.endpoint_name.as_deref()
    }
    /// <p>The status of the VPC endpoint.</p>
    pub fn endpoint_status(&self) -> std::option::Option<&str> {
        self.endpoint_status.as_deref()
    }
    /// <p>The name of the workgroup associated with the endpoint.</p>
    pub fn workgroup_name(&self) -> std::option::Option<&str> {
        self.workgroup_name.as_deref()
    }
    /// <p>The time that the endpoint was created.</p>
    pub fn endpoint_create_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.endpoint_create_time.as_ref()
    }
    /// <p>The port number on which Amazon Redshift Serverless accepts incoming connections.</p>
    pub fn port(&self) -> std::option::Option<i32> {
        self.port
    }
    /// <p>The DNS address of the endpoint.</p>
    pub fn address(&self) -> std::option::Option<&str> {
        self.address.as_deref()
    }
    /// <p>The unique identifier of subnets where Amazon Redshift Serverless choose to deploy the VPC endpoint.</p>
    pub fn subnet_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.subnet_ids.as_deref()
    }
    /// <p>The security groups associated with the endpoint.</p>
    pub fn vpc_security_groups(
        &self,
    ) -> std::option::Option<&[crate::model::VpcSecurityGroupMembership]> {
        self.vpc_security_groups.as_deref()
    }
    /// <p>The connection endpoint for connecting to Amazon Redshift Serverless.</p>
    pub fn vpc_endpoint(&self) -> std::option::Option<&crate::model::VpcEndpoint> {
        self.vpc_endpoint.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the VPC endpoint.</p>
    pub fn endpoint_arn(&self) -> std::option::Option<&str> {
        self.endpoint_arn.as_deref()
    }
}
/// See [`EndpointAccess`](crate::model::EndpointAccess).
pub mod endpoint_access {

    /// A builder for [`EndpointAccess`](crate::model::EndpointAccess).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_name: std::option::Option<std::string::String>,
        pub(crate) endpoint_status: std::option::Option<std::string::String>,
        pub(crate) workgroup_name: std::option::Option<std::string::String>,
        pub(crate) endpoint_create_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) port: std::option::Option<i32>,
        pub(crate) address: std::option::Option<std::string::String>,
        pub(crate) subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) vpc_security_groups:
            std::option::Option<std::vec::Vec<crate::model::VpcSecurityGroupMembership>>,
        pub(crate) vpc_endpoint: std::option::Option<crate::model::VpcEndpoint>,
        pub(crate) endpoint_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the VPC endpoint.</p>
        pub fn endpoint_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_name = Some(input.into());
            self
        }
        /// <p>The name of the VPC endpoint.</p>
        pub fn set_endpoint_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_name = input;
            self
        }
        /// <p>The status of the VPC endpoint.</p>
        pub fn endpoint_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_status = Some(input.into());
            self
        }
        /// <p>The status of the VPC endpoint.</p>
        pub fn set_endpoint_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_status = input;
            self
        }
        /// <p>The name of the workgroup associated with the endpoint.</p>
        pub fn workgroup_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.workgroup_name = Some(input.into());
            self
        }
        /// <p>The name of the workgroup associated with the endpoint.</p>
        pub fn set_workgroup_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.workgroup_name = input;
            self
        }
        /// <p>The time that the endpoint was created.</p>
        pub fn endpoint_create_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.endpoint_create_time = Some(input);
            self
        }
        /// <p>The time that the endpoint was created.</p>
        pub fn set_endpoint_create_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.endpoint_create_time = input;
            self
        }
        /// <p>The port number on which Amazon Redshift Serverless accepts incoming connections.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        /// <p>The port number on which Amazon Redshift Serverless accepts incoming connections.</p>
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        /// <p>The DNS address of the endpoint.</p>
        pub fn address(mut self, input: impl Into<std::string::String>) -> Self {
            self.address = Some(input.into());
            self
        }
        /// <p>The DNS address of the endpoint.</p>
        pub fn set_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.address = input;
            self
        }
        /// Appends an item to `subnet_ids`.
        ///
        /// To override the contents of this collection use [`set_subnet_ids`](Self::set_subnet_ids).
        ///
        /// <p>The unique identifier of subnets where Amazon Redshift Serverless choose to deploy the VPC endpoint.</p>
        pub fn subnet_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnet_ids.unwrap_or_default();
            v.push(input.into());
            self.subnet_ids = Some(v);
            self
        }
        /// <p>The unique identifier of subnets where Amazon Redshift Serverless choose to deploy the VPC endpoint.</p>
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnet_ids = input;
            self
        }
        /// Appends an item to `vpc_security_groups`.
        ///
        /// To override the contents of this collection use [`set_vpc_security_groups`](Self::set_vpc_security_groups).
        ///
        /// <p>The security groups associated with the endpoint.</p>
        pub fn vpc_security_groups(
            mut self,
            input: crate::model::VpcSecurityGroupMembership,
        ) -> Self {
            let mut v = self.vpc_security_groups.unwrap_or_default();
            v.push(input);
            self.vpc_security_groups = Some(v);
            self
        }
        /// <p>The security groups associated with the endpoint.</p>
        pub fn set_vpc_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VpcSecurityGroupMembership>>,
        ) -> Self {
            self.vpc_security_groups = input;
            self
        }
        /// <p>The connection endpoint for connecting to Amazon Redshift Serverless.</p>
        pub fn vpc_endpoint(mut self, input: crate::model::VpcEndpoint) -> Self {
            self.vpc_endpoint = Some(input);
            self
        }
        /// <p>The connection endpoint for connecting to Amazon Redshift Serverless.</p>
        pub fn set_vpc_endpoint(
            mut self,
            input: std::option::Option<crate::model::VpcEndpoint>,
        ) -> Self {
            self.vpc_endpoint = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the VPC endpoint.</p>
        pub fn endpoint_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the VPC endpoint.</p>
        pub fn set_endpoint_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.endpoint_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`EndpointAccess`](crate::model::EndpointAccess).
        pub fn build(self) -> crate::model::EndpointAccess {
            crate::model::EndpointAccess {
                endpoint_name: self.endpoint_name,
                endpoint_status: self.endpoint_status,
                workgroup_name: self.workgroup_name,
                endpoint_create_time: self.endpoint_create_time,
                port: self.port,
                address: self.address,
                subnet_ids: self.subnet_ids,
                vpc_security_groups: self.vpc_security_groups,
                vpc_endpoint: self.vpc_endpoint,
                endpoint_arn: self.endpoint_arn,
            }
        }
    }
}
impl EndpointAccess {
    /// Creates a new builder-style object to manufacture [`EndpointAccess`](crate::model::EndpointAccess).
    pub fn builder() -> crate::model::endpoint_access::Builder {
        crate::model::endpoint_access::Builder::default()
    }
}

/// <p>Describes the members of a VPC security group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VpcSecurityGroupMembership {
    /// <p>The unique identifier of the VPC security group.</p>
    #[doc(hidden)]
    pub vpc_security_group_id: std::option::Option<std::string::String>,
    /// <p>The status of the VPC security group.</p>
    #[doc(hidden)]
    pub status: std::option::Option<std::string::String>,
}
impl VpcSecurityGroupMembership {
    /// <p>The unique identifier of the VPC security group.</p>
    pub fn vpc_security_group_id(&self) -> std::option::Option<&str> {
        self.vpc_security_group_id.as_deref()
    }
    /// <p>The status of the VPC security group.</p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
}
/// See [`VpcSecurityGroupMembership`](crate::model::VpcSecurityGroupMembership).
pub mod vpc_security_group_membership {

    /// A builder for [`VpcSecurityGroupMembership`](crate::model::VpcSecurityGroupMembership).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vpc_security_group_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the VPC security group.</p>
        pub fn vpc_security_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_security_group_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the VPC security group.</p>
        pub fn set_vpc_security_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpc_security_group_id = input;
            self
        }
        /// <p>The status of the VPC security group.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the VPC security group.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcSecurityGroupMembership`](crate::model::VpcSecurityGroupMembership).
        pub fn build(self) -> crate::model::VpcSecurityGroupMembership {
            crate::model::VpcSecurityGroupMembership {
                vpc_security_group_id: self.vpc_security_group_id,
                status: self.status,
            }
        }
    }
}
impl VpcSecurityGroupMembership {
    /// Creates a new builder-style object to manufacture [`VpcSecurityGroupMembership`](crate::model::VpcSecurityGroupMembership).
    pub fn builder() -> crate::model::vpc_security_group_membership::Builder {
        crate::model::vpc_security_group_membership::Builder::default()
    }
}

/// <p>The resource policy object. Currently, you can use policies to share snapshots across Amazon Web Services accounts.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourcePolicy {
    /// <p>The Amazon Resource Name (ARN) of the policy.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The resource policy.</p>
    #[doc(hidden)]
    pub policy: std::option::Option<std::string::String>,
}
impl ResourcePolicy {
    /// <p>The Amazon Resource Name (ARN) of the policy.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The resource policy.</p>
    pub fn policy(&self) -> std::option::Option<&str> {
        self.policy.as_deref()
    }
}
/// See [`ResourcePolicy`](crate::model::ResourcePolicy).
pub mod resource_policy {

    /// A builder for [`ResourcePolicy`](crate::model::ResourcePolicy).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) policy: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the policy.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the policy.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// <p>The resource policy.</p>
        pub fn policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy = Some(input.into());
            self
        }
        /// <p>The resource policy.</p>
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourcePolicy`](crate::model::ResourcePolicy).
        pub fn build(self) -> crate::model::ResourcePolicy {
            crate::model::ResourcePolicy {
                resource_arn: self.resource_arn,
                policy: self.policy,
            }
        }
    }
}
impl ResourcePolicy {
    /// Creates a new builder-style object to manufacture [`ResourcePolicy`](crate::model::ResourcePolicy).
    pub fn builder() -> crate::model::resource_policy::Builder {
        crate::model::resource_policy::Builder::default()
    }
}
