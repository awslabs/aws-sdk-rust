// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The collection of computing resources from which an endpoint is created.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Workgroup {
    /// <p>The unique identifier of the workgroup.</p>
    pub workgroup_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) that links to the workgroup.</p>
    pub workgroup_arn: std::option::Option<std::string::String>,
    /// <p>The name of the workgroup.</p>
    pub workgroup_name: std::option::Option<std::string::String>,
    /// <p>The namespace the workgroup is associated with.</p>
    pub namespace_name: std::option::Option<std::string::String>,
    /// <p>The base data warehouse capacity of the workgroup in Redshift Processing Units (RPUs).</p>
    pub base_capacity: std::option::Option<i32>,
    /// <p>The value that specifies whether to enable enhanced virtual private cloud (VPC) routing, which forces Amazon Redshift Serverless to route traffic through your VPC.</p>
    pub enhanced_vpc_routing: std::option::Option<bool>,
    /// <p>An array of parameters to set for finer control over a database. The options are <code>datestyle</code>, <code>enable_user_activity_logging</code>, <code>query_group</code>, <code>search_path</code>, and <code>max_query_execution_time</code>.</p>
    pub config_parameters: std::option::Option<std::vec::Vec<crate::model::ConfigParameter>>,
    /// <p>An array of security group IDs to associate with the workgroup.</p>
    pub security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>An array of subnet IDs the workgroup is associated with.</p>
    pub subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The status of the workgroup.</p>
    pub status: std::option::Option<crate::model::WorkgroupStatus>,
    /// <p>The endpoint that is created from the workgroup.</p>
    pub endpoint: std::option::Option<crate::model::Endpoint>,
    /// <p>A value that specifies whether the workgroup can be accessible from a public network</p>
    pub publicly_accessible: std::option::Option<bool>,
    /// <p>The creation date of the workgroup.</p>
    pub creation_date: std::option::Option<aws_smithy_types::DateTime>,
}
impl Workgroup {
    /// <p>The unique identifier of the workgroup.</p>
    pub fn workgroup_id(&self) -> std::option::Option<&str> {
        self.workgroup_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) that links to the workgroup.</p>
    pub fn workgroup_arn(&self) -> std::option::Option<&str> {
        self.workgroup_arn.as_deref()
    }
    /// <p>The name of the workgroup.</p>
    pub fn workgroup_name(&self) -> std::option::Option<&str> {
        self.workgroup_name.as_deref()
    }
    /// <p>The namespace the workgroup is associated with.</p>
    pub fn namespace_name(&self) -> std::option::Option<&str> {
        self.namespace_name.as_deref()
    }
    /// <p>The base data warehouse capacity of the workgroup in Redshift Processing Units (RPUs).</p>
    pub fn base_capacity(&self) -> std::option::Option<i32> {
        self.base_capacity
    }
    /// <p>The value that specifies whether to enable enhanced virtual private cloud (VPC) routing, which forces Amazon Redshift Serverless to route traffic through your VPC.</p>
    pub fn enhanced_vpc_routing(&self) -> std::option::Option<bool> {
        self.enhanced_vpc_routing
    }
    /// <p>An array of parameters to set for finer control over a database. The options are <code>datestyle</code>, <code>enable_user_activity_logging</code>, <code>query_group</code>, <code>search_path</code>, and <code>max_query_execution_time</code>.</p>
    pub fn config_parameters(&self) -> std::option::Option<&[crate::model::ConfigParameter]> {
        self.config_parameters.as_deref()
    }
    /// <p>An array of security group IDs to associate with the workgroup.</p>
    pub fn security_group_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.security_group_ids.as_deref()
    }
    /// <p>An array of subnet IDs the workgroup is associated with.</p>
    pub fn subnet_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.subnet_ids.as_deref()
    }
    /// <p>The status of the workgroup.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::WorkgroupStatus> {
        self.status.as_ref()
    }
    /// <p>The endpoint that is created from the workgroup.</p>
    pub fn endpoint(&self) -> std::option::Option<&crate::model::Endpoint> {
        self.endpoint.as_ref()
    }
    /// <p>A value that specifies whether the workgroup can be accessible from a public network</p>
    pub fn publicly_accessible(&self) -> std::option::Option<bool> {
        self.publicly_accessible
    }
    /// <p>The creation date of the workgroup.</p>
    pub fn creation_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_date.as_ref()
    }
}
impl std::fmt::Debug for Workgroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Workgroup");
        formatter.field("workgroup_id", &self.workgroup_id);
        formatter.field("workgroup_arn", &self.workgroup_arn);
        formatter.field("workgroup_name", &self.workgroup_name);
        formatter.field("namespace_name", &self.namespace_name);
        formatter.field("base_capacity", &self.base_capacity);
        formatter.field("enhanced_vpc_routing", &self.enhanced_vpc_routing);
        formatter.field("config_parameters", &self.config_parameters);
        formatter.field("security_group_ids", &self.security_group_ids);
        formatter.field("subnet_ids", &self.subnet_ids);
        formatter.field("status", &self.status);
        formatter.field("endpoint", &self.endpoint);
        formatter.field("publicly_accessible", &self.publicly_accessible);
        formatter.field("creation_date", &self.creation_date);
        formatter.finish()
    }
}
/// See [`Workgroup`](crate::model::Workgroup)
pub mod workgroup {

    /// A builder for [`Workgroup`](crate::model::Workgroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workgroup_id: std::option::Option<std::string::String>,
        pub(crate) workgroup_arn: std::option::Option<std::string::String>,
        pub(crate) workgroup_name: std::option::Option<std::string::String>,
        pub(crate) namespace_name: std::option::Option<std::string::String>,
        pub(crate) base_capacity: std::option::Option<i32>,
        pub(crate) enhanced_vpc_routing: std::option::Option<bool>,
        pub(crate) config_parameters:
            std::option::Option<std::vec::Vec<crate::model::ConfigParameter>>,
        pub(crate) security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) status: std::option::Option<crate::model::WorkgroupStatus>,
        pub(crate) endpoint: std::option::Option<crate::model::Endpoint>,
        pub(crate) publicly_accessible: std::option::Option<bool>,
        pub(crate) creation_date: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The unique identifier of the workgroup.</p>
        pub fn workgroup_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workgroup_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the workgroup.</p>
        pub fn set_workgroup_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workgroup_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) that links to the workgroup.</p>
        pub fn workgroup_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.workgroup_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) that links to the workgroup.</p>
        pub fn set_workgroup_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.workgroup_arn = input;
            self
        }
        /// <p>The name of the workgroup.</p>
        pub fn workgroup_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.workgroup_name = Some(input.into());
            self
        }
        /// <p>The name of the workgroup.</p>
        pub fn set_workgroup_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.workgroup_name = input;
            self
        }
        /// <p>The namespace the workgroup is associated with.</p>
        pub fn namespace_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace_name = Some(input.into());
            self
        }
        /// <p>The namespace the workgroup is associated with.</p>
        pub fn set_namespace_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.namespace_name = input;
            self
        }
        /// <p>The base data warehouse capacity of the workgroup in Redshift Processing Units (RPUs).</p>
        pub fn base_capacity(mut self, input: i32) -> Self {
            self.base_capacity = Some(input);
            self
        }
        /// <p>The base data warehouse capacity of the workgroup in Redshift Processing Units (RPUs).</p>
        pub fn set_base_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.base_capacity = input;
            self
        }
        /// <p>The value that specifies whether to enable enhanced virtual private cloud (VPC) routing, which forces Amazon Redshift Serverless to route traffic through your VPC.</p>
        pub fn enhanced_vpc_routing(mut self, input: bool) -> Self {
            self.enhanced_vpc_routing = Some(input);
            self
        }
        /// <p>The value that specifies whether to enable enhanced virtual private cloud (VPC) routing, which forces Amazon Redshift Serverless to route traffic through your VPC.</p>
        pub fn set_enhanced_vpc_routing(mut self, input: std::option::Option<bool>) -> Self {
            self.enhanced_vpc_routing = input;
            self
        }
        /// Appends an item to `config_parameters`.
        ///
        /// To override the contents of this collection use [`set_config_parameters`](Self::set_config_parameters).
        ///
        /// <p>An array of parameters to set for finer control over a database. The options are <code>datestyle</code>, <code>enable_user_activity_logging</code>, <code>query_group</code>, <code>search_path</code>, and <code>max_query_execution_time</code>.</p>
        pub fn config_parameters(mut self, input: crate::model::ConfigParameter) -> Self {
            let mut v = self.config_parameters.unwrap_or_default();
            v.push(input);
            self.config_parameters = Some(v);
            self
        }
        /// <p>An array of parameters to set for finer control over a database. The options are <code>datestyle</code>, <code>enable_user_activity_logging</code>, <code>query_group</code>, <code>search_path</code>, and <code>max_query_execution_time</code>.</p>
        pub fn set_config_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ConfigParameter>>,
        ) -> Self {
            self.config_parameters = input;
            self
        }
        /// Appends an item to `security_group_ids`.
        ///
        /// To override the contents of this collection use [`set_security_group_ids`](Self::set_security_group_ids).
        ///
        /// <p>An array of security group IDs to associate with the workgroup.</p>
        pub fn security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.security_group_ids = Some(v);
            self
        }
        /// <p>An array of security group IDs to associate with the workgroup.</p>
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_ids = input;
            self
        }
        /// Appends an item to `subnet_ids`.
        ///
        /// To override the contents of this collection use [`set_subnet_ids`](Self::set_subnet_ids).
        ///
        /// <p>An array of subnet IDs the workgroup is associated with.</p>
        pub fn subnet_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnet_ids.unwrap_or_default();
            v.push(input.into());
            self.subnet_ids = Some(v);
            self
        }
        /// <p>An array of subnet IDs the workgroup is associated with.</p>
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnet_ids = input;
            self
        }
        /// <p>The status of the workgroup.</p>
        pub fn status(mut self, input: crate::model::WorkgroupStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the workgroup.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::WorkgroupStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The endpoint that is created from the workgroup.</p>
        pub fn endpoint(mut self, input: crate::model::Endpoint) -> Self {
            self.endpoint = Some(input);
            self
        }
        /// <p>The endpoint that is created from the workgroup.</p>
        pub fn set_endpoint(mut self, input: std::option::Option<crate::model::Endpoint>) -> Self {
            self.endpoint = input;
            self
        }
        /// <p>A value that specifies whether the workgroup can be accessible from a public network</p>
        pub fn publicly_accessible(mut self, input: bool) -> Self {
            self.publicly_accessible = Some(input);
            self
        }
        /// <p>A value that specifies whether the workgroup can be accessible from a public network</p>
        pub fn set_publicly_accessible(mut self, input: std::option::Option<bool>) -> Self {
            self.publicly_accessible = input;
            self
        }
        /// <p>The creation date of the workgroup.</p>
        pub fn creation_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_date = Some(input);
            self
        }
        /// <p>The creation date of the workgroup.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// Consumes the builder and constructs a [`Workgroup`](crate::model::Workgroup)
        pub fn build(self) -> crate::model::Workgroup {
            crate::model::Workgroup {
                workgroup_id: self.workgroup_id,
                workgroup_arn: self.workgroup_arn,
                workgroup_name: self.workgroup_name,
                namespace_name: self.namespace_name,
                base_capacity: self.base_capacity,
                enhanced_vpc_routing: self.enhanced_vpc_routing,
                config_parameters: self.config_parameters,
                security_group_ids: self.security_group_ids,
                subnet_ids: self.subnet_ids,
                status: self.status,
                endpoint: self.endpoint,
                publicly_accessible: self.publicly_accessible,
                creation_date: self.creation_date,
            }
        }
    }
}
impl Workgroup {
    /// Creates a new builder-style object to manufacture [`Workgroup`](crate::model::Workgroup)
    pub fn builder() -> crate::model::workgroup::Builder {
        crate::model::workgroup::Builder::default()
    }
}

/// <p>The VPC endpoint object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Endpoint {
    /// <p>The DNS address of the VPC endpoint.</p>
    pub address: std::option::Option<std::string::String>,
    /// <p>The port that Amazon Redshift Serverless listens on.</p>
    pub port: std::option::Option<i32>,
    /// <p>An array of <code>VpcEndpoint</code> objects.</p>
    pub vpc_endpoints: std::option::Option<std::vec::Vec<crate::model::VpcEndpoint>>,
}
impl Endpoint {
    /// <p>The DNS address of the VPC endpoint.</p>
    pub fn address(&self) -> std::option::Option<&str> {
        self.address.as_deref()
    }
    /// <p>The port that Amazon Redshift Serverless listens on.</p>
    pub fn port(&self) -> std::option::Option<i32> {
        self.port
    }
    /// <p>An array of <code>VpcEndpoint</code> objects.</p>
    pub fn vpc_endpoints(&self) -> std::option::Option<&[crate::model::VpcEndpoint]> {
        self.vpc_endpoints.as_deref()
    }
}
impl std::fmt::Debug for Endpoint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Endpoint");
        formatter.field("address", &self.address);
        formatter.field("port", &self.port);
        formatter.field("vpc_endpoints", &self.vpc_endpoints);
        formatter.finish()
    }
}
/// See [`Endpoint`](crate::model::Endpoint)
pub mod endpoint {

    /// A builder for [`Endpoint`](crate::model::Endpoint)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) address: std::option::Option<std::string::String>,
        pub(crate) port: std::option::Option<i32>,
        pub(crate) vpc_endpoints: std::option::Option<std::vec::Vec<crate::model::VpcEndpoint>>,
    }
    impl Builder {
        /// <p>The DNS address of the VPC endpoint.</p>
        pub fn address(mut self, input: impl Into<std::string::String>) -> Self {
            self.address = Some(input.into());
            self
        }
        /// <p>The DNS address of the VPC endpoint.</p>
        pub fn set_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.address = input;
            self
        }
        /// <p>The port that Amazon Redshift Serverless listens on.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        /// <p>The port that Amazon Redshift Serverless listens on.</p>
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        /// Appends an item to `vpc_endpoints`.
        ///
        /// To override the contents of this collection use [`set_vpc_endpoints`](Self::set_vpc_endpoints).
        ///
        /// <p>An array of <code>VpcEndpoint</code> objects.</p>
        pub fn vpc_endpoints(mut self, input: crate::model::VpcEndpoint) -> Self {
            let mut v = self.vpc_endpoints.unwrap_or_default();
            v.push(input);
            self.vpc_endpoints = Some(v);
            self
        }
        /// <p>An array of <code>VpcEndpoint</code> objects.</p>
        pub fn set_vpc_endpoints(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VpcEndpoint>>,
        ) -> Self {
            self.vpc_endpoints = input;
            self
        }
        /// Consumes the builder and constructs a [`Endpoint`](crate::model::Endpoint)
        pub fn build(self) -> crate::model::Endpoint {
            crate::model::Endpoint {
                address: self.address,
                port: self.port,
                vpc_endpoints: self.vpc_endpoints,
            }
        }
    }
}
impl Endpoint {
    /// Creates a new builder-style object to manufacture [`Endpoint`](crate::model::Endpoint)
    pub fn builder() -> crate::model::endpoint::Builder {
        crate::model::endpoint::Builder::default()
    }
}

/// <p>The connection endpoint for connecting to Amazon Redshift Serverless through the proxy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VpcEndpoint {
    /// <p>The connection endpoint ID for connecting to Amazon Redshift Serverless.</p>
    pub vpc_endpoint_id: std::option::Option<std::string::String>,
    /// <p>The VPC identifier that the endpoint is associated with.</p>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>One or more network interfaces of the endpoint. Also known as an interface endpoint.</p>
    pub network_interfaces: std::option::Option<std::vec::Vec<crate::model::NetworkInterface>>,
}
impl VpcEndpoint {
    /// <p>The connection endpoint ID for connecting to Amazon Redshift Serverless.</p>
    pub fn vpc_endpoint_id(&self) -> std::option::Option<&str> {
        self.vpc_endpoint_id.as_deref()
    }
    /// <p>The VPC identifier that the endpoint is associated with.</p>
    pub fn vpc_id(&self) -> std::option::Option<&str> {
        self.vpc_id.as_deref()
    }
    /// <p>One or more network interfaces of the endpoint. Also known as an interface endpoint.</p>
    pub fn network_interfaces(&self) -> std::option::Option<&[crate::model::NetworkInterface]> {
        self.network_interfaces.as_deref()
    }
}
impl std::fmt::Debug for VpcEndpoint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VpcEndpoint");
        formatter.field("vpc_endpoint_id", &self.vpc_endpoint_id);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("network_interfaces", &self.network_interfaces);
        formatter.finish()
    }
}
/// See [`VpcEndpoint`](crate::model::VpcEndpoint)
pub mod vpc_endpoint {

    /// A builder for [`VpcEndpoint`](crate::model::VpcEndpoint)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vpc_endpoint_id: std::option::Option<std::string::String>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) network_interfaces:
            std::option::Option<std::vec::Vec<crate::model::NetworkInterface>>,
    }
    impl Builder {
        /// <p>The connection endpoint ID for connecting to Amazon Redshift Serverless.</p>
        pub fn vpc_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_endpoint_id = Some(input.into());
            self
        }
        /// <p>The connection endpoint ID for connecting to Amazon Redshift Serverless.</p>
        pub fn set_vpc_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpc_endpoint_id = input;
            self
        }
        /// <p>The VPC identifier that the endpoint is associated with.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        /// <p>The VPC identifier that the endpoint is associated with.</p>
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// Appends an item to `network_interfaces`.
        ///
        /// To override the contents of this collection use [`set_network_interfaces`](Self::set_network_interfaces).
        ///
        /// <p>One or more network interfaces of the endpoint. Also known as an interface endpoint.</p>
        pub fn network_interfaces(mut self, input: crate::model::NetworkInterface) -> Self {
            let mut v = self.network_interfaces.unwrap_or_default();
            v.push(input);
            self.network_interfaces = Some(v);
            self
        }
        /// <p>One or more network interfaces of the endpoint. Also known as an interface endpoint.</p>
        pub fn set_network_interfaces(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NetworkInterface>>,
        ) -> Self {
            self.network_interfaces = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcEndpoint`](crate::model::VpcEndpoint)
        pub fn build(self) -> crate::model::VpcEndpoint {
            crate::model::VpcEndpoint {
                vpc_endpoint_id: self.vpc_endpoint_id,
                vpc_id: self.vpc_id,
                network_interfaces: self.network_interfaces,
            }
        }
    }
}
impl VpcEndpoint {
    /// Creates a new builder-style object to manufacture [`VpcEndpoint`](crate::model::VpcEndpoint)
    pub fn builder() -> crate::model::vpc_endpoint::Builder {
        crate::model::vpc_endpoint::Builder::default()
    }
}

/// <p>Contains information about a network interface in an Amazon Redshift Serverless managed VPC endpoint. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NetworkInterface {
    /// <p>The unique identifier of the network interface.</p>
    pub network_interface_id: std::option::Option<std::string::String>,
    /// <p>The unique identifier of the subnet.</p>
    pub subnet_id: std::option::Option<std::string::String>,
    /// <p>The IPv4 address of the network interface within the subnet.</p>
    pub private_ip_address: std::option::Option<std::string::String>,
    /// <p>The availability Zone.</p>
    pub availability_zone: std::option::Option<std::string::String>,
}
impl NetworkInterface {
    /// <p>The unique identifier of the network interface.</p>
    pub fn network_interface_id(&self) -> std::option::Option<&str> {
        self.network_interface_id.as_deref()
    }
    /// <p>The unique identifier of the subnet.</p>
    pub fn subnet_id(&self) -> std::option::Option<&str> {
        self.subnet_id.as_deref()
    }
    /// <p>The IPv4 address of the network interface within the subnet.</p>
    pub fn private_ip_address(&self) -> std::option::Option<&str> {
        self.private_ip_address.as_deref()
    }
    /// <p>The availability Zone.</p>
    pub fn availability_zone(&self) -> std::option::Option<&str> {
        self.availability_zone.as_deref()
    }
}
impl std::fmt::Debug for NetworkInterface {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NetworkInterface");
        formatter.field("network_interface_id", &self.network_interface_id);
        formatter.field("subnet_id", &self.subnet_id);
        formatter.field("private_ip_address", &self.private_ip_address);
        formatter.field("availability_zone", &self.availability_zone);
        formatter.finish()
    }
}
/// See [`NetworkInterface`](crate::model::NetworkInterface)
pub mod network_interface {

    /// A builder for [`NetworkInterface`](crate::model::NetworkInterface)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) network_interface_id: std::option::Option<std::string::String>,
        pub(crate) subnet_id: std::option::Option<std::string::String>,
        pub(crate) private_ip_address: std::option::Option<std::string::String>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the network interface.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_interface_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the network interface.</p>
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_interface_id = input;
            self
        }
        /// <p>The unique identifier of the subnet.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the subnet.</p>
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_id = input;
            self
        }
        /// <p>The IPv4 address of the network interface within the subnet.</p>
        pub fn private_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_ip_address = Some(input.into());
            self
        }
        /// <p>The IPv4 address of the network interface within the subnet.</p>
        pub fn set_private_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_ip_address = input;
            self
        }
        /// <p>The availability Zone.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        /// <p>The availability Zone.</p>
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkInterface`](crate::model::NetworkInterface)
        pub fn build(self) -> crate::model::NetworkInterface {
            crate::model::NetworkInterface {
                network_interface_id: self.network_interface_id,
                subnet_id: self.subnet_id,
                private_ip_address: self.private_ip_address,
                availability_zone: self.availability_zone,
            }
        }
    }
}
impl NetworkInterface {
    /// Creates a new builder-style object to manufacture [`NetworkInterface`](crate::model::NetworkInterface)
    pub fn builder() -> crate::model::network_interface::Builder {
        crate::model::network_interface::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WorkgroupStatus {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Modifying,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for WorkgroupStatus {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => WorkgroupStatus::Available,
            "CREATING" => WorkgroupStatus::Creating,
            "DELETING" => WorkgroupStatus::Deleting,
            "MODIFYING" => WorkgroupStatus::Modifying,
            other => WorkgroupStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for WorkgroupStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WorkgroupStatus::from(s))
    }
}
impl WorkgroupStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WorkgroupStatus::Available => "AVAILABLE",
            WorkgroupStatus::Creating => "CREATING",
            WorkgroupStatus::Deleting => "DELETING",
            WorkgroupStatus::Modifying => "MODIFYING",
            WorkgroupStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["AVAILABLE", "CREATING", "DELETING", "MODIFYING"]
    }
}
impl AsRef<str> for WorkgroupStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An array of key-value pairs to set for advanced control over Amazon Redshift Serverless.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConfigParameter {
    /// <p>The key of the parameter. The options are <code>datestyle</code>, <code>enable_user_activity_logging</code>, <code>query_group</code>, <code>search_path</code>, and <code>max_query_execution_time</code>.</p>
    pub parameter_key: std::option::Option<std::string::String>,
    /// <p>The value of the parameter to set.</p>
    pub parameter_value: std::option::Option<std::string::String>,
}
impl ConfigParameter {
    /// <p>The key of the parameter. The options are <code>datestyle</code>, <code>enable_user_activity_logging</code>, <code>query_group</code>, <code>search_path</code>, and <code>max_query_execution_time</code>.</p>
    pub fn parameter_key(&self) -> std::option::Option<&str> {
        self.parameter_key.as_deref()
    }
    /// <p>The value of the parameter to set.</p>
    pub fn parameter_value(&self) -> std::option::Option<&str> {
        self.parameter_value.as_deref()
    }
}
impl std::fmt::Debug for ConfigParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConfigParameter");
        formatter.field("parameter_key", &self.parameter_key);
        formatter.field("parameter_value", &self.parameter_value);
        formatter.finish()
    }
}
/// See [`ConfigParameter`](crate::model::ConfigParameter)
pub mod config_parameter {

    /// A builder for [`ConfigParameter`](crate::model::ConfigParameter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) parameter_key: std::option::Option<std::string::String>,
        pub(crate) parameter_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The key of the parameter. The options are <code>datestyle</code>, <code>enable_user_activity_logging</code>, <code>query_group</code>, <code>search_path</code>, and <code>max_query_execution_time</code>.</p>
        pub fn parameter_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter_key = Some(input.into());
            self
        }
        /// <p>The key of the parameter. The options are <code>datestyle</code>, <code>enable_user_activity_logging</code>, <code>query_group</code>, <code>search_path</code>, and <code>max_query_execution_time</code>.</p>
        pub fn set_parameter_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_key = input;
            self
        }
        /// <p>The value of the parameter to set.</p>
        pub fn parameter_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter_value = Some(input.into());
            self
        }
        /// <p>The value of the parameter to set.</p>
        pub fn set_parameter_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_value = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfigParameter`](crate::model::ConfigParameter)
        pub fn build(self) -> crate::model::ConfigParameter {
            crate::model::ConfigParameter {
                parameter_key: self.parameter_key,
                parameter_value: self.parameter_value,
            }
        }
    }
}
impl ConfigParameter {
    /// Creates a new builder-style object to manufacture [`ConfigParameter`](crate::model::ConfigParameter)
    pub fn builder() -> crate::model::config_parameter::Builder {
        crate::model::config_parameter::Builder::default()
    }
}

/// <p>A map of key-value pairs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Tag {
    /// <p>The key to use in the tag.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The value of the tag.</p>
    pub value: std::option::Option<std::string::String>,
}
impl Tag {
    /// <p>The key to use in the tag.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The value of the tag.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for Tag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Tag");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Tag`](crate::model::Tag)
pub mod tag {

    /// A builder for [`Tag`](crate::model::Tag)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The key to use in the tag.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The key to use in the tag.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The value of the tag.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the tag.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag)
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag)
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// <p>The usage limit object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UsageLimit {
    /// <p>The identifier of the usage limit.</p>
    pub usage_limit_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the resource associated with the usage limit.</p>
    pub usage_limit_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) that identifies the Amazon Redshift Serverless resource.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Redshift Serverless feature to limit.</p>
    pub usage_type: std::option::Option<crate::model::UsageLimitUsageType>,
    /// <p>The limit amount. If time-based, this amount is in RPUs consumed per hour. If data-based, this amount is in terabytes (TB). The value must be a positive number.</p>
    pub amount: std::option::Option<i64>,
    /// <p>The time period that the amount applies to. A weekly period begins on Sunday. The default is monthly.</p>
    pub period: std::option::Option<crate::model::UsageLimitPeriod>,
    /// <p>The action that Amazon Redshift Serverless takes when the limit is reached.</p>
    pub breach_action: std::option::Option<crate::model::UsageLimitBreachAction>,
}
impl UsageLimit {
    /// <p>The identifier of the usage limit.</p>
    pub fn usage_limit_id(&self) -> std::option::Option<&str> {
        self.usage_limit_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the resource associated with the usage limit.</p>
    pub fn usage_limit_arn(&self) -> std::option::Option<&str> {
        self.usage_limit_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) that identifies the Amazon Redshift Serverless resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The Amazon Redshift Serverless feature to limit.</p>
    pub fn usage_type(&self) -> std::option::Option<&crate::model::UsageLimitUsageType> {
        self.usage_type.as_ref()
    }
    /// <p>The limit amount. If time-based, this amount is in RPUs consumed per hour. If data-based, this amount is in terabytes (TB). The value must be a positive number.</p>
    pub fn amount(&self) -> std::option::Option<i64> {
        self.amount
    }
    /// <p>The time period that the amount applies to. A weekly period begins on Sunday. The default is monthly.</p>
    pub fn period(&self) -> std::option::Option<&crate::model::UsageLimitPeriod> {
        self.period.as_ref()
    }
    /// <p>The action that Amazon Redshift Serverless takes when the limit is reached.</p>
    pub fn breach_action(&self) -> std::option::Option<&crate::model::UsageLimitBreachAction> {
        self.breach_action.as_ref()
    }
}
impl std::fmt::Debug for UsageLimit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UsageLimit");
        formatter.field("usage_limit_id", &self.usage_limit_id);
        formatter.field("usage_limit_arn", &self.usage_limit_arn);
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("usage_type", &self.usage_type);
        formatter.field("amount", &self.amount);
        formatter.field("period", &self.period);
        formatter.field("breach_action", &self.breach_action);
        formatter.finish()
    }
}
/// See [`UsageLimit`](crate::model::UsageLimit)
pub mod usage_limit {

    /// A builder for [`UsageLimit`](crate::model::UsageLimit)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) usage_limit_id: std::option::Option<std::string::String>,
        pub(crate) usage_limit_arn: std::option::Option<std::string::String>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) usage_type: std::option::Option<crate::model::UsageLimitUsageType>,
        pub(crate) amount: std::option::Option<i64>,
        pub(crate) period: std::option::Option<crate::model::UsageLimitPeriod>,
        pub(crate) breach_action: std::option::Option<crate::model::UsageLimitBreachAction>,
    }
    impl Builder {
        /// <p>The identifier of the usage limit.</p>
        pub fn usage_limit_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.usage_limit_id = Some(input.into());
            self
        }
        /// <p>The identifier of the usage limit.</p>
        pub fn set_usage_limit_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.usage_limit_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource associated with the usage limit.</p>
        pub fn usage_limit_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.usage_limit_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource associated with the usage limit.</p>
        pub fn set_usage_limit_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.usage_limit_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) that identifies the Amazon Redshift Serverless resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) that identifies the Amazon Redshift Serverless resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// <p>The Amazon Redshift Serverless feature to limit.</p>
        pub fn usage_type(mut self, input: crate::model::UsageLimitUsageType) -> Self {
            self.usage_type = Some(input);
            self
        }
        /// <p>The Amazon Redshift Serverless feature to limit.</p>
        pub fn set_usage_type(
            mut self,
            input: std::option::Option<crate::model::UsageLimitUsageType>,
        ) -> Self {
            self.usage_type = input;
            self
        }
        /// <p>The limit amount. If time-based, this amount is in RPUs consumed per hour. If data-based, this amount is in terabytes (TB). The value must be a positive number.</p>
        pub fn amount(mut self, input: i64) -> Self {
            self.amount = Some(input);
            self
        }
        /// <p>The limit amount. If time-based, this amount is in RPUs consumed per hour. If data-based, this amount is in terabytes (TB). The value must be a positive number.</p>
        pub fn set_amount(mut self, input: std::option::Option<i64>) -> Self {
            self.amount = input;
            self
        }
        /// <p>The time period that the amount applies to. A weekly period begins on Sunday. The default is monthly.</p>
        pub fn period(mut self, input: crate::model::UsageLimitPeriod) -> Self {
            self.period = Some(input);
            self
        }
        /// <p>The time period that the amount applies to. A weekly period begins on Sunday. The default is monthly.</p>
        pub fn set_period(
            mut self,
            input: std::option::Option<crate::model::UsageLimitPeriod>,
        ) -> Self {
            self.period = input;
            self
        }
        /// <p>The action that Amazon Redshift Serverless takes when the limit is reached.</p>
        pub fn breach_action(mut self, input: crate::model::UsageLimitBreachAction) -> Self {
            self.breach_action = Some(input);
            self
        }
        /// <p>The action that Amazon Redshift Serverless takes when the limit is reached.</p>
        pub fn set_breach_action(
            mut self,
            input: std::option::Option<crate::model::UsageLimitBreachAction>,
        ) -> Self {
            self.breach_action = input;
            self
        }
        /// Consumes the builder and constructs a [`UsageLimit`](crate::model::UsageLimit)
        pub fn build(self) -> crate::model::UsageLimit {
            crate::model::UsageLimit {
                usage_limit_id: self.usage_limit_id,
                usage_limit_arn: self.usage_limit_arn,
                resource_arn: self.resource_arn,
                usage_type: self.usage_type,
                amount: self.amount,
                period: self.period,
                breach_action: self.breach_action,
            }
        }
    }
}
impl UsageLimit {
    /// Creates a new builder-style object to manufacture [`UsageLimit`](crate::model::UsageLimit)
    pub fn builder() -> crate::model::usage_limit::Builder {
        crate::model::usage_limit::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UsageLimitBreachAction {
    #[allow(missing_docs)] // documentation missing in model
    Deactivate,
    #[allow(missing_docs)] // documentation missing in model
    EmitMetric,
    #[allow(missing_docs)] // documentation missing in model
    Log,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for UsageLimitBreachAction {
    fn from(s: &str) -> Self {
        match s {
            "deactivate" => UsageLimitBreachAction::Deactivate,
            "emit-metric" => UsageLimitBreachAction::EmitMetric,
            "log" => UsageLimitBreachAction::Log,
            other => UsageLimitBreachAction::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for UsageLimitBreachAction {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UsageLimitBreachAction::from(s))
    }
}
impl UsageLimitBreachAction {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UsageLimitBreachAction::Deactivate => "deactivate",
            UsageLimitBreachAction::EmitMetric => "emit-metric",
            UsageLimitBreachAction::Log => "log",
            UsageLimitBreachAction::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["deactivate", "emit-metric", "log"]
    }
}
impl AsRef<str> for UsageLimitBreachAction {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UsageLimitPeriod {
    #[allow(missing_docs)] // documentation missing in model
    Daily,
    #[allow(missing_docs)] // documentation missing in model
    Monthly,
    #[allow(missing_docs)] // documentation missing in model
    Weekly,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for UsageLimitPeriod {
    fn from(s: &str) -> Self {
        match s {
            "daily" => UsageLimitPeriod::Daily,
            "monthly" => UsageLimitPeriod::Monthly,
            "weekly" => UsageLimitPeriod::Weekly,
            other => UsageLimitPeriod::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for UsageLimitPeriod {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UsageLimitPeriod::from(s))
    }
}
impl UsageLimitPeriod {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UsageLimitPeriod::Daily => "daily",
            UsageLimitPeriod::Monthly => "monthly",
            UsageLimitPeriod::Weekly => "weekly",
            UsageLimitPeriod::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["daily", "monthly", "weekly"]
    }
}
impl AsRef<str> for UsageLimitPeriod {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UsageLimitUsageType {
    #[allow(missing_docs)] // documentation missing in model
    CrossRegionDatasharing,
    #[allow(missing_docs)] // documentation missing in model
    ServerlessCompute,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for UsageLimitUsageType {
    fn from(s: &str) -> Self {
        match s {
            "cross-region-datasharing" => UsageLimitUsageType::CrossRegionDatasharing,
            "serverless-compute" => UsageLimitUsageType::ServerlessCompute,
            other => UsageLimitUsageType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for UsageLimitUsageType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UsageLimitUsageType::from(s))
    }
}
impl UsageLimitUsageType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UsageLimitUsageType::CrossRegionDatasharing => "cross-region-datasharing",
            UsageLimitUsageType::ServerlessCompute => "serverless-compute",
            UsageLimitUsageType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["cross-region-datasharing", "serverless-compute"]
    }
}
impl AsRef<str> for UsageLimitUsageType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A snapshot object that contains databases.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Snapshot {
    /// <p>The name of the namepsace.</p>
    pub namespace_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the namespace the snapshot was created from.</p>
    pub namespace_arn: std::option::Option<std::string::String>,
    /// <p>The name of the snapshot.</p>
    pub snapshot_name: std::option::Option<std::string::String>,
    /// <p>The timestamp of when the snapshot was created.</p>
    pub snapshot_create_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The username of the database within a snapshot.</p>
    pub admin_username: std::option::Option<std::string::String>,
    /// <p>The status of the snapshot.</p>
    pub status: std::option::Option<crate::model::SnapshotStatus>,
    /// <p>The unique identifier of the KMS key used to encrypt the snapshot.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>The owner Amazon Web Services; account of the snapshot.</p>
    pub owner_account: std::option::Option<std::string::String>,
    /// <p>The total size, in megabytes, of how big the snapshot is.</p>
    pub total_backup_size_in_mega_bytes: std::option::Option<f64>,
    /// <p>The size of the incremental backup in megabytes.</p>
    pub actual_incremental_backup_size_in_mega_bytes: std::option::Option<f64>,
    /// <p>The size in megabytes of the data that has been backed up to a snapshot.</p>
    pub backup_progress_in_mega_bytes: std::option::Option<f64>,
    /// <p>The rate at which data is backed up into a snapshot in megabytes per second.</p>
    pub current_backup_rate_in_mega_bytes_per_second: std::option::Option<f64>,
    /// <p>The estimated amount of seconds until the snapshot completes backup.</p>
    pub estimated_seconds_to_completion: std::option::Option<i64>,
    /// <p>The amount of time it took to back up data into a snapshot.</p>
    pub elapsed_time_in_seconds: std::option::Option<i64>,
    /// <p>The period of time, in days, of how long the snapshot is retained.</p>
    pub snapshot_retention_period: std::option::Option<i32>,
    /// <p>The amount of days until the snapshot is deleted.</p>
    pub snapshot_remaining_days: std::option::Option<i32>,
    /// <p>The timestamp of when data within the snapshot started getting retained.</p>
    pub snapshot_retention_start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The Amazon Resource Name (ARN) of the snapshot.</p>
    pub snapshot_arn: std::option::Option<std::string::String>,
    /// <p>All of the Amazon Web Services accounts that have access to restore a snapshot to a namespace.</p>
    pub accounts_with_restore_access: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>All of the Amazon Web Services accounts that have access to restore a snapshot to a provisioned cluster.</p>
    pub accounts_with_provisioned_restore_access:
        std::option::Option<std::vec::Vec<std::string::String>>,
}
impl Snapshot {
    /// <p>The name of the namepsace.</p>
    pub fn namespace_name(&self) -> std::option::Option<&str> {
        self.namespace_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the namespace the snapshot was created from.</p>
    pub fn namespace_arn(&self) -> std::option::Option<&str> {
        self.namespace_arn.as_deref()
    }
    /// <p>The name of the snapshot.</p>
    pub fn snapshot_name(&self) -> std::option::Option<&str> {
        self.snapshot_name.as_deref()
    }
    /// <p>The timestamp of when the snapshot was created.</p>
    pub fn snapshot_create_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.snapshot_create_time.as_ref()
    }
    /// <p>The username of the database within a snapshot.</p>
    pub fn admin_username(&self) -> std::option::Option<&str> {
        self.admin_username.as_deref()
    }
    /// <p>The status of the snapshot.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::SnapshotStatus> {
        self.status.as_ref()
    }
    /// <p>The unique identifier of the KMS key used to encrypt the snapshot.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
    /// <p>The owner Amazon Web Services; account of the snapshot.</p>
    pub fn owner_account(&self) -> std::option::Option<&str> {
        self.owner_account.as_deref()
    }
    /// <p>The total size, in megabytes, of how big the snapshot is.</p>
    pub fn total_backup_size_in_mega_bytes(&self) -> std::option::Option<f64> {
        self.total_backup_size_in_mega_bytes
    }
    /// <p>The size of the incremental backup in megabytes.</p>
    pub fn actual_incremental_backup_size_in_mega_bytes(&self) -> std::option::Option<f64> {
        self.actual_incremental_backup_size_in_mega_bytes
    }
    /// <p>The size in megabytes of the data that has been backed up to a snapshot.</p>
    pub fn backup_progress_in_mega_bytes(&self) -> std::option::Option<f64> {
        self.backup_progress_in_mega_bytes
    }
    /// <p>The rate at which data is backed up into a snapshot in megabytes per second.</p>
    pub fn current_backup_rate_in_mega_bytes_per_second(&self) -> std::option::Option<f64> {
        self.current_backup_rate_in_mega_bytes_per_second
    }
    /// <p>The estimated amount of seconds until the snapshot completes backup.</p>
    pub fn estimated_seconds_to_completion(&self) -> std::option::Option<i64> {
        self.estimated_seconds_to_completion
    }
    /// <p>The amount of time it took to back up data into a snapshot.</p>
    pub fn elapsed_time_in_seconds(&self) -> std::option::Option<i64> {
        self.elapsed_time_in_seconds
    }
    /// <p>The period of time, in days, of how long the snapshot is retained.</p>
    pub fn snapshot_retention_period(&self) -> std::option::Option<i32> {
        self.snapshot_retention_period
    }
    /// <p>The amount of days until the snapshot is deleted.</p>
    pub fn snapshot_remaining_days(&self) -> std::option::Option<i32> {
        self.snapshot_remaining_days
    }
    /// <p>The timestamp of when data within the snapshot started getting retained.</p>
    pub fn snapshot_retention_start_time(
        &self,
    ) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.snapshot_retention_start_time.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the snapshot.</p>
    pub fn snapshot_arn(&self) -> std::option::Option<&str> {
        self.snapshot_arn.as_deref()
    }
    /// <p>All of the Amazon Web Services accounts that have access to restore a snapshot to a namespace.</p>
    pub fn accounts_with_restore_access(&self) -> std::option::Option<&[std::string::String]> {
        self.accounts_with_restore_access.as_deref()
    }
    /// <p>All of the Amazon Web Services accounts that have access to restore a snapshot to a provisioned cluster.</p>
    pub fn accounts_with_provisioned_restore_access(
        &self,
    ) -> std::option::Option<&[std::string::String]> {
        self.accounts_with_provisioned_restore_access.as_deref()
    }
}
impl std::fmt::Debug for Snapshot {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Snapshot");
        formatter.field("namespace_name", &self.namespace_name);
        formatter.field("namespace_arn", &self.namespace_arn);
        formatter.field("snapshot_name", &self.snapshot_name);
        formatter.field("snapshot_create_time", &self.snapshot_create_time);
        formatter.field("admin_username", &self.admin_username);
        formatter.field("status", &self.status);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("owner_account", &self.owner_account);
        formatter.field(
            "total_backup_size_in_mega_bytes",
            &self.total_backup_size_in_mega_bytes,
        );
        formatter.field(
            "actual_incremental_backup_size_in_mega_bytes",
            &self.actual_incremental_backup_size_in_mega_bytes,
        );
        formatter.field(
            "backup_progress_in_mega_bytes",
            &self.backup_progress_in_mega_bytes,
        );
        formatter.field(
            "current_backup_rate_in_mega_bytes_per_second",
            &self.current_backup_rate_in_mega_bytes_per_second,
        );
        formatter.field(
            "estimated_seconds_to_completion",
            &self.estimated_seconds_to_completion,
        );
        formatter.field("elapsed_time_in_seconds", &self.elapsed_time_in_seconds);
        formatter.field("snapshot_retention_period", &self.snapshot_retention_period);
        formatter.field("snapshot_remaining_days", &self.snapshot_remaining_days);
        formatter.field(
            "snapshot_retention_start_time",
            &self.snapshot_retention_start_time,
        );
        formatter.field("snapshot_arn", &self.snapshot_arn);
        formatter.field(
            "accounts_with_restore_access",
            &self.accounts_with_restore_access,
        );
        formatter.field(
            "accounts_with_provisioned_restore_access",
            &self.accounts_with_provisioned_restore_access,
        );
        formatter.finish()
    }
}
/// See [`Snapshot`](crate::model::Snapshot)
pub mod snapshot {

    /// A builder for [`Snapshot`](crate::model::Snapshot)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) namespace_name: std::option::Option<std::string::String>,
        pub(crate) namespace_arn: std::option::Option<std::string::String>,
        pub(crate) snapshot_name: std::option::Option<std::string::String>,
        pub(crate) snapshot_create_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) admin_username: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::SnapshotStatus>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) owner_account: std::option::Option<std::string::String>,
        pub(crate) total_backup_size_in_mega_bytes: std::option::Option<f64>,
        pub(crate) actual_incremental_backup_size_in_mega_bytes: std::option::Option<f64>,
        pub(crate) backup_progress_in_mega_bytes: std::option::Option<f64>,
        pub(crate) current_backup_rate_in_mega_bytes_per_second: std::option::Option<f64>,
        pub(crate) estimated_seconds_to_completion: std::option::Option<i64>,
        pub(crate) elapsed_time_in_seconds: std::option::Option<i64>,
        pub(crate) snapshot_retention_period: std::option::Option<i32>,
        pub(crate) snapshot_remaining_days: std::option::Option<i32>,
        pub(crate) snapshot_retention_start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) snapshot_arn: std::option::Option<std::string::String>,
        pub(crate) accounts_with_restore_access:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) accounts_with_provisioned_restore_access:
            std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the namepsace.</p>
        pub fn namespace_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace_name = Some(input.into());
            self
        }
        /// <p>The name of the namepsace.</p>
        pub fn set_namespace_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.namespace_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the namespace the snapshot was created from.</p>
        pub fn namespace_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the namespace the snapshot was created from.</p>
        pub fn set_namespace_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.namespace_arn = input;
            self
        }
        /// <p>The name of the snapshot.</p>
        pub fn snapshot_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_name = Some(input.into());
            self
        }
        /// <p>The name of the snapshot.</p>
        pub fn set_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.snapshot_name = input;
            self
        }
        /// <p>The timestamp of when the snapshot was created.</p>
        pub fn snapshot_create_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.snapshot_create_time = Some(input);
            self
        }
        /// <p>The timestamp of when the snapshot was created.</p>
        pub fn set_snapshot_create_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.snapshot_create_time = input;
            self
        }
        /// <p>The username of the database within a snapshot.</p>
        pub fn admin_username(mut self, input: impl Into<std::string::String>) -> Self {
            self.admin_username = Some(input.into());
            self
        }
        /// <p>The username of the database within a snapshot.</p>
        pub fn set_admin_username(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.admin_username = input;
            self
        }
        /// <p>The status of the snapshot.</p>
        pub fn status(mut self, input: crate::model::SnapshotStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the snapshot.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::SnapshotStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The unique identifier of the KMS key used to encrypt the snapshot.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the KMS key used to encrypt the snapshot.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>The owner Amazon Web Services; account of the snapshot.</p>
        pub fn owner_account(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_account = Some(input.into());
            self
        }
        /// <p>The owner Amazon Web Services; account of the snapshot.</p>
        pub fn set_owner_account(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.owner_account = input;
            self
        }
        /// <p>The total size, in megabytes, of how big the snapshot is.</p>
        pub fn total_backup_size_in_mega_bytes(mut self, input: f64) -> Self {
            self.total_backup_size_in_mega_bytes = Some(input);
            self
        }
        /// <p>The total size, in megabytes, of how big the snapshot is.</p>
        pub fn set_total_backup_size_in_mega_bytes(
            mut self,
            input: std::option::Option<f64>,
        ) -> Self {
            self.total_backup_size_in_mega_bytes = input;
            self
        }
        /// <p>The size of the incremental backup in megabytes.</p>
        pub fn actual_incremental_backup_size_in_mega_bytes(mut self, input: f64) -> Self {
            self.actual_incremental_backup_size_in_mega_bytes = Some(input);
            self
        }
        /// <p>The size of the incremental backup in megabytes.</p>
        pub fn set_actual_incremental_backup_size_in_mega_bytes(
            mut self,
            input: std::option::Option<f64>,
        ) -> Self {
            self.actual_incremental_backup_size_in_mega_bytes = input;
            self
        }
        /// <p>The size in megabytes of the data that has been backed up to a snapshot.</p>
        pub fn backup_progress_in_mega_bytes(mut self, input: f64) -> Self {
            self.backup_progress_in_mega_bytes = Some(input);
            self
        }
        /// <p>The size in megabytes of the data that has been backed up to a snapshot.</p>
        pub fn set_backup_progress_in_mega_bytes(
            mut self,
            input: std::option::Option<f64>,
        ) -> Self {
            self.backup_progress_in_mega_bytes = input;
            self
        }
        /// <p>The rate at which data is backed up into a snapshot in megabytes per second.</p>
        pub fn current_backup_rate_in_mega_bytes_per_second(mut self, input: f64) -> Self {
            self.current_backup_rate_in_mega_bytes_per_second = Some(input);
            self
        }
        /// <p>The rate at which data is backed up into a snapshot in megabytes per second.</p>
        pub fn set_current_backup_rate_in_mega_bytes_per_second(
            mut self,
            input: std::option::Option<f64>,
        ) -> Self {
            self.current_backup_rate_in_mega_bytes_per_second = input;
            self
        }
        /// <p>The estimated amount of seconds until the snapshot completes backup.</p>
        pub fn estimated_seconds_to_completion(mut self, input: i64) -> Self {
            self.estimated_seconds_to_completion = Some(input);
            self
        }
        /// <p>The estimated amount of seconds until the snapshot completes backup.</p>
        pub fn set_estimated_seconds_to_completion(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.estimated_seconds_to_completion = input;
            self
        }
        /// <p>The amount of time it took to back up data into a snapshot.</p>
        pub fn elapsed_time_in_seconds(mut self, input: i64) -> Self {
            self.elapsed_time_in_seconds = Some(input);
            self
        }
        /// <p>The amount of time it took to back up data into a snapshot.</p>
        pub fn set_elapsed_time_in_seconds(mut self, input: std::option::Option<i64>) -> Self {
            self.elapsed_time_in_seconds = input;
            self
        }
        /// <p>The period of time, in days, of how long the snapshot is retained.</p>
        pub fn snapshot_retention_period(mut self, input: i32) -> Self {
            self.snapshot_retention_period = Some(input);
            self
        }
        /// <p>The period of time, in days, of how long the snapshot is retained.</p>
        pub fn set_snapshot_retention_period(mut self, input: std::option::Option<i32>) -> Self {
            self.snapshot_retention_period = input;
            self
        }
        /// <p>The amount of days until the snapshot is deleted.</p>
        pub fn snapshot_remaining_days(mut self, input: i32) -> Self {
            self.snapshot_remaining_days = Some(input);
            self
        }
        /// <p>The amount of days until the snapshot is deleted.</p>
        pub fn set_snapshot_remaining_days(mut self, input: std::option::Option<i32>) -> Self {
            self.snapshot_remaining_days = input;
            self
        }
        /// <p>The timestamp of when data within the snapshot started getting retained.</p>
        pub fn snapshot_retention_start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.snapshot_retention_start_time = Some(input);
            self
        }
        /// <p>The timestamp of when data within the snapshot started getting retained.</p>
        pub fn set_snapshot_retention_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.snapshot_retention_start_time = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the snapshot.</p>
        pub fn snapshot_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the snapshot.</p>
        pub fn set_snapshot_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.snapshot_arn = input;
            self
        }
        /// Appends an item to `accounts_with_restore_access`.
        ///
        /// To override the contents of this collection use [`set_accounts_with_restore_access`](Self::set_accounts_with_restore_access).
        ///
        /// <p>All of the Amazon Web Services accounts that have access to restore a snapshot to a namespace.</p>
        pub fn accounts_with_restore_access(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.accounts_with_restore_access.unwrap_or_default();
            v.push(input.into());
            self.accounts_with_restore_access = Some(v);
            self
        }
        /// <p>All of the Amazon Web Services accounts that have access to restore a snapshot to a namespace.</p>
        pub fn set_accounts_with_restore_access(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.accounts_with_restore_access = input;
            self
        }
        /// Appends an item to `accounts_with_provisioned_restore_access`.
        ///
        /// To override the contents of this collection use [`set_accounts_with_provisioned_restore_access`](Self::set_accounts_with_provisioned_restore_access).
        ///
        /// <p>All of the Amazon Web Services accounts that have access to restore a snapshot to a provisioned cluster.</p>
        pub fn accounts_with_provisioned_restore_access(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self
                .accounts_with_provisioned_restore_access
                .unwrap_or_default();
            v.push(input.into());
            self.accounts_with_provisioned_restore_access = Some(v);
            self
        }
        /// <p>All of the Amazon Web Services accounts that have access to restore a snapshot to a provisioned cluster.</p>
        pub fn set_accounts_with_provisioned_restore_access(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.accounts_with_provisioned_restore_access = input;
            self
        }
        /// Consumes the builder and constructs a [`Snapshot`](crate::model::Snapshot)
        pub fn build(self) -> crate::model::Snapshot {
            crate::model::Snapshot {
                namespace_name: self.namespace_name,
                namespace_arn: self.namespace_arn,
                snapshot_name: self.snapshot_name,
                snapshot_create_time: self.snapshot_create_time,
                admin_username: self.admin_username,
                status: self.status,
                kms_key_id: self.kms_key_id,
                owner_account: self.owner_account,
                total_backup_size_in_mega_bytes: self.total_backup_size_in_mega_bytes,
                actual_incremental_backup_size_in_mega_bytes: self
                    .actual_incremental_backup_size_in_mega_bytes,
                backup_progress_in_mega_bytes: self.backup_progress_in_mega_bytes,
                current_backup_rate_in_mega_bytes_per_second: self
                    .current_backup_rate_in_mega_bytes_per_second,
                estimated_seconds_to_completion: self.estimated_seconds_to_completion,
                elapsed_time_in_seconds: self.elapsed_time_in_seconds,
                snapshot_retention_period: self.snapshot_retention_period,
                snapshot_remaining_days: self.snapshot_remaining_days,
                snapshot_retention_start_time: self.snapshot_retention_start_time,
                snapshot_arn: self.snapshot_arn,
                accounts_with_restore_access: self.accounts_with_restore_access,
                accounts_with_provisioned_restore_access: self
                    .accounts_with_provisioned_restore_access,
            }
        }
    }
}
impl Snapshot {
    /// Creates a new builder-style object to manufacture [`Snapshot`](crate::model::Snapshot)
    pub fn builder() -> crate::model::snapshot::Builder {
        crate::model::snapshot::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SnapshotStatus {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Cancelled,
    #[allow(missing_docs)] // documentation missing in model
    Copying,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SnapshotStatus {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => SnapshotStatus::Available,
            "CANCELLED" => SnapshotStatus::Cancelled,
            "COPYING" => SnapshotStatus::Copying,
            "CREATING" => SnapshotStatus::Creating,
            "DELETED" => SnapshotStatus::Deleted,
            "FAILED" => SnapshotStatus::Failed,
            other => SnapshotStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SnapshotStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SnapshotStatus::from(s))
    }
}
impl SnapshotStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SnapshotStatus::Available => "AVAILABLE",
            SnapshotStatus::Cancelled => "CANCELLED",
            SnapshotStatus::Copying => "COPYING",
            SnapshotStatus::Creating => "CREATING",
            SnapshotStatus::Deleted => "DELETED",
            SnapshotStatus::Failed => "FAILED",
            SnapshotStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "AVAILABLE",
            "CANCELLED",
            "COPYING",
            "CREATING",
            "DELETED",
            "FAILED",
        ]
    }
}
impl AsRef<str> for SnapshotStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A collection of database objects and users.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Namespace {
    /// <p>The Amazon Resource Name (ARN) associated with a namespace.</p>
    pub namespace_arn: std::option::Option<std::string::String>,
    /// <p>The unique identifier of a namespace.</p>
    pub namespace_id: std::option::Option<std::string::String>,
    /// <p>The name of the namespace. Must be between 3-64 alphanumeric characters in lowercase, and it cannot be a reserved word. A list of reserved words can be found in <a href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p>
    pub namespace_name: std::option::Option<std::string::String>,
    /// <p>The username of the administrator for the first database created in the namespace.</p>
    pub admin_username: std::option::Option<std::string::String>,
    /// <p>The name of the first database created in the namespace.</p>
    pub db_name: std::option::Option<std::string::String>,
    /// <p>The ID of the Amazon Web Services Key Management Service key used to encrypt your data.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the IAM role to set as a default in the namespace.</p>
    pub default_iam_role_arn: std::option::Option<std::string::String>,
    /// <p>A list of IAM roles to associate with the namespace.</p>
    pub iam_roles: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The types of logs the namespace can export. Available export types are User log, Connection log, and User activity log.</p>
    pub log_exports: std::option::Option<std::vec::Vec<crate::model::LogExport>>,
    /// <p>The status of the namespace.</p>
    pub status: std::option::Option<crate::model::NamespaceStatus>,
    /// <p>The date of when the namespace was created.</p>
    pub creation_date: std::option::Option<aws_smithy_types::DateTime>,
}
impl Namespace {
    /// <p>The Amazon Resource Name (ARN) associated with a namespace.</p>
    pub fn namespace_arn(&self) -> std::option::Option<&str> {
        self.namespace_arn.as_deref()
    }
    /// <p>The unique identifier of a namespace.</p>
    pub fn namespace_id(&self) -> std::option::Option<&str> {
        self.namespace_id.as_deref()
    }
    /// <p>The name of the namespace. Must be between 3-64 alphanumeric characters in lowercase, and it cannot be a reserved word. A list of reserved words can be found in <a href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p>
    pub fn namespace_name(&self) -> std::option::Option<&str> {
        self.namespace_name.as_deref()
    }
    /// <p>The username of the administrator for the first database created in the namespace.</p>
    pub fn admin_username(&self) -> std::option::Option<&str> {
        self.admin_username.as_deref()
    }
    /// <p>The name of the first database created in the namespace.</p>
    pub fn db_name(&self) -> std::option::Option<&str> {
        self.db_name.as_deref()
    }
    /// <p>The ID of the Amazon Web Services Key Management Service key used to encrypt your data.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the IAM role to set as a default in the namespace.</p>
    pub fn default_iam_role_arn(&self) -> std::option::Option<&str> {
        self.default_iam_role_arn.as_deref()
    }
    /// <p>A list of IAM roles to associate with the namespace.</p>
    pub fn iam_roles(&self) -> std::option::Option<&[std::string::String]> {
        self.iam_roles.as_deref()
    }
    /// <p>The types of logs the namespace can export. Available export types are User log, Connection log, and User activity log.</p>
    pub fn log_exports(&self) -> std::option::Option<&[crate::model::LogExport]> {
        self.log_exports.as_deref()
    }
    /// <p>The status of the namespace.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::NamespaceStatus> {
        self.status.as_ref()
    }
    /// <p>The date of when the namespace was created.</p>
    pub fn creation_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_date.as_ref()
    }
}
impl std::fmt::Debug for Namespace {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Namespace");
        formatter.field("namespace_arn", &self.namespace_arn);
        formatter.field("namespace_id", &self.namespace_id);
        formatter.field("namespace_name", &self.namespace_name);
        formatter.field("admin_username", &"*** Sensitive Data Redacted ***");
        formatter.field("db_name", &self.db_name);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("default_iam_role_arn", &self.default_iam_role_arn);
        formatter.field("iam_roles", &self.iam_roles);
        formatter.field("log_exports", &self.log_exports);
        formatter.field("status", &self.status);
        formatter.field("creation_date", &self.creation_date);
        formatter.finish()
    }
}
/// See [`Namespace`](crate::model::Namespace)
pub mod namespace {

    /// A builder for [`Namespace`](crate::model::Namespace)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) namespace_arn: std::option::Option<std::string::String>,
        pub(crate) namespace_id: std::option::Option<std::string::String>,
        pub(crate) namespace_name: std::option::Option<std::string::String>,
        pub(crate) admin_username: std::option::Option<std::string::String>,
        pub(crate) db_name: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) default_iam_role_arn: std::option::Option<std::string::String>,
        pub(crate) iam_roles: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) log_exports: std::option::Option<std::vec::Vec<crate::model::LogExport>>,
        pub(crate) status: std::option::Option<crate::model::NamespaceStatus>,
        pub(crate) creation_date: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) associated with a namespace.</p>
        pub fn namespace_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) associated with a namespace.</p>
        pub fn set_namespace_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.namespace_arn = input;
            self
        }
        /// <p>The unique identifier of a namespace.</p>
        pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of a namespace.</p>
        pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace_id = input;
            self
        }
        /// <p>The name of the namespace. Must be between 3-64 alphanumeric characters in lowercase, and it cannot be a reserved word. A list of reserved words can be found in <a href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p>
        pub fn namespace_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace_name = Some(input.into());
            self
        }
        /// <p>The name of the namespace. Must be between 3-64 alphanumeric characters in lowercase, and it cannot be a reserved word. A list of reserved words can be found in <a href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p>
        pub fn set_namespace_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.namespace_name = input;
            self
        }
        /// <p>The username of the administrator for the first database created in the namespace.</p>
        pub fn admin_username(mut self, input: impl Into<std::string::String>) -> Self {
            self.admin_username = Some(input.into());
            self
        }
        /// <p>The username of the administrator for the first database created in the namespace.</p>
        pub fn set_admin_username(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.admin_username = input;
            self
        }
        /// <p>The name of the first database created in the namespace.</p>
        pub fn db_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.db_name = Some(input.into());
            self
        }
        /// <p>The name of the first database created in the namespace.</p>
        pub fn set_db_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.db_name = input;
            self
        }
        /// <p>The ID of the Amazon Web Services Key Management Service key used to encrypt your data.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The ID of the Amazon Web Services Key Management Service key used to encrypt your data.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM role to set as a default in the namespace.</p>
        pub fn default_iam_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_iam_role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM role to set as a default in the namespace.</p>
        pub fn set_default_iam_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_iam_role_arn = input;
            self
        }
        /// Appends an item to `iam_roles`.
        ///
        /// To override the contents of this collection use [`set_iam_roles`](Self::set_iam_roles).
        ///
        /// <p>A list of IAM roles to associate with the namespace.</p>
        pub fn iam_roles(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.iam_roles.unwrap_or_default();
            v.push(input.into());
            self.iam_roles = Some(v);
            self
        }
        /// <p>A list of IAM roles to associate with the namespace.</p>
        pub fn set_iam_roles(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.iam_roles = input;
            self
        }
        /// Appends an item to `log_exports`.
        ///
        /// To override the contents of this collection use [`set_log_exports`](Self::set_log_exports).
        ///
        /// <p>The types of logs the namespace can export. Available export types are User log, Connection log, and User activity log.</p>
        pub fn log_exports(mut self, input: crate::model::LogExport) -> Self {
            let mut v = self.log_exports.unwrap_or_default();
            v.push(input);
            self.log_exports = Some(v);
            self
        }
        /// <p>The types of logs the namespace can export. Available export types are User log, Connection log, and User activity log.</p>
        pub fn set_log_exports(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LogExport>>,
        ) -> Self {
            self.log_exports = input;
            self
        }
        /// <p>The status of the namespace.</p>
        pub fn status(mut self, input: crate::model::NamespaceStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the namespace.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::NamespaceStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The date of when the namespace was created.</p>
        pub fn creation_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_date = Some(input);
            self
        }
        /// <p>The date of when the namespace was created.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// Consumes the builder and constructs a [`Namespace`](crate::model::Namespace)
        pub fn build(self) -> crate::model::Namespace {
            crate::model::Namespace {
                namespace_arn: self.namespace_arn,
                namespace_id: self.namespace_id,
                namespace_name: self.namespace_name,
                admin_username: self.admin_username,
                db_name: self.db_name,
                kms_key_id: self.kms_key_id,
                default_iam_role_arn: self.default_iam_role_arn,
                iam_roles: self.iam_roles,
                log_exports: self.log_exports,
                status: self.status,
                creation_date: self.creation_date,
            }
        }
    }
}
impl Namespace {
    /// Creates a new builder-style object to manufacture [`Namespace`](crate::model::Namespace)
    pub fn builder() -> crate::model::namespace::Builder {
        crate::model::namespace::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NamespaceStatus {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Modifying,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for NamespaceStatus {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => NamespaceStatus::Available,
            "DELETING" => NamespaceStatus::Deleting,
            "MODIFYING" => NamespaceStatus::Modifying,
            other => NamespaceStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for NamespaceStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NamespaceStatus::from(s))
    }
}
impl NamespaceStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NamespaceStatus::Available => "AVAILABLE",
            NamespaceStatus::Deleting => "DELETING",
            NamespaceStatus::Modifying => "MODIFYING",
            NamespaceStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["AVAILABLE", "DELETING", "MODIFYING"]
    }
}
impl AsRef<str> for NamespaceStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LogExport {
    #[allow(missing_docs)] // documentation missing in model
    ConnectionLog,
    #[allow(missing_docs)] // documentation missing in model
    UserActivityLog,
    #[allow(missing_docs)] // documentation missing in model
    UserLog,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LogExport {
    fn from(s: &str) -> Self {
        match s {
            "connectionlog" => LogExport::ConnectionLog,
            "useractivitylog" => LogExport::UserActivityLog,
            "userlog" => LogExport::UserLog,
            other => LogExport::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LogExport {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LogExport::from(s))
    }
}
impl LogExport {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LogExport::ConnectionLog => "connectionlog",
            LogExport::UserActivityLog => "useractivitylog",
            LogExport::UserLog => "userlog",
            LogExport::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["connectionlog", "useractivitylog", "userlog"]
    }
}
impl AsRef<str> for LogExport {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The automatically created recovery point of a namespace. Recovery points are created every 30 minutes and kept for 24 hours.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RecoveryPoint {
    /// <p>The unique identifier of the recovery point.</p>
    pub recovery_point_id: std::option::Option<std::string::String>,
    /// <p>The time the recovery point is created.</p>
    pub recovery_point_create_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The total size of the data in the recovery point in megabytes.</p>
    pub total_size_in_mega_bytes: std::option::Option<f64>,
    /// <p>The name of the namespace the recovery point is associated with.</p>
    pub namespace_name: std::option::Option<std::string::String>,
    /// <p>The name of the workgroup the recovery point is associated with.</p>
    pub workgroup_name: std::option::Option<std::string::String>,
}
impl RecoveryPoint {
    /// <p>The unique identifier of the recovery point.</p>
    pub fn recovery_point_id(&self) -> std::option::Option<&str> {
        self.recovery_point_id.as_deref()
    }
    /// <p>The time the recovery point is created.</p>
    pub fn recovery_point_create_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.recovery_point_create_time.as_ref()
    }
    /// <p>The total size of the data in the recovery point in megabytes.</p>
    pub fn total_size_in_mega_bytes(&self) -> std::option::Option<f64> {
        self.total_size_in_mega_bytes
    }
    /// <p>The name of the namespace the recovery point is associated with.</p>
    pub fn namespace_name(&self) -> std::option::Option<&str> {
        self.namespace_name.as_deref()
    }
    /// <p>The name of the workgroup the recovery point is associated with.</p>
    pub fn workgroup_name(&self) -> std::option::Option<&str> {
        self.workgroup_name.as_deref()
    }
}
impl std::fmt::Debug for RecoveryPoint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RecoveryPoint");
        formatter.field("recovery_point_id", &self.recovery_point_id);
        formatter.field(
            "recovery_point_create_time",
            &self.recovery_point_create_time,
        );
        formatter.field("total_size_in_mega_bytes", &self.total_size_in_mega_bytes);
        formatter.field("namespace_name", &self.namespace_name);
        formatter.field("workgroup_name", &self.workgroup_name);
        formatter.finish()
    }
}
/// See [`RecoveryPoint`](crate::model::RecoveryPoint)
pub mod recovery_point {

    /// A builder for [`RecoveryPoint`](crate::model::RecoveryPoint)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) recovery_point_id: std::option::Option<std::string::String>,
        pub(crate) recovery_point_create_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) total_size_in_mega_bytes: std::option::Option<f64>,
        pub(crate) namespace_name: std::option::Option<std::string::String>,
        pub(crate) workgroup_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the recovery point.</p>
        pub fn recovery_point_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.recovery_point_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the recovery point.</p>
        pub fn set_recovery_point_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recovery_point_id = input;
            self
        }
        /// <p>The time the recovery point is created.</p>
        pub fn recovery_point_create_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.recovery_point_create_time = Some(input);
            self
        }
        /// <p>The time the recovery point is created.</p>
        pub fn set_recovery_point_create_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.recovery_point_create_time = input;
            self
        }
        /// <p>The total size of the data in the recovery point in megabytes.</p>
        pub fn total_size_in_mega_bytes(mut self, input: f64) -> Self {
            self.total_size_in_mega_bytes = Some(input);
            self
        }
        /// <p>The total size of the data in the recovery point in megabytes.</p>
        pub fn set_total_size_in_mega_bytes(mut self, input: std::option::Option<f64>) -> Self {
            self.total_size_in_mega_bytes = input;
            self
        }
        /// <p>The name of the namespace the recovery point is associated with.</p>
        pub fn namespace_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace_name = Some(input.into());
            self
        }
        /// <p>The name of the namespace the recovery point is associated with.</p>
        pub fn set_namespace_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.namespace_name = input;
            self
        }
        /// <p>The name of the workgroup the recovery point is associated with.</p>
        pub fn workgroup_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.workgroup_name = Some(input.into());
            self
        }
        /// <p>The name of the workgroup the recovery point is associated with.</p>
        pub fn set_workgroup_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.workgroup_name = input;
            self
        }
        /// Consumes the builder and constructs a [`RecoveryPoint`](crate::model::RecoveryPoint)
        pub fn build(self) -> crate::model::RecoveryPoint {
            crate::model::RecoveryPoint {
                recovery_point_id: self.recovery_point_id,
                recovery_point_create_time: self.recovery_point_create_time,
                total_size_in_mega_bytes: self.total_size_in_mega_bytes,
                namespace_name: self.namespace_name,
                workgroup_name: self.workgroup_name,
            }
        }
    }
}
impl RecoveryPoint {
    /// Creates a new builder-style object to manufacture [`RecoveryPoint`](crate::model::RecoveryPoint)
    pub fn builder() -> crate::model::recovery_point::Builder {
        crate::model::recovery_point::Builder::default()
    }
}

/// <p>Information about an Amazon Redshift Serverless VPC endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EndpointAccess {
    /// <p>The name of the VPC endpoint.</p>
    pub endpoint_name: std::option::Option<std::string::String>,
    /// <p>The status of the VPC endpoint.</p>
    pub endpoint_status: std::option::Option<std::string::String>,
    /// <p>The name of the workgroup associated with the endpoint.</p>
    pub workgroup_name: std::option::Option<std::string::String>,
    /// <p>The time that the endpoint was created.</p>
    pub endpoint_create_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The port number on which Amazon Redshift Serverless accepts incoming connections.</p>
    pub port: std::option::Option<i32>,
    /// <p>The DNS address of the endpoint.</p>
    pub address: std::option::Option<std::string::String>,
    /// <p>The unique identifier of subnets where Amazon Redshift Serverless choose to deploy the VPC endpoint.</p>
    pub subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The security groups associated with the endpoint.</p>
    pub vpc_security_groups:
        std::option::Option<std::vec::Vec<crate::model::VpcSecurityGroupMembership>>,
    /// <p>The connection endpoint for connecting to Amazon Redshift Serverless.</p>
    pub vpc_endpoint: std::option::Option<crate::model::VpcEndpoint>,
    /// <p>The Amazon Resource Name (ARN) of the VPC endpoint.</p>
    pub endpoint_arn: std::option::Option<std::string::String>,
}
impl EndpointAccess {
    /// <p>The name of the VPC endpoint.</p>
    pub fn endpoint_name(&self) -> std::option::Option<&str> {
        self.endpoint_name.as_deref()
    }
    /// <p>The status of the VPC endpoint.</p>
    pub fn endpoint_status(&self) -> std::option::Option<&str> {
        self.endpoint_status.as_deref()
    }
    /// <p>The name of the workgroup associated with the endpoint.</p>
    pub fn workgroup_name(&self) -> std::option::Option<&str> {
        self.workgroup_name.as_deref()
    }
    /// <p>The time that the endpoint was created.</p>
    pub fn endpoint_create_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.endpoint_create_time.as_ref()
    }
    /// <p>The port number on which Amazon Redshift Serverless accepts incoming connections.</p>
    pub fn port(&self) -> std::option::Option<i32> {
        self.port
    }
    /// <p>The DNS address of the endpoint.</p>
    pub fn address(&self) -> std::option::Option<&str> {
        self.address.as_deref()
    }
    /// <p>The unique identifier of subnets where Amazon Redshift Serverless choose to deploy the VPC endpoint.</p>
    pub fn subnet_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.subnet_ids.as_deref()
    }
    /// <p>The security groups associated with the endpoint.</p>
    pub fn vpc_security_groups(
        &self,
    ) -> std::option::Option<&[crate::model::VpcSecurityGroupMembership]> {
        self.vpc_security_groups.as_deref()
    }
    /// <p>The connection endpoint for connecting to Amazon Redshift Serverless.</p>
    pub fn vpc_endpoint(&self) -> std::option::Option<&crate::model::VpcEndpoint> {
        self.vpc_endpoint.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the VPC endpoint.</p>
    pub fn endpoint_arn(&self) -> std::option::Option<&str> {
        self.endpoint_arn.as_deref()
    }
}
impl std::fmt::Debug for EndpointAccess {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EndpointAccess");
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.field("endpoint_status", &self.endpoint_status);
        formatter.field("workgroup_name", &self.workgroup_name);
        formatter.field("endpoint_create_time", &self.endpoint_create_time);
        formatter.field("port", &self.port);
        formatter.field("address", &self.address);
        formatter.field("subnet_ids", &self.subnet_ids);
        formatter.field("vpc_security_groups", &self.vpc_security_groups);
        formatter.field("vpc_endpoint", &self.vpc_endpoint);
        formatter.field("endpoint_arn", &self.endpoint_arn);
        formatter.finish()
    }
}
/// See [`EndpointAccess`](crate::model::EndpointAccess)
pub mod endpoint_access {

    /// A builder for [`EndpointAccess`](crate::model::EndpointAccess)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_name: std::option::Option<std::string::String>,
        pub(crate) endpoint_status: std::option::Option<std::string::String>,
        pub(crate) workgroup_name: std::option::Option<std::string::String>,
        pub(crate) endpoint_create_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) port: std::option::Option<i32>,
        pub(crate) address: std::option::Option<std::string::String>,
        pub(crate) subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) vpc_security_groups:
            std::option::Option<std::vec::Vec<crate::model::VpcSecurityGroupMembership>>,
        pub(crate) vpc_endpoint: std::option::Option<crate::model::VpcEndpoint>,
        pub(crate) endpoint_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the VPC endpoint.</p>
        pub fn endpoint_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_name = Some(input.into());
            self
        }
        /// <p>The name of the VPC endpoint.</p>
        pub fn set_endpoint_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_name = input;
            self
        }
        /// <p>The status of the VPC endpoint.</p>
        pub fn endpoint_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_status = Some(input.into());
            self
        }
        /// <p>The status of the VPC endpoint.</p>
        pub fn set_endpoint_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_status = input;
            self
        }
        /// <p>The name of the workgroup associated with the endpoint.</p>
        pub fn workgroup_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.workgroup_name = Some(input.into());
            self
        }
        /// <p>The name of the workgroup associated with the endpoint.</p>
        pub fn set_workgroup_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.workgroup_name = input;
            self
        }
        /// <p>The time that the endpoint was created.</p>
        pub fn endpoint_create_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.endpoint_create_time = Some(input);
            self
        }
        /// <p>The time that the endpoint was created.</p>
        pub fn set_endpoint_create_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.endpoint_create_time = input;
            self
        }
        /// <p>The port number on which Amazon Redshift Serverless accepts incoming connections.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        /// <p>The port number on which Amazon Redshift Serverless accepts incoming connections.</p>
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        /// <p>The DNS address of the endpoint.</p>
        pub fn address(mut self, input: impl Into<std::string::String>) -> Self {
            self.address = Some(input.into());
            self
        }
        /// <p>The DNS address of the endpoint.</p>
        pub fn set_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.address = input;
            self
        }
        /// Appends an item to `subnet_ids`.
        ///
        /// To override the contents of this collection use [`set_subnet_ids`](Self::set_subnet_ids).
        ///
        /// <p>The unique identifier of subnets where Amazon Redshift Serverless choose to deploy the VPC endpoint.</p>
        pub fn subnet_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnet_ids.unwrap_or_default();
            v.push(input.into());
            self.subnet_ids = Some(v);
            self
        }
        /// <p>The unique identifier of subnets where Amazon Redshift Serverless choose to deploy the VPC endpoint.</p>
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnet_ids = input;
            self
        }
        /// Appends an item to `vpc_security_groups`.
        ///
        /// To override the contents of this collection use [`set_vpc_security_groups`](Self::set_vpc_security_groups).
        ///
        /// <p>The security groups associated with the endpoint.</p>
        pub fn vpc_security_groups(
            mut self,
            input: crate::model::VpcSecurityGroupMembership,
        ) -> Self {
            let mut v = self.vpc_security_groups.unwrap_or_default();
            v.push(input);
            self.vpc_security_groups = Some(v);
            self
        }
        /// <p>The security groups associated with the endpoint.</p>
        pub fn set_vpc_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VpcSecurityGroupMembership>>,
        ) -> Self {
            self.vpc_security_groups = input;
            self
        }
        /// <p>The connection endpoint for connecting to Amazon Redshift Serverless.</p>
        pub fn vpc_endpoint(mut self, input: crate::model::VpcEndpoint) -> Self {
            self.vpc_endpoint = Some(input);
            self
        }
        /// <p>The connection endpoint for connecting to Amazon Redshift Serverless.</p>
        pub fn set_vpc_endpoint(
            mut self,
            input: std::option::Option<crate::model::VpcEndpoint>,
        ) -> Self {
            self.vpc_endpoint = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the VPC endpoint.</p>
        pub fn endpoint_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the VPC endpoint.</p>
        pub fn set_endpoint_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.endpoint_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`EndpointAccess`](crate::model::EndpointAccess)
        pub fn build(self) -> crate::model::EndpointAccess {
            crate::model::EndpointAccess {
                endpoint_name: self.endpoint_name,
                endpoint_status: self.endpoint_status,
                workgroup_name: self.workgroup_name,
                endpoint_create_time: self.endpoint_create_time,
                port: self.port,
                address: self.address,
                subnet_ids: self.subnet_ids,
                vpc_security_groups: self.vpc_security_groups,
                vpc_endpoint: self.vpc_endpoint,
                endpoint_arn: self.endpoint_arn,
            }
        }
    }
}
impl EndpointAccess {
    /// Creates a new builder-style object to manufacture [`EndpointAccess`](crate::model::EndpointAccess)
    pub fn builder() -> crate::model::endpoint_access::Builder {
        crate::model::endpoint_access::Builder::default()
    }
}

/// <p>Describes the members of a VPC security group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VpcSecurityGroupMembership {
    /// <p>The unique identifier of the VPC security group.</p>
    pub vpc_security_group_id: std::option::Option<std::string::String>,
    /// <p>The status of the VPC security group.</p>
    pub status: std::option::Option<std::string::String>,
}
impl VpcSecurityGroupMembership {
    /// <p>The unique identifier of the VPC security group.</p>
    pub fn vpc_security_group_id(&self) -> std::option::Option<&str> {
        self.vpc_security_group_id.as_deref()
    }
    /// <p>The status of the VPC security group.</p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
}
impl std::fmt::Debug for VpcSecurityGroupMembership {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VpcSecurityGroupMembership");
        formatter.field("vpc_security_group_id", &self.vpc_security_group_id);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`VpcSecurityGroupMembership`](crate::model::VpcSecurityGroupMembership)
pub mod vpc_security_group_membership {

    /// A builder for [`VpcSecurityGroupMembership`](crate::model::VpcSecurityGroupMembership)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vpc_security_group_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the VPC security group.</p>
        pub fn vpc_security_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_security_group_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the VPC security group.</p>
        pub fn set_vpc_security_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpc_security_group_id = input;
            self
        }
        /// <p>The status of the VPC security group.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the VPC security group.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcSecurityGroupMembership`](crate::model::VpcSecurityGroupMembership)
        pub fn build(self) -> crate::model::VpcSecurityGroupMembership {
            crate::model::VpcSecurityGroupMembership {
                vpc_security_group_id: self.vpc_security_group_id,
                status: self.status,
            }
        }
    }
}
impl VpcSecurityGroupMembership {
    /// Creates a new builder-style object to manufacture [`VpcSecurityGroupMembership`](crate::model::VpcSecurityGroupMembership)
    pub fn builder() -> crate::model::vpc_security_group_membership::Builder {
        crate::model::vpc_security_group_membership::Builder::default()
    }
}

/// <p>The resource policy object. Currently, you can use policies to share snapshots across Amazon Web Services accounts.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourcePolicy {
    /// <p>The Amazon Resource Name (ARN) of the policy.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The resource policy.</p>
    pub policy: std::option::Option<std::string::String>,
}
impl ResourcePolicy {
    /// <p>The Amazon Resource Name (ARN) of the policy.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The resource policy.</p>
    pub fn policy(&self) -> std::option::Option<&str> {
        self.policy.as_deref()
    }
}
impl std::fmt::Debug for ResourcePolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourcePolicy");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("policy", &self.policy);
        formatter.finish()
    }
}
/// See [`ResourcePolicy`](crate::model::ResourcePolicy)
pub mod resource_policy {

    /// A builder for [`ResourcePolicy`](crate::model::ResourcePolicy)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) policy: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the policy.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the policy.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// <p>The resource policy.</p>
        pub fn policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy = Some(input.into());
            self
        }
        /// <p>The resource policy.</p>
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourcePolicy`](crate::model::ResourcePolicy)
        pub fn build(self) -> crate::model::ResourcePolicy {
            crate::model::ResourcePolicy {
                resource_arn: self.resource_arn,
                policy: self.policy,
            }
        }
    }
}
impl ResourcePolicy {
    /// Creates a new builder-style object to manufacture [`ResourcePolicy`](crate::model::ResourcePolicy)
    pub fn builder() -> crate::model::resource_policy::Builder {
        crate::model::resource_policy::Builder::default()
    }
}
