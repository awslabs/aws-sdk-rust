// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Error type for the `UpdateIdentityProviderSettings` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateIdentityProviderSettingsError {
    /// Kind of error that occurred.
                    pub kind: UpdateIdentityProviderSettingsErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateIdentityProviderSettingsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: UpdateIdentityProviderSettingsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `UpdateIdentityProviderSettings` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateIdentityProviderSettingsErrorKind {
    /// <p>You don't have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>An exception occurred with the service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The request was denied because of request throttling. Retry the request.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>A parameter is not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for UpdateIdentityProviderSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateIdentityProviderSettingsErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateIdentityProviderSettingsErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateIdentityProviderSettingsErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateIdentityProviderSettingsErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateIdentityProviderSettingsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateIdentityProviderSettingsError {
    fn code(&self) -> Option<&str> {
        UpdateIdentityProviderSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateIdentityProviderSettingsError {
    /// Creates a new `UpdateIdentityProviderSettingsError`.
                    pub fn new(kind: UpdateIdentityProviderSettingsErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `UpdateIdentityProviderSettingsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: UpdateIdentityProviderSettingsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `UpdateIdentityProviderSettingsError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: UpdateIdentityProviderSettingsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `UpdateIdentityProviderSettingsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UpdateIdentityProviderSettingsErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `UpdateIdentityProviderSettingsErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, UpdateIdentityProviderSettingsErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `UpdateIdentityProviderSettingsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateIdentityProviderSettingsErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `UpdateIdentityProviderSettingsErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UpdateIdentityProviderSettingsErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UpdateIdentityProviderSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateIdentityProviderSettingsErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            UpdateIdentityProviderSettingsErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            UpdateIdentityProviderSettingsErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            UpdateIdentityProviderSettingsErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            UpdateIdentityProviderSettingsErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// <p>A parameter is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ValidationException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ValidationException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ValidationException")?;
        if let Some(inner_1) = &self.message {
             {
                write!(f, ": {}", inner_1)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ValidationException {}
/// See [`ValidationException`](crate::error::ValidationException).
pub mod validation_exception {
    
    /// A builder for [`ValidationException`](crate::error::ValidationException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`ValidationException`](crate::error::ValidationException).
        pub fn build(self) -> crate::error::ValidationException {
            crate::error::ValidationException {
                message: self.message
                ,
            }
        }
    }
    
    
}
impl ValidationException {
    /// Creates a new builder-style object to manufacture [`ValidationException`](crate::error::ValidationException).
    pub fn builder() -> crate::error::validation_exception::Builder {
        crate::error::validation_exception::Builder::default()
    }
}

/// <p>The request was denied because of request throttling. Retry the request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ThrottlingException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ThrottlingException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ThrottlingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ThrottlingException")?;
        if let Some(inner_2) = &self.message {
             {
                write!(f, ": {}", inner_2)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ThrottlingException {}
/// See [`ThrottlingException`](crate::error::ThrottlingException).
pub mod throttling_exception {
    
    /// A builder for [`ThrottlingException`](crate::error::ThrottlingException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`ThrottlingException`](crate::error::ThrottlingException).
        pub fn build(self) -> crate::error::ThrottlingException {
            crate::error::ThrottlingException {
                message: self.message
                ,
            }
        }
    }
    
    
}
impl ThrottlingException {
    /// Creates a new builder-style object to manufacture [`ThrottlingException`](crate::error::ThrottlingException).
    pub fn builder() -> crate::error::throttling_exception::Builder {
        crate::error::throttling_exception::Builder::default()
    }
}

/// <p>An exception occurred with the service.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InternalServerException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl InternalServerException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for InternalServerException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServerException")?;
        if let Some(inner_3) = &self.message {
             {
                write!(f, ": {}", inner_3)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InternalServerException {}
/// See [`InternalServerException`](crate::error::InternalServerException).
pub mod internal_server_exception {
    
    /// A builder for [`InternalServerException`](crate::error::InternalServerException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`InternalServerException`](crate::error::InternalServerException).
        pub fn build(self) -> crate::error::InternalServerException {
            crate::error::InternalServerException {
                message: self.message
                ,
            }
        }
    }
    
    
}
impl InternalServerException {
    /// Creates a new builder-style object to manufacture [`InternalServerException`](crate::error::InternalServerException).
    pub fn builder() -> crate::error::internal_server_exception::Builder {
        crate::error::internal_server_exception::Builder::default()
    }
}

/// <p>You don't have sufficient access to perform this action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AccessDeniedException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl AccessDeniedException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccessDeniedException")?;
        if let Some(inner_4) = &self.message {
             {
                write!(f, ": {}", inner_4)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for AccessDeniedException {}
/// See [`AccessDeniedException`](crate::error::AccessDeniedException).
pub mod access_denied_exception {
    
    /// A builder for [`AccessDeniedException`](crate::error::AccessDeniedException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`AccessDeniedException`](crate::error::AccessDeniedException).
        pub fn build(self) -> crate::error::AccessDeniedException {
            crate::error::AccessDeniedException {
                message: self.message
                ,
            }
        }
    }
    
    
}
impl AccessDeniedException {
    /// Creates a new builder-style object to manufacture [`AccessDeniedException`](crate::error::AccessDeniedException).
    pub fn builder() -> crate::error::access_denied_exception::Builder {
        crate::error::access_denied_exception::Builder::default()
    }
}

/// Error type for the `StopProductSubscription` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopProductSubscriptionError {
    /// Kind of error that occurred.
                    pub kind: StopProductSubscriptionErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for StopProductSubscriptionError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: StopProductSubscriptionErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `StopProductSubscription` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopProductSubscriptionErrorKind {
    /// <p>You don't have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request couldn't be completed because it conflicted with the current state of the resource.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>An exception occurred with the service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The resource couldn't be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The request failed because a service quota is exceeded.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>The request was denied because of request throttling. Retry the request.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>A parameter is not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for StopProductSubscriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopProductSubscriptionErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            StopProductSubscriptionErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            StopProductSubscriptionErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            StopProductSubscriptionErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            StopProductSubscriptionErrorKind::ServiceQuotaExceededException(_inner) =>
            _inner.fmt(f)
            ,
            StopProductSubscriptionErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            StopProductSubscriptionErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            StopProductSubscriptionErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for StopProductSubscriptionError {
    fn code(&self) -> Option<&str> {
        StopProductSubscriptionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopProductSubscriptionError {
    /// Creates a new `StopProductSubscriptionError`.
                    pub fn new(kind: StopProductSubscriptionErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `StopProductSubscriptionError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: StopProductSubscriptionErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `StopProductSubscriptionError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: StopProductSubscriptionErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `StopProductSubscriptionErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, StopProductSubscriptionErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `StopProductSubscriptionErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, StopProductSubscriptionErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `StopProductSubscriptionErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, StopProductSubscriptionErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `StopProductSubscriptionErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, StopProductSubscriptionErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `StopProductSubscriptionErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(&self.kind, StopProductSubscriptionErrorKind::ServiceQuotaExceededException(_))
    }
    /// Returns `true` if the error kind is `StopProductSubscriptionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, StopProductSubscriptionErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `StopProductSubscriptionErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, StopProductSubscriptionErrorKind::ValidationException(_))
    }
}
impl std::error::Error for StopProductSubscriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopProductSubscriptionErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            StopProductSubscriptionErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            StopProductSubscriptionErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            StopProductSubscriptionErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            StopProductSubscriptionErrorKind::ServiceQuotaExceededException(_inner) =>
            Some(_inner)
            ,
            StopProductSubscriptionErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            StopProductSubscriptionErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            StopProductSubscriptionErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// <p>The request failed because a service quota is exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServiceQuotaExceededException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ServiceQuotaExceededException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ServiceQuotaExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceQuotaExceededException")?;
        if let Some(inner_5) = &self.message {
             {
                write!(f, ": {}", inner_5)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ServiceQuotaExceededException {}
/// See [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException).
pub mod service_quota_exceeded_exception {
    
    /// A builder for [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException).
        pub fn build(self) -> crate::error::ServiceQuotaExceededException {
            crate::error::ServiceQuotaExceededException {
                message: self.message
                ,
            }
        }
    }
    
    
}
impl ServiceQuotaExceededException {
    /// Creates a new builder-style object to manufacture [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException).
    pub fn builder() -> crate::error::service_quota_exceeded_exception::Builder {
        crate::error::service_quota_exceeded_exception::Builder::default()
    }
}

/// <p>The resource couldn't be found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceNotFoundException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ResourceNotFoundException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundException")?;
        if let Some(inner_6) = &self.message {
             {
                write!(f, ": {}", inner_6)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundException {}
/// See [`ResourceNotFoundException`](crate::error::ResourceNotFoundException).
pub mod resource_not_found_exception {
    
    /// A builder for [`ResourceNotFoundException`](crate::error::ResourceNotFoundException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException).
        pub fn build(self) -> crate::error::ResourceNotFoundException {
            crate::error::ResourceNotFoundException {
                message: self.message
                ,
            }
        }
    }
    
    
}
impl ResourceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundException`](crate::error::ResourceNotFoundException).
    pub fn builder() -> crate::error::resource_not_found_exception::Builder {
        crate::error::resource_not_found_exception::Builder::default()
    }
}

/// <p>The request couldn't be completed because it conflicted with the current state of the resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConflictException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ConflictException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_7) = &self.message {
             {
                write!(f, ": {}", inner_7)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
/// See [`ConflictException`](crate::error::ConflictException).
pub mod conflict_exception {
    
    /// A builder for [`ConflictException`](crate::error::ConflictException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException).
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                message: self.message
                ,
            }
        }
    }
    
    
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException).
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}

/// Error type for the `StartProductSubscription` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartProductSubscriptionError {
    /// Kind of error that occurred.
                    pub kind: StartProductSubscriptionErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for StartProductSubscriptionError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: StartProductSubscriptionErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `StartProductSubscription` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartProductSubscriptionErrorKind {
    /// <p>You don't have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request couldn't be completed because it conflicted with the current state of the resource.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>An exception occurred with the service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The resource couldn't be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The request failed because a service quota is exceeded.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>The request was denied because of request throttling. Retry the request.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>A parameter is not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for StartProductSubscriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartProductSubscriptionErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            StartProductSubscriptionErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            StartProductSubscriptionErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            StartProductSubscriptionErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            StartProductSubscriptionErrorKind::ServiceQuotaExceededException(_inner) =>
            _inner.fmt(f)
            ,
            StartProductSubscriptionErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            StartProductSubscriptionErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            StartProductSubscriptionErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for StartProductSubscriptionError {
    fn code(&self) -> Option<&str> {
        StartProductSubscriptionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartProductSubscriptionError {
    /// Creates a new `StartProductSubscriptionError`.
                    pub fn new(kind: StartProductSubscriptionErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `StartProductSubscriptionError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: StartProductSubscriptionErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `StartProductSubscriptionError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: StartProductSubscriptionErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `StartProductSubscriptionErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, StartProductSubscriptionErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `StartProductSubscriptionErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, StartProductSubscriptionErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `StartProductSubscriptionErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, StartProductSubscriptionErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `StartProductSubscriptionErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, StartProductSubscriptionErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `StartProductSubscriptionErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(&self.kind, StartProductSubscriptionErrorKind::ServiceQuotaExceededException(_))
    }
    /// Returns `true` if the error kind is `StartProductSubscriptionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, StartProductSubscriptionErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `StartProductSubscriptionErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, StartProductSubscriptionErrorKind::ValidationException(_))
    }
}
impl std::error::Error for StartProductSubscriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartProductSubscriptionErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            StartProductSubscriptionErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            StartProductSubscriptionErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            StartProductSubscriptionErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            StartProductSubscriptionErrorKind::ServiceQuotaExceededException(_inner) =>
            Some(_inner)
            ,
            StartProductSubscriptionErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            StartProductSubscriptionErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            StartProductSubscriptionErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `RegisterIdentityProvider` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RegisterIdentityProviderError {
    /// Kind of error that occurred.
                    pub kind: RegisterIdentityProviderErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for RegisterIdentityProviderError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: RegisterIdentityProviderErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `RegisterIdentityProvider` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterIdentityProviderErrorKind {
    /// <p>You don't have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request couldn't be completed because it conflicted with the current state of the resource.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>An exception occurred with the service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The resource couldn't be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The request failed because a service quota is exceeded.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>The request was denied because of request throttling. Retry the request.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>A parameter is not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for RegisterIdentityProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RegisterIdentityProviderErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            RegisterIdentityProviderErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            RegisterIdentityProviderErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            RegisterIdentityProviderErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            RegisterIdentityProviderErrorKind::ServiceQuotaExceededException(_inner) =>
            _inner.fmt(f)
            ,
            RegisterIdentityProviderErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            RegisterIdentityProviderErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            RegisterIdentityProviderErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RegisterIdentityProviderError {
    fn code(&self) -> Option<&str> {
        RegisterIdentityProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterIdentityProviderError {
    /// Creates a new `RegisterIdentityProviderError`.
                    pub fn new(kind: RegisterIdentityProviderErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `RegisterIdentityProviderError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: RegisterIdentityProviderErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `RegisterIdentityProviderError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: RegisterIdentityProviderErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `RegisterIdentityProviderErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, RegisterIdentityProviderErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `RegisterIdentityProviderErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, RegisterIdentityProviderErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `RegisterIdentityProviderErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, RegisterIdentityProviderErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `RegisterIdentityProviderErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, RegisterIdentityProviderErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `RegisterIdentityProviderErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(&self.kind, RegisterIdentityProviderErrorKind::ServiceQuotaExceededException(_))
    }
    /// Returns `true` if the error kind is `RegisterIdentityProviderErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, RegisterIdentityProviderErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `RegisterIdentityProviderErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, RegisterIdentityProviderErrorKind::ValidationException(_))
    }
}
impl std::error::Error for RegisterIdentityProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RegisterIdentityProviderErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            RegisterIdentityProviderErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            RegisterIdentityProviderErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            RegisterIdentityProviderErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            RegisterIdentityProviderErrorKind::ServiceQuotaExceededException(_inner) =>
            Some(_inner)
            ,
            RegisterIdentityProviderErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            RegisterIdentityProviderErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            RegisterIdentityProviderErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListUserAssociations` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListUserAssociationsError {
    /// Kind of error that occurred.
                    pub kind: ListUserAssociationsErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListUserAssociationsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListUserAssociationsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListUserAssociations` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListUserAssociationsErrorKind {
    /// <p>You don't have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request couldn't be completed because it conflicted with the current state of the resource.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>An exception occurred with the service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The resource couldn't be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The request failed because a service quota is exceeded.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>The request was denied because of request throttling. Retry the request.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>A parameter is not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListUserAssociationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListUserAssociationsErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListUserAssociationsErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            ListUserAssociationsErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            ListUserAssociationsErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            ListUserAssociationsErrorKind::ServiceQuotaExceededException(_inner) =>
            _inner.fmt(f)
            ,
            ListUserAssociationsErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            ListUserAssociationsErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            ListUserAssociationsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListUserAssociationsError {
    fn code(&self) -> Option<&str> {
        ListUserAssociationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListUserAssociationsError {
    /// Creates a new `ListUserAssociationsError`.
                    pub fn new(kind: ListUserAssociationsErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListUserAssociationsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListUserAssociationsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListUserAssociationsError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListUserAssociationsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListUserAssociationsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListUserAssociationsErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListUserAssociationsErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, ListUserAssociationsErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `ListUserAssociationsErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListUserAssociationsErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `ListUserAssociationsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListUserAssociationsErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListUserAssociationsErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(&self.kind, ListUserAssociationsErrorKind::ServiceQuotaExceededException(_))
    }
    /// Returns `true` if the error kind is `ListUserAssociationsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListUserAssociationsErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListUserAssociationsErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListUserAssociationsErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListUserAssociationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListUserAssociationsErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListUserAssociationsErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            ListUserAssociationsErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            ListUserAssociationsErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            ListUserAssociationsErrorKind::ServiceQuotaExceededException(_inner) =>
            Some(_inner)
            ,
            ListUserAssociationsErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            ListUserAssociationsErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            ListUserAssociationsErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListProductSubscriptions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListProductSubscriptionsError {
    /// Kind of error that occurred.
                    pub kind: ListProductSubscriptionsErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListProductSubscriptionsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListProductSubscriptionsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListProductSubscriptions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListProductSubscriptionsErrorKind {
    /// <p>You don't have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request couldn't be completed because it conflicted with the current state of the resource.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>An exception occurred with the service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The resource couldn't be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The request failed because a service quota is exceeded.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>The request was denied because of request throttling. Retry the request.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>A parameter is not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListProductSubscriptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListProductSubscriptionsErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListProductSubscriptionsErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            ListProductSubscriptionsErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            ListProductSubscriptionsErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            ListProductSubscriptionsErrorKind::ServiceQuotaExceededException(_inner) =>
            _inner.fmt(f)
            ,
            ListProductSubscriptionsErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            ListProductSubscriptionsErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            ListProductSubscriptionsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListProductSubscriptionsError {
    fn code(&self) -> Option<&str> {
        ListProductSubscriptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListProductSubscriptionsError {
    /// Creates a new `ListProductSubscriptionsError`.
                    pub fn new(kind: ListProductSubscriptionsErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListProductSubscriptionsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListProductSubscriptionsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListProductSubscriptionsError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListProductSubscriptionsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListProductSubscriptionsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListProductSubscriptionsErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListProductSubscriptionsErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, ListProductSubscriptionsErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `ListProductSubscriptionsErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListProductSubscriptionsErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `ListProductSubscriptionsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListProductSubscriptionsErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListProductSubscriptionsErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(&self.kind, ListProductSubscriptionsErrorKind::ServiceQuotaExceededException(_))
    }
    /// Returns `true` if the error kind is `ListProductSubscriptionsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListProductSubscriptionsErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListProductSubscriptionsErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListProductSubscriptionsErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListProductSubscriptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListProductSubscriptionsErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListProductSubscriptionsErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            ListProductSubscriptionsErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            ListProductSubscriptionsErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            ListProductSubscriptionsErrorKind::ServiceQuotaExceededException(_inner) =>
            Some(_inner)
            ,
            ListProductSubscriptionsErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            ListProductSubscriptionsErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            ListProductSubscriptionsErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListInstances` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListInstancesError {
    /// Kind of error that occurred.
                    pub kind: ListInstancesErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListInstancesError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListInstancesErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListInstances` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListInstancesErrorKind {
    /// <p>You don't have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request couldn't be completed because it conflicted with the current state of the resource.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>An exception occurred with the service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The resource couldn't be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The request failed because a service quota is exceeded.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>The request was denied because of request throttling. Retry the request.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>A parameter is not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListInstancesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListInstancesErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListInstancesErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            ListInstancesErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            ListInstancesErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            ListInstancesErrorKind::ServiceQuotaExceededException(_inner) =>
            _inner.fmt(f)
            ,
            ListInstancesErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            ListInstancesErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            ListInstancesErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListInstancesError {
    fn code(&self) -> Option<&str> {
        ListInstancesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListInstancesError {
    /// Creates a new `ListInstancesError`.
                    pub fn new(kind: ListInstancesErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListInstancesError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListInstancesErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListInstancesError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListInstancesErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListInstancesErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListInstancesErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListInstancesErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, ListInstancesErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `ListInstancesErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListInstancesErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `ListInstancesErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListInstancesErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListInstancesErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(&self.kind, ListInstancesErrorKind::ServiceQuotaExceededException(_))
    }
    /// Returns `true` if the error kind is `ListInstancesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListInstancesErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListInstancesErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListInstancesErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListInstancesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListInstancesErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListInstancesErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            ListInstancesErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            ListInstancesErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            ListInstancesErrorKind::ServiceQuotaExceededException(_inner) =>
            Some(_inner)
            ,
            ListInstancesErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            ListInstancesErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            ListInstancesErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListIdentityProviders` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListIdentityProvidersError {
    /// Kind of error that occurred.
                    pub kind: ListIdentityProvidersErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListIdentityProvidersError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListIdentityProvidersErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListIdentityProviders` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListIdentityProvidersErrorKind {
    /// <p>You don't have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request couldn't be completed because it conflicted with the current state of the resource.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>An exception occurred with the service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The resource couldn't be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The request failed because a service quota is exceeded.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>The request was denied because of request throttling. Retry the request.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>A parameter is not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListIdentityProvidersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListIdentityProvidersErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListIdentityProvidersErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            ListIdentityProvidersErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            ListIdentityProvidersErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            ListIdentityProvidersErrorKind::ServiceQuotaExceededException(_inner) =>
            _inner.fmt(f)
            ,
            ListIdentityProvidersErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            ListIdentityProvidersErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            ListIdentityProvidersErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListIdentityProvidersError {
    fn code(&self) -> Option<&str> {
        ListIdentityProvidersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListIdentityProvidersError {
    /// Creates a new `ListIdentityProvidersError`.
                    pub fn new(kind: ListIdentityProvidersErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListIdentityProvidersError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListIdentityProvidersErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListIdentityProvidersError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListIdentityProvidersErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListIdentityProvidersErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListIdentityProvidersErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListIdentityProvidersErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, ListIdentityProvidersErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `ListIdentityProvidersErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListIdentityProvidersErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `ListIdentityProvidersErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListIdentityProvidersErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListIdentityProvidersErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(&self.kind, ListIdentityProvidersErrorKind::ServiceQuotaExceededException(_))
    }
    /// Returns `true` if the error kind is `ListIdentityProvidersErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListIdentityProvidersErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListIdentityProvidersErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListIdentityProvidersErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListIdentityProvidersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListIdentityProvidersErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListIdentityProvidersErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            ListIdentityProvidersErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            ListIdentityProvidersErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            ListIdentityProvidersErrorKind::ServiceQuotaExceededException(_inner) =>
            Some(_inner)
            ,
            ListIdentityProvidersErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            ListIdentityProvidersErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            ListIdentityProvidersErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `DisassociateUser` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateUserError {
    /// Kind of error that occurred.
                    pub kind: DisassociateUserErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for DisassociateUserError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DisassociateUserErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `DisassociateUser` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateUserErrorKind {
    /// <p>You don't have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request couldn't be completed because it conflicted with the current state of the resource.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>An exception occurred with the service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The resource couldn't be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The request failed because a service quota is exceeded.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>The request was denied because of request throttling. Retry the request.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>A parameter is not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DisassociateUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateUserErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociateUserErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociateUserErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociateUserErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociateUserErrorKind::ServiceQuotaExceededException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociateUserErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociateUserErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociateUserErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DisassociateUserError {
    fn code(&self) -> Option<&str> {
        DisassociateUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateUserError {
    /// Creates a new `DisassociateUserError`.
                    pub fn new(kind: DisassociateUserErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `DisassociateUserError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: DisassociateUserErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `DisassociateUserError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: DisassociateUserErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `DisassociateUserErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DisassociateUserErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DisassociateUserErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DisassociateUserErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `DisassociateUserErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, DisassociateUserErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `DisassociateUserErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, DisassociateUserErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DisassociateUserErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(&self.kind, DisassociateUserErrorKind::ServiceQuotaExceededException(_))
    }
    /// Returns `true` if the error kind is `DisassociateUserErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DisassociateUserErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `DisassociateUserErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DisassociateUserErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DisassociateUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateUserErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            DisassociateUserErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            DisassociateUserErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            DisassociateUserErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            DisassociateUserErrorKind::ServiceQuotaExceededException(_inner) =>
            Some(_inner)
            ,
            DisassociateUserErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            DisassociateUserErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            DisassociateUserErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `DeregisterIdentityProvider` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeregisterIdentityProviderError {
    /// Kind of error that occurred.
                    pub kind: DeregisterIdentityProviderErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for DeregisterIdentityProviderError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeregisterIdentityProviderErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `DeregisterIdentityProvider` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeregisterIdentityProviderErrorKind {
    /// <p>You don't have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request couldn't be completed because it conflicted with the current state of the resource.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>An exception occurred with the service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The resource couldn't be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The request failed because a service quota is exceeded.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>The request was denied because of request throttling. Retry the request.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>A parameter is not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeregisterIdentityProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeregisterIdentityProviderErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            DeregisterIdentityProviderErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            DeregisterIdentityProviderErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            DeregisterIdentityProviderErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DeregisterIdentityProviderErrorKind::ServiceQuotaExceededException(_inner) =>
            _inner.fmt(f)
            ,
            DeregisterIdentityProviderErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            DeregisterIdentityProviderErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            DeregisterIdentityProviderErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeregisterIdentityProviderError {
    fn code(&self) -> Option<&str> {
        DeregisterIdentityProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeregisterIdentityProviderError {
    /// Creates a new `DeregisterIdentityProviderError`.
                    pub fn new(kind: DeregisterIdentityProviderErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `DeregisterIdentityProviderError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: DeregisterIdentityProviderErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `DeregisterIdentityProviderError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: DeregisterIdentityProviderErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `DeregisterIdentityProviderErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DeregisterIdentityProviderErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DeregisterIdentityProviderErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeregisterIdentityProviderErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `DeregisterIdentityProviderErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, DeregisterIdentityProviderErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `DeregisterIdentityProviderErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeregisterIdentityProviderErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DeregisterIdentityProviderErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(&self.kind, DeregisterIdentityProviderErrorKind::ServiceQuotaExceededException(_))
    }
    /// Returns `true` if the error kind is `DeregisterIdentityProviderErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeregisterIdentityProviderErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `DeregisterIdentityProviderErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DeregisterIdentityProviderErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DeregisterIdentityProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeregisterIdentityProviderErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            DeregisterIdentityProviderErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            DeregisterIdentityProviderErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            DeregisterIdentityProviderErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            DeregisterIdentityProviderErrorKind::ServiceQuotaExceededException(_inner) =>
            Some(_inner)
            ,
            DeregisterIdentityProviderErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            DeregisterIdentityProviderErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            DeregisterIdentityProviderErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `AssociateUser` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateUserError {
    /// Kind of error that occurred.
                    pub kind: AssociateUserErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for AssociateUserError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: AssociateUserErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `AssociateUser` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateUserErrorKind {
    /// <p>You don't have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request couldn't be completed because it conflicted with the current state of the resource.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>An exception occurred with the service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The resource couldn't be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The request failed because a service quota is exceeded.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>The request was denied because of request throttling. Retry the request.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>A parameter is not valid.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for AssociateUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateUserErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            AssociateUserErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            AssociateUserErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            AssociateUserErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            AssociateUserErrorKind::ServiceQuotaExceededException(_inner) =>
            _inner.fmt(f)
            ,
            AssociateUserErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            AssociateUserErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            AssociateUserErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AssociateUserError {
    fn code(&self) -> Option<&str> {
        AssociateUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateUserError {
    /// Creates a new `AssociateUserError`.
                    pub fn new(kind: AssociateUserErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `AssociateUserError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: AssociateUserErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `AssociateUserError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: AssociateUserErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `AssociateUserErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, AssociateUserErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `AssociateUserErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, AssociateUserErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `AssociateUserErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, AssociateUserErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `AssociateUserErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, AssociateUserErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `AssociateUserErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(&self.kind, AssociateUserErrorKind::ServiceQuotaExceededException(_))
    }
    /// Returns `true` if the error kind is `AssociateUserErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, AssociateUserErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `AssociateUserErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, AssociateUserErrorKind::ValidationException(_))
    }
}
impl std::error::Error for AssociateUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateUserErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            AssociateUserErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            AssociateUserErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            AssociateUserErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            AssociateUserErrorKind::ServiceQuotaExceededException(_inner) =>
            Some(_inner)
            ,
            AssociateUserErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            AssociateUserErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            AssociateUserErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// 
/// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
/// 
/// When logging an error from the SDK, it is recommended that you either wrap the error in
/// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
/// error reporter library that visits the error's cause/source chain, or call
/// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
/// 
#[derive(Debug)]
        pub struct Unhandled {
            source: Box<dyn std::error::Error + Send + Sync + 'static>,
        }
        impl Unhandled {
            #[allow(unused)]
            pub(crate) fn new(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
                Self { source }
            }
        }
        impl std::fmt::Display for Unhandled {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                write!(f, "unhandled error")
            }
        }
        impl std::error::Error for Unhandled {
            fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                Some(self.source.as_ref() as _)
            }
        }

