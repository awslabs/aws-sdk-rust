// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Error type for the `UpdateIdentityProviderSettings` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateIdentityProviderSettingsError {
    /// Kind of error that occurred.
    pub kind: UpdateIdentityProviderSettingsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateIdentityProviderSettingsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: UpdateIdentityProviderSettingsErrorKind::Unhandled(crate::error::Unhandled::new(
                source,
            )),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `UpdateIdentityProviderSettings` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateIdentityProviderSettingsErrorKind {
    /// <p>You don't have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>An exception occurred with the service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The request was denied because of request throttling. Retry the request.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>A parameter is not valid.</p>
    ValidationException(crate::error::ValidationException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for UpdateIdentityProviderSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateIdentityProviderSettingsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateIdentityProviderSettingsErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            UpdateIdentityProviderSettingsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateIdentityProviderSettingsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateIdentityProviderSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateIdentityProviderSettingsError {
    fn code(&self) -> Option<&str> {
        UpdateIdentityProviderSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateIdentityProviderSettingsError {
    /// Creates a new `UpdateIdentityProviderSettingsError`.
    pub fn new(
        kind: UpdateIdentityProviderSettingsErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateIdentityProviderSettingsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateIdentityProviderSettingsErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateIdentityProviderSettingsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateIdentityProviderSettingsErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateIdentityProviderSettingsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIdentityProviderSettingsErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateIdentityProviderSettingsErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIdentityProviderSettingsErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateIdentityProviderSettingsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIdentityProviderSettingsErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateIdentityProviderSettingsErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIdentityProviderSettingsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for UpdateIdentityProviderSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateIdentityProviderSettingsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateIdentityProviderSettingsErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            UpdateIdentityProviderSettingsErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateIdentityProviderSettingsErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateIdentityProviderSettingsErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>A parameter is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ValidationException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ValidationException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ValidationException")?;
        if let Some(inner_1) = &self.message {
            {
                write!(f, ": {}", inner_1)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ValidationException {}
/// See [`ValidationException`](crate::error::ValidationException).
pub mod validation_exception {

    /// A builder for [`ValidationException`](crate::error::ValidationException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ValidationException`](crate::error::ValidationException).
        pub fn build(self) -> crate::error::ValidationException {
            crate::error::ValidationException {
                message: self.message,
            }
        }
    }
}
impl ValidationException {
    /// Creates a new builder-style object to manufacture [`ValidationException`](crate::error::ValidationException).
    pub fn builder() -> crate::error::validation_exception::Builder {
        crate::error::validation_exception::Builder::default()
    }
}

/// <p>The request was denied because of request throttling. Retry the request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ThrottlingException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ThrottlingException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ThrottlingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ThrottlingException")?;
        if let Some(inner_2) = &self.message {
            {
                write!(f, ": {}", inner_2)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ThrottlingException {}
/// See [`ThrottlingException`](crate::error::ThrottlingException).
pub mod throttling_exception {

    /// A builder for [`ThrottlingException`](crate::error::ThrottlingException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ThrottlingException`](crate::error::ThrottlingException).
        pub fn build(self) -> crate::error::ThrottlingException {
            crate::error::ThrottlingException {
                message: self.message,
            }
        }
    }
}
impl ThrottlingException {
    /// Creates a new builder-style object to manufacture [`ThrottlingException`](crate::error::ThrottlingException).
    pub fn builder() -> crate::error::throttling_exception::Builder {
        crate::error::throttling_exception::Builder::default()
    }
}

/// <p>An exception occurred with the service.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InternalServerException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl InternalServerException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalServerException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServerException")?;
        if let Some(inner_3) = &self.message {
            {
                write!(f, ": {}", inner_3)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InternalServerException {}
/// See [`InternalServerException`](crate::error::InternalServerException).
pub mod internal_server_exception {

    /// A builder for [`InternalServerException`](crate::error::InternalServerException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalServerException`](crate::error::InternalServerException).
        pub fn build(self) -> crate::error::InternalServerException {
            crate::error::InternalServerException {
                message: self.message,
            }
        }
    }
}
impl InternalServerException {
    /// Creates a new builder-style object to manufacture [`InternalServerException`](crate::error::InternalServerException).
    pub fn builder() -> crate::error::internal_server_exception::Builder {
        crate::error::internal_server_exception::Builder::default()
    }
}

/// <p>You don't have sufficient access to perform this action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AccessDeniedException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl AccessDeniedException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccessDeniedException")?;
        if let Some(inner_4) = &self.message {
            {
                write!(f, ": {}", inner_4)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for AccessDeniedException {}
/// See [`AccessDeniedException`](crate::error::AccessDeniedException).
pub mod access_denied_exception {

    /// A builder for [`AccessDeniedException`](crate::error::AccessDeniedException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AccessDeniedException`](crate::error::AccessDeniedException).
        pub fn build(self) -> crate::error::AccessDeniedException {
            crate::error::AccessDeniedException {
                message: self.message,
            }
        }
    }
}
impl AccessDeniedException {
    /// Creates a new builder-style object to manufacture [`AccessDeniedException`](crate::error::AccessDeniedException).
    pub fn builder() -> crate::error::access_denied_exception::Builder {
        crate::error::access_denied_exception::Builder::default()
    }
}

/// Error type for the `StopProductSubscription` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopProductSubscriptionError {
    /// Kind of error that occurred.
    pub kind: StopProductSubscriptionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for StopProductSubscriptionError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: StopProductSubscriptionErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `StopProductSubscription` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopProductSubscriptionErrorKind {
    /// <p>You don't have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request couldn't be completed because it conflicted with the current state of the resource.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>An exception occurred with the service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The resource couldn't be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The request failed because a service quota is exceeded.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>The request was denied because of request throttling. Retry the request.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>A parameter is not valid.</p>
    ValidationException(crate::error::ValidationException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for StopProductSubscriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopProductSubscriptionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            StopProductSubscriptionErrorKind::ConflictException(_inner) => _inner.fmt(f),
            StopProductSubscriptionErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            StopProductSubscriptionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            StopProductSubscriptionErrorKind::ServiceQuotaExceededException(_inner) => {
                _inner.fmt(f)
            }
            StopProductSubscriptionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StopProductSubscriptionErrorKind::ValidationException(_inner) => _inner.fmt(f),
            StopProductSubscriptionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for StopProductSubscriptionError {
    fn code(&self) -> Option<&str> {
        StopProductSubscriptionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopProductSubscriptionError {
    /// Creates a new `StopProductSubscriptionError`.
    pub fn new(kind: StopProductSubscriptionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `StopProductSubscriptionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopProductSubscriptionErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `StopProductSubscriptionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopProductSubscriptionErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `StopProductSubscriptionErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopProductSubscriptionErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `StopProductSubscriptionErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopProductSubscriptionErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `StopProductSubscriptionErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopProductSubscriptionErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `StopProductSubscriptionErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopProductSubscriptionErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `StopProductSubscriptionErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopProductSubscriptionErrorKind::ServiceQuotaExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `StopProductSubscriptionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopProductSubscriptionErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `StopProductSubscriptionErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopProductSubscriptionErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for StopProductSubscriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopProductSubscriptionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            StopProductSubscriptionErrorKind::ConflictException(_inner) => Some(_inner),
            StopProductSubscriptionErrorKind::InternalServerException(_inner) => Some(_inner),
            StopProductSubscriptionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            StopProductSubscriptionErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            StopProductSubscriptionErrorKind::ThrottlingException(_inner) => Some(_inner),
            StopProductSubscriptionErrorKind::ValidationException(_inner) => Some(_inner),
            StopProductSubscriptionErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The request failed because a service quota is exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServiceQuotaExceededException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ServiceQuotaExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceQuotaExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceQuotaExceededException")?;
        if let Some(inner_5) = &self.message {
            {
                write!(f, ": {}", inner_5)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ServiceQuotaExceededException {}
/// See [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException).
pub mod service_quota_exceeded_exception {

    /// A builder for [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException).
        pub fn build(self) -> crate::error::ServiceQuotaExceededException {
            crate::error::ServiceQuotaExceededException {
                message: self.message,
            }
        }
    }
}
impl ServiceQuotaExceededException {
    /// Creates a new builder-style object to manufacture [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException).
    pub fn builder() -> crate::error::service_quota_exceeded_exception::Builder {
        crate::error::service_quota_exceeded_exception::Builder::default()
    }
}

/// <p>The resource couldn't be found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceNotFoundException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ResourceNotFoundException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundException")?;
        if let Some(inner_6) = &self.message {
            {
                write!(f, ": {}", inner_6)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundException {}
/// See [`ResourceNotFoundException`](crate::error::ResourceNotFoundException).
pub mod resource_not_found_exception {

    /// A builder for [`ResourceNotFoundException`](crate::error::ResourceNotFoundException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException).
        pub fn build(self) -> crate::error::ResourceNotFoundException {
            crate::error::ResourceNotFoundException {
                message: self.message,
            }
        }
    }
}
impl ResourceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundException`](crate::error::ResourceNotFoundException).
    pub fn builder() -> crate::error::resource_not_found_exception::Builder {
        crate::error::resource_not_found_exception::Builder::default()
    }
}

/// <p>The request couldn't be completed because it conflicted with the current state of the resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConflictException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ConflictException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_7) = &self.message {
            {
                write!(f, ": {}", inner_7)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
/// See [`ConflictException`](crate::error::ConflictException).
pub mod conflict_exception {

    /// A builder for [`ConflictException`](crate::error::ConflictException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException).
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                message: self.message,
            }
        }
    }
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException).
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}

/// Error type for the `StartProductSubscription` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartProductSubscriptionError {
    /// Kind of error that occurred.
    pub kind: StartProductSubscriptionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for StartProductSubscriptionError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: StartProductSubscriptionErrorKind::Unhandled(crate::error::Unhandled::new(
                source,
            )),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `StartProductSubscription` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartProductSubscriptionErrorKind {
    /// <p>You don't have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request couldn't be completed because it conflicted with the current state of the resource.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>An exception occurred with the service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The resource couldn't be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The request failed because a service quota is exceeded.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>The request was denied because of request throttling. Retry the request.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>A parameter is not valid.</p>
    ValidationException(crate::error::ValidationException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for StartProductSubscriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartProductSubscriptionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            StartProductSubscriptionErrorKind::ConflictException(_inner) => _inner.fmt(f),
            StartProductSubscriptionErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            StartProductSubscriptionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            StartProductSubscriptionErrorKind::ServiceQuotaExceededException(_inner) => {
                _inner.fmt(f)
            }
            StartProductSubscriptionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StartProductSubscriptionErrorKind::ValidationException(_inner) => _inner.fmt(f),
            StartProductSubscriptionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for StartProductSubscriptionError {
    fn code(&self) -> Option<&str> {
        StartProductSubscriptionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartProductSubscriptionError {
    /// Creates a new `StartProductSubscriptionError`.
    pub fn new(kind: StartProductSubscriptionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `StartProductSubscriptionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartProductSubscriptionErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `StartProductSubscriptionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartProductSubscriptionErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `StartProductSubscriptionErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartProductSubscriptionErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `StartProductSubscriptionErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartProductSubscriptionErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `StartProductSubscriptionErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartProductSubscriptionErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `StartProductSubscriptionErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartProductSubscriptionErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `StartProductSubscriptionErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartProductSubscriptionErrorKind::ServiceQuotaExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `StartProductSubscriptionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartProductSubscriptionErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `StartProductSubscriptionErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartProductSubscriptionErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for StartProductSubscriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartProductSubscriptionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            StartProductSubscriptionErrorKind::ConflictException(_inner) => Some(_inner),
            StartProductSubscriptionErrorKind::InternalServerException(_inner) => Some(_inner),
            StartProductSubscriptionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            StartProductSubscriptionErrorKind::ServiceQuotaExceededException(_inner) => {
                Some(_inner)
            }
            StartProductSubscriptionErrorKind::ThrottlingException(_inner) => Some(_inner),
            StartProductSubscriptionErrorKind::ValidationException(_inner) => Some(_inner),
            StartProductSubscriptionErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `RegisterIdentityProvider` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RegisterIdentityProviderError {
    /// Kind of error that occurred.
    pub kind: RegisterIdentityProviderErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for RegisterIdentityProviderError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: RegisterIdentityProviderErrorKind::Unhandled(crate::error::Unhandled::new(
                source,
            )),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `RegisterIdentityProvider` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterIdentityProviderErrorKind {
    /// <p>You don't have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request couldn't be completed because it conflicted with the current state of the resource.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>An exception occurred with the service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The resource couldn't be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The request failed because a service quota is exceeded.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>The request was denied because of request throttling. Retry the request.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>A parameter is not valid.</p>
    ValidationException(crate::error::ValidationException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for RegisterIdentityProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RegisterIdentityProviderErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            RegisterIdentityProviderErrorKind::ConflictException(_inner) => _inner.fmt(f),
            RegisterIdentityProviderErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            RegisterIdentityProviderErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            RegisterIdentityProviderErrorKind::ServiceQuotaExceededException(_inner) => {
                _inner.fmt(f)
            }
            RegisterIdentityProviderErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            RegisterIdentityProviderErrorKind::ValidationException(_inner) => _inner.fmt(f),
            RegisterIdentityProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RegisterIdentityProviderError {
    fn code(&self) -> Option<&str> {
        RegisterIdentityProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterIdentityProviderError {
    /// Creates a new `RegisterIdentityProviderError`.
    pub fn new(kind: RegisterIdentityProviderErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `RegisterIdentityProviderError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RegisterIdentityProviderErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `RegisterIdentityProviderError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RegisterIdentityProviderErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `RegisterIdentityProviderErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterIdentityProviderErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `RegisterIdentityProviderErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterIdentityProviderErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `RegisterIdentityProviderErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterIdentityProviderErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `RegisterIdentityProviderErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterIdentityProviderErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `RegisterIdentityProviderErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterIdentityProviderErrorKind::ServiceQuotaExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `RegisterIdentityProviderErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterIdentityProviderErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `RegisterIdentityProviderErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterIdentityProviderErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for RegisterIdentityProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RegisterIdentityProviderErrorKind::AccessDeniedException(_inner) => Some(_inner),
            RegisterIdentityProviderErrorKind::ConflictException(_inner) => Some(_inner),
            RegisterIdentityProviderErrorKind::InternalServerException(_inner) => Some(_inner),
            RegisterIdentityProviderErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            RegisterIdentityProviderErrorKind::ServiceQuotaExceededException(_inner) => {
                Some(_inner)
            }
            RegisterIdentityProviderErrorKind::ThrottlingException(_inner) => Some(_inner),
            RegisterIdentityProviderErrorKind::ValidationException(_inner) => Some(_inner),
            RegisterIdentityProviderErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `ListUserAssociations` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListUserAssociationsError {
    /// Kind of error that occurred.
    pub kind: ListUserAssociationsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for ListUserAssociationsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListUserAssociationsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `ListUserAssociations` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListUserAssociationsErrorKind {
    /// <p>You don't have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request couldn't be completed because it conflicted with the current state of the resource.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>An exception occurred with the service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The resource couldn't be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The request failed because a service quota is exceeded.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>The request was denied because of request throttling. Retry the request.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>A parameter is not valid.</p>
    ValidationException(crate::error::ValidationException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListUserAssociationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListUserAssociationsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListUserAssociationsErrorKind::ConflictException(_inner) => _inner.fmt(f),
            ListUserAssociationsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListUserAssociationsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListUserAssociationsErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            ListUserAssociationsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListUserAssociationsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListUserAssociationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListUserAssociationsError {
    fn code(&self) -> Option<&str> {
        ListUserAssociationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListUserAssociationsError {
    /// Creates a new `ListUserAssociationsError`.
    pub fn new(kind: ListUserAssociationsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListUserAssociationsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListUserAssociationsErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `ListUserAssociationsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListUserAssociationsErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListUserAssociationsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserAssociationsErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `ListUserAssociationsErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserAssociationsErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `ListUserAssociationsErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserAssociationsErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `ListUserAssociationsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserAssociationsErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListUserAssociationsErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserAssociationsErrorKind::ServiceQuotaExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `ListUserAssociationsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserAssociationsErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `ListUserAssociationsErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserAssociationsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListUserAssociationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListUserAssociationsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListUserAssociationsErrorKind::ConflictException(_inner) => Some(_inner),
            ListUserAssociationsErrorKind::InternalServerException(_inner) => Some(_inner),
            ListUserAssociationsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListUserAssociationsErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            ListUserAssociationsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListUserAssociationsErrorKind::ValidationException(_inner) => Some(_inner),
            ListUserAssociationsErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `ListProductSubscriptions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListProductSubscriptionsError {
    /// Kind of error that occurred.
    pub kind: ListProductSubscriptionsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for ListProductSubscriptionsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListProductSubscriptionsErrorKind::Unhandled(crate::error::Unhandled::new(
                source,
            )),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `ListProductSubscriptions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListProductSubscriptionsErrorKind {
    /// <p>You don't have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request couldn't be completed because it conflicted with the current state of the resource.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>An exception occurred with the service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The resource couldn't be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The request failed because a service quota is exceeded.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>The request was denied because of request throttling. Retry the request.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>A parameter is not valid.</p>
    ValidationException(crate::error::ValidationException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListProductSubscriptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListProductSubscriptionsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListProductSubscriptionsErrorKind::ConflictException(_inner) => _inner.fmt(f),
            ListProductSubscriptionsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListProductSubscriptionsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListProductSubscriptionsErrorKind::ServiceQuotaExceededException(_inner) => {
                _inner.fmt(f)
            }
            ListProductSubscriptionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListProductSubscriptionsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListProductSubscriptionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListProductSubscriptionsError {
    fn code(&self) -> Option<&str> {
        ListProductSubscriptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListProductSubscriptionsError {
    /// Creates a new `ListProductSubscriptionsError`.
    pub fn new(kind: ListProductSubscriptionsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListProductSubscriptionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListProductSubscriptionsErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `ListProductSubscriptionsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListProductSubscriptionsErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListProductSubscriptionsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProductSubscriptionsErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `ListProductSubscriptionsErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProductSubscriptionsErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `ListProductSubscriptionsErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProductSubscriptionsErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `ListProductSubscriptionsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProductSubscriptionsErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListProductSubscriptionsErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProductSubscriptionsErrorKind::ServiceQuotaExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `ListProductSubscriptionsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProductSubscriptionsErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `ListProductSubscriptionsErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProductSubscriptionsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListProductSubscriptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListProductSubscriptionsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListProductSubscriptionsErrorKind::ConflictException(_inner) => Some(_inner),
            ListProductSubscriptionsErrorKind::InternalServerException(_inner) => Some(_inner),
            ListProductSubscriptionsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListProductSubscriptionsErrorKind::ServiceQuotaExceededException(_inner) => {
                Some(_inner)
            }
            ListProductSubscriptionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListProductSubscriptionsErrorKind::ValidationException(_inner) => Some(_inner),
            ListProductSubscriptionsErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `ListInstances` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListInstancesError {
    /// Kind of error that occurred.
    pub kind: ListInstancesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for ListInstancesError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListInstancesErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `ListInstances` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListInstancesErrorKind {
    /// <p>You don't have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request couldn't be completed because it conflicted with the current state of the resource.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>An exception occurred with the service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The resource couldn't be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The request failed because a service quota is exceeded.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>The request was denied because of request throttling. Retry the request.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>A parameter is not valid.</p>
    ValidationException(crate::error::ValidationException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListInstancesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListInstancesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListInstancesErrorKind::ConflictException(_inner) => _inner.fmt(f),
            ListInstancesErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListInstancesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListInstancesErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            ListInstancesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListInstancesErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListInstancesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListInstancesError {
    fn code(&self) -> Option<&str> {
        ListInstancesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListInstancesError {
    /// Creates a new `ListInstancesError`.
    pub fn new(kind: ListInstancesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListInstancesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListInstancesErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
            meta: Default::default(),
        }
    }

    /// Creates the `ListInstancesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListInstancesErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListInstancesErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListInstancesErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListInstancesErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, ListInstancesErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `ListInstancesErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInstancesErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `ListInstancesErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInstancesErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListInstancesErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInstancesErrorKind::ServiceQuotaExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `ListInstancesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListInstancesErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListInstancesErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListInstancesErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListInstancesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListInstancesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListInstancesErrorKind::ConflictException(_inner) => Some(_inner),
            ListInstancesErrorKind::InternalServerException(_inner) => Some(_inner),
            ListInstancesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListInstancesErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            ListInstancesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListInstancesErrorKind::ValidationException(_inner) => Some(_inner),
            ListInstancesErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `ListIdentityProviders` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListIdentityProvidersError {
    /// Kind of error that occurred.
    pub kind: ListIdentityProvidersErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for ListIdentityProvidersError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListIdentityProvidersErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `ListIdentityProviders` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListIdentityProvidersErrorKind {
    /// <p>You don't have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request couldn't be completed because it conflicted with the current state of the resource.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>An exception occurred with the service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The resource couldn't be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The request failed because a service quota is exceeded.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>The request was denied because of request throttling. Retry the request.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>A parameter is not valid.</p>
    ValidationException(crate::error::ValidationException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListIdentityProvidersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListIdentityProvidersErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListIdentityProvidersErrorKind::ConflictException(_inner) => _inner.fmt(f),
            ListIdentityProvidersErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListIdentityProvidersErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListIdentityProvidersErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            ListIdentityProvidersErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListIdentityProvidersErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListIdentityProvidersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListIdentityProvidersError {
    fn code(&self) -> Option<&str> {
        ListIdentityProvidersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListIdentityProvidersError {
    /// Creates a new `ListIdentityProvidersError`.
    pub fn new(kind: ListIdentityProvidersErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListIdentityProvidersError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListIdentityProvidersErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `ListIdentityProvidersError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListIdentityProvidersErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListIdentityProvidersErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIdentityProvidersErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `ListIdentityProvidersErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIdentityProvidersErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `ListIdentityProvidersErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIdentityProvidersErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `ListIdentityProvidersErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIdentityProvidersErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListIdentityProvidersErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIdentityProvidersErrorKind::ServiceQuotaExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `ListIdentityProvidersErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIdentityProvidersErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `ListIdentityProvidersErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIdentityProvidersErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListIdentityProvidersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListIdentityProvidersErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListIdentityProvidersErrorKind::ConflictException(_inner) => Some(_inner),
            ListIdentityProvidersErrorKind::InternalServerException(_inner) => Some(_inner),
            ListIdentityProvidersErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListIdentityProvidersErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            ListIdentityProvidersErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListIdentityProvidersErrorKind::ValidationException(_inner) => Some(_inner),
            ListIdentityProvidersErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `DisassociateUser` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateUserError {
    /// Kind of error that occurred.
    pub kind: DisassociateUserErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for DisassociateUserError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DisassociateUserErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `DisassociateUser` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateUserErrorKind {
    /// <p>You don't have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request couldn't be completed because it conflicted with the current state of the resource.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>An exception occurred with the service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The resource couldn't be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The request failed because a service quota is exceeded.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>The request was denied because of request throttling. Retry the request.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>A parameter is not valid.</p>
    ValidationException(crate::error::ValidationException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DisassociateUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateUserErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DisassociateUserErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DisassociateUserErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DisassociateUserErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DisassociateUserErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            DisassociateUserErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DisassociateUserErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DisassociateUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DisassociateUserError {
    fn code(&self) -> Option<&str> {
        DisassociateUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateUserError {
    /// Creates a new `DisassociateUserError`.
    pub fn new(kind: DisassociateUserErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DisassociateUserError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateUserErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
            meta: Default::default(),
        }
    }

    /// Creates the `DisassociateUserError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateUserErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DisassociateUserErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateUserErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `DisassociateUserErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DisassociateUserErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `DisassociateUserErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateUserErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `DisassociateUserErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateUserErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DisassociateUserErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateUserErrorKind::ServiceQuotaExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `DisassociateUserErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateUserErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DisassociateUserErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateUserErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DisassociateUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateUserErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DisassociateUserErrorKind::ConflictException(_inner) => Some(_inner),
            DisassociateUserErrorKind::InternalServerException(_inner) => Some(_inner),
            DisassociateUserErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DisassociateUserErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            DisassociateUserErrorKind::ThrottlingException(_inner) => Some(_inner),
            DisassociateUserErrorKind::ValidationException(_inner) => Some(_inner),
            DisassociateUserErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `DeregisterIdentityProvider` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeregisterIdentityProviderError {
    /// Kind of error that occurred.
    pub kind: DeregisterIdentityProviderErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for DeregisterIdentityProviderError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeregisterIdentityProviderErrorKind::Unhandled(crate::error::Unhandled::new(
                source,
            )),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `DeregisterIdentityProvider` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeregisterIdentityProviderErrorKind {
    /// <p>You don't have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request couldn't be completed because it conflicted with the current state of the resource.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>An exception occurred with the service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The resource couldn't be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The request failed because a service quota is exceeded.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>The request was denied because of request throttling. Retry the request.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>A parameter is not valid.</p>
    ValidationException(crate::error::ValidationException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeregisterIdentityProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeregisterIdentityProviderErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeregisterIdentityProviderErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeregisterIdentityProviderErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeregisterIdentityProviderErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeregisterIdentityProviderErrorKind::ServiceQuotaExceededException(_inner) => {
                _inner.fmt(f)
            }
            DeregisterIdentityProviderErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeregisterIdentityProviderErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeregisterIdentityProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeregisterIdentityProviderError {
    fn code(&self) -> Option<&str> {
        DeregisterIdentityProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeregisterIdentityProviderError {
    /// Creates a new `DeregisterIdentityProviderError`.
    pub fn new(kind: DeregisterIdentityProviderErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeregisterIdentityProviderError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeregisterIdentityProviderErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `DeregisterIdentityProviderError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeregisterIdentityProviderErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeregisterIdentityProviderErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterIdentityProviderErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `DeregisterIdentityProviderErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterIdentityProviderErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `DeregisterIdentityProviderErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterIdentityProviderErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `DeregisterIdentityProviderErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterIdentityProviderErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeregisterIdentityProviderErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterIdentityProviderErrorKind::ServiceQuotaExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `DeregisterIdentityProviderErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterIdentityProviderErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DeregisterIdentityProviderErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterIdentityProviderErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DeregisterIdentityProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeregisterIdentityProviderErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeregisterIdentityProviderErrorKind::ConflictException(_inner) => Some(_inner),
            DeregisterIdentityProviderErrorKind::InternalServerException(_inner) => Some(_inner),
            DeregisterIdentityProviderErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeregisterIdentityProviderErrorKind::ServiceQuotaExceededException(_inner) => {
                Some(_inner)
            }
            DeregisterIdentityProviderErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeregisterIdentityProviderErrorKind::ValidationException(_inner) => Some(_inner),
            DeregisterIdentityProviderErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `AssociateUser` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateUserError {
    /// Kind of error that occurred.
    pub kind: AssociateUserErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for AssociateUserError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: AssociateUserErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `AssociateUser` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateUserErrorKind {
    /// <p>You don't have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request couldn't be completed because it conflicted with the current state of the resource.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>An exception occurred with the service.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The resource couldn't be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The request failed because a service quota is exceeded.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>The request was denied because of request throttling. Retry the request.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>A parameter is not valid.</p>
    ValidationException(crate::error::ValidationException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for AssociateUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateUserErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            AssociateUserErrorKind::ConflictException(_inner) => _inner.fmt(f),
            AssociateUserErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            AssociateUserErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AssociateUserErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            AssociateUserErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            AssociateUserErrorKind::ValidationException(_inner) => _inner.fmt(f),
            AssociateUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AssociateUserError {
    fn code(&self) -> Option<&str> {
        AssociateUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateUserError {
    /// Creates a new `AssociateUserError`.
    pub fn new(kind: AssociateUserErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `AssociateUserError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateUserErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
            meta: Default::default(),
        }
    }

    /// Creates the `AssociateUserError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateUserErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `AssociateUserErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, AssociateUserErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `AssociateUserErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, AssociateUserErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `AssociateUserErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateUserErrorKind::InternalServerException(_)
        )
    }
    /// Returns `true` if the error kind is `AssociateUserErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateUserErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `AssociateUserErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateUserErrorKind::ServiceQuotaExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `AssociateUserErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, AssociateUserErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `AssociateUserErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, AssociateUserErrorKind::ValidationException(_))
    }
}
impl std::error::Error for AssociateUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateUserErrorKind::AccessDeniedException(_inner) => Some(_inner),
            AssociateUserErrorKind::ConflictException(_inner) => Some(_inner),
            AssociateUserErrorKind::InternalServerException(_inner) => Some(_inner),
            AssociateUserErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AssociateUserErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            AssociateUserErrorKind::ThrottlingException(_inner) => Some(_inner),
            AssociateUserErrorKind::ValidationException(_inner) => Some(_inner),
            AssociateUserErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

///
/// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
///
/// When logging an error from the SDK, it is recommended that you either wrap the error in
/// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
/// error reporter library that visits the error's cause/source chain, or call
/// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
///
#[derive(Debug)]
pub struct Unhandled {
    source: Box<dyn std::error::Error + Send + Sync + 'static>,
}
impl Unhandled {
    #[allow(unused)]
    pub(crate) fn new(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self { source }
    }
}
impl std::fmt::Display for Unhandled {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(f, "unhandled error")
    }
}
impl std::error::Error for Unhandled {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        Some(self.source.as_ref() as _)
    }
}
