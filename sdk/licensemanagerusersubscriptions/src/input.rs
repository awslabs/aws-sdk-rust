// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;

/// See [`AssociateUserInput`](crate::input::AssociateUserInput).
pub mod associate_user_input {
    
    /// A builder for [`AssociateUserInput`](crate::input::AssociateUserInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) username: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) identity_provider: std::option::Option<crate::model::IdentityProvider>,
        pub(crate) domain: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The user name from the identity provider for the user.</p>
        pub fn username(mut self, input: impl Into<std::string::String>) -> Self {
            self.username = Some(input.into());
            self
        }
        /// <p>The user name from the identity provider for the user.</p>
        pub fn set_username(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.username = input; self
        }
        /// <p>The ID of the EC2 instance, which provides user-based subscriptions.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The ID of the EC2 instance, which provides user-based subscriptions.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input; self
        }
        /// <p>The identity provider of the user.</p>
        pub fn identity_provider(mut self, input: crate::model::IdentityProvider) -> Self {
            self.identity_provider = Some(input);
            self
        }
        /// <p>The identity provider of the user.</p>
        pub fn set_identity_provider(mut self, input: std::option::Option<crate::model::IdentityProvider>) -> Self {
            self.identity_provider = input; self
        }
        /// <p>The domain name of the user.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p>The domain name of the user.</p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input; self
        }
        /// Consumes the builder and constructs a [`AssociateUserInput`](crate::input::AssociateUserInput).
        pub fn build(self) -> Result<crate::input::AssociateUserInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::AssociateUserInput {
                    username: self.username
                    ,
                    instance_id: self.instance_id
                    ,
                    identity_provider: self.identity_provider
                    ,
                    domain: self.domain
                    ,
                }
            )
        }
    }
    
    
}
impl AssociateUserInput {
    /// Consumes the builder and constructs an Operation<[`AssociateUser`](crate::operation::AssociateUser)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::AssociateUser, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::AssociateUserInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/user/AssociateUser").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::AssociateUserInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_associate_user(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::AssociateUser::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("AssociateUser", "licensemanagerusersubscriptions"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`AssociateUserInput`](crate::input::AssociateUserInput).
    pub fn builder() -> crate::input::associate_user_input::Builder {
        crate::input::associate_user_input::Builder::default()
    }
}

/// See [`DeregisterIdentityProviderInput`](crate::input::DeregisterIdentityProviderInput).
pub mod deregister_identity_provider_input {
    
    /// A builder for [`DeregisterIdentityProviderInput`](crate::input::DeregisterIdentityProviderInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) identity_provider: std::option::Option<crate::model::IdentityProvider>,
        pub(crate) product: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An object that specifies details for the identity provider.</p>
        pub fn identity_provider(mut self, input: crate::model::IdentityProvider) -> Self {
            self.identity_provider = Some(input);
            self
        }
        /// <p>An object that specifies details for the identity provider.</p>
        pub fn set_identity_provider(mut self, input: std::option::Option<crate::model::IdentityProvider>) -> Self {
            self.identity_provider = input; self
        }
        /// <p>The name of the user-based subscription product.</p>
        pub fn product(mut self, input: impl Into<std::string::String>) -> Self {
            self.product = Some(input.into());
            self
        }
        /// <p>The name of the user-based subscription product.</p>
        pub fn set_product(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.product = input; self
        }
        /// Consumes the builder and constructs a [`DeregisterIdentityProviderInput`](crate::input::DeregisterIdentityProviderInput).
        pub fn build(self) -> Result<crate::input::DeregisterIdentityProviderInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeregisterIdentityProviderInput {
                    identity_provider: self.identity_provider
                    ,
                    product: self.product
                    ,
                }
            )
        }
    }
    
    
}
impl DeregisterIdentityProviderInput {
    /// Consumes the builder and constructs an Operation<[`DeregisterIdentityProvider`](crate::operation::DeregisterIdentityProvider)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeregisterIdentityProvider, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeregisterIdentityProviderInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/identity-provider/DeregisterIdentityProvider").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeregisterIdentityProviderInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_deregister_identity_provider(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeregisterIdentityProvider::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeregisterIdentityProvider", "licensemanagerusersubscriptions"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeregisterIdentityProviderInput`](crate::input::DeregisterIdentityProviderInput).
    pub fn builder() -> crate::input::deregister_identity_provider_input::Builder {
        crate::input::deregister_identity_provider_input::Builder::default()
    }
}

/// See [`DisassociateUserInput`](crate::input::DisassociateUserInput).
pub mod disassociate_user_input {
    
    /// A builder for [`DisassociateUserInput`](crate::input::DisassociateUserInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) username: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) identity_provider: std::option::Option<crate::model::IdentityProvider>,
        pub(crate) domain: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The user name from the identity provider for the user.</p>
        pub fn username(mut self, input: impl Into<std::string::String>) -> Self {
            self.username = Some(input.into());
            self
        }
        /// <p>The user name from the identity provider for the user.</p>
        pub fn set_username(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.username = input; self
        }
        /// <p>The ID of the EC2 instance, which provides user-based subscriptions.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The ID of the EC2 instance, which provides user-based subscriptions.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input; self
        }
        /// <p>An object that specifies details for the identity provider.</p>
        pub fn identity_provider(mut self, input: crate::model::IdentityProvider) -> Self {
            self.identity_provider = Some(input);
            self
        }
        /// <p>An object that specifies details for the identity provider.</p>
        pub fn set_identity_provider(mut self, input: std::option::Option<crate::model::IdentityProvider>) -> Self {
            self.identity_provider = input; self
        }
        /// <p>The domain name of the user.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p>The domain name of the user.</p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input; self
        }
        /// Consumes the builder and constructs a [`DisassociateUserInput`](crate::input::DisassociateUserInput).
        pub fn build(self) -> Result<crate::input::DisassociateUserInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DisassociateUserInput {
                    username: self.username
                    ,
                    instance_id: self.instance_id
                    ,
                    identity_provider: self.identity_provider
                    ,
                    domain: self.domain
                    ,
                }
            )
        }
    }
    
    
}
impl DisassociateUserInput {
    /// Consumes the builder and constructs an Operation<[`DisassociateUser`](crate::operation::DisassociateUser)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DisassociateUser, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DisassociateUserInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/user/DisassociateUser").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DisassociateUserInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_disassociate_user(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DisassociateUser::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DisassociateUser", "licensemanagerusersubscriptions"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DisassociateUserInput`](crate::input::DisassociateUserInput).
    pub fn builder() -> crate::input::disassociate_user_input::Builder {
        crate::input::disassociate_user_input::Builder::default()
    }
}

/// See [`ListIdentityProvidersInput`](crate::input::ListIdentityProvidersInput).
pub mod list_identity_providers_input {
    
    /// A builder for [`ListIdentityProvidersInput`](crate::input::ListIdentityProvidersInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Maximum number of results to return in a single call.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>Maximum number of results to return in a single call.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// <p>Token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Token for the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`ListIdentityProvidersInput`](crate::input::ListIdentityProvidersInput).
        pub fn build(self) -> Result<crate::input::ListIdentityProvidersInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListIdentityProvidersInput {
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl ListIdentityProvidersInput {
    /// Consumes the builder and constructs an Operation<[`ListIdentityProviders`](crate::operation::ListIdentityProviders)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListIdentityProviders, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListIdentityProvidersInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/identity-provider/ListIdentityProviders").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListIdentityProvidersInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_list_identity_providers(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListIdentityProviders::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListIdentityProviders", "licensemanagerusersubscriptions"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListIdentityProvidersInput`](crate::input::ListIdentityProvidersInput).
    pub fn builder() -> crate::input::list_identity_providers_input::Builder {
        crate::input::list_identity_providers_input::Builder::default()
    }
}

/// See [`ListInstancesInput`](crate::input::ListInstancesInput).
pub mod list_instances_input {
    
    /// A builder for [`ListInstancesInput`](crate::input::ListInstancesInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) filters: std::option::Option<std::vec::Vec<crate::model::Filter>>,
    }
    impl Builder {
        /// <p>Maximum number of results to return in a single call.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>Maximum number of results to return in a single call.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// <p>Token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Token for the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Appends an item to `filters`.
        ///
        /// To override the contents of this collection use [`set_filters`](Self::set_filters).
        ///
        /// <p>An array of structures that you can use to filter the results to those that match one or more sets of key-value pairs that you specify.</p>
        pub fn filters(mut self, input: crate::model::Filter) -> Self {
            let mut v = self.filters.unwrap_or_default();
                            v.push(input);
                            self.filters = Some(v);
                            self
        }
        /// <p>An array of structures that you can use to filter the results to those that match one or more sets of key-value pairs that you specify.</p>
        pub fn set_filters(mut self, input: std::option::Option<std::vec::Vec<crate::model::Filter>>) -> Self {
            self.filters = input; self
        }
        /// Consumes the builder and constructs a [`ListInstancesInput`](crate::input::ListInstancesInput).
        pub fn build(self) -> Result<crate::input::ListInstancesInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListInstancesInput {
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                    filters: self.filters
                    ,
                }
            )
        }
    }
    
    
}
impl ListInstancesInput {
    /// Consumes the builder and constructs an Operation<[`ListInstances`](crate::operation::ListInstances)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListInstances, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListInstancesInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/instance/ListInstances").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListInstancesInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_list_instances(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListInstances::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListInstances", "licensemanagerusersubscriptions"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListInstancesInput`](crate::input::ListInstancesInput).
    pub fn builder() -> crate::input::list_instances_input::Builder {
        crate::input::list_instances_input::Builder::default()
    }
}

/// See [`ListProductSubscriptionsInput`](crate::input::ListProductSubscriptionsInput).
pub mod list_product_subscriptions_input {
    
    /// A builder for [`ListProductSubscriptionsInput`](crate::input::ListProductSubscriptionsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) product: std::option::Option<std::string::String>,
        pub(crate) identity_provider: std::option::Option<crate::model::IdentityProvider>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) filters: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the user-based subscription product.</p>
        pub fn product(mut self, input: impl Into<std::string::String>) -> Self {
            self.product = Some(input.into());
            self
        }
        /// <p>The name of the user-based subscription product.</p>
        pub fn set_product(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.product = input; self
        }
        /// <p>An object that specifies details for the identity provider.</p>
        pub fn identity_provider(mut self, input: crate::model::IdentityProvider) -> Self {
            self.identity_provider = Some(input);
            self
        }
        /// <p>An object that specifies details for the identity provider.</p>
        pub fn set_identity_provider(mut self, input: std::option::Option<crate::model::IdentityProvider>) -> Self {
            self.identity_provider = input; self
        }
        /// <p>Maximum number of results to return in a single call.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>Maximum number of results to return in a single call.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Appends an item to `filters`.
        ///
        /// To override the contents of this collection use [`set_filters`](Self::set_filters).
        ///
        /// <p>An array of structures that you can use to filter the results to those that match one or more sets of key-value pairs that you specify.</p>
        pub fn filters(mut self, input: crate::model::Filter) -> Self {
            let mut v = self.filters.unwrap_or_default();
                            v.push(input);
                            self.filters = Some(v);
                            self
        }
        /// <p>An array of structures that you can use to filter the results to those that match one or more sets of key-value pairs that you specify.</p>
        pub fn set_filters(mut self, input: std::option::Option<std::vec::Vec<crate::model::Filter>>) -> Self {
            self.filters = input; self
        }
        /// <p>Token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Token for the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`ListProductSubscriptionsInput`](crate::input::ListProductSubscriptionsInput).
        pub fn build(self) -> Result<crate::input::ListProductSubscriptionsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListProductSubscriptionsInput {
                    product: self.product
                    ,
                    identity_provider: self.identity_provider
                    ,
                    max_results: self.max_results
                    ,
                    filters: self.filters
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl ListProductSubscriptionsInput {
    /// Consumes the builder and constructs an Operation<[`ListProductSubscriptions`](crate::operation::ListProductSubscriptions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListProductSubscriptions, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListProductSubscriptionsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/user/ListProductSubscriptions").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListProductSubscriptionsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_list_product_subscriptions(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListProductSubscriptions::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListProductSubscriptions", "licensemanagerusersubscriptions"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListProductSubscriptionsInput`](crate::input::ListProductSubscriptionsInput).
    pub fn builder() -> crate::input::list_product_subscriptions_input::Builder {
        crate::input::list_product_subscriptions_input::Builder::default()
    }
}

/// See [`ListUserAssociationsInput`](crate::input::ListUserAssociationsInput).
pub mod list_user_associations_input {
    
    /// A builder for [`ListUserAssociationsInput`](crate::input::ListUserAssociationsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) identity_provider: std::option::Option<crate::model::IdentityProvider>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) filters: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the EC2 instance, which provides user-based subscriptions.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>The ID of the EC2 instance, which provides user-based subscriptions.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input; self
        }
        /// <p>An object that specifies details for the identity provider.</p>
        pub fn identity_provider(mut self, input: crate::model::IdentityProvider) -> Self {
            self.identity_provider = Some(input);
            self
        }
        /// <p>An object that specifies details for the identity provider.</p>
        pub fn set_identity_provider(mut self, input: std::option::Option<crate::model::IdentityProvider>) -> Self {
            self.identity_provider = input; self
        }
        /// <p>Maximum number of results to return in a single call.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>Maximum number of results to return in a single call.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Appends an item to `filters`.
        ///
        /// To override the contents of this collection use [`set_filters`](Self::set_filters).
        ///
        /// <p>An array of structures that you can use to filter the results to those that match one or more sets of key-value pairs that you specify.</p>
        pub fn filters(mut self, input: crate::model::Filter) -> Self {
            let mut v = self.filters.unwrap_or_default();
                            v.push(input);
                            self.filters = Some(v);
                            self
        }
        /// <p>An array of structures that you can use to filter the results to those that match one or more sets of key-value pairs that you specify.</p>
        pub fn set_filters(mut self, input: std::option::Option<std::vec::Vec<crate::model::Filter>>) -> Self {
            self.filters = input; self
        }
        /// <p>Token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Token for the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`ListUserAssociationsInput`](crate::input::ListUserAssociationsInput).
        pub fn build(self) -> Result<crate::input::ListUserAssociationsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListUserAssociationsInput {
                    instance_id: self.instance_id
                    ,
                    identity_provider: self.identity_provider
                    ,
                    max_results: self.max_results
                    ,
                    filters: self.filters
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl ListUserAssociationsInput {
    /// Consumes the builder and constructs an Operation<[`ListUserAssociations`](crate::operation::ListUserAssociations)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListUserAssociations, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListUserAssociationsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/user/ListUserAssociations").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListUserAssociationsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_list_user_associations(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListUserAssociations::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListUserAssociations", "licensemanagerusersubscriptions"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListUserAssociationsInput`](crate::input::ListUserAssociationsInput).
    pub fn builder() -> crate::input::list_user_associations_input::Builder {
        crate::input::list_user_associations_input::Builder::default()
    }
}

/// See [`RegisterIdentityProviderInput`](crate::input::RegisterIdentityProviderInput).
pub mod register_identity_provider_input {
    
    /// A builder for [`RegisterIdentityProviderInput`](crate::input::RegisterIdentityProviderInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) identity_provider: std::option::Option<crate::model::IdentityProvider>,
        pub(crate) product: std::option::Option<std::string::String>,
        pub(crate) settings: std::option::Option<crate::model::Settings>,
    }
    impl Builder {
        /// <p>An object that specifies details for the identity provider.</p>
        pub fn identity_provider(mut self, input: crate::model::IdentityProvider) -> Self {
            self.identity_provider = Some(input);
            self
        }
        /// <p>An object that specifies details for the identity provider.</p>
        pub fn set_identity_provider(mut self, input: std::option::Option<crate::model::IdentityProvider>) -> Self {
            self.identity_provider = input; self
        }
        /// <p>The name of the user-based subscription product.</p>
        pub fn product(mut self, input: impl Into<std::string::String>) -> Self {
            self.product = Some(input.into());
            self
        }
        /// <p>The name of the user-based subscription product.</p>
        pub fn set_product(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.product = input; self
        }
        /// <p>The registered identity providers product related configuration settings such as the subnets to provision VPC endpoints.</p>
        pub fn settings(mut self, input: crate::model::Settings) -> Self {
            self.settings = Some(input);
            self
        }
        /// <p>The registered identity providers product related configuration settings such as the subnets to provision VPC endpoints.</p>
        pub fn set_settings(mut self, input: std::option::Option<crate::model::Settings>) -> Self {
            self.settings = input; self
        }
        /// Consumes the builder and constructs a [`RegisterIdentityProviderInput`](crate::input::RegisterIdentityProviderInput).
        pub fn build(self) -> Result<crate::input::RegisterIdentityProviderInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::RegisterIdentityProviderInput {
                    identity_provider: self.identity_provider
                    ,
                    product: self.product
                    ,
                    settings: self.settings
                    ,
                }
            )
        }
    }
    
    
}
impl RegisterIdentityProviderInput {
    /// Consumes the builder and constructs an Operation<[`RegisterIdentityProvider`](crate::operation::RegisterIdentityProvider)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::RegisterIdentityProvider, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::RegisterIdentityProviderInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/identity-provider/RegisterIdentityProvider").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::RegisterIdentityProviderInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_register_identity_provider(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::RegisterIdentityProvider::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("RegisterIdentityProvider", "licensemanagerusersubscriptions"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`RegisterIdentityProviderInput`](crate::input::RegisterIdentityProviderInput).
    pub fn builder() -> crate::input::register_identity_provider_input::Builder {
        crate::input::register_identity_provider_input::Builder::default()
    }
}

/// See [`StartProductSubscriptionInput`](crate::input::StartProductSubscriptionInput).
pub mod start_product_subscription_input {
    
    /// A builder for [`StartProductSubscriptionInput`](crate::input::StartProductSubscriptionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) username: std::option::Option<std::string::String>,
        pub(crate) identity_provider: std::option::Option<crate::model::IdentityProvider>,
        pub(crate) product: std::option::Option<std::string::String>,
        pub(crate) domain: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The user name from the identity provider of the user.</p>
        pub fn username(mut self, input: impl Into<std::string::String>) -> Self {
            self.username = Some(input.into());
            self
        }
        /// <p>The user name from the identity provider of the user.</p>
        pub fn set_username(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.username = input; self
        }
        /// <p>An object that specifies details for the identity provider.</p>
        pub fn identity_provider(mut self, input: crate::model::IdentityProvider) -> Self {
            self.identity_provider = Some(input);
            self
        }
        /// <p>An object that specifies details for the identity provider.</p>
        pub fn set_identity_provider(mut self, input: std::option::Option<crate::model::IdentityProvider>) -> Self {
            self.identity_provider = input; self
        }
        /// <p>The name of the user-based subscription product.</p>
        pub fn product(mut self, input: impl Into<std::string::String>) -> Self {
            self.product = Some(input.into());
            self
        }
        /// <p>The name of the user-based subscription product.</p>
        pub fn set_product(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.product = input; self
        }
        /// <p>The domain name of the user.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p>The domain name of the user.</p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input; self
        }
        /// Consumes the builder and constructs a [`StartProductSubscriptionInput`](crate::input::StartProductSubscriptionInput).
        pub fn build(self) -> Result<crate::input::StartProductSubscriptionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::StartProductSubscriptionInput {
                    username: self.username
                    ,
                    identity_provider: self.identity_provider
                    ,
                    product: self.product
                    ,
                    domain: self.domain
                    ,
                }
            )
        }
    }
    
    
}
impl StartProductSubscriptionInput {
    /// Consumes the builder and constructs an Operation<[`StartProductSubscription`](crate::operation::StartProductSubscription)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::StartProductSubscription, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::StartProductSubscriptionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/user/StartProductSubscription").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::StartProductSubscriptionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_start_product_subscription(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::StartProductSubscription::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("StartProductSubscription", "licensemanagerusersubscriptions"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`StartProductSubscriptionInput`](crate::input::StartProductSubscriptionInput).
    pub fn builder() -> crate::input::start_product_subscription_input::Builder {
        crate::input::start_product_subscription_input::Builder::default()
    }
}

/// See [`StopProductSubscriptionInput`](crate::input::StopProductSubscriptionInput).
pub mod stop_product_subscription_input {
    
    /// A builder for [`StopProductSubscriptionInput`](crate::input::StopProductSubscriptionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) username: std::option::Option<std::string::String>,
        pub(crate) identity_provider: std::option::Option<crate::model::IdentityProvider>,
        pub(crate) product: std::option::Option<std::string::String>,
        pub(crate) domain: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The user name from the identity provider for the user.</p>
        pub fn username(mut self, input: impl Into<std::string::String>) -> Self {
            self.username = Some(input.into());
            self
        }
        /// <p>The user name from the identity provider for the user.</p>
        pub fn set_username(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.username = input; self
        }
        /// <p>An object that specifies details for the identity provider.</p>
        pub fn identity_provider(mut self, input: crate::model::IdentityProvider) -> Self {
            self.identity_provider = Some(input);
            self
        }
        /// <p>An object that specifies details for the identity provider.</p>
        pub fn set_identity_provider(mut self, input: std::option::Option<crate::model::IdentityProvider>) -> Self {
            self.identity_provider = input; self
        }
        /// <p>The name of the user-based subscription product.</p>
        pub fn product(mut self, input: impl Into<std::string::String>) -> Self {
            self.product = Some(input.into());
            self
        }
        /// <p>The name of the user-based subscription product.</p>
        pub fn set_product(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.product = input; self
        }
        /// <p>The domain name of the user.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p>The domain name of the user.</p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input; self
        }
        /// Consumes the builder and constructs a [`StopProductSubscriptionInput`](crate::input::StopProductSubscriptionInput).
        pub fn build(self) -> Result<crate::input::StopProductSubscriptionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::StopProductSubscriptionInput {
                    username: self.username
                    ,
                    identity_provider: self.identity_provider
                    ,
                    product: self.product
                    ,
                    domain: self.domain
                    ,
                }
            )
        }
    }
    
    
}
impl StopProductSubscriptionInput {
    /// Consumes the builder and constructs an Operation<[`StopProductSubscription`](crate::operation::StopProductSubscription)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::StopProductSubscription, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::StopProductSubscriptionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/user/StopProductSubscription").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::StopProductSubscriptionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_stop_product_subscription(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::StopProductSubscription::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("StopProductSubscription", "licensemanagerusersubscriptions"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`StopProductSubscriptionInput`](crate::input::StopProductSubscriptionInput).
    pub fn builder() -> crate::input::stop_product_subscription_input::Builder {
        crate::input::stop_product_subscription_input::Builder::default()
    }
}

/// See [`UpdateIdentityProviderSettingsInput`](crate::input::UpdateIdentityProviderSettingsInput).
pub mod update_identity_provider_settings_input {
    
    /// A builder for [`UpdateIdentityProviderSettingsInput`](crate::input::UpdateIdentityProviderSettingsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) identity_provider: std::option::Option<crate::model::IdentityProvider>,
        pub(crate) product: std::option::Option<std::string::String>,
        pub(crate) update_settings: std::option::Option<crate::model::UpdateSettings>,
    }
    impl Builder {
        /// <p>Details about an identity provider.</p>
        pub fn identity_provider(mut self, input: crate::model::IdentityProvider) -> Self {
            self.identity_provider = Some(input);
            self
        }
        /// <p>Details about an identity provider.</p>
        pub fn set_identity_provider(mut self, input: std::option::Option<crate::model::IdentityProvider>) -> Self {
            self.identity_provider = input; self
        }
        /// <p>The name of the user-based subscription product.</p>
        pub fn product(mut self, input: impl Into<std::string::String>) -> Self {
            self.product = Some(input.into());
            self
        }
        /// <p>The name of the user-based subscription product.</p>
        pub fn set_product(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.product = input; self
        }
        /// <p>Updates the registered identity providers product related configuration settings. You can update any combination of settings in a single operation such as the:</p> 
        /// <ul> 
        /// <li> <p>Subnets which you want to add to provision VPC endpoints.</p> </li> 
        /// <li> <p>Subnets which you want to remove the VPC endpoints from.</p> </li> 
        /// <li> <p>Security group ID which permits traffic to the VPC endpoints.</p> </li> 
        /// </ul>
        pub fn update_settings(mut self, input: crate::model::UpdateSettings) -> Self {
            self.update_settings = Some(input);
            self
        }
        /// <p>Updates the registered identity providers product related configuration settings. You can update any combination of settings in a single operation such as the:</p> 
        /// <ul> 
        /// <li> <p>Subnets which you want to add to provision VPC endpoints.</p> </li> 
        /// <li> <p>Subnets which you want to remove the VPC endpoints from.</p> </li> 
        /// <li> <p>Security group ID which permits traffic to the VPC endpoints.</p> </li> 
        /// </ul>
        pub fn set_update_settings(mut self, input: std::option::Option<crate::model::UpdateSettings>) -> Self {
            self.update_settings = input; self
        }
        /// Consumes the builder and constructs a [`UpdateIdentityProviderSettingsInput`](crate::input::UpdateIdentityProviderSettingsInput).
        pub fn build(self) -> Result<crate::input::UpdateIdentityProviderSettingsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateIdentityProviderSettingsInput {
                    identity_provider: self.identity_provider
                    ,
                    product: self.product
                    ,
                    update_settings: self.update_settings
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateIdentityProviderSettingsInput {
    /// Consumes the builder and constructs an Operation<[`UpdateIdentityProviderSettings`](crate::operation::UpdateIdentityProviderSettings)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateIdentityProviderSettings, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateIdentityProviderSettingsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/identity-provider/UpdateIdentityProviderSettings").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateIdentityProviderSettingsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_identity_provider_settings(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateIdentityProviderSettings::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateIdentityProviderSettings", "licensemanagerusersubscriptions"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateIdentityProviderSettingsInput`](crate::input::UpdateIdentityProviderSettingsInput).
    pub fn builder() -> crate::input::update_identity_provider_settings_input::Builder {
        crate::input::update_identity_provider_settings_input::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateIdentityProviderSettingsInput  {
    /// <p>Details about an identity provider.</p>
    #[doc(hidden)]
    pub identity_provider: std::option::Option<crate::model::IdentityProvider>,
    /// <p>The name of the user-based subscription product.</p>
    #[doc(hidden)]
    pub product: std::option::Option<std::string::String>,
    /// <p>Updates the registered identity providers product related configuration settings. You can update any combination of settings in a single operation such as the:</p> 
    /// <ul> 
    /// <li> <p>Subnets which you want to add to provision VPC endpoints.</p> </li> 
    /// <li> <p>Subnets which you want to remove the VPC endpoints from.</p> </li> 
    /// <li> <p>Security group ID which permits traffic to the VPC endpoints.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub update_settings: std::option::Option<crate::model::UpdateSettings>,
}
impl UpdateIdentityProviderSettingsInput {
    /// <p>Details about an identity provider.</p>
    pub fn identity_provider(&self) -> std::option::Option<& crate::model::IdentityProvider> {
        self.identity_provider.as_ref()
    }
    /// <p>The name of the user-based subscription product.</p>
    pub fn product(&self) -> std::option::Option<& str> {
        self.product.as_deref()
    }
    /// <p>Updates the registered identity providers product related configuration settings. You can update any combination of settings in a single operation such as the:</p> 
    /// <ul> 
    /// <li> <p>Subnets which you want to add to provision VPC endpoints.</p> </li> 
    /// <li> <p>Subnets which you want to remove the VPC endpoints from.</p> </li> 
    /// <li> <p>Security group ID which permits traffic to the VPC endpoints.</p> </li> 
    /// </ul>
    pub fn update_settings(&self) -> std::option::Option<& crate::model::UpdateSettings> {
        self.update_settings.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StopProductSubscriptionInput  {
    /// <p>The user name from the identity provider for the user.</p>
    #[doc(hidden)]
    pub username: std::option::Option<std::string::String>,
    /// <p>An object that specifies details for the identity provider.</p>
    #[doc(hidden)]
    pub identity_provider: std::option::Option<crate::model::IdentityProvider>,
    /// <p>The name of the user-based subscription product.</p>
    #[doc(hidden)]
    pub product: std::option::Option<std::string::String>,
    /// <p>The domain name of the user.</p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
}
impl StopProductSubscriptionInput {
    /// <p>The user name from the identity provider for the user.</p>
    pub fn username(&self) -> std::option::Option<& str> {
        self.username.as_deref()
    }
    /// <p>An object that specifies details for the identity provider.</p>
    pub fn identity_provider(&self) -> std::option::Option<& crate::model::IdentityProvider> {
        self.identity_provider.as_ref()
    }
    /// <p>The name of the user-based subscription product.</p>
    pub fn product(&self) -> std::option::Option<& str> {
        self.product.as_deref()
    }
    /// <p>The domain name of the user.</p>
    pub fn domain(&self) -> std::option::Option<& str> {
        self.domain.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StartProductSubscriptionInput  {
    /// <p>The user name from the identity provider of the user.</p>
    #[doc(hidden)]
    pub username: std::option::Option<std::string::String>,
    /// <p>An object that specifies details for the identity provider.</p>
    #[doc(hidden)]
    pub identity_provider: std::option::Option<crate::model::IdentityProvider>,
    /// <p>The name of the user-based subscription product.</p>
    #[doc(hidden)]
    pub product: std::option::Option<std::string::String>,
    /// <p>The domain name of the user.</p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
}
impl StartProductSubscriptionInput {
    /// <p>The user name from the identity provider of the user.</p>
    pub fn username(&self) -> std::option::Option<& str> {
        self.username.as_deref()
    }
    /// <p>An object that specifies details for the identity provider.</p>
    pub fn identity_provider(&self) -> std::option::Option<& crate::model::IdentityProvider> {
        self.identity_provider.as_ref()
    }
    /// <p>The name of the user-based subscription product.</p>
    pub fn product(&self) -> std::option::Option<& str> {
        self.product.as_deref()
    }
    /// <p>The domain name of the user.</p>
    pub fn domain(&self) -> std::option::Option<& str> {
        self.domain.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RegisterIdentityProviderInput  {
    /// <p>An object that specifies details for the identity provider.</p>
    #[doc(hidden)]
    pub identity_provider: std::option::Option<crate::model::IdentityProvider>,
    /// <p>The name of the user-based subscription product.</p>
    #[doc(hidden)]
    pub product: std::option::Option<std::string::String>,
    /// <p>The registered identity providers product related configuration settings such as the subnets to provision VPC endpoints.</p>
    #[doc(hidden)]
    pub settings: std::option::Option<crate::model::Settings>,
}
impl RegisterIdentityProviderInput {
    /// <p>An object that specifies details for the identity provider.</p>
    pub fn identity_provider(&self) -> std::option::Option<& crate::model::IdentityProvider> {
        self.identity_provider.as_ref()
    }
    /// <p>The name of the user-based subscription product.</p>
    pub fn product(&self) -> std::option::Option<& str> {
        self.product.as_deref()
    }
    /// <p>The registered identity providers product related configuration settings such as the subnets to provision VPC endpoints.</p>
    pub fn settings(&self) -> std::option::Option<& crate::model::Settings> {
        self.settings.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListUserAssociationsInput  {
    /// <p>The ID of the EC2 instance, which provides user-based subscriptions.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>An object that specifies details for the identity provider.</p>
    #[doc(hidden)]
    pub identity_provider: std::option::Option<crate::model::IdentityProvider>,
    /// <p>Maximum number of results to return in a single call.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>An array of structures that you can use to filter the results to those that match one or more sets of key-value pairs that you specify.</p>
    #[doc(hidden)]
    pub filters: std::option::Option<std::vec::Vec<crate::model::Filter>>,
    /// <p>Token for the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListUserAssociationsInput {
    /// <p>The ID of the EC2 instance, which provides user-based subscriptions.</p>
    pub fn instance_id(&self) -> std::option::Option<& str> {
        self.instance_id.as_deref()
    }
    /// <p>An object that specifies details for the identity provider.</p>
    pub fn identity_provider(&self) -> std::option::Option<& crate::model::IdentityProvider> {
        self.identity_provider.as_ref()
    }
    /// <p>Maximum number of results to return in a single call.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>An array of structures that you can use to filter the results to those that match one or more sets of key-value pairs that you specify.</p>
    pub fn filters(&self) -> std::option::Option<& [crate::model::Filter]> {
        self.filters.as_deref()
    }
    /// <p>Token for the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListProductSubscriptionsInput  {
    /// <p>The name of the user-based subscription product.</p>
    #[doc(hidden)]
    pub product: std::option::Option<std::string::String>,
    /// <p>An object that specifies details for the identity provider.</p>
    #[doc(hidden)]
    pub identity_provider: std::option::Option<crate::model::IdentityProvider>,
    /// <p>Maximum number of results to return in a single call.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>An array of structures that you can use to filter the results to those that match one or more sets of key-value pairs that you specify.</p>
    #[doc(hidden)]
    pub filters: std::option::Option<std::vec::Vec<crate::model::Filter>>,
    /// <p>Token for the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListProductSubscriptionsInput {
    /// <p>The name of the user-based subscription product.</p>
    pub fn product(&self) -> std::option::Option<& str> {
        self.product.as_deref()
    }
    /// <p>An object that specifies details for the identity provider.</p>
    pub fn identity_provider(&self) -> std::option::Option<& crate::model::IdentityProvider> {
        self.identity_provider.as_ref()
    }
    /// <p>Maximum number of results to return in a single call.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>An array of structures that you can use to filter the results to those that match one or more sets of key-value pairs that you specify.</p>
    pub fn filters(&self) -> std::option::Option<& [crate::model::Filter]> {
        self.filters.as_deref()
    }
    /// <p>Token for the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListInstancesInput  {
    /// <p>Maximum number of results to return in a single call.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>Token for the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>An array of structures that you can use to filter the results to those that match one or more sets of key-value pairs that you specify.</p>
    #[doc(hidden)]
    pub filters: std::option::Option<std::vec::Vec<crate::model::Filter>>,
}
impl ListInstancesInput {
    /// <p>Maximum number of results to return in a single call.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>Token for the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>An array of structures that you can use to filter the results to those that match one or more sets of key-value pairs that you specify.</p>
    pub fn filters(&self) -> std::option::Option<& [crate::model::Filter]> {
        self.filters.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListIdentityProvidersInput  {
    /// <p>Maximum number of results to return in a single call.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>Token for the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListIdentityProvidersInput {
    /// <p>Maximum number of results to return in a single call.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>Token for the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DisassociateUserInput  {
    /// <p>The user name from the identity provider for the user.</p>
    #[doc(hidden)]
    pub username: std::option::Option<std::string::String>,
    /// <p>The ID of the EC2 instance, which provides user-based subscriptions.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>An object that specifies details for the identity provider.</p>
    #[doc(hidden)]
    pub identity_provider: std::option::Option<crate::model::IdentityProvider>,
    /// <p>The domain name of the user.</p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
}
impl DisassociateUserInput {
    /// <p>The user name from the identity provider for the user.</p>
    pub fn username(&self) -> std::option::Option<& str> {
        self.username.as_deref()
    }
    /// <p>The ID of the EC2 instance, which provides user-based subscriptions.</p>
    pub fn instance_id(&self) -> std::option::Option<& str> {
        self.instance_id.as_deref()
    }
    /// <p>An object that specifies details for the identity provider.</p>
    pub fn identity_provider(&self) -> std::option::Option<& crate::model::IdentityProvider> {
        self.identity_provider.as_ref()
    }
    /// <p>The domain name of the user.</p>
    pub fn domain(&self) -> std::option::Option<& str> {
        self.domain.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeregisterIdentityProviderInput  {
    /// <p>An object that specifies details for the identity provider.</p>
    #[doc(hidden)]
    pub identity_provider: std::option::Option<crate::model::IdentityProvider>,
    /// <p>The name of the user-based subscription product.</p>
    #[doc(hidden)]
    pub product: std::option::Option<std::string::String>,
}
impl DeregisterIdentityProviderInput {
    /// <p>An object that specifies details for the identity provider.</p>
    pub fn identity_provider(&self) -> std::option::Option<& crate::model::IdentityProvider> {
        self.identity_provider.as_ref()
    }
    /// <p>The name of the user-based subscription product.</p>
    pub fn product(&self) -> std::option::Option<& str> {
        self.product.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssociateUserInput  {
    /// <p>The user name from the identity provider for the user.</p>
    #[doc(hidden)]
    pub username: std::option::Option<std::string::String>,
    /// <p>The ID of the EC2 instance, which provides user-based subscriptions.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The identity provider of the user.</p>
    #[doc(hidden)]
    pub identity_provider: std::option::Option<crate::model::IdentityProvider>,
    /// <p>The domain name of the user.</p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
}
impl AssociateUserInput {
    /// <p>The user name from the identity provider for the user.</p>
    pub fn username(&self) -> std::option::Option<& str> {
        self.username.as_deref()
    }
    /// <p>The ID of the EC2 instance, which provides user-based subscriptions.</p>
    pub fn instance_id(&self) -> std::option::Option<& str> {
        self.instance_id.as_deref()
    }
    /// <p>The identity provider of the user.</p>
    pub fn identity_provider(&self) -> std::option::Option<& crate::model::IdentityProvider> {
        self.identity_provider.as_ref()
    }
    /// <p>The domain name of the user.</p>
    pub fn domain(&self) -> std::option::Option<& str> {
        self.domain.as_deref()
    }
}

