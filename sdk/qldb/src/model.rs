// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LedgerState {
    Active,
    Creating,
    Deleted,
    Deleting,
    Unknown(String),
}
impl std::convert::From<&str> for LedgerState {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => LedgerState::Active,
            "CREATING" => LedgerState::Creating,
            "DELETED" => LedgerState::Deleted,
            "DELETING" => LedgerState::Deleting,
            other => LedgerState::Unknown(other.to_owned()),
        }
    }
}

impl std::str::FromStr for LedgerState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(LedgerState::from(s))
    }
}

impl LedgerState {
    pub fn as_str(&self) -> &str {
        match self {
            LedgerState::Active => "ACTIVE",
            LedgerState::Creating => "CREATING",
            LedgerState::Deleted => "DELETED",
            LedgerState::Deleting => "DELETING",
            LedgerState::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for LedgerState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl serde::Serialize for LedgerState {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::Serializer>::Ok, <S as serde::Serializer>::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(self.as_str())
    }
}

impl<'de> serde::Deserialize<'de> for LedgerState {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>The configuration settings of the Amazon Kinesis Data Streams destination for your Amazon QLDB journal
/// stream.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct KinesisConfiguration {
    /// <p>The Amazon Resource Name (ARN) of the Kinesis data stream resource.</p>
    #[serde(rename = "StreamArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub stream_arn: std::option::Option<std::string::String>,
    /// <p>Enables QLDB to publish multiple data records in a single Kinesis Data Streams record. To learn more,
    /// see <a href="https://docs.aws.amazon.com/streams/latest/dev/kinesis-kpl-concepts.html">KPL Key
    /// Concepts</a> in the <i>Amazon Kinesis Data Streams Developer Guide</i>.</p>
    #[serde(rename = "AggregationEnabled")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub aggregation_enabled: std::option::Option<bool>,
}
impl std::fmt::Debug for KinesisConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KinesisConfiguration");
        formatter.field("stream_arn", &self.stream_arn);
        formatter.field("aggregation_enabled", &self.aggregation_enabled);
        formatter.finish()
    }
}
/// See [`KinesisConfiguration`](crate::model::KinesisConfiguration)
pub mod kinesis_configuration {
    /// A builder for [`KinesisConfiguration`](crate::model::KinesisConfiguration)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        stream_arn: std::option::Option<std::string::String>,
        aggregation_enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the Kinesis data stream resource.</p>
        pub fn stream_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stream_arn = Some(inp.into());
            self
        }
        pub fn set_stream_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stream_arn = inp;
            self
        }
        /// <p>Enables QLDB to publish multiple data records in a single Kinesis Data Streams record. To learn more,
        /// see <a href="https://docs.aws.amazon.com/streams/latest/dev/kinesis-kpl-concepts.html">KPL Key
        /// Concepts</a> in the <i>Amazon Kinesis Data Streams Developer Guide</i>.</p>
        pub fn aggregation_enabled(mut self, inp: bool) -> Self {
            self.aggregation_enabled = Some(inp);
            self
        }
        pub fn set_aggregation_enabled(mut self, inp: std::option::Option<bool>) -> Self {
            self.aggregation_enabled = inp;
            self
        }
        /// Consumes the builder and constructs a [`KinesisConfiguration`](crate::model::KinesisConfiguration)
        pub fn build(self) -> crate::model::KinesisConfiguration {
            crate::model::KinesisConfiguration {
                stream_arn: self.stream_arn,
                aggregation_enabled: self.aggregation_enabled,
            }
        }
    }
}
impl KinesisConfiguration {
    /// Creates a new builder-style object to manufacture [`KinesisConfiguration`](crate::model::KinesisConfiguration)
    pub fn builder() -> crate::model::kinesis_configuration::Builder {
        crate::model::kinesis_configuration::Builder::default()
    }
}

/// <p>Information about a ledger, including its name, state, and when it was created.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct LedgerSummary {
    /// <p>The name of the ledger.</p>
    #[serde(rename = "Name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The current status of the ledger.</p>
    #[serde(rename = "State")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub state: std::option::Option<crate::model::LedgerState>,
    /// <p>The date and time, in epoch time format, when the ledger was created. (Epoch time format
    /// is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC.)</p>
    #[serde(rename = "CreationDateTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(
        serialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_ser"
    )]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_date_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for LedgerSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LedgerSummary");
        formatter.field("name", &self.name);
        formatter.field("state", &self.state);
        formatter.field("creation_date_time", &self.creation_date_time);
        formatter.finish()
    }
}
/// See [`LedgerSummary`](crate::model::LedgerSummary)
pub mod ledger_summary {
    /// A builder for [`LedgerSummary`](crate::model::LedgerSummary)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        name: std::option::Option<std::string::String>,
        state: std::option::Option<crate::model::LedgerState>,
        creation_date_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The name of the ledger.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.name = Some(inp.into());
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.name = inp;
            self
        }
        /// <p>The current status of the ledger.</p>
        pub fn state(mut self, inp: crate::model::LedgerState) -> Self {
            self.state = Some(inp);
            self
        }
        pub fn set_state(mut self, inp: std::option::Option<crate::model::LedgerState>) -> Self {
            self.state = inp;
            self
        }
        /// <p>The date and time, in epoch time format, when the ledger was created. (Epoch time format
        /// is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC.)</p>
        pub fn creation_date_time(mut self, inp: smithy_types::Instant) -> Self {
            self.creation_date_time = Some(inp);
            self
        }
        pub fn set_creation_date_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_date_time = inp;
            self
        }
        /// Consumes the builder and constructs a [`LedgerSummary`](crate::model::LedgerSummary)
        pub fn build(self) -> crate::model::LedgerSummary {
            crate::model::LedgerSummary {
                name: self.name,
                state: self.state,
                creation_date_time: self.creation_date_time,
            }
        }
    }
}
impl LedgerSummary {
    /// Creates a new builder-style object to manufacture [`LedgerSummary`](crate::model::LedgerSummary)
    pub fn builder() -> crate::model::ledger_summary::Builder {
        crate::model::ledger_summary::Builder::default()
    }
}

/// <p>The information about a journal export job, including the ledger name, export ID, when
/// it was created, current status, and its start and end time export parameters.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct JournalS3ExportDescription {
    /// <p>The name of the ledger.</p>
    #[serde(rename = "LedgerName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub ledger_name: std::option::Option<std::string::String>,
    /// <p>The unique ID of the journal export job.</p>
    #[serde(rename = "ExportId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub export_id: std::option::Option<std::string::String>,
    /// <p>The date and time, in epoch time format, when the export job was created. (Epoch time
    /// format is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC.)</p>
    #[serde(rename = "ExportCreationTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(
        serialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_ser"
    )]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub export_creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The current state of the journal export job.</p>
    #[serde(rename = "Status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub status: std::option::Option<crate::model::ExportStatus>,
    /// <p>The inclusive start date and time for the range of journal contents that are specified
    /// in the original export request.</p>
    #[serde(rename = "InclusiveStartTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(
        serialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_ser"
    )]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub inclusive_start_time: std::option::Option<smithy_types::Instant>,
    /// <p>The exclusive end date and time for the range of journal contents that are specified in
    /// the original export request.</p>
    #[serde(rename = "ExclusiveEndTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(
        serialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_ser"
    )]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub exclusive_end_time: std::option::Option<smithy_types::Instant>,
    /// <p>The Amazon Simple Storage Service (Amazon S3) bucket location in which a journal export job writes the journal
    /// contents.</p>
    #[serde(rename = "S3ExportConfiguration")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub s3_export_configuration: std::option::Option<crate::model::S3ExportConfiguration>,
    /// <p>The Amazon Resource Name (ARN) of the IAM role that grants QLDB permissions for a
    /// journal export job to do the following:</p>
    /// <ul>
    /// <li>
    /// <p>Write objects into your Amazon Simple Storage Service (Amazon S3) bucket.</p>
    /// </li>
    /// <li>
    /// <p>(Optional) Use your customer master key (CMK) in AWS Key Management Service (AWS
    /// KMS) for server-side encryption of your exported data.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "RoleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub role_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for JournalS3ExportDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("JournalS3ExportDescription");
        formatter.field("ledger_name", &self.ledger_name);
        formatter.field("export_id", &self.export_id);
        formatter.field("export_creation_time", &self.export_creation_time);
        formatter.field("status", &self.status);
        formatter.field("inclusive_start_time", &self.inclusive_start_time);
        formatter.field("exclusive_end_time", &self.exclusive_end_time);
        formatter.field("s3_export_configuration", &self.s3_export_configuration);
        formatter.field("role_arn", &self.role_arn);
        formatter.finish()
    }
}
/// See [`JournalS3ExportDescription`](crate::model::JournalS3ExportDescription)
pub mod journal_s3_export_description {
    /// A builder for [`JournalS3ExportDescription`](crate::model::JournalS3ExportDescription)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        ledger_name: std::option::Option<std::string::String>,
        export_id: std::option::Option<std::string::String>,
        export_creation_time: std::option::Option<smithy_types::Instant>,
        status: std::option::Option<crate::model::ExportStatus>,
        inclusive_start_time: std::option::Option<smithy_types::Instant>,
        exclusive_end_time: std::option::Option<smithy_types::Instant>,
        s3_export_configuration: std::option::Option<crate::model::S3ExportConfiguration>,
        role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the ledger.</p>
        pub fn ledger_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.ledger_name = Some(inp.into());
            self
        }
        pub fn set_ledger_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.ledger_name = inp;
            self
        }
        /// <p>The unique ID of the journal export job.</p>
        pub fn export_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.export_id = Some(inp.into());
            self
        }
        pub fn set_export_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.export_id = inp;
            self
        }
        /// <p>The date and time, in epoch time format, when the export job was created. (Epoch time
        /// format is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC.)</p>
        pub fn export_creation_time(mut self, inp: smithy_types::Instant) -> Self {
            self.export_creation_time = Some(inp);
            self
        }
        pub fn set_export_creation_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.export_creation_time = inp;
            self
        }
        /// <p>The current state of the journal export job.</p>
        pub fn status(mut self, inp: crate::model::ExportStatus) -> Self {
            self.status = Some(inp);
            self
        }
        pub fn set_status(mut self, inp: std::option::Option<crate::model::ExportStatus>) -> Self {
            self.status = inp;
            self
        }
        /// <p>The inclusive start date and time for the range of journal contents that are specified
        /// in the original export request.</p>
        pub fn inclusive_start_time(mut self, inp: smithy_types::Instant) -> Self {
            self.inclusive_start_time = Some(inp);
            self
        }
        pub fn set_inclusive_start_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inclusive_start_time = inp;
            self
        }
        /// <p>The exclusive end date and time for the range of journal contents that are specified in
        /// the original export request.</p>
        pub fn exclusive_end_time(mut self, inp: smithy_types::Instant) -> Self {
            self.exclusive_end_time = Some(inp);
            self
        }
        pub fn set_exclusive_end_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.exclusive_end_time = inp;
            self
        }
        /// <p>The Amazon Simple Storage Service (Amazon S3) bucket location in which a journal export job writes the journal
        /// contents.</p>
        pub fn s3_export_configuration(mut self, inp: crate::model::S3ExportConfiguration) -> Self {
            self.s3_export_configuration = Some(inp);
            self
        }
        pub fn set_s3_export_configuration(
            mut self,
            inp: std::option::Option<crate::model::S3ExportConfiguration>,
        ) -> Self {
            self.s3_export_configuration = inp;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM role that grants QLDB permissions for a
        /// journal export job to do the following:</p>
        /// <ul>
        /// <li>
        /// <p>Write objects into your Amazon Simple Storage Service (Amazon S3) bucket.</p>
        /// </li>
        /// <li>
        /// <p>(Optional) Use your customer master key (CMK) in AWS Key Management Service (AWS
        /// KMS) for server-side encryption of your exported data.</p>
        /// </li>
        /// </ul>
        pub fn role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(inp.into());
            self
        }
        pub fn set_role_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.role_arn = inp;
            self
        }
        /// Consumes the builder and constructs a [`JournalS3ExportDescription`](crate::model::JournalS3ExportDescription)
        pub fn build(self) -> crate::model::JournalS3ExportDescription {
            crate::model::JournalS3ExportDescription {
                ledger_name: self.ledger_name,
                export_id: self.export_id,
                export_creation_time: self.export_creation_time,
                status: self.status,
                inclusive_start_time: self.inclusive_start_time,
                exclusive_end_time: self.exclusive_end_time,
                s3_export_configuration: self.s3_export_configuration,
                role_arn: self.role_arn,
            }
        }
    }
}
impl JournalS3ExportDescription {
    /// Creates a new builder-style object to manufacture [`JournalS3ExportDescription`](crate::model::JournalS3ExportDescription)
    pub fn builder() -> crate::model::journal_s3_export_description::Builder {
        crate::model::journal_s3_export_description::Builder::default()
    }
}

/// <p>The Amazon Simple Storage Service (Amazon S3) bucket location in which a journal export job writes the journal
/// contents.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct S3ExportConfiguration {
    /// <p>The Amazon S3 bucket name in which a journal export job writes the journal contents.</p>
    /// <p>The bucket name must comply with the Amazon S3 bucket naming conventions. For more
    /// information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html">Bucket Restrictions and
    /// Limitations</a> in the <i>Amazon S3 Developer Guide</i>.</p>
    #[serde(rename = "Bucket")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The prefix for the Amazon S3 bucket in which a journal export job writes the journal
    /// contents.</p>
    /// <p>The prefix must comply with Amazon S3 key naming rules and restrictions. For more
    /// information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html">Object Key and Metadata</a> in the <i>Amazon S3 Developer
    /// Guide</i>.</p>
    /// <p>The following are examples of valid <code>Prefix</code> values:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>JournalExports-ForMyLedger/Testing/</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>JournalExports</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>My:Tests/</code>
    /// </p>
    /// </li>
    /// </ul>
    #[serde(rename = "Prefix")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub prefix: std::option::Option<std::string::String>,
    /// <p>The encryption settings that are used by a journal export job to write data in an Amazon S3
    /// bucket.</p>
    #[serde(rename = "EncryptionConfiguration")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub encryption_configuration: std::option::Option<crate::model::S3EncryptionConfiguration>,
}
impl std::fmt::Debug for S3ExportConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("S3ExportConfiguration");
        formatter.field("bucket", &self.bucket);
        formatter.field("prefix", &self.prefix);
        formatter.field("encryption_configuration", &self.encryption_configuration);
        formatter.finish()
    }
}
/// See [`S3ExportConfiguration`](crate::model::S3ExportConfiguration)
pub mod s3_export_configuration {
    /// A builder for [`S3ExportConfiguration`](crate::model::S3ExportConfiguration)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        bucket: std::option::Option<std::string::String>,
        prefix: std::option::Option<std::string::String>,
        encryption_configuration: std::option::Option<crate::model::S3EncryptionConfiguration>,
    }
    impl Builder {
        /// <p>The Amazon S3 bucket name in which a journal export job writes the journal contents.</p>
        /// <p>The bucket name must comply with the Amazon S3 bucket naming conventions. For more
        /// information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html">Bucket Restrictions and
        /// Limitations</a> in the <i>Amazon S3 Developer Guide</i>.</p>
        pub fn bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.bucket = Some(inp.into());
            self
        }
        pub fn set_bucket(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.bucket = inp;
            self
        }
        /// <p>The prefix for the Amazon S3 bucket in which a journal export job writes the journal
        /// contents.</p>
        /// <p>The prefix must comply with Amazon S3 key naming rules and restrictions. For more
        /// information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html">Object Key and Metadata</a> in the <i>Amazon S3 Developer
        /// Guide</i>.</p>
        /// <p>The following are examples of valid <code>Prefix</code> values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>JournalExports-ForMyLedger/Testing/</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>JournalExports</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>My:Tests/</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn prefix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.prefix = Some(inp.into());
            self
        }
        pub fn set_prefix(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.prefix = inp;
            self
        }
        /// <p>The encryption settings that are used by a journal export job to write data in an Amazon S3
        /// bucket.</p>
        pub fn encryption_configuration(
            mut self,
            inp: crate::model::S3EncryptionConfiguration,
        ) -> Self {
            self.encryption_configuration = Some(inp);
            self
        }
        pub fn set_encryption_configuration(
            mut self,
            inp: std::option::Option<crate::model::S3EncryptionConfiguration>,
        ) -> Self {
            self.encryption_configuration = inp;
            self
        }
        /// Consumes the builder and constructs a [`S3ExportConfiguration`](crate::model::S3ExportConfiguration)
        pub fn build(self) -> crate::model::S3ExportConfiguration {
            crate::model::S3ExportConfiguration {
                bucket: self.bucket,
                prefix: self.prefix,
                encryption_configuration: self.encryption_configuration,
            }
        }
    }
}
impl S3ExportConfiguration {
    /// Creates a new builder-style object to manufacture [`S3ExportConfiguration`](crate::model::S3ExportConfiguration)
    pub fn builder() -> crate::model::s3_export_configuration::Builder {
        crate::model::s3_export_configuration::Builder::default()
    }
}

/// <p>The encryption settings that are used by a journal export job to write data in an
/// Amazon Simple Storage Service (Amazon S3) bucket.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct S3EncryptionConfiguration {
    /// <p>The Amazon S3 object encryption type.</p>
    /// <p>To learn more about server-side encryption options in Amazon S3, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/serv-side-encryption.html">Protecting Data
    /// Using Server-Side Encryption</a> in the <i>Amazon S3 Developer
    /// Guide</i>.</p>
    #[serde(rename = "ObjectEncryptionType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub object_encryption_type: std::option::Option<crate::model::S3ObjectEncryptionType>,
    /// <p>The Amazon Resource Name (ARN) for a symmetric customer master key (CMK) in AWS Key
    /// Management Service (AWS KMS). Amazon QLDB does not support asymmetric CMKs.</p>
    /// <p>You must provide a <code>KmsKeyArn</code> if you specify <code>SSE_KMS</code> as the
    /// <code>ObjectEncryptionType</code>.</p>
    /// <p>
    /// <code>KmsKeyArn</code> is not required if you specify <code>SSE_S3</code> as the
    /// <code>ObjectEncryptionType</code>.</p>
    #[serde(rename = "KmsKeyArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub kms_key_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for S3EncryptionConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("S3EncryptionConfiguration");
        formatter.field("object_encryption_type", &self.object_encryption_type);
        formatter.field("kms_key_arn", &self.kms_key_arn);
        formatter.finish()
    }
}
/// See [`S3EncryptionConfiguration`](crate::model::S3EncryptionConfiguration)
pub mod s3_encryption_configuration {
    /// A builder for [`S3EncryptionConfiguration`](crate::model::S3EncryptionConfiguration)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        object_encryption_type: std::option::Option<crate::model::S3ObjectEncryptionType>,
        kms_key_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 object encryption type.</p>
        /// <p>To learn more about server-side encryption options in Amazon S3, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/serv-side-encryption.html">Protecting Data
        /// Using Server-Side Encryption</a> in the <i>Amazon S3 Developer
        /// Guide</i>.</p>
        pub fn object_encryption_type(mut self, inp: crate::model::S3ObjectEncryptionType) -> Self {
            self.object_encryption_type = Some(inp);
            self
        }
        pub fn set_object_encryption_type(
            mut self,
            inp: std::option::Option<crate::model::S3ObjectEncryptionType>,
        ) -> Self {
            self.object_encryption_type = inp;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for a symmetric customer master key (CMK) in AWS Key
        /// Management Service (AWS KMS). Amazon QLDB does not support asymmetric CMKs.</p>
        /// <p>You must provide a <code>KmsKeyArn</code> if you specify <code>SSE_KMS</code> as the
        /// <code>ObjectEncryptionType</code>.</p>
        /// <p>
        /// <code>KmsKeyArn</code> is not required if you specify <code>SSE_S3</code> as the
        /// <code>ObjectEncryptionType</code>.</p>
        pub fn kms_key_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.kms_key_arn = Some(inp.into());
            self
        }
        pub fn set_kms_key_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.kms_key_arn = inp;
            self
        }
        /// Consumes the builder and constructs a [`S3EncryptionConfiguration`](crate::model::S3EncryptionConfiguration)
        pub fn build(self) -> crate::model::S3EncryptionConfiguration {
            crate::model::S3EncryptionConfiguration {
                object_encryption_type: self.object_encryption_type,
                kms_key_arn: self.kms_key_arn,
            }
        }
    }
}
impl S3EncryptionConfiguration {
    /// Creates a new builder-style object to manufacture [`S3EncryptionConfiguration`](crate::model::S3EncryptionConfiguration)
    pub fn builder() -> crate::model::s3_encryption_configuration::Builder {
        crate::model::s3_encryption_configuration::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum S3ObjectEncryptionType {
    NoEncryption,
    SseKms,
    SseS3,
    Unknown(String),
}
impl std::convert::From<&str> for S3ObjectEncryptionType {
    fn from(s: &str) -> Self {
        match s {
            "NO_ENCRYPTION" => S3ObjectEncryptionType::NoEncryption,
            "SSE_KMS" => S3ObjectEncryptionType::SseKms,
            "SSE_S3" => S3ObjectEncryptionType::SseS3,
            other => S3ObjectEncryptionType::Unknown(other.to_owned()),
        }
    }
}

impl std::str::FromStr for S3ObjectEncryptionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(S3ObjectEncryptionType::from(s))
    }
}

impl S3ObjectEncryptionType {
    pub fn as_str(&self) -> &str {
        match self {
            S3ObjectEncryptionType::NoEncryption => "NO_ENCRYPTION",
            S3ObjectEncryptionType::SseKms => "SSE_KMS",
            S3ObjectEncryptionType::SseS3 => "SSE_S3",
            S3ObjectEncryptionType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for S3ObjectEncryptionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl serde::Serialize for S3ObjectEncryptionType {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::Serializer>::Ok, <S as serde::Serializer>::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(self.as_str())
    }
}

impl<'de> serde::Deserialize<'de> for S3ObjectEncryptionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ExportStatus {
    Cancelled,
    Completed,
    InProgress,
    Unknown(String),
}
impl std::convert::From<&str> for ExportStatus {
    fn from(s: &str) -> Self {
        match s {
            "CANCELLED" => ExportStatus::Cancelled,
            "COMPLETED" => ExportStatus::Completed,
            "IN_PROGRESS" => ExportStatus::InProgress,
            other => ExportStatus::Unknown(other.to_owned()),
        }
    }
}

impl std::str::FromStr for ExportStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ExportStatus::from(s))
    }
}

impl ExportStatus {
    pub fn as_str(&self) -> &str {
        match self {
            ExportStatus::Cancelled => "CANCELLED",
            ExportStatus::Completed => "COMPLETED",
            ExportStatus::InProgress => "IN_PROGRESS",
            ExportStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ExportStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl serde::Serialize for ExportStatus {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::Serializer>::Ok, <S as serde::Serializer>::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(self.as_str())
    }
}

impl<'de> serde::Deserialize<'de> for ExportStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>The information about an Amazon QLDB journal stream, including the Amazon Resource Name
/// (ARN), stream name, creation time, current status, and the parameters of your original
/// stream creation request.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct JournalKinesisStreamDescription {
    /// <p>The name of the ledger.</p>
    #[serde(rename = "LedgerName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub ledger_name: std::option::Option<std::string::String>,
    /// <p>The date and time, in epoch time format, when the QLDB journal stream was created.
    /// (Epoch time format is the number of seconds elapsed since 12:00:00 AM January 1, 1970
    /// UTC.)</p>
    #[serde(rename = "CreationTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(
        serialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_ser"
    )]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The inclusive start date and time from which to start streaming journal data.</p>
    #[serde(rename = "InclusiveStartTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(
        serialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_ser"
    )]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub inclusive_start_time: std::option::Option<smithy_types::Instant>,
    /// <p>The exclusive date and time that specifies when the stream ends. If this parameter is
    /// blank, the stream runs indefinitely until you cancel it.</p>
    #[serde(rename = "ExclusiveEndTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(
        serialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_ser"
    )]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub exclusive_end_time: std::option::Option<smithy_types::Instant>,
    /// <p>The Amazon Resource Name (ARN) of the IAM role that grants QLDB permissions for a
    /// journal stream to write data records to a Kinesis Data Streams resource.</p>
    #[serde(rename = "RoleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The unique ID that QLDB assigns to each QLDB journal stream.</p>
    #[serde(rename = "StreamId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub stream_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the QLDB journal stream.</p>
    #[serde(rename = "Arn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The current state of the QLDB journal stream.</p>
    #[serde(rename = "Status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub status: std::option::Option<crate::model::StreamStatus>,
    /// <p>The configuration settings of the Amazon Kinesis Data Streams destination for your QLDB journal
    /// stream.</p>
    #[serde(rename = "KinesisConfiguration")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub kinesis_configuration: std::option::Option<crate::model::KinesisConfiguration>,
    /// <p>The error message that describes the reason that a stream has a status of
    /// <code>IMPAIRED</code> or <code>FAILED</code>. This is not applicable to streams that
    /// have other status values.</p>
    #[serde(rename = "ErrorCause")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub error_cause: std::option::Option<crate::model::ErrorCause>,
    /// <p>The user-defined name of the QLDB journal stream.</p>
    #[serde(rename = "StreamName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub stream_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for JournalKinesisStreamDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("JournalKinesisStreamDescription");
        formatter.field("ledger_name", &self.ledger_name);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("inclusive_start_time", &self.inclusive_start_time);
        formatter.field("exclusive_end_time", &self.exclusive_end_time);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("stream_id", &self.stream_id);
        formatter.field("arn", &self.arn);
        formatter.field("status", &self.status);
        formatter.field("kinesis_configuration", &self.kinesis_configuration);
        formatter.field("error_cause", &self.error_cause);
        formatter.field("stream_name", &self.stream_name);
        formatter.finish()
    }
}
/// See [`JournalKinesisStreamDescription`](crate::model::JournalKinesisStreamDescription)
pub mod journal_kinesis_stream_description {
    /// A builder for [`JournalKinesisStreamDescription`](crate::model::JournalKinesisStreamDescription)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        ledger_name: std::option::Option<std::string::String>,
        creation_time: std::option::Option<smithy_types::Instant>,
        inclusive_start_time: std::option::Option<smithy_types::Instant>,
        exclusive_end_time: std::option::Option<smithy_types::Instant>,
        role_arn: std::option::Option<std::string::String>,
        stream_id: std::option::Option<std::string::String>,
        arn: std::option::Option<std::string::String>,
        status: std::option::Option<crate::model::StreamStatus>,
        kinesis_configuration: std::option::Option<crate::model::KinesisConfiguration>,
        error_cause: std::option::Option<crate::model::ErrorCause>,
        stream_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the ledger.</p>
        pub fn ledger_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.ledger_name = Some(inp.into());
            self
        }
        pub fn set_ledger_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.ledger_name = inp;
            self
        }
        /// <p>The date and time, in epoch time format, when the QLDB journal stream was created.
        /// (Epoch time format is the number of seconds elapsed since 12:00:00 AM January 1, 1970
        /// UTC.)</p>
        pub fn creation_time(mut self, inp: smithy_types::Instant) -> Self {
            self.creation_time = Some(inp);
            self
        }
        pub fn set_creation_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = inp;
            self
        }
        /// <p>The inclusive start date and time from which to start streaming journal data.</p>
        pub fn inclusive_start_time(mut self, inp: smithy_types::Instant) -> Self {
            self.inclusive_start_time = Some(inp);
            self
        }
        pub fn set_inclusive_start_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inclusive_start_time = inp;
            self
        }
        /// <p>The exclusive date and time that specifies when the stream ends. If this parameter is
        /// blank, the stream runs indefinitely until you cancel it.</p>
        pub fn exclusive_end_time(mut self, inp: smithy_types::Instant) -> Self {
            self.exclusive_end_time = Some(inp);
            self
        }
        pub fn set_exclusive_end_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.exclusive_end_time = inp;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM role that grants QLDB permissions for a
        /// journal stream to write data records to a Kinesis Data Streams resource.</p>
        pub fn role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(inp.into());
            self
        }
        pub fn set_role_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.role_arn = inp;
            self
        }
        /// <p>The unique ID that QLDB assigns to each QLDB journal stream.</p>
        pub fn stream_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stream_id = Some(inp.into());
            self
        }
        pub fn set_stream_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stream_id = inp;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the QLDB journal stream.</p>
        pub fn arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.arn = Some(inp.into());
            self
        }
        pub fn set_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.arn = inp;
            self
        }
        /// <p>The current state of the QLDB journal stream.</p>
        pub fn status(mut self, inp: crate::model::StreamStatus) -> Self {
            self.status = Some(inp);
            self
        }
        pub fn set_status(mut self, inp: std::option::Option<crate::model::StreamStatus>) -> Self {
            self.status = inp;
            self
        }
        /// <p>The configuration settings of the Amazon Kinesis Data Streams destination for your QLDB journal
        /// stream.</p>
        pub fn kinesis_configuration(mut self, inp: crate::model::KinesisConfiguration) -> Self {
            self.kinesis_configuration = Some(inp);
            self
        }
        pub fn set_kinesis_configuration(
            mut self,
            inp: std::option::Option<crate::model::KinesisConfiguration>,
        ) -> Self {
            self.kinesis_configuration = inp;
            self
        }
        /// <p>The error message that describes the reason that a stream has a status of
        /// <code>IMPAIRED</code> or <code>FAILED</code>. This is not applicable to streams that
        /// have other status values.</p>
        pub fn error_cause(mut self, inp: crate::model::ErrorCause) -> Self {
            self.error_cause = Some(inp);
            self
        }
        pub fn set_error_cause(
            mut self,
            inp: std::option::Option<crate::model::ErrorCause>,
        ) -> Self {
            self.error_cause = inp;
            self
        }
        /// <p>The user-defined name of the QLDB journal stream.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stream_name = Some(inp.into());
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stream_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`JournalKinesisStreamDescription`](crate::model::JournalKinesisStreamDescription)
        pub fn build(self) -> crate::model::JournalKinesisStreamDescription {
            crate::model::JournalKinesisStreamDescription {
                ledger_name: self.ledger_name,
                creation_time: self.creation_time,
                inclusive_start_time: self.inclusive_start_time,
                exclusive_end_time: self.exclusive_end_time,
                role_arn: self.role_arn,
                stream_id: self.stream_id,
                arn: self.arn,
                status: self.status,
                kinesis_configuration: self.kinesis_configuration,
                error_cause: self.error_cause,
                stream_name: self.stream_name,
            }
        }
    }
}
impl JournalKinesisStreamDescription {
    /// Creates a new builder-style object to manufacture [`JournalKinesisStreamDescription`](crate::model::JournalKinesisStreamDescription)
    pub fn builder() -> crate::model::journal_kinesis_stream_description::Builder {
        crate::model::journal_kinesis_stream_description::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ErrorCause {
    IamPermissionRevoked,
    KinesisStreamNotFound,
    Unknown(String),
}
impl std::convert::From<&str> for ErrorCause {
    fn from(s: &str) -> Self {
        match s {
            "IAM_PERMISSION_REVOKED" => ErrorCause::IamPermissionRevoked,
            "KINESIS_STREAM_NOT_FOUND" => ErrorCause::KinesisStreamNotFound,
            other => ErrorCause::Unknown(other.to_owned()),
        }
    }
}

impl std::str::FromStr for ErrorCause {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ErrorCause::from(s))
    }
}

impl ErrorCause {
    pub fn as_str(&self) -> &str {
        match self {
            ErrorCause::IamPermissionRevoked => "IAM_PERMISSION_REVOKED",
            ErrorCause::KinesisStreamNotFound => "KINESIS_STREAM_NOT_FOUND",
            ErrorCause::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ErrorCause {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl serde::Serialize for ErrorCause {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::Serializer>::Ok, <S as serde::Serializer>::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(self.as_str())
    }
}

impl<'de> serde::Deserialize<'de> for ErrorCause {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StreamStatus {
    Active,
    Canceled,
    Completed,
    Failed,
    Impaired,
    Unknown(String),
}
impl std::convert::From<&str> for StreamStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => StreamStatus::Active,
            "CANCELED" => StreamStatus::Canceled,
            "COMPLETED" => StreamStatus::Completed,
            "FAILED" => StreamStatus::Failed,
            "IMPAIRED" => StreamStatus::Impaired,
            other => StreamStatus::Unknown(other.to_owned()),
        }
    }
}

impl std::str::FromStr for StreamStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(StreamStatus::from(s))
    }
}

impl StreamStatus {
    pub fn as_str(&self) -> &str {
        match self {
            StreamStatus::Active => "ACTIVE",
            StreamStatus::Canceled => "CANCELED",
            StreamStatus::Completed => "COMPLETED",
            StreamStatus::Failed => "FAILED",
            StreamStatus::Impaired => "IMPAIRED",
            StreamStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for StreamStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl serde::Serialize for StreamStatus {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::Serializer>::Ok, <S as serde::Serializer>::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(self.as_str())
    }
}

impl<'de> serde::Deserialize<'de> for StreamStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>A structure that can contain a value in multiple encoding formats.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ValueHolder {
    /// <p>An Amazon Ion plaintext value contained in a <code>ValueHolder</code> structure.</p>
    #[serde(rename = "IonText")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub ion_text: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ValueHolder {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ValueHolder");
        formatter.field("ion_text", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`ValueHolder`](crate::model::ValueHolder)
pub mod value_holder {
    /// A builder for [`ValueHolder`](crate::model::ValueHolder)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        ion_text: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An Amazon Ion plaintext value contained in a <code>ValueHolder</code> structure.</p>
        pub fn ion_text(mut self, inp: impl Into<std::string::String>) -> Self {
            self.ion_text = Some(inp.into());
            self
        }
        pub fn set_ion_text(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.ion_text = inp;
            self
        }
        /// Consumes the builder and constructs a [`ValueHolder`](crate::model::ValueHolder)
        pub fn build(self) -> crate::model::ValueHolder {
            crate::model::ValueHolder {
                ion_text: self.ion_text,
            }
        }
    }
}
impl ValueHolder {
    /// Creates a new builder-style object to manufacture [`ValueHolder`](crate::model::ValueHolder)
    pub fn builder() -> crate::model::value_holder::Builder {
        crate::model::value_holder::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PermissionsMode {
    AllowAll,
    Unknown(String),
}
impl std::convert::From<&str> for PermissionsMode {
    fn from(s: &str) -> Self {
        match s {
            "ALLOW_ALL" => PermissionsMode::AllowAll,
            other => PermissionsMode::Unknown(other.to_owned()),
        }
    }
}

impl std::str::FromStr for PermissionsMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(PermissionsMode::from(s))
    }
}

impl PermissionsMode {
    pub fn as_str(&self) -> &str {
        match self {
            PermissionsMode::AllowAll => "ALLOW_ALL",
            PermissionsMode::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for PermissionsMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl serde::Serialize for PermissionsMode {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::Serializer>::Ok, <S as serde::Serializer>::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(self.as_str())
    }
}

impl<'de> serde::Deserialize<'de> for PermissionsMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}
