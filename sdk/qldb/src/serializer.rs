// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateLedgerInputBody<'a> {
    /// <p>The name of the ledger that you want to create. The name must be unique among all of
    /// your ledgers in the current AWS Region.</p>
    /// <p>Naming constraints for ledger names are defined in <a href="https://docs.aws.amazon.com/qldb/latest/developerguide/limits.html#limits.naming">Quotas in Amazon QLDB</a>
    /// in the <i>Amazon QLDB Developer Guide</i>.</p>
    pub name: &'a std::option::Option<std::string::String>,
    /// <p>The key-value pairs to add as tags to the ledger that you want to create. Tag keys are
    /// case sensitive. Tag values are case sensitive and can be null.</p>
    pub tags: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::option::Option<std::string::String>>,
    >,
    /// <p>The permissions mode to assign to the ledger that you want to create.</p>
    pub permissions_mode: &'a std::option::Option<crate::model::PermissionsMode>,
    /// <p>The flag that prevents a ledger from being deleted by any user. If not provided on
    /// ledger creation, this feature is enabled (<code>true</code>) by default.</p>
    /// <p>If deletion protection is enabled, you must first disable it before you can delete the
    /// ledger using the QLDB API or the AWS Command Line Interface (AWS CLI). You can disable it by calling the
    /// <code>UpdateLedger</code> operation to set the flag to <code>false</code>. The QLDB
    /// console disables deletion protection for you when you use it to delete a ledger.</p>
    pub deletion_protection: &'a std::option::Option<bool>,
}
impl<'a> std::fmt::Debug for CreateLedgerInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateLedgerInputBody");
        formatter.field("name", &self.name);
        formatter.field("tags", &self.tags);
        formatter.field("permissions_mode", &self.permissions_mode);
        formatter.field("deletion_protection", &self.deletion_protection);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExportJournalToS3InputBody<'a> {
    /// <p>The inclusive start date and time for the range of journal contents that you want to
    /// export.</p>
    /// <p>The <code>InclusiveStartTime</code> must be in <code>ISO 8601</code> date and time
    /// format and in Universal Coordinated Time (UTC). For example:
    /// <code>2019-06-13T21:36:34Z</code>
    /// </p>
    /// <p>The <code>InclusiveStartTime</code> must be before <code>ExclusiveEndTime</code>.</p>
    /// <p>If you provide an <code>InclusiveStartTime</code> that is before the ledger's
    /// <code>CreationDateTime</code>, Amazon QLDB defaults it to the ledger's
    /// <code>CreationDateTime</code>.</p>
    pub inclusive_start_time: &'a std::option::Option<smithy_types::Instant>,
    /// <p>The exclusive end date and time for the range of journal contents that you want to
    /// export.</p>
    /// <p>The <code>ExclusiveEndTime</code> must be in <code>ISO 8601</code> date and time format
    /// and in Universal Coordinated Time (UTC). For example:
    /// <code>2019-06-13T21:36:34Z</code>
    /// </p>
    /// <p>The <code>ExclusiveEndTime</code> must be less than or equal to the current UTC date and
    /// time.</p>
    pub exclusive_end_time: &'a std::option::Option<smithy_types::Instant>,
    /// <p>The configuration settings of the Amazon S3 bucket destination for your export
    /// request.</p>
    pub s3_export_configuration: &'a std::option::Option<crate::model::S3ExportConfiguration>,
    /// <p>The Amazon Resource Name (ARN) of the IAM role that grants QLDB permissions for a
    /// journal export job to do the following:</p>
    /// <ul>
    /// <li>
    /// <p>Write objects into your Amazon Simple Storage Service (Amazon S3) bucket.</p>
    /// </li>
    /// <li>
    /// <p>(Optional) Use your customer master key (CMK) in AWS Key Management Service (AWS
    /// KMS) for server-side encryption of your exported data.</p>
    /// </li>
    /// </ul>
    pub role_arn: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for ExportJournalToS3InputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExportJournalToS3InputBody");
        formatter.field("inclusive_start_time", &self.inclusive_start_time);
        formatter.field("exclusive_end_time", &self.exclusive_end_time);
        formatter.field("s3_export_configuration", &self.s3_export_configuration);
        formatter.field("role_arn", &self.role_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBlockInputBody<'a> {
    /// <p>The location of the block that you want to request. An address is an Amazon Ion
    /// structure that has two fields: <code>strandId</code> and <code>sequenceNo</code>.</p>
    /// <p>For example: <code>{strandId:"BlFTjlSXze9BIh1KOszcE3",sequenceNo:14}</code>
    /// </p>
    pub block_address: &'a std::option::Option<crate::model::ValueHolder>,
    /// <p>The latest block location covered by the digest for which to request a proof. An address
    /// is an Amazon Ion structure that has two fields: <code>strandId</code> and
    /// <code>sequenceNo</code>.</p>
    /// <p>For example: <code>{strandId:"BlFTjlSXze9BIh1KOszcE3",sequenceNo:49}</code>
    /// </p>
    pub digest_tip_address: &'a std::option::Option<crate::model::ValueHolder>,
}
impl<'a> std::fmt::Debug for GetBlockInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBlockInputBody");
        formatter.field("block_address", &"*** Sensitive Data Redacted ***");
        formatter.field("digest_tip_address", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRevisionInputBody<'a> {
    /// <p>The block location of the document revision to be verified. An address is an Amazon Ion
    /// structure that has two fields: <code>strandId</code> and <code>sequenceNo</code>.</p>
    /// <p>For example: <code>{strandId:"BlFTjlSXze9BIh1KOszcE3",sequenceNo:14}</code>
    /// </p>
    pub block_address: &'a std::option::Option<crate::model::ValueHolder>,
    /// <p>The unique ID of the document to be verified.</p>
    pub document_id: &'a std::option::Option<std::string::String>,
    /// <p>The latest block location covered by the digest for which to request a proof. An address
    /// is an Amazon Ion structure that has two fields: <code>strandId</code> and
    /// <code>sequenceNo</code>.</p>
    /// <p>For example: <code>{strandId:"BlFTjlSXze9BIh1KOszcE3",sequenceNo:49}</code>
    /// </p>
    pub digest_tip_address: &'a std::option::Option<crate::model::ValueHolder>,
}
impl<'a> std::fmt::Debug for GetRevisionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetRevisionInputBody");
        formatter.field("block_address", &"*** Sensitive Data Redacted ***");
        formatter.field("document_id", &self.document_id);
        formatter.field("digest_tip_address", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StreamJournalToKinesisInputBody<'a> {
    /// <p>The Amazon Resource Name (ARN) of the IAM role that grants QLDB permissions for a
    /// journal stream to write data records to a Kinesis Data Streams resource.</p>
    pub role_arn: &'a std::option::Option<std::string::String>,
    /// <p>The key-value pairs to add as tags to the stream that you want to create. Tag keys are
    /// case sensitive. Tag values are case sensitive and can be null.</p>
    pub tags: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::option::Option<std::string::String>>,
    >,
    /// <p>The inclusive start date and time from which to start streaming journal data. This
    /// parameter must be in <code>ISO 8601</code> date and time format and in Universal
    /// Coordinated Time (UTC). For example: <code>2019-06-13T21:36:34Z</code>
    /// </p>
    /// <p>The <code>InclusiveStartTime</code> cannot be in the future and must be before
    /// <code>ExclusiveEndTime</code>.</p>
    /// <p>If you provide an <code>InclusiveStartTime</code> that is before the ledger's
    /// <code>CreationDateTime</code>, QLDB effectively defaults it to the ledger's
    /// <code>CreationDateTime</code>.</p>
    pub inclusive_start_time: &'a std::option::Option<smithy_types::Instant>,
    /// <p>The exclusive date and time that specifies when the stream ends. If you don't define
    /// this parameter, the stream runs indefinitely until you cancel it.</p>
    /// <p>The <code>ExclusiveEndTime</code> must be in <code>ISO 8601</code> date and time format
    /// and in Universal Coordinated Time (UTC). For example:
    /// <code>2019-06-13T21:36:34Z</code>
    /// </p>
    pub exclusive_end_time: &'a std::option::Option<smithy_types::Instant>,
    /// <p>The configuration settings of the Kinesis Data Streams destination for your stream request.</p>
    pub kinesis_configuration: &'a std::option::Option<crate::model::KinesisConfiguration>,
    /// <p>The name that you want to assign to the QLDB journal stream. User-defined names can
    /// help identify and indicate the purpose of a stream.</p>
    /// <p>Your stream name must be unique among other <i>active</i> streams for a
    /// given ledger. Stream names have the same naming constraints as ledger names, as defined in
    /// <a href="https://docs.aws.amazon.com/qldb/latest/developerguide/limits.html#limits.naming">Quotas in Amazon QLDB</a> in the <i>Amazon QLDB Developer
    /// Guide</i>.</p>
    pub stream_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for StreamJournalToKinesisInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StreamJournalToKinesisInputBody");
        formatter.field("role_arn", &self.role_arn);
        formatter.field("tags", &self.tags);
        formatter.field("inclusive_start_time", &self.inclusive_start_time);
        formatter.field("exclusive_end_time", &self.exclusive_end_time);
        formatter.field("kinesis_configuration", &self.kinesis_configuration);
        formatter.field("stream_name", &self.stream_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagResourceInputBody<'a> {
    /// <p>The key-value pairs to add as tags to the specified QLDB resource. Tag keys are case
    /// sensitive. If you specify a key that already exists for the resource, your request fails
    /// and returns an error. Tag values are case sensitive and can be null.</p>
    pub tags: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::option::Option<std::string::String>>,
    >,
}
impl<'a> std::fmt::Debug for TagResourceInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagResourceInputBody");
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateLedgerInputBody<'a> {
    /// <p>The flag that prevents a ledger from being deleted by any user. If not provided on
    /// ledger creation, this feature is enabled (<code>true</code>) by default.</p>
    /// <p>If deletion protection is enabled, you must first disable it before you can delete the
    /// ledger using the QLDB API or the AWS Command Line Interface (AWS CLI). You can disable it by calling the
    /// <code>UpdateLedger</code> operation to set the flag to <code>false</code>. The QLDB
    /// console disables deletion protection for you when you use it to delete a ledger.</p>
    pub deletion_protection: &'a std::option::Option<bool>,
}
impl<'a> std::fmt::Debug for UpdateLedgerInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateLedgerInputBody");
        formatter.field("deletion_protection", &self.deletion_protection);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CancelJournalKinesisStreamOutputBody {
    /// <p>The unique ID that QLDB assigns to each QLDB journal stream.</p>
    #[serde(rename = "StreamId")]
    #[serde(default)]
    pub stream_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CancelJournalKinesisStreamOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CancelJournalKinesisStreamOutputBody");
        formatter.field("stream_id", &self.stream_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateLedgerOutputBody {
    /// <p>The name of the ledger.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the ledger.</p>
    #[serde(rename = "Arn")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The current status of the ledger.</p>
    #[serde(rename = "State")]
    #[serde(default)]
    pub state: std::option::Option<crate::model::LedgerState>,
    /// <p>The date and time, in epoch time format, when the ledger was created. (Epoch time format
    /// is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC.)</p>
    #[serde(rename = "CreationDateTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_date_time: std::option::Option<smithy_types::Instant>,
    /// <p>The flag that prevents a ledger from being deleted by any user. If not provided on
    /// ledger creation, this feature is enabled (<code>true</code>) by default.</p>
    /// <p>If deletion protection is enabled, you must first disable it before you can delete the
    /// ledger using the QLDB API or the AWS Command Line Interface (AWS CLI). You can disable it by calling the
    /// <code>UpdateLedger</code> operation to set the flag to <code>false</code>. The QLDB
    /// console disables deletion protection for you when you use it to delete a ledger.</p>
    #[serde(rename = "DeletionProtection")]
    #[serde(default)]
    pub deletion_protection: std::option::Option<bool>,
}
impl std::fmt::Debug for CreateLedgerOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateLedgerOutputBody");
        formatter.field("name", &self.name);
        formatter.field("arn", &self.arn);
        formatter.field("state", &self.state);
        formatter.field("creation_date_time", &self.creation_date_time);
        formatter.field("deletion_protection", &self.deletion_protection);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeJournalKinesisStreamOutputBody {
    /// <p>Information about the QLDB journal stream returned by a
    /// <code>DescribeJournalS3Export</code> request.</p>
    #[serde(rename = "Stream")]
    #[serde(default)]
    pub stream: std::option::Option<crate::model::JournalKinesisStreamDescription>,
}
impl std::fmt::Debug for DescribeJournalKinesisStreamOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeJournalKinesisStreamOutputBody");
        formatter.field("stream", &self.stream);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeJournalS3ExportOutputBody {
    /// <p>Information about the journal export job returned by a
    /// <code>DescribeJournalS3Export</code> request.</p>
    #[serde(rename = "ExportDescription")]
    #[serde(default)]
    pub export_description: std::option::Option<crate::model::JournalS3ExportDescription>,
}
impl std::fmt::Debug for DescribeJournalS3ExportOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeJournalS3ExportOutputBody");
        formatter.field("export_description", &self.export_description);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeLedgerOutputBody {
    /// <p>The name of the ledger.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the ledger.</p>
    #[serde(rename = "Arn")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The current status of the ledger.</p>
    #[serde(rename = "State")]
    #[serde(default)]
    pub state: std::option::Option<crate::model::LedgerState>,
    /// <p>The date and time, in epoch time format, when the ledger was created. (Epoch time format
    /// is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC.)</p>
    #[serde(rename = "CreationDateTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_date_time: std::option::Option<smithy_types::Instant>,
    /// <p>The flag that prevents a ledger from being deleted by any user. If not provided on
    /// ledger creation, this feature is enabled (<code>true</code>) by default.</p>
    /// <p>If deletion protection is enabled, you must first disable it before you can delete the
    /// ledger using the QLDB API or the AWS Command Line Interface (AWS CLI). You can disable it by calling the
    /// <code>UpdateLedger</code> operation to set the flag to <code>false</code>. The QLDB
    /// console disables deletion protection for you when you use it to delete a ledger.</p>
    #[serde(rename = "DeletionProtection")]
    #[serde(default)]
    pub deletion_protection: std::option::Option<bool>,
}
impl std::fmt::Debug for DescribeLedgerOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeLedgerOutputBody");
        formatter.field("name", &self.name);
        formatter.field("arn", &self.arn);
        formatter.field("state", &self.state);
        formatter.field("creation_date_time", &self.creation_date_time);
        formatter.field("deletion_protection", &self.deletion_protection);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ExportJournalToS3OutputBody {
    /// <p>The unique ID that QLDB assigns to each journal export job.</p>
    /// <p>To describe your export request and check the status of the job, you can use
    /// <code>ExportId</code> to call <code>DescribeJournalS3Export</code>.</p>
    #[serde(rename = "ExportId")]
    #[serde(default)]
    pub export_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ExportJournalToS3OutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExportJournalToS3OutputBody");
        formatter.field("export_id", &self.export_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBlockOutputBody {
    /// <p>The block data object in Amazon Ion format.</p>
    #[serde(rename = "Block")]
    #[serde(default)]
    pub block: std::option::Option<crate::model::ValueHolder>,
    /// <p>The proof object in Amazon Ion format returned by a <code>GetBlock</code> request. A
    /// proof contains the list of hash values required to recalculate the specified digest using a
    /// Merkle tree, starting with the specified block.</p>
    #[serde(rename = "Proof")]
    #[serde(default)]
    pub proof: std::option::Option<crate::model::ValueHolder>,
}
impl std::fmt::Debug for GetBlockOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBlockOutputBody");
        formatter.field("block", &"*** Sensitive Data Redacted ***");
        formatter.field("proof", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetDigestOutputBody {
    /// <p>The 256-bit hash value representing the digest returned by a <code>GetDigest</code>
    /// request.</p>
    #[serde(rename = "Digest")]
    #[serde(deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesblob_deser")]
    #[serde(default)]
    pub digest: std::option::Option<smithy_types::Blob>,
    /// <p>The latest block location covered by the digest that you requested. An address is an
    /// Amazon Ion structure that has two fields: <code>strandId</code> and
    /// <code>sequenceNo</code>.</p>
    #[serde(rename = "DigestTipAddress")]
    #[serde(default)]
    pub digest_tip_address: std::option::Option<crate::model::ValueHolder>,
}
impl std::fmt::Debug for GetDigestOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetDigestOutputBody");
        formatter.field("digest", &self.digest);
        formatter.field("digest_tip_address", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRevisionOutputBody {
    /// <p>The proof object in Amazon Ion format returned by a <code>GetRevision</code> request. A
    /// proof contains the list of hash values that are required to recalculate the specified
    /// digest using a Merkle tree, starting with the specified document revision.</p>
    #[serde(rename = "Proof")]
    #[serde(default)]
    pub proof: std::option::Option<crate::model::ValueHolder>,
    /// <p>The document revision data object in Amazon Ion format.</p>
    #[serde(rename = "Revision")]
    #[serde(default)]
    pub revision: std::option::Option<crate::model::ValueHolder>,
}
impl std::fmt::Debug for GetRevisionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetRevisionOutputBody");
        formatter.field("proof", &"*** Sensitive Data Redacted ***");
        formatter.field("revision", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListJournalKinesisStreamsForLedgerOutputBody {
    /// <p>The array of QLDB journal stream descriptors that are associated with the given
    /// ledger.</p>
    #[serde(rename = "Streams")]
    #[serde(default)]
    pub streams: std::option::Option<std::vec::Vec<crate::model::JournalKinesisStreamDescription>>,
    /// <ul>
    /// <li>
    /// <p>If <code>NextToken</code> is empty, the last page of results has been processed
    /// and there are no more results to be retrieved.</p>
    /// </li>
    /// <li>
    /// <p>If <code>NextToken</code> is <i>not</i> empty, more results are
    /// available. To retrieve the next page of results, use the value of
    /// <code>NextToken</code> in a subsequent
    /// <code>ListJournalKinesisStreamsForLedger</code> call.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListJournalKinesisStreamsForLedgerOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListJournalKinesisStreamsForLedgerOutputBody");
        formatter.field("streams", &self.streams);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListJournalS3ExportsOutputBody {
    /// <p>The array of journal export job descriptions for all ledgers that are associated with
    /// the current AWS account and Region.</p>
    #[serde(rename = "JournalS3Exports")]
    #[serde(default)]
    pub journal_s3_exports:
        std::option::Option<std::vec::Vec<crate::model::JournalS3ExportDescription>>,
    /// <ul>
    /// <li>
    /// <p>If <code>NextToken</code> is empty, then the last page of results has been
    /// processed and there are no more results to be retrieved.</p>
    /// </li>
    /// <li>
    /// <p>If <code>NextToken</code> is <i>not</i> empty, then there are more
    /// results available. To retrieve the next page of results, use the value of
    /// <code>NextToken</code> in a subsequent <code>ListJournalS3Exports</code>
    /// call.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListJournalS3ExportsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListJournalS3ExportsOutputBody");
        formatter.field("journal_s3_exports", &self.journal_s3_exports);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListJournalS3ExportsForLedgerOutputBody {
    /// <p>The array of journal export job descriptions that are associated with the specified
    /// ledger.</p>
    #[serde(rename = "JournalS3Exports")]
    #[serde(default)]
    pub journal_s3_exports:
        std::option::Option<std::vec::Vec<crate::model::JournalS3ExportDescription>>,
    /// <ul>
    /// <li>
    /// <p>If <code>NextToken</code> is empty, then the last page of results has been
    /// processed and there are no more results to be retrieved.</p>
    /// </li>
    /// <li>
    /// <p>If <code>NextToken</code> is <i>not</i> empty, then there are more
    /// results available. To retrieve the next page of results, use the value of
    /// <code>NextToken</code> in a subsequent <code>ListJournalS3ExportsForLedger</code>
    /// call.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListJournalS3ExportsForLedgerOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListJournalS3ExportsForLedgerOutputBody");
        formatter.field("journal_s3_exports", &self.journal_s3_exports);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListLedgersOutputBody {
    /// <p>The array of ledger summaries that are associated with the current AWS account and
    /// Region.</p>
    #[serde(rename = "Ledgers")]
    #[serde(default)]
    pub ledgers: std::option::Option<std::vec::Vec<crate::model::LedgerSummary>>,
    /// <p>A pagination token, indicating whether there are more results available:</p>
    /// <ul>
    /// <li>
    /// <p>If <code>NextToken</code> is empty, then the last page of results has been
    /// processed and there are no more results to be retrieved.</p>
    /// </li>
    /// <li>
    /// <p>If <code>NextToken</code> is <i>not</i> empty, then there are more
    /// results available. To retrieve the next page of results, use the value of
    /// <code>NextToken</code> in a subsequent <code>ListLedgers</code> call.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListLedgersOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListLedgersOutputBody");
        formatter.field("ledgers", &self.ledgers);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsForResourceOutputBody {
    /// <p>The tags that are currently associated with the specified Amazon QLDB resource.</p>
    #[serde(rename = "Tags")]
    #[serde(default)]
    pub tags: std::option::Option<
        std::collections::HashMap<std::string::String, std::option::Option<std::string::String>>,
    >,
}
impl std::fmt::Debug for ListTagsForResourceOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsForResourceOutputBody");
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct StreamJournalToKinesisOutputBody {
    /// <p>The unique ID that QLDB assigns to each QLDB journal stream.</p>
    #[serde(rename = "StreamId")]
    #[serde(default)]
    pub stream_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StreamJournalToKinesisOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StreamJournalToKinesisOutputBody");
        formatter.field("stream_id", &self.stream_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateLedgerOutputBody {
    /// <p>The name of the ledger.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the ledger.</p>
    #[serde(rename = "Arn")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The current status of the ledger.</p>
    #[serde(rename = "State")]
    #[serde(default)]
    pub state: std::option::Option<crate::model::LedgerState>,
    /// <p>The date and time, in epoch time format, when the ledger was created. (Epoch time format
    /// is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC.)</p>
    #[serde(rename = "CreationDateTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_date_time: std::option::Option<smithy_types::Instant>,
    /// <p>The flag that prevents a ledger from being deleted by any user. If not provided on
    /// ledger creation, this feature is enabled (<code>true</code>) by default.</p>
    /// <p>If deletion protection is enabled, you must first disable it before you can delete the
    /// ledger using the QLDB API or the AWS Command Line Interface (AWS CLI). You can disable it by calling the
    /// <code>UpdateLedger</code> operation to set the flag to <code>false</code>. The QLDB
    /// console disables deletion protection for you when you use it to delete a ledger.</p>
    #[serde(rename = "DeletionProtection")]
    #[serde(default)]
    pub deletion_protection: std::option::Option<bool>,
}
impl std::fmt::Debug for UpdateLedgerOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateLedgerOutputBody");
        formatter.field("name", &self.name);
        formatter.field("arn", &self.arn);
        formatter.field("state", &self.state);
        formatter.field("creation_date_time", &self.creation_date_time);
        formatter.field("deletion_protection", &self.deletion_protection);
        formatter.finish()
    }
}
