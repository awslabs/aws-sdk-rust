// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle {
    client: aws_hyper::Client<aws_hyper::conn::Standard>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client {
    handle: std::sync::Arc<Handle>,
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf_conn(
            crate::Config::builder().build(),
            aws_hyper::conn::Standard::https(),
        )
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        Self::from_conf_conn(conf, aws_hyper::conn::Standard::https())
    }

    pub fn from_conf_conn(conf: crate::Config, conn: aws_hyper::conn::Standard) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
    pub fn cancel_journal_kinesis_stream(&self) -> fluent_builders::CancelJournalKinesisStream {
        fluent_builders::CancelJournalKinesisStream::new(self.handle.clone())
    }
    pub fn create_ledger(&self) -> fluent_builders::CreateLedger {
        fluent_builders::CreateLedger::new(self.handle.clone())
    }
    pub fn delete_ledger(&self) -> fluent_builders::DeleteLedger {
        fluent_builders::DeleteLedger::new(self.handle.clone())
    }
    pub fn describe_journal_kinesis_stream(&self) -> fluent_builders::DescribeJournalKinesisStream {
        fluent_builders::DescribeJournalKinesisStream::new(self.handle.clone())
    }
    pub fn describe_journal_s3_export(&self) -> fluent_builders::DescribeJournalS3Export {
        fluent_builders::DescribeJournalS3Export::new(self.handle.clone())
    }
    pub fn describe_ledger(&self) -> fluent_builders::DescribeLedger {
        fluent_builders::DescribeLedger::new(self.handle.clone())
    }
    pub fn export_journal_to_s3(&self) -> fluent_builders::ExportJournalToS3 {
        fluent_builders::ExportJournalToS3::new(self.handle.clone())
    }
    pub fn get_block(&self) -> fluent_builders::GetBlock {
        fluent_builders::GetBlock::new(self.handle.clone())
    }
    pub fn get_digest(&self) -> fluent_builders::GetDigest {
        fluent_builders::GetDigest::new(self.handle.clone())
    }
    pub fn get_revision(&self) -> fluent_builders::GetRevision {
        fluent_builders::GetRevision::new(self.handle.clone())
    }
    pub fn list_journal_kinesis_streams_for_ledger(
        &self,
    ) -> fluent_builders::ListJournalKinesisStreamsForLedger {
        fluent_builders::ListJournalKinesisStreamsForLedger::new(self.handle.clone())
    }
    pub fn list_journal_s3_exports(&self) -> fluent_builders::ListJournalS3Exports {
        fluent_builders::ListJournalS3Exports::new(self.handle.clone())
    }
    pub fn list_journal_s3_exports_for_ledger(
        &self,
    ) -> fluent_builders::ListJournalS3ExportsForLedger {
        fluent_builders::ListJournalS3ExportsForLedger::new(self.handle.clone())
    }
    pub fn list_ledgers(&self) -> fluent_builders::ListLedgers {
        fluent_builders::ListLedgers::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn stream_journal_to_kinesis(&self) -> fluent_builders::StreamJournalToKinesis {
        fluent_builders::StreamJournalToKinesis::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_ledger(&self) -> fluent_builders::UpdateLedger {
        fluent_builders::UpdateLedger::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct CancelJournalKinesisStream {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::cancel_journal_kinesis_stream_input::Builder,
    }
    impl CancelJournalKinesisStream {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CancelJournalKinesisStreamOutput,
            smithy_http::result::SdkError<crate::error::CancelJournalKinesisStreamError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the ledger.</p>
        pub fn ledger_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ledger_name(inp);
            self
        }
        pub fn set_ledger_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_ledger_name(inp);
            self
        }
        /// <p>The unique ID that QLDB assigns to each QLDB journal stream.</p>
        pub fn stream_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_id(inp);
            self
        }
        pub fn set_stream_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_stream_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateLedger {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::create_ledger_input::Builder,
    }
    impl CreateLedger {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateLedgerOutput,
            smithy_http::result::SdkError<crate::error::CreateLedgerError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the ledger that you want to create. The name must be unique among all of
        /// your ledgers in the current AWS Region.</p>
        /// <p>Naming constraints for ledger names are defined in <a href="https://docs.aws.amazon.com/qldb/latest/developerguide/limits.html#limits.naming">Quotas in Amazon QLDB</a>
        /// in the <i>Amazon QLDB Developer Guide</i>.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>The key-value pairs to add as tags to the ledger that you want to create. Tag keys are
        /// case sensitive. Tag values are case sensitive and can be null.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::option::Option<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    std::option::Option<std::string::String>,
                >,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
        /// <p>The permissions mode to assign to the ledger that you want to create.</p>
        pub fn permissions_mode(mut self, inp: crate::model::PermissionsMode) -> Self {
            self.inner = self.inner.permissions_mode(inp);
            self
        }
        pub fn set_permissions_mode(
            mut self,
            inp: std::option::Option<crate::model::PermissionsMode>,
        ) -> Self {
            self.inner = self.inner.set_permissions_mode(inp);
            self
        }
        /// <p>The flag that prevents a ledger from being deleted by any user. If not provided on
        /// ledger creation, this feature is enabled (<code>true</code>) by default.</p>
        /// <p>If deletion protection is enabled, you must first disable it before you can delete the
        /// ledger using the QLDB API or the AWS Command Line Interface (AWS CLI). You can disable it by calling the
        /// <code>UpdateLedger</code> operation to set the flag to <code>false</code>. The QLDB
        /// console disables deletion protection for you when you use it to delete a ledger.</p>
        pub fn deletion_protection(mut self, inp: bool) -> Self {
            self.inner = self.inner.deletion_protection(inp);
            self
        }
        pub fn set_deletion_protection(mut self, inp: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_deletion_protection(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteLedger {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_ledger_input::Builder,
    }
    impl DeleteLedger {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteLedgerOutput,
            smithy_http::result::SdkError<crate::error::DeleteLedgerError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the ledger that you want to delete.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeJournalKinesisStream {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_journal_kinesis_stream_input::Builder,
    }
    impl DescribeJournalKinesisStream {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeJournalKinesisStreamOutput,
            smithy_http::result::SdkError<crate::error::DescribeJournalKinesisStreamError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the ledger.</p>
        pub fn ledger_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ledger_name(inp);
            self
        }
        pub fn set_ledger_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_ledger_name(inp);
            self
        }
        /// <p>The unique ID that QLDB assigns to each QLDB journal stream.</p>
        pub fn stream_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_id(inp);
            self
        }
        pub fn set_stream_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_stream_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeJournalS3Export {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_journal_s3_export_input::Builder,
    }
    impl DescribeJournalS3Export {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeJournalS3ExportOutput,
            smithy_http::result::SdkError<crate::error::DescribeJournalS3ExportError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the ledger.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>The unique ID of the journal export job that you want to describe.</p>
        pub fn export_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.export_id(inp);
            self
        }
        pub fn set_export_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_export_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLedger {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_ledger_input::Builder,
    }
    impl DescribeLedger {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeLedgerOutput,
            smithy_http::result::SdkError<crate::error::DescribeLedgerError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the ledger that you want to describe.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ExportJournalToS3 {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::export_journal_to_s3_input::Builder,
    }
    impl ExportJournalToS3 {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ExportJournalToS3Output,
            smithy_http::result::SdkError<crate::error::ExportJournalToS3Error>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the ledger.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>The inclusive start date and time for the range of journal contents that you want to
        /// export.</p>
        /// <p>The <code>InclusiveStartTime</code> must be in <code>ISO 8601</code> date and time
        /// format and in Universal Coordinated Time (UTC). For example:
        /// <code>2019-06-13T21:36:34Z</code>
        /// </p>
        /// <p>The <code>InclusiveStartTime</code> must be before <code>ExclusiveEndTime</code>.</p>
        /// <p>If you provide an <code>InclusiveStartTime</code> that is before the ledger's
        /// <code>CreationDateTime</code>, Amazon QLDB defaults it to the ledger's
        /// <code>CreationDateTime</code>.</p>
        pub fn inclusive_start_time(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.inclusive_start_time(inp);
            self
        }
        pub fn set_inclusive_start_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_inclusive_start_time(inp);
            self
        }
        /// <p>The exclusive end date and time for the range of journal contents that you want to
        /// export.</p>
        /// <p>The <code>ExclusiveEndTime</code> must be in <code>ISO 8601</code> date and time format
        /// and in Universal Coordinated Time (UTC). For example:
        /// <code>2019-06-13T21:36:34Z</code>
        /// </p>
        /// <p>The <code>ExclusiveEndTime</code> must be less than or equal to the current UTC date and
        /// time.</p>
        pub fn exclusive_end_time(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.exclusive_end_time(inp);
            self
        }
        pub fn set_exclusive_end_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_exclusive_end_time(inp);
            self
        }
        /// <p>The configuration settings of the Amazon S3 bucket destination for your export
        /// request.</p>
        pub fn s3_export_configuration(mut self, inp: crate::model::S3ExportConfiguration) -> Self {
            self.inner = self.inner.s3_export_configuration(inp);
            self
        }
        pub fn set_s3_export_configuration(
            mut self,
            inp: std::option::Option<crate::model::S3ExportConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_s3_export_configuration(inp);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM role that grants QLDB permissions for a
        /// journal export job to do the following:</p>
        /// <ul>
        /// <li>
        /// <p>Write objects into your Amazon Simple Storage Service (Amazon S3) bucket.</p>
        /// </li>
        /// <li>
        /// <p>(Optional) Use your customer master key (CMK) in AWS Key Management Service (AWS
        /// KMS) for server-side encryption of your exported data.</p>
        /// </li>
        /// </ul>
        pub fn role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(inp);
            self
        }
        pub fn set_role_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBlock {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_block_input::Builder,
    }
    impl GetBlock {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetBlockOutput,
            smithy_http::result::SdkError<crate::error::GetBlockError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the ledger.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>The location of the block that you want to request. An address is an Amazon Ion
        /// structure that has two fields: <code>strandId</code> and <code>sequenceNo</code>.</p>
        /// <p>For example: <code>{strandId:"BlFTjlSXze9BIh1KOszcE3",sequenceNo:14}</code>
        /// </p>
        pub fn block_address(mut self, inp: crate::model::ValueHolder) -> Self {
            self.inner = self.inner.block_address(inp);
            self
        }
        pub fn set_block_address(
            mut self,
            inp: std::option::Option<crate::model::ValueHolder>,
        ) -> Self {
            self.inner = self.inner.set_block_address(inp);
            self
        }
        /// <p>The latest block location covered by the digest for which to request a proof. An address
        /// is an Amazon Ion structure that has two fields: <code>strandId</code> and
        /// <code>sequenceNo</code>.</p>
        /// <p>For example: <code>{strandId:"BlFTjlSXze9BIh1KOszcE3",sequenceNo:49}</code>
        /// </p>
        pub fn digest_tip_address(mut self, inp: crate::model::ValueHolder) -> Self {
            self.inner = self.inner.digest_tip_address(inp);
            self
        }
        pub fn set_digest_tip_address(
            mut self,
            inp: std::option::Option<crate::model::ValueHolder>,
        ) -> Self {
            self.inner = self.inner.set_digest_tip_address(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDigest {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_digest_input::Builder,
    }
    impl GetDigest {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetDigestOutput,
            smithy_http::result::SdkError<crate::error::GetDigestError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the ledger.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetRevision {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_revision_input::Builder,
    }
    impl GetRevision {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetRevisionOutput,
            smithy_http::result::SdkError<crate::error::GetRevisionError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the ledger.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>The block location of the document revision to be verified. An address is an Amazon Ion
        /// structure that has two fields: <code>strandId</code> and <code>sequenceNo</code>.</p>
        /// <p>For example: <code>{strandId:"BlFTjlSXze9BIh1KOszcE3",sequenceNo:14}</code>
        /// </p>
        pub fn block_address(mut self, inp: crate::model::ValueHolder) -> Self {
            self.inner = self.inner.block_address(inp);
            self
        }
        pub fn set_block_address(
            mut self,
            inp: std::option::Option<crate::model::ValueHolder>,
        ) -> Self {
            self.inner = self.inner.set_block_address(inp);
            self
        }
        /// <p>The unique ID of the document to be verified.</p>
        pub fn document_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.document_id(inp);
            self
        }
        pub fn set_document_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_document_id(inp);
            self
        }
        /// <p>The latest block location covered by the digest for which to request a proof. An address
        /// is an Amazon Ion structure that has two fields: <code>strandId</code> and
        /// <code>sequenceNo</code>.</p>
        /// <p>For example: <code>{strandId:"BlFTjlSXze9BIh1KOszcE3",sequenceNo:49}</code>
        /// </p>
        pub fn digest_tip_address(mut self, inp: crate::model::ValueHolder) -> Self {
            self.inner = self.inner.digest_tip_address(inp);
            self
        }
        pub fn set_digest_tip_address(
            mut self,
            inp: std::option::Option<crate::model::ValueHolder>,
        ) -> Self {
            self.inner = self.inner.set_digest_tip_address(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListJournalKinesisStreamsForLedger {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_journal_kinesis_streams_for_ledger_input::Builder,
    }
    impl ListJournalKinesisStreamsForLedger {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListJournalKinesisStreamsForLedgerOutput,
            smithy_http::result::SdkError<crate::error::ListJournalKinesisStreamsForLedgerError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the ledger.</p>
        pub fn ledger_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ledger_name(inp);
            self
        }
        pub fn set_ledger_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_ledger_name(inp);
            self
        }
        /// <p>The maximum number of results to return in a single
        /// <code>ListJournalKinesisStreamsForLedger</code> request. (The actual number of results
        /// returned might be fewer.)</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>A pagination token, indicating that you want to retrieve the next page of results. If
        /// you received a value for <code>NextToken</code> in the response from a previous
        /// <code>ListJournalKinesisStreamsForLedger</code> call, you should use that value as input
        /// here.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListJournalS3Exports {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_journal_s3_exports_input::Builder,
    }
    impl ListJournalS3Exports {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListJournalS3ExportsOutput,
            smithy_http::result::SdkError<crate::error::ListJournalS3ExportsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of results to return in a single <code>ListJournalS3Exports</code>
        /// request. (The actual number of results returned might be fewer.)</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>A pagination token, indicating that you want to retrieve the next page of results. If
        /// you received a value for <code>NextToken</code> in the response from a previous
        /// <code>ListJournalS3Exports</code> call, then you should use that value as input
        /// here.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListJournalS3ExportsForLedger {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_journal_s3_exports_for_ledger_input::Builder,
    }
    impl ListJournalS3ExportsForLedger {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListJournalS3ExportsForLedgerOutput,
            smithy_http::result::SdkError<crate::error::ListJournalS3ExportsForLedgerError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the ledger.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>The maximum number of results to return in a single
        /// <code>ListJournalS3ExportsForLedger</code> request. (The actual number of results
        /// returned might be fewer.)</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>A pagination token, indicating that you want to retrieve the next page of results. If
        /// you received a value for <code>NextToken</code> in the response from a previous
        /// <code>ListJournalS3ExportsForLedger</code> call, then you should use that value as input
        /// here.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListLedgers {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_ledgers_input::Builder,
    }
    impl ListLedgers {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListLedgersOutput,
            smithy_http::result::SdkError<crate::error::ListLedgersError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of results to return in a single <code>ListLedgers</code> request.
        /// (The actual number of results returned might be fewer.)</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>A pagination token, indicating that you want to retrieve the next page of results. If
        /// you received a value for <code>NextToken</code> in the response from a previous
        /// <code>ListLedgers</code> call, then you should use that value as input here.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl ListTagsForResource {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) for which you want to list the tags. For example:</p>
        /// <p>
        /// <code>arn:aws:qldb:us-east-1:123456789012:ledger/exampleLedger</code>
        /// </p>
        pub fn resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(inp);
            self
        }
        pub fn set_resource_arn(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_resource_arn(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StreamJournalToKinesis {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::stream_journal_to_kinesis_input::Builder,
    }
    impl StreamJournalToKinesis {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::StreamJournalToKinesisOutput,
            smithy_http::result::SdkError<crate::error::StreamJournalToKinesisError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the ledger.</p>
        pub fn ledger_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ledger_name(inp);
            self
        }
        pub fn set_ledger_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_ledger_name(inp);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM role that grants QLDB permissions for a
        /// journal stream to write data records to a Kinesis Data Streams resource.</p>
        pub fn role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(inp);
            self
        }
        pub fn set_role_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(inp);
            self
        }
        /// <p>The key-value pairs to add as tags to the stream that you want to create. Tag keys are
        /// case sensitive. Tag values are case sensitive and can be null.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::option::Option<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    std::option::Option<std::string::String>,
                >,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
        /// <p>The inclusive start date and time from which to start streaming journal data. This
        /// parameter must be in <code>ISO 8601</code> date and time format and in Universal
        /// Coordinated Time (UTC). For example: <code>2019-06-13T21:36:34Z</code>
        /// </p>
        /// <p>The <code>InclusiveStartTime</code> cannot be in the future and must be before
        /// <code>ExclusiveEndTime</code>.</p>
        /// <p>If you provide an <code>InclusiveStartTime</code> that is before the ledger's
        /// <code>CreationDateTime</code>, QLDB effectively defaults it to the ledger's
        /// <code>CreationDateTime</code>.</p>
        pub fn inclusive_start_time(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.inclusive_start_time(inp);
            self
        }
        pub fn set_inclusive_start_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_inclusive_start_time(inp);
            self
        }
        /// <p>The exclusive date and time that specifies when the stream ends. If you don't define
        /// this parameter, the stream runs indefinitely until you cancel it.</p>
        /// <p>The <code>ExclusiveEndTime</code> must be in <code>ISO 8601</code> date and time format
        /// and in Universal Coordinated Time (UTC). For example:
        /// <code>2019-06-13T21:36:34Z</code>
        /// </p>
        pub fn exclusive_end_time(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.exclusive_end_time(inp);
            self
        }
        pub fn set_exclusive_end_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_exclusive_end_time(inp);
            self
        }
        /// <p>The configuration settings of the Kinesis Data Streams destination for your stream request.</p>
        pub fn kinesis_configuration(mut self, inp: crate::model::KinesisConfiguration) -> Self {
            self.inner = self.inner.kinesis_configuration(inp);
            self
        }
        pub fn set_kinesis_configuration(
            mut self,
            inp: std::option::Option<crate::model::KinesisConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_kinesis_configuration(inp);
            self
        }
        /// <p>The name that you want to assign to the QLDB journal stream. User-defined names can
        /// help identify and indicate the purpose of a stream.</p>
        /// <p>Your stream name must be unique among other <i>active</i> streams for a
        /// given ledger. Stream names have the same naming constraints as ledger names, as defined in
        /// <a href="https://docs.aws.amazon.com/qldb/latest/developerguide/limits.html#limits.naming">Quotas in Amazon QLDB</a> in the <i>Amazon QLDB Developer
        /// Guide</i>.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(inp);
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl TagResource {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) to which you want to add the tags. For example:</p>
        /// <p>
        /// <code>arn:aws:qldb:us-east-1:123456789012:ledger/exampleLedger</code>
        /// </p>
        pub fn resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(inp);
            self
        }
        pub fn set_resource_arn(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_resource_arn(inp);
            self
        }
        /// <p>The key-value pairs to add as tags to the specified QLDB resource. Tag keys are case
        /// sensitive. If you specify a key that already exists for the resource, your request fails
        /// and returns an error. Tag values are case sensitive and can be null.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::option::Option<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    std::option::Option<std::string::String>,
                >,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl UntagResource {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) from which you want to remove the tags. For
        /// example:</p>
        /// <p>
        /// <code>arn:aws:qldb:us-east-1:123456789012:ledger/exampleLedger</code>
        /// </p>
        pub fn resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(inp);
            self
        }
        pub fn set_resource_arn(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_resource_arn(inp);
            self
        }
        /// <p>The list of tag keys that you want to remove.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateLedger {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::update_ledger_input::Builder,
    }
    impl UpdateLedger {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateLedgerOutput,
            smithy_http::result::SdkError<crate::error::UpdateLedgerError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the ledger.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>The flag that prevents a ledger from being deleted by any user. If not provided on
        /// ledger creation, this feature is enabled (<code>true</code>) by default.</p>
        /// <p>If deletion protection is enabled, you must first disable it before you can delete the
        /// ledger using the QLDB API or the AWS Command Line Interface (AWS CLI). You can disable it by calling the
        /// <code>UpdateLedger</code> operation to set the flag to <code>false</code>. The QLDB
        /// console disables deletion protection for you when you use it to delete a ledger.</p>
        pub fn deletion_protection(mut self, inp: bool) -> Self {
            self.inner = self.inner.deletion_protection(inp);
            self
        }
        pub fn set_deletion_protection(mut self, inp: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_deletion_protection(inp);
            self
        }
    }
}
