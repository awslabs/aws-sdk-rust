// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn delete_object(&self) -> fluent_builders::DeleteObject<C> {
        fluent_builders::DeleteObject::new(self.handle.clone())
    }
    pub fn describe_object(&self) -> fluent_builders::DescribeObject<C> {
        fluent_builders::DescribeObject::new(self.handle.clone())
    }
    pub fn get_object(&self) -> fluent_builders::GetObject<C> {
        fluent_builders::GetObject::new(self.handle.clone())
    }
    pub fn list_items(&self) -> fluent_builders::ListItems<C> {
        fluent_builders::ListItems::new(self.handle.clone())
    }
    pub fn put_object(&self) -> fluent_builders::PutObject<C> {
        fluent_builders::PutObject::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct DeleteObject<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_object_input::Builder,
    }
    impl<C> DeleteObject<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteObjectOutput,
            smithy_http::result::SdkError<crate::error::DeleteObjectError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The path (including the file name) where the object is stored in the container.
        /// Format: <folder name>/<folder name>/<file name></p>
        pub fn path(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.path(input);
            self
        }
        pub fn set_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_path(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeObject<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_object_input::Builder,
    }
    impl<C> DescribeObject<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeObjectOutput,
            smithy_http::result::SdkError<crate::error::DescribeObjectError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The path (including the file name) where the object is stored in the container.
        /// Format: <folder name>/<folder name>/<file name></p>
        pub fn path(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.path(input);
            self
        }
        pub fn set_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_path(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetObject<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_object_input::Builder,
    }
    impl<C> GetObject<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetObjectOutput,
            smithy_http::result::SdkError<crate::error::GetObjectError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The path (including the file name) where the object is stored in the container.
        /// Format: <folder name>/<folder name>/<file name></p>
        /// <p>For example, to upload the file <code>mlaw.avi</code> to the folder path
        /// <code>premium\canada</code> in the container <code>movies</code>, enter the path
        /// <code>premium/canada/mlaw.avi</code>.</p>
        /// <p>Do not include the container name in this path.</p>
        /// <p>If the path includes any folders that don't exist yet, the service creates them. For
        /// example, suppose you have an existing <code>premium/usa</code> subfolder. If you specify
        /// <code>premium/canada</code>, the service creates a <code>canada</code> subfolder in the
        /// <code>premium</code> folder. You then have two subfolders, <code>usa</code> and
        /// <code>canada</code>, in the <code>premium</code> folder. </p>
        /// <p>There is no correlation between the path to the source and the path (folders) in the
        /// container in AWS Elemental MediaStore.</p>
        /// <p>For more information about folders and how they exist in a container, see the <a href="http://docs.aws.amazon.com/mediastore/latest/ug/">AWS Elemental MediaStore User
        /// Guide</a>.</p>
        /// <p>The file name is the name that is assigned to the file that you upload. The file can
        /// have the same name inside and outside of AWS Elemental MediaStore, or it can have the same
        /// name. The file name can include or omit an extension. </p>
        pub fn path(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.path(input);
            self
        }
        pub fn set_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_path(input);
            self
        }
        /// <p>The range bytes of an object to retrieve. For more information about the
        /// <code>Range</code> header, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35</a>. AWS Elemental MediaStore ignores this header for partially uploaded objects that have streaming upload availability.</p>
        pub fn range(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.range(input);
            self
        }
        pub fn set_range(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_range(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListItems<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_items_input::Builder,
    }
    impl<C> ListItems<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListItemsOutput,
            smithy_http::result::SdkError<crate::error::ListItemsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The path in the container from which to retrieve items. Format: <folder
        /// name>/<folder name>/<file name></p>
        pub fn path(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.path(input);
            self
        }
        pub fn set_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_path(input);
            self
        }
        /// <p>The maximum number of results to return per API request. For example, you submit a
        /// <code>ListItems</code> request with <code>MaxResults</code> set at 500. Although 2,000
        /// items match your request, the service returns no more than the first 500 items. (The
        /// service also returns a <code>NextToken</code> value that you can use to fetch the next
        /// batch of results.) The service might return fewer results than the <code>MaxResults</code>
        /// value.</p>
        /// <p>If <code>MaxResults</code> is not included in the request, the service defaults to
        /// pagination with a maximum of 1,000 results per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token that identifies which batch of results that you want to see. For example,
        /// you submit a <code>ListItems</code> request with <code>MaxResults</code> set at 500. The
        /// service returns the first batch of results (up to 500) and a <code>NextToken</code> value.
        /// To see the next batch of results, you can submit the <code>ListItems</code> request a
        /// second time and specify the <code>NextToken</code> value.</p>
        /// <p>Tokens expire after 15 minutes.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutObject<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_object_input::Builder,
    }
    impl<C> PutObject<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutObjectOutput,
            smithy_http::result::SdkError<crate::error::PutObjectError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The bytes to be stored. </p>
        pub fn body(mut self, input: smithy_http::byte_stream::ByteStream) -> Self {
            self.inner = self.inner.body(input);
            self
        }
        pub fn set_body(
            mut self,
            input: std::option::Option<smithy_http::byte_stream::ByteStream>,
        ) -> Self {
            self.inner = self.inner.set_body(input);
            self
        }
        /// <p>The path (including the file name) where the object is stored in the container.
        /// Format: <folder name>/<folder name>/<file name></p>
        /// <p>For example, to upload the file <code>mlaw.avi</code> to the folder path
        /// <code>premium\canada</code> in the container <code>movies</code>, enter the path
        /// <code>premium/canada/mlaw.avi</code>.</p>
        /// <p>Do not include the container name in this path.</p>
        /// <p>If the path includes any folders that don't exist yet, the service creates them. For
        /// example, suppose you have an existing <code>premium/usa</code> subfolder. If you specify
        /// <code>premium/canada</code>, the service creates a <code>canada</code> subfolder in the
        /// <code>premium</code> folder. You then have two subfolders, <code>usa</code> and
        /// <code>canada</code>, in the <code>premium</code> folder. </p>
        /// <p>There is no correlation between the path to the source and the path (folders) in the
        /// container in AWS Elemental MediaStore.</p>
        /// <p>For more information about folders and how they exist in a container, see the <a href="http://docs.aws.amazon.com/mediastore/latest/ug/">AWS Elemental MediaStore User
        /// Guide</a>.</p>
        /// <p>The file name is the name that is assigned to the file that you upload. The file can
        /// have the same name inside and outside of AWS Elemental MediaStore, or it can have the same
        /// name. The file name can include or omit an extension. </p>
        pub fn path(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.path(input);
            self
        }
        pub fn set_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_path(input);
            self
        }
        /// <p>The content type of the object.</p>
        pub fn content_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_type(input);
            self
        }
        pub fn set_content_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_content_type(input);
            self
        }
        /// <p>An optional <code>CacheControl</code> header that allows the caller to control the
        /// object's cache behavior. Headers can be passed in as specified in the HTTP at <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9</a>.</p>
        /// <p>Headers with a custom user-defined value are also accepted.</p>
        pub fn cache_control(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cache_control(input);
            self
        }
        pub fn set_cache_control(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_cache_control(input);
            self
        }
        /// <p>Indicates the storage class of a <code>Put</code> request. Defaults to
        /// high-performance temporal storage class, and objects are persisted into durable storage
        /// shortly after being received.</p>
        pub fn storage_class(mut self, input: crate::model::StorageClass) -> Self {
            self.inner = self.inner.storage_class(input);
            self
        }
        pub fn set_storage_class(
            mut self,
            input: std::option::Option<crate::model::StorageClass>,
        ) -> Self {
            self.inner = self.inner.set_storage_class(input);
            self
        }
        /// <p>Indicates the availability of an object while it is still uploading. If the value is set to <code>streaming</code>, the object is available for
        /// downloading after some initial buffering but before the object is uploaded completely. If the value is set to <code>standard</code>, the object is
        /// available for downloading only when it is uploaded completely. The default value for this header is <code>standard</code>.</p>
        /// <p>To use this header, you must also set the HTTP <code>Transfer-Encoding</code> header to <code>chunked</code>.</p>
        pub fn upload_availability(mut self, input: crate::model::UploadAvailability) -> Self {
            self.inner = self.inner.upload_availability(input);
            self
        }
        pub fn set_upload_availability(
            mut self,
            input: std::option::Option<crate::model::UploadAvailability>,
        ) -> Self {
            self.inner = self.inner.set_upload_availability(input);
            self
        }
    }
}
