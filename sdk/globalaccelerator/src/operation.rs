// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Associate a virtual private cloud (VPC) subnet endpoint with your custom routing accelerator.</p>
/// <p>The listener port range must be large enough to support the number of IP addresses that can be
/// specified in your subnet. The number of ports required is: subnet size times the number
/// of ports per destination EC2 instances. For example, a subnet defined as /24 requires a listener
/// port range of at least 255 ports. </p>
/// <p>Note: You must have enough remaining listener ports available to
/// map to the subnet ports, or the call will fail with a LimitExceededException.</p>
/// <p>By default, all destinations in a subnet in a custom routing accelerator cannot receive traffic. To enable all
/// destinations to receive traffic, or to specify individual port mappings that can receive
/// traffic, see the <a href="https://docs.aws.amazon.com/global-accelerator/latest/api/API_AllowCustomRoutingTraffic.html">
/// AllowCustomRoutingTraffic</a> operation.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AddCustomRoutingEndpoints {
    _private: (),
}
impl AddCustomRoutingEndpoints {
    /// Creates a new builder-style object to manufacture [`AddCustomRoutingEndpointsInput`](crate::input::AddCustomRoutingEndpointsInput)
    pub fn builder() -> crate::input::add_custom_routing_endpoints_input::Builder {
        crate::input::add_custom_routing_endpoints_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AddCustomRoutingEndpoints {
    type Output = std::result::Result<
        crate::output::AddCustomRoutingEndpointsOutput,
        crate::error::AddCustomRoutingEndpointsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_add_custom_routing_endpoints_error(response)
        } else {
            crate::operation_deser::parse_add_custom_routing_endpoints_response(response)
        }
    }
}

/// <p>Advertises an IPv4 address range that is provisioned for use with your AWS resources
/// through bring your own IP addresses (BYOIP). It can take a few minutes before traffic to
/// the specified addresses starts routing to AWS because of propagation delays. </p>
/// <p>To stop advertising the BYOIP address range, use <a href="https://docs.aws.amazon.com/global-accelerator/latest/api/WithdrawByoipCidr.html">
/// WithdrawByoipCidr</a>.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/using-byoip.html">Bring Your Own
/// IP Addresses (BYOIP)</a> in the <i>AWS Global Accelerator Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AdvertiseByoipCidr {
    _private: (),
}
impl AdvertiseByoipCidr {
    /// Creates a new builder-style object to manufacture [`AdvertiseByoipCidrInput`](crate::input::AdvertiseByoipCidrInput)
    pub fn builder() -> crate::input::advertise_byoip_cidr_input::Builder {
        crate::input::advertise_byoip_cidr_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AdvertiseByoipCidr {
    type Output = std::result::Result<
        crate::output::AdvertiseByoipCidrOutput,
        crate::error::AdvertiseByoipCidrError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_advertise_byoip_cidr_error(response)
        } else {
            crate::operation_deser::parse_advertise_byoip_cidr_response(response)
        }
    }
}

/// <p>Specify the Amazon EC2 instance (destination) IP addresses and ports for a VPC subnet endpoint that can receive traffic
/// for a custom routing accelerator. You can allow traffic to all destinations in the subnet endpoint, or allow traffic to a
/// specified list of destination IP addresses and ports in the subnet. Note that you cannot specify IP addresses or ports
/// outside of the range that you configured for the endpoint group.</p>
/// <p>After you make changes, you can verify that the updates are complete by checking the status of your
/// accelerator: the status changes from IN_PROGRESS to DEPLOYED.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AllowCustomRoutingTraffic {
    _private: (),
}
impl AllowCustomRoutingTraffic {
    /// Creates a new builder-style object to manufacture [`AllowCustomRoutingTrafficInput`](crate::input::AllowCustomRoutingTrafficInput)
    pub fn builder() -> crate::input::allow_custom_routing_traffic_input::Builder {
        crate::input::allow_custom_routing_traffic_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AllowCustomRoutingTraffic {
    type Output = std::result::Result<
        crate::output::AllowCustomRoutingTrafficOutput,
        crate::error::AllowCustomRoutingTrafficError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_allow_custom_routing_traffic_error(response)
        } else {
            crate::operation_deser::parse_allow_custom_routing_traffic_response(response)
        }
    }
}

/// <p>Create an accelerator. An accelerator includes one or more listeners that process inbound connections and direct traffic
/// to one or more endpoint groups, each of which includes endpoints, such as Network Load Balancers. </p>  
/// <important>
/// <p>Global Accelerator is a global service that supports endpoints in multiple AWS Regions but you must specify the
/// US West (Oregon) Region to create or update accelerators.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateAccelerator {
    _private: (),
}
impl CreateAccelerator {
    /// Creates a new builder-style object to manufacture [`CreateAcceleratorInput`](crate::input::CreateAcceleratorInput)
    pub fn builder() -> crate::input::create_accelerator_input::Builder {
        crate::input::create_accelerator_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateAccelerator {
    type Output = std::result::Result<
        crate::output::CreateAcceleratorOutput,
        crate::error::CreateAcceleratorError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_accelerator_error(response)
        } else {
            crate::operation_deser::parse_create_accelerator_response(response)
        }
    }
}

/// <p>Create a custom routing accelerator. A custom routing accelerator directs traffic to one of possibly thousands
/// of Amazon EC2 instance destinations running in a single or multiple virtual private clouds (VPC) subnet endpoints.</p>
/// <p>Be aware that, by default, all destination EC2 instances in a VPC subnet endpoint cannot receive
/// traffic. To enable all destinations to receive traffic, or to specify individual port
/// mappings that can receive traffic, see the <a href="https://docs.aws.amazon.com/global-accelerator/latest/api/API_AllowCustomRoutingTraffic.html">
/// AllowCustomRoutingTraffic</a> operation.</p>
/// <important>
/// <p>Global Accelerator is a global service that supports endpoints in multiple AWS Regions but you must specify the
/// US West (Oregon) Region to create or update accelerators.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateCustomRoutingAccelerator {
    _private: (),
}
impl CreateCustomRoutingAccelerator {
    /// Creates a new builder-style object to manufacture [`CreateCustomRoutingAcceleratorInput`](crate::input::CreateCustomRoutingAcceleratorInput)
    pub fn builder() -> crate::input::create_custom_routing_accelerator_input::Builder {
        crate::input::create_custom_routing_accelerator_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateCustomRoutingAccelerator {
    type Output = std::result::Result<
        crate::output::CreateCustomRoutingAcceleratorOutput,
        crate::error::CreateCustomRoutingAcceleratorError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_custom_routing_accelerator_error(response)
        } else {
            crate::operation_deser::parse_create_custom_routing_accelerator_response(response)
        }
    }
}

/// <p>Create an endpoint group for the specified listener for a custom routing accelerator.
/// An endpoint group is a collection of endpoints in one AWS
/// Region. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateCustomRoutingEndpointGroup {
    _private: (),
}
impl CreateCustomRoutingEndpointGroup {
    /// Creates a new builder-style object to manufacture [`CreateCustomRoutingEndpointGroupInput`](crate::input::CreateCustomRoutingEndpointGroupInput)
    pub fn builder() -> crate::input::create_custom_routing_endpoint_group_input::Builder {
        crate::input::create_custom_routing_endpoint_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateCustomRoutingEndpointGroup {
    type Output = std::result::Result<
        crate::output::CreateCustomRoutingEndpointGroupOutput,
        crate::error::CreateCustomRoutingEndpointGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_custom_routing_endpoint_group_error(response)
        } else {
            crate::operation_deser::parse_create_custom_routing_endpoint_group_response(response)
        }
    }
}

/// <p>Create a listener to process inbound connections from clients to a custom routing accelerator.
/// Connections arrive to assigned static IP addresses on the port range that you specify. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateCustomRoutingListener {
    _private: (),
}
impl CreateCustomRoutingListener {
    /// Creates a new builder-style object to manufacture [`CreateCustomRoutingListenerInput`](crate::input::CreateCustomRoutingListenerInput)
    pub fn builder() -> crate::input::create_custom_routing_listener_input::Builder {
        crate::input::create_custom_routing_listener_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateCustomRoutingListener {
    type Output = std::result::Result<
        crate::output::CreateCustomRoutingListenerOutput,
        crate::error::CreateCustomRoutingListenerError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_custom_routing_listener_error(response)
        } else {
            crate::operation_deser::parse_create_custom_routing_listener_response(response)
        }
    }
}

/// <p>Create an endpoint group for the specified listener. An endpoint group is a collection of endpoints in one AWS
/// Region. A resource must be valid and active when you add it as an endpoint.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateEndpointGroup {
    _private: (),
}
impl CreateEndpointGroup {
    /// Creates a new builder-style object to manufacture [`CreateEndpointGroupInput`](crate::input::CreateEndpointGroupInput)
    pub fn builder() -> crate::input::create_endpoint_group_input::Builder {
        crate::input::create_endpoint_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateEndpointGroup {
    type Output = std::result::Result<
        crate::output::CreateEndpointGroupOutput,
        crate::error::CreateEndpointGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_endpoint_group_error(response)
        } else {
            crate::operation_deser::parse_create_endpoint_group_response(response)
        }
    }
}

/// <p>Create a listener to process inbound connections from clients to an accelerator. Connections arrive to assigned static
/// IP addresses on a port, port range, or list of port ranges that you specify. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateListener {
    _private: (),
}
impl CreateListener {
    /// Creates a new builder-style object to manufacture [`CreateListenerInput`](crate::input::CreateListenerInput)
    pub fn builder() -> crate::input::create_listener_input::Builder {
        crate::input::create_listener_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateListener {
    type Output =
        std::result::Result<crate::output::CreateListenerOutput, crate::error::CreateListenerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_listener_error(response)
        } else {
            crate::operation_deser::parse_create_listener_response(response)
        }
    }
}

/// <p>Delete an accelerator. Before you can delete an accelerator, you must disable it and remove all dependent resources
/// (listeners and endpoint groups). To disable the accelerator, update the accelerator to set <code>Enabled</code> to false.</p>
/// <important>
/// <p>When you create an accelerator, by default, Global Accelerator provides you with a set of two static IP addresses.
/// Alternatively, you can bring your own IP address ranges to Global Accelerator and assign IP addresses from those ranges.
/// </p>
/// <p>The IP addresses are assigned to your accelerator for as long as it exists, even if you disable the accelerator and
/// it no longer accepts or routes traffic. However, when you <i>delete</i> an accelerator, you lose the
/// static IP addresses that are assigned to the accelerator, so you can no longer route traffic by using them.
/// As a best practice, ensure that you have permissions in place to avoid inadvertently deleting accelerators. You
/// can use IAM policies with Global Accelerator to limit the users who have permissions to delete an accelerator. For more information,
/// see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/auth-and-access-control.html">Authentication and Access Control</a> in
/// the <i>AWS Global Accelerator Developer Guide</i>.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteAccelerator {
    _private: (),
}
impl DeleteAccelerator {
    /// Creates a new builder-style object to manufacture [`DeleteAcceleratorInput`](crate::input::DeleteAcceleratorInput)
    pub fn builder() -> crate::input::delete_accelerator_input::Builder {
        crate::input::delete_accelerator_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteAccelerator {
    type Output = std::result::Result<
        crate::output::DeleteAcceleratorOutput,
        crate::error::DeleteAcceleratorError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_accelerator_error(response)
        } else {
            crate::operation_deser::parse_delete_accelerator_response(response)
        }
    }
}

/// <p>Delete a custom routing accelerator. Before you can delete an accelerator, you must disable it and remove all dependent resources
/// (listeners and endpoint groups). To disable the accelerator, update the accelerator to set <code>Enabled</code> to false.</p>
/// <important>
/// <p>When you create a custom routing accelerator, by default, Global Accelerator provides you with a set of two static IP addresses.
/// </p>
/// <p>The IP
/// addresses are assigned to your accelerator for as long as it exists, even if you disable the accelerator and
/// it no longer accepts or routes traffic. However, when you <i>delete</i> an accelerator, you lose the
/// static IP addresses that are assigned to the accelerator, so you can no longer route traffic by using them.
/// As a best practice, ensure that you have permissions in place to avoid inadvertently deleting accelerators. You
/// can use IAM policies with Global Accelerator to limit the users who have permissions to delete an accelerator. For more information,
/// see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/auth-and-access-control.html">Authentication and Access Control</a> in
/// the <i>AWS Global Accelerator Developer Guide</i>.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteCustomRoutingAccelerator {
    _private: (),
}
impl DeleteCustomRoutingAccelerator {
    /// Creates a new builder-style object to manufacture [`DeleteCustomRoutingAcceleratorInput`](crate::input::DeleteCustomRoutingAcceleratorInput)
    pub fn builder() -> crate::input::delete_custom_routing_accelerator_input::Builder {
        crate::input::delete_custom_routing_accelerator_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteCustomRoutingAccelerator {
    type Output = std::result::Result<
        crate::output::DeleteCustomRoutingAcceleratorOutput,
        crate::error::DeleteCustomRoutingAcceleratorError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_custom_routing_accelerator_error(response)
        } else {
            crate::operation_deser::parse_delete_custom_routing_accelerator_response(response)
        }
    }
}

/// <p>Delete an endpoint group from a listener for a custom routing accelerator.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteCustomRoutingEndpointGroup {
    _private: (),
}
impl DeleteCustomRoutingEndpointGroup {
    /// Creates a new builder-style object to manufacture [`DeleteCustomRoutingEndpointGroupInput`](crate::input::DeleteCustomRoutingEndpointGroupInput)
    pub fn builder() -> crate::input::delete_custom_routing_endpoint_group_input::Builder {
        crate::input::delete_custom_routing_endpoint_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteCustomRoutingEndpointGroup {
    type Output = std::result::Result<
        crate::output::DeleteCustomRoutingEndpointGroupOutput,
        crate::error::DeleteCustomRoutingEndpointGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_custom_routing_endpoint_group_error(response)
        } else {
            crate::operation_deser::parse_delete_custom_routing_endpoint_group_response(response)
        }
    }
}

/// <p>Delete a listener for a custom routing accelerator.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteCustomRoutingListener {
    _private: (),
}
impl DeleteCustomRoutingListener {
    /// Creates a new builder-style object to manufacture [`DeleteCustomRoutingListenerInput`](crate::input::DeleteCustomRoutingListenerInput)
    pub fn builder() -> crate::input::delete_custom_routing_listener_input::Builder {
        crate::input::delete_custom_routing_listener_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteCustomRoutingListener {
    type Output = std::result::Result<
        crate::output::DeleteCustomRoutingListenerOutput,
        crate::error::DeleteCustomRoutingListenerError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_custom_routing_listener_error(response)
        } else {
            crate::operation_deser::parse_delete_custom_routing_listener_response(response)
        }
    }
}

/// <p>Delete an endpoint group from a listener.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteEndpointGroup {
    _private: (),
}
impl DeleteEndpointGroup {
    /// Creates a new builder-style object to manufacture [`DeleteEndpointGroupInput`](crate::input::DeleteEndpointGroupInput)
    pub fn builder() -> crate::input::delete_endpoint_group_input::Builder {
        crate::input::delete_endpoint_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteEndpointGroup {
    type Output = std::result::Result<
        crate::output::DeleteEndpointGroupOutput,
        crate::error::DeleteEndpointGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_endpoint_group_error(response)
        } else {
            crate::operation_deser::parse_delete_endpoint_group_response(response)
        }
    }
}

/// <p>Delete a listener from an accelerator.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteListener {
    _private: (),
}
impl DeleteListener {
    /// Creates a new builder-style object to manufacture [`DeleteListenerInput`](crate::input::DeleteListenerInput)
    pub fn builder() -> crate::input::delete_listener_input::Builder {
        crate::input::delete_listener_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteListener {
    type Output =
        std::result::Result<crate::output::DeleteListenerOutput, crate::error::DeleteListenerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_listener_error(response)
        } else {
            crate::operation_deser::parse_delete_listener_response(response)
        }
    }
}

/// <p>Specify the Amazon EC2 instance (destination) IP addresses and ports for a VPC subnet endpoint that cannot receive traffic
/// for a custom routing accelerator. You can deny traffic to all destinations in the VPC endpoint, or deny traffic to a
/// specified list of destination IP addresses and ports. Note that you cannot specify IP addresses
/// or ports outside of the range that you configured for the endpoint group.</p>
/// <p>After you make changes, you can verify that the updates are complete by checking the status of your
/// accelerator: the status changes from IN_PROGRESS to DEPLOYED.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DenyCustomRoutingTraffic {
    _private: (),
}
impl DenyCustomRoutingTraffic {
    /// Creates a new builder-style object to manufacture [`DenyCustomRoutingTrafficInput`](crate::input::DenyCustomRoutingTrafficInput)
    pub fn builder() -> crate::input::deny_custom_routing_traffic_input::Builder {
        crate::input::deny_custom_routing_traffic_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DenyCustomRoutingTraffic {
    type Output = std::result::Result<
        crate::output::DenyCustomRoutingTrafficOutput,
        crate::error::DenyCustomRoutingTrafficError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_deny_custom_routing_traffic_error(response)
        } else {
            crate::operation_deser::parse_deny_custom_routing_traffic_response(response)
        }
    }
}

/// <p>Releases the specified address range that you provisioned to use with your AWS resources
/// through bring your own IP addresses (BYOIP) and deletes the corresponding address pool. </p>
/// <p>Before you can release an address range, you must stop advertising it by using <a href="https://docs.aws.amazon.com/global-accelerator/latest/api/WithdrawByoipCidr.html">WithdrawByoipCidr</a> and you must not have
/// any accelerators that are using static IP addresses allocated from its address range.
/// </p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/using-byoip.html">Bring Your Own
/// IP Addresses (BYOIP)</a> in the <i>AWS Global Accelerator Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeprovisionByoipCidr {
    _private: (),
}
impl DeprovisionByoipCidr {
    /// Creates a new builder-style object to manufacture [`DeprovisionByoipCidrInput`](crate::input::DeprovisionByoipCidrInput)
    pub fn builder() -> crate::input::deprovision_byoip_cidr_input::Builder {
        crate::input::deprovision_byoip_cidr_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeprovisionByoipCidr {
    type Output = std::result::Result<
        crate::output::DeprovisionByoipCidrOutput,
        crate::error::DeprovisionByoipCidrError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_deprovision_byoip_cidr_error(response)
        } else {
            crate::operation_deser::parse_deprovision_byoip_cidr_response(response)
        }
    }
}

/// <p>Describe an accelerator. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeAccelerator {
    _private: (),
}
impl DescribeAccelerator {
    /// Creates a new builder-style object to manufacture [`DescribeAcceleratorInput`](crate::input::DescribeAcceleratorInput)
    pub fn builder() -> crate::input::describe_accelerator_input::Builder {
        crate::input::describe_accelerator_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeAccelerator {
    type Output = std::result::Result<
        crate::output::DescribeAcceleratorOutput,
        crate::error::DescribeAcceleratorError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_accelerator_error(response)
        } else {
            crate::operation_deser::parse_describe_accelerator_response(response)
        }
    }
}

/// <p>Describe the attributes of an accelerator.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeAcceleratorAttributes {
    _private: (),
}
impl DescribeAcceleratorAttributes {
    /// Creates a new builder-style object to manufacture [`DescribeAcceleratorAttributesInput`](crate::input::DescribeAcceleratorAttributesInput)
    pub fn builder() -> crate::input::describe_accelerator_attributes_input::Builder {
        crate::input::describe_accelerator_attributes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeAcceleratorAttributes {
    type Output = std::result::Result<
        crate::output::DescribeAcceleratorAttributesOutput,
        crate::error::DescribeAcceleratorAttributesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_accelerator_attributes_error(response)
        } else {
            crate::operation_deser::parse_describe_accelerator_attributes_response(response)
        }
    }
}

/// <p>Describe a custom routing accelerator. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeCustomRoutingAccelerator {
    _private: (),
}
impl DescribeCustomRoutingAccelerator {
    /// Creates a new builder-style object to manufacture [`DescribeCustomRoutingAcceleratorInput`](crate::input::DescribeCustomRoutingAcceleratorInput)
    pub fn builder() -> crate::input::describe_custom_routing_accelerator_input::Builder {
        crate::input::describe_custom_routing_accelerator_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeCustomRoutingAccelerator {
    type Output = std::result::Result<
        crate::output::DescribeCustomRoutingAcceleratorOutput,
        crate::error::DescribeCustomRoutingAcceleratorError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_custom_routing_accelerator_error(response)
        } else {
            crate::operation_deser::parse_describe_custom_routing_accelerator_response(response)
        }
    }
}

/// <p>Describe the attributes of a custom routing accelerator. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeCustomRoutingAcceleratorAttributes {
    _private: (),
}
impl DescribeCustomRoutingAcceleratorAttributes {
    /// Creates a new builder-style object to manufacture [`DescribeCustomRoutingAcceleratorAttributesInput`](crate::input::DescribeCustomRoutingAcceleratorAttributesInput)
    pub fn builder() -> crate::input::describe_custom_routing_accelerator_attributes_input::Builder
    {
        crate::input::describe_custom_routing_accelerator_attributes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeCustomRoutingAcceleratorAttributes {
    type Output = std::result::Result<
        crate::output::DescribeCustomRoutingAcceleratorAttributesOutput,
        crate::error::DescribeCustomRoutingAcceleratorAttributesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_custom_routing_accelerator_attributes_error(
                response,
            )
        } else {
            crate::operation_deser::parse_describe_custom_routing_accelerator_attributes_response(
                response,
            )
        }
    }
}

/// <p>Describe an endpoint group for a custom routing accelerator. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeCustomRoutingEndpointGroup {
    _private: (),
}
impl DescribeCustomRoutingEndpointGroup {
    /// Creates a new builder-style object to manufacture [`DescribeCustomRoutingEndpointGroupInput`](crate::input::DescribeCustomRoutingEndpointGroupInput)
    pub fn builder() -> crate::input::describe_custom_routing_endpoint_group_input::Builder {
        crate::input::describe_custom_routing_endpoint_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeCustomRoutingEndpointGroup {
    type Output = std::result::Result<
        crate::output::DescribeCustomRoutingEndpointGroupOutput,
        crate::error::DescribeCustomRoutingEndpointGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_custom_routing_endpoint_group_error(response)
        } else {
            crate::operation_deser::parse_describe_custom_routing_endpoint_group_response(response)
        }
    }
}

/// <p>The description of a listener for a custom routing accelerator.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeCustomRoutingListener {
    _private: (),
}
impl DescribeCustomRoutingListener {
    /// Creates a new builder-style object to manufacture [`DescribeCustomRoutingListenerInput`](crate::input::DescribeCustomRoutingListenerInput)
    pub fn builder() -> crate::input::describe_custom_routing_listener_input::Builder {
        crate::input::describe_custom_routing_listener_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeCustomRoutingListener {
    type Output = std::result::Result<
        crate::output::DescribeCustomRoutingListenerOutput,
        crate::error::DescribeCustomRoutingListenerError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_custom_routing_listener_error(response)
        } else {
            crate::operation_deser::parse_describe_custom_routing_listener_response(response)
        }
    }
}

/// <p>Describe an endpoint group. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeEndpointGroup {
    _private: (),
}
impl DescribeEndpointGroup {
    /// Creates a new builder-style object to manufacture [`DescribeEndpointGroupInput`](crate::input::DescribeEndpointGroupInput)
    pub fn builder() -> crate::input::describe_endpoint_group_input::Builder {
        crate::input::describe_endpoint_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeEndpointGroup {
    type Output = std::result::Result<
        crate::output::DescribeEndpointGroupOutput,
        crate::error::DescribeEndpointGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_endpoint_group_error(response)
        } else {
            crate::operation_deser::parse_describe_endpoint_group_response(response)
        }
    }
}

/// <p>Describe a listener. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeListener {
    _private: (),
}
impl DescribeListener {
    /// Creates a new builder-style object to manufacture [`DescribeListenerInput`](crate::input::DescribeListenerInput)
    pub fn builder() -> crate::input::describe_listener_input::Builder {
        crate::input::describe_listener_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeListener {
    type Output = std::result::Result<
        crate::output::DescribeListenerOutput,
        crate::error::DescribeListenerError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_listener_error(response)
        } else {
            crate::operation_deser::parse_describe_listener_response(response)
        }
    }
}

/// <p>List the accelerators for an AWS account. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListAccelerators {
    _private: (),
}
impl ListAccelerators {
    /// Creates a new builder-style object to manufacture [`ListAcceleratorsInput`](crate::input::ListAcceleratorsInput)
    pub fn builder() -> crate::input::list_accelerators_input::Builder {
        crate::input::list_accelerators_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListAccelerators {
    type Output = std::result::Result<
        crate::output::ListAcceleratorsOutput,
        crate::error::ListAcceleratorsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_accelerators_error(response)
        } else {
            crate::operation_deser::parse_list_accelerators_response(response)
        }
    }
}

/// <p>Lists the IP address ranges that were specified in calls to <a href="https://docs.aws.amazon.com/global-accelerator/latest/api/ProvisionByoipCidr.html">ProvisionByoipCidr</a>, including
/// the current state and a history of state changes.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListByoipCidrs {
    _private: (),
}
impl ListByoipCidrs {
    /// Creates a new builder-style object to manufacture [`ListByoipCidrsInput`](crate::input::ListByoipCidrsInput)
    pub fn builder() -> crate::input::list_byoip_cidrs_input::Builder {
        crate::input::list_byoip_cidrs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListByoipCidrs {
    type Output =
        std::result::Result<crate::output::ListByoipCidrsOutput, crate::error::ListByoipCidrsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_byoip_cidrs_error(response)
        } else {
            crate::operation_deser::parse_list_byoip_cidrs_response(response)
        }
    }
}

/// <p>List the custom routing accelerators for an AWS account. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListCustomRoutingAccelerators {
    _private: (),
}
impl ListCustomRoutingAccelerators {
    /// Creates a new builder-style object to manufacture [`ListCustomRoutingAcceleratorsInput`](crate::input::ListCustomRoutingAcceleratorsInput)
    pub fn builder() -> crate::input::list_custom_routing_accelerators_input::Builder {
        crate::input::list_custom_routing_accelerators_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListCustomRoutingAccelerators {
    type Output = std::result::Result<
        crate::output::ListCustomRoutingAcceleratorsOutput,
        crate::error::ListCustomRoutingAcceleratorsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_custom_routing_accelerators_error(response)
        } else {
            crate::operation_deser::parse_list_custom_routing_accelerators_response(response)
        }
    }
}

/// <p>List the endpoint groups that are associated with a listener for a custom routing accelerator. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListCustomRoutingEndpointGroups {
    _private: (),
}
impl ListCustomRoutingEndpointGroups {
    /// Creates a new builder-style object to manufacture [`ListCustomRoutingEndpointGroupsInput`](crate::input::ListCustomRoutingEndpointGroupsInput)
    pub fn builder() -> crate::input::list_custom_routing_endpoint_groups_input::Builder {
        crate::input::list_custom_routing_endpoint_groups_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListCustomRoutingEndpointGroups {
    type Output = std::result::Result<
        crate::output::ListCustomRoutingEndpointGroupsOutput,
        crate::error::ListCustomRoutingEndpointGroupsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_custom_routing_endpoint_groups_error(response)
        } else {
            crate::operation_deser::parse_list_custom_routing_endpoint_groups_response(response)
        }
    }
}

/// <p>List the listeners for a custom routing accelerator. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListCustomRoutingListeners {
    _private: (),
}
impl ListCustomRoutingListeners {
    /// Creates a new builder-style object to manufacture [`ListCustomRoutingListenersInput`](crate::input::ListCustomRoutingListenersInput)
    pub fn builder() -> crate::input::list_custom_routing_listeners_input::Builder {
        crate::input::list_custom_routing_listeners_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListCustomRoutingListeners {
    type Output = std::result::Result<
        crate::output::ListCustomRoutingListenersOutput,
        crate::error::ListCustomRoutingListenersError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_custom_routing_listeners_error(response)
        } else {
            crate::operation_deser::parse_list_custom_routing_listeners_response(response)
        }
    }
}

/// <p>Provides a complete mapping from the public accelerator IP address and port to destination EC2 instance
/// IP addresses and ports in the virtual public cloud (VPC) subnet endpoint for a custom routing accelerator.
/// For each subnet endpoint that you add, Global Accelerator creates a new static port mapping for the accelerator. The port
/// mappings don't change after Global Accelerator generates them, so you can retrieve and cache the full mapping on your servers. </p>
/// <p>If you remove a subnet from your accelerator, Global Accelerator removes (reclaims) the port mappings. If you add a subnet to
/// your accelerator, Global Accelerator creates new port mappings (the existing ones don't change). If you add or remove EC2 instances
/// in your subnet, the port mappings don't change, because the mappings are created when you add the subnet to Global Accelerator.</p>
/// <p>The mappings also include a flag for each destination denoting which destination IP addresses and
/// ports are allowed or denied traffic.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListCustomRoutingPortMappings {
    _private: (),
}
impl ListCustomRoutingPortMappings {
    /// Creates a new builder-style object to manufacture [`ListCustomRoutingPortMappingsInput`](crate::input::ListCustomRoutingPortMappingsInput)
    pub fn builder() -> crate::input::list_custom_routing_port_mappings_input::Builder {
        crate::input::list_custom_routing_port_mappings_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListCustomRoutingPortMappings {
    type Output = std::result::Result<
        crate::output::ListCustomRoutingPortMappingsOutput,
        crate::error::ListCustomRoutingPortMappingsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_custom_routing_port_mappings_error(response)
        } else {
            crate::operation_deser::parse_list_custom_routing_port_mappings_response(response)
        }
    }
}

/// <p>List the port mappings for a specific EC2 instance (destination) in a VPC subnet endpoint. The
/// response is the mappings for one destination IP address. This is useful when your subnet endpoint has mappings that
/// span multiple custom routing accelerators in your account, or for scenarios where you only want to
/// list the port mappings for a specific destination instance.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListCustomRoutingPortMappingsByDestination {
    _private: (),
}
impl ListCustomRoutingPortMappingsByDestination {
    /// Creates a new builder-style object to manufacture [`ListCustomRoutingPortMappingsByDestinationInput`](crate::input::ListCustomRoutingPortMappingsByDestinationInput)
    pub fn builder() -> crate::input::list_custom_routing_port_mappings_by_destination_input::Builder
    {
        crate::input::list_custom_routing_port_mappings_by_destination_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListCustomRoutingPortMappingsByDestination {
    type Output = std::result::Result<
        crate::output::ListCustomRoutingPortMappingsByDestinationOutput,
        crate::error::ListCustomRoutingPortMappingsByDestinationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_custom_routing_port_mappings_by_destination_error(
                response,
            )
        } else {
            crate::operation_deser::parse_list_custom_routing_port_mappings_by_destination_response(
                response,
            )
        }
    }
}

/// <p>List the endpoint groups that are associated with a listener. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListEndpointGroups {
    _private: (),
}
impl ListEndpointGroups {
    /// Creates a new builder-style object to manufacture [`ListEndpointGroupsInput`](crate::input::ListEndpointGroupsInput)
    pub fn builder() -> crate::input::list_endpoint_groups_input::Builder {
        crate::input::list_endpoint_groups_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListEndpointGroups {
    type Output = std::result::Result<
        crate::output::ListEndpointGroupsOutput,
        crate::error::ListEndpointGroupsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_endpoint_groups_error(response)
        } else {
            crate::operation_deser::parse_list_endpoint_groups_response(response)
        }
    }
}

/// <p>List the listeners for an accelerator. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListListeners {
    _private: (),
}
impl ListListeners {
    /// Creates a new builder-style object to manufacture [`ListListenersInput`](crate::input::ListListenersInput)
    pub fn builder() -> crate::input::list_listeners_input::Builder {
        crate::input::list_listeners_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListListeners {
    type Output =
        std::result::Result<crate::output::ListListenersOutput, crate::error::ListListenersError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_listeners_error(response)
        } else {
            crate::operation_deser::parse_list_listeners_response(response)
        }
    }
}

/// <p>List all tags for an accelerator. </p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/tagging-in-global-accelerator.html">Tagging
/// in AWS Global Accelerator</a> in the <i>AWS Global Accelerator Developer Guide</i>. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p>Provisions an IP address range to use with your AWS resources through bring your own IP
/// addresses (BYOIP) and creates a corresponding address pool. After the address range is provisioned,
/// it is ready to be advertised using <a href="https://docs.aws.amazon.com/global-accelerator/latest/api/AdvertiseByoipCidr.html">
/// AdvertiseByoipCidr</a>.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/using-byoip.html">Bring Your Own
/// IP Addresses (BYOIP)</a> in the <i>AWS Global Accelerator Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ProvisionByoipCidr {
    _private: (),
}
impl ProvisionByoipCidr {
    /// Creates a new builder-style object to manufacture [`ProvisionByoipCidrInput`](crate::input::ProvisionByoipCidrInput)
    pub fn builder() -> crate::input::provision_byoip_cidr_input::Builder {
        crate::input::provision_byoip_cidr_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ProvisionByoipCidr {
    type Output = std::result::Result<
        crate::output::ProvisionByoipCidrOutput,
        crate::error::ProvisionByoipCidrError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_provision_byoip_cidr_error(response)
        } else {
            crate::operation_deser::parse_provision_byoip_cidr_response(response)
        }
    }
}

/// <p>Remove endpoints from a custom routing accelerator.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RemoveCustomRoutingEndpoints {
    _private: (),
}
impl RemoveCustomRoutingEndpoints {
    /// Creates a new builder-style object to manufacture [`RemoveCustomRoutingEndpointsInput`](crate::input::RemoveCustomRoutingEndpointsInput)
    pub fn builder() -> crate::input::remove_custom_routing_endpoints_input::Builder {
        crate::input::remove_custom_routing_endpoints_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RemoveCustomRoutingEndpoints {
    type Output = std::result::Result<
        crate::output::RemoveCustomRoutingEndpointsOutput,
        crate::error::RemoveCustomRoutingEndpointsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_remove_custom_routing_endpoints_error(response)
        } else {
            crate::operation_deser::parse_remove_custom_routing_endpoints_response(response)
        }
    }
}

/// <p>Add tags to an accelerator resource. </p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/tagging-in-global-accelerator.html">Tagging
/// in AWS Global Accelerator</a> in the <i>AWS Global Accelerator Developer Guide</i>. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p>Remove tags from a Global Accelerator resource. When you specify a tag key, the action removes both that key and its associated value.
/// The operation succeeds even if you attempt to remove tags from an accelerator that was already removed.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/tagging-in-global-accelerator.html">Tagging
/// in AWS Global Accelerator</a> in the <i>AWS Global Accelerator Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}

/// <p>Update an accelerator. </p>
/// <important>
/// <p>Global Accelerator is a global service that supports endpoints in multiple AWS Regions but you must specify the
/// US West (Oregon) Region to create or update accelerators.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateAccelerator {
    _private: (),
}
impl UpdateAccelerator {
    /// Creates a new builder-style object to manufacture [`UpdateAcceleratorInput`](crate::input::UpdateAcceleratorInput)
    pub fn builder() -> crate::input::update_accelerator_input::Builder {
        crate::input::update_accelerator_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateAccelerator {
    type Output = std::result::Result<
        crate::output::UpdateAcceleratorOutput,
        crate::error::UpdateAcceleratorError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_accelerator_error(response)
        } else {
            crate::operation_deser::parse_update_accelerator_response(response)
        }
    }
}

/// <p>Update the attributes for an accelerator. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateAcceleratorAttributes {
    _private: (),
}
impl UpdateAcceleratorAttributes {
    /// Creates a new builder-style object to manufacture [`UpdateAcceleratorAttributesInput`](crate::input::UpdateAcceleratorAttributesInput)
    pub fn builder() -> crate::input::update_accelerator_attributes_input::Builder {
        crate::input::update_accelerator_attributes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateAcceleratorAttributes {
    type Output = std::result::Result<
        crate::output::UpdateAcceleratorAttributesOutput,
        crate::error::UpdateAcceleratorAttributesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_accelerator_attributes_error(response)
        } else {
            crate::operation_deser::parse_update_accelerator_attributes_response(response)
        }
    }
}

/// <p>Update a custom routing accelerator. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateCustomRoutingAccelerator {
    _private: (),
}
impl UpdateCustomRoutingAccelerator {
    /// Creates a new builder-style object to manufacture [`UpdateCustomRoutingAcceleratorInput`](crate::input::UpdateCustomRoutingAcceleratorInput)
    pub fn builder() -> crate::input::update_custom_routing_accelerator_input::Builder {
        crate::input::update_custom_routing_accelerator_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateCustomRoutingAccelerator {
    type Output = std::result::Result<
        crate::output::UpdateCustomRoutingAcceleratorOutput,
        crate::error::UpdateCustomRoutingAcceleratorError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_custom_routing_accelerator_error(response)
        } else {
            crate::operation_deser::parse_update_custom_routing_accelerator_response(response)
        }
    }
}

/// <p>Update the attributes for a custom routing accelerator. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateCustomRoutingAcceleratorAttributes {
    _private: (),
}
impl UpdateCustomRoutingAcceleratorAttributes {
    /// Creates a new builder-style object to manufacture [`UpdateCustomRoutingAcceleratorAttributesInput`](crate::input::UpdateCustomRoutingAcceleratorAttributesInput)
    pub fn builder() -> crate::input::update_custom_routing_accelerator_attributes_input::Builder {
        crate::input::update_custom_routing_accelerator_attributes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateCustomRoutingAcceleratorAttributes {
    type Output = std::result::Result<
        crate::output::UpdateCustomRoutingAcceleratorAttributesOutput,
        crate::error::UpdateCustomRoutingAcceleratorAttributesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_custom_routing_accelerator_attributes_error(
                response,
            )
        } else {
            crate::operation_deser::parse_update_custom_routing_accelerator_attributes_response(
                response,
            )
        }
    }
}

/// <p>Update a listener for a custom routing accelerator. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateCustomRoutingListener {
    _private: (),
}
impl UpdateCustomRoutingListener {
    /// Creates a new builder-style object to manufacture [`UpdateCustomRoutingListenerInput`](crate::input::UpdateCustomRoutingListenerInput)
    pub fn builder() -> crate::input::update_custom_routing_listener_input::Builder {
        crate::input::update_custom_routing_listener_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateCustomRoutingListener {
    type Output = std::result::Result<
        crate::output::UpdateCustomRoutingListenerOutput,
        crate::error::UpdateCustomRoutingListenerError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_custom_routing_listener_error(response)
        } else {
            crate::operation_deser::parse_update_custom_routing_listener_response(response)
        }
    }
}

/// <p>Update an endpoint group. A resource must be valid and active when you add it as an endpoint.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateEndpointGroup {
    _private: (),
}
impl UpdateEndpointGroup {
    /// Creates a new builder-style object to manufacture [`UpdateEndpointGroupInput`](crate::input::UpdateEndpointGroupInput)
    pub fn builder() -> crate::input::update_endpoint_group_input::Builder {
        crate::input::update_endpoint_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateEndpointGroup {
    type Output = std::result::Result<
        crate::output::UpdateEndpointGroupOutput,
        crate::error::UpdateEndpointGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_endpoint_group_error(response)
        } else {
            crate::operation_deser::parse_update_endpoint_group_response(response)
        }
    }
}

/// <p>Update a listener. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateListener {
    _private: (),
}
impl UpdateListener {
    /// Creates a new builder-style object to manufacture [`UpdateListenerInput`](crate::input::UpdateListenerInput)
    pub fn builder() -> crate::input::update_listener_input::Builder {
        crate::input::update_listener_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateListener {
    type Output =
        std::result::Result<crate::output::UpdateListenerOutput, crate::error::UpdateListenerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_listener_error(response)
        } else {
            crate::operation_deser::parse_update_listener_response(response)
        }
    }
}

/// <p>Stops advertising an address range that is provisioned as an address pool.
/// You can perform this operation at most once every 10 seconds, even if you specify different address
/// ranges each time.</p>
/// <p>It can take a few minutes before traffic to the specified addresses stops routing to AWS because of
/// propagation delays.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/using-byoip.html">Bring Your Own
/// IP Addresses (BYOIP)</a> in the <i>AWS Global Accelerator Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct WithdrawByoipCidr {
    _private: (),
}
impl WithdrawByoipCidr {
    /// Creates a new builder-style object to manufacture [`WithdrawByoipCidrInput`](crate::input::WithdrawByoipCidrInput)
    pub fn builder() -> crate::input::withdraw_byoip_cidr_input::Builder {
        crate::input::withdraw_byoip_cidr_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for WithdrawByoipCidr {
    type Output = std::result::Result<
        crate::output::WithdrawByoipCidrOutput,
        crate::error::WithdrawByoipCidrError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_withdraw_byoip_cidr_error(response)
        } else {
            crate::operation_deser::parse_withdraw_byoip_cidr_response(response)
        }
    }
}
