// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::create_endpoint_group::_create_endpoint_group_output::CreateEndpointGroupOutputBuilder;

pub use crate::operation::create_endpoint_group::_create_endpoint_group_input::CreateEndpointGroupInputBuilder;

impl CreateEndpointGroupInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::create_endpoint_group::CreateEndpointGroupOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_endpoint_group::CreateEndpointGroupError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.create_endpoint_group();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `CreateEndpointGroup`.
///
/// <p>Create an endpoint group for the specified listener. An endpoint group is a collection of endpoints in one Amazon Web Services Region. A resource must be valid and active when you add it as an endpoint.</p>
/// <p>For more information about endpoint types and requirements for endpoints that you can add to Global Accelerator, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/about-endpoints.html"> Endpoints for standard accelerators</a> in the <i>Global Accelerator Developer Guide</i>.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct CreateEndpointGroupFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::create_endpoint_group::builders::CreateEndpointGroupInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::create_endpoint_group::CreateEndpointGroupOutput,
        crate::operation::create_endpoint_group::CreateEndpointGroupError,
    > for CreateEndpointGroupFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::create_endpoint_group::CreateEndpointGroupOutput,
            crate::operation::create_endpoint_group::CreateEndpointGroupError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl CreateEndpointGroupFluentBuilder {
    /// Creates a new `CreateEndpointGroup`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the CreateEndpointGroup as a reference.
    pub fn as_input(&self) -> &crate::operation::create_endpoint_group::builders::CreateEndpointGroupInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::create_endpoint_group::CreateEndpointGroupOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_endpoint_group::CreateEndpointGroupError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::create_endpoint_group::CreateEndpointGroup::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::create_endpoint_group::CreateEndpointGroup::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::create_endpoint_group::CreateEndpointGroupOutput,
        crate::operation::create_endpoint_group::CreateEndpointGroupError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl Into<crate::config::Builder>) -> Self {
        self.set_config_override(Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the listener.</p>
    pub fn listener_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.listener_arn(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the listener.</p>
    pub fn set_listener_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_listener_arn(input);
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the listener.</p>
    pub fn get_listener_arn(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_listener_arn()
    }
    /// <p>The Amazon Web Services Region where the endpoint group is located. A listener can have only one endpoint group in a specific Region.</p>
    pub fn endpoint_group_region(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.endpoint_group_region(input.into());
        self
    }
    /// <p>The Amazon Web Services Region where the endpoint group is located. A listener can have only one endpoint group in a specific Region.</p>
    pub fn set_endpoint_group_region(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_endpoint_group_region(input);
        self
    }
    /// <p>The Amazon Web Services Region where the endpoint group is located. A listener can have only one endpoint group in a specific Region.</p>
    pub fn get_endpoint_group_region(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_endpoint_group_region()
    }
    /// Appends an item to `EndpointConfigurations`.
    ///
    /// To override the contents of this collection use [`set_endpoint_configurations`](Self::set_endpoint_configurations).
    ///
    /// <p>The list of endpoint objects.</p>
    pub fn endpoint_configurations(mut self, input: crate::types::EndpointConfiguration) -> Self {
        self.inner = self.inner.endpoint_configurations(input);
        self
    }
    /// <p>The list of endpoint objects.</p>
    pub fn set_endpoint_configurations(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::EndpointConfiguration>>) -> Self {
        self.inner = self.inner.set_endpoint_configurations(input);
        self
    }
    /// <p>The list of endpoint objects.</p>
    pub fn get_endpoint_configurations(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::EndpointConfiguration>> {
        self.inner.get_endpoint_configurations()
    }
    /// <p>The percentage of traffic to send to an Amazon Web Services Region. Additional traffic is distributed to other endpoint groups for this listener. </p>
    /// <p>Use this action to increase (dial up) or decrease (dial down) traffic to a specific Region. The percentage is applied to the traffic that would otherwise have been routed to the Region based on optimal routing.</p>
    /// <p>The default value is 100.</p>
    pub fn traffic_dial_percentage(mut self, input: f32) -> Self {
        self.inner = self.inner.traffic_dial_percentage(input);
        self
    }
    /// <p>The percentage of traffic to send to an Amazon Web Services Region. Additional traffic is distributed to other endpoint groups for this listener. </p>
    /// <p>Use this action to increase (dial up) or decrease (dial down) traffic to a specific Region. The percentage is applied to the traffic that would otherwise have been routed to the Region based on optimal routing.</p>
    /// <p>The default value is 100.</p>
    pub fn set_traffic_dial_percentage(mut self, input: ::std::option::Option<f32>) -> Self {
        self.inner = self.inner.set_traffic_dial_percentage(input);
        self
    }
    /// <p>The percentage of traffic to send to an Amazon Web Services Region. Additional traffic is distributed to other endpoint groups for this listener. </p>
    /// <p>Use this action to increase (dial up) or decrease (dial down) traffic to a specific Region. The percentage is applied to the traffic that would otherwise have been routed to the Region based on optimal routing.</p>
    /// <p>The default value is 100.</p>
    pub fn get_traffic_dial_percentage(&self) -> &::std::option::Option<f32> {
        self.inner.get_traffic_dial_percentage()
    }
    /// <p>The port that Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default port is the listener port that this endpoint group is associated with. If listener port is a list of ports, Global Accelerator uses the first port in the list.</p>
    pub fn health_check_port(mut self, input: i32) -> Self {
        self.inner = self.inner.health_check_port(input);
        self
    }
    /// <p>The port that Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default port is the listener port that this endpoint group is associated with. If listener port is a list of ports, Global Accelerator uses the first port in the list.</p>
    pub fn set_health_check_port(mut self, input: ::std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_health_check_port(input);
        self
    }
    /// <p>The port that Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default port is the listener port that this endpoint group is associated with. If listener port is a list of ports, Global Accelerator uses the first port in the list.</p>
    pub fn get_health_check_port(&self) -> &::std::option::Option<i32> {
        self.inner.get_health_check_port()
    }
    /// <p>The protocol that Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default value is TCP.</p>
    pub fn health_check_protocol(mut self, input: crate::types::HealthCheckProtocol) -> Self {
        self.inner = self.inner.health_check_protocol(input);
        self
    }
    /// <p>The protocol that Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default value is TCP.</p>
    pub fn set_health_check_protocol(mut self, input: ::std::option::Option<crate::types::HealthCheckProtocol>) -> Self {
        self.inner = self.inner.set_health_check_protocol(input);
        self
    }
    /// <p>The protocol that Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default value is TCP.</p>
    pub fn get_health_check_protocol(&self) -> &::std::option::Option<crate::types::HealthCheckProtocol> {
        self.inner.get_health_check_protocol()
    }
    /// <p>If the protocol is HTTP/S, then this specifies the path that is the destination for health check targets. The default value is slash (/).</p>
    pub fn health_check_path(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.health_check_path(input.into());
        self
    }
    /// <p>If the protocol is HTTP/S, then this specifies the path that is the destination for health check targets. The default value is slash (/).</p>
    pub fn set_health_check_path(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_health_check_path(input);
        self
    }
    /// <p>If the protocol is HTTP/S, then this specifies the path that is the destination for health check targets. The default value is slash (/).</p>
    pub fn get_health_check_path(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_health_check_path()
    }
    /// <p>The time—10 seconds or 30 seconds—between each health check for an endpoint. The default value is 30.</p>
    pub fn health_check_interval_seconds(mut self, input: i32) -> Self {
        self.inner = self.inner.health_check_interval_seconds(input);
        self
    }
    /// <p>The time—10 seconds or 30 seconds—between each health check for an endpoint. The default value is 30.</p>
    pub fn set_health_check_interval_seconds(mut self, input: ::std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_health_check_interval_seconds(input);
        self
    }
    /// <p>The time—10 seconds or 30 seconds—between each health check for an endpoint. The default value is 30.</p>
    pub fn get_health_check_interval_seconds(&self) -> &::std::option::Option<i32> {
        self.inner.get_health_check_interval_seconds()
    }
    /// <p>The number of consecutive health checks required to set the state of a healthy endpoint to unhealthy, or to set an unhealthy endpoint to healthy. The default value is 3.</p>
    pub fn threshold_count(mut self, input: i32) -> Self {
        self.inner = self.inner.threshold_count(input);
        self
    }
    /// <p>The number of consecutive health checks required to set the state of a healthy endpoint to unhealthy, or to set an unhealthy endpoint to healthy. The default value is 3.</p>
    pub fn set_threshold_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_threshold_count(input);
        self
    }
    /// <p>The number of consecutive health checks required to set the state of a healthy endpoint to unhealthy, or to set an unhealthy endpoint to healthy. The default value is 3.</p>
    pub fn get_threshold_count(&self) -> &::std::option::Option<i32> {
        self.inner.get_threshold_count()
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency—that is, the uniqueness—of the request.</p>
    pub fn idempotency_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.idempotency_token(input.into());
        self
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency—that is, the uniqueness—of the request.</p>
    pub fn set_idempotency_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_idempotency_token(input);
        self
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency—that is, the uniqueness—of the request.</p>
    pub fn get_idempotency_token(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_idempotency_token()
    }
    /// Appends an item to `PortOverrides`.
    ///
    /// To override the contents of this collection use [`set_port_overrides`](Self::set_port_overrides).
    ///
    /// <p>Override specific listener ports used to route traffic to endpoints that are part of this endpoint group. For example, you can create a port override in which the listener receives user traffic on ports 80 and 443, but your accelerator routes that traffic to ports 1080 and 1443, respectively, on the endpoints.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/about-endpoint-groups-port-override.html"> Overriding listener ports</a> in the <i>Global Accelerator Developer Guide</i>.</p>
    pub fn port_overrides(mut self, input: crate::types::PortOverride) -> Self {
        self.inner = self.inner.port_overrides(input);
        self
    }
    /// <p>Override specific listener ports used to route traffic to endpoints that are part of this endpoint group. For example, you can create a port override in which the listener receives user traffic on ports 80 and 443, but your accelerator routes that traffic to ports 1080 and 1443, respectively, on the endpoints.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/about-endpoint-groups-port-override.html"> Overriding listener ports</a> in the <i>Global Accelerator Developer Guide</i>.</p>
    pub fn set_port_overrides(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::PortOverride>>) -> Self {
        self.inner = self.inner.set_port_overrides(input);
        self
    }
    /// <p>Override specific listener ports used to route traffic to endpoints that are part of this endpoint group. For example, you can create a port override in which the listener receives user traffic on ports 80 and 443, but your accelerator routes that traffic to ports 1080 and 1443, respectively, on the endpoints.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/about-endpoint-groups-port-override.html"> Overriding listener ports</a> in the <i>Global Accelerator Developer Guide</i>.</p>
    pub fn get_port_overrides(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::PortOverride>> {
        self.inner.get_port_overrides()
    }
}
