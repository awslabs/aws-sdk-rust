// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// When writing a match expression against `NoSuchEntityErrorCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let nosuchentityerrorcode = unimplemented!();
/// match nosuchentityerrorcode {
///     NoSuchEntityErrorCode::AssessmentRunDoesNotExist => { /* ... */ },
///     NoSuchEntityErrorCode::AssessmentTargetDoesNotExist => { /* ... */ },
///     NoSuchEntityErrorCode::AssessmentTemplateDoesNotExist => { /* ... */ },
///     NoSuchEntityErrorCode::FindingDoesNotExist => { /* ... */ },
///     NoSuchEntityErrorCode::IamRoleDoesNotExist => { /* ... */ },
///     NoSuchEntityErrorCode::ResourceGroupDoesNotExist => { /* ... */ },
///     NoSuchEntityErrorCode::RulesPackageDoesNotExist => { /* ... */ },
///     NoSuchEntityErrorCode::SnsTopicDoesNotExist => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `nosuchentityerrorcode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `NoSuchEntityErrorCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `NoSuchEntityErrorCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `NoSuchEntityErrorCode::NewFeature` is defined.
/// Specifically, when `nosuchentityerrorcode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `NoSuchEntityErrorCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NoSuchEntityErrorCode {
    #[allow(missing_docs)] // documentation missing in model
    AssessmentRunDoesNotExist,
    #[allow(missing_docs)] // documentation missing in model
    AssessmentTargetDoesNotExist,
    #[allow(missing_docs)] // documentation missing in model
    AssessmentTemplateDoesNotExist,
    #[allow(missing_docs)] // documentation missing in model
    FindingDoesNotExist,
    #[allow(missing_docs)] // documentation missing in model
    IamRoleDoesNotExist,
    #[allow(missing_docs)] // documentation missing in model
    ResourceGroupDoesNotExist,
    #[allow(missing_docs)] // documentation missing in model
    RulesPackageDoesNotExist,
    #[allow(missing_docs)] // documentation missing in model
    SnsTopicDoesNotExist,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for NoSuchEntityErrorCode {
    fn from(s: &str) -> Self {
        match s {
            "ASSESSMENT_RUN_DOES_NOT_EXIST" => NoSuchEntityErrorCode::AssessmentRunDoesNotExist,
            "ASSESSMENT_TARGET_DOES_NOT_EXIST" => {
                NoSuchEntityErrorCode::AssessmentTargetDoesNotExist
            }
            "ASSESSMENT_TEMPLATE_DOES_NOT_EXIST" => {
                NoSuchEntityErrorCode::AssessmentTemplateDoesNotExist
            }
            "FINDING_DOES_NOT_EXIST" => NoSuchEntityErrorCode::FindingDoesNotExist,
            "IAM_ROLE_DOES_NOT_EXIST" => NoSuchEntityErrorCode::IamRoleDoesNotExist,
            "RESOURCE_GROUP_DOES_NOT_EXIST" => NoSuchEntityErrorCode::ResourceGroupDoesNotExist,
            "RULES_PACKAGE_DOES_NOT_EXIST" => NoSuchEntityErrorCode::RulesPackageDoesNotExist,
            "SNS_TOPIC_DOES_NOT_EXIST" => NoSuchEntityErrorCode::SnsTopicDoesNotExist,
            other => {
                NoSuchEntityErrorCode::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for NoSuchEntityErrorCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NoSuchEntityErrorCode::from(s))
    }
}
impl NoSuchEntityErrorCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NoSuchEntityErrorCode::AssessmentRunDoesNotExist => "ASSESSMENT_RUN_DOES_NOT_EXIST",
            NoSuchEntityErrorCode::AssessmentTargetDoesNotExist => {
                "ASSESSMENT_TARGET_DOES_NOT_EXIST"
            }
            NoSuchEntityErrorCode::AssessmentTemplateDoesNotExist => {
                "ASSESSMENT_TEMPLATE_DOES_NOT_EXIST"
            }
            NoSuchEntityErrorCode::FindingDoesNotExist => "FINDING_DOES_NOT_EXIST",
            NoSuchEntityErrorCode::IamRoleDoesNotExist => "IAM_ROLE_DOES_NOT_EXIST",
            NoSuchEntityErrorCode::ResourceGroupDoesNotExist => "RESOURCE_GROUP_DOES_NOT_EXIST",
            NoSuchEntityErrorCode::RulesPackageDoesNotExist => "RULES_PACKAGE_DOES_NOT_EXIST",
            NoSuchEntityErrorCode::SnsTopicDoesNotExist => "SNS_TOPIC_DOES_NOT_EXIST",
            NoSuchEntityErrorCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ASSESSMENT_RUN_DOES_NOT_EXIST",
            "ASSESSMENT_TARGET_DOES_NOT_EXIST",
            "ASSESSMENT_TEMPLATE_DOES_NOT_EXIST",
            "FINDING_DOES_NOT_EXIST",
            "IAM_ROLE_DOES_NOT_EXIST",
            "RESOURCE_GROUP_DOES_NOT_EXIST",
            "RULES_PACKAGE_DOES_NOT_EXIST",
            "SNS_TOPIC_DOES_NOT_EXIST",
        ]
    }
}
impl AsRef<str> for NoSuchEntityErrorCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `InvalidInputErrorCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let invalidinputerrorcode = unimplemented!();
/// match invalidinputerrorcode {
///     InvalidInputErrorCode::AssessmentTargetNameAlreadyTaken => { /* ... */ },
///     InvalidInputErrorCode::AssessmentTemplateNameAlreadyTaken => { /* ... */ },
///     InvalidInputErrorCode::InvalidAgentId => { /* ... */ },
///     InvalidInputErrorCode::InvalidAssessmentRunArn => { /* ... */ },
///     InvalidInputErrorCode::InvalidAssessmentRunCompletionTimeRange => { /* ... */ },
///     InvalidInputErrorCode::InvalidAssessmentRunDurationRange => { /* ... */ },
///     InvalidInputErrorCode::InvalidAssessmentRunStartTimeRange => { /* ... */ },
///     InvalidInputErrorCode::InvalidAssessmentRunState => { /* ... */ },
///     InvalidInputErrorCode::InvalidAssessmentRunStateChangeTimeRange => { /* ... */ },
///     InvalidInputErrorCode::InvalidAssessmentTargetArn => { /* ... */ },
///     InvalidInputErrorCode::InvalidAssessmentTargetName => { /* ... */ },
///     InvalidInputErrorCode::InvalidAssessmentTargetNamePattern => { /* ... */ },
///     InvalidInputErrorCode::InvalidAssessmentTemplateArn => { /* ... */ },
///     InvalidInputErrorCode::InvalidAssessmentTemplateDuration => { /* ... */ },
///     InvalidInputErrorCode::InvalidAssessmentTemplateDurationRange => { /* ... */ },
///     InvalidInputErrorCode::InvalidAssessmentTemplateName => { /* ... */ },
///     InvalidInputErrorCode::InvalidAssessmentTemplateNamePattern => { /* ... */ },
///     InvalidInputErrorCode::InvalidAttribute => { /* ... */ },
///     InvalidInputErrorCode::InvalidAutoScalingGroup => { /* ... */ },
///     InvalidInputErrorCode::InvalidEvent => { /* ... */ },
///     InvalidInputErrorCode::InvalidFindingArn => { /* ... */ },
///     InvalidInputErrorCode::InvalidIamRoleArn => { /* ... */ },
///     InvalidInputErrorCode::InvalidLocale => { /* ... */ },
///     InvalidInputErrorCode::InvalidMaxResults => { /* ... */ },
///     InvalidInputErrorCode::InvalidNumberOfAgentIds => { /* ... */ },
///     InvalidInputErrorCode::InvalidNumberOfAssessmentRunArns => { /* ... */ },
///     InvalidInputErrorCode::InvalidNumberOfAssessmentRunStates => { /* ... */ },
///     InvalidInputErrorCode::InvalidNumberOfAssessmentTargetArns => { /* ... */ },
///     InvalidInputErrorCode::InvalidNumberOfAssessmentTemplateArns => { /* ... */ },
///     InvalidInputErrorCode::InvalidNumberOfAttributes => { /* ... */ },
///     InvalidInputErrorCode::InvalidNumberOfAutoScalingGroups => { /* ... */ },
///     InvalidInputErrorCode::InvalidNumberOfFindingArns => { /* ... */ },
///     InvalidInputErrorCode::InvalidNumberOfResourceGroupArns => { /* ... */ },
///     InvalidInputErrorCode::InvalidNumberOfResourceGroupTags => { /* ... */ },
///     InvalidInputErrorCode::InvalidNumberOfRulesPackageArns => { /* ... */ },
///     InvalidInputErrorCode::InvalidNumberOfRuleNames => { /* ... */ },
///     InvalidInputErrorCode::InvalidNumberOfSeverities => { /* ... */ },
///     InvalidInputErrorCode::InvalidNumberOfTags => { /* ... */ },
///     InvalidInputErrorCode::InvalidNumberOfUserAttributes => { /* ... */ },
///     InvalidInputErrorCode::InvalidPaginationToken => { /* ... */ },
///     InvalidInputErrorCode::InvalidResourceArn => { /* ... */ },
///     InvalidInputErrorCode::InvalidResourceGroupArn => { /* ... */ },
///     InvalidInputErrorCode::InvalidResourceGroupTagKey => { /* ... */ },
///     InvalidInputErrorCode::InvalidResourceGroupTagValue => { /* ... */ },
///     InvalidInputErrorCode::InvalidRulesPackageArn => { /* ... */ },
///     InvalidInputErrorCode::InvalidRuleName => { /* ... */ },
///     InvalidInputErrorCode::InvalidSeverity => { /* ... */ },
///     InvalidInputErrorCode::InvalidSnsTopicArn => { /* ... */ },
///     InvalidInputErrorCode::InvalidTag => { /* ... */ },
///     InvalidInputErrorCode::InvalidTagKey => { /* ... */ },
///     InvalidInputErrorCode::InvalidTagValue => { /* ... */ },
///     InvalidInputErrorCode::InvalidUserAttribute => { /* ... */ },
///     InvalidInputErrorCode::InvalidUserAttributeKey => { /* ... */ },
///     InvalidInputErrorCode::InvalidUserAttributeValue => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `invalidinputerrorcode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `InvalidInputErrorCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `InvalidInputErrorCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `InvalidInputErrorCode::NewFeature` is defined.
/// Specifically, when `invalidinputerrorcode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `InvalidInputErrorCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InvalidInputErrorCode {
    #[allow(missing_docs)] // documentation missing in model
    AssessmentTargetNameAlreadyTaken,
    #[allow(missing_docs)] // documentation missing in model
    AssessmentTemplateNameAlreadyTaken,
    #[allow(missing_docs)] // documentation missing in model
    InvalidAgentId,
    #[allow(missing_docs)] // documentation missing in model
    InvalidAssessmentRunArn,
    #[allow(missing_docs)] // documentation missing in model
    InvalidAssessmentRunCompletionTimeRange,
    #[allow(missing_docs)] // documentation missing in model
    InvalidAssessmentRunDurationRange,
    #[allow(missing_docs)] // documentation missing in model
    InvalidAssessmentRunStartTimeRange,
    #[allow(missing_docs)] // documentation missing in model
    InvalidAssessmentRunState,
    #[allow(missing_docs)] // documentation missing in model
    InvalidAssessmentRunStateChangeTimeRange,
    #[allow(missing_docs)] // documentation missing in model
    InvalidAssessmentTargetArn,
    #[allow(missing_docs)] // documentation missing in model
    InvalidAssessmentTargetName,
    #[allow(missing_docs)] // documentation missing in model
    InvalidAssessmentTargetNamePattern,
    #[allow(missing_docs)] // documentation missing in model
    InvalidAssessmentTemplateArn,
    #[allow(missing_docs)] // documentation missing in model
    InvalidAssessmentTemplateDuration,
    #[allow(missing_docs)] // documentation missing in model
    InvalidAssessmentTemplateDurationRange,
    #[allow(missing_docs)] // documentation missing in model
    InvalidAssessmentTemplateName,
    #[allow(missing_docs)] // documentation missing in model
    InvalidAssessmentTemplateNamePattern,
    #[allow(missing_docs)] // documentation missing in model
    InvalidAttribute,
    #[allow(missing_docs)] // documentation missing in model
    InvalidAutoScalingGroup,
    #[allow(missing_docs)] // documentation missing in model
    InvalidEvent,
    #[allow(missing_docs)] // documentation missing in model
    InvalidFindingArn,
    #[allow(missing_docs)] // documentation missing in model
    InvalidIamRoleArn,
    #[allow(missing_docs)] // documentation missing in model
    InvalidLocale,
    #[allow(missing_docs)] // documentation missing in model
    InvalidMaxResults,
    #[allow(missing_docs)] // documentation missing in model
    InvalidNumberOfAgentIds,
    #[allow(missing_docs)] // documentation missing in model
    InvalidNumberOfAssessmentRunArns,
    #[allow(missing_docs)] // documentation missing in model
    InvalidNumberOfAssessmentRunStates,
    #[allow(missing_docs)] // documentation missing in model
    InvalidNumberOfAssessmentTargetArns,
    #[allow(missing_docs)] // documentation missing in model
    InvalidNumberOfAssessmentTemplateArns,
    #[allow(missing_docs)] // documentation missing in model
    InvalidNumberOfAttributes,
    #[allow(missing_docs)] // documentation missing in model
    InvalidNumberOfAutoScalingGroups,
    #[allow(missing_docs)] // documentation missing in model
    InvalidNumberOfFindingArns,
    #[allow(missing_docs)] // documentation missing in model
    InvalidNumberOfResourceGroupArns,
    #[allow(missing_docs)] // documentation missing in model
    InvalidNumberOfResourceGroupTags,
    #[allow(missing_docs)] // documentation missing in model
    InvalidNumberOfRulesPackageArns,
    #[allow(missing_docs)] // documentation missing in model
    InvalidNumberOfRuleNames,
    #[allow(missing_docs)] // documentation missing in model
    InvalidNumberOfSeverities,
    #[allow(missing_docs)] // documentation missing in model
    InvalidNumberOfTags,
    #[allow(missing_docs)] // documentation missing in model
    InvalidNumberOfUserAttributes,
    #[allow(missing_docs)] // documentation missing in model
    InvalidPaginationToken,
    #[allow(missing_docs)] // documentation missing in model
    InvalidResourceArn,
    #[allow(missing_docs)] // documentation missing in model
    InvalidResourceGroupArn,
    #[allow(missing_docs)] // documentation missing in model
    InvalidResourceGroupTagKey,
    #[allow(missing_docs)] // documentation missing in model
    InvalidResourceGroupTagValue,
    #[allow(missing_docs)] // documentation missing in model
    InvalidRulesPackageArn,
    #[allow(missing_docs)] // documentation missing in model
    InvalidRuleName,
    #[allow(missing_docs)] // documentation missing in model
    InvalidSeverity,
    #[allow(missing_docs)] // documentation missing in model
    InvalidSnsTopicArn,
    #[allow(missing_docs)] // documentation missing in model
    InvalidTag,
    #[allow(missing_docs)] // documentation missing in model
    InvalidTagKey,
    #[allow(missing_docs)] // documentation missing in model
    InvalidTagValue,
    #[allow(missing_docs)] // documentation missing in model
    InvalidUserAttribute,
    #[allow(missing_docs)] // documentation missing in model
    InvalidUserAttributeKey,
    #[allow(missing_docs)] // documentation missing in model
    InvalidUserAttributeValue,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for InvalidInputErrorCode {
    fn from(s: &str) -> Self {
        match s {
            "ASSESSMENT_TARGET_NAME_ALREADY_TAKEN" => {
                InvalidInputErrorCode::AssessmentTargetNameAlreadyTaken
            }
            "ASSESSMENT_TEMPLATE_NAME_ALREADY_TAKEN" => {
                InvalidInputErrorCode::AssessmentTemplateNameAlreadyTaken
            }
            "INVALID_AGENT_ID" => InvalidInputErrorCode::InvalidAgentId,
            "INVALID_ASSESSMENT_RUN_ARN" => InvalidInputErrorCode::InvalidAssessmentRunArn,
            "INVALID_ASSESSMENT_RUN_COMPLETION_TIME_RANGE" => {
                InvalidInputErrorCode::InvalidAssessmentRunCompletionTimeRange
            }
            "INVALID_ASSESSMENT_RUN_DURATION_RANGE" => {
                InvalidInputErrorCode::InvalidAssessmentRunDurationRange
            }
            "INVALID_ASSESSMENT_RUN_START_TIME_RANGE" => {
                InvalidInputErrorCode::InvalidAssessmentRunStartTimeRange
            }
            "INVALID_ASSESSMENT_RUN_STATE" => InvalidInputErrorCode::InvalidAssessmentRunState,
            "INVALID_ASSESSMENT_RUN_STATE_CHANGE_TIME_RANGE" => {
                InvalidInputErrorCode::InvalidAssessmentRunStateChangeTimeRange
            }
            "INVALID_ASSESSMENT_TARGET_ARN" => InvalidInputErrorCode::InvalidAssessmentTargetArn,
            "INVALID_ASSESSMENT_TARGET_NAME" => InvalidInputErrorCode::InvalidAssessmentTargetName,
            "INVALID_ASSESSMENT_TARGET_NAME_PATTERN" => {
                InvalidInputErrorCode::InvalidAssessmentTargetNamePattern
            }
            "INVALID_ASSESSMENT_TEMPLATE_ARN" => {
                InvalidInputErrorCode::InvalidAssessmentTemplateArn
            }
            "INVALID_ASSESSMENT_TEMPLATE_DURATION" => {
                InvalidInputErrorCode::InvalidAssessmentTemplateDuration
            }
            "INVALID_ASSESSMENT_TEMPLATE_DURATION_RANGE" => {
                InvalidInputErrorCode::InvalidAssessmentTemplateDurationRange
            }
            "INVALID_ASSESSMENT_TEMPLATE_NAME" => {
                InvalidInputErrorCode::InvalidAssessmentTemplateName
            }
            "INVALID_ASSESSMENT_TEMPLATE_NAME_PATTERN" => {
                InvalidInputErrorCode::InvalidAssessmentTemplateNamePattern
            }
            "INVALID_ATTRIBUTE" => InvalidInputErrorCode::InvalidAttribute,
            "INVALID_AUTO_SCALING_GROUP" => InvalidInputErrorCode::InvalidAutoScalingGroup,
            "INVALID_EVENT" => InvalidInputErrorCode::InvalidEvent,
            "INVALID_FINDING_ARN" => InvalidInputErrorCode::InvalidFindingArn,
            "INVALID_IAM_ROLE_ARN" => InvalidInputErrorCode::InvalidIamRoleArn,
            "INVALID_LOCALE" => InvalidInputErrorCode::InvalidLocale,
            "INVALID_MAX_RESULTS" => InvalidInputErrorCode::InvalidMaxResults,
            "INVALID_NUMBER_OF_AGENT_IDS" => InvalidInputErrorCode::InvalidNumberOfAgentIds,
            "INVALID_NUMBER_OF_ASSESSMENT_RUN_ARNS" => {
                InvalidInputErrorCode::InvalidNumberOfAssessmentRunArns
            }
            "INVALID_NUMBER_OF_ASSESSMENT_RUN_STATES" => {
                InvalidInputErrorCode::InvalidNumberOfAssessmentRunStates
            }
            "INVALID_NUMBER_OF_ASSESSMENT_TARGET_ARNS" => {
                InvalidInputErrorCode::InvalidNumberOfAssessmentTargetArns
            }
            "INVALID_NUMBER_OF_ASSESSMENT_TEMPLATE_ARNS" => {
                InvalidInputErrorCode::InvalidNumberOfAssessmentTemplateArns
            }
            "INVALID_NUMBER_OF_ATTRIBUTES" => InvalidInputErrorCode::InvalidNumberOfAttributes,
            "INVALID_NUMBER_OF_AUTO_SCALING_GROUPS" => {
                InvalidInputErrorCode::InvalidNumberOfAutoScalingGroups
            }
            "INVALID_NUMBER_OF_FINDING_ARNS" => InvalidInputErrorCode::InvalidNumberOfFindingArns,
            "INVALID_NUMBER_OF_RESOURCE_GROUP_ARNS" => {
                InvalidInputErrorCode::InvalidNumberOfResourceGroupArns
            }
            "INVALID_NUMBER_OF_RESOURCE_GROUP_TAGS" => {
                InvalidInputErrorCode::InvalidNumberOfResourceGroupTags
            }
            "INVALID_NUMBER_OF_RULES_PACKAGE_ARNS" => {
                InvalidInputErrorCode::InvalidNumberOfRulesPackageArns
            }
            "INVALID_NUMBER_OF_RULE_NAMES" => InvalidInputErrorCode::InvalidNumberOfRuleNames,
            "INVALID_NUMBER_OF_SEVERITIES" => InvalidInputErrorCode::InvalidNumberOfSeverities,
            "INVALID_NUMBER_OF_TAGS" => InvalidInputErrorCode::InvalidNumberOfTags,
            "INVALID_NUMBER_OF_USER_ATTRIBUTES" => {
                InvalidInputErrorCode::InvalidNumberOfUserAttributes
            }
            "INVALID_PAGINATION_TOKEN" => InvalidInputErrorCode::InvalidPaginationToken,
            "INVALID_RESOURCE_ARN" => InvalidInputErrorCode::InvalidResourceArn,
            "INVALID_RESOURCE_GROUP_ARN" => InvalidInputErrorCode::InvalidResourceGroupArn,
            "INVALID_RESOURCE_GROUP_TAG_KEY" => InvalidInputErrorCode::InvalidResourceGroupTagKey,
            "INVALID_RESOURCE_GROUP_TAG_VALUE" => {
                InvalidInputErrorCode::InvalidResourceGroupTagValue
            }
            "INVALID_RULES_PACKAGE_ARN" => InvalidInputErrorCode::InvalidRulesPackageArn,
            "INVALID_RULE_NAME" => InvalidInputErrorCode::InvalidRuleName,
            "INVALID_SEVERITY" => InvalidInputErrorCode::InvalidSeverity,
            "INVALID_SNS_TOPIC_ARN" => InvalidInputErrorCode::InvalidSnsTopicArn,
            "INVALID_TAG" => InvalidInputErrorCode::InvalidTag,
            "INVALID_TAG_KEY" => InvalidInputErrorCode::InvalidTagKey,
            "INVALID_TAG_VALUE" => InvalidInputErrorCode::InvalidTagValue,
            "INVALID_USER_ATTRIBUTE" => InvalidInputErrorCode::InvalidUserAttribute,
            "INVALID_USER_ATTRIBUTE_KEY" => InvalidInputErrorCode::InvalidUserAttributeKey,
            "INVALID_USER_ATTRIBUTE_VALUE" => InvalidInputErrorCode::InvalidUserAttributeValue,
            other => {
                InvalidInputErrorCode::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for InvalidInputErrorCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InvalidInputErrorCode::from(s))
    }
}
impl InvalidInputErrorCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            InvalidInputErrorCode::AssessmentTargetNameAlreadyTaken => {
                "ASSESSMENT_TARGET_NAME_ALREADY_TAKEN"
            }
            InvalidInputErrorCode::AssessmentTemplateNameAlreadyTaken => {
                "ASSESSMENT_TEMPLATE_NAME_ALREADY_TAKEN"
            }
            InvalidInputErrorCode::InvalidAgentId => "INVALID_AGENT_ID",
            InvalidInputErrorCode::InvalidAssessmentRunArn => "INVALID_ASSESSMENT_RUN_ARN",
            InvalidInputErrorCode::InvalidAssessmentRunCompletionTimeRange => {
                "INVALID_ASSESSMENT_RUN_COMPLETION_TIME_RANGE"
            }
            InvalidInputErrorCode::InvalidAssessmentRunDurationRange => {
                "INVALID_ASSESSMENT_RUN_DURATION_RANGE"
            }
            InvalidInputErrorCode::InvalidAssessmentRunStartTimeRange => {
                "INVALID_ASSESSMENT_RUN_START_TIME_RANGE"
            }
            InvalidInputErrorCode::InvalidAssessmentRunState => "INVALID_ASSESSMENT_RUN_STATE",
            InvalidInputErrorCode::InvalidAssessmentRunStateChangeTimeRange => {
                "INVALID_ASSESSMENT_RUN_STATE_CHANGE_TIME_RANGE"
            }
            InvalidInputErrorCode::InvalidAssessmentTargetArn => "INVALID_ASSESSMENT_TARGET_ARN",
            InvalidInputErrorCode::InvalidAssessmentTargetName => "INVALID_ASSESSMENT_TARGET_NAME",
            InvalidInputErrorCode::InvalidAssessmentTargetNamePattern => {
                "INVALID_ASSESSMENT_TARGET_NAME_PATTERN"
            }
            InvalidInputErrorCode::InvalidAssessmentTemplateArn => {
                "INVALID_ASSESSMENT_TEMPLATE_ARN"
            }
            InvalidInputErrorCode::InvalidAssessmentTemplateDuration => {
                "INVALID_ASSESSMENT_TEMPLATE_DURATION"
            }
            InvalidInputErrorCode::InvalidAssessmentTemplateDurationRange => {
                "INVALID_ASSESSMENT_TEMPLATE_DURATION_RANGE"
            }
            InvalidInputErrorCode::InvalidAssessmentTemplateName => {
                "INVALID_ASSESSMENT_TEMPLATE_NAME"
            }
            InvalidInputErrorCode::InvalidAssessmentTemplateNamePattern => {
                "INVALID_ASSESSMENT_TEMPLATE_NAME_PATTERN"
            }
            InvalidInputErrorCode::InvalidAttribute => "INVALID_ATTRIBUTE",
            InvalidInputErrorCode::InvalidAutoScalingGroup => "INVALID_AUTO_SCALING_GROUP",
            InvalidInputErrorCode::InvalidEvent => "INVALID_EVENT",
            InvalidInputErrorCode::InvalidFindingArn => "INVALID_FINDING_ARN",
            InvalidInputErrorCode::InvalidIamRoleArn => "INVALID_IAM_ROLE_ARN",
            InvalidInputErrorCode::InvalidLocale => "INVALID_LOCALE",
            InvalidInputErrorCode::InvalidMaxResults => "INVALID_MAX_RESULTS",
            InvalidInputErrorCode::InvalidNumberOfAgentIds => "INVALID_NUMBER_OF_AGENT_IDS",
            InvalidInputErrorCode::InvalidNumberOfAssessmentRunArns => {
                "INVALID_NUMBER_OF_ASSESSMENT_RUN_ARNS"
            }
            InvalidInputErrorCode::InvalidNumberOfAssessmentRunStates => {
                "INVALID_NUMBER_OF_ASSESSMENT_RUN_STATES"
            }
            InvalidInputErrorCode::InvalidNumberOfAssessmentTargetArns => {
                "INVALID_NUMBER_OF_ASSESSMENT_TARGET_ARNS"
            }
            InvalidInputErrorCode::InvalidNumberOfAssessmentTemplateArns => {
                "INVALID_NUMBER_OF_ASSESSMENT_TEMPLATE_ARNS"
            }
            InvalidInputErrorCode::InvalidNumberOfAttributes => "INVALID_NUMBER_OF_ATTRIBUTES",
            InvalidInputErrorCode::InvalidNumberOfAutoScalingGroups => {
                "INVALID_NUMBER_OF_AUTO_SCALING_GROUPS"
            }
            InvalidInputErrorCode::InvalidNumberOfFindingArns => "INVALID_NUMBER_OF_FINDING_ARNS",
            InvalidInputErrorCode::InvalidNumberOfResourceGroupArns => {
                "INVALID_NUMBER_OF_RESOURCE_GROUP_ARNS"
            }
            InvalidInputErrorCode::InvalidNumberOfResourceGroupTags => {
                "INVALID_NUMBER_OF_RESOURCE_GROUP_TAGS"
            }
            InvalidInputErrorCode::InvalidNumberOfRulesPackageArns => {
                "INVALID_NUMBER_OF_RULES_PACKAGE_ARNS"
            }
            InvalidInputErrorCode::InvalidNumberOfRuleNames => "INVALID_NUMBER_OF_RULE_NAMES",
            InvalidInputErrorCode::InvalidNumberOfSeverities => "INVALID_NUMBER_OF_SEVERITIES",
            InvalidInputErrorCode::InvalidNumberOfTags => "INVALID_NUMBER_OF_TAGS",
            InvalidInputErrorCode::InvalidNumberOfUserAttributes => {
                "INVALID_NUMBER_OF_USER_ATTRIBUTES"
            }
            InvalidInputErrorCode::InvalidPaginationToken => "INVALID_PAGINATION_TOKEN",
            InvalidInputErrorCode::InvalidResourceArn => "INVALID_RESOURCE_ARN",
            InvalidInputErrorCode::InvalidResourceGroupArn => "INVALID_RESOURCE_GROUP_ARN",
            InvalidInputErrorCode::InvalidResourceGroupTagKey => "INVALID_RESOURCE_GROUP_TAG_KEY",
            InvalidInputErrorCode::InvalidResourceGroupTagValue => {
                "INVALID_RESOURCE_GROUP_TAG_VALUE"
            }
            InvalidInputErrorCode::InvalidRulesPackageArn => "INVALID_RULES_PACKAGE_ARN",
            InvalidInputErrorCode::InvalidRuleName => "INVALID_RULE_NAME",
            InvalidInputErrorCode::InvalidSeverity => "INVALID_SEVERITY",
            InvalidInputErrorCode::InvalidSnsTopicArn => "INVALID_SNS_TOPIC_ARN",
            InvalidInputErrorCode::InvalidTag => "INVALID_TAG",
            InvalidInputErrorCode::InvalidTagKey => "INVALID_TAG_KEY",
            InvalidInputErrorCode::InvalidTagValue => "INVALID_TAG_VALUE",
            InvalidInputErrorCode::InvalidUserAttribute => "INVALID_USER_ATTRIBUTE",
            InvalidInputErrorCode::InvalidUserAttributeKey => "INVALID_USER_ATTRIBUTE_KEY",
            InvalidInputErrorCode::InvalidUserAttributeValue => "INVALID_USER_ATTRIBUTE_VALUE",
            InvalidInputErrorCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ASSESSMENT_TARGET_NAME_ALREADY_TAKEN",
            "ASSESSMENT_TEMPLATE_NAME_ALREADY_TAKEN",
            "INVALID_AGENT_ID",
            "INVALID_ASSESSMENT_RUN_ARN",
            "INVALID_ASSESSMENT_RUN_COMPLETION_TIME_RANGE",
            "INVALID_ASSESSMENT_RUN_DURATION_RANGE",
            "INVALID_ASSESSMENT_RUN_START_TIME_RANGE",
            "INVALID_ASSESSMENT_RUN_STATE",
            "INVALID_ASSESSMENT_RUN_STATE_CHANGE_TIME_RANGE",
            "INVALID_ASSESSMENT_TARGET_ARN",
            "INVALID_ASSESSMENT_TARGET_NAME",
            "INVALID_ASSESSMENT_TARGET_NAME_PATTERN",
            "INVALID_ASSESSMENT_TEMPLATE_ARN",
            "INVALID_ASSESSMENT_TEMPLATE_DURATION",
            "INVALID_ASSESSMENT_TEMPLATE_DURATION_RANGE",
            "INVALID_ASSESSMENT_TEMPLATE_NAME",
            "INVALID_ASSESSMENT_TEMPLATE_NAME_PATTERN",
            "INVALID_ATTRIBUTE",
            "INVALID_AUTO_SCALING_GROUP",
            "INVALID_EVENT",
            "INVALID_FINDING_ARN",
            "INVALID_IAM_ROLE_ARN",
            "INVALID_LOCALE",
            "INVALID_MAX_RESULTS",
            "INVALID_NUMBER_OF_AGENT_IDS",
            "INVALID_NUMBER_OF_ASSESSMENT_RUN_ARNS",
            "INVALID_NUMBER_OF_ASSESSMENT_RUN_STATES",
            "INVALID_NUMBER_OF_ASSESSMENT_TARGET_ARNS",
            "INVALID_NUMBER_OF_ASSESSMENT_TEMPLATE_ARNS",
            "INVALID_NUMBER_OF_ATTRIBUTES",
            "INVALID_NUMBER_OF_AUTO_SCALING_GROUPS",
            "INVALID_NUMBER_OF_FINDING_ARNS",
            "INVALID_NUMBER_OF_RESOURCE_GROUP_ARNS",
            "INVALID_NUMBER_OF_RESOURCE_GROUP_TAGS",
            "INVALID_NUMBER_OF_RULES_PACKAGE_ARNS",
            "INVALID_NUMBER_OF_RULE_NAMES",
            "INVALID_NUMBER_OF_SEVERITIES",
            "INVALID_NUMBER_OF_TAGS",
            "INVALID_NUMBER_OF_USER_ATTRIBUTES",
            "INVALID_PAGINATION_TOKEN",
            "INVALID_RESOURCE_ARN",
            "INVALID_RESOURCE_GROUP_ARN",
            "INVALID_RESOURCE_GROUP_TAG_KEY",
            "INVALID_RESOURCE_GROUP_TAG_VALUE",
            "INVALID_RULES_PACKAGE_ARN",
            "INVALID_RULE_NAME",
            "INVALID_SEVERITY",
            "INVALID_SNS_TOPIC_ARN",
            "INVALID_TAG",
            "INVALID_TAG_KEY",
            "INVALID_TAG_VALUE",
            "INVALID_USER_ATTRIBUTE",
            "INVALID_USER_ATTRIBUTE_KEY",
            "INVALID_USER_ATTRIBUTE_VALUE",
        ]
    }
}
impl AsRef<str> for InvalidInputErrorCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `AccessDeniedErrorCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let accessdeniederrorcode = unimplemented!();
/// match accessdeniederrorcode {
///     AccessDeniedErrorCode::AccessDeniedToAssessmentRun => { /* ... */ },
///     AccessDeniedErrorCode::AccessDeniedToAssessmentTarget => { /* ... */ },
///     AccessDeniedErrorCode::AccessDeniedToAssessmentTemplate => { /* ... */ },
///     AccessDeniedErrorCode::AccessDeniedToFinding => { /* ... */ },
///     AccessDeniedErrorCode::AccessDeniedToIamRole => { /* ... */ },
///     AccessDeniedErrorCode::AccessDeniedToResourceGroup => { /* ... */ },
///     AccessDeniedErrorCode::AccessDeniedToRulesPackage => { /* ... */ },
///     AccessDeniedErrorCode::AccessDeniedToSnsTopic => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `accessdeniederrorcode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AccessDeniedErrorCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AccessDeniedErrorCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AccessDeniedErrorCode::NewFeature` is defined.
/// Specifically, when `accessdeniederrorcode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AccessDeniedErrorCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AccessDeniedErrorCode {
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedToAssessmentRun,
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedToAssessmentTarget,
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedToAssessmentTemplate,
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedToFinding,
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedToIamRole,
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedToResourceGroup,
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedToRulesPackage,
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedToSnsTopic,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AccessDeniedErrorCode {
    fn from(s: &str) -> Self {
        match s {
            "ACCESS_DENIED_TO_ASSESSMENT_RUN" => AccessDeniedErrorCode::AccessDeniedToAssessmentRun,
            "ACCESS_DENIED_TO_ASSESSMENT_TARGET" => {
                AccessDeniedErrorCode::AccessDeniedToAssessmentTarget
            }
            "ACCESS_DENIED_TO_ASSESSMENT_TEMPLATE" => {
                AccessDeniedErrorCode::AccessDeniedToAssessmentTemplate
            }
            "ACCESS_DENIED_TO_FINDING" => AccessDeniedErrorCode::AccessDeniedToFinding,
            "ACCESS_DENIED_TO_IAM_ROLE" => AccessDeniedErrorCode::AccessDeniedToIamRole,
            "ACCESS_DENIED_TO_RESOURCE_GROUP" => AccessDeniedErrorCode::AccessDeniedToResourceGroup,
            "ACCESS_DENIED_TO_RULES_PACKAGE" => AccessDeniedErrorCode::AccessDeniedToRulesPackage,
            "ACCESS_DENIED_TO_SNS_TOPIC" => AccessDeniedErrorCode::AccessDeniedToSnsTopic,
            other => {
                AccessDeniedErrorCode::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for AccessDeniedErrorCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AccessDeniedErrorCode::from(s))
    }
}
impl AccessDeniedErrorCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AccessDeniedErrorCode::AccessDeniedToAssessmentRun => "ACCESS_DENIED_TO_ASSESSMENT_RUN",
            AccessDeniedErrorCode::AccessDeniedToAssessmentTarget => {
                "ACCESS_DENIED_TO_ASSESSMENT_TARGET"
            }
            AccessDeniedErrorCode::AccessDeniedToAssessmentTemplate => {
                "ACCESS_DENIED_TO_ASSESSMENT_TEMPLATE"
            }
            AccessDeniedErrorCode::AccessDeniedToFinding => "ACCESS_DENIED_TO_FINDING",
            AccessDeniedErrorCode::AccessDeniedToIamRole => "ACCESS_DENIED_TO_IAM_ROLE",
            AccessDeniedErrorCode::AccessDeniedToResourceGroup => "ACCESS_DENIED_TO_RESOURCE_GROUP",
            AccessDeniedErrorCode::AccessDeniedToRulesPackage => "ACCESS_DENIED_TO_RULES_PACKAGE",
            AccessDeniedErrorCode::AccessDeniedToSnsTopic => "ACCESS_DENIED_TO_SNS_TOPIC",
            AccessDeniedErrorCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACCESS_DENIED_TO_ASSESSMENT_RUN",
            "ACCESS_DENIED_TO_ASSESSMENT_TARGET",
            "ACCESS_DENIED_TO_ASSESSMENT_TEMPLATE",
            "ACCESS_DENIED_TO_FINDING",
            "ACCESS_DENIED_TO_IAM_ROLE",
            "ACCESS_DENIED_TO_RESOURCE_GROUP",
            "ACCESS_DENIED_TO_RULES_PACKAGE",
            "ACCESS_DENIED_TO_SNS_TOPIC",
        ]
    }
}
impl AsRef<str> for AccessDeniedErrorCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `InspectorEvent`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let inspectorevent = unimplemented!();
/// match inspectorevent {
///     InspectorEvent::AssessmentRunCompleted => { /* ... */ },
///     InspectorEvent::AssessmentRunStarted => { /* ... */ },
///     InspectorEvent::AssessmentRunStateChanged => { /* ... */ },
///     InspectorEvent::FindingReported => { /* ... */ },
///     InspectorEvent::Other => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `inspectorevent` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `InspectorEvent::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `InspectorEvent::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `InspectorEvent::NewFeature` is defined.
/// Specifically, when `inspectorevent` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `InspectorEvent::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InspectorEvent {
    #[allow(missing_docs)] // documentation missing in model
    AssessmentRunCompleted,
    #[allow(missing_docs)] // documentation missing in model
    AssessmentRunStarted,
    #[allow(missing_docs)] // documentation missing in model
    AssessmentRunStateChanged,
    #[allow(missing_docs)] // documentation missing in model
    FindingReported,
    #[allow(missing_docs)] // documentation missing in model
    Other,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for InspectorEvent {
    fn from(s: &str) -> Self {
        match s {
            "ASSESSMENT_RUN_COMPLETED" => InspectorEvent::AssessmentRunCompleted,
            "ASSESSMENT_RUN_STARTED" => InspectorEvent::AssessmentRunStarted,
            "ASSESSMENT_RUN_STATE_CHANGED" => InspectorEvent::AssessmentRunStateChanged,
            "FINDING_REPORTED" => InspectorEvent::FindingReported,
            "OTHER" => InspectorEvent::Other,
            other => InspectorEvent::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for InspectorEvent {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InspectorEvent::from(s))
    }
}
impl InspectorEvent {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            InspectorEvent::AssessmentRunCompleted => "ASSESSMENT_RUN_COMPLETED",
            InspectorEvent::AssessmentRunStarted => "ASSESSMENT_RUN_STARTED",
            InspectorEvent::AssessmentRunStateChanged => "ASSESSMENT_RUN_STATE_CHANGED",
            InspectorEvent::FindingReported => "FINDING_REPORTED",
            InspectorEvent::Other => "OTHER",
            InspectorEvent::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ASSESSMENT_RUN_COMPLETED",
            "ASSESSMENT_RUN_STARTED",
            "ASSESSMENT_RUN_STATE_CHANGED",
            "FINDING_REPORTED",
            "OTHER",
        ]
    }
}
impl AsRef<str> for InspectorEvent {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `LimitExceededErrorCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let limitexceedederrorcode = unimplemented!();
/// match limitexceedederrorcode {
///     LimitExceededErrorCode::AssessmentRunLimitExceeded => { /* ... */ },
///     LimitExceededErrorCode::AssessmentTargetLimitExceeded => { /* ... */ },
///     LimitExceededErrorCode::AssessmentTemplateLimitExceeded => { /* ... */ },
///     LimitExceededErrorCode::EventSubscriptionLimitExceeded => { /* ... */ },
///     LimitExceededErrorCode::ResourceGroupLimitExceeded => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `limitexceedederrorcode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LimitExceededErrorCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LimitExceededErrorCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LimitExceededErrorCode::NewFeature` is defined.
/// Specifically, when `limitexceedederrorcode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LimitExceededErrorCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LimitExceededErrorCode {
    #[allow(missing_docs)] // documentation missing in model
    AssessmentRunLimitExceeded,
    #[allow(missing_docs)] // documentation missing in model
    AssessmentTargetLimitExceeded,
    #[allow(missing_docs)] // documentation missing in model
    AssessmentTemplateLimitExceeded,
    #[allow(missing_docs)] // documentation missing in model
    EventSubscriptionLimitExceeded,
    #[allow(missing_docs)] // documentation missing in model
    ResourceGroupLimitExceeded,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LimitExceededErrorCode {
    fn from(s: &str) -> Self {
        match s {
            "ASSESSMENT_RUN_LIMIT_EXCEEDED" => LimitExceededErrorCode::AssessmentRunLimitExceeded,
            "ASSESSMENT_TARGET_LIMIT_EXCEEDED" => {
                LimitExceededErrorCode::AssessmentTargetLimitExceeded
            }
            "ASSESSMENT_TEMPLATE_LIMIT_EXCEEDED" => {
                LimitExceededErrorCode::AssessmentTemplateLimitExceeded
            }
            "EVENT_SUBSCRIPTION_LIMIT_EXCEEDED" => {
                LimitExceededErrorCode::EventSubscriptionLimitExceeded
            }
            "RESOURCE_GROUP_LIMIT_EXCEEDED" => LimitExceededErrorCode::ResourceGroupLimitExceeded,
            other => {
                LimitExceededErrorCode::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for LimitExceededErrorCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LimitExceededErrorCode::from(s))
    }
}
impl LimitExceededErrorCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LimitExceededErrorCode::AssessmentRunLimitExceeded => "ASSESSMENT_RUN_LIMIT_EXCEEDED",
            LimitExceededErrorCode::AssessmentTargetLimitExceeded => {
                "ASSESSMENT_TARGET_LIMIT_EXCEEDED"
            }
            LimitExceededErrorCode::AssessmentTemplateLimitExceeded => {
                "ASSESSMENT_TEMPLATE_LIMIT_EXCEEDED"
            }
            LimitExceededErrorCode::EventSubscriptionLimitExceeded => {
                "EVENT_SUBSCRIPTION_LIMIT_EXCEEDED"
            }
            LimitExceededErrorCode::ResourceGroupLimitExceeded => "RESOURCE_GROUP_LIMIT_EXCEEDED",
            LimitExceededErrorCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ASSESSMENT_RUN_LIMIT_EXCEEDED",
            "ASSESSMENT_TARGET_LIMIT_EXCEEDED",
            "ASSESSMENT_TEMPLATE_LIMIT_EXCEEDED",
            "EVENT_SUBSCRIPTION_LIMIT_EXCEEDED",
            "RESOURCE_GROUP_LIMIT_EXCEEDED",
        ]
    }
}
impl AsRef<str> for LimitExceededErrorCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `StopAction`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let stopaction = unimplemented!();
/// match stopaction {
///     StopAction::SkipEvaluation => { /* ... */ },
///     StopAction::StartEvaluation => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `stopaction` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StopAction::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StopAction::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StopAction::NewFeature` is defined.
/// Specifically, when `stopaction` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StopAction::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StopAction {
    #[allow(missing_docs)] // documentation missing in model
    SkipEvaluation,
    #[allow(missing_docs)] // documentation missing in model
    StartEvaluation,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StopAction {
    fn from(s: &str) -> Self {
        match s {
            "SKIP_EVALUATION" => StopAction::SkipEvaluation,
            "START_EVALUATION" => StopAction::StartEvaluation,
            other => StopAction::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for StopAction {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StopAction::from(s))
    }
}
impl StopAction {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StopAction::SkipEvaluation => "SKIP_EVALUATION",
            StopAction::StartEvaluation => "START_EVALUATION",
            StopAction::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["SKIP_EVALUATION", "START_EVALUATION"]
    }
}
impl AsRef<str> for StopAction {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `InvalidCrossAccountRoleErrorCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let invalidcrossaccountroleerrorcode = unimplemented!();
/// match invalidcrossaccountroleerrorcode {
///     InvalidCrossAccountRoleErrorCode::RoleDoesNotExistOrInvalidTrustRelationship => { /* ... */ },
///     InvalidCrossAccountRoleErrorCode::RoleDoesNotHaveCorrectPolicy => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `invalidcrossaccountroleerrorcode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `InvalidCrossAccountRoleErrorCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `InvalidCrossAccountRoleErrorCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `InvalidCrossAccountRoleErrorCode::NewFeature` is defined.
/// Specifically, when `invalidcrossaccountroleerrorcode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `InvalidCrossAccountRoleErrorCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InvalidCrossAccountRoleErrorCode {
    #[allow(missing_docs)] // documentation missing in model
    RoleDoesNotExistOrInvalidTrustRelationship,
    #[allow(missing_docs)] // documentation missing in model
    RoleDoesNotHaveCorrectPolicy,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for InvalidCrossAccountRoleErrorCode {
    fn from(s: &str) -> Self {
        match s {
            "ROLE_DOES_NOT_EXIST_OR_INVALID_TRUST_RELATIONSHIP" => {
                InvalidCrossAccountRoleErrorCode::RoleDoesNotExistOrInvalidTrustRelationship
            }
            "ROLE_DOES_NOT_HAVE_CORRECT_POLICY" => {
                InvalidCrossAccountRoleErrorCode::RoleDoesNotHaveCorrectPolicy
            }
            other => InvalidCrossAccountRoleErrorCode::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for InvalidCrossAccountRoleErrorCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InvalidCrossAccountRoleErrorCode::from(s))
    }
}
impl InvalidCrossAccountRoleErrorCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            InvalidCrossAccountRoleErrorCode::RoleDoesNotExistOrInvalidTrustRelationship => {
                "ROLE_DOES_NOT_EXIST_OR_INVALID_TRUST_RELATIONSHIP"
            }
            InvalidCrossAccountRoleErrorCode::RoleDoesNotHaveCorrectPolicy => {
                "ROLE_DOES_NOT_HAVE_CORRECT_POLICY"
            }
            InvalidCrossAccountRoleErrorCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ROLE_DOES_NOT_EXIST_OR_INVALID_TRUST_RELATIONSHIP",
            "ROLE_DOES_NOT_HAVE_CORRECT_POLICY",
        ]
    }
}
impl AsRef<str> for InvalidCrossAccountRoleErrorCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Used in the exception error that is thrown if you start an assessment run for an assessment target that includes an EC2 instance that is already participating in another started assessment run.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AgentAlreadyRunningAssessment {
    /// <p>ID of the agent that is running on an EC2 instance that is already participating in another started assessment run.</p>
    #[doc(hidden)]
    pub agent_id: std::option::Option<std::string::String>,
    /// <p>The ARN of the assessment run that has already been started.</p>
    #[doc(hidden)]
    pub assessment_run_arn: std::option::Option<std::string::String>,
}
impl AgentAlreadyRunningAssessment {
    /// <p>ID of the agent that is running on an EC2 instance that is already participating in another started assessment run.</p>
    pub fn agent_id(&self) -> std::option::Option<&str> {
        self.agent_id.as_deref()
    }
    /// <p>The ARN of the assessment run that has already been started.</p>
    pub fn assessment_run_arn(&self) -> std::option::Option<&str> {
        self.assessment_run_arn.as_deref()
    }
}
/// See [`AgentAlreadyRunningAssessment`](crate::model::AgentAlreadyRunningAssessment).
pub mod agent_already_running_assessment {

    /// A builder for [`AgentAlreadyRunningAssessment`](crate::model::AgentAlreadyRunningAssessment).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) agent_id: std::option::Option<std::string::String>,
        pub(crate) assessment_run_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>ID of the agent that is running on an EC2 instance that is already participating in another started assessment run.</p>
        pub fn agent_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.agent_id = Some(input.into());
            self
        }
        /// <p>ID of the agent that is running on an EC2 instance that is already participating in another started assessment run.</p>
        pub fn set_agent_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.agent_id = input;
            self
        }
        /// <p>The ARN of the assessment run that has already been started.</p>
        pub fn assessment_run_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_run_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the assessment run that has already been started.</p>
        pub fn set_assessment_run_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_run_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`AgentAlreadyRunningAssessment`](crate::model::AgentAlreadyRunningAssessment).
        pub fn build(self) -> crate::model::AgentAlreadyRunningAssessment {
            crate::model::AgentAlreadyRunningAssessment {
                agent_id: self.agent_id,
                assessment_run_arn: self.assessment_run_arn,
            }
        }
    }
}
impl AgentAlreadyRunningAssessment {
    /// Creates a new builder-style object to manufacture [`AgentAlreadyRunningAssessment`](crate::model::AgentAlreadyRunningAssessment).
    pub fn builder() -> crate::model::agent_already_running_assessment::Builder {
        crate::model::agent_already_running_assessment::Builder::default()
    }
}

/// <p>A key and value pair. This data type is used as a request parameter in the <code>SetTagsForResource</code> action and a response element in the <code>ListTagsForResource</code> action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Tag {
    /// <p>A tag key.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>A value assigned to a tag key.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl Tag {
    /// <p>A tag key.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>A value assigned to a tag key.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`Tag`](crate::model::Tag).
pub mod tag {

    /// A builder for [`Tag`](crate::model::Tag).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A tag key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>A tag key.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>A value assigned to a tag key.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>A value assigned to a tag key.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag).
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag).
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// <p>Includes details about the failed items.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FailedItemDetails {
    /// <p>The status code of a failed item.</p>
    #[doc(hidden)]
    pub failure_code: std::option::Option<crate::model::FailedItemErrorCode>,
    /// <p>Indicates whether you can immediately retry a request for this item for a specified resource.</p>
    #[doc(hidden)]
    pub retryable: std::option::Option<bool>,
}
impl FailedItemDetails {
    /// <p>The status code of a failed item.</p>
    pub fn failure_code(&self) -> std::option::Option<&crate::model::FailedItemErrorCode> {
        self.failure_code.as_ref()
    }
    /// <p>Indicates whether you can immediately retry a request for this item for a specified resource.</p>
    pub fn retryable(&self) -> std::option::Option<bool> {
        self.retryable
    }
}
/// See [`FailedItemDetails`](crate::model::FailedItemDetails).
pub mod failed_item_details {

    /// A builder for [`FailedItemDetails`](crate::model::FailedItemDetails).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) failure_code: std::option::Option<crate::model::FailedItemErrorCode>,
        pub(crate) retryable: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The status code of a failed item.</p>
        pub fn failure_code(mut self, input: crate::model::FailedItemErrorCode) -> Self {
            self.failure_code = Some(input);
            self
        }
        /// <p>The status code of a failed item.</p>
        pub fn set_failure_code(
            mut self,
            input: std::option::Option<crate::model::FailedItemErrorCode>,
        ) -> Self {
            self.failure_code = input;
            self
        }
        /// <p>Indicates whether you can immediately retry a request for this item for a specified resource.</p>
        pub fn retryable(mut self, input: bool) -> Self {
            self.retryable = Some(input);
            self
        }
        /// <p>Indicates whether you can immediately retry a request for this item for a specified resource.</p>
        pub fn set_retryable(mut self, input: std::option::Option<bool>) -> Self {
            self.retryable = input;
            self
        }
        /// Consumes the builder and constructs a [`FailedItemDetails`](crate::model::FailedItemDetails).
        pub fn build(self) -> crate::model::FailedItemDetails {
            crate::model::FailedItemDetails {
                failure_code: self.failure_code,
                retryable: self.retryable,
            }
        }
    }
}
impl FailedItemDetails {
    /// Creates a new builder-style object to manufacture [`FailedItemDetails`](crate::model::FailedItemDetails).
    pub fn builder() -> crate::model::failed_item_details::Builder {
        crate::model::failed_item_details::Builder::default()
    }
}

/// When writing a match expression against `FailedItemErrorCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let faileditemerrorcode = unimplemented!();
/// match faileditemerrorcode {
///     FailedItemErrorCode::AccessDenied => { /* ... */ },
///     FailedItemErrorCode::DuplicateArn => { /* ... */ },
///     FailedItemErrorCode::InternalError => { /* ... */ },
///     FailedItemErrorCode::InvalidArn => { /* ... */ },
///     FailedItemErrorCode::ItemDoesNotExist => { /* ... */ },
///     FailedItemErrorCode::LimitExceeded => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `faileditemerrorcode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FailedItemErrorCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FailedItemErrorCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FailedItemErrorCode::NewFeature` is defined.
/// Specifically, when `faileditemerrorcode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FailedItemErrorCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FailedItemErrorCode {
    #[allow(missing_docs)] // documentation missing in model
    AccessDenied,
    #[allow(missing_docs)] // documentation missing in model
    DuplicateArn,
    #[allow(missing_docs)] // documentation missing in model
    InternalError,
    #[allow(missing_docs)] // documentation missing in model
    InvalidArn,
    #[allow(missing_docs)] // documentation missing in model
    ItemDoesNotExist,
    #[allow(missing_docs)] // documentation missing in model
    LimitExceeded,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FailedItemErrorCode {
    fn from(s: &str) -> Self {
        match s {
            "ACCESS_DENIED" => FailedItemErrorCode::AccessDenied,
            "DUPLICATE_ARN" => FailedItemErrorCode::DuplicateArn,
            "INTERNAL_ERROR" => FailedItemErrorCode::InternalError,
            "INVALID_ARN" => FailedItemErrorCode::InvalidArn,
            "ITEM_DOES_NOT_EXIST" => FailedItemErrorCode::ItemDoesNotExist,
            "LIMIT_EXCEEDED" => FailedItemErrorCode::LimitExceeded,
            other => {
                FailedItemErrorCode::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for FailedItemErrorCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FailedItemErrorCode::from(s))
    }
}
impl FailedItemErrorCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FailedItemErrorCode::AccessDenied => "ACCESS_DENIED",
            FailedItemErrorCode::DuplicateArn => "DUPLICATE_ARN",
            FailedItemErrorCode::InternalError => "INTERNAL_ERROR",
            FailedItemErrorCode::InvalidArn => "INVALID_ARN",
            FailedItemErrorCode::ItemDoesNotExist => "ITEM_DOES_NOT_EXIST",
            FailedItemErrorCode::LimitExceeded => "LIMIT_EXCEEDED",
            FailedItemErrorCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACCESS_DENIED",
            "DUPLICATE_ARN",
            "INTERNAL_ERROR",
            "INVALID_ARN",
            "ITEM_DOES_NOT_EXIST",
            "LIMIT_EXCEEDED",
        ]
    }
}
impl AsRef<str> for FailedItemErrorCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Used as a response element in the <code>PreviewAgents</code> action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AgentPreview {
    /// <p>The hostname of the EC2 instance on which the Amazon Inspector Agent is installed.</p>
    #[doc(hidden)]
    pub hostname: std::option::Option<std::string::String>,
    /// <p>The ID of the EC2 instance where the agent is installed.</p>
    #[doc(hidden)]
    pub agent_id: std::option::Option<std::string::String>,
    /// <p>The Auto Scaling group for the EC2 instance where the agent is installed.</p>
    #[doc(hidden)]
    pub auto_scaling_group: std::option::Option<std::string::String>,
    /// <p>The health status of the Amazon Inspector Agent.</p>
    #[doc(hidden)]
    pub agent_health: std::option::Option<crate::model::AgentHealth>,
    /// <p>The version of the Amazon Inspector Agent.</p>
    #[doc(hidden)]
    pub agent_version: std::option::Option<std::string::String>,
    /// <p>The operating system running on the EC2 instance on which the Amazon Inspector Agent is installed.</p>
    #[doc(hidden)]
    pub operating_system: std::option::Option<std::string::String>,
    /// <p>The kernel version of the operating system running on the EC2 instance on which the Amazon Inspector Agent is installed.</p>
    #[doc(hidden)]
    pub kernel_version: std::option::Option<std::string::String>,
    /// <p>The IP address of the EC2 instance on which the Amazon Inspector Agent is installed.</p>
    #[doc(hidden)]
    pub ipv4_address: std::option::Option<std::string::String>,
}
impl AgentPreview {
    /// <p>The hostname of the EC2 instance on which the Amazon Inspector Agent is installed.</p>
    pub fn hostname(&self) -> std::option::Option<&str> {
        self.hostname.as_deref()
    }
    /// <p>The ID of the EC2 instance where the agent is installed.</p>
    pub fn agent_id(&self) -> std::option::Option<&str> {
        self.agent_id.as_deref()
    }
    /// <p>The Auto Scaling group for the EC2 instance where the agent is installed.</p>
    pub fn auto_scaling_group(&self) -> std::option::Option<&str> {
        self.auto_scaling_group.as_deref()
    }
    /// <p>The health status of the Amazon Inspector Agent.</p>
    pub fn agent_health(&self) -> std::option::Option<&crate::model::AgentHealth> {
        self.agent_health.as_ref()
    }
    /// <p>The version of the Amazon Inspector Agent.</p>
    pub fn agent_version(&self) -> std::option::Option<&str> {
        self.agent_version.as_deref()
    }
    /// <p>The operating system running on the EC2 instance on which the Amazon Inspector Agent is installed.</p>
    pub fn operating_system(&self) -> std::option::Option<&str> {
        self.operating_system.as_deref()
    }
    /// <p>The kernel version of the operating system running on the EC2 instance on which the Amazon Inspector Agent is installed.</p>
    pub fn kernel_version(&self) -> std::option::Option<&str> {
        self.kernel_version.as_deref()
    }
    /// <p>The IP address of the EC2 instance on which the Amazon Inspector Agent is installed.</p>
    pub fn ipv4_address(&self) -> std::option::Option<&str> {
        self.ipv4_address.as_deref()
    }
}
/// See [`AgentPreview`](crate::model::AgentPreview).
pub mod agent_preview {

    /// A builder for [`AgentPreview`](crate::model::AgentPreview).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) hostname: std::option::Option<std::string::String>,
        pub(crate) agent_id: std::option::Option<std::string::String>,
        pub(crate) auto_scaling_group: std::option::Option<std::string::String>,
        pub(crate) agent_health: std::option::Option<crate::model::AgentHealth>,
        pub(crate) agent_version: std::option::Option<std::string::String>,
        pub(crate) operating_system: std::option::Option<std::string::String>,
        pub(crate) kernel_version: std::option::Option<std::string::String>,
        pub(crate) ipv4_address: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The hostname of the EC2 instance on which the Amazon Inspector Agent is installed.</p>
        pub fn hostname(mut self, input: impl Into<std::string::String>) -> Self {
            self.hostname = Some(input.into());
            self
        }
        /// <p>The hostname of the EC2 instance on which the Amazon Inspector Agent is installed.</p>
        pub fn set_hostname(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hostname = input;
            self
        }
        /// <p>The ID of the EC2 instance where the agent is installed.</p>
        pub fn agent_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.agent_id = Some(input.into());
            self
        }
        /// <p>The ID of the EC2 instance where the agent is installed.</p>
        pub fn set_agent_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.agent_id = input;
            self
        }
        /// <p>The Auto Scaling group for the EC2 instance where the agent is installed.</p>
        pub fn auto_scaling_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.auto_scaling_group = Some(input.into());
            self
        }
        /// <p>The Auto Scaling group for the EC2 instance where the agent is installed.</p>
        pub fn set_auto_scaling_group(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.auto_scaling_group = input;
            self
        }
        /// <p>The health status of the Amazon Inspector Agent.</p>
        pub fn agent_health(mut self, input: crate::model::AgentHealth) -> Self {
            self.agent_health = Some(input);
            self
        }
        /// <p>The health status of the Amazon Inspector Agent.</p>
        pub fn set_agent_health(
            mut self,
            input: std::option::Option<crate::model::AgentHealth>,
        ) -> Self {
            self.agent_health = input;
            self
        }
        /// <p>The version of the Amazon Inspector Agent.</p>
        pub fn agent_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.agent_version = Some(input.into());
            self
        }
        /// <p>The version of the Amazon Inspector Agent.</p>
        pub fn set_agent_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.agent_version = input;
            self
        }
        /// <p>The operating system running on the EC2 instance on which the Amazon Inspector Agent is installed.</p>
        pub fn operating_system(mut self, input: impl Into<std::string::String>) -> Self {
            self.operating_system = Some(input.into());
            self
        }
        /// <p>The operating system running on the EC2 instance on which the Amazon Inspector Agent is installed.</p>
        pub fn set_operating_system(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.operating_system = input;
            self
        }
        /// <p>The kernel version of the operating system running on the EC2 instance on which the Amazon Inspector Agent is installed.</p>
        pub fn kernel_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.kernel_version = Some(input.into());
            self
        }
        /// <p>The kernel version of the operating system running on the EC2 instance on which the Amazon Inspector Agent is installed.</p>
        pub fn set_kernel_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.kernel_version = input;
            self
        }
        /// <p>The IP address of the EC2 instance on which the Amazon Inspector Agent is installed.</p>
        pub fn ipv4_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.ipv4_address = Some(input.into());
            self
        }
        /// <p>The IP address of the EC2 instance on which the Amazon Inspector Agent is installed.</p>
        pub fn set_ipv4_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ipv4_address = input;
            self
        }
        /// Consumes the builder and constructs a [`AgentPreview`](crate::model::AgentPreview).
        pub fn build(self) -> crate::model::AgentPreview {
            crate::model::AgentPreview {
                hostname: self.hostname,
                agent_id: self.agent_id,
                auto_scaling_group: self.auto_scaling_group,
                agent_health: self.agent_health,
                agent_version: self.agent_version,
                operating_system: self.operating_system,
                kernel_version: self.kernel_version,
                ipv4_address: self.ipv4_address,
            }
        }
    }
}
impl AgentPreview {
    /// Creates a new builder-style object to manufacture [`AgentPreview`](crate::model::AgentPreview).
    pub fn builder() -> crate::model::agent_preview::Builder {
        crate::model::agent_preview::Builder::default()
    }
}

/// When writing a match expression against `AgentHealth`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let agenthealth = unimplemented!();
/// match agenthealth {
///     AgentHealth::Healthy => { /* ... */ },
///     AgentHealth::Unhealthy => { /* ... */ },
///     AgentHealth::UnknownValue => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `agenthealth` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AgentHealth::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AgentHealth::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AgentHealth::NewFeature` is defined.
/// Specifically, when `agenthealth` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AgentHealth::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// _Note: `AgentHealth::Unknown` has been renamed to `::UnknownValue`._
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AgentHealth {
    #[allow(missing_docs)] // documentation missing in model
    Healthy,
    #[allow(missing_docs)] // documentation missing in model
    Unhealthy,
    /// _Note: `::Unknown` has been renamed to `::UnknownValue`._
    UnknownValue,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AgentHealth {
    fn from(s: &str) -> Self {
        match s {
            "HEALTHY" => AgentHealth::Healthy,
            "UNHEALTHY" => AgentHealth::Unhealthy,
            "UNKNOWN" => AgentHealth::UnknownValue,
            other => AgentHealth::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AgentHealth {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AgentHealth::from(s))
    }
}
impl AgentHealth {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AgentHealth::Healthy => "HEALTHY",
            AgentHealth::Unhealthy => "UNHEALTHY",
            AgentHealth::UnknownValue => "UNKNOWN",
            AgentHealth::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["HEALTHY", "UNHEALTHY", "UNKNOWN"]
    }
}
impl AsRef<str> for AgentHealth {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>This data type is used as a request parameter in the <code>ListFindings</code> action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FindingFilter {
    /// <p>For a record to match a filter, one of the values that is specified for this data type property must be the exact match of the value of the <b>agentId</b> property of the <code>Finding</code> data type.</p>
    #[doc(hidden)]
    pub agent_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>For a record to match a filter, one of the values that is specified for this data type property must be the exact match of the value of the <b>autoScalingGroup</b> property of the <code>Finding</code> data type.</p>
    #[doc(hidden)]
    pub auto_scaling_groups: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>For a record to match a filter, one of the values that is specified for this data type property must be the exact match of the value of the <b>ruleName</b> property of the <code>Finding</code> data type.</p>
    #[doc(hidden)]
    pub rule_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>For a record to match a filter, one of the values that is specified for this data type property must be the exact match of the value of the <b>severity</b> property of the <code>Finding</code> data type.</p>
    #[doc(hidden)]
    pub severities: std::option::Option<std::vec::Vec<crate::model::Severity>>,
    /// <p>For a record to match a filter, one of the values that is specified for this data type property must be the exact match of the value of the <b>rulesPackageArn</b> property of the <code>Finding</code> data type.</p>
    #[doc(hidden)]
    pub rules_package_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>For a record to match a filter, the list of values that are specified for this data type property must be contained in the list of values of the <b>attributes</b> property of the <code>Finding</code> data type.</p>
    #[doc(hidden)]
    pub attributes: std::option::Option<std::vec::Vec<crate::model::Attribute>>,
    /// <p>For a record to match a filter, the value that is specified for this data type property must be contained in the list of values of the <b>userAttributes</b> property of the <code>Finding</code> data type.</p>
    #[doc(hidden)]
    pub user_attributes: std::option::Option<std::vec::Vec<crate::model::Attribute>>,
    /// <p>The time range during which the finding is generated.</p>
    #[doc(hidden)]
    pub creation_time_range: std::option::Option<crate::model::TimestampRange>,
}
impl FindingFilter {
    /// <p>For a record to match a filter, one of the values that is specified for this data type property must be the exact match of the value of the <b>agentId</b> property of the <code>Finding</code> data type.</p>
    pub fn agent_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.agent_ids.as_deref()
    }
    /// <p>For a record to match a filter, one of the values that is specified for this data type property must be the exact match of the value of the <b>autoScalingGroup</b> property of the <code>Finding</code> data type.</p>
    pub fn auto_scaling_groups(&self) -> std::option::Option<&[std::string::String]> {
        self.auto_scaling_groups.as_deref()
    }
    /// <p>For a record to match a filter, one of the values that is specified for this data type property must be the exact match of the value of the <b>ruleName</b> property of the <code>Finding</code> data type.</p>
    pub fn rule_names(&self) -> std::option::Option<&[std::string::String]> {
        self.rule_names.as_deref()
    }
    /// <p>For a record to match a filter, one of the values that is specified for this data type property must be the exact match of the value of the <b>severity</b> property of the <code>Finding</code> data type.</p>
    pub fn severities(&self) -> std::option::Option<&[crate::model::Severity]> {
        self.severities.as_deref()
    }
    /// <p>For a record to match a filter, one of the values that is specified for this data type property must be the exact match of the value of the <b>rulesPackageArn</b> property of the <code>Finding</code> data type.</p>
    pub fn rules_package_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.rules_package_arns.as_deref()
    }
    /// <p>For a record to match a filter, the list of values that are specified for this data type property must be contained in the list of values of the <b>attributes</b> property of the <code>Finding</code> data type.</p>
    pub fn attributes(&self) -> std::option::Option<&[crate::model::Attribute]> {
        self.attributes.as_deref()
    }
    /// <p>For a record to match a filter, the value that is specified for this data type property must be contained in the list of values of the <b>userAttributes</b> property of the <code>Finding</code> data type.</p>
    pub fn user_attributes(&self) -> std::option::Option<&[crate::model::Attribute]> {
        self.user_attributes.as_deref()
    }
    /// <p>The time range during which the finding is generated.</p>
    pub fn creation_time_range(&self) -> std::option::Option<&crate::model::TimestampRange> {
        self.creation_time_range.as_ref()
    }
}
/// See [`FindingFilter`](crate::model::FindingFilter).
pub mod finding_filter {

    /// A builder for [`FindingFilter`](crate::model::FindingFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) agent_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) auto_scaling_groups: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) rule_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) severities: std::option::Option<std::vec::Vec<crate::model::Severity>>,
        pub(crate) rules_package_arns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) attributes: std::option::Option<std::vec::Vec<crate::model::Attribute>>,
        pub(crate) user_attributes: std::option::Option<std::vec::Vec<crate::model::Attribute>>,
        pub(crate) creation_time_range: std::option::Option<crate::model::TimestampRange>,
    }
    impl Builder {
        /// Appends an item to `agent_ids`.
        ///
        /// To override the contents of this collection use [`set_agent_ids`](Self::set_agent_ids).
        ///
        /// <p>For a record to match a filter, one of the values that is specified for this data type property must be the exact match of the value of the <b>agentId</b> property of the <code>Finding</code> data type.</p>
        pub fn agent_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.agent_ids.unwrap_or_default();
            v.push(input.into());
            self.agent_ids = Some(v);
            self
        }
        /// <p>For a record to match a filter, one of the values that is specified for this data type property must be the exact match of the value of the <b>agentId</b> property of the <code>Finding</code> data type.</p>
        pub fn set_agent_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.agent_ids = input;
            self
        }
        /// Appends an item to `auto_scaling_groups`.
        ///
        /// To override the contents of this collection use [`set_auto_scaling_groups`](Self::set_auto_scaling_groups).
        ///
        /// <p>For a record to match a filter, one of the values that is specified for this data type property must be the exact match of the value of the <b>autoScalingGroup</b> property of the <code>Finding</code> data type.</p>
        pub fn auto_scaling_groups(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.auto_scaling_groups.unwrap_or_default();
            v.push(input.into());
            self.auto_scaling_groups = Some(v);
            self
        }
        /// <p>For a record to match a filter, one of the values that is specified for this data type property must be the exact match of the value of the <b>autoScalingGroup</b> property of the <code>Finding</code> data type.</p>
        pub fn set_auto_scaling_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.auto_scaling_groups = input;
            self
        }
        /// Appends an item to `rule_names`.
        ///
        /// To override the contents of this collection use [`set_rule_names`](Self::set_rule_names).
        ///
        /// <p>For a record to match a filter, one of the values that is specified for this data type property must be the exact match of the value of the <b>ruleName</b> property of the <code>Finding</code> data type.</p>
        pub fn rule_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.rule_names.unwrap_or_default();
            v.push(input.into());
            self.rule_names = Some(v);
            self
        }
        /// <p>For a record to match a filter, one of the values that is specified for this data type property must be the exact match of the value of the <b>ruleName</b> property of the <code>Finding</code> data type.</p>
        pub fn set_rule_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.rule_names = input;
            self
        }
        /// Appends an item to `severities`.
        ///
        /// To override the contents of this collection use [`set_severities`](Self::set_severities).
        ///
        /// <p>For a record to match a filter, one of the values that is specified for this data type property must be the exact match of the value of the <b>severity</b> property of the <code>Finding</code> data type.</p>
        pub fn severities(mut self, input: crate::model::Severity) -> Self {
            let mut v = self.severities.unwrap_or_default();
            v.push(input);
            self.severities = Some(v);
            self
        }
        /// <p>For a record to match a filter, one of the values that is specified for this data type property must be the exact match of the value of the <b>severity</b> property of the <code>Finding</code> data type.</p>
        pub fn set_severities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Severity>>,
        ) -> Self {
            self.severities = input;
            self
        }
        /// Appends an item to `rules_package_arns`.
        ///
        /// To override the contents of this collection use [`set_rules_package_arns`](Self::set_rules_package_arns).
        ///
        /// <p>For a record to match a filter, one of the values that is specified for this data type property must be the exact match of the value of the <b>rulesPackageArn</b> property of the <code>Finding</code> data type.</p>
        pub fn rules_package_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.rules_package_arns.unwrap_or_default();
            v.push(input.into());
            self.rules_package_arns = Some(v);
            self
        }
        /// <p>For a record to match a filter, one of the values that is specified for this data type property must be the exact match of the value of the <b>rulesPackageArn</b> property of the <code>Finding</code> data type.</p>
        pub fn set_rules_package_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.rules_package_arns = input;
            self
        }
        /// Appends an item to `attributes`.
        ///
        /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
        ///
        /// <p>For a record to match a filter, the list of values that are specified for this data type property must be contained in the list of values of the <b>attributes</b> property of the <code>Finding</code> data type.</p>
        pub fn attributes(mut self, input: crate::model::Attribute) -> Self {
            let mut v = self.attributes.unwrap_or_default();
            v.push(input);
            self.attributes = Some(v);
            self
        }
        /// <p>For a record to match a filter, the list of values that are specified for this data type property must be contained in the list of values of the <b>attributes</b> property of the <code>Finding</code> data type.</p>
        pub fn set_attributes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Attribute>>,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// Appends an item to `user_attributes`.
        ///
        /// To override the contents of this collection use [`set_user_attributes`](Self::set_user_attributes).
        ///
        /// <p>For a record to match a filter, the value that is specified for this data type property must be contained in the list of values of the <b>userAttributes</b> property of the <code>Finding</code> data type.</p>
        pub fn user_attributes(mut self, input: crate::model::Attribute) -> Self {
            let mut v = self.user_attributes.unwrap_or_default();
            v.push(input);
            self.user_attributes = Some(v);
            self
        }
        /// <p>For a record to match a filter, the value that is specified for this data type property must be contained in the list of values of the <b>userAttributes</b> property of the <code>Finding</code> data type.</p>
        pub fn set_user_attributes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Attribute>>,
        ) -> Self {
            self.user_attributes = input;
            self
        }
        /// <p>The time range during which the finding is generated.</p>
        pub fn creation_time_range(mut self, input: crate::model::TimestampRange) -> Self {
            self.creation_time_range = Some(input);
            self
        }
        /// <p>The time range during which the finding is generated.</p>
        pub fn set_creation_time_range(
            mut self,
            input: std::option::Option<crate::model::TimestampRange>,
        ) -> Self {
            self.creation_time_range = input;
            self
        }
        /// Consumes the builder and constructs a [`FindingFilter`](crate::model::FindingFilter).
        pub fn build(self) -> crate::model::FindingFilter {
            crate::model::FindingFilter {
                agent_ids: self.agent_ids,
                auto_scaling_groups: self.auto_scaling_groups,
                rule_names: self.rule_names,
                severities: self.severities,
                rules_package_arns: self.rules_package_arns,
                attributes: self.attributes,
                user_attributes: self.user_attributes,
                creation_time_range: self.creation_time_range,
            }
        }
    }
}
impl FindingFilter {
    /// Creates a new builder-style object to manufacture [`FindingFilter`](crate::model::FindingFilter).
    pub fn builder() -> crate::model::finding_filter::Builder {
        crate::model::finding_filter::Builder::default()
    }
}

/// <p>This data type is used in the <code>AssessmentRunFilter</code> data type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TimestampRange {
    /// <p>The minimum value of the timestamp range.</p>
    #[doc(hidden)]
    pub begin_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The maximum value of the timestamp range.</p>
    #[doc(hidden)]
    pub end_date: std::option::Option<aws_smithy_types::DateTime>,
}
impl TimestampRange {
    /// <p>The minimum value of the timestamp range.</p>
    pub fn begin_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.begin_date.as_ref()
    }
    /// <p>The maximum value of the timestamp range.</p>
    pub fn end_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_date.as_ref()
    }
}
/// See [`TimestampRange`](crate::model::TimestampRange).
pub mod timestamp_range {

    /// A builder for [`TimestampRange`](crate::model::TimestampRange).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) begin_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_date: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The minimum value of the timestamp range.</p>
        pub fn begin_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.begin_date = Some(input);
            self
        }
        /// <p>The minimum value of the timestamp range.</p>
        pub fn set_begin_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.begin_date = input;
            self
        }
        /// <p>The maximum value of the timestamp range.</p>
        pub fn end_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_date = Some(input);
            self
        }
        /// <p>The maximum value of the timestamp range.</p>
        pub fn set_end_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_date = input;
            self
        }
        /// Consumes the builder and constructs a [`TimestampRange`](crate::model::TimestampRange).
        pub fn build(self) -> crate::model::TimestampRange {
            crate::model::TimestampRange {
                begin_date: self.begin_date,
                end_date: self.end_date,
            }
        }
    }
}
impl TimestampRange {
    /// Creates a new builder-style object to manufacture [`TimestampRange`](crate::model::TimestampRange).
    pub fn builder() -> crate::model::timestamp_range::Builder {
        crate::model::timestamp_range::Builder::default()
    }
}

/// <p>This data type is used as a request parameter in the <code>AddAttributesToFindings</code> and <code>CreateAssessmentTemplate</code> actions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Attribute {
    /// <p>The attribute key.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The value assigned to the attribute key.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl Attribute {
    /// <p>The attribute key.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The value assigned to the attribute key.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`Attribute`](crate::model::Attribute).
pub mod attribute {

    /// A builder for [`Attribute`](crate::model::Attribute).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The attribute key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The attribute key.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The value assigned to the attribute key.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value assigned to the attribute key.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Attribute`](crate::model::Attribute).
        pub fn build(self) -> crate::model::Attribute {
            crate::model::Attribute {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl Attribute {
    /// Creates a new builder-style object to manufacture [`Attribute`](crate::model::Attribute).
    pub fn builder() -> crate::model::attribute::Builder {
        crate::model::attribute::Builder::default()
    }
}

/// When writing a match expression against `Severity`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let severity = unimplemented!();
/// match severity {
///     Severity::High => { /* ... */ },
///     Severity::Informational => { /* ... */ },
///     Severity::Low => { /* ... */ },
///     Severity::Medium => { /* ... */ },
///     Severity::Undefined => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `severity` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Severity::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Severity::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Severity::NewFeature` is defined.
/// Specifically, when `severity` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Severity::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Severity {
    #[allow(missing_docs)] // documentation missing in model
    High,
    #[allow(missing_docs)] // documentation missing in model
    Informational,
    #[allow(missing_docs)] // documentation missing in model
    Low,
    #[allow(missing_docs)] // documentation missing in model
    Medium,
    #[allow(missing_docs)] // documentation missing in model
    Undefined,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Severity {
    fn from(s: &str) -> Self {
        match s {
            "High" => Severity::High,
            "Informational" => Severity::Informational,
            "Low" => Severity::Low,
            "Medium" => Severity::Medium,
            "Undefined" => Severity::Undefined,
            other => Severity::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Severity {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Severity::from(s))
    }
}
impl Severity {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Severity::High => "High",
            Severity::Informational => "Informational",
            Severity::Low => "Low",
            Severity::Medium => "Medium",
            Severity::Undefined => "Undefined",
            Severity::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["High", "Informational", "Low", "Medium", "Undefined"]
    }
}
impl AsRef<str> for Severity {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>This data type is used as a response element in the <code>ListEventSubscriptions</code> action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Subscription {
    /// <p>The ARN of the assessment template that is used during the event for which the SNS notification is sent.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the Amazon Simple Notification Service (SNS) topic to which the SNS notifications are sent.</p>
    #[doc(hidden)]
    pub topic_arn: std::option::Option<std::string::String>,
    /// <p>The list of existing event subscriptions.</p>
    #[doc(hidden)]
    pub event_subscriptions: std::option::Option<std::vec::Vec<crate::model::EventSubscription>>,
}
impl Subscription {
    /// <p>The ARN of the assessment template that is used during the event for which the SNS notification is sent.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The ARN of the Amazon Simple Notification Service (SNS) topic to which the SNS notifications are sent.</p>
    pub fn topic_arn(&self) -> std::option::Option<&str> {
        self.topic_arn.as_deref()
    }
    /// <p>The list of existing event subscriptions.</p>
    pub fn event_subscriptions(&self) -> std::option::Option<&[crate::model::EventSubscription]> {
        self.event_subscriptions.as_deref()
    }
}
/// See [`Subscription`](crate::model::Subscription).
pub mod subscription {

    /// A builder for [`Subscription`](crate::model::Subscription).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) topic_arn: std::option::Option<std::string::String>,
        pub(crate) event_subscriptions:
            std::option::Option<std::vec::Vec<crate::model::EventSubscription>>,
    }
    impl Builder {
        /// <p>The ARN of the assessment template that is used during the event for which the SNS notification is sent.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the assessment template that is used during the event for which the SNS notification is sent.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// <p>The ARN of the Amazon Simple Notification Service (SNS) topic to which the SNS notifications are sent.</p>
        pub fn topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.topic_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the Amazon Simple Notification Service (SNS) topic to which the SNS notifications are sent.</p>
        pub fn set_topic_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.topic_arn = input;
            self
        }
        /// Appends an item to `event_subscriptions`.
        ///
        /// To override the contents of this collection use [`set_event_subscriptions`](Self::set_event_subscriptions).
        ///
        /// <p>The list of existing event subscriptions.</p>
        pub fn event_subscriptions(mut self, input: crate::model::EventSubscription) -> Self {
            let mut v = self.event_subscriptions.unwrap_or_default();
            v.push(input);
            self.event_subscriptions = Some(v);
            self
        }
        /// <p>The list of existing event subscriptions.</p>
        pub fn set_event_subscriptions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EventSubscription>>,
        ) -> Self {
            self.event_subscriptions = input;
            self
        }
        /// Consumes the builder and constructs a [`Subscription`](crate::model::Subscription).
        pub fn build(self) -> crate::model::Subscription {
            crate::model::Subscription {
                resource_arn: self.resource_arn,
                topic_arn: self.topic_arn,
                event_subscriptions: self.event_subscriptions,
            }
        }
    }
}
impl Subscription {
    /// Creates a new builder-style object to manufacture [`Subscription`](crate::model::Subscription).
    pub fn builder() -> crate::model::subscription::Builder {
        crate::model::subscription::Builder::default()
    }
}

/// <p>This data type is used in the <code>Subscription</code> data type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EventSubscription {
    /// <p>The event for which Amazon Simple Notification Service (SNS) notifications are sent.</p>
    #[doc(hidden)]
    pub event: std::option::Option<crate::model::InspectorEvent>,
    /// <p>The time at which <code>SubscribeToEvent</code> is called.</p>
    #[doc(hidden)]
    pub subscribed_at: std::option::Option<aws_smithy_types::DateTime>,
}
impl EventSubscription {
    /// <p>The event for which Amazon Simple Notification Service (SNS) notifications are sent.</p>
    pub fn event(&self) -> std::option::Option<&crate::model::InspectorEvent> {
        self.event.as_ref()
    }
    /// <p>The time at which <code>SubscribeToEvent</code> is called.</p>
    pub fn subscribed_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.subscribed_at.as_ref()
    }
}
/// See [`EventSubscription`](crate::model::EventSubscription).
pub mod event_subscription {

    /// A builder for [`EventSubscription`](crate::model::EventSubscription).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) event: std::option::Option<crate::model::InspectorEvent>,
        pub(crate) subscribed_at: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The event for which Amazon Simple Notification Service (SNS) notifications are sent.</p>
        pub fn event(mut self, input: crate::model::InspectorEvent) -> Self {
            self.event = Some(input);
            self
        }
        /// <p>The event for which Amazon Simple Notification Service (SNS) notifications are sent.</p>
        pub fn set_event(
            mut self,
            input: std::option::Option<crate::model::InspectorEvent>,
        ) -> Self {
            self.event = input;
            self
        }
        /// <p>The time at which <code>SubscribeToEvent</code> is called.</p>
        pub fn subscribed_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.subscribed_at = Some(input);
            self
        }
        /// <p>The time at which <code>SubscribeToEvent</code> is called.</p>
        pub fn set_subscribed_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.subscribed_at = input;
            self
        }
        /// Consumes the builder and constructs a [`EventSubscription`](crate::model::EventSubscription).
        pub fn build(self) -> crate::model::EventSubscription {
            crate::model::EventSubscription {
                event: self.event,
                subscribed_at: self.subscribed_at,
            }
        }
    }
}
impl EventSubscription {
    /// Creates a new builder-style object to manufacture [`EventSubscription`](crate::model::EventSubscription).
    pub fn builder() -> crate::model::event_subscription::Builder {
        crate::model::event_subscription::Builder::default()
    }
}

/// <p>Used as the request parameter in the <code>ListAssessmentTemplates</code> action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssessmentTemplateFilter {
    /// <p>For a record to match a filter, an explicit value or a string that contains a wildcard that is specified for this data type property must match the value of the <b>assessmentTemplateName</b> property of the <code>AssessmentTemplate</code> data type.</p>
    #[doc(hidden)]
    pub name_pattern: std::option::Option<std::string::String>,
    /// <p>For a record to match a filter, the value specified for this data type property must inclusively match any value between the specified minimum and maximum values of the <b>durationInSeconds</b> property of the <code>AssessmentTemplate</code> data type.</p>
    #[doc(hidden)]
    pub duration_range: std::option::Option<crate::model::DurationRange>,
    /// <p>For a record to match a filter, the values that are specified for this data type property must be contained in the list of values of the <b>rulesPackageArns</b> property of the <code>AssessmentTemplate</code> data type.</p>
    #[doc(hidden)]
    pub rules_package_arns: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl AssessmentTemplateFilter {
    /// <p>For a record to match a filter, an explicit value or a string that contains a wildcard that is specified for this data type property must match the value of the <b>assessmentTemplateName</b> property of the <code>AssessmentTemplate</code> data type.</p>
    pub fn name_pattern(&self) -> std::option::Option<&str> {
        self.name_pattern.as_deref()
    }
    /// <p>For a record to match a filter, the value specified for this data type property must inclusively match any value between the specified minimum and maximum values of the <b>durationInSeconds</b> property of the <code>AssessmentTemplate</code> data type.</p>
    pub fn duration_range(&self) -> std::option::Option<&crate::model::DurationRange> {
        self.duration_range.as_ref()
    }
    /// <p>For a record to match a filter, the values that are specified for this data type property must be contained in the list of values of the <b>rulesPackageArns</b> property of the <code>AssessmentTemplate</code> data type.</p>
    pub fn rules_package_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.rules_package_arns.as_deref()
    }
}
/// See [`AssessmentTemplateFilter`](crate::model::AssessmentTemplateFilter).
pub mod assessment_template_filter {

    /// A builder for [`AssessmentTemplateFilter`](crate::model::AssessmentTemplateFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name_pattern: std::option::Option<std::string::String>,
        pub(crate) duration_range: std::option::Option<crate::model::DurationRange>,
        pub(crate) rules_package_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>For a record to match a filter, an explicit value or a string that contains a wildcard that is specified for this data type property must match the value of the <b>assessmentTemplateName</b> property of the <code>AssessmentTemplate</code> data type.</p>
        pub fn name_pattern(mut self, input: impl Into<std::string::String>) -> Self {
            self.name_pattern = Some(input.into());
            self
        }
        /// <p>For a record to match a filter, an explicit value or a string that contains a wildcard that is specified for this data type property must match the value of the <b>assessmentTemplateName</b> property of the <code>AssessmentTemplate</code> data type.</p>
        pub fn set_name_pattern(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name_pattern = input;
            self
        }
        /// <p>For a record to match a filter, the value specified for this data type property must inclusively match any value between the specified minimum and maximum values of the <b>durationInSeconds</b> property of the <code>AssessmentTemplate</code> data type.</p>
        pub fn duration_range(mut self, input: crate::model::DurationRange) -> Self {
            self.duration_range = Some(input);
            self
        }
        /// <p>For a record to match a filter, the value specified for this data type property must inclusively match any value between the specified minimum and maximum values of the <b>durationInSeconds</b> property of the <code>AssessmentTemplate</code> data type.</p>
        pub fn set_duration_range(
            mut self,
            input: std::option::Option<crate::model::DurationRange>,
        ) -> Self {
            self.duration_range = input;
            self
        }
        /// Appends an item to `rules_package_arns`.
        ///
        /// To override the contents of this collection use [`set_rules_package_arns`](Self::set_rules_package_arns).
        ///
        /// <p>For a record to match a filter, the values that are specified for this data type property must be contained in the list of values of the <b>rulesPackageArns</b> property of the <code>AssessmentTemplate</code> data type.</p>
        pub fn rules_package_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.rules_package_arns.unwrap_or_default();
            v.push(input.into());
            self.rules_package_arns = Some(v);
            self
        }
        /// <p>For a record to match a filter, the values that are specified for this data type property must be contained in the list of values of the <b>rulesPackageArns</b> property of the <code>AssessmentTemplate</code> data type.</p>
        pub fn set_rules_package_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.rules_package_arns = input;
            self
        }
        /// Consumes the builder and constructs a [`AssessmentTemplateFilter`](crate::model::AssessmentTemplateFilter).
        pub fn build(self) -> crate::model::AssessmentTemplateFilter {
            crate::model::AssessmentTemplateFilter {
                name_pattern: self.name_pattern,
                duration_range: self.duration_range,
                rules_package_arns: self.rules_package_arns,
            }
        }
    }
}
impl AssessmentTemplateFilter {
    /// Creates a new builder-style object to manufacture [`AssessmentTemplateFilter`](crate::model::AssessmentTemplateFilter).
    pub fn builder() -> crate::model::assessment_template_filter::Builder {
        crate::model::assessment_template_filter::Builder::default()
    }
}

/// <p>This data type is used in the <code>AssessmentTemplateFilter</code> data type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DurationRange {
    /// <p>The minimum value of the duration range. Must be greater than zero.</p>
    #[doc(hidden)]
    pub min_seconds: i32,
    /// <p>The maximum value of the duration range. Must be less than or equal to 604800 seconds (1 week).</p>
    #[doc(hidden)]
    pub max_seconds: i32,
}
impl DurationRange {
    /// <p>The minimum value of the duration range. Must be greater than zero.</p>
    pub fn min_seconds(&self) -> i32 {
        self.min_seconds
    }
    /// <p>The maximum value of the duration range. Must be less than or equal to 604800 seconds (1 week).</p>
    pub fn max_seconds(&self) -> i32 {
        self.max_seconds
    }
}
/// See [`DurationRange`](crate::model::DurationRange).
pub mod duration_range {

    /// A builder for [`DurationRange`](crate::model::DurationRange).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) min_seconds: std::option::Option<i32>,
        pub(crate) max_seconds: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The minimum value of the duration range. Must be greater than zero.</p>
        pub fn min_seconds(mut self, input: i32) -> Self {
            self.min_seconds = Some(input);
            self
        }
        /// <p>The minimum value of the duration range. Must be greater than zero.</p>
        pub fn set_min_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.min_seconds = input;
            self
        }
        /// <p>The maximum value of the duration range. Must be less than or equal to 604800 seconds (1 week).</p>
        pub fn max_seconds(mut self, input: i32) -> Self {
            self.max_seconds = Some(input);
            self
        }
        /// <p>The maximum value of the duration range. Must be less than or equal to 604800 seconds (1 week).</p>
        pub fn set_max_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.max_seconds = input;
            self
        }
        /// Consumes the builder and constructs a [`DurationRange`](crate::model::DurationRange).
        pub fn build(self) -> crate::model::DurationRange {
            crate::model::DurationRange {
                min_seconds: self.min_seconds.unwrap_or_default(),
                max_seconds: self.max_seconds.unwrap_or_default(),
            }
        }
    }
}
impl DurationRange {
    /// Creates a new builder-style object to manufacture [`DurationRange`](crate::model::DurationRange).
    pub fn builder() -> crate::model::duration_range::Builder {
        crate::model::duration_range::Builder::default()
    }
}

/// <p>Used as the request parameter in the <code>ListAssessmentTargets</code> action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssessmentTargetFilter {
    /// <p>For a record to match a filter, an explicit value or a string that contains a wildcard that is specified for this data type property must match the value of the <b>assessmentTargetName</b> property of the <code>AssessmentTarget</code> data type.</p>
    #[doc(hidden)]
    pub assessment_target_name_pattern: std::option::Option<std::string::String>,
}
impl AssessmentTargetFilter {
    /// <p>For a record to match a filter, an explicit value or a string that contains a wildcard that is specified for this data type property must match the value of the <b>assessmentTargetName</b> property of the <code>AssessmentTarget</code> data type.</p>
    pub fn assessment_target_name_pattern(&self) -> std::option::Option<&str> {
        self.assessment_target_name_pattern.as_deref()
    }
}
/// See [`AssessmentTargetFilter`](crate::model::AssessmentTargetFilter).
pub mod assessment_target_filter {

    /// A builder for [`AssessmentTargetFilter`](crate::model::AssessmentTargetFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_target_name_pattern: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>For a record to match a filter, an explicit value or a string that contains a wildcard that is specified for this data type property must match the value of the <b>assessmentTargetName</b> property of the <code>AssessmentTarget</code> data type.</p>
        pub fn assessment_target_name_pattern(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.assessment_target_name_pattern = Some(input.into());
            self
        }
        /// <p>For a record to match a filter, an explicit value or a string that contains a wildcard that is specified for this data type property must match the value of the <b>assessmentTargetName</b> property of the <code>AssessmentTarget</code> data type.</p>
        pub fn set_assessment_target_name_pattern(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_target_name_pattern = input;
            self
        }
        /// Consumes the builder and constructs a [`AssessmentTargetFilter`](crate::model::AssessmentTargetFilter).
        pub fn build(self) -> crate::model::AssessmentTargetFilter {
            crate::model::AssessmentTargetFilter {
                assessment_target_name_pattern: self.assessment_target_name_pattern,
            }
        }
    }
}
impl AssessmentTargetFilter {
    /// Creates a new builder-style object to manufacture [`AssessmentTargetFilter`](crate::model::AssessmentTargetFilter).
    pub fn builder() -> crate::model::assessment_target_filter::Builder {
        crate::model::assessment_target_filter::Builder::default()
    }
}

/// <p>Used as the request parameter in the <code>ListAssessmentRuns</code> action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssessmentRunFilter {
    /// <p>For a record to match a filter, an explicit value or a string containing a wildcard that is specified for this data type property must match the value of the <b>assessmentRunName</b> property of the <code>AssessmentRun</code> data type.</p>
    #[doc(hidden)]
    pub name_pattern: std::option::Option<std::string::String>,
    /// <p>For a record to match a filter, one of the values specified for this data type property must be the exact match of the value of the <b>assessmentRunState</b> property of the <code>AssessmentRun</code> data type.</p>
    #[doc(hidden)]
    pub states: std::option::Option<std::vec::Vec<crate::model::AssessmentRunState>>,
    /// <p>For a record to match a filter, the value that is specified for this data type property must inclusively match any value between the specified minimum and maximum values of the <b>durationInSeconds</b> property of the <code>AssessmentRun</code> data type.</p>
    #[doc(hidden)]
    pub duration_range: std::option::Option<crate::model::DurationRange>,
    /// <p>For a record to match a filter, the value that is specified for this data type property must be contained in the list of values of the <b>rulesPackages</b> property of the <code>AssessmentRun</code> data type.</p>
    #[doc(hidden)]
    pub rules_package_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>For a record to match a filter, the value that is specified for this data type property must inclusively match any value between the specified minimum and maximum values of the <b>startTime</b> property of the <code>AssessmentRun</code> data type.</p>
    #[doc(hidden)]
    pub start_time_range: std::option::Option<crate::model::TimestampRange>,
    /// <p>For a record to match a filter, the value that is specified for this data type property must inclusively match any value between the specified minimum and maximum values of the <b>completedAt</b> property of the <code>AssessmentRun</code> data type.</p>
    #[doc(hidden)]
    pub completion_time_range: std::option::Option<crate::model::TimestampRange>,
    /// <p>For a record to match a filter, the value that is specified for this data type property must match the <b>stateChangedAt</b> property of the <code>AssessmentRun</code> data type.</p>
    #[doc(hidden)]
    pub state_change_time_range: std::option::Option<crate::model::TimestampRange>,
}
impl AssessmentRunFilter {
    /// <p>For a record to match a filter, an explicit value or a string containing a wildcard that is specified for this data type property must match the value of the <b>assessmentRunName</b> property of the <code>AssessmentRun</code> data type.</p>
    pub fn name_pattern(&self) -> std::option::Option<&str> {
        self.name_pattern.as_deref()
    }
    /// <p>For a record to match a filter, one of the values specified for this data type property must be the exact match of the value of the <b>assessmentRunState</b> property of the <code>AssessmentRun</code> data type.</p>
    pub fn states(&self) -> std::option::Option<&[crate::model::AssessmentRunState]> {
        self.states.as_deref()
    }
    /// <p>For a record to match a filter, the value that is specified for this data type property must inclusively match any value between the specified minimum and maximum values of the <b>durationInSeconds</b> property of the <code>AssessmentRun</code> data type.</p>
    pub fn duration_range(&self) -> std::option::Option<&crate::model::DurationRange> {
        self.duration_range.as_ref()
    }
    /// <p>For a record to match a filter, the value that is specified for this data type property must be contained in the list of values of the <b>rulesPackages</b> property of the <code>AssessmentRun</code> data type.</p>
    pub fn rules_package_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.rules_package_arns.as_deref()
    }
    /// <p>For a record to match a filter, the value that is specified for this data type property must inclusively match any value between the specified minimum and maximum values of the <b>startTime</b> property of the <code>AssessmentRun</code> data type.</p>
    pub fn start_time_range(&self) -> std::option::Option<&crate::model::TimestampRange> {
        self.start_time_range.as_ref()
    }
    /// <p>For a record to match a filter, the value that is specified for this data type property must inclusively match any value between the specified minimum and maximum values of the <b>completedAt</b> property of the <code>AssessmentRun</code> data type.</p>
    pub fn completion_time_range(&self) -> std::option::Option<&crate::model::TimestampRange> {
        self.completion_time_range.as_ref()
    }
    /// <p>For a record to match a filter, the value that is specified for this data type property must match the <b>stateChangedAt</b> property of the <code>AssessmentRun</code> data type.</p>
    pub fn state_change_time_range(&self) -> std::option::Option<&crate::model::TimestampRange> {
        self.state_change_time_range.as_ref()
    }
}
/// See [`AssessmentRunFilter`](crate::model::AssessmentRunFilter).
pub mod assessment_run_filter {

    /// A builder for [`AssessmentRunFilter`](crate::model::AssessmentRunFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name_pattern: std::option::Option<std::string::String>,
        pub(crate) states: std::option::Option<std::vec::Vec<crate::model::AssessmentRunState>>,
        pub(crate) duration_range: std::option::Option<crate::model::DurationRange>,
        pub(crate) rules_package_arns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) start_time_range: std::option::Option<crate::model::TimestampRange>,
        pub(crate) completion_time_range: std::option::Option<crate::model::TimestampRange>,
        pub(crate) state_change_time_range: std::option::Option<crate::model::TimestampRange>,
    }
    impl Builder {
        /// <p>For a record to match a filter, an explicit value or a string containing a wildcard that is specified for this data type property must match the value of the <b>assessmentRunName</b> property of the <code>AssessmentRun</code> data type.</p>
        pub fn name_pattern(mut self, input: impl Into<std::string::String>) -> Self {
            self.name_pattern = Some(input.into());
            self
        }
        /// <p>For a record to match a filter, an explicit value or a string containing a wildcard that is specified for this data type property must match the value of the <b>assessmentRunName</b> property of the <code>AssessmentRun</code> data type.</p>
        pub fn set_name_pattern(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name_pattern = input;
            self
        }
        /// Appends an item to `states`.
        ///
        /// To override the contents of this collection use [`set_states`](Self::set_states).
        ///
        /// <p>For a record to match a filter, one of the values specified for this data type property must be the exact match of the value of the <b>assessmentRunState</b> property of the <code>AssessmentRun</code> data type.</p>
        pub fn states(mut self, input: crate::model::AssessmentRunState) -> Self {
            let mut v = self.states.unwrap_or_default();
            v.push(input);
            self.states = Some(v);
            self
        }
        /// <p>For a record to match a filter, one of the values specified for this data type property must be the exact match of the value of the <b>assessmentRunState</b> property of the <code>AssessmentRun</code> data type.</p>
        pub fn set_states(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AssessmentRunState>>,
        ) -> Self {
            self.states = input;
            self
        }
        /// <p>For a record to match a filter, the value that is specified for this data type property must inclusively match any value between the specified minimum and maximum values of the <b>durationInSeconds</b> property of the <code>AssessmentRun</code> data type.</p>
        pub fn duration_range(mut self, input: crate::model::DurationRange) -> Self {
            self.duration_range = Some(input);
            self
        }
        /// <p>For a record to match a filter, the value that is specified for this data type property must inclusively match any value between the specified minimum and maximum values of the <b>durationInSeconds</b> property of the <code>AssessmentRun</code> data type.</p>
        pub fn set_duration_range(
            mut self,
            input: std::option::Option<crate::model::DurationRange>,
        ) -> Self {
            self.duration_range = input;
            self
        }
        /// Appends an item to `rules_package_arns`.
        ///
        /// To override the contents of this collection use [`set_rules_package_arns`](Self::set_rules_package_arns).
        ///
        /// <p>For a record to match a filter, the value that is specified for this data type property must be contained in the list of values of the <b>rulesPackages</b> property of the <code>AssessmentRun</code> data type.</p>
        pub fn rules_package_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.rules_package_arns.unwrap_or_default();
            v.push(input.into());
            self.rules_package_arns = Some(v);
            self
        }
        /// <p>For a record to match a filter, the value that is specified for this data type property must be contained in the list of values of the <b>rulesPackages</b> property of the <code>AssessmentRun</code> data type.</p>
        pub fn set_rules_package_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.rules_package_arns = input;
            self
        }
        /// <p>For a record to match a filter, the value that is specified for this data type property must inclusively match any value between the specified minimum and maximum values of the <b>startTime</b> property of the <code>AssessmentRun</code> data type.</p>
        pub fn start_time_range(mut self, input: crate::model::TimestampRange) -> Self {
            self.start_time_range = Some(input);
            self
        }
        /// <p>For a record to match a filter, the value that is specified for this data type property must inclusively match any value between the specified minimum and maximum values of the <b>startTime</b> property of the <code>AssessmentRun</code> data type.</p>
        pub fn set_start_time_range(
            mut self,
            input: std::option::Option<crate::model::TimestampRange>,
        ) -> Self {
            self.start_time_range = input;
            self
        }
        /// <p>For a record to match a filter, the value that is specified for this data type property must inclusively match any value between the specified minimum and maximum values of the <b>completedAt</b> property of the <code>AssessmentRun</code> data type.</p>
        pub fn completion_time_range(mut self, input: crate::model::TimestampRange) -> Self {
            self.completion_time_range = Some(input);
            self
        }
        /// <p>For a record to match a filter, the value that is specified for this data type property must inclusively match any value between the specified minimum and maximum values of the <b>completedAt</b> property of the <code>AssessmentRun</code> data type.</p>
        pub fn set_completion_time_range(
            mut self,
            input: std::option::Option<crate::model::TimestampRange>,
        ) -> Self {
            self.completion_time_range = input;
            self
        }
        /// <p>For a record to match a filter, the value that is specified for this data type property must match the <b>stateChangedAt</b> property of the <code>AssessmentRun</code> data type.</p>
        pub fn state_change_time_range(mut self, input: crate::model::TimestampRange) -> Self {
            self.state_change_time_range = Some(input);
            self
        }
        /// <p>For a record to match a filter, the value that is specified for this data type property must match the <b>stateChangedAt</b> property of the <code>AssessmentRun</code> data type.</p>
        pub fn set_state_change_time_range(
            mut self,
            input: std::option::Option<crate::model::TimestampRange>,
        ) -> Self {
            self.state_change_time_range = input;
            self
        }
        /// Consumes the builder and constructs a [`AssessmentRunFilter`](crate::model::AssessmentRunFilter).
        pub fn build(self) -> crate::model::AssessmentRunFilter {
            crate::model::AssessmentRunFilter {
                name_pattern: self.name_pattern,
                states: self.states,
                duration_range: self.duration_range,
                rules_package_arns: self.rules_package_arns,
                start_time_range: self.start_time_range,
                completion_time_range: self.completion_time_range,
                state_change_time_range: self.state_change_time_range,
            }
        }
    }
}
impl AssessmentRunFilter {
    /// Creates a new builder-style object to manufacture [`AssessmentRunFilter`](crate::model::AssessmentRunFilter).
    pub fn builder() -> crate::model::assessment_run_filter::Builder {
        crate::model::assessment_run_filter::Builder::default()
    }
}

/// When writing a match expression against `AssessmentRunState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let assessmentrunstate = unimplemented!();
/// match assessmentrunstate {
///     AssessmentRunState::Canceled => { /* ... */ },
///     AssessmentRunState::CollectingData => { /* ... */ },
///     AssessmentRunState::Completed => { /* ... */ },
///     AssessmentRunState::CompletedWithErrors => { /* ... */ },
///     AssessmentRunState::Created => { /* ... */ },
///     AssessmentRunState::DataCollected => { /* ... */ },
///     AssessmentRunState::Error => { /* ... */ },
///     AssessmentRunState::EvaluatingRules => { /* ... */ },
///     AssessmentRunState::Failed => { /* ... */ },
///     AssessmentRunState::StartDataCollectionInProgress => { /* ... */ },
///     AssessmentRunState::StartDataCollectionPending => { /* ... */ },
///     AssessmentRunState::StartEvaluatingRulesPending => { /* ... */ },
///     AssessmentRunState::StopDataCollectionPending => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `assessmentrunstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AssessmentRunState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AssessmentRunState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AssessmentRunState::NewFeature` is defined.
/// Specifically, when `assessmentrunstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AssessmentRunState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AssessmentRunState {
    #[allow(missing_docs)] // documentation missing in model
    Canceled,
    #[allow(missing_docs)] // documentation missing in model
    CollectingData,
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    CompletedWithErrors,
    #[allow(missing_docs)] // documentation missing in model
    Created,
    #[allow(missing_docs)] // documentation missing in model
    DataCollected,
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    EvaluatingRules,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    StartDataCollectionInProgress,
    #[allow(missing_docs)] // documentation missing in model
    StartDataCollectionPending,
    #[allow(missing_docs)] // documentation missing in model
    StartEvaluatingRulesPending,
    #[allow(missing_docs)] // documentation missing in model
    StopDataCollectionPending,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AssessmentRunState {
    fn from(s: &str) -> Self {
        match s {
            "CANCELED" => AssessmentRunState::Canceled,
            "COLLECTING_DATA" => AssessmentRunState::CollectingData,
            "COMPLETED" => AssessmentRunState::Completed,
            "COMPLETED_WITH_ERRORS" => AssessmentRunState::CompletedWithErrors,
            "CREATED" => AssessmentRunState::Created,
            "DATA_COLLECTED" => AssessmentRunState::DataCollected,
            "ERROR" => AssessmentRunState::Error,
            "EVALUATING_RULES" => AssessmentRunState::EvaluatingRules,
            "FAILED" => AssessmentRunState::Failed,
            "START_DATA_COLLECTION_IN_PROGRESS" => {
                AssessmentRunState::StartDataCollectionInProgress
            }
            "START_DATA_COLLECTION_PENDING" => AssessmentRunState::StartDataCollectionPending,
            "START_EVALUATING_RULES_PENDING" => AssessmentRunState::StartEvaluatingRulesPending,
            "STOP_DATA_COLLECTION_PENDING" => AssessmentRunState::StopDataCollectionPending,
            other => {
                AssessmentRunState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for AssessmentRunState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AssessmentRunState::from(s))
    }
}
impl AssessmentRunState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AssessmentRunState::Canceled => "CANCELED",
            AssessmentRunState::CollectingData => "COLLECTING_DATA",
            AssessmentRunState::Completed => "COMPLETED",
            AssessmentRunState::CompletedWithErrors => "COMPLETED_WITH_ERRORS",
            AssessmentRunState::Created => "CREATED",
            AssessmentRunState::DataCollected => "DATA_COLLECTED",
            AssessmentRunState::Error => "ERROR",
            AssessmentRunState::EvaluatingRules => "EVALUATING_RULES",
            AssessmentRunState::Failed => "FAILED",
            AssessmentRunState::StartDataCollectionInProgress => {
                "START_DATA_COLLECTION_IN_PROGRESS"
            }
            AssessmentRunState::StartDataCollectionPending => "START_DATA_COLLECTION_PENDING",
            AssessmentRunState::StartEvaluatingRulesPending => "START_EVALUATING_RULES_PENDING",
            AssessmentRunState::StopDataCollectionPending => "STOP_DATA_COLLECTION_PENDING",
            AssessmentRunState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CANCELED",
            "COLLECTING_DATA",
            "COMPLETED",
            "COMPLETED_WITH_ERRORS",
            "CREATED",
            "DATA_COLLECTED",
            "ERROR",
            "EVALUATING_RULES",
            "FAILED",
            "START_DATA_COLLECTION_IN_PROGRESS",
            "START_DATA_COLLECTION_PENDING",
            "START_EVALUATING_RULES_PENDING",
            "STOP_DATA_COLLECTION_PENDING",
        ]
    }
}
impl AsRef<str> for AssessmentRunState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about an Amazon Inspector agent. This data type is used as a response element in the <code>ListAssessmentRunAgents</code> action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssessmentRunAgent {
    /// <p>The AWS account of the EC2 instance where the agent is installed.</p>
    #[doc(hidden)]
    pub agent_id: std::option::Option<std::string::String>,
    /// <p>The ARN of the assessment run that is associated with the agent.</p>
    #[doc(hidden)]
    pub assessment_run_arn: std::option::Option<std::string::String>,
    /// <p>The current health state of the agent.</p>
    #[doc(hidden)]
    pub agent_health: std::option::Option<crate::model::AgentHealth>,
    /// <p>The detailed health state of the agent.</p>
    #[doc(hidden)]
    pub agent_health_code: std::option::Option<crate::model::AgentHealthCode>,
    /// <p>The description for the agent health code.</p>
    #[doc(hidden)]
    pub agent_health_details: std::option::Option<std::string::String>,
    /// <p>The Auto Scaling group of the EC2 instance that is specified by the agent ID.</p>
    #[doc(hidden)]
    pub auto_scaling_group: std::option::Option<std::string::String>,
    /// <p>The Amazon Inspector application data metrics that are collected by the agent.</p>
    #[doc(hidden)]
    pub telemetry_metadata: std::option::Option<std::vec::Vec<crate::model::TelemetryMetadata>>,
}
impl AssessmentRunAgent {
    /// <p>The AWS account of the EC2 instance where the agent is installed.</p>
    pub fn agent_id(&self) -> std::option::Option<&str> {
        self.agent_id.as_deref()
    }
    /// <p>The ARN of the assessment run that is associated with the agent.</p>
    pub fn assessment_run_arn(&self) -> std::option::Option<&str> {
        self.assessment_run_arn.as_deref()
    }
    /// <p>The current health state of the agent.</p>
    pub fn agent_health(&self) -> std::option::Option<&crate::model::AgentHealth> {
        self.agent_health.as_ref()
    }
    /// <p>The detailed health state of the agent.</p>
    pub fn agent_health_code(&self) -> std::option::Option<&crate::model::AgentHealthCode> {
        self.agent_health_code.as_ref()
    }
    /// <p>The description for the agent health code.</p>
    pub fn agent_health_details(&self) -> std::option::Option<&str> {
        self.agent_health_details.as_deref()
    }
    /// <p>The Auto Scaling group of the EC2 instance that is specified by the agent ID.</p>
    pub fn auto_scaling_group(&self) -> std::option::Option<&str> {
        self.auto_scaling_group.as_deref()
    }
    /// <p>The Amazon Inspector application data metrics that are collected by the agent.</p>
    pub fn telemetry_metadata(&self) -> std::option::Option<&[crate::model::TelemetryMetadata]> {
        self.telemetry_metadata.as_deref()
    }
}
/// See [`AssessmentRunAgent`](crate::model::AssessmentRunAgent).
pub mod assessment_run_agent {

    /// A builder for [`AssessmentRunAgent`](crate::model::AssessmentRunAgent).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) agent_id: std::option::Option<std::string::String>,
        pub(crate) assessment_run_arn: std::option::Option<std::string::String>,
        pub(crate) agent_health: std::option::Option<crate::model::AgentHealth>,
        pub(crate) agent_health_code: std::option::Option<crate::model::AgentHealthCode>,
        pub(crate) agent_health_details: std::option::Option<std::string::String>,
        pub(crate) auto_scaling_group: std::option::Option<std::string::String>,
        pub(crate) telemetry_metadata:
            std::option::Option<std::vec::Vec<crate::model::TelemetryMetadata>>,
    }
    impl Builder {
        /// <p>The AWS account of the EC2 instance where the agent is installed.</p>
        pub fn agent_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.agent_id = Some(input.into());
            self
        }
        /// <p>The AWS account of the EC2 instance where the agent is installed.</p>
        pub fn set_agent_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.agent_id = input;
            self
        }
        /// <p>The ARN of the assessment run that is associated with the agent.</p>
        pub fn assessment_run_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_run_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the assessment run that is associated with the agent.</p>
        pub fn set_assessment_run_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_run_arn = input;
            self
        }
        /// <p>The current health state of the agent.</p>
        pub fn agent_health(mut self, input: crate::model::AgentHealth) -> Self {
            self.agent_health = Some(input);
            self
        }
        /// <p>The current health state of the agent.</p>
        pub fn set_agent_health(
            mut self,
            input: std::option::Option<crate::model::AgentHealth>,
        ) -> Self {
            self.agent_health = input;
            self
        }
        /// <p>The detailed health state of the agent.</p>
        pub fn agent_health_code(mut self, input: crate::model::AgentHealthCode) -> Self {
            self.agent_health_code = Some(input);
            self
        }
        /// <p>The detailed health state of the agent.</p>
        pub fn set_agent_health_code(
            mut self,
            input: std::option::Option<crate::model::AgentHealthCode>,
        ) -> Self {
            self.agent_health_code = input;
            self
        }
        /// <p>The description for the agent health code.</p>
        pub fn agent_health_details(mut self, input: impl Into<std::string::String>) -> Self {
            self.agent_health_details = Some(input.into());
            self
        }
        /// <p>The description for the agent health code.</p>
        pub fn set_agent_health_details(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.agent_health_details = input;
            self
        }
        /// <p>The Auto Scaling group of the EC2 instance that is specified by the agent ID.</p>
        pub fn auto_scaling_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.auto_scaling_group = Some(input.into());
            self
        }
        /// <p>The Auto Scaling group of the EC2 instance that is specified by the agent ID.</p>
        pub fn set_auto_scaling_group(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.auto_scaling_group = input;
            self
        }
        /// Appends an item to `telemetry_metadata`.
        ///
        /// To override the contents of this collection use [`set_telemetry_metadata`](Self::set_telemetry_metadata).
        ///
        /// <p>The Amazon Inspector application data metrics that are collected by the agent.</p>
        pub fn telemetry_metadata(mut self, input: crate::model::TelemetryMetadata) -> Self {
            let mut v = self.telemetry_metadata.unwrap_or_default();
            v.push(input);
            self.telemetry_metadata = Some(v);
            self
        }
        /// <p>The Amazon Inspector application data metrics that are collected by the agent.</p>
        pub fn set_telemetry_metadata(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TelemetryMetadata>>,
        ) -> Self {
            self.telemetry_metadata = input;
            self
        }
        /// Consumes the builder and constructs a [`AssessmentRunAgent`](crate::model::AssessmentRunAgent).
        pub fn build(self) -> crate::model::AssessmentRunAgent {
            crate::model::AssessmentRunAgent {
                agent_id: self.agent_id,
                assessment_run_arn: self.assessment_run_arn,
                agent_health: self.agent_health,
                agent_health_code: self.agent_health_code,
                agent_health_details: self.agent_health_details,
                auto_scaling_group: self.auto_scaling_group,
                telemetry_metadata: self.telemetry_metadata,
            }
        }
    }
}
impl AssessmentRunAgent {
    /// Creates a new builder-style object to manufacture [`AssessmentRunAgent`](crate::model::AssessmentRunAgent).
    pub fn builder() -> crate::model::assessment_run_agent::Builder {
        crate::model::assessment_run_agent::Builder::default()
    }
}

/// <p>The metadata about the Amazon Inspector application data metrics collected by the agent. This data type is used as the response element in the <code>GetTelemetryMetadata</code> action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TelemetryMetadata {
    /// <p>A specific type of behavioral data that is collected by the agent.</p>
    #[doc(hidden)]
    pub message_type: std::option::Option<std::string::String>,
    /// <p>The count of messages that the agent sends to the Amazon Inspector service.</p>
    #[doc(hidden)]
    pub count: std::option::Option<i64>,
    /// <p>The data size of messages that the agent sends to the Amazon Inspector service.</p>
    #[doc(hidden)]
    pub data_size: std::option::Option<i64>,
}
impl TelemetryMetadata {
    /// <p>A specific type of behavioral data that is collected by the agent.</p>
    pub fn message_type(&self) -> std::option::Option<&str> {
        self.message_type.as_deref()
    }
    /// <p>The count of messages that the agent sends to the Amazon Inspector service.</p>
    pub fn count(&self) -> std::option::Option<i64> {
        self.count
    }
    /// <p>The data size of messages that the agent sends to the Amazon Inspector service.</p>
    pub fn data_size(&self) -> std::option::Option<i64> {
        self.data_size
    }
}
/// See [`TelemetryMetadata`](crate::model::TelemetryMetadata).
pub mod telemetry_metadata {

    /// A builder for [`TelemetryMetadata`](crate::model::TelemetryMetadata).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message_type: std::option::Option<std::string::String>,
        pub(crate) count: std::option::Option<i64>,
        pub(crate) data_size: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>A specific type of behavioral data that is collected by the agent.</p>
        pub fn message_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.message_type = Some(input.into());
            self
        }
        /// <p>A specific type of behavioral data that is collected by the agent.</p>
        pub fn set_message_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message_type = input;
            self
        }
        /// <p>The count of messages that the agent sends to the Amazon Inspector service.</p>
        pub fn count(mut self, input: i64) -> Self {
            self.count = Some(input);
            self
        }
        /// <p>The count of messages that the agent sends to the Amazon Inspector service.</p>
        pub fn set_count(mut self, input: std::option::Option<i64>) -> Self {
            self.count = input;
            self
        }
        /// <p>The data size of messages that the agent sends to the Amazon Inspector service.</p>
        pub fn data_size(mut self, input: i64) -> Self {
            self.data_size = Some(input);
            self
        }
        /// <p>The data size of messages that the agent sends to the Amazon Inspector service.</p>
        pub fn set_data_size(mut self, input: std::option::Option<i64>) -> Self {
            self.data_size = input;
            self
        }
        /// Consumes the builder and constructs a [`TelemetryMetadata`](crate::model::TelemetryMetadata).
        pub fn build(self) -> crate::model::TelemetryMetadata {
            crate::model::TelemetryMetadata {
                message_type: self.message_type,
                count: self.count,
                data_size: self.data_size,
            }
        }
    }
}
impl TelemetryMetadata {
    /// Creates a new builder-style object to manufacture [`TelemetryMetadata`](crate::model::TelemetryMetadata).
    pub fn builder() -> crate::model::telemetry_metadata::Builder {
        crate::model::telemetry_metadata::Builder::default()
    }
}

/// When writing a match expression against `AgentHealthCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let agenthealthcode = unimplemented!();
/// match agenthealthcode {
///     AgentHealthCode::Idle => { /* ... */ },
///     AgentHealthCode::Running => { /* ... */ },
///     AgentHealthCode::Shutdown => { /* ... */ },
///     AgentHealthCode::Throttled => { /* ... */ },
///     AgentHealthCode::Unhealthy => { /* ... */ },
///     AgentHealthCode::UnknownValue => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `agenthealthcode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AgentHealthCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AgentHealthCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AgentHealthCode::NewFeature` is defined.
/// Specifically, when `agenthealthcode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AgentHealthCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// _Note: `AgentHealthCode::Unknown` has been renamed to `::UnknownValue`._
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AgentHealthCode {
    #[allow(missing_docs)] // documentation missing in model
    Idle,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    #[allow(missing_docs)] // documentation missing in model
    Shutdown,
    #[allow(missing_docs)] // documentation missing in model
    Throttled,
    #[allow(missing_docs)] // documentation missing in model
    Unhealthy,
    /// _Note: `::Unknown` has been renamed to `::UnknownValue`._
    UnknownValue,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AgentHealthCode {
    fn from(s: &str) -> Self {
        match s {
            "IDLE" => AgentHealthCode::Idle,
            "RUNNING" => AgentHealthCode::Running,
            "SHUTDOWN" => AgentHealthCode::Shutdown,
            "THROTTLED" => AgentHealthCode::Throttled,
            "UNHEALTHY" => AgentHealthCode::Unhealthy,
            "UNKNOWN" => AgentHealthCode::UnknownValue,
            other => AgentHealthCode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AgentHealthCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AgentHealthCode::from(s))
    }
}
impl AgentHealthCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AgentHealthCode::Idle => "IDLE",
            AgentHealthCode::Running => "RUNNING",
            AgentHealthCode::Shutdown => "SHUTDOWN",
            AgentHealthCode::Throttled => "THROTTLED",
            AgentHealthCode::Unhealthy => "UNHEALTHY",
            AgentHealthCode::UnknownValue => "UNKNOWN",
            AgentHealthCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "IDLE",
            "RUNNING",
            "SHUTDOWN",
            "THROTTLED",
            "UNHEALTHY",
            "UNKNOWN",
        ]
    }
}
impl AsRef<str> for AgentHealthCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about an Amazon Inspector agent. This data type is used as a request parameter in the <code>ListAssessmentRunAgents</code> action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AgentFilter {
    /// <p>The current health state of the agent. Values can be set to <b>HEALTHY</b> or <b>UNHEALTHY</b>.</p>
    #[doc(hidden)]
    pub agent_healths: std::option::Option<std::vec::Vec<crate::model::AgentHealth>>,
    /// <p>The detailed health state of the agent. Values can be set to <b>IDLE</b>, <b>RUNNING</b>, <b>SHUTDOWN</b>, <b>UNHEALTHY</b>, <b>THROTTLED</b>, and <b>UNKNOWN</b>. </p>
    #[doc(hidden)]
    pub agent_health_codes: std::option::Option<std::vec::Vec<crate::model::AgentHealthCode>>,
}
impl AgentFilter {
    /// <p>The current health state of the agent. Values can be set to <b>HEALTHY</b> or <b>UNHEALTHY</b>.</p>
    pub fn agent_healths(&self) -> std::option::Option<&[crate::model::AgentHealth]> {
        self.agent_healths.as_deref()
    }
    /// <p>The detailed health state of the agent. Values can be set to <b>IDLE</b>, <b>RUNNING</b>, <b>SHUTDOWN</b>, <b>UNHEALTHY</b>, <b>THROTTLED</b>, and <b>UNKNOWN</b>. </p>
    pub fn agent_health_codes(&self) -> std::option::Option<&[crate::model::AgentHealthCode]> {
        self.agent_health_codes.as_deref()
    }
}
/// See [`AgentFilter`](crate::model::AgentFilter).
pub mod agent_filter {

    /// A builder for [`AgentFilter`](crate::model::AgentFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) agent_healths: std::option::Option<std::vec::Vec<crate::model::AgentHealth>>,
        pub(crate) agent_health_codes:
            std::option::Option<std::vec::Vec<crate::model::AgentHealthCode>>,
    }
    impl Builder {
        /// Appends an item to `agent_healths`.
        ///
        /// To override the contents of this collection use [`set_agent_healths`](Self::set_agent_healths).
        ///
        /// <p>The current health state of the agent. Values can be set to <b>HEALTHY</b> or <b>UNHEALTHY</b>.</p>
        pub fn agent_healths(mut self, input: crate::model::AgentHealth) -> Self {
            let mut v = self.agent_healths.unwrap_or_default();
            v.push(input);
            self.agent_healths = Some(v);
            self
        }
        /// <p>The current health state of the agent. Values can be set to <b>HEALTHY</b> or <b>UNHEALTHY</b>.</p>
        pub fn set_agent_healths(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AgentHealth>>,
        ) -> Self {
            self.agent_healths = input;
            self
        }
        /// Appends an item to `agent_health_codes`.
        ///
        /// To override the contents of this collection use [`set_agent_health_codes`](Self::set_agent_health_codes).
        ///
        /// <p>The detailed health state of the agent. Values can be set to <b>IDLE</b>, <b>RUNNING</b>, <b>SHUTDOWN</b>, <b>UNHEALTHY</b>, <b>THROTTLED</b>, and <b>UNKNOWN</b>. </p>
        pub fn agent_health_codes(mut self, input: crate::model::AgentHealthCode) -> Self {
            let mut v = self.agent_health_codes.unwrap_or_default();
            v.push(input);
            self.agent_health_codes = Some(v);
            self
        }
        /// <p>The detailed health state of the agent. Values can be set to <b>IDLE</b>, <b>RUNNING</b>, <b>SHUTDOWN</b>, <b>UNHEALTHY</b>, <b>THROTTLED</b>, and <b>UNKNOWN</b>. </p>
        pub fn set_agent_health_codes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AgentHealthCode>>,
        ) -> Self {
            self.agent_health_codes = input;
            self
        }
        /// Consumes the builder and constructs a [`AgentFilter`](crate::model::AgentFilter).
        pub fn build(self) -> crate::model::AgentFilter {
            crate::model::AgentFilter {
                agent_healths: self.agent_healths,
                agent_health_codes: self.agent_health_codes,
            }
        }
    }
}
impl AgentFilter {
    /// Creates a new builder-style object to manufacture [`AgentFilter`](crate::model::AgentFilter).
    pub fn builder() -> crate::model::agent_filter::Builder {
        crate::model::agent_filter::Builder::default()
    }
}

/// <p>Contains information about what is excluded from an assessment run given the current state of the assessment template.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExclusionPreview {
    /// <p>The name of the exclusion preview.</p>
    #[doc(hidden)]
    pub title: std::option::Option<std::string::String>,
    /// <p>The description of the exclusion preview.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The recommendation for the exclusion preview.</p>
    #[doc(hidden)]
    pub recommendation: std::option::Option<std::string::String>,
    /// <p>The AWS resources for which the exclusion preview pertains.</p>
    #[doc(hidden)]
    pub scopes: std::option::Option<std::vec::Vec<crate::model::Scope>>,
    /// <p>The system-defined attributes for the exclusion preview.</p>
    #[doc(hidden)]
    pub attributes: std::option::Option<std::vec::Vec<crate::model::Attribute>>,
}
impl ExclusionPreview {
    /// <p>The name of the exclusion preview.</p>
    pub fn title(&self) -> std::option::Option<&str> {
        self.title.as_deref()
    }
    /// <p>The description of the exclusion preview.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The recommendation for the exclusion preview.</p>
    pub fn recommendation(&self) -> std::option::Option<&str> {
        self.recommendation.as_deref()
    }
    /// <p>The AWS resources for which the exclusion preview pertains.</p>
    pub fn scopes(&self) -> std::option::Option<&[crate::model::Scope]> {
        self.scopes.as_deref()
    }
    /// <p>The system-defined attributes for the exclusion preview.</p>
    pub fn attributes(&self) -> std::option::Option<&[crate::model::Attribute]> {
        self.attributes.as_deref()
    }
}
/// See [`ExclusionPreview`](crate::model::ExclusionPreview).
pub mod exclusion_preview {

    /// A builder for [`ExclusionPreview`](crate::model::ExclusionPreview).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) recommendation: std::option::Option<std::string::String>,
        pub(crate) scopes: std::option::Option<std::vec::Vec<crate::model::Scope>>,
        pub(crate) attributes: std::option::Option<std::vec::Vec<crate::model::Attribute>>,
    }
    impl Builder {
        /// <p>The name of the exclusion preview.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>The name of the exclusion preview.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The description of the exclusion preview.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the exclusion preview.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The recommendation for the exclusion preview.</p>
        pub fn recommendation(mut self, input: impl Into<std::string::String>) -> Self {
            self.recommendation = Some(input.into());
            self
        }
        /// <p>The recommendation for the exclusion preview.</p>
        pub fn set_recommendation(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recommendation = input;
            self
        }
        /// Appends an item to `scopes`.
        ///
        /// To override the contents of this collection use [`set_scopes`](Self::set_scopes).
        ///
        /// <p>The AWS resources for which the exclusion preview pertains.</p>
        pub fn scopes(mut self, input: crate::model::Scope) -> Self {
            let mut v = self.scopes.unwrap_or_default();
            v.push(input);
            self.scopes = Some(v);
            self
        }
        /// <p>The AWS resources for which the exclusion preview pertains.</p>
        pub fn set_scopes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Scope>>,
        ) -> Self {
            self.scopes = input;
            self
        }
        /// Appends an item to `attributes`.
        ///
        /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
        ///
        /// <p>The system-defined attributes for the exclusion preview.</p>
        pub fn attributes(mut self, input: crate::model::Attribute) -> Self {
            let mut v = self.attributes.unwrap_or_default();
            v.push(input);
            self.attributes = Some(v);
            self
        }
        /// <p>The system-defined attributes for the exclusion preview.</p>
        pub fn set_attributes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Attribute>>,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// Consumes the builder and constructs a [`ExclusionPreview`](crate::model::ExclusionPreview).
        pub fn build(self) -> crate::model::ExclusionPreview {
            crate::model::ExclusionPreview {
                title: self.title,
                description: self.description,
                recommendation: self.recommendation,
                scopes: self.scopes,
                attributes: self.attributes,
            }
        }
    }
}
impl ExclusionPreview {
    /// Creates a new builder-style object to manufacture [`ExclusionPreview`](crate::model::ExclusionPreview).
    pub fn builder() -> crate::model::exclusion_preview::Builder {
        crate::model::exclusion_preview::Builder::default()
    }
}

/// <p>This data type contains key-value pairs that identify various Amazon resources.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Scope {
    /// <p>The type of the scope.</p>
    #[doc(hidden)]
    pub key: std::option::Option<crate::model::ScopeType>,
    /// <p>The resource identifier for the specified scope type.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl Scope {
    /// <p>The type of the scope.</p>
    pub fn key(&self) -> std::option::Option<&crate::model::ScopeType> {
        self.key.as_ref()
    }
    /// <p>The resource identifier for the specified scope type.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`Scope`](crate::model::Scope).
pub mod scope {

    /// A builder for [`Scope`](crate::model::Scope).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<crate::model::ScopeType>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of the scope.</p>
        pub fn key(mut self, input: crate::model::ScopeType) -> Self {
            self.key = Some(input);
            self
        }
        /// <p>The type of the scope.</p>
        pub fn set_key(mut self, input: std::option::Option<crate::model::ScopeType>) -> Self {
            self.key = input;
            self
        }
        /// <p>The resource identifier for the specified scope type.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The resource identifier for the specified scope type.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Scope`](crate::model::Scope).
        pub fn build(self) -> crate::model::Scope {
            crate::model::Scope {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl Scope {
    /// Creates a new builder-style object to manufacture [`Scope`](crate::model::Scope).
    pub fn builder() -> crate::model::scope::Builder {
        crate::model::scope::Builder::default()
    }
}

/// When writing a match expression against `ScopeType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let scopetype = unimplemented!();
/// match scopetype {
///     ScopeType::InstanceId => { /* ... */ },
///     ScopeType::RulesPackageArn => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `scopetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ScopeType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ScopeType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ScopeType::NewFeature` is defined.
/// Specifically, when `scopetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ScopeType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ScopeType {
    #[allow(missing_docs)] // documentation missing in model
    InstanceId,
    #[allow(missing_docs)] // documentation missing in model
    RulesPackageArn,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ScopeType {
    fn from(s: &str) -> Self {
        match s {
            "INSTANCE_ID" => ScopeType::InstanceId,
            "RULES_PACKAGE_ARN" => ScopeType::RulesPackageArn,
            other => ScopeType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ScopeType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ScopeType::from(s))
    }
}
impl ScopeType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ScopeType::InstanceId => "INSTANCE_ID",
            ScopeType::RulesPackageArn => "RULES_PACKAGE_ARN",
            ScopeType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["INSTANCE_ID", "RULES_PACKAGE_ARN"]
    }
}
impl AsRef<str> for ScopeType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PreviewStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let previewstatus = unimplemented!();
/// match previewstatus {
///     PreviewStatus::Completed => { /* ... */ },
///     PreviewStatus::WorkInProgress => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `previewstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PreviewStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PreviewStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PreviewStatus::NewFeature` is defined.
/// Specifically, when `previewstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PreviewStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PreviewStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    WorkInProgress,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PreviewStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => PreviewStatus::Completed,
            "WORK_IN_PROGRESS" => PreviewStatus::WorkInProgress,
            other => PreviewStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PreviewStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PreviewStatus::from(s))
    }
}
impl PreviewStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PreviewStatus::Completed => "COMPLETED",
            PreviewStatus::WorkInProgress => "WORK_IN_PROGRESS",
            PreviewStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["COMPLETED", "WORK_IN_PROGRESS"]
    }
}
impl AsRef<str> for PreviewStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `Locale`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let locale = unimplemented!();
/// match locale {
///     Locale::EnUs => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `locale` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Locale::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Locale::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Locale::NewFeature` is defined.
/// Specifically, when `locale` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Locale::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Locale {
    #[allow(missing_docs)] // documentation missing in model
    EnUs,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Locale {
    fn from(s: &str) -> Self {
        match s {
            "EN_US" => Locale::EnUs,
            other => Locale::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Locale {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Locale::from(s))
    }
}
impl Locale {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Locale::EnUs => "EN_US",
            Locale::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["EN_US"]
    }
}
impl AsRef<str> for Locale {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ReportStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let reportstatus = unimplemented!();
/// match reportstatus {
///     ReportStatus::Completed => { /* ... */ },
///     ReportStatus::Failed => { /* ... */ },
///     ReportStatus::WorkInProgress => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `reportstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ReportStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ReportStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ReportStatus::NewFeature` is defined.
/// Specifically, when `reportstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ReportStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReportStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    WorkInProgress,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ReportStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => ReportStatus::Completed,
            "FAILED" => ReportStatus::Failed,
            "WORK_IN_PROGRESS" => ReportStatus::WorkInProgress,
            other => ReportStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ReportStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReportStatus::from(s))
    }
}
impl ReportStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReportStatus::Completed => "COMPLETED",
            ReportStatus::Failed => "FAILED",
            ReportStatus::WorkInProgress => "WORK_IN_PROGRESS",
            ReportStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["COMPLETED", "FAILED", "WORK_IN_PROGRESS"]
    }
}
impl AsRef<str> for ReportStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ReportType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let reporttype = unimplemented!();
/// match reporttype {
///     ReportType::Finding => { /* ... */ },
///     ReportType::Full => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `reporttype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ReportType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ReportType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ReportType::NewFeature` is defined.
/// Specifically, when `reporttype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ReportType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReportType {
    #[allow(missing_docs)] // documentation missing in model
    Finding,
    #[allow(missing_docs)] // documentation missing in model
    Full,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ReportType {
    fn from(s: &str) -> Self {
        match s {
            "FINDING" => ReportType::Finding,
            "FULL" => ReportType::Full,
            other => ReportType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ReportType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReportType::from(s))
    }
}
impl ReportType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReportType::Finding => "FINDING",
            ReportType::Full => "FULL",
            ReportType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FINDING", "FULL"]
    }
}
impl AsRef<str> for ReportType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ReportFileFormat`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let reportfileformat = unimplemented!();
/// match reportfileformat {
///     ReportFileFormat::Html => { /* ... */ },
///     ReportFileFormat::Pdf => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `reportfileformat` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ReportFileFormat::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ReportFileFormat::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ReportFileFormat::NewFeature` is defined.
/// Specifically, when `reportfileformat` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ReportFileFormat::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReportFileFormat {
    #[allow(missing_docs)] // documentation missing in model
    Html,
    #[allow(missing_docs)] // documentation missing in model
    Pdf,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ReportFileFormat {
    fn from(s: &str) -> Self {
        match s {
            "HTML" => ReportFileFormat::Html,
            "PDF" => ReportFileFormat::Pdf,
            other => ReportFileFormat::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ReportFileFormat {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReportFileFormat::from(s))
    }
}
impl ReportFileFormat {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReportFileFormat::Html => "HTML",
            ReportFileFormat::Pdf => "PDF",
            ReportFileFormat::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["HTML", "PDF"]
    }
}
impl AsRef<str> for ReportFileFormat {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about an Amazon Inspector rules package. This data type is used as the response element in the <code>DescribeRulesPackages</code> action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RulesPackage {
    /// <p>The ARN of the rules package.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the rules package.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The version ID of the rules package.</p>
    #[doc(hidden)]
    pub version: std::option::Option<std::string::String>,
    /// <p>The provider of the rules package.</p>
    #[doc(hidden)]
    pub provider: std::option::Option<std::string::String>,
    /// <p>The description of the rules package.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
}
impl RulesPackage {
    /// <p>The ARN of the rules package.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the rules package.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The version ID of the rules package.</p>
    pub fn version(&self) -> std::option::Option<&str> {
        self.version.as_deref()
    }
    /// <p>The provider of the rules package.</p>
    pub fn provider(&self) -> std::option::Option<&str> {
        self.provider.as_deref()
    }
    /// <p>The description of the rules package.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}
/// See [`RulesPackage`](crate::model::RulesPackage).
pub mod rules_package {

    /// A builder for [`RulesPackage`](crate::model::RulesPackage).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<std::string::String>,
        pub(crate) provider: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the rules package.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the rules package.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the rules package.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the rules package.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The version ID of the rules package.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>The version ID of the rules package.</p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// <p>The provider of the rules package.</p>
        pub fn provider(mut self, input: impl Into<std::string::String>) -> Self {
            self.provider = Some(input.into());
            self
        }
        /// <p>The provider of the rules package.</p>
        pub fn set_provider(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.provider = input;
            self
        }
        /// <p>The description of the rules package.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the rules package.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`RulesPackage`](crate::model::RulesPackage).
        pub fn build(self) -> crate::model::RulesPackage {
            crate::model::RulesPackage {
                arn: self.arn,
                name: self.name,
                version: self.version,
                provider: self.provider,
                description: self.description,
            }
        }
    }
}
impl RulesPackage {
    /// Creates a new builder-style object to manufacture [`RulesPackage`](crate::model::RulesPackage).
    pub fn builder() -> crate::model::rules_package::Builder {
        crate::model::rules_package::Builder::default()
    }
}

/// <p>Contains information about a resource group. The resource group defines a set of tags that, when queried, identify the AWS resources that make up the assessment target. This data type is used as the response element in the <code>DescribeResourceGroups</code> action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceGroup {
    /// <p>The ARN of the resource group.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The tags (key and value pairs) of the resource group. This data type property is used in the <code>CreateResourceGroup</code> action.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::ResourceGroupTag>>,
    /// <p>The time at which resource group is created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
}
impl ResourceGroup {
    /// <p>The ARN of the resource group.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The tags (key and value pairs) of the resource group. This data type property is used in the <code>CreateResourceGroup</code> action.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::ResourceGroupTag]> {
        self.tags.as_deref()
    }
    /// <p>The time at which resource group is created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
}
/// See [`ResourceGroup`](crate::model::ResourceGroup).
pub mod resource_group {

    /// A builder for [`ResourceGroup`](crate::model::ResourceGroup).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::ResourceGroupTag>>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The ARN of the resource group.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the resource group.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags (key and value pairs) of the resource group. This data type property is used in the <code>CreateResourceGroup</code> action.</p>
        pub fn tags(mut self, input: crate::model::ResourceGroupTag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The tags (key and value pairs) of the resource group. This data type property is used in the <code>CreateResourceGroup</code> action.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ResourceGroupTag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The time at which resource group is created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The time at which resource group is created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceGroup`](crate::model::ResourceGroup).
        pub fn build(self) -> crate::model::ResourceGroup {
            crate::model::ResourceGroup {
                arn: self.arn,
                tags: self.tags,
                created_at: self.created_at,
            }
        }
    }
}
impl ResourceGroup {
    /// Creates a new builder-style object to manufacture [`ResourceGroup`](crate::model::ResourceGroup).
    pub fn builder() -> crate::model::resource_group::Builder {
        crate::model::resource_group::Builder::default()
    }
}

/// <p>This data type is used as one of the elements of the <code>ResourceGroup</code> data type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceGroupTag {
    /// <p>A tag key.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The value assigned to a tag key.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl ResourceGroupTag {
    /// <p>A tag key.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The value assigned to a tag key.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`ResourceGroupTag`](crate::model::ResourceGroupTag).
pub mod resource_group_tag {

    /// A builder for [`ResourceGroupTag`](crate::model::ResourceGroupTag).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A tag key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>A tag key.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The value assigned to a tag key.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value assigned to a tag key.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceGroupTag`](crate::model::ResourceGroupTag).
        pub fn build(self) -> crate::model::ResourceGroupTag {
            crate::model::ResourceGroupTag {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl ResourceGroupTag {
    /// Creates a new builder-style object to manufacture [`ResourceGroupTag`](crate::model::ResourceGroupTag).
    pub fn builder() -> crate::model::resource_group_tag::Builder {
        crate::model::resource_group_tag::Builder::default()
    }
}

/// <p>Contains information about an Amazon Inspector finding. This data type is used as the response element in the <code>DescribeFindings</code> action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Finding {
    /// <p>The ARN that specifies the finding.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The schema version of this data type.</p>
    #[doc(hidden)]
    pub schema_version: i32,
    /// <p>The data element is set to "Inspector".</p>
    #[doc(hidden)]
    pub service: std::option::Option<std::string::String>,
    /// <p>This data type is used in the <code>Finding</code> data type.</p>
    #[doc(hidden)]
    pub service_attributes: std::option::Option<crate::model::InspectorServiceAttributes>,
    /// <p>The type of the host from which the finding is generated.</p>
    #[doc(hidden)]
    pub asset_type: std::option::Option<crate::model::AssetType>,
    /// <p>A collection of attributes of the host from which the finding is generated.</p>
    #[doc(hidden)]
    pub asset_attributes: std::option::Option<crate::model::AssetAttributes>,
    /// <p>The ID of the finding.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the finding.</p>
    #[doc(hidden)]
    pub title: std::option::Option<std::string::String>,
    /// <p>The description of the finding.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The recommendation for the finding.</p>
    #[doc(hidden)]
    pub recommendation: std::option::Option<std::string::String>,
    /// <p>The finding severity. Values can be set to High, Medium, Low, and Informational.</p>
    #[doc(hidden)]
    pub severity: std::option::Option<crate::model::Severity>,
    /// <p>The numeric value of the finding severity.</p>
    #[doc(hidden)]
    pub numeric_severity: f64,
    /// <p>This data element is currently not used.</p>
    #[doc(hidden)]
    pub confidence: i32,
    /// <p>This data element is currently not used.</p>
    #[doc(hidden)]
    pub indicator_of_compromise: std::option::Option<bool>,
    /// <p>The system-defined attributes for the finding.</p>
    #[doc(hidden)]
    pub attributes: std::option::Option<std::vec::Vec<crate::model::Attribute>>,
    /// <p>The user-defined attributes that are assigned to the finding.</p>
    #[doc(hidden)]
    pub user_attributes: std::option::Option<std::vec::Vec<crate::model::Attribute>>,
    /// <p>The time when the finding was generated.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time when <code>AddAttributesToFindings</code> is called.</p>
    #[doc(hidden)]
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
}
impl Finding {
    /// <p>The ARN that specifies the finding.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The schema version of this data type.</p>
    pub fn schema_version(&self) -> i32 {
        self.schema_version
    }
    /// <p>The data element is set to "Inspector".</p>
    pub fn service(&self) -> std::option::Option<&str> {
        self.service.as_deref()
    }
    /// <p>This data type is used in the <code>Finding</code> data type.</p>
    pub fn service_attributes(
        &self,
    ) -> std::option::Option<&crate::model::InspectorServiceAttributes> {
        self.service_attributes.as_ref()
    }
    /// <p>The type of the host from which the finding is generated.</p>
    pub fn asset_type(&self) -> std::option::Option<&crate::model::AssetType> {
        self.asset_type.as_ref()
    }
    /// <p>A collection of attributes of the host from which the finding is generated.</p>
    pub fn asset_attributes(&self) -> std::option::Option<&crate::model::AssetAttributes> {
        self.asset_attributes.as_ref()
    }
    /// <p>The ID of the finding.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the finding.</p>
    pub fn title(&self) -> std::option::Option<&str> {
        self.title.as_deref()
    }
    /// <p>The description of the finding.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The recommendation for the finding.</p>
    pub fn recommendation(&self) -> std::option::Option<&str> {
        self.recommendation.as_deref()
    }
    /// <p>The finding severity. Values can be set to High, Medium, Low, and Informational.</p>
    pub fn severity(&self) -> std::option::Option<&crate::model::Severity> {
        self.severity.as_ref()
    }
    /// <p>The numeric value of the finding severity.</p>
    pub fn numeric_severity(&self) -> f64 {
        self.numeric_severity
    }
    /// <p>This data element is currently not used.</p>
    pub fn confidence(&self) -> i32 {
        self.confidence
    }
    /// <p>This data element is currently not used.</p>
    pub fn indicator_of_compromise(&self) -> std::option::Option<bool> {
        self.indicator_of_compromise
    }
    /// <p>The system-defined attributes for the finding.</p>
    pub fn attributes(&self) -> std::option::Option<&[crate::model::Attribute]> {
        self.attributes.as_deref()
    }
    /// <p>The user-defined attributes that are assigned to the finding.</p>
    pub fn user_attributes(&self) -> std::option::Option<&[crate::model::Attribute]> {
        self.user_attributes.as_deref()
    }
    /// <p>The time when the finding was generated.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The time when <code>AddAttributesToFindings</code> is called.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
}
/// See [`Finding`](crate::model::Finding).
pub mod finding {

    /// A builder for [`Finding`](crate::model::Finding).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) schema_version: std::option::Option<i32>,
        pub(crate) service: std::option::Option<std::string::String>,
        pub(crate) service_attributes:
            std::option::Option<crate::model::InspectorServiceAttributes>,
        pub(crate) asset_type: std::option::Option<crate::model::AssetType>,
        pub(crate) asset_attributes: std::option::Option<crate::model::AssetAttributes>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) recommendation: std::option::Option<std::string::String>,
        pub(crate) severity: std::option::Option<crate::model::Severity>,
        pub(crate) numeric_severity: std::option::Option<f64>,
        pub(crate) confidence: std::option::Option<i32>,
        pub(crate) indicator_of_compromise: std::option::Option<bool>,
        pub(crate) attributes: std::option::Option<std::vec::Vec<crate::model::Attribute>>,
        pub(crate) user_attributes: std::option::Option<std::vec::Vec<crate::model::Attribute>>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The ARN that specifies the finding.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN that specifies the finding.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The schema version of this data type.</p>
        pub fn schema_version(mut self, input: i32) -> Self {
            self.schema_version = Some(input);
            self
        }
        /// <p>The schema version of this data type.</p>
        pub fn set_schema_version(mut self, input: std::option::Option<i32>) -> Self {
            self.schema_version = input;
            self
        }
        /// <p>The data element is set to "Inspector".</p>
        pub fn service(mut self, input: impl Into<std::string::String>) -> Self {
            self.service = Some(input.into());
            self
        }
        /// <p>The data element is set to "Inspector".</p>
        pub fn set_service(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service = input;
            self
        }
        /// <p>This data type is used in the <code>Finding</code> data type.</p>
        pub fn service_attributes(
            mut self,
            input: crate::model::InspectorServiceAttributes,
        ) -> Self {
            self.service_attributes = Some(input);
            self
        }
        /// <p>This data type is used in the <code>Finding</code> data type.</p>
        pub fn set_service_attributes(
            mut self,
            input: std::option::Option<crate::model::InspectorServiceAttributes>,
        ) -> Self {
            self.service_attributes = input;
            self
        }
        /// <p>The type of the host from which the finding is generated.</p>
        pub fn asset_type(mut self, input: crate::model::AssetType) -> Self {
            self.asset_type = Some(input);
            self
        }
        /// <p>The type of the host from which the finding is generated.</p>
        pub fn set_asset_type(
            mut self,
            input: std::option::Option<crate::model::AssetType>,
        ) -> Self {
            self.asset_type = input;
            self
        }
        /// <p>A collection of attributes of the host from which the finding is generated.</p>
        pub fn asset_attributes(mut self, input: crate::model::AssetAttributes) -> Self {
            self.asset_attributes = Some(input);
            self
        }
        /// <p>A collection of attributes of the host from which the finding is generated.</p>
        pub fn set_asset_attributes(
            mut self,
            input: std::option::Option<crate::model::AssetAttributes>,
        ) -> Self {
            self.asset_attributes = input;
            self
        }
        /// <p>The ID of the finding.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the finding.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the finding.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>The name of the finding.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The description of the finding.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the finding.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The recommendation for the finding.</p>
        pub fn recommendation(mut self, input: impl Into<std::string::String>) -> Self {
            self.recommendation = Some(input.into());
            self
        }
        /// <p>The recommendation for the finding.</p>
        pub fn set_recommendation(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recommendation = input;
            self
        }
        /// <p>The finding severity. Values can be set to High, Medium, Low, and Informational.</p>
        pub fn severity(mut self, input: crate::model::Severity) -> Self {
            self.severity = Some(input);
            self
        }
        /// <p>The finding severity. Values can be set to High, Medium, Low, and Informational.</p>
        pub fn set_severity(mut self, input: std::option::Option<crate::model::Severity>) -> Self {
            self.severity = input;
            self
        }
        /// <p>The numeric value of the finding severity.</p>
        pub fn numeric_severity(mut self, input: f64) -> Self {
            self.numeric_severity = Some(input);
            self
        }
        /// <p>The numeric value of the finding severity.</p>
        pub fn set_numeric_severity(mut self, input: std::option::Option<f64>) -> Self {
            self.numeric_severity = input;
            self
        }
        /// <p>This data element is currently not used.</p>
        pub fn confidence(mut self, input: i32) -> Self {
            self.confidence = Some(input);
            self
        }
        /// <p>This data element is currently not used.</p>
        pub fn set_confidence(mut self, input: std::option::Option<i32>) -> Self {
            self.confidence = input;
            self
        }
        /// <p>This data element is currently not used.</p>
        pub fn indicator_of_compromise(mut self, input: bool) -> Self {
            self.indicator_of_compromise = Some(input);
            self
        }
        /// <p>This data element is currently not used.</p>
        pub fn set_indicator_of_compromise(mut self, input: std::option::Option<bool>) -> Self {
            self.indicator_of_compromise = input;
            self
        }
        /// Appends an item to `attributes`.
        ///
        /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
        ///
        /// <p>The system-defined attributes for the finding.</p>
        pub fn attributes(mut self, input: crate::model::Attribute) -> Self {
            let mut v = self.attributes.unwrap_or_default();
            v.push(input);
            self.attributes = Some(v);
            self
        }
        /// <p>The system-defined attributes for the finding.</p>
        pub fn set_attributes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Attribute>>,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// Appends an item to `user_attributes`.
        ///
        /// To override the contents of this collection use [`set_user_attributes`](Self::set_user_attributes).
        ///
        /// <p>The user-defined attributes that are assigned to the finding.</p>
        pub fn user_attributes(mut self, input: crate::model::Attribute) -> Self {
            let mut v = self.user_attributes.unwrap_or_default();
            v.push(input);
            self.user_attributes = Some(v);
            self
        }
        /// <p>The user-defined attributes that are assigned to the finding.</p>
        pub fn set_user_attributes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Attribute>>,
        ) -> Self {
            self.user_attributes = input;
            self
        }
        /// <p>The time when the finding was generated.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The time when the finding was generated.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The time when <code>AddAttributesToFindings</code> is called.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The time when <code>AddAttributesToFindings</code> is called.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// Consumes the builder and constructs a [`Finding`](crate::model::Finding).
        pub fn build(self) -> crate::model::Finding {
            crate::model::Finding {
                arn: self.arn,
                schema_version: self.schema_version.unwrap_or_default(),
                service: self.service,
                service_attributes: self.service_attributes,
                asset_type: self.asset_type,
                asset_attributes: self.asset_attributes,
                id: self.id,
                title: self.title,
                description: self.description,
                recommendation: self.recommendation,
                severity: self.severity,
                numeric_severity: self.numeric_severity.unwrap_or_default(),
                confidence: self.confidence.unwrap_or_default(),
                indicator_of_compromise: self.indicator_of_compromise,
                attributes: self.attributes,
                user_attributes: self.user_attributes,
                created_at: self.created_at,
                updated_at: self.updated_at,
            }
        }
    }
}
impl Finding {
    /// Creates a new builder-style object to manufacture [`Finding`](crate::model::Finding).
    pub fn builder() -> crate::model::finding::Builder {
        crate::model::finding::Builder::default()
    }
}

/// <p>A collection of attributes of the host from which the finding is generated.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssetAttributes {
    /// <p>The schema version of this data type.</p>
    #[doc(hidden)]
    pub schema_version: i32,
    /// <p>The ID of the agent that is installed on the EC2 instance where the finding is generated.</p>
    #[doc(hidden)]
    pub agent_id: std::option::Option<std::string::String>,
    /// <p>The Auto Scaling group of the EC2 instance where the finding is generated.</p>
    #[doc(hidden)]
    pub auto_scaling_group: std::option::Option<std::string::String>,
    /// <p>The ID of the Amazon Machine Image (AMI) that is installed on the EC2 instance where the finding is generated.</p>
    #[doc(hidden)]
    pub ami_id: std::option::Option<std::string::String>,
    /// <p>The hostname of the EC2 instance where the finding is generated.</p>
    #[doc(hidden)]
    pub hostname: std::option::Option<std::string::String>,
    /// <p>The list of IP v4 addresses of the EC2 instance where the finding is generated.</p>
    #[doc(hidden)]
    pub ipv4_addresses: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The tags related to the EC2 instance where the finding is generated.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>An array of the network interfaces interacting with the EC2 instance where the finding is generated.</p>
    #[doc(hidden)]
    pub network_interfaces: std::option::Option<std::vec::Vec<crate::model::NetworkInterface>>,
}
impl AssetAttributes {
    /// <p>The schema version of this data type.</p>
    pub fn schema_version(&self) -> i32 {
        self.schema_version
    }
    /// <p>The ID of the agent that is installed on the EC2 instance where the finding is generated.</p>
    pub fn agent_id(&self) -> std::option::Option<&str> {
        self.agent_id.as_deref()
    }
    /// <p>The Auto Scaling group of the EC2 instance where the finding is generated.</p>
    pub fn auto_scaling_group(&self) -> std::option::Option<&str> {
        self.auto_scaling_group.as_deref()
    }
    /// <p>The ID of the Amazon Machine Image (AMI) that is installed on the EC2 instance where the finding is generated.</p>
    pub fn ami_id(&self) -> std::option::Option<&str> {
        self.ami_id.as_deref()
    }
    /// <p>The hostname of the EC2 instance where the finding is generated.</p>
    pub fn hostname(&self) -> std::option::Option<&str> {
        self.hostname.as_deref()
    }
    /// <p>The list of IP v4 addresses of the EC2 instance where the finding is generated.</p>
    pub fn ipv4_addresses(&self) -> std::option::Option<&[std::string::String]> {
        self.ipv4_addresses.as_deref()
    }
    /// <p>The tags related to the EC2 instance where the finding is generated.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>An array of the network interfaces interacting with the EC2 instance where the finding is generated.</p>
    pub fn network_interfaces(&self) -> std::option::Option<&[crate::model::NetworkInterface]> {
        self.network_interfaces.as_deref()
    }
}
/// See [`AssetAttributes`](crate::model::AssetAttributes).
pub mod asset_attributes {

    /// A builder for [`AssetAttributes`](crate::model::AssetAttributes).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) schema_version: std::option::Option<i32>,
        pub(crate) agent_id: std::option::Option<std::string::String>,
        pub(crate) auto_scaling_group: std::option::Option<std::string::String>,
        pub(crate) ami_id: std::option::Option<std::string::String>,
        pub(crate) hostname: std::option::Option<std::string::String>,
        pub(crate) ipv4_addresses: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) network_interfaces:
            std::option::Option<std::vec::Vec<crate::model::NetworkInterface>>,
    }
    impl Builder {
        /// <p>The schema version of this data type.</p>
        pub fn schema_version(mut self, input: i32) -> Self {
            self.schema_version = Some(input);
            self
        }
        /// <p>The schema version of this data type.</p>
        pub fn set_schema_version(mut self, input: std::option::Option<i32>) -> Self {
            self.schema_version = input;
            self
        }
        /// <p>The ID of the agent that is installed on the EC2 instance where the finding is generated.</p>
        pub fn agent_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.agent_id = Some(input.into());
            self
        }
        /// <p>The ID of the agent that is installed on the EC2 instance where the finding is generated.</p>
        pub fn set_agent_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.agent_id = input;
            self
        }
        /// <p>The Auto Scaling group of the EC2 instance where the finding is generated.</p>
        pub fn auto_scaling_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.auto_scaling_group = Some(input.into());
            self
        }
        /// <p>The Auto Scaling group of the EC2 instance where the finding is generated.</p>
        pub fn set_auto_scaling_group(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.auto_scaling_group = input;
            self
        }
        /// <p>The ID of the Amazon Machine Image (AMI) that is installed on the EC2 instance where the finding is generated.</p>
        pub fn ami_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ami_id = Some(input.into());
            self
        }
        /// <p>The ID of the Amazon Machine Image (AMI) that is installed on the EC2 instance where the finding is generated.</p>
        pub fn set_ami_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ami_id = input;
            self
        }
        /// <p>The hostname of the EC2 instance where the finding is generated.</p>
        pub fn hostname(mut self, input: impl Into<std::string::String>) -> Self {
            self.hostname = Some(input.into());
            self
        }
        /// <p>The hostname of the EC2 instance where the finding is generated.</p>
        pub fn set_hostname(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hostname = input;
            self
        }
        /// Appends an item to `ipv4_addresses`.
        ///
        /// To override the contents of this collection use [`set_ipv4_addresses`](Self::set_ipv4_addresses).
        ///
        /// <p>The list of IP v4 addresses of the EC2 instance where the finding is generated.</p>
        pub fn ipv4_addresses(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.ipv4_addresses.unwrap_or_default();
            v.push(input.into());
            self.ipv4_addresses = Some(v);
            self
        }
        /// <p>The list of IP v4 addresses of the EC2 instance where the finding is generated.</p>
        pub fn set_ipv4_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.ipv4_addresses = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags related to the EC2 instance where the finding is generated.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The tags related to the EC2 instance where the finding is generated.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Appends an item to `network_interfaces`.
        ///
        /// To override the contents of this collection use [`set_network_interfaces`](Self::set_network_interfaces).
        ///
        /// <p>An array of the network interfaces interacting with the EC2 instance where the finding is generated.</p>
        pub fn network_interfaces(mut self, input: crate::model::NetworkInterface) -> Self {
            let mut v = self.network_interfaces.unwrap_or_default();
            v.push(input);
            self.network_interfaces = Some(v);
            self
        }
        /// <p>An array of the network interfaces interacting with the EC2 instance where the finding is generated.</p>
        pub fn set_network_interfaces(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NetworkInterface>>,
        ) -> Self {
            self.network_interfaces = input;
            self
        }
        /// Consumes the builder and constructs a [`AssetAttributes`](crate::model::AssetAttributes).
        pub fn build(self) -> crate::model::AssetAttributes {
            crate::model::AssetAttributes {
                schema_version: self.schema_version.unwrap_or_default(),
                agent_id: self.agent_id,
                auto_scaling_group: self.auto_scaling_group,
                ami_id: self.ami_id,
                hostname: self.hostname,
                ipv4_addresses: self.ipv4_addresses,
                tags: self.tags,
                network_interfaces: self.network_interfaces,
            }
        }
    }
}
impl AssetAttributes {
    /// Creates a new builder-style object to manufacture [`AssetAttributes`](crate::model::AssetAttributes).
    pub fn builder() -> crate::model::asset_attributes::Builder {
        crate::model::asset_attributes::Builder::default()
    }
}

/// <p>Contains information about the network interfaces interacting with an EC2 instance. This data type is used as one of the elements of the <code>AssetAttributes</code> data type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NetworkInterface {
    /// <p>The ID of the network interface.</p>
    #[doc(hidden)]
    pub network_interface_id: std::option::Option<std::string::String>,
    /// <p>The ID of a subnet associated with the network interface.</p>
    #[doc(hidden)]
    pub subnet_id: std::option::Option<std::string::String>,
    /// <p>The ID of a VPC associated with the network interface.</p>
    #[doc(hidden)]
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>The name of a private DNS associated with the network interface.</p>
    #[doc(hidden)]
    pub private_dns_name: std::option::Option<std::string::String>,
    /// <p>The private IP address associated with the network interface.</p>
    #[doc(hidden)]
    pub private_ip_address: std::option::Option<std::string::String>,
    /// <p>A list of the private IP addresses associated with the network interface. Includes the privateDnsName and privateIpAddress.</p>
    #[doc(hidden)]
    pub private_ip_addresses: std::option::Option<std::vec::Vec<crate::model::PrivateIp>>,
    /// <p>The name of a public DNS associated with the network interface.</p>
    #[doc(hidden)]
    pub public_dns_name: std::option::Option<std::string::String>,
    /// <p>The public IP address from which the network interface is reachable.</p>
    #[doc(hidden)]
    pub public_ip: std::option::Option<std::string::String>,
    /// <p>The IP addresses associated with the network interface.</p>
    #[doc(hidden)]
    pub ipv6_addresses: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of the security groups associated with the network interface. Includes the groupId and groupName.</p>
    #[doc(hidden)]
    pub security_groups: std::option::Option<std::vec::Vec<crate::model::SecurityGroup>>,
}
impl NetworkInterface {
    /// <p>The ID of the network interface.</p>
    pub fn network_interface_id(&self) -> std::option::Option<&str> {
        self.network_interface_id.as_deref()
    }
    /// <p>The ID of a subnet associated with the network interface.</p>
    pub fn subnet_id(&self) -> std::option::Option<&str> {
        self.subnet_id.as_deref()
    }
    /// <p>The ID of a VPC associated with the network interface.</p>
    pub fn vpc_id(&self) -> std::option::Option<&str> {
        self.vpc_id.as_deref()
    }
    /// <p>The name of a private DNS associated with the network interface.</p>
    pub fn private_dns_name(&self) -> std::option::Option<&str> {
        self.private_dns_name.as_deref()
    }
    /// <p>The private IP address associated with the network interface.</p>
    pub fn private_ip_address(&self) -> std::option::Option<&str> {
        self.private_ip_address.as_deref()
    }
    /// <p>A list of the private IP addresses associated with the network interface. Includes the privateDnsName and privateIpAddress.</p>
    pub fn private_ip_addresses(&self) -> std::option::Option<&[crate::model::PrivateIp]> {
        self.private_ip_addresses.as_deref()
    }
    /// <p>The name of a public DNS associated with the network interface.</p>
    pub fn public_dns_name(&self) -> std::option::Option<&str> {
        self.public_dns_name.as_deref()
    }
    /// <p>The public IP address from which the network interface is reachable.</p>
    pub fn public_ip(&self) -> std::option::Option<&str> {
        self.public_ip.as_deref()
    }
    /// <p>The IP addresses associated with the network interface.</p>
    pub fn ipv6_addresses(&self) -> std::option::Option<&[std::string::String]> {
        self.ipv6_addresses.as_deref()
    }
    /// <p>A list of the security groups associated with the network interface. Includes the groupId and groupName.</p>
    pub fn security_groups(&self) -> std::option::Option<&[crate::model::SecurityGroup]> {
        self.security_groups.as_deref()
    }
}
/// See [`NetworkInterface`](crate::model::NetworkInterface).
pub mod network_interface {

    /// A builder for [`NetworkInterface`](crate::model::NetworkInterface).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) network_interface_id: std::option::Option<std::string::String>,
        pub(crate) subnet_id: std::option::Option<std::string::String>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) private_dns_name: std::option::Option<std::string::String>,
        pub(crate) private_ip_address: std::option::Option<std::string::String>,
        pub(crate) private_ip_addresses:
            std::option::Option<std::vec::Vec<crate::model::PrivateIp>>,
        pub(crate) public_dns_name: std::option::Option<std::string::String>,
        pub(crate) public_ip: std::option::Option<std::string::String>,
        pub(crate) ipv6_addresses: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) security_groups: std::option::Option<std::vec::Vec<crate::model::SecurityGroup>>,
    }
    impl Builder {
        /// <p>The ID of the network interface.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_interface_id = Some(input.into());
            self
        }
        /// <p>The ID of the network interface.</p>
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_interface_id = input;
            self
        }
        /// <p>The ID of a subnet associated with the network interface.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_id = Some(input.into());
            self
        }
        /// <p>The ID of a subnet associated with the network interface.</p>
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_id = input;
            self
        }
        /// <p>The ID of a VPC associated with the network interface.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        /// <p>The ID of a VPC associated with the network interface.</p>
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// <p>The name of a private DNS associated with the network interface.</p>
        pub fn private_dns_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_dns_name = Some(input.into());
            self
        }
        /// <p>The name of a private DNS associated with the network interface.</p>
        pub fn set_private_dns_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_dns_name = input;
            self
        }
        /// <p>The private IP address associated with the network interface.</p>
        pub fn private_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_ip_address = Some(input.into());
            self
        }
        /// <p>The private IP address associated with the network interface.</p>
        pub fn set_private_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_ip_address = input;
            self
        }
        /// Appends an item to `private_ip_addresses`.
        ///
        /// To override the contents of this collection use [`set_private_ip_addresses`](Self::set_private_ip_addresses).
        ///
        /// <p>A list of the private IP addresses associated with the network interface. Includes the privateDnsName and privateIpAddress.</p>
        pub fn private_ip_addresses(mut self, input: crate::model::PrivateIp) -> Self {
            let mut v = self.private_ip_addresses.unwrap_or_default();
            v.push(input);
            self.private_ip_addresses = Some(v);
            self
        }
        /// <p>A list of the private IP addresses associated with the network interface. Includes the privateDnsName and privateIpAddress.</p>
        pub fn set_private_ip_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PrivateIp>>,
        ) -> Self {
            self.private_ip_addresses = input;
            self
        }
        /// <p>The name of a public DNS associated with the network interface.</p>
        pub fn public_dns_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.public_dns_name = Some(input.into());
            self
        }
        /// <p>The name of a public DNS associated with the network interface.</p>
        pub fn set_public_dns_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.public_dns_name = input;
            self
        }
        /// <p>The public IP address from which the network interface is reachable.</p>
        pub fn public_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.public_ip = Some(input.into());
            self
        }
        /// <p>The public IP address from which the network interface is reachable.</p>
        pub fn set_public_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.public_ip = input;
            self
        }
        /// Appends an item to `ipv6_addresses`.
        ///
        /// To override the contents of this collection use [`set_ipv6_addresses`](Self::set_ipv6_addresses).
        ///
        /// <p>The IP addresses associated with the network interface.</p>
        pub fn ipv6_addresses(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.ipv6_addresses.unwrap_or_default();
            v.push(input.into());
            self.ipv6_addresses = Some(v);
            self
        }
        /// <p>The IP addresses associated with the network interface.</p>
        pub fn set_ipv6_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.ipv6_addresses = input;
            self
        }
        /// Appends an item to `security_groups`.
        ///
        /// To override the contents of this collection use [`set_security_groups`](Self::set_security_groups).
        ///
        /// <p>A list of the security groups associated with the network interface. Includes the groupId and groupName.</p>
        pub fn security_groups(mut self, input: crate::model::SecurityGroup) -> Self {
            let mut v = self.security_groups.unwrap_or_default();
            v.push(input);
            self.security_groups = Some(v);
            self
        }
        /// <p>A list of the security groups associated with the network interface. Includes the groupId and groupName.</p>
        pub fn set_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SecurityGroup>>,
        ) -> Self {
            self.security_groups = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkInterface`](crate::model::NetworkInterface).
        pub fn build(self) -> crate::model::NetworkInterface {
            crate::model::NetworkInterface {
                network_interface_id: self.network_interface_id,
                subnet_id: self.subnet_id,
                vpc_id: self.vpc_id,
                private_dns_name: self.private_dns_name,
                private_ip_address: self.private_ip_address,
                private_ip_addresses: self.private_ip_addresses,
                public_dns_name: self.public_dns_name,
                public_ip: self.public_ip,
                ipv6_addresses: self.ipv6_addresses,
                security_groups: self.security_groups,
            }
        }
    }
}
impl NetworkInterface {
    /// Creates a new builder-style object to manufacture [`NetworkInterface`](crate::model::NetworkInterface).
    pub fn builder() -> crate::model::network_interface::Builder {
        crate::model::network_interface::Builder::default()
    }
}

/// <p>Contains information about a security group associated with a network interface. This data type is used as one of the elements of the <code>NetworkInterface</code> data type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SecurityGroup {
    /// <p>The name of the security group.</p>
    #[doc(hidden)]
    pub group_name: std::option::Option<std::string::String>,
    /// <p>The ID of the security group.</p>
    #[doc(hidden)]
    pub group_id: std::option::Option<std::string::String>,
}
impl SecurityGroup {
    /// <p>The name of the security group.</p>
    pub fn group_name(&self) -> std::option::Option<&str> {
        self.group_name.as_deref()
    }
    /// <p>The ID of the security group.</p>
    pub fn group_id(&self) -> std::option::Option<&str> {
        self.group_id.as_deref()
    }
}
/// See [`SecurityGroup`](crate::model::SecurityGroup).
pub mod security_group {

    /// A builder for [`SecurityGroup`](crate::model::SecurityGroup).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) group_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the security group.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_name = Some(input.into());
            self
        }
        /// <p>The name of the security group.</p>
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_name = input;
            self
        }
        /// <p>The ID of the security group.</p>
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        /// <p>The ID of the security group.</p>
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input;
            self
        }
        /// Consumes the builder and constructs a [`SecurityGroup`](crate::model::SecurityGroup).
        pub fn build(self) -> crate::model::SecurityGroup {
            crate::model::SecurityGroup {
                group_name: self.group_name,
                group_id: self.group_id,
            }
        }
    }
}
impl SecurityGroup {
    /// Creates a new builder-style object to manufacture [`SecurityGroup`](crate::model::SecurityGroup).
    pub fn builder() -> crate::model::security_group::Builder {
        crate::model::security_group::Builder::default()
    }
}

/// <p>Contains information about a private IP address associated with a network interface. This data type is used as a response element in the <code>DescribeFindings</code> action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PrivateIp {
    /// <p>The DNS name of the private IP address.</p>
    #[doc(hidden)]
    pub private_dns_name: std::option::Option<std::string::String>,
    /// <p>The full IP address of the network inteface.</p>
    #[doc(hidden)]
    pub private_ip_address: std::option::Option<std::string::String>,
}
impl PrivateIp {
    /// <p>The DNS name of the private IP address.</p>
    pub fn private_dns_name(&self) -> std::option::Option<&str> {
        self.private_dns_name.as_deref()
    }
    /// <p>The full IP address of the network inteface.</p>
    pub fn private_ip_address(&self) -> std::option::Option<&str> {
        self.private_ip_address.as_deref()
    }
}
/// See [`PrivateIp`](crate::model::PrivateIp).
pub mod private_ip {

    /// A builder for [`PrivateIp`](crate::model::PrivateIp).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) private_dns_name: std::option::Option<std::string::String>,
        pub(crate) private_ip_address: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The DNS name of the private IP address.</p>
        pub fn private_dns_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_dns_name = Some(input.into());
            self
        }
        /// <p>The DNS name of the private IP address.</p>
        pub fn set_private_dns_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_dns_name = input;
            self
        }
        /// <p>The full IP address of the network inteface.</p>
        pub fn private_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_ip_address = Some(input.into());
            self
        }
        /// <p>The full IP address of the network inteface.</p>
        pub fn set_private_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_ip_address = input;
            self
        }
        /// Consumes the builder and constructs a [`PrivateIp`](crate::model::PrivateIp).
        pub fn build(self) -> crate::model::PrivateIp {
            crate::model::PrivateIp {
                private_dns_name: self.private_dns_name,
                private_ip_address: self.private_ip_address,
            }
        }
    }
}
impl PrivateIp {
    /// Creates a new builder-style object to manufacture [`PrivateIp`](crate::model::PrivateIp).
    pub fn builder() -> crate::model::private_ip::Builder {
        crate::model::private_ip::Builder::default()
    }
}

/// When writing a match expression against `AssetType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let assettype = unimplemented!();
/// match assettype {
///     AssetType::Ec2Instance => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `assettype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AssetType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AssetType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AssetType::NewFeature` is defined.
/// Specifically, when `assettype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AssetType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AssetType {
    #[allow(missing_docs)] // documentation missing in model
    Ec2Instance,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AssetType {
    fn from(s: &str) -> Self {
        match s {
            "ec2-instance" => AssetType::Ec2Instance,
            other => AssetType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AssetType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AssetType::from(s))
    }
}
impl AssetType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AssetType::Ec2Instance => "ec2-instance",
            AssetType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ec2-instance"]
    }
}
impl AsRef<str> for AssetType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>This data type is used in the <code>Finding</code> data type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InspectorServiceAttributes {
    /// <p>The schema version of this data type.</p>
    #[doc(hidden)]
    pub schema_version: i32,
    /// <p>The ARN of the assessment run during which the finding is generated.</p>
    #[doc(hidden)]
    pub assessment_run_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the rules package that is used to generate the finding.</p>
    #[doc(hidden)]
    pub rules_package_arn: std::option::Option<std::string::String>,
}
impl InspectorServiceAttributes {
    /// <p>The schema version of this data type.</p>
    pub fn schema_version(&self) -> i32 {
        self.schema_version
    }
    /// <p>The ARN of the assessment run during which the finding is generated.</p>
    pub fn assessment_run_arn(&self) -> std::option::Option<&str> {
        self.assessment_run_arn.as_deref()
    }
    /// <p>The ARN of the rules package that is used to generate the finding.</p>
    pub fn rules_package_arn(&self) -> std::option::Option<&str> {
        self.rules_package_arn.as_deref()
    }
}
/// See [`InspectorServiceAttributes`](crate::model::InspectorServiceAttributes).
pub mod inspector_service_attributes {

    /// A builder for [`InspectorServiceAttributes`](crate::model::InspectorServiceAttributes).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) schema_version: std::option::Option<i32>,
        pub(crate) assessment_run_arn: std::option::Option<std::string::String>,
        pub(crate) rules_package_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The schema version of this data type.</p>
        pub fn schema_version(mut self, input: i32) -> Self {
            self.schema_version = Some(input);
            self
        }
        /// <p>The schema version of this data type.</p>
        pub fn set_schema_version(mut self, input: std::option::Option<i32>) -> Self {
            self.schema_version = input;
            self
        }
        /// <p>The ARN of the assessment run during which the finding is generated.</p>
        pub fn assessment_run_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_run_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the assessment run during which the finding is generated.</p>
        pub fn set_assessment_run_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_run_arn = input;
            self
        }
        /// <p>The ARN of the rules package that is used to generate the finding.</p>
        pub fn rules_package_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.rules_package_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the rules package that is used to generate the finding.</p>
        pub fn set_rules_package_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.rules_package_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`InspectorServiceAttributes`](crate::model::InspectorServiceAttributes).
        pub fn build(self) -> crate::model::InspectorServiceAttributes {
            crate::model::InspectorServiceAttributes {
                schema_version: self.schema_version.unwrap_or_default(),
                assessment_run_arn: self.assessment_run_arn,
                rules_package_arn: self.rules_package_arn,
            }
        }
    }
}
impl InspectorServiceAttributes {
    /// Creates a new builder-style object to manufacture [`InspectorServiceAttributes`](crate::model::InspectorServiceAttributes).
    pub fn builder() -> crate::model::inspector_service_attributes::Builder {
        crate::model::inspector_service_attributes::Builder::default()
    }
}

/// <p>Contains information about what was excluded from an assessment run.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Exclusion {
    /// <p>The ARN that specifies the exclusion.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the exclusion.</p>
    #[doc(hidden)]
    pub title: std::option::Option<std::string::String>,
    /// <p>The description of the exclusion.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The recommendation for the exclusion.</p>
    #[doc(hidden)]
    pub recommendation: std::option::Option<std::string::String>,
    /// <p>The AWS resources for which the exclusion pertains.</p>
    #[doc(hidden)]
    pub scopes: std::option::Option<std::vec::Vec<crate::model::Scope>>,
    /// <p>The system-defined attributes for the exclusion.</p>
    #[doc(hidden)]
    pub attributes: std::option::Option<std::vec::Vec<crate::model::Attribute>>,
}
impl Exclusion {
    /// <p>The ARN that specifies the exclusion.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the exclusion.</p>
    pub fn title(&self) -> std::option::Option<&str> {
        self.title.as_deref()
    }
    /// <p>The description of the exclusion.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The recommendation for the exclusion.</p>
    pub fn recommendation(&self) -> std::option::Option<&str> {
        self.recommendation.as_deref()
    }
    /// <p>The AWS resources for which the exclusion pertains.</p>
    pub fn scopes(&self) -> std::option::Option<&[crate::model::Scope]> {
        self.scopes.as_deref()
    }
    /// <p>The system-defined attributes for the exclusion.</p>
    pub fn attributes(&self) -> std::option::Option<&[crate::model::Attribute]> {
        self.attributes.as_deref()
    }
}
/// See [`Exclusion`](crate::model::Exclusion).
pub mod exclusion {

    /// A builder for [`Exclusion`](crate::model::Exclusion).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) recommendation: std::option::Option<std::string::String>,
        pub(crate) scopes: std::option::Option<std::vec::Vec<crate::model::Scope>>,
        pub(crate) attributes: std::option::Option<std::vec::Vec<crate::model::Attribute>>,
    }
    impl Builder {
        /// <p>The ARN that specifies the exclusion.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN that specifies the exclusion.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the exclusion.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>The name of the exclusion.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The description of the exclusion.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the exclusion.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The recommendation for the exclusion.</p>
        pub fn recommendation(mut self, input: impl Into<std::string::String>) -> Self {
            self.recommendation = Some(input.into());
            self
        }
        /// <p>The recommendation for the exclusion.</p>
        pub fn set_recommendation(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recommendation = input;
            self
        }
        /// Appends an item to `scopes`.
        ///
        /// To override the contents of this collection use [`set_scopes`](Self::set_scopes).
        ///
        /// <p>The AWS resources for which the exclusion pertains.</p>
        pub fn scopes(mut self, input: crate::model::Scope) -> Self {
            let mut v = self.scopes.unwrap_or_default();
            v.push(input);
            self.scopes = Some(v);
            self
        }
        /// <p>The AWS resources for which the exclusion pertains.</p>
        pub fn set_scopes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Scope>>,
        ) -> Self {
            self.scopes = input;
            self
        }
        /// Appends an item to `attributes`.
        ///
        /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
        ///
        /// <p>The system-defined attributes for the exclusion.</p>
        pub fn attributes(mut self, input: crate::model::Attribute) -> Self {
            let mut v = self.attributes.unwrap_or_default();
            v.push(input);
            self.attributes = Some(v);
            self
        }
        /// <p>The system-defined attributes for the exclusion.</p>
        pub fn set_attributes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Attribute>>,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// Consumes the builder and constructs a [`Exclusion`](crate::model::Exclusion).
        pub fn build(self) -> crate::model::Exclusion {
            crate::model::Exclusion {
                arn: self.arn,
                title: self.title,
                description: self.description,
                recommendation: self.recommendation,
                scopes: self.scopes,
                attributes: self.attributes,
            }
        }
    }
}
impl Exclusion {
    /// Creates a new builder-style object to manufacture [`Exclusion`](crate::model::Exclusion).
    pub fn builder() -> crate::model::exclusion::Builder {
        crate::model::exclusion::Builder::default()
    }
}

/// <p>Contains information about an Amazon Inspector assessment template. This data type is used as the response element in the <code>DescribeAssessmentTemplates</code> action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssessmentTemplate {
    /// <p>The ARN of the assessment template.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the assessment template.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The ARN of the assessment target that corresponds to this assessment template.</p>
    #[doc(hidden)]
    pub assessment_target_arn: std::option::Option<std::string::String>,
    /// <p>The duration in seconds specified for this assessment template. The default value is 3600 seconds (one hour). The maximum value is 86400 seconds (one day).</p>
    #[doc(hidden)]
    pub duration_in_seconds: i32,
    /// <p>The rules packages that are specified for this assessment template.</p>
    #[doc(hidden)]
    pub rules_package_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The user-defined attributes that are assigned to every generated finding from the assessment run that uses this assessment template.</p>
    #[doc(hidden)]
    pub user_attributes_for_findings: std::option::Option<std::vec::Vec<crate::model::Attribute>>,
    /// <p>The Amazon Resource Name (ARN) of the most recent assessment run associated with this assessment template. This value exists only when the value of assessmentRunCount is greaterpa than zero.</p>
    #[doc(hidden)]
    pub last_assessment_run_arn: std::option::Option<std::string::String>,
    /// <p>The number of existing assessment runs associated with this assessment template. This value can be zero or a positive integer.</p>
    #[doc(hidden)]
    pub assessment_run_count: std::option::Option<i32>,
    /// <p>The time at which the assessment template is created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
}
impl AssessmentTemplate {
    /// <p>The ARN of the assessment template.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the assessment template.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The ARN of the assessment target that corresponds to this assessment template.</p>
    pub fn assessment_target_arn(&self) -> std::option::Option<&str> {
        self.assessment_target_arn.as_deref()
    }
    /// <p>The duration in seconds specified for this assessment template. The default value is 3600 seconds (one hour). The maximum value is 86400 seconds (one day).</p>
    pub fn duration_in_seconds(&self) -> i32 {
        self.duration_in_seconds
    }
    /// <p>The rules packages that are specified for this assessment template.</p>
    pub fn rules_package_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.rules_package_arns.as_deref()
    }
    /// <p>The user-defined attributes that are assigned to every generated finding from the assessment run that uses this assessment template.</p>
    pub fn user_attributes_for_findings(&self) -> std::option::Option<&[crate::model::Attribute]> {
        self.user_attributes_for_findings.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the most recent assessment run associated with this assessment template. This value exists only when the value of assessmentRunCount is greaterpa than zero.</p>
    pub fn last_assessment_run_arn(&self) -> std::option::Option<&str> {
        self.last_assessment_run_arn.as_deref()
    }
    /// <p>The number of existing assessment runs associated with this assessment template. This value can be zero or a positive integer.</p>
    pub fn assessment_run_count(&self) -> std::option::Option<i32> {
        self.assessment_run_count
    }
    /// <p>The time at which the assessment template is created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
}
/// See [`AssessmentTemplate`](crate::model::AssessmentTemplate).
pub mod assessment_template {

    /// A builder for [`AssessmentTemplate`](crate::model::AssessmentTemplate).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) assessment_target_arn: std::option::Option<std::string::String>,
        pub(crate) duration_in_seconds: std::option::Option<i32>,
        pub(crate) rules_package_arns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) user_attributes_for_findings:
            std::option::Option<std::vec::Vec<crate::model::Attribute>>,
        pub(crate) last_assessment_run_arn: std::option::Option<std::string::String>,
        pub(crate) assessment_run_count: std::option::Option<i32>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The ARN of the assessment template.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the assessment template.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the assessment template.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the assessment template.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The ARN of the assessment target that corresponds to this assessment template.</p>
        pub fn assessment_target_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_target_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the assessment target that corresponds to this assessment template.</p>
        pub fn set_assessment_target_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_target_arn = input;
            self
        }
        /// <p>The duration in seconds specified for this assessment template. The default value is 3600 seconds (one hour). The maximum value is 86400 seconds (one day).</p>
        pub fn duration_in_seconds(mut self, input: i32) -> Self {
            self.duration_in_seconds = Some(input);
            self
        }
        /// <p>The duration in seconds specified for this assessment template. The default value is 3600 seconds (one hour). The maximum value is 86400 seconds (one day).</p>
        pub fn set_duration_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.duration_in_seconds = input;
            self
        }
        /// Appends an item to `rules_package_arns`.
        ///
        /// To override the contents of this collection use [`set_rules_package_arns`](Self::set_rules_package_arns).
        ///
        /// <p>The rules packages that are specified for this assessment template.</p>
        pub fn rules_package_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.rules_package_arns.unwrap_or_default();
            v.push(input.into());
            self.rules_package_arns = Some(v);
            self
        }
        /// <p>The rules packages that are specified for this assessment template.</p>
        pub fn set_rules_package_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.rules_package_arns = input;
            self
        }
        /// Appends an item to `user_attributes_for_findings`.
        ///
        /// To override the contents of this collection use [`set_user_attributes_for_findings`](Self::set_user_attributes_for_findings).
        ///
        /// <p>The user-defined attributes that are assigned to every generated finding from the assessment run that uses this assessment template.</p>
        pub fn user_attributes_for_findings(mut self, input: crate::model::Attribute) -> Self {
            let mut v = self.user_attributes_for_findings.unwrap_or_default();
            v.push(input);
            self.user_attributes_for_findings = Some(v);
            self
        }
        /// <p>The user-defined attributes that are assigned to every generated finding from the assessment run that uses this assessment template.</p>
        pub fn set_user_attributes_for_findings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Attribute>>,
        ) -> Self {
            self.user_attributes_for_findings = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the most recent assessment run associated with this assessment template. This value exists only when the value of assessmentRunCount is greaterpa than zero.</p>
        pub fn last_assessment_run_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_assessment_run_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the most recent assessment run associated with this assessment template. This value exists only when the value of assessmentRunCount is greaterpa than zero.</p>
        pub fn set_last_assessment_run_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_assessment_run_arn = input;
            self
        }
        /// <p>The number of existing assessment runs associated with this assessment template. This value can be zero or a positive integer.</p>
        pub fn assessment_run_count(mut self, input: i32) -> Self {
            self.assessment_run_count = Some(input);
            self
        }
        /// <p>The number of existing assessment runs associated with this assessment template. This value can be zero or a positive integer.</p>
        pub fn set_assessment_run_count(mut self, input: std::option::Option<i32>) -> Self {
            self.assessment_run_count = input;
            self
        }
        /// <p>The time at which the assessment template is created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The time at which the assessment template is created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// Consumes the builder and constructs a [`AssessmentTemplate`](crate::model::AssessmentTemplate).
        pub fn build(self) -> crate::model::AssessmentTemplate {
            crate::model::AssessmentTemplate {
                arn: self.arn,
                name: self.name,
                assessment_target_arn: self.assessment_target_arn,
                duration_in_seconds: self.duration_in_seconds.unwrap_or_default(),
                rules_package_arns: self.rules_package_arns,
                user_attributes_for_findings: self.user_attributes_for_findings,
                last_assessment_run_arn: self.last_assessment_run_arn,
                assessment_run_count: self.assessment_run_count,
                created_at: self.created_at,
            }
        }
    }
}
impl AssessmentTemplate {
    /// Creates a new builder-style object to manufacture [`AssessmentTemplate`](crate::model::AssessmentTemplate).
    pub fn builder() -> crate::model::assessment_template::Builder {
        crate::model::assessment_template::Builder::default()
    }
}

/// <p>Contains information about an Amazon Inspector application. This data type is used as the response element in the <code>DescribeAssessmentTargets</code> action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssessmentTarget {
    /// <p>The ARN that specifies the Amazon Inspector assessment target.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the Amazon Inspector assessment target.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The ARN that specifies the resource group that is associated with the assessment target.</p>
    #[doc(hidden)]
    pub resource_group_arn: std::option::Option<std::string::String>,
    /// <p>The time at which the assessment target is created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time at which <code>UpdateAssessmentTarget</code> is called.</p>
    #[doc(hidden)]
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
}
impl AssessmentTarget {
    /// <p>The ARN that specifies the Amazon Inspector assessment target.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the Amazon Inspector assessment target.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The ARN that specifies the resource group that is associated with the assessment target.</p>
    pub fn resource_group_arn(&self) -> std::option::Option<&str> {
        self.resource_group_arn.as_deref()
    }
    /// <p>The time at which the assessment target is created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The time at which <code>UpdateAssessmentTarget</code> is called.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
}
/// See [`AssessmentTarget`](crate::model::AssessmentTarget).
pub mod assessment_target {

    /// A builder for [`AssessmentTarget`](crate::model::AssessmentTarget).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) resource_group_arn: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The ARN that specifies the Amazon Inspector assessment target.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN that specifies the Amazon Inspector assessment target.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the Amazon Inspector assessment target.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the Amazon Inspector assessment target.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The ARN that specifies the resource group that is associated with the assessment target.</p>
        pub fn resource_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_group_arn = Some(input.into());
            self
        }
        /// <p>The ARN that specifies the resource group that is associated with the assessment target.</p>
        pub fn set_resource_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_group_arn = input;
            self
        }
        /// <p>The time at which the assessment target is created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The time at which the assessment target is created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The time at which <code>UpdateAssessmentTarget</code> is called.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The time at which <code>UpdateAssessmentTarget</code> is called.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// Consumes the builder and constructs a [`AssessmentTarget`](crate::model::AssessmentTarget).
        pub fn build(self) -> crate::model::AssessmentTarget {
            crate::model::AssessmentTarget {
                arn: self.arn,
                name: self.name,
                resource_group_arn: self.resource_group_arn,
                created_at: self.created_at,
                updated_at: self.updated_at,
            }
        }
    }
}
impl AssessmentTarget {
    /// Creates a new builder-style object to manufacture [`AssessmentTarget`](crate::model::AssessmentTarget).
    pub fn builder() -> crate::model::assessment_target::Builder {
        crate::model::assessment_target::Builder::default()
    }
}

/// <p>A snapshot of an Amazon Inspector assessment run that contains the findings of the assessment run .</p>
/// <p>Used as the response element in the <code>DescribeAssessmentRuns</code> action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssessmentRun {
    /// <p>The ARN of the assessment run.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The auto-generated name for the assessment run.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The ARN of the assessment template that is associated with the assessment run.</p>
    #[doc(hidden)]
    pub assessment_template_arn: std::option::Option<std::string::String>,
    /// <p>The state of the assessment run.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::AssessmentRunState>,
    /// <p>The duration of the assessment run.</p>
    #[doc(hidden)]
    pub duration_in_seconds: i32,
    /// <p>The rules packages selected for the assessment run.</p>
    #[doc(hidden)]
    pub rules_package_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The user-defined attributes that are assigned to every generated finding.</p>
    #[doc(hidden)]
    pub user_attributes_for_findings: std::option::Option<std::vec::Vec<crate::model::Attribute>>,
    /// <p>The time when <code>StartAssessmentRun</code> was called.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time when <code>StartAssessmentRun</code> was called.</p>
    #[doc(hidden)]
    pub started_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The assessment run completion time that corresponds to the rules packages evaluation completion time or failure.</p>
    #[doc(hidden)]
    pub completed_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last time when the assessment run's state changed.</p>
    #[doc(hidden)]
    pub state_changed_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A Boolean value (true or false) that specifies whether the process of collecting data from the agents is completed.</p>
    #[doc(hidden)]
    pub data_collected: std::option::Option<bool>,
    /// <p>A list of the assessment run state changes.</p>
    #[doc(hidden)]
    pub state_changes: std::option::Option<std::vec::Vec<crate::model::AssessmentRunStateChange>>,
    /// <p>A list of notifications for the event subscriptions. A notification about a particular generated finding is added to this list only once.</p>
    #[doc(hidden)]
    pub notifications: std::option::Option<std::vec::Vec<crate::model::AssessmentRunNotification>>,
    /// <p>Provides a total count of generated findings per severity.</p>
    #[doc(hidden)]
    pub finding_counts: std::option::Option<std::collections::HashMap<crate::model::Severity, i32>>,
}
impl AssessmentRun {
    /// <p>The ARN of the assessment run.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The auto-generated name for the assessment run.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The ARN of the assessment template that is associated with the assessment run.</p>
    pub fn assessment_template_arn(&self) -> std::option::Option<&str> {
        self.assessment_template_arn.as_deref()
    }
    /// <p>The state of the assessment run.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::AssessmentRunState> {
        self.state.as_ref()
    }
    /// <p>The duration of the assessment run.</p>
    pub fn duration_in_seconds(&self) -> i32 {
        self.duration_in_seconds
    }
    /// <p>The rules packages selected for the assessment run.</p>
    pub fn rules_package_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.rules_package_arns.as_deref()
    }
    /// <p>The user-defined attributes that are assigned to every generated finding.</p>
    pub fn user_attributes_for_findings(&self) -> std::option::Option<&[crate::model::Attribute]> {
        self.user_attributes_for_findings.as_deref()
    }
    /// <p>The time when <code>StartAssessmentRun</code> was called.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The time when <code>StartAssessmentRun</code> was called.</p>
    pub fn started_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.started_at.as_ref()
    }
    /// <p>The assessment run completion time that corresponds to the rules packages evaluation completion time or failure.</p>
    pub fn completed_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.completed_at.as_ref()
    }
    /// <p>The last time when the assessment run's state changed.</p>
    pub fn state_changed_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.state_changed_at.as_ref()
    }
    /// <p>A Boolean value (true or false) that specifies whether the process of collecting data from the agents is completed.</p>
    pub fn data_collected(&self) -> std::option::Option<bool> {
        self.data_collected
    }
    /// <p>A list of the assessment run state changes.</p>
    pub fn state_changes(&self) -> std::option::Option<&[crate::model::AssessmentRunStateChange]> {
        self.state_changes.as_deref()
    }
    /// <p>A list of notifications for the event subscriptions. A notification about a particular generated finding is added to this list only once.</p>
    pub fn notifications(&self) -> std::option::Option<&[crate::model::AssessmentRunNotification]> {
        self.notifications.as_deref()
    }
    /// <p>Provides a total count of generated findings per severity.</p>
    pub fn finding_counts(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<crate::model::Severity, i32>> {
        self.finding_counts.as_ref()
    }
}
/// See [`AssessmentRun`](crate::model::AssessmentRun).
pub mod assessment_run {

    /// A builder for [`AssessmentRun`](crate::model::AssessmentRun).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) assessment_template_arn: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::AssessmentRunState>,
        pub(crate) duration_in_seconds: std::option::Option<i32>,
        pub(crate) rules_package_arns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) user_attributes_for_findings:
            std::option::Option<std::vec::Vec<crate::model::Attribute>>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) started_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) completed_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) state_changed_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) data_collected: std::option::Option<bool>,
        pub(crate) state_changes:
            std::option::Option<std::vec::Vec<crate::model::AssessmentRunStateChange>>,
        pub(crate) notifications:
            std::option::Option<std::vec::Vec<crate::model::AssessmentRunNotification>>,
        pub(crate) finding_counts:
            std::option::Option<std::collections::HashMap<crate::model::Severity, i32>>,
    }
    impl Builder {
        /// <p>The ARN of the assessment run.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the assessment run.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The auto-generated name for the assessment run.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The auto-generated name for the assessment run.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The ARN of the assessment template that is associated with the assessment run.</p>
        pub fn assessment_template_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_template_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the assessment template that is associated with the assessment run.</p>
        pub fn set_assessment_template_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_template_arn = input;
            self
        }
        /// <p>The state of the assessment run.</p>
        pub fn state(mut self, input: crate::model::AssessmentRunState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the assessment run.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::AssessmentRunState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The duration of the assessment run.</p>
        pub fn duration_in_seconds(mut self, input: i32) -> Self {
            self.duration_in_seconds = Some(input);
            self
        }
        /// <p>The duration of the assessment run.</p>
        pub fn set_duration_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.duration_in_seconds = input;
            self
        }
        /// Appends an item to `rules_package_arns`.
        ///
        /// To override the contents of this collection use [`set_rules_package_arns`](Self::set_rules_package_arns).
        ///
        /// <p>The rules packages selected for the assessment run.</p>
        pub fn rules_package_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.rules_package_arns.unwrap_or_default();
            v.push(input.into());
            self.rules_package_arns = Some(v);
            self
        }
        /// <p>The rules packages selected for the assessment run.</p>
        pub fn set_rules_package_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.rules_package_arns = input;
            self
        }
        /// Appends an item to `user_attributes_for_findings`.
        ///
        /// To override the contents of this collection use [`set_user_attributes_for_findings`](Self::set_user_attributes_for_findings).
        ///
        /// <p>The user-defined attributes that are assigned to every generated finding.</p>
        pub fn user_attributes_for_findings(mut self, input: crate::model::Attribute) -> Self {
            let mut v = self.user_attributes_for_findings.unwrap_or_default();
            v.push(input);
            self.user_attributes_for_findings = Some(v);
            self
        }
        /// <p>The user-defined attributes that are assigned to every generated finding.</p>
        pub fn set_user_attributes_for_findings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Attribute>>,
        ) -> Self {
            self.user_attributes_for_findings = input;
            self
        }
        /// <p>The time when <code>StartAssessmentRun</code> was called.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The time when <code>StartAssessmentRun</code> was called.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The time when <code>StartAssessmentRun</code> was called.</p>
        pub fn started_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.started_at = Some(input);
            self
        }
        /// <p>The time when <code>StartAssessmentRun</code> was called.</p>
        pub fn set_started_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.started_at = input;
            self
        }
        /// <p>The assessment run completion time that corresponds to the rules packages evaluation completion time or failure.</p>
        pub fn completed_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.completed_at = Some(input);
            self
        }
        /// <p>The assessment run completion time that corresponds to the rules packages evaluation completion time or failure.</p>
        pub fn set_completed_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.completed_at = input;
            self
        }
        /// <p>The last time when the assessment run's state changed.</p>
        pub fn state_changed_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.state_changed_at = Some(input);
            self
        }
        /// <p>The last time when the assessment run's state changed.</p>
        pub fn set_state_changed_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.state_changed_at = input;
            self
        }
        /// <p>A Boolean value (true or false) that specifies whether the process of collecting data from the agents is completed.</p>
        pub fn data_collected(mut self, input: bool) -> Self {
            self.data_collected = Some(input);
            self
        }
        /// <p>A Boolean value (true or false) that specifies whether the process of collecting data from the agents is completed.</p>
        pub fn set_data_collected(mut self, input: std::option::Option<bool>) -> Self {
            self.data_collected = input;
            self
        }
        /// Appends an item to `state_changes`.
        ///
        /// To override the contents of this collection use [`set_state_changes`](Self::set_state_changes).
        ///
        /// <p>A list of the assessment run state changes.</p>
        pub fn state_changes(mut self, input: crate::model::AssessmentRunStateChange) -> Self {
            let mut v = self.state_changes.unwrap_or_default();
            v.push(input);
            self.state_changes = Some(v);
            self
        }
        /// <p>A list of the assessment run state changes.</p>
        pub fn set_state_changes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AssessmentRunStateChange>>,
        ) -> Self {
            self.state_changes = input;
            self
        }
        /// Appends an item to `notifications`.
        ///
        /// To override the contents of this collection use [`set_notifications`](Self::set_notifications).
        ///
        /// <p>A list of notifications for the event subscriptions. A notification about a particular generated finding is added to this list only once.</p>
        pub fn notifications(mut self, input: crate::model::AssessmentRunNotification) -> Self {
            let mut v = self.notifications.unwrap_or_default();
            v.push(input);
            self.notifications = Some(v);
            self
        }
        /// <p>A list of notifications for the event subscriptions. A notification about a particular generated finding is added to this list only once.</p>
        pub fn set_notifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AssessmentRunNotification>>,
        ) -> Self {
            self.notifications = input;
            self
        }
        /// Adds a key-value pair to `finding_counts`.
        ///
        /// To override the contents of this collection use [`set_finding_counts`](Self::set_finding_counts).
        ///
        /// <p>Provides a total count of generated findings per severity.</p>
        pub fn finding_counts(mut self, k: crate::model::Severity, v: i32) -> Self {
            let mut hash_map = self.finding_counts.unwrap_or_default();
            hash_map.insert(k, v);
            self.finding_counts = Some(hash_map);
            self
        }
        /// <p>Provides a total count of generated findings per severity.</p>
        pub fn set_finding_counts(
            mut self,
            input: std::option::Option<std::collections::HashMap<crate::model::Severity, i32>>,
        ) -> Self {
            self.finding_counts = input;
            self
        }
        /// Consumes the builder and constructs a [`AssessmentRun`](crate::model::AssessmentRun).
        pub fn build(self) -> crate::model::AssessmentRun {
            crate::model::AssessmentRun {
                arn: self.arn,
                name: self.name,
                assessment_template_arn: self.assessment_template_arn,
                state: self.state,
                duration_in_seconds: self.duration_in_seconds.unwrap_or_default(),
                rules_package_arns: self.rules_package_arns,
                user_attributes_for_findings: self.user_attributes_for_findings,
                created_at: self.created_at,
                started_at: self.started_at,
                completed_at: self.completed_at,
                state_changed_at: self.state_changed_at,
                data_collected: self.data_collected,
                state_changes: self.state_changes,
                notifications: self.notifications,
                finding_counts: self.finding_counts,
            }
        }
    }
}
impl AssessmentRun {
    /// Creates a new builder-style object to manufacture [`AssessmentRun`](crate::model::AssessmentRun).
    pub fn builder() -> crate::model::assessment_run::Builder {
        crate::model::assessment_run::Builder::default()
    }
}

/// <p>Used as one of the elements of the <code>AssessmentRun</code> data type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssessmentRunNotification {
    /// <p>The date of the notification.</p>
    #[doc(hidden)]
    pub date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The event for which a notification is sent.</p>
    #[doc(hidden)]
    pub event: std::option::Option<crate::model::InspectorEvent>,
    /// <p>The message included in the notification.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Boolean value that specifies whether the notification represents an error.</p>
    #[doc(hidden)]
    pub error: std::option::Option<bool>,
    /// <p>The SNS topic to which the SNS notification is sent.</p>
    #[doc(hidden)]
    pub sns_topic_arn: std::option::Option<std::string::String>,
    /// <p>The status code of the SNS notification.</p>
    #[doc(hidden)]
    pub sns_publish_status_code:
        std::option::Option<crate::model::AssessmentRunNotificationSnsStatusCode>,
}
impl AssessmentRunNotification {
    /// <p>The date of the notification.</p>
    pub fn date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.date.as_ref()
    }
    /// <p>The event for which a notification is sent.</p>
    pub fn event(&self) -> std::option::Option<&crate::model::InspectorEvent> {
        self.event.as_ref()
    }
    /// <p>The message included in the notification.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>The Boolean value that specifies whether the notification represents an error.</p>
    pub fn error(&self) -> std::option::Option<bool> {
        self.error
    }
    /// <p>The SNS topic to which the SNS notification is sent.</p>
    pub fn sns_topic_arn(&self) -> std::option::Option<&str> {
        self.sns_topic_arn.as_deref()
    }
    /// <p>The status code of the SNS notification.</p>
    pub fn sns_publish_status_code(
        &self,
    ) -> std::option::Option<&crate::model::AssessmentRunNotificationSnsStatusCode> {
        self.sns_publish_status_code.as_ref()
    }
}
/// See [`AssessmentRunNotification`](crate::model::AssessmentRunNotification).
pub mod assessment_run_notification {

    /// A builder for [`AssessmentRunNotification`](crate::model::AssessmentRunNotification).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) event: std::option::Option<crate::model::InspectorEvent>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) error: std::option::Option<bool>,
        pub(crate) sns_topic_arn: std::option::Option<std::string::String>,
        pub(crate) sns_publish_status_code:
            std::option::Option<crate::model::AssessmentRunNotificationSnsStatusCode>,
    }
    impl Builder {
        /// <p>The date of the notification.</p>
        pub fn date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.date = Some(input);
            self
        }
        /// <p>The date of the notification.</p>
        pub fn set_date(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.date = input;
            self
        }
        /// <p>The event for which a notification is sent.</p>
        pub fn event(mut self, input: crate::model::InspectorEvent) -> Self {
            self.event = Some(input);
            self
        }
        /// <p>The event for which a notification is sent.</p>
        pub fn set_event(
            mut self,
            input: std::option::Option<crate::model::InspectorEvent>,
        ) -> Self {
            self.event = input;
            self
        }
        /// <p>The message included in the notification.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message included in the notification.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Boolean value that specifies whether the notification represents an error.</p>
        pub fn error(mut self, input: bool) -> Self {
            self.error = Some(input);
            self
        }
        /// <p>The Boolean value that specifies whether the notification represents an error.</p>
        pub fn set_error(mut self, input: std::option::Option<bool>) -> Self {
            self.error = input;
            self
        }
        /// <p>The SNS topic to which the SNS notification is sent.</p>
        pub fn sns_topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.sns_topic_arn = Some(input.into());
            self
        }
        /// <p>The SNS topic to which the SNS notification is sent.</p>
        pub fn set_sns_topic_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sns_topic_arn = input;
            self
        }
        /// <p>The status code of the SNS notification.</p>
        pub fn sns_publish_status_code(
            mut self,
            input: crate::model::AssessmentRunNotificationSnsStatusCode,
        ) -> Self {
            self.sns_publish_status_code = Some(input);
            self
        }
        /// <p>The status code of the SNS notification.</p>
        pub fn set_sns_publish_status_code(
            mut self,
            input: std::option::Option<crate::model::AssessmentRunNotificationSnsStatusCode>,
        ) -> Self {
            self.sns_publish_status_code = input;
            self
        }
        /// Consumes the builder and constructs a [`AssessmentRunNotification`](crate::model::AssessmentRunNotification).
        pub fn build(self) -> crate::model::AssessmentRunNotification {
            crate::model::AssessmentRunNotification {
                date: self.date,
                event: self.event,
                message: self.message,
                error: self.error,
                sns_topic_arn: self.sns_topic_arn,
                sns_publish_status_code: self.sns_publish_status_code,
            }
        }
    }
}
impl AssessmentRunNotification {
    /// Creates a new builder-style object to manufacture [`AssessmentRunNotification`](crate::model::AssessmentRunNotification).
    pub fn builder() -> crate::model::assessment_run_notification::Builder {
        crate::model::assessment_run_notification::Builder::default()
    }
}

/// When writing a match expression against `AssessmentRunNotificationSnsStatusCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let assessmentrunnotificationsnsstatuscode = unimplemented!();
/// match assessmentrunnotificationsnsstatuscode {
///     AssessmentRunNotificationSnsStatusCode::AccessDenied => { /* ... */ },
///     AssessmentRunNotificationSnsStatusCode::InternalError => { /* ... */ },
///     AssessmentRunNotificationSnsStatusCode::Success => { /* ... */ },
///     AssessmentRunNotificationSnsStatusCode::TopicDoesNotExist => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `assessmentrunnotificationsnsstatuscode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AssessmentRunNotificationSnsStatusCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AssessmentRunNotificationSnsStatusCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AssessmentRunNotificationSnsStatusCode::NewFeature` is defined.
/// Specifically, when `assessmentrunnotificationsnsstatuscode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AssessmentRunNotificationSnsStatusCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AssessmentRunNotificationSnsStatusCode {
    #[allow(missing_docs)] // documentation missing in model
    AccessDenied,
    #[allow(missing_docs)] // documentation missing in model
    InternalError,
    #[allow(missing_docs)] // documentation missing in model
    Success,
    #[allow(missing_docs)] // documentation missing in model
    TopicDoesNotExist,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AssessmentRunNotificationSnsStatusCode {
    fn from(s: &str) -> Self {
        match s {
            "ACCESS_DENIED" => AssessmentRunNotificationSnsStatusCode::AccessDenied,
            "INTERNAL_ERROR" => AssessmentRunNotificationSnsStatusCode::InternalError,
            "SUCCESS" => AssessmentRunNotificationSnsStatusCode::Success,
            "TOPIC_DOES_NOT_EXIST" => AssessmentRunNotificationSnsStatusCode::TopicDoesNotExist,
            other => AssessmentRunNotificationSnsStatusCode::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for AssessmentRunNotificationSnsStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AssessmentRunNotificationSnsStatusCode::from(s))
    }
}
impl AssessmentRunNotificationSnsStatusCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AssessmentRunNotificationSnsStatusCode::AccessDenied => "ACCESS_DENIED",
            AssessmentRunNotificationSnsStatusCode::InternalError => "INTERNAL_ERROR",
            AssessmentRunNotificationSnsStatusCode::Success => "SUCCESS",
            AssessmentRunNotificationSnsStatusCode::TopicDoesNotExist => "TOPIC_DOES_NOT_EXIST",
            AssessmentRunNotificationSnsStatusCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACCESS_DENIED",
            "INTERNAL_ERROR",
            "SUCCESS",
            "TOPIC_DOES_NOT_EXIST",
        ]
    }
}
impl AsRef<str> for AssessmentRunNotificationSnsStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Used as one of the elements of the <code>AssessmentRun</code> data type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssessmentRunStateChange {
    /// <p>The last time the assessment run state changed.</p>
    #[doc(hidden)]
    pub state_changed_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The assessment run state.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::AssessmentRunState>,
}
impl AssessmentRunStateChange {
    /// <p>The last time the assessment run state changed.</p>
    pub fn state_changed_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.state_changed_at.as_ref()
    }
    /// <p>The assessment run state.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::AssessmentRunState> {
        self.state.as_ref()
    }
}
/// See [`AssessmentRunStateChange`](crate::model::AssessmentRunStateChange).
pub mod assessment_run_state_change {

    /// A builder for [`AssessmentRunStateChange`](crate::model::AssessmentRunStateChange).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) state_changed_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) state: std::option::Option<crate::model::AssessmentRunState>,
    }
    impl Builder {
        /// <p>The last time the assessment run state changed.</p>
        pub fn state_changed_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.state_changed_at = Some(input);
            self
        }
        /// <p>The last time the assessment run state changed.</p>
        pub fn set_state_changed_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.state_changed_at = input;
            self
        }
        /// <p>The assessment run state.</p>
        pub fn state(mut self, input: crate::model::AssessmentRunState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The assessment run state.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::AssessmentRunState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`AssessmentRunStateChange`](crate::model::AssessmentRunStateChange).
        pub fn build(self) -> crate::model::AssessmentRunStateChange {
            crate::model::AssessmentRunStateChange {
                state_changed_at: self.state_changed_at,
                state: self.state,
            }
        }
    }
}
impl AssessmentRunStateChange {
    /// Creates a new builder-style object to manufacture [`AssessmentRunStateChange`](crate::model::AssessmentRunStateChange).
    pub fn builder() -> crate::model::assessment_run_state_change::Builder {
        crate::model::assessment_run_state_change::Builder::default()
    }
}
