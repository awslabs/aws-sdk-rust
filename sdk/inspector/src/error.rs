// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddAttributesToFindingsError {
    pub kind: AddAttributesToFindingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddAttributesToFindingsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalException(crate::error::InternalException),
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceTemporarilyUnavailableException(crate::error::ServiceTemporarilyUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddAttributesToFindingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AddAttributesToFindingsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            AddAttributesToFindingsErrorKind::InternalException(_inner) => _inner.fmt(f),
            AddAttributesToFindingsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            AddAttributesToFindingsErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            AddAttributesToFindingsErrorKind::ServiceTemporarilyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            AddAttributesToFindingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AddAttributesToFindingsError {
    fn code(&self) -> Option<&str> {
        AddAttributesToFindingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddAttributesToFindingsError {
    pub fn new(kind: AddAttributesToFindingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AddAttributesToFindingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AddAttributesToFindingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddAttributesToFindingsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddAttributesToFindingsErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddAttributesToFindingsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddAttributesToFindingsErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_temporarily_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddAttributesToFindingsErrorKind::ServiceTemporarilyUnavailableException(_)
        )
    }
}
impl std::error::Error for AddAttributesToFindingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AddAttributesToFindingsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            AddAttributesToFindingsErrorKind::InternalException(_inner) => Some(_inner),
            AddAttributesToFindingsErrorKind::InvalidInputException(_inner) => Some(_inner),
            AddAttributesToFindingsErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            AddAttributesToFindingsErrorKind::ServiceTemporarilyUnavailableException(_inner) => {
                Some(_inner)
            }
            AddAttributesToFindingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAssessmentTargetError {
    pub kind: CreateAssessmentTargetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAssessmentTargetErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalException(crate::error::InternalException),
    InvalidCrossAccountRoleException(crate::error::InvalidCrossAccountRoleException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceTemporarilyUnavailableException(crate::error::ServiceTemporarilyUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateAssessmentTargetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAssessmentTargetErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateAssessmentTargetErrorKind::InternalException(_inner) => _inner.fmt(f),
            CreateAssessmentTargetErrorKind::InvalidCrossAccountRoleException(_inner) => {
                _inner.fmt(f)
            }
            CreateAssessmentTargetErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateAssessmentTargetErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateAssessmentTargetErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            CreateAssessmentTargetErrorKind::ServiceTemporarilyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            CreateAssessmentTargetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateAssessmentTargetError {
    fn code(&self) -> Option<&str> {
        CreateAssessmentTargetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAssessmentTargetError {
    pub fn new(kind: CreateAssessmentTargetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateAssessmentTargetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateAssessmentTargetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssessmentTargetErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssessmentTargetErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_cross_account_role_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssessmentTargetErrorKind::InvalidCrossAccountRoleException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssessmentTargetErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssessmentTargetErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssessmentTargetErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_temporarily_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssessmentTargetErrorKind::ServiceTemporarilyUnavailableException(_)
        )
    }
}
impl std::error::Error for CreateAssessmentTargetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAssessmentTargetErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateAssessmentTargetErrorKind::InternalException(_inner) => Some(_inner),
            CreateAssessmentTargetErrorKind::InvalidCrossAccountRoleException(_inner) => {
                Some(_inner)
            }
            CreateAssessmentTargetErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateAssessmentTargetErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateAssessmentTargetErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            CreateAssessmentTargetErrorKind::ServiceTemporarilyUnavailableException(_inner) => {
                Some(_inner)
            }
            CreateAssessmentTargetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAssessmentTemplateError {
    pub kind: CreateAssessmentTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAssessmentTemplateErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalException(crate::error::InternalException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceTemporarilyUnavailableException(crate::error::ServiceTemporarilyUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateAssessmentTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAssessmentTemplateErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateAssessmentTemplateErrorKind::InternalException(_inner) => _inner.fmt(f),
            CreateAssessmentTemplateErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateAssessmentTemplateErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateAssessmentTemplateErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            CreateAssessmentTemplateErrorKind::ServiceTemporarilyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            CreateAssessmentTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateAssessmentTemplateError {
    fn code(&self) -> Option<&str> {
        CreateAssessmentTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAssessmentTemplateError {
    pub fn new(kind: CreateAssessmentTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateAssessmentTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateAssessmentTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssessmentTemplateErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssessmentTemplateErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssessmentTemplateErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssessmentTemplateErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssessmentTemplateErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_temporarily_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssessmentTemplateErrorKind::ServiceTemporarilyUnavailableException(_)
        )
    }
}
impl std::error::Error for CreateAssessmentTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAssessmentTemplateErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateAssessmentTemplateErrorKind::InternalException(_inner) => Some(_inner),
            CreateAssessmentTemplateErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateAssessmentTemplateErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateAssessmentTemplateErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            CreateAssessmentTemplateErrorKind::ServiceTemporarilyUnavailableException(_inner) => {
                Some(_inner)
            }
            CreateAssessmentTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateExclusionsPreviewError {
    pub kind: CreateExclusionsPreviewErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateExclusionsPreviewErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalException(crate::error::InternalException),
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    PreviewGenerationInProgressException(crate::error::PreviewGenerationInProgressException),
    ServiceTemporarilyUnavailableException(crate::error::ServiceTemporarilyUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateExclusionsPreviewError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateExclusionsPreviewErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateExclusionsPreviewErrorKind::InternalException(_inner) => _inner.fmt(f),
            CreateExclusionsPreviewErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateExclusionsPreviewErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            CreateExclusionsPreviewErrorKind::PreviewGenerationInProgressException(_inner) => {
                _inner.fmt(f)
            }
            CreateExclusionsPreviewErrorKind::ServiceTemporarilyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            CreateExclusionsPreviewErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateExclusionsPreviewError {
    fn code(&self) -> Option<&str> {
        CreateExclusionsPreviewError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateExclusionsPreviewError {
    pub fn new(kind: CreateExclusionsPreviewErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateExclusionsPreviewErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateExclusionsPreviewErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateExclusionsPreviewErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateExclusionsPreviewErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateExclusionsPreviewErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateExclusionsPreviewErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_preview_generation_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateExclusionsPreviewErrorKind::PreviewGenerationInProgressException(_)
        )
    }
    pub fn is_service_temporarily_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateExclusionsPreviewErrorKind::ServiceTemporarilyUnavailableException(_)
        )
    }
}
impl std::error::Error for CreateExclusionsPreviewError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateExclusionsPreviewErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateExclusionsPreviewErrorKind::InternalException(_inner) => Some(_inner),
            CreateExclusionsPreviewErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateExclusionsPreviewErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            CreateExclusionsPreviewErrorKind::PreviewGenerationInProgressException(_inner) => {
                Some(_inner)
            }
            CreateExclusionsPreviewErrorKind::ServiceTemporarilyUnavailableException(_inner) => {
                Some(_inner)
            }
            CreateExclusionsPreviewErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateResourceGroupError {
    pub kind: CreateResourceGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateResourceGroupErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalException(crate::error::InternalException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    ServiceTemporarilyUnavailableException(crate::error::ServiceTemporarilyUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateResourceGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateResourceGroupErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateResourceGroupErrorKind::InternalException(_inner) => _inner.fmt(f),
            CreateResourceGroupErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateResourceGroupErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateResourceGroupErrorKind::ServiceTemporarilyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            CreateResourceGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateResourceGroupError {
    fn code(&self) -> Option<&str> {
        CreateResourceGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateResourceGroupError {
    pub fn new(kind: CreateResourceGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateResourceGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateResourceGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResourceGroupErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResourceGroupErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResourceGroupErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResourceGroupErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_service_temporarily_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResourceGroupErrorKind::ServiceTemporarilyUnavailableException(_)
        )
    }
}
impl std::error::Error for CreateResourceGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateResourceGroupErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateResourceGroupErrorKind::InternalException(_inner) => Some(_inner),
            CreateResourceGroupErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateResourceGroupErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateResourceGroupErrorKind::ServiceTemporarilyUnavailableException(_inner) => {
                Some(_inner)
            }
            CreateResourceGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAssessmentRunError {
    pub kind: DeleteAssessmentRunErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAssessmentRunErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AssessmentRunInProgressException(crate::error::AssessmentRunInProgressException),
    InternalException(crate::error::InternalException),
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceTemporarilyUnavailableException(crate::error::ServiceTemporarilyUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAssessmentRunError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAssessmentRunErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteAssessmentRunErrorKind::AssessmentRunInProgressException(_inner) => _inner.fmt(f),
            DeleteAssessmentRunErrorKind::InternalException(_inner) => _inner.fmt(f),
            DeleteAssessmentRunErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteAssessmentRunErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            DeleteAssessmentRunErrorKind::ServiceTemporarilyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DeleteAssessmentRunErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAssessmentRunError {
    fn code(&self) -> Option<&str> {
        DeleteAssessmentRunError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAssessmentRunError {
    pub fn new(kind: DeleteAssessmentRunErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAssessmentRunErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAssessmentRunErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAssessmentRunErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_assessment_run_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAssessmentRunErrorKind::AssessmentRunInProgressException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAssessmentRunErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAssessmentRunErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAssessmentRunErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_temporarily_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAssessmentRunErrorKind::ServiceTemporarilyUnavailableException(_)
        )
    }
}
impl std::error::Error for DeleteAssessmentRunError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAssessmentRunErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteAssessmentRunErrorKind::AssessmentRunInProgressException(_inner) => Some(_inner),
            DeleteAssessmentRunErrorKind::InternalException(_inner) => Some(_inner),
            DeleteAssessmentRunErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteAssessmentRunErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            DeleteAssessmentRunErrorKind::ServiceTemporarilyUnavailableException(_inner) => {
                Some(_inner)
            }
            DeleteAssessmentRunErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAssessmentTargetError {
    pub kind: DeleteAssessmentTargetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAssessmentTargetErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AssessmentRunInProgressException(crate::error::AssessmentRunInProgressException),
    InternalException(crate::error::InternalException),
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceTemporarilyUnavailableException(crate::error::ServiceTemporarilyUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAssessmentTargetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAssessmentTargetErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteAssessmentTargetErrorKind::AssessmentRunInProgressException(_inner) => {
                _inner.fmt(f)
            }
            DeleteAssessmentTargetErrorKind::InternalException(_inner) => _inner.fmt(f),
            DeleteAssessmentTargetErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteAssessmentTargetErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            DeleteAssessmentTargetErrorKind::ServiceTemporarilyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DeleteAssessmentTargetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAssessmentTargetError {
    fn code(&self) -> Option<&str> {
        DeleteAssessmentTargetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAssessmentTargetError {
    pub fn new(kind: DeleteAssessmentTargetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAssessmentTargetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAssessmentTargetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAssessmentTargetErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_assessment_run_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAssessmentTargetErrorKind::AssessmentRunInProgressException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAssessmentTargetErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAssessmentTargetErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAssessmentTargetErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_temporarily_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAssessmentTargetErrorKind::ServiceTemporarilyUnavailableException(_)
        )
    }
}
impl std::error::Error for DeleteAssessmentTargetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAssessmentTargetErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteAssessmentTargetErrorKind::AssessmentRunInProgressException(_inner) => {
                Some(_inner)
            }
            DeleteAssessmentTargetErrorKind::InternalException(_inner) => Some(_inner),
            DeleteAssessmentTargetErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteAssessmentTargetErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            DeleteAssessmentTargetErrorKind::ServiceTemporarilyUnavailableException(_inner) => {
                Some(_inner)
            }
            DeleteAssessmentTargetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAssessmentTemplateError {
    pub kind: DeleteAssessmentTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAssessmentTemplateErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AssessmentRunInProgressException(crate::error::AssessmentRunInProgressException),
    InternalException(crate::error::InternalException),
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceTemporarilyUnavailableException(crate::error::ServiceTemporarilyUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAssessmentTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAssessmentTemplateErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteAssessmentTemplateErrorKind::AssessmentRunInProgressException(_inner) => {
                _inner.fmt(f)
            }
            DeleteAssessmentTemplateErrorKind::InternalException(_inner) => _inner.fmt(f),
            DeleteAssessmentTemplateErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteAssessmentTemplateErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            DeleteAssessmentTemplateErrorKind::ServiceTemporarilyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DeleteAssessmentTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAssessmentTemplateError {
    fn code(&self) -> Option<&str> {
        DeleteAssessmentTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAssessmentTemplateError {
    pub fn new(kind: DeleteAssessmentTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAssessmentTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAssessmentTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAssessmentTemplateErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_assessment_run_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAssessmentTemplateErrorKind::AssessmentRunInProgressException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAssessmentTemplateErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAssessmentTemplateErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAssessmentTemplateErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_temporarily_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAssessmentTemplateErrorKind::ServiceTemporarilyUnavailableException(_)
        )
    }
}
impl std::error::Error for DeleteAssessmentTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAssessmentTemplateErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteAssessmentTemplateErrorKind::AssessmentRunInProgressException(_inner) => {
                Some(_inner)
            }
            DeleteAssessmentTemplateErrorKind::InternalException(_inner) => Some(_inner),
            DeleteAssessmentTemplateErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteAssessmentTemplateErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            DeleteAssessmentTemplateErrorKind::ServiceTemporarilyUnavailableException(_inner) => {
                Some(_inner)
            }
            DeleteAssessmentTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAssessmentRunsError {
    pub kind: DescribeAssessmentRunsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAssessmentRunsErrorKind {
    InternalException(crate::error::InternalException),
    InvalidInputException(crate::error::InvalidInputException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAssessmentRunsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAssessmentRunsErrorKind::InternalException(_inner) => _inner.fmt(f),
            DescribeAssessmentRunsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DescribeAssessmentRunsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAssessmentRunsError {
    fn code(&self) -> Option<&str> {
        DescribeAssessmentRunsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAssessmentRunsError {
    pub fn new(kind: DescribeAssessmentRunsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAssessmentRunsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAssessmentRunsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAssessmentRunsErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAssessmentRunsErrorKind::InvalidInputException(_)
        )
    }
}
impl std::error::Error for DescribeAssessmentRunsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAssessmentRunsErrorKind::InternalException(_inner) => Some(_inner),
            DescribeAssessmentRunsErrorKind::InvalidInputException(_inner) => Some(_inner),
            DescribeAssessmentRunsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAssessmentTargetsError {
    pub kind: DescribeAssessmentTargetsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAssessmentTargetsErrorKind {
    InternalException(crate::error::InternalException),
    InvalidInputException(crate::error::InvalidInputException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAssessmentTargetsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAssessmentTargetsErrorKind::InternalException(_inner) => _inner.fmt(f),
            DescribeAssessmentTargetsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DescribeAssessmentTargetsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAssessmentTargetsError {
    fn code(&self) -> Option<&str> {
        DescribeAssessmentTargetsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAssessmentTargetsError {
    pub fn new(kind: DescribeAssessmentTargetsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAssessmentTargetsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAssessmentTargetsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAssessmentTargetsErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAssessmentTargetsErrorKind::InvalidInputException(_)
        )
    }
}
impl std::error::Error for DescribeAssessmentTargetsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAssessmentTargetsErrorKind::InternalException(_inner) => Some(_inner),
            DescribeAssessmentTargetsErrorKind::InvalidInputException(_inner) => Some(_inner),
            DescribeAssessmentTargetsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAssessmentTemplatesError {
    pub kind: DescribeAssessmentTemplatesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAssessmentTemplatesErrorKind {
    InternalException(crate::error::InternalException),
    InvalidInputException(crate::error::InvalidInputException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAssessmentTemplatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAssessmentTemplatesErrorKind::InternalException(_inner) => _inner.fmt(f),
            DescribeAssessmentTemplatesErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DescribeAssessmentTemplatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAssessmentTemplatesError {
    fn code(&self) -> Option<&str> {
        DescribeAssessmentTemplatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAssessmentTemplatesError {
    pub fn new(kind: DescribeAssessmentTemplatesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAssessmentTemplatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAssessmentTemplatesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAssessmentTemplatesErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAssessmentTemplatesErrorKind::InvalidInputException(_)
        )
    }
}
impl std::error::Error for DescribeAssessmentTemplatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAssessmentTemplatesErrorKind::InternalException(_inner) => Some(_inner),
            DescribeAssessmentTemplatesErrorKind::InvalidInputException(_inner) => Some(_inner),
            DescribeAssessmentTemplatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeCrossAccountAccessRoleError {
    pub kind: DescribeCrossAccountAccessRoleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeCrossAccountAccessRoleErrorKind {
    InternalException(crate::error::InternalException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeCrossAccountAccessRoleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeCrossAccountAccessRoleErrorKind::InternalException(_inner) => _inner.fmt(f),
            DescribeCrossAccountAccessRoleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeCrossAccountAccessRoleError {
    fn code(&self) -> Option<&str> {
        DescribeCrossAccountAccessRoleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeCrossAccountAccessRoleError {
    pub fn new(kind: DescribeCrossAccountAccessRoleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeCrossAccountAccessRoleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeCrossAccountAccessRoleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCrossAccountAccessRoleErrorKind::InternalException(_)
        )
    }
}
impl std::error::Error for DescribeCrossAccountAccessRoleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeCrossAccountAccessRoleErrorKind::InternalException(_inner) => Some(_inner),
            DescribeCrossAccountAccessRoleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeExclusionsError {
    pub kind: DescribeExclusionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeExclusionsErrorKind {
    InternalException(crate::error::InternalException),
    InvalidInputException(crate::error::InvalidInputException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeExclusionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeExclusionsErrorKind::InternalException(_inner) => _inner.fmt(f),
            DescribeExclusionsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DescribeExclusionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeExclusionsError {
    fn code(&self) -> Option<&str> {
        DescribeExclusionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeExclusionsError {
    pub fn new(kind: DescribeExclusionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeExclusionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeExclusionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeExclusionsErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeExclusionsErrorKind::InvalidInputException(_)
        )
    }
}
impl std::error::Error for DescribeExclusionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeExclusionsErrorKind::InternalException(_inner) => Some(_inner),
            DescribeExclusionsErrorKind::InvalidInputException(_inner) => Some(_inner),
            DescribeExclusionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeFindingsError {
    pub kind: DescribeFindingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeFindingsErrorKind {
    InternalException(crate::error::InternalException),
    InvalidInputException(crate::error::InvalidInputException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeFindingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeFindingsErrorKind::InternalException(_inner) => _inner.fmt(f),
            DescribeFindingsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DescribeFindingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeFindingsError {
    fn code(&self) -> Option<&str> {
        DescribeFindingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeFindingsError {
    pub fn new(kind: DescribeFindingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeFindingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeFindingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, DescribeFindingsErrorKind::InternalException(_))
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFindingsErrorKind::InvalidInputException(_)
        )
    }
}
impl std::error::Error for DescribeFindingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeFindingsErrorKind::InternalException(_inner) => Some(_inner),
            DescribeFindingsErrorKind::InvalidInputException(_inner) => Some(_inner),
            DescribeFindingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeResourceGroupsError {
    pub kind: DescribeResourceGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeResourceGroupsErrorKind {
    InternalException(crate::error::InternalException),
    InvalidInputException(crate::error::InvalidInputException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeResourceGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeResourceGroupsErrorKind::InternalException(_inner) => _inner.fmt(f),
            DescribeResourceGroupsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DescribeResourceGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeResourceGroupsError {
    fn code(&self) -> Option<&str> {
        DescribeResourceGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeResourceGroupsError {
    pub fn new(kind: DescribeResourceGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeResourceGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeResourceGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeResourceGroupsErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeResourceGroupsErrorKind::InvalidInputException(_)
        )
    }
}
impl std::error::Error for DescribeResourceGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeResourceGroupsErrorKind::InternalException(_inner) => Some(_inner),
            DescribeResourceGroupsErrorKind::InvalidInputException(_inner) => Some(_inner),
            DescribeResourceGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeRulesPackagesError {
    pub kind: DescribeRulesPackagesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeRulesPackagesErrorKind {
    InternalException(crate::error::InternalException),
    InvalidInputException(crate::error::InvalidInputException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeRulesPackagesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeRulesPackagesErrorKind::InternalException(_inner) => _inner.fmt(f),
            DescribeRulesPackagesErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DescribeRulesPackagesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeRulesPackagesError {
    fn code(&self) -> Option<&str> {
        DescribeRulesPackagesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeRulesPackagesError {
    pub fn new(kind: DescribeRulesPackagesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeRulesPackagesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeRulesPackagesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRulesPackagesErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRulesPackagesErrorKind::InvalidInputException(_)
        )
    }
}
impl std::error::Error for DescribeRulesPackagesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeRulesPackagesErrorKind::InternalException(_inner) => Some(_inner),
            DescribeRulesPackagesErrorKind::InvalidInputException(_inner) => Some(_inner),
            DescribeRulesPackagesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAssessmentReportError {
    pub kind: GetAssessmentReportErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAssessmentReportErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AssessmentRunInProgressException(crate::error::AssessmentRunInProgressException),
    InternalException(crate::error::InternalException),
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceTemporarilyUnavailableException(crate::error::ServiceTemporarilyUnavailableException),
    UnsupportedFeatureException(crate::error::UnsupportedFeatureException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAssessmentReportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAssessmentReportErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetAssessmentReportErrorKind::AssessmentRunInProgressException(_inner) => _inner.fmt(f),
            GetAssessmentReportErrorKind::InternalException(_inner) => _inner.fmt(f),
            GetAssessmentReportErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetAssessmentReportErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            GetAssessmentReportErrorKind::ServiceTemporarilyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            GetAssessmentReportErrorKind::UnsupportedFeatureException(_inner) => _inner.fmt(f),
            GetAssessmentReportErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAssessmentReportError {
    fn code(&self) -> Option<&str> {
        GetAssessmentReportError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAssessmentReportError {
    pub fn new(kind: GetAssessmentReportErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAssessmentReportErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAssessmentReportErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAssessmentReportErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_assessment_run_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAssessmentReportErrorKind::AssessmentRunInProgressException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAssessmentReportErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAssessmentReportErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAssessmentReportErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_temporarily_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAssessmentReportErrorKind::ServiceTemporarilyUnavailableException(_)
        )
    }
    pub fn is_unsupported_feature_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAssessmentReportErrorKind::UnsupportedFeatureException(_)
        )
    }
}
impl std::error::Error for GetAssessmentReportError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAssessmentReportErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetAssessmentReportErrorKind::AssessmentRunInProgressException(_inner) => Some(_inner),
            GetAssessmentReportErrorKind::InternalException(_inner) => Some(_inner),
            GetAssessmentReportErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetAssessmentReportErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            GetAssessmentReportErrorKind::ServiceTemporarilyUnavailableException(_inner) => {
                Some(_inner)
            }
            GetAssessmentReportErrorKind::UnsupportedFeatureException(_inner) => Some(_inner),
            GetAssessmentReportErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetExclusionsPreviewError {
    pub kind: GetExclusionsPreviewErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetExclusionsPreviewErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalException(crate::error::InternalException),
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetExclusionsPreviewError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetExclusionsPreviewErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetExclusionsPreviewErrorKind::InternalException(_inner) => _inner.fmt(f),
            GetExclusionsPreviewErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetExclusionsPreviewErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            GetExclusionsPreviewErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetExclusionsPreviewError {
    fn code(&self) -> Option<&str> {
        GetExclusionsPreviewError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetExclusionsPreviewError {
    pub fn new(kind: GetExclusionsPreviewErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetExclusionsPreviewErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetExclusionsPreviewErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetExclusionsPreviewErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetExclusionsPreviewErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetExclusionsPreviewErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetExclusionsPreviewErrorKind::NoSuchEntityException(_)
        )
    }
}
impl std::error::Error for GetExclusionsPreviewError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetExclusionsPreviewErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetExclusionsPreviewErrorKind::InternalException(_inner) => Some(_inner),
            GetExclusionsPreviewErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetExclusionsPreviewErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            GetExclusionsPreviewErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetTelemetryMetadataError {
    pub kind: GetTelemetryMetadataErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetTelemetryMetadataErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalException(crate::error::InternalException),
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetTelemetryMetadataError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetTelemetryMetadataErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetTelemetryMetadataErrorKind::InternalException(_inner) => _inner.fmt(f),
            GetTelemetryMetadataErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetTelemetryMetadataErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            GetTelemetryMetadataErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetTelemetryMetadataError {
    fn code(&self) -> Option<&str> {
        GetTelemetryMetadataError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetTelemetryMetadataError {
    pub fn new(kind: GetTelemetryMetadataErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetTelemetryMetadataErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetTelemetryMetadataErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTelemetryMetadataErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTelemetryMetadataErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTelemetryMetadataErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTelemetryMetadataErrorKind::NoSuchEntityException(_)
        )
    }
}
impl std::error::Error for GetTelemetryMetadataError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetTelemetryMetadataErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetTelemetryMetadataErrorKind::InternalException(_inner) => Some(_inner),
            GetTelemetryMetadataErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetTelemetryMetadataErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            GetTelemetryMetadataErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAssessmentRunAgentsError {
    pub kind: ListAssessmentRunAgentsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAssessmentRunAgentsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalException(crate::error::InternalException),
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAssessmentRunAgentsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAssessmentRunAgentsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListAssessmentRunAgentsErrorKind::InternalException(_inner) => _inner.fmt(f),
            ListAssessmentRunAgentsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ListAssessmentRunAgentsErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            ListAssessmentRunAgentsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAssessmentRunAgentsError {
    fn code(&self) -> Option<&str> {
        ListAssessmentRunAgentsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAssessmentRunAgentsError {
    pub fn new(kind: ListAssessmentRunAgentsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAssessmentRunAgentsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAssessmentRunAgentsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAssessmentRunAgentsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAssessmentRunAgentsErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAssessmentRunAgentsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAssessmentRunAgentsErrorKind::NoSuchEntityException(_)
        )
    }
}
impl std::error::Error for ListAssessmentRunAgentsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAssessmentRunAgentsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListAssessmentRunAgentsErrorKind::InternalException(_inner) => Some(_inner),
            ListAssessmentRunAgentsErrorKind::InvalidInputException(_inner) => Some(_inner),
            ListAssessmentRunAgentsErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            ListAssessmentRunAgentsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAssessmentRunsError {
    pub kind: ListAssessmentRunsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAssessmentRunsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalException(crate::error::InternalException),
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAssessmentRunsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAssessmentRunsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListAssessmentRunsErrorKind::InternalException(_inner) => _inner.fmt(f),
            ListAssessmentRunsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ListAssessmentRunsErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            ListAssessmentRunsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAssessmentRunsError {
    fn code(&self) -> Option<&str> {
        ListAssessmentRunsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAssessmentRunsError {
    pub fn new(kind: ListAssessmentRunsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAssessmentRunsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAssessmentRunsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAssessmentRunsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAssessmentRunsErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAssessmentRunsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAssessmentRunsErrorKind::NoSuchEntityException(_)
        )
    }
}
impl std::error::Error for ListAssessmentRunsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAssessmentRunsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListAssessmentRunsErrorKind::InternalException(_inner) => Some(_inner),
            ListAssessmentRunsErrorKind::InvalidInputException(_inner) => Some(_inner),
            ListAssessmentRunsErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            ListAssessmentRunsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAssessmentTargetsError {
    pub kind: ListAssessmentTargetsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAssessmentTargetsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalException(crate::error::InternalException),
    InvalidInputException(crate::error::InvalidInputException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAssessmentTargetsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAssessmentTargetsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListAssessmentTargetsErrorKind::InternalException(_inner) => _inner.fmt(f),
            ListAssessmentTargetsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ListAssessmentTargetsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAssessmentTargetsError {
    fn code(&self) -> Option<&str> {
        ListAssessmentTargetsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAssessmentTargetsError {
    pub fn new(kind: ListAssessmentTargetsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAssessmentTargetsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAssessmentTargetsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAssessmentTargetsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAssessmentTargetsErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAssessmentTargetsErrorKind::InvalidInputException(_)
        )
    }
}
impl std::error::Error for ListAssessmentTargetsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAssessmentTargetsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListAssessmentTargetsErrorKind::InternalException(_inner) => Some(_inner),
            ListAssessmentTargetsErrorKind::InvalidInputException(_inner) => Some(_inner),
            ListAssessmentTargetsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAssessmentTemplatesError {
    pub kind: ListAssessmentTemplatesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAssessmentTemplatesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalException(crate::error::InternalException),
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAssessmentTemplatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAssessmentTemplatesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListAssessmentTemplatesErrorKind::InternalException(_inner) => _inner.fmt(f),
            ListAssessmentTemplatesErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ListAssessmentTemplatesErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            ListAssessmentTemplatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAssessmentTemplatesError {
    fn code(&self) -> Option<&str> {
        ListAssessmentTemplatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAssessmentTemplatesError {
    pub fn new(kind: ListAssessmentTemplatesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAssessmentTemplatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAssessmentTemplatesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAssessmentTemplatesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAssessmentTemplatesErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAssessmentTemplatesErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAssessmentTemplatesErrorKind::NoSuchEntityException(_)
        )
    }
}
impl std::error::Error for ListAssessmentTemplatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAssessmentTemplatesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListAssessmentTemplatesErrorKind::InternalException(_inner) => Some(_inner),
            ListAssessmentTemplatesErrorKind::InvalidInputException(_inner) => Some(_inner),
            ListAssessmentTemplatesErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            ListAssessmentTemplatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListEventSubscriptionsError {
    pub kind: ListEventSubscriptionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListEventSubscriptionsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalException(crate::error::InternalException),
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListEventSubscriptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListEventSubscriptionsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListEventSubscriptionsErrorKind::InternalException(_inner) => _inner.fmt(f),
            ListEventSubscriptionsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ListEventSubscriptionsErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            ListEventSubscriptionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListEventSubscriptionsError {
    fn code(&self) -> Option<&str> {
        ListEventSubscriptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListEventSubscriptionsError {
    pub fn new(kind: ListEventSubscriptionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListEventSubscriptionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListEventSubscriptionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEventSubscriptionsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEventSubscriptionsErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEventSubscriptionsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEventSubscriptionsErrorKind::NoSuchEntityException(_)
        )
    }
}
impl std::error::Error for ListEventSubscriptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListEventSubscriptionsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListEventSubscriptionsErrorKind::InternalException(_inner) => Some(_inner),
            ListEventSubscriptionsErrorKind::InvalidInputException(_inner) => Some(_inner),
            ListEventSubscriptionsErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            ListEventSubscriptionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListExclusionsError {
    pub kind: ListExclusionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListExclusionsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalException(crate::error::InternalException),
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListExclusionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListExclusionsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListExclusionsErrorKind::InternalException(_inner) => _inner.fmt(f),
            ListExclusionsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ListExclusionsErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            ListExclusionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListExclusionsError {
    fn code(&self) -> Option<&str> {
        ListExclusionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListExclusionsError {
    pub fn new(kind: ListExclusionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListExclusionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListExclusionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListExclusionsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, ListExclusionsErrorKind::InternalException(_))
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListExclusionsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListExclusionsErrorKind::NoSuchEntityException(_)
        )
    }
}
impl std::error::Error for ListExclusionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListExclusionsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListExclusionsErrorKind::InternalException(_inner) => Some(_inner),
            ListExclusionsErrorKind::InvalidInputException(_inner) => Some(_inner),
            ListExclusionsErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            ListExclusionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListFindingsError {
    pub kind: ListFindingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListFindingsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalException(crate::error::InternalException),
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListFindingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListFindingsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListFindingsErrorKind::InternalException(_inner) => _inner.fmt(f),
            ListFindingsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ListFindingsErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            ListFindingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListFindingsError {
    fn code(&self) -> Option<&str> {
        ListFindingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListFindingsError {
    pub fn new(kind: ListFindingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListFindingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListFindingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListFindingsErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, ListFindingsErrorKind::InternalException(_))
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, ListFindingsErrorKind::InvalidInputException(_))
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(&self.kind, ListFindingsErrorKind::NoSuchEntityException(_))
    }
}
impl std::error::Error for ListFindingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListFindingsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListFindingsErrorKind::InternalException(_inner) => Some(_inner),
            ListFindingsErrorKind::InvalidInputException(_inner) => Some(_inner),
            ListFindingsErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            ListFindingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListRulesPackagesError {
    pub kind: ListRulesPackagesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRulesPackagesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalException(crate::error::InternalException),
    InvalidInputException(crate::error::InvalidInputException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListRulesPackagesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListRulesPackagesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListRulesPackagesErrorKind::InternalException(_inner) => _inner.fmt(f),
            ListRulesPackagesErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ListRulesPackagesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListRulesPackagesError {
    fn code(&self) -> Option<&str> {
        ListRulesPackagesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRulesPackagesError {
    pub fn new(kind: ListRulesPackagesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListRulesPackagesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListRulesPackagesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRulesPackagesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, ListRulesPackagesErrorKind::InternalException(_))
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRulesPackagesErrorKind::InvalidInputException(_)
        )
    }
}
impl std::error::Error for ListRulesPackagesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListRulesPackagesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListRulesPackagesErrorKind::InternalException(_inner) => Some(_inner),
            ListRulesPackagesErrorKind::InvalidInputException(_inner) => Some(_inner),
            ListRulesPackagesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalException(crate::error::InternalException),
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InternalException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::NoSuchEntityException(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InternalException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InvalidInputException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PreviewAgentsError {
    pub kind: PreviewAgentsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PreviewAgentsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalException(crate::error::InternalException),
    InvalidCrossAccountRoleException(crate::error::InvalidCrossAccountRoleException),
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PreviewAgentsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PreviewAgentsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            PreviewAgentsErrorKind::InternalException(_inner) => _inner.fmt(f),
            PreviewAgentsErrorKind::InvalidCrossAccountRoleException(_inner) => _inner.fmt(f),
            PreviewAgentsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            PreviewAgentsErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            PreviewAgentsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PreviewAgentsError {
    fn code(&self) -> Option<&str> {
        PreviewAgentsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PreviewAgentsError {
    pub fn new(kind: PreviewAgentsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PreviewAgentsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PreviewAgentsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, PreviewAgentsErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, PreviewAgentsErrorKind::InternalException(_))
    }
    pub fn is_invalid_cross_account_role_exception(&self) -> bool {
        matches!(
            &self.kind,
            PreviewAgentsErrorKind::InvalidCrossAccountRoleException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, PreviewAgentsErrorKind::InvalidInputException(_))
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(&self.kind, PreviewAgentsErrorKind::NoSuchEntityException(_))
    }
}
impl std::error::Error for PreviewAgentsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PreviewAgentsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            PreviewAgentsErrorKind::InternalException(_inner) => Some(_inner),
            PreviewAgentsErrorKind::InvalidCrossAccountRoleException(_inner) => Some(_inner),
            PreviewAgentsErrorKind::InvalidInputException(_inner) => Some(_inner),
            PreviewAgentsErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            PreviewAgentsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RegisterCrossAccountAccessRoleError {
    pub kind: RegisterCrossAccountAccessRoleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterCrossAccountAccessRoleErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalException(crate::error::InternalException),
    InvalidCrossAccountRoleException(crate::error::InvalidCrossAccountRoleException),
    InvalidInputException(crate::error::InvalidInputException),
    ServiceTemporarilyUnavailableException(crate::error::ServiceTemporarilyUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RegisterCrossAccountAccessRoleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RegisterCrossAccountAccessRoleErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            RegisterCrossAccountAccessRoleErrorKind::InternalException(_inner) => _inner.fmt(f),
            RegisterCrossAccountAccessRoleErrorKind::InvalidCrossAccountRoleException(_inner) => {
                _inner.fmt(f)
            }
            RegisterCrossAccountAccessRoleErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            RegisterCrossAccountAccessRoleErrorKind::ServiceTemporarilyUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            RegisterCrossAccountAccessRoleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RegisterCrossAccountAccessRoleError {
    fn code(&self) -> Option<&str> {
        RegisterCrossAccountAccessRoleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterCrossAccountAccessRoleError {
    pub fn new(kind: RegisterCrossAccountAccessRoleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RegisterCrossAccountAccessRoleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RegisterCrossAccountAccessRoleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCrossAccountAccessRoleErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCrossAccountAccessRoleErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_cross_account_role_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCrossAccountAccessRoleErrorKind::InvalidCrossAccountRoleException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCrossAccountAccessRoleErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_service_temporarily_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCrossAccountAccessRoleErrorKind::ServiceTemporarilyUnavailableException(_)
        )
    }
}
impl std::error::Error for RegisterCrossAccountAccessRoleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RegisterCrossAccountAccessRoleErrorKind::AccessDeniedException(_inner) => Some(_inner),
            RegisterCrossAccountAccessRoleErrorKind::InternalException(_inner) => Some(_inner),
            RegisterCrossAccountAccessRoleErrorKind::InvalidCrossAccountRoleException(_inner) => {
                Some(_inner)
            }
            RegisterCrossAccountAccessRoleErrorKind::InvalidInputException(_inner) => Some(_inner),
            RegisterCrossAccountAccessRoleErrorKind::ServiceTemporarilyUnavailableException(
                _inner,
            ) => Some(_inner),
            RegisterCrossAccountAccessRoleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveAttributesFromFindingsError {
    pub kind: RemoveAttributesFromFindingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveAttributesFromFindingsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalException(crate::error::InternalException),
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceTemporarilyUnavailableException(crate::error::ServiceTemporarilyUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveAttributesFromFindingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemoveAttributesFromFindingsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            RemoveAttributesFromFindingsErrorKind::InternalException(_inner) => _inner.fmt(f),
            RemoveAttributesFromFindingsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            RemoveAttributesFromFindingsErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            RemoveAttributesFromFindingsErrorKind::ServiceTemporarilyUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            RemoveAttributesFromFindingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RemoveAttributesFromFindingsError {
    fn code(&self) -> Option<&str> {
        RemoveAttributesFromFindingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveAttributesFromFindingsError {
    pub fn new(kind: RemoveAttributesFromFindingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemoveAttributesFromFindingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemoveAttributesFromFindingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveAttributesFromFindingsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveAttributesFromFindingsErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveAttributesFromFindingsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveAttributesFromFindingsErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_temporarily_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveAttributesFromFindingsErrorKind::ServiceTemporarilyUnavailableException(_)
        )
    }
}
impl std::error::Error for RemoveAttributesFromFindingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemoveAttributesFromFindingsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            RemoveAttributesFromFindingsErrorKind::InternalException(_inner) => Some(_inner),
            RemoveAttributesFromFindingsErrorKind::InvalidInputException(_inner) => Some(_inner),
            RemoveAttributesFromFindingsErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            RemoveAttributesFromFindingsErrorKind::ServiceTemporarilyUnavailableException(
                _inner,
            ) => Some(_inner),
            RemoveAttributesFromFindingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetTagsForResourceError {
    pub kind: SetTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetTagsForResourceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalException(crate::error::InternalException),
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceTemporarilyUnavailableException(crate::error::ServiceTemporarilyUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SetTagsForResourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            SetTagsForResourceErrorKind::InternalException(_inner) => _inner.fmt(f),
            SetTagsForResourceErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            SetTagsForResourceErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            SetTagsForResourceErrorKind::ServiceTemporarilyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            SetTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SetTagsForResourceError {
    fn code(&self) -> Option<&str> {
        SetTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SetTagsForResourceError {
    pub fn new(kind: SetTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SetTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SetTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetTagsForResourceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetTagsForResourceErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetTagsForResourceErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetTagsForResourceErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_temporarily_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetTagsForResourceErrorKind::ServiceTemporarilyUnavailableException(_)
        )
    }
}
impl std::error::Error for SetTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SetTagsForResourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            SetTagsForResourceErrorKind::InternalException(_inner) => Some(_inner),
            SetTagsForResourceErrorKind::InvalidInputException(_inner) => Some(_inner),
            SetTagsForResourceErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            SetTagsForResourceErrorKind::ServiceTemporarilyUnavailableException(_inner) => {
                Some(_inner)
            }
            SetTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartAssessmentRunError {
    pub kind: StartAssessmentRunErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartAssessmentRunErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AgentsAlreadyRunningAssessmentException(crate::error::AgentsAlreadyRunningAssessmentException),
    InternalException(crate::error::InternalException),
    InvalidCrossAccountRoleException(crate::error::InvalidCrossAccountRoleException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceTemporarilyUnavailableException(crate::error::ServiceTemporarilyUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartAssessmentRunError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartAssessmentRunErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            StartAssessmentRunErrorKind::AgentsAlreadyRunningAssessmentException(_inner) => {
                _inner.fmt(f)
            }
            StartAssessmentRunErrorKind::InternalException(_inner) => _inner.fmt(f),
            StartAssessmentRunErrorKind::InvalidCrossAccountRoleException(_inner) => _inner.fmt(f),
            StartAssessmentRunErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            StartAssessmentRunErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StartAssessmentRunErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            StartAssessmentRunErrorKind::ServiceTemporarilyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            StartAssessmentRunErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartAssessmentRunError {
    fn code(&self) -> Option<&str> {
        StartAssessmentRunError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartAssessmentRunError {
    pub fn new(kind: StartAssessmentRunErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartAssessmentRunErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartAssessmentRunErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartAssessmentRunErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_agents_already_running_assessment_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartAssessmentRunErrorKind::AgentsAlreadyRunningAssessmentException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartAssessmentRunErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_cross_account_role_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartAssessmentRunErrorKind::InvalidCrossAccountRoleException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartAssessmentRunErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartAssessmentRunErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartAssessmentRunErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_temporarily_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartAssessmentRunErrorKind::ServiceTemporarilyUnavailableException(_)
        )
    }
}
impl std::error::Error for StartAssessmentRunError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartAssessmentRunErrorKind::AccessDeniedException(_inner) => Some(_inner),
            StartAssessmentRunErrorKind::AgentsAlreadyRunningAssessmentException(_inner) => {
                Some(_inner)
            }
            StartAssessmentRunErrorKind::InternalException(_inner) => Some(_inner),
            StartAssessmentRunErrorKind::InvalidCrossAccountRoleException(_inner) => Some(_inner),
            StartAssessmentRunErrorKind::InvalidInputException(_inner) => Some(_inner),
            StartAssessmentRunErrorKind::LimitExceededException(_inner) => Some(_inner),
            StartAssessmentRunErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            StartAssessmentRunErrorKind::ServiceTemporarilyUnavailableException(_inner) => {
                Some(_inner)
            }
            StartAssessmentRunErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopAssessmentRunError {
    pub kind: StopAssessmentRunErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopAssessmentRunErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalException(crate::error::InternalException),
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceTemporarilyUnavailableException(crate::error::ServiceTemporarilyUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopAssessmentRunError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopAssessmentRunErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            StopAssessmentRunErrorKind::InternalException(_inner) => _inner.fmt(f),
            StopAssessmentRunErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            StopAssessmentRunErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            StopAssessmentRunErrorKind::ServiceTemporarilyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            StopAssessmentRunErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopAssessmentRunError {
    fn code(&self) -> Option<&str> {
        StopAssessmentRunError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopAssessmentRunError {
    pub fn new(kind: StopAssessmentRunErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopAssessmentRunErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopAssessmentRunErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopAssessmentRunErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, StopAssessmentRunErrorKind::InternalException(_))
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopAssessmentRunErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopAssessmentRunErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_temporarily_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopAssessmentRunErrorKind::ServiceTemporarilyUnavailableException(_)
        )
    }
}
impl std::error::Error for StopAssessmentRunError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopAssessmentRunErrorKind::AccessDeniedException(_inner) => Some(_inner),
            StopAssessmentRunErrorKind::InternalException(_inner) => Some(_inner),
            StopAssessmentRunErrorKind::InvalidInputException(_inner) => Some(_inner),
            StopAssessmentRunErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            StopAssessmentRunErrorKind::ServiceTemporarilyUnavailableException(_inner) => {
                Some(_inner)
            }
            StopAssessmentRunErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SubscribeToEventError {
    pub kind: SubscribeToEventErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SubscribeToEventErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalException(crate::error::InternalException),
    InvalidInputException(crate::error::InvalidInputException),
    LimitExceededException(crate::error::LimitExceededException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceTemporarilyUnavailableException(crate::error::ServiceTemporarilyUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SubscribeToEventError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SubscribeToEventErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            SubscribeToEventErrorKind::InternalException(_inner) => _inner.fmt(f),
            SubscribeToEventErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            SubscribeToEventErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            SubscribeToEventErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            SubscribeToEventErrorKind::ServiceTemporarilyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            SubscribeToEventErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SubscribeToEventError {
    fn code(&self) -> Option<&str> {
        SubscribeToEventError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SubscribeToEventError {
    pub fn new(kind: SubscribeToEventErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SubscribeToEventErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SubscribeToEventErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            SubscribeToEventErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, SubscribeToEventErrorKind::InternalException(_))
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            SubscribeToEventErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            SubscribeToEventErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            SubscribeToEventErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_temporarily_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            SubscribeToEventErrorKind::ServiceTemporarilyUnavailableException(_)
        )
    }
}
impl std::error::Error for SubscribeToEventError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SubscribeToEventErrorKind::AccessDeniedException(_inner) => Some(_inner),
            SubscribeToEventErrorKind::InternalException(_inner) => Some(_inner),
            SubscribeToEventErrorKind::InvalidInputException(_inner) => Some(_inner),
            SubscribeToEventErrorKind::LimitExceededException(_inner) => Some(_inner),
            SubscribeToEventErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            SubscribeToEventErrorKind::ServiceTemporarilyUnavailableException(_inner) => {
                Some(_inner)
            }
            SubscribeToEventErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UnsubscribeFromEventError {
    pub kind: UnsubscribeFromEventErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UnsubscribeFromEventErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalException(crate::error::InternalException),
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceTemporarilyUnavailableException(crate::error::ServiceTemporarilyUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UnsubscribeFromEventError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UnsubscribeFromEventErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UnsubscribeFromEventErrorKind::InternalException(_inner) => _inner.fmt(f),
            UnsubscribeFromEventErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UnsubscribeFromEventErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            UnsubscribeFromEventErrorKind::ServiceTemporarilyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            UnsubscribeFromEventErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UnsubscribeFromEventError {
    fn code(&self) -> Option<&str> {
        UnsubscribeFromEventError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UnsubscribeFromEventError {
    pub fn new(kind: UnsubscribeFromEventErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UnsubscribeFromEventErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UnsubscribeFromEventErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UnsubscribeFromEventErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            UnsubscribeFromEventErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            UnsubscribeFromEventErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            UnsubscribeFromEventErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_temporarily_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UnsubscribeFromEventErrorKind::ServiceTemporarilyUnavailableException(_)
        )
    }
}
impl std::error::Error for UnsubscribeFromEventError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UnsubscribeFromEventErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UnsubscribeFromEventErrorKind::InternalException(_inner) => Some(_inner),
            UnsubscribeFromEventErrorKind::InvalidInputException(_inner) => Some(_inner),
            UnsubscribeFromEventErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            UnsubscribeFromEventErrorKind::ServiceTemporarilyUnavailableException(_inner) => {
                Some(_inner)
            }
            UnsubscribeFromEventErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAssessmentTargetError {
    pub kind: UpdateAssessmentTargetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAssessmentTargetErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalException(crate::error::InternalException),
    InvalidInputException(crate::error::InvalidInputException),
    NoSuchEntityException(crate::error::NoSuchEntityException),
    ServiceTemporarilyUnavailableException(crate::error::ServiceTemporarilyUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAssessmentTargetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAssessmentTargetErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateAssessmentTargetErrorKind::InternalException(_inner) => _inner.fmt(f),
            UpdateAssessmentTargetErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UpdateAssessmentTargetErrorKind::NoSuchEntityException(_inner) => _inner.fmt(f),
            UpdateAssessmentTargetErrorKind::ServiceTemporarilyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            UpdateAssessmentTargetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAssessmentTargetError {
    fn code(&self) -> Option<&str> {
        UpdateAssessmentTargetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAssessmentTargetError {
    pub fn new(kind: UpdateAssessmentTargetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAssessmentTargetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAssessmentTargetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssessmentTargetErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssessmentTargetErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssessmentTargetErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_no_such_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssessmentTargetErrorKind::NoSuchEntityException(_)
        )
    }
    pub fn is_service_temporarily_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssessmentTargetErrorKind::ServiceTemporarilyUnavailableException(_)
        )
    }
}
impl std::error::Error for UpdateAssessmentTargetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAssessmentTargetErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateAssessmentTargetErrorKind::InternalException(_inner) => Some(_inner),
            UpdateAssessmentTargetErrorKind::InvalidInputException(_inner) => Some(_inner),
            UpdateAssessmentTargetErrorKind::NoSuchEntityException(_inner) => Some(_inner),
            UpdateAssessmentTargetErrorKind::ServiceTemporarilyUnavailableException(_inner) => {
                Some(_inner)
            }
            UpdateAssessmentTargetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The serice is temporary unavailable.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceTemporarilyUnavailableException {
    /// <p>Details of the exception error.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>You can wait and then retry your request.</p>
    pub can_retry: std::option::Option<bool>,
}
impl std::fmt::Debug for ServiceTemporarilyUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceTemporarilyUnavailableException");
        formatter.field("message", &self.message);
        formatter.field("can_retry", &self.can_retry);
        formatter.finish()
    }
}
impl ServiceTemporarilyUnavailableException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceTemporarilyUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceTemporarilyUnavailableException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceTemporarilyUnavailableException {}
/// See [`ServiceTemporarilyUnavailableException`](crate::error::ServiceTemporarilyUnavailableException)
pub mod service_temporarily_unavailable_exception {
    /// A builder for [`ServiceTemporarilyUnavailableException`](crate::error::ServiceTemporarilyUnavailableException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) can_retry: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Details of the exception error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>You can wait and then retry your request.</p>
        pub fn can_retry(mut self, input: bool) -> Self {
            self.can_retry = Some(input);
            self
        }
        pub fn set_can_retry(mut self, input: std::option::Option<bool>) -> Self {
            self.can_retry = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceTemporarilyUnavailableException`](crate::error::ServiceTemporarilyUnavailableException)
        pub fn build(self) -> crate::error::ServiceTemporarilyUnavailableException {
            crate::error::ServiceTemporarilyUnavailableException {
                message: self.message,
                can_retry: self.can_retry,
            }
        }
    }
}
impl ServiceTemporarilyUnavailableException {
    /// Creates a new builder-style object to manufacture [`ServiceTemporarilyUnavailableException`](crate::error::ServiceTemporarilyUnavailableException)
    pub fn builder() -> crate::error::service_temporarily_unavailable_exception::Builder {
        crate::error::service_temporarily_unavailable_exception::Builder::default()
    }
}

/// <p>The request was rejected because it referenced an entity that does not exist. The
/// error code describes the entity.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NoSuchEntityException {
    /// <p>Details of the exception error.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>Code that indicates the type of error that is generated.</p>
    pub error_code: std::option::Option<crate::model::NoSuchEntityErrorCode>,
    /// <p>You can immediately retry your request.</p>
    pub can_retry: std::option::Option<bool>,
}
impl std::fmt::Debug for NoSuchEntityException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NoSuchEntityException");
        formatter.field("message", &self.message);
        formatter.field("error_code", &self.error_code);
        formatter.field("can_retry", &self.can_retry);
        formatter.finish()
    }
}
impl NoSuchEntityException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoSuchEntityException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoSuchEntityException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for NoSuchEntityException {}
/// See [`NoSuchEntityException`](crate::error::NoSuchEntityException)
pub mod no_such_entity_exception {
    /// A builder for [`NoSuchEntityException`](crate::error::NoSuchEntityException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) error_code: std::option::Option<crate::model::NoSuchEntityErrorCode>,
        pub(crate) can_retry: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Details of the exception error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>Code that indicates the type of error that is generated.</p>
        pub fn error_code(mut self, input: crate::model::NoSuchEntityErrorCode) -> Self {
            self.error_code = Some(input);
            self
        }
        pub fn set_error_code(
            mut self,
            input: std::option::Option<crate::model::NoSuchEntityErrorCode>,
        ) -> Self {
            self.error_code = input;
            self
        }
        /// <p>You can immediately retry your request.</p>
        pub fn can_retry(mut self, input: bool) -> Self {
            self.can_retry = Some(input);
            self
        }
        pub fn set_can_retry(mut self, input: std::option::Option<bool>) -> Self {
            self.can_retry = input;
            self
        }
        /// Consumes the builder and constructs a [`NoSuchEntityException`](crate::error::NoSuchEntityException)
        pub fn build(self) -> crate::error::NoSuchEntityException {
            crate::error::NoSuchEntityException {
                message: self.message,
                error_code: self.error_code,
                can_retry: self.can_retry,
            }
        }
    }
}
impl NoSuchEntityException {
    /// Creates a new builder-style object to manufacture [`NoSuchEntityException`](crate::error::NoSuchEntityException)
    pub fn builder() -> crate::error::no_such_entity_exception::Builder {
        crate::error::no_such_entity_exception::Builder::default()
    }
}

/// <p>The request was rejected because an invalid or out-of-range value was supplied for an
/// input parameter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidInputException {
    /// <p>Details of the exception error.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>Code that indicates the type of error that is generated.</p>
    pub error_code: std::option::Option<crate::model::InvalidInputErrorCode>,
    /// <p>You can immediately retry your request.</p>
    pub can_retry: std::option::Option<bool>,
}
impl std::fmt::Debug for InvalidInputException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidInputException");
        formatter.field("message", &self.message);
        formatter.field("error_code", &self.error_code);
        formatter.field("can_retry", &self.can_retry);
        formatter.finish()
    }
}
impl InvalidInputException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidInputException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidInputException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidInputException {}
/// See [`InvalidInputException`](crate::error::InvalidInputException)
pub mod invalid_input_exception {
    /// A builder for [`InvalidInputException`](crate::error::InvalidInputException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) error_code: std::option::Option<crate::model::InvalidInputErrorCode>,
        pub(crate) can_retry: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Details of the exception error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>Code that indicates the type of error that is generated.</p>
        pub fn error_code(mut self, input: crate::model::InvalidInputErrorCode) -> Self {
            self.error_code = Some(input);
            self
        }
        pub fn set_error_code(
            mut self,
            input: std::option::Option<crate::model::InvalidInputErrorCode>,
        ) -> Self {
            self.error_code = input;
            self
        }
        /// <p>You can immediately retry your request.</p>
        pub fn can_retry(mut self, input: bool) -> Self {
            self.can_retry = Some(input);
            self
        }
        pub fn set_can_retry(mut self, input: std::option::Option<bool>) -> Self {
            self.can_retry = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidInputException`](crate::error::InvalidInputException)
        pub fn build(self) -> crate::error::InvalidInputException {
            crate::error::InvalidInputException {
                message: self.message,
                error_code: self.error_code,
                can_retry: self.can_retry,
            }
        }
    }
}
impl InvalidInputException {
    /// Creates a new builder-style object to manufacture [`InvalidInputException`](crate::error::InvalidInputException)
    pub fn builder() -> crate::error::invalid_input_exception::Builder {
        crate::error::invalid_input_exception::Builder::default()
    }
}

/// <p>Internal server error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalException {
    /// <p>Details of the exception error.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>You can immediately retry your request.</p>
    pub can_retry: std::option::Option<bool>,
}
impl std::fmt::Debug for InternalException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalException");
        formatter.field("message", &self.message);
        formatter.field("can_retry", &self.can_retry);
        formatter.finish()
    }
}
impl InternalException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalException {}
/// See [`InternalException`](crate::error::InternalException)
pub mod internal_exception {
    /// A builder for [`InternalException`](crate::error::InternalException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) can_retry: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Details of the exception error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>You can immediately retry your request.</p>
        pub fn can_retry(mut self, input: bool) -> Self {
            self.can_retry = Some(input);
            self
        }
        pub fn set_can_retry(mut self, input: std::option::Option<bool>) -> Self {
            self.can_retry = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalException`](crate::error::InternalException)
        pub fn build(self) -> crate::error::InternalException {
            crate::error::InternalException {
                message: self.message,
                can_retry: self.can_retry,
            }
        }
    }
}
impl InternalException {
    /// Creates a new builder-style object to manufacture [`InternalException`](crate::error::InternalException)
    pub fn builder() -> crate::error::internal_exception::Builder {
        crate::error::internal_exception::Builder::default()
    }
}

/// <p>You do not have required permissions to access the requested resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AccessDeniedException {
    /// <p>Details of the exception error.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>Code that indicates the type of error that is generated.</p>
    pub error_code: std::option::Option<crate::model::AccessDeniedErrorCode>,
    /// <p>You can immediately retry your request.</p>
    pub can_retry: std::option::Option<bool>,
}
impl std::fmt::Debug for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AccessDeniedException");
        formatter.field("message", &self.message);
        formatter.field("error_code", &self.error_code);
        formatter.field("can_retry", &self.can_retry);
        formatter.finish()
    }
}
impl AccessDeniedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccessDeniedException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for AccessDeniedException {}
/// See [`AccessDeniedException`](crate::error::AccessDeniedException)
pub mod access_denied_exception {
    /// A builder for [`AccessDeniedException`](crate::error::AccessDeniedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) error_code: std::option::Option<crate::model::AccessDeniedErrorCode>,
        pub(crate) can_retry: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Details of the exception error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>Code that indicates the type of error that is generated.</p>
        pub fn error_code(mut self, input: crate::model::AccessDeniedErrorCode) -> Self {
            self.error_code = Some(input);
            self
        }
        pub fn set_error_code(
            mut self,
            input: std::option::Option<crate::model::AccessDeniedErrorCode>,
        ) -> Self {
            self.error_code = input;
            self
        }
        /// <p>You can immediately retry your request.</p>
        pub fn can_retry(mut self, input: bool) -> Self {
            self.can_retry = Some(input);
            self
        }
        pub fn set_can_retry(mut self, input: std::option::Option<bool>) -> Self {
            self.can_retry = input;
            self
        }
        /// Consumes the builder and constructs a [`AccessDeniedException`](crate::error::AccessDeniedException)
        pub fn build(self) -> crate::error::AccessDeniedException {
            crate::error::AccessDeniedException {
                message: self.message,
                error_code: self.error_code,
                can_retry: self.can_retry,
            }
        }
    }
}
impl AccessDeniedException {
    /// Creates a new builder-style object to manufacture [`AccessDeniedException`](crate::error::AccessDeniedException)
    pub fn builder() -> crate::error::access_denied_exception::Builder {
        crate::error::access_denied_exception::Builder::default()
    }
}

/// <p>The request was rejected because it attempted to create resources beyond the current
/// AWS account limits. The error code describes the limit exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededException {
    /// <p>Details of the exception error.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>Code that indicates the type of error that is generated.</p>
    pub error_code: std::option::Option<crate::model::LimitExceededErrorCode>,
    /// <p>You can immediately retry your request.</p>
    pub can_retry: std::option::Option<bool>,
}
impl std::fmt::Debug for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededException");
        formatter.field("message", &self.message);
        formatter.field("error_code", &self.error_code);
        formatter.field("can_retry", &self.can_retry);
        formatter.finish()
    }
}
impl LimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededException {}
/// See [`LimitExceededException`](crate::error::LimitExceededException)
pub mod limit_exceeded_exception {
    /// A builder for [`LimitExceededException`](crate::error::LimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) error_code: std::option::Option<crate::model::LimitExceededErrorCode>,
        pub(crate) can_retry: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Details of the exception error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>Code that indicates the type of error that is generated.</p>
        pub fn error_code(mut self, input: crate::model::LimitExceededErrorCode) -> Self {
            self.error_code = Some(input);
            self
        }
        pub fn set_error_code(
            mut self,
            input: std::option::Option<crate::model::LimitExceededErrorCode>,
        ) -> Self {
            self.error_code = input;
            self
        }
        /// <p>You can immediately retry your request.</p>
        pub fn can_retry(mut self, input: bool) -> Self {
            self.can_retry = Some(input);
            self
        }
        pub fn set_can_retry(mut self, input: std::option::Option<bool>) -> Self {
            self.can_retry = input;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededException`](crate::error::LimitExceededException)
        pub fn build(self) -> crate::error::LimitExceededException {
            crate::error::LimitExceededException {
                message: self.message,
                error_code: self.error_code,
                can_retry: self.can_retry,
            }
        }
    }
}
impl LimitExceededException {
    /// Creates a new builder-style object to manufacture [`LimitExceededException`](crate::error::LimitExceededException)
    pub fn builder() -> crate::error::limit_exceeded_exception::Builder {
        crate::error::limit_exceeded_exception::Builder::default()
    }
}

/// <p>Amazon Inspector cannot assume the cross-account role that it needs to list your EC2
/// instances during the assessment run.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidCrossAccountRoleException {
    /// <p>Details of the exception error.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>Code that indicates the type of error that is generated.</p>
    pub error_code: std::option::Option<crate::model::InvalidCrossAccountRoleErrorCode>,
    /// <p>You can immediately retry your request.</p>
    pub can_retry: std::option::Option<bool>,
}
impl std::fmt::Debug for InvalidCrossAccountRoleException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidCrossAccountRoleException");
        formatter.field("message", &self.message);
        formatter.field("error_code", &self.error_code);
        formatter.field("can_retry", &self.can_retry);
        formatter.finish()
    }
}
impl InvalidCrossAccountRoleException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidCrossAccountRoleException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidCrossAccountRoleException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidCrossAccountRoleException {}
/// See [`InvalidCrossAccountRoleException`](crate::error::InvalidCrossAccountRoleException)
pub mod invalid_cross_account_role_exception {
    /// A builder for [`InvalidCrossAccountRoleException`](crate::error::InvalidCrossAccountRoleException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) error_code: std::option::Option<crate::model::InvalidCrossAccountRoleErrorCode>,
        pub(crate) can_retry: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Details of the exception error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>Code that indicates the type of error that is generated.</p>
        pub fn error_code(mut self, input: crate::model::InvalidCrossAccountRoleErrorCode) -> Self {
            self.error_code = Some(input);
            self
        }
        pub fn set_error_code(
            mut self,
            input: std::option::Option<crate::model::InvalidCrossAccountRoleErrorCode>,
        ) -> Self {
            self.error_code = input;
            self
        }
        /// <p>You can immediately retry your request.</p>
        pub fn can_retry(mut self, input: bool) -> Self {
            self.can_retry = Some(input);
            self
        }
        pub fn set_can_retry(mut self, input: std::option::Option<bool>) -> Self {
            self.can_retry = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidCrossAccountRoleException`](crate::error::InvalidCrossAccountRoleException)
        pub fn build(self) -> crate::error::InvalidCrossAccountRoleException {
            crate::error::InvalidCrossAccountRoleException {
                message: self.message,
                error_code: self.error_code,
                can_retry: self.can_retry,
            }
        }
    }
}
impl InvalidCrossAccountRoleException {
    /// Creates a new builder-style object to manufacture [`InvalidCrossAccountRoleException`](crate::error::InvalidCrossAccountRoleException)
    pub fn builder() -> crate::error::invalid_cross_account_role_exception::Builder {
        crate::error::invalid_cross_account_role_exception::Builder::default()
    }
}

/// <p>You started an assessment run, but one of the instances is already participating in
/// another assessment run.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AgentsAlreadyRunningAssessmentException {
    /// <p>Details of the exception error.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p></p>
    pub agents: std::option::Option<std::vec::Vec<crate::model::AgentAlreadyRunningAssessment>>,
    /// <p></p>
    pub agents_truncated: std::option::Option<bool>,
    /// <p>You can immediately retry your request.</p>
    pub can_retry: std::option::Option<bool>,
}
impl std::fmt::Debug for AgentsAlreadyRunningAssessmentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AgentsAlreadyRunningAssessmentException");
        formatter.field("message", &self.message);
        formatter.field("agents", &self.agents);
        formatter.field("agents_truncated", &self.agents_truncated);
        formatter.field("can_retry", &self.can_retry);
        formatter.finish()
    }
}
impl AgentsAlreadyRunningAssessmentException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AgentsAlreadyRunningAssessmentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AgentsAlreadyRunningAssessmentException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for AgentsAlreadyRunningAssessmentException {}
/// See [`AgentsAlreadyRunningAssessmentException`](crate::error::AgentsAlreadyRunningAssessmentException)
pub mod agents_already_running_assessment_exception {
    /// A builder for [`AgentsAlreadyRunningAssessmentException`](crate::error::AgentsAlreadyRunningAssessmentException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) agents:
            std::option::Option<std::vec::Vec<crate::model::AgentAlreadyRunningAssessment>>,
        pub(crate) agents_truncated: std::option::Option<bool>,
        pub(crate) can_retry: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Details of the exception error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn agents(
            mut self,
            input: impl Into<crate::model::AgentAlreadyRunningAssessment>,
        ) -> Self {
            let mut v = self.agents.unwrap_or_default();
            v.push(input.into());
            self.agents = Some(v);
            self
        }
        pub fn set_agents(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AgentAlreadyRunningAssessment>>,
        ) -> Self {
            self.agents = input;
            self
        }
        /// <p></p>
        pub fn agents_truncated(mut self, input: bool) -> Self {
            self.agents_truncated = Some(input);
            self
        }
        pub fn set_agents_truncated(mut self, input: std::option::Option<bool>) -> Self {
            self.agents_truncated = input;
            self
        }
        /// <p>You can immediately retry your request.</p>
        pub fn can_retry(mut self, input: bool) -> Self {
            self.can_retry = Some(input);
            self
        }
        pub fn set_can_retry(mut self, input: std::option::Option<bool>) -> Self {
            self.can_retry = input;
            self
        }
        /// Consumes the builder and constructs a [`AgentsAlreadyRunningAssessmentException`](crate::error::AgentsAlreadyRunningAssessmentException)
        pub fn build(self) -> crate::error::AgentsAlreadyRunningAssessmentException {
            crate::error::AgentsAlreadyRunningAssessmentException {
                message: self.message,
                agents: self.agents,
                agents_truncated: self.agents_truncated,
                can_retry: self.can_retry,
            }
        }
    }
}
impl AgentsAlreadyRunningAssessmentException {
    /// Creates a new builder-style object to manufacture [`AgentsAlreadyRunningAssessmentException`](crate::error::AgentsAlreadyRunningAssessmentException)
    pub fn builder() -> crate::error::agents_already_running_assessment_exception::Builder {
        crate::error::agents_already_running_assessment_exception::Builder::default()
    }
}

/// <p>Used by the <a>GetAssessmentReport</a> API. The request was rejected
/// because you tried to generate a report for an assessment run that existed before reporting
/// was supported in Amazon Inspector. You can only generate reports for assessment runs that
/// took place or will take place after generating reports in Amazon Inspector became
/// available.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnsupportedFeatureException {
    pub message: std::option::Option<std::string::String>,
    pub can_retry: std::option::Option<bool>,
}
impl std::fmt::Debug for UnsupportedFeatureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnsupportedFeatureException");
        formatter.field("message", &self.message);
        formatter.field("can_retry", &self.can_retry);
        formatter.finish()
    }
}
impl UnsupportedFeatureException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedFeatureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnsupportedFeatureException")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedFeatureException {}
/// See [`UnsupportedFeatureException`](crate::error::UnsupportedFeatureException)
pub mod unsupported_feature_exception {
    /// A builder for [`UnsupportedFeatureException`](crate::error::UnsupportedFeatureException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) can_retry: std::option::Option<bool>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn can_retry(mut self, input: bool) -> Self {
            self.can_retry = Some(input);
            self
        }
        pub fn set_can_retry(mut self, input: std::option::Option<bool>) -> Self {
            self.can_retry = input;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedFeatureException`](crate::error::UnsupportedFeatureException)
        pub fn build(self) -> crate::error::UnsupportedFeatureException {
            crate::error::UnsupportedFeatureException {
                message: self.message,
                can_retry: self.can_retry,
            }
        }
    }
}
impl UnsupportedFeatureException {
    /// Creates a new builder-style object to manufacture [`UnsupportedFeatureException`](crate::error::UnsupportedFeatureException)
    pub fn builder() -> crate::error::unsupported_feature_exception::Builder {
        crate::error::unsupported_feature_exception::Builder::default()
    }
}

/// <p>You cannot perform a specified action if an assessment run is currently in
/// progress.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AssessmentRunInProgressException {
    /// <p>Details of the exception error.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>The ARNs of the assessment runs that are currently in progress.</p>
    pub assessment_run_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Boolean value that indicates whether the ARN list of the assessment runs is
    /// truncated.</p>
    pub assessment_run_arns_truncated: std::option::Option<bool>,
    /// <p>You can immediately retry your request.</p>
    pub can_retry: std::option::Option<bool>,
}
impl std::fmt::Debug for AssessmentRunInProgressException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssessmentRunInProgressException");
        formatter.field("message", &self.message);
        formatter.field("assessment_run_arns", &self.assessment_run_arns);
        formatter.field(
            "assessment_run_arns_truncated",
            &self.assessment_run_arns_truncated,
        );
        formatter.field("can_retry", &self.can_retry);
        formatter.finish()
    }
}
impl AssessmentRunInProgressException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AssessmentRunInProgressException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AssessmentRunInProgressException")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for AssessmentRunInProgressException {}
/// See [`AssessmentRunInProgressException`](crate::error::AssessmentRunInProgressException)
pub mod assessment_run_in_progress_exception {
    /// A builder for [`AssessmentRunInProgressException`](crate::error::AssessmentRunInProgressException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) assessment_run_arns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) assessment_run_arns_truncated: std::option::Option<bool>,
        pub(crate) can_retry: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Details of the exception error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn assessment_run_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.assessment_run_arns.unwrap_or_default();
            v.push(input.into());
            self.assessment_run_arns = Some(v);
            self
        }
        pub fn set_assessment_run_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.assessment_run_arns = input;
            self
        }
        /// <p>Boolean value that indicates whether the ARN list of the assessment runs is
        /// truncated.</p>
        pub fn assessment_run_arns_truncated(mut self, input: bool) -> Self {
            self.assessment_run_arns_truncated = Some(input);
            self
        }
        pub fn set_assessment_run_arns_truncated(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.assessment_run_arns_truncated = input;
            self
        }
        /// <p>You can immediately retry your request.</p>
        pub fn can_retry(mut self, input: bool) -> Self {
            self.can_retry = Some(input);
            self
        }
        pub fn set_can_retry(mut self, input: std::option::Option<bool>) -> Self {
            self.can_retry = input;
            self
        }
        /// Consumes the builder and constructs a [`AssessmentRunInProgressException`](crate::error::AssessmentRunInProgressException)
        pub fn build(self) -> crate::error::AssessmentRunInProgressException {
            crate::error::AssessmentRunInProgressException {
                message: self.message,
                assessment_run_arns: self.assessment_run_arns,
                assessment_run_arns_truncated: self.assessment_run_arns_truncated,
                can_retry: self.can_retry,
            }
        }
    }
}
impl AssessmentRunInProgressException {
    /// Creates a new builder-style object to manufacture [`AssessmentRunInProgressException`](crate::error::AssessmentRunInProgressException)
    pub fn builder() -> crate::error::assessment_run_in_progress_exception::Builder {
        crate::error::assessment_run_in_progress_exception::Builder::default()
    }
}

/// <p>The request is rejected. The specified assessment template is currently generating an
/// exclusions preview.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PreviewGenerationInProgressException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PreviewGenerationInProgressException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PreviewGenerationInProgressException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PreviewGenerationInProgressException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PreviewGenerationInProgressException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PreviewGenerationInProgressException")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for PreviewGenerationInProgressException {}
/// See [`PreviewGenerationInProgressException`](crate::error::PreviewGenerationInProgressException)
pub mod preview_generation_in_progress_exception {
    /// A builder for [`PreviewGenerationInProgressException`](crate::error::PreviewGenerationInProgressException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PreviewGenerationInProgressException`](crate::error::PreviewGenerationInProgressException)
        pub fn build(self) -> crate::error::PreviewGenerationInProgressException {
            crate::error::PreviewGenerationInProgressException {
                message: self.message,
            }
        }
    }
}
impl PreviewGenerationInProgressException {
    /// Creates a new builder-style object to manufacture [`PreviewGenerationInProgressException`](crate::error::PreviewGenerationInProgressException)
    pub fn builder() -> crate::error::preview_generation_in_progress_exception::Builder {
        crate::error::preview_generation_in_progress_exception::Builder::default()
    }
}
