// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub fn parse_http_generic_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<smithy_types::Error, smithy_xml::decode::XmlError> {
    crate::rest_xml_wrapped_errors::parse_generic_error(response.body().as_ref())
}

#[allow(unused_mut)]
pub fn deser_structure_source_not_found_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::source_not_found_fault::Builder,
) -> Result<crate::error::source_not_found_fault::Builder, smithy_xml::decode::XmlError> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#SourceNotFoundFault$message */ =>  {
                let var_1 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_1);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_subscription_not_found_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::subscription_not_found_fault::Builder,
) -> Result<crate::error::subscription_not_found_fault::Builder, smithy_xml::decode::XmlError> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#SubscriptionNotFoundFault$message */ =>  {
                let var_2 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_2);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_add_source_identifier_to_subscription(
    inp: &[u8],
    mut builder: crate::output::add_source_identifier_to_subscription_output::Builder,
) -> Result<
    crate::output::add_source_identifier_to_subscription_output::Builder,
    smithy_xml::decode::XmlError,
> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("AddSourceIdentifierToSubscriptionResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected AddSourceIdentifierToSubscriptionResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("AddSourceIdentifierToSubscriptionResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected AddSourceIdentifierToSubscriptionResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("EventSubscription") /* EventSubscription com.amazonaws.docdb#AddSourceIdentifierToSubscriptionOutput$EventSubscription */ =>  {
                let var_3 =
                    Some(
                        crate::xml_deser::deser_structure_event_subscription(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_event_subscription(var_3);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected AddSourceIdentifierToSubscriptionResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_db_cluster_not_found_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::db_cluster_not_found_fault::Builder,
) -> Result<crate::error::db_cluster_not_found_fault::Builder, smithy_xml::decode::XmlError> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#DBClusterNotFoundFault$message */ =>  {
                let var_4 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_4);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_db_instance_not_found_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::db_instance_not_found_fault::Builder,
) -> Result<crate::error::db_instance_not_found_fault::Builder, smithy_xml::decode::XmlError> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#DBInstanceNotFoundFault$message */ =>  {
                let var_5 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_5);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_db_snapshot_not_found_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::db_snapshot_not_found_fault::Builder,
) -> Result<crate::error::db_snapshot_not_found_fault::Builder, smithy_xml::decode::XmlError> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#DBSnapshotNotFoundFault$message */ =>  {
                let var_6 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_6);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_invalid_db_cluster_state_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::invalid_db_cluster_state_fault::Builder,
) -> Result<crate::error::invalid_db_cluster_state_fault::Builder, smithy_xml::decode::XmlError> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#InvalidDBClusterStateFault$message */ =>  {
                let var_7 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_7);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_invalid_db_instance_state_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::invalid_db_instance_state_fault::Builder,
) -> Result<crate::error::invalid_db_instance_state_fault::Builder, smithy_xml::decode::XmlError> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#InvalidDBInstanceStateFault$message */ =>  {
                let var_8 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_8);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_resource_not_found_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::resource_not_found_fault::Builder,
) -> Result<crate::error::resource_not_found_fault::Builder, smithy_xml::decode::XmlError> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#ResourceNotFoundFault$message */ =>  {
                let var_9 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_9);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_apply_pending_maintenance_action(
    inp: &[u8],
    mut builder: crate::output::apply_pending_maintenance_action_output::Builder,
) -> Result<
    crate::output::apply_pending_maintenance_action_output::Builder,
    smithy_xml::decode::XmlError,
> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("ApplyPendingMaintenanceActionResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected ApplyPendingMaintenanceActionResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("ApplyPendingMaintenanceActionResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected ApplyPendingMaintenanceActionResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("ResourcePendingMaintenanceActions") /* ResourcePendingMaintenanceActions com.amazonaws.docdb#ApplyPendingMaintenanceActionOutput$ResourcePendingMaintenanceActions */ =>  {
                let var_10 =
                    Some(
                        crate::xml_deser::deser_structure_resource_pending_maintenance_actions(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_resource_pending_maintenance_actions(var_10);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected ApplyPendingMaintenanceActionResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_db_parameter_group_already_exists_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::db_parameter_group_already_exists_fault::Builder,
) -> Result<
    crate::error::db_parameter_group_already_exists_fault::Builder,
    smithy_xml::decode::XmlError,
> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#DBParameterGroupAlreadyExistsFault$message */ =>  {
                let var_11 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_11);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_db_parameter_group_not_found_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::db_parameter_group_not_found_fault::Builder,
) -> Result<crate::error::db_parameter_group_not_found_fault::Builder, smithy_xml::decode::XmlError>
{
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#DBParameterGroupNotFoundFault$message */ =>  {
                let var_12 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_12);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_db_parameter_group_quota_exceeded_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::db_parameter_group_quota_exceeded_fault::Builder,
) -> Result<
    crate::error::db_parameter_group_quota_exceeded_fault::Builder,
    smithy_xml::decode::XmlError,
> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#DBParameterGroupQuotaExceededFault$message */ =>  {
                let var_13 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_13);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_copy_db_cluster_parameter_group(
    inp: &[u8],
    mut builder: crate::output::copy_db_cluster_parameter_group_output::Builder,
) -> Result<
    crate::output::copy_db_cluster_parameter_group_output::Builder,
    smithy_xml::decode::XmlError,
> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("CopyDBClusterParameterGroupResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected CopyDBClusterParameterGroupResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("CopyDBClusterParameterGroupResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected CopyDBClusterParameterGroupResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("DBClusterParameterGroup") /* DBClusterParameterGroup com.amazonaws.docdb#CopyDBClusterParameterGroupOutput$DBClusterParameterGroup */ =>  {
                let var_14 =
                    Some(
                        crate::xml_deser::deser_structure_db_cluster_parameter_group(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_db_cluster_parameter_group(var_14);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected CopyDBClusterParameterGroupResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_db_cluster_snapshot_already_exists_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::db_cluster_snapshot_already_exists_fault::Builder,
) -> Result<
    crate::error::db_cluster_snapshot_already_exists_fault::Builder,
    smithy_xml::decode::XmlError,
> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#DBClusterSnapshotAlreadyExistsFault$message */ =>  {
                let var_15 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_15);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_db_cluster_snapshot_not_found_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::db_cluster_snapshot_not_found_fault::Builder,
) -> Result<crate::error::db_cluster_snapshot_not_found_fault::Builder, smithy_xml::decode::XmlError>
{
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#DBClusterSnapshotNotFoundFault$message */ =>  {
                let var_16 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_16);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_invalid_db_cluster_snapshot_state_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::invalid_db_cluster_snapshot_state_fault::Builder,
) -> Result<
    crate::error::invalid_db_cluster_snapshot_state_fault::Builder,
    smithy_xml::decode::XmlError,
> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#InvalidDBClusterSnapshotStateFault$message */ =>  {
                let var_17 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_17);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_kms_key_not_accessible_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::kms_key_not_accessible_fault::Builder,
) -> Result<crate::error::kms_key_not_accessible_fault::Builder, smithy_xml::decode::XmlError> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#KMSKeyNotAccessibleFault$message */ =>  {
                let var_18 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_18);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_snapshot_quota_exceeded_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::snapshot_quota_exceeded_fault::Builder,
) -> Result<crate::error::snapshot_quota_exceeded_fault::Builder, smithy_xml::decode::XmlError> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#SnapshotQuotaExceededFault$message */ =>  {
                let var_19 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_19);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_copy_db_cluster_snapshot(
    inp: &[u8],
    mut builder: crate::output::copy_db_cluster_snapshot_output::Builder,
) -> Result<crate::output::copy_db_cluster_snapshot_output::Builder, smithy_xml::decode::XmlError> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("CopyDBClusterSnapshotResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected CopyDBClusterSnapshotResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("CopyDBClusterSnapshotResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected CopyDBClusterSnapshotResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("DBClusterSnapshot") /* DBClusterSnapshot com.amazonaws.docdb#CopyDBClusterSnapshotOutput$DBClusterSnapshot */ =>  {
                let var_20 =
                    Some(
                        crate::xml_deser::deser_structure_db_cluster_snapshot(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_db_cluster_snapshot(var_20);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected CopyDBClusterSnapshotResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_db_cluster_already_exists_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::db_cluster_already_exists_fault::Builder,
) -> Result<crate::error::db_cluster_already_exists_fault::Builder, smithy_xml::decode::XmlError> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#DBClusterAlreadyExistsFault$message */ =>  {
                let var_21 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_21);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_db_cluster_parameter_group_not_found_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::db_cluster_parameter_group_not_found_fault::Builder,
) -> Result<
    crate::error::db_cluster_parameter_group_not_found_fault::Builder,
    smithy_xml::decode::XmlError,
> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#DBClusterParameterGroupNotFoundFault$message */ =>  {
                let var_22 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_22);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_db_cluster_quota_exceeded_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::db_cluster_quota_exceeded_fault::Builder,
) -> Result<crate::error::db_cluster_quota_exceeded_fault::Builder, smithy_xml::decode::XmlError> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#DBClusterQuotaExceededFault$message */ =>  {
                let var_23 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_23);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_db_subnet_group_does_not_cover_enough_a_zs_xml_err(
    inp: &[u8],
    mut builder: crate::error::db_subnet_group_does_not_cover_enough_a_zs::Builder,
) -> Result<
    crate::error::db_subnet_group_does_not_cover_enough_a_zs::Builder,
    smithy_xml::decode::XmlError,
> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#DBSubnetGroupDoesNotCoverEnoughAZs$message */ =>  {
                let var_24 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_24);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_db_subnet_group_not_found_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::db_subnet_group_not_found_fault::Builder,
) -> Result<crate::error::db_subnet_group_not_found_fault::Builder, smithy_xml::decode::XmlError> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#DBSubnetGroupNotFoundFault$message */ =>  {
                let var_25 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_25);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_global_cluster_not_found_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::global_cluster_not_found_fault::Builder,
) -> Result<crate::error::global_cluster_not_found_fault::Builder, smithy_xml::decode::XmlError> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#GlobalClusterNotFoundFault$message */ =>  {
                let var_26 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_26);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_insufficient_storage_cluster_capacity_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::insufficient_storage_cluster_capacity_fault::Builder,
) -> Result<
    crate::error::insufficient_storage_cluster_capacity_fault::Builder,
    smithy_xml::decode::XmlError,
> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#InsufficientStorageClusterCapacityFault$message */ =>  {
                let var_27 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_27);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_invalid_db_subnet_group_state_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::invalid_db_subnet_group_state_fault::Builder,
) -> Result<crate::error::invalid_db_subnet_group_state_fault::Builder, smithy_xml::decode::XmlError>
{
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#InvalidDBSubnetGroupStateFault$message */ =>  {
                let var_28 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_28);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_invalid_global_cluster_state_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::invalid_global_cluster_state_fault::Builder,
) -> Result<crate::error::invalid_global_cluster_state_fault::Builder, smithy_xml::decode::XmlError>
{
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#InvalidGlobalClusterStateFault$message */ =>  {
                let var_29 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_29);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_invalid_subnet_xml_err(
    inp: &[u8],
    mut builder: crate::error::invalid_subnet::Builder,
) -> Result<crate::error::invalid_subnet::Builder, smithy_xml::decode::XmlError> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#InvalidSubnet$message */ =>  {
                let var_30 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_30);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_invalid_vpc_network_state_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::invalid_vpc_network_state_fault::Builder,
) -> Result<crate::error::invalid_vpc_network_state_fault::Builder, smithy_xml::decode::XmlError> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#InvalidVPCNetworkStateFault$message */ =>  {
                let var_31 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_31);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_storage_quota_exceeded_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::storage_quota_exceeded_fault::Builder,
) -> Result<crate::error::storage_quota_exceeded_fault::Builder, smithy_xml::decode::XmlError> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#StorageQuotaExceededFault$message */ =>  {
                let var_32 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_32);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_create_db_cluster(
    inp: &[u8],
    mut builder: crate::output::create_db_cluster_output::Builder,
) -> Result<crate::output::create_db_cluster_output::Builder, smithy_xml::decode::XmlError> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("CreateDBClusterResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected CreateDBClusterResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("CreateDBClusterResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected CreateDBClusterResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("DBCluster") /* DBCluster com.amazonaws.docdb#CreateDBClusterOutput$DBCluster */ =>  {
                let var_33 =
                    Some(
                        crate::xml_deser::deser_structure_db_cluster(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_db_cluster(var_33);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected CreateDBClusterResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_create_db_cluster_parameter_group(
    inp: &[u8],
    mut builder: crate::output::create_db_cluster_parameter_group_output::Builder,
) -> Result<
    crate::output::create_db_cluster_parameter_group_output::Builder,
    smithy_xml::decode::XmlError,
> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("CreateDBClusterParameterGroupResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected CreateDBClusterParameterGroupResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("CreateDBClusterParameterGroupResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected CreateDBClusterParameterGroupResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("DBClusterParameterGroup") /* DBClusterParameterGroup com.amazonaws.docdb#CreateDBClusterParameterGroupOutput$DBClusterParameterGroup */ =>  {
                let var_34 =
                    Some(
                        crate::xml_deser::deser_structure_db_cluster_parameter_group(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_db_cluster_parameter_group(var_34);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected CreateDBClusterParameterGroupResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_create_db_cluster_snapshot(
    inp: &[u8],
    mut builder: crate::output::create_db_cluster_snapshot_output::Builder,
) -> Result<crate::output::create_db_cluster_snapshot_output::Builder, smithy_xml::decode::XmlError>
{
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("CreateDBClusterSnapshotResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected CreateDBClusterSnapshotResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("CreateDBClusterSnapshotResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected CreateDBClusterSnapshotResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("DBClusterSnapshot") /* DBClusterSnapshot com.amazonaws.docdb#CreateDBClusterSnapshotOutput$DBClusterSnapshot */ =>  {
                let var_35 =
                    Some(
                        crate::xml_deser::deser_structure_db_cluster_snapshot(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_db_cluster_snapshot(var_35);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected CreateDBClusterSnapshotResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_authorization_not_found_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::authorization_not_found_fault::Builder,
) -> Result<crate::error::authorization_not_found_fault::Builder, smithy_xml::decode::XmlError> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#AuthorizationNotFoundFault$message */ =>  {
                let var_36 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_36);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_db_instance_already_exists_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::db_instance_already_exists_fault::Builder,
) -> Result<crate::error::db_instance_already_exists_fault::Builder, smithy_xml::decode::XmlError> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#DBInstanceAlreadyExistsFault$message */ =>  {
                let var_37 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_37);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_db_security_group_not_found_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::db_security_group_not_found_fault::Builder,
) -> Result<crate::error::db_security_group_not_found_fault::Builder, smithy_xml::decode::XmlError>
{
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#DBSecurityGroupNotFoundFault$message */ =>  {
                let var_38 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_38);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_instance_quota_exceeded_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::instance_quota_exceeded_fault::Builder,
) -> Result<crate::error::instance_quota_exceeded_fault::Builder, smithy_xml::decode::XmlError> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#InstanceQuotaExceededFault$message */ =>  {
                let var_39 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_39);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_insufficient_db_instance_capacity_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::insufficient_db_instance_capacity_fault::Builder,
) -> Result<
    crate::error::insufficient_db_instance_capacity_fault::Builder,
    smithy_xml::decode::XmlError,
> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#InsufficientDBInstanceCapacityFault$message */ =>  {
                let var_40 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_40);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_storage_type_not_supported_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::storage_type_not_supported_fault::Builder,
) -> Result<crate::error::storage_type_not_supported_fault::Builder, smithy_xml::decode::XmlError> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#StorageTypeNotSupportedFault$message */ =>  {
                let var_41 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_41);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_create_db_instance(
    inp: &[u8],
    mut builder: crate::output::create_db_instance_output::Builder,
) -> Result<crate::output::create_db_instance_output::Builder, smithy_xml::decode::XmlError> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("CreateDBInstanceResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected CreateDBInstanceResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("CreateDBInstanceResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected CreateDBInstanceResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("DBInstance") /* DBInstance com.amazonaws.docdb#CreateDBInstanceOutput$DBInstance */ =>  {
                let var_42 =
                    Some(
                        crate::xml_deser::deser_structure_db_instance(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_db_instance(var_42);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected CreateDBInstanceResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_db_subnet_group_already_exists_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::db_subnet_group_already_exists_fault::Builder,
) -> Result<crate::error::db_subnet_group_already_exists_fault::Builder, smithy_xml::decode::XmlError>
{
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#DBSubnetGroupAlreadyExistsFault$message */ =>  {
                let var_43 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_43);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_db_subnet_group_quota_exceeded_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::db_subnet_group_quota_exceeded_fault::Builder,
) -> Result<crate::error::db_subnet_group_quota_exceeded_fault::Builder, smithy_xml::decode::XmlError>
{
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#DBSubnetGroupQuotaExceededFault$message */ =>  {
                let var_44 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_44);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_db_subnet_quota_exceeded_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::db_subnet_quota_exceeded_fault::Builder,
) -> Result<crate::error::db_subnet_quota_exceeded_fault::Builder, smithy_xml::decode::XmlError> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#DBSubnetQuotaExceededFault$message */ =>  {
                let var_45 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_45);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_create_db_subnet_group(
    inp: &[u8],
    mut builder: crate::output::create_db_subnet_group_output::Builder,
) -> Result<crate::output::create_db_subnet_group_output::Builder, smithy_xml::decode::XmlError> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("CreateDBSubnetGroupResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected CreateDBSubnetGroupResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("CreateDBSubnetGroupResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected CreateDBSubnetGroupResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("DBSubnetGroup") /* DBSubnetGroup com.amazonaws.docdb#CreateDBSubnetGroupOutput$DBSubnetGroup */ =>  {
                let var_46 =
                    Some(
                        crate::xml_deser::deser_structure_db_subnet_group(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_db_subnet_group(var_46);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected CreateDBSubnetGroupResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_event_subscription_quota_exceeded_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::event_subscription_quota_exceeded_fault::Builder,
) -> Result<
    crate::error::event_subscription_quota_exceeded_fault::Builder,
    smithy_xml::decode::XmlError,
> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#EventSubscriptionQuotaExceededFault$message */ =>  {
                let var_47 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_47);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_sns_invalid_topic_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::sns_invalid_topic_fault::Builder,
) -> Result<crate::error::sns_invalid_topic_fault::Builder, smithy_xml::decode::XmlError> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#SNSInvalidTopicFault$message */ =>  {
                let var_48 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_48);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_sns_no_authorization_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::sns_no_authorization_fault::Builder,
) -> Result<crate::error::sns_no_authorization_fault::Builder, smithy_xml::decode::XmlError> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#SNSNoAuthorizationFault$message */ =>  {
                let var_49 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_49);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_sns_topic_arn_not_found_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::sns_topic_arn_not_found_fault::Builder,
) -> Result<crate::error::sns_topic_arn_not_found_fault::Builder, smithy_xml::decode::XmlError> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#SNSTopicArnNotFoundFault$message */ =>  {
                let var_50 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_50);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_subscription_already_exist_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::subscription_already_exist_fault::Builder,
) -> Result<crate::error::subscription_already_exist_fault::Builder, smithy_xml::decode::XmlError> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#SubscriptionAlreadyExistFault$message */ =>  {
                let var_51 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_51);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_subscription_category_not_found_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::subscription_category_not_found_fault::Builder,
) -> Result<
    crate::error::subscription_category_not_found_fault::Builder,
    smithy_xml::decode::XmlError,
> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#SubscriptionCategoryNotFoundFault$message */ =>  {
                let var_52 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_52);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_create_event_subscription(
    inp: &[u8],
    mut builder: crate::output::create_event_subscription_output::Builder,
) -> Result<crate::output::create_event_subscription_output::Builder, smithy_xml::decode::XmlError>
{
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("CreateEventSubscriptionResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected CreateEventSubscriptionResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("CreateEventSubscriptionResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected CreateEventSubscriptionResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("EventSubscription") /* EventSubscription com.amazonaws.docdb#CreateEventSubscriptionOutput$EventSubscription */ =>  {
                let var_53 =
                    Some(
                        crate::xml_deser::deser_structure_event_subscription(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_event_subscription(var_53);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected CreateEventSubscriptionResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_global_cluster_already_exists_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::global_cluster_already_exists_fault::Builder,
) -> Result<crate::error::global_cluster_already_exists_fault::Builder, smithy_xml::decode::XmlError>
{
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#GlobalClusterAlreadyExistsFault$message */ =>  {
                let var_54 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_54);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_global_cluster_quota_exceeded_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::global_cluster_quota_exceeded_fault::Builder,
) -> Result<crate::error::global_cluster_quota_exceeded_fault::Builder, smithy_xml::decode::XmlError>
{
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#GlobalClusterQuotaExceededFault$message */ =>  {
                let var_55 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_55);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_create_global_cluster(
    inp: &[u8],
    mut builder: crate::output::create_global_cluster_output::Builder,
) -> Result<crate::output::create_global_cluster_output::Builder, smithy_xml::decode::XmlError> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("CreateGlobalClusterResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected CreateGlobalClusterResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("CreateGlobalClusterResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected CreateGlobalClusterResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("GlobalCluster") /* GlobalCluster com.amazonaws.docdb#CreateGlobalClusterOutput$GlobalCluster */ =>  {
                let var_56 =
                    Some(
                        crate::xml_deser::deser_structure_global_cluster(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_global_cluster(var_56);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected CreateGlobalClusterResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_delete_db_cluster(
    inp: &[u8],
    mut builder: crate::output::delete_db_cluster_output::Builder,
) -> Result<crate::output::delete_db_cluster_output::Builder, smithy_xml::decode::XmlError> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("DeleteDBClusterResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected DeleteDBClusterResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("DeleteDBClusterResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected DeleteDBClusterResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("DBCluster") /* DBCluster com.amazonaws.docdb#DeleteDBClusterOutput$DBCluster */ =>  {
                let var_57 =
                    Some(
                        crate::xml_deser::deser_structure_db_cluster(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_db_cluster(var_57);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected DeleteDBClusterResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_invalid_db_parameter_group_state_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::invalid_db_parameter_group_state_fault::Builder,
) -> Result<
    crate::error::invalid_db_parameter_group_state_fault::Builder,
    smithy_xml::decode::XmlError,
> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#InvalidDBParameterGroupStateFault$message */ =>  {
                let var_58 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_58);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_delete_db_cluster_snapshot(
    inp: &[u8],
    mut builder: crate::output::delete_db_cluster_snapshot_output::Builder,
) -> Result<crate::output::delete_db_cluster_snapshot_output::Builder, smithy_xml::decode::XmlError>
{
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("DeleteDBClusterSnapshotResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected DeleteDBClusterSnapshotResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("DeleteDBClusterSnapshotResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected DeleteDBClusterSnapshotResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("DBClusterSnapshot") /* DBClusterSnapshot com.amazonaws.docdb#DeleteDBClusterSnapshotOutput$DBClusterSnapshot */ =>  {
                let var_59 =
                    Some(
                        crate::xml_deser::deser_structure_db_cluster_snapshot(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_db_cluster_snapshot(var_59);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected DeleteDBClusterSnapshotResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_db_snapshot_already_exists_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::db_snapshot_already_exists_fault::Builder,
) -> Result<crate::error::db_snapshot_already_exists_fault::Builder, smithy_xml::decode::XmlError> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#DBSnapshotAlreadyExistsFault$message */ =>  {
                let var_60 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_60);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_delete_db_instance(
    inp: &[u8],
    mut builder: crate::output::delete_db_instance_output::Builder,
) -> Result<crate::output::delete_db_instance_output::Builder, smithy_xml::decode::XmlError> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("DeleteDBInstanceResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected DeleteDBInstanceResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("DeleteDBInstanceResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected DeleteDBInstanceResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("DBInstance") /* DBInstance com.amazonaws.docdb#DeleteDBInstanceOutput$DBInstance */ =>  {
                let var_61 =
                    Some(
                        crate::xml_deser::deser_structure_db_instance(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_db_instance(var_61);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected DeleteDBInstanceResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_invalid_db_subnet_state_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::invalid_db_subnet_state_fault::Builder,
) -> Result<crate::error::invalid_db_subnet_state_fault::Builder, smithy_xml::decode::XmlError> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#InvalidDBSubnetStateFault$message */ =>  {
                let var_62 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_62);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_invalid_event_subscription_state_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::invalid_event_subscription_state_fault::Builder,
) -> Result<
    crate::error::invalid_event_subscription_state_fault::Builder,
    smithy_xml::decode::XmlError,
> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#InvalidEventSubscriptionStateFault$message */ =>  {
                let var_63 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_63);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_delete_event_subscription(
    inp: &[u8],
    mut builder: crate::output::delete_event_subscription_output::Builder,
) -> Result<crate::output::delete_event_subscription_output::Builder, smithy_xml::decode::XmlError>
{
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("DeleteEventSubscriptionResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected DeleteEventSubscriptionResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("DeleteEventSubscriptionResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected DeleteEventSubscriptionResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("EventSubscription") /* EventSubscription com.amazonaws.docdb#DeleteEventSubscriptionOutput$EventSubscription */ =>  {
                let var_64 =
                    Some(
                        crate::xml_deser::deser_structure_event_subscription(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_event_subscription(var_64);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected DeleteEventSubscriptionResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_delete_global_cluster(
    inp: &[u8],
    mut builder: crate::output::delete_global_cluster_output::Builder,
) -> Result<crate::output::delete_global_cluster_output::Builder, smithy_xml::decode::XmlError> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("DeleteGlobalClusterResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected DeleteGlobalClusterResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("DeleteGlobalClusterResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected DeleteGlobalClusterResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("GlobalCluster") /* GlobalCluster com.amazonaws.docdb#DeleteGlobalClusterOutput$GlobalCluster */ =>  {
                let var_65 =
                    Some(
                        crate::xml_deser::deser_structure_global_cluster(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_global_cluster(var_65);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected DeleteGlobalClusterResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_certificate_not_found_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::certificate_not_found_fault::Builder,
) -> Result<crate::error::certificate_not_found_fault::Builder, smithy_xml::decode::XmlError> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#CertificateNotFoundFault$message */ =>  {
                let var_66 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_66);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_describe_certificates(
    inp: &[u8],
    mut builder: crate::output::describe_certificates_output::Builder,
) -> Result<crate::output::describe_certificates_output::Builder, smithy_xml::decode::XmlError> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("DescribeCertificatesResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected DescribeCertificatesResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("DescribeCertificatesResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected DescribeCertificatesResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("Certificates") /* Certificates com.amazonaws.docdb#DescribeCertificatesOutput$Certificates */ =>  {
                let var_67 =
                    Some(
                        crate::xml_deser::deser_list_certificate_list(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_certificates(var_67);
            }
            ,
            s if s.matches("Marker") /* Marker com.amazonaws.docdb#DescribeCertificatesOutput$Marker */ =>  {
                let var_68 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_marker(var_68);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected DescribeCertificatesResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_describe_db_cluster_parameter_groups(
    inp: &[u8],
    mut builder: crate::output::describe_db_cluster_parameter_groups_output::Builder,
) -> Result<
    crate::output::describe_db_cluster_parameter_groups_output::Builder,
    smithy_xml::decode::XmlError,
> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("DescribeDBClusterParameterGroupsResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected DescribeDBClusterParameterGroupsResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("DescribeDBClusterParameterGroupsResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected DescribeDBClusterParameterGroupsResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("Marker") /* Marker com.amazonaws.docdb#DescribeDBClusterParameterGroupsOutput$Marker */ =>  {
                let var_69 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_marker(var_69);
            }
            ,
            s if s.matches("DBClusterParameterGroups") /* DBClusterParameterGroups com.amazonaws.docdb#DescribeDBClusterParameterGroupsOutput$DBClusterParameterGroups */ =>  {
                let var_70 =
                    Some(
                        crate::xml_deser::deser_list_db_cluster_parameter_group_list(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_db_cluster_parameter_groups(var_70);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected DescribeDBClusterParameterGroupsResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_describe_db_cluster_parameters(
    inp: &[u8],
    mut builder: crate::output::describe_db_cluster_parameters_output::Builder,
) -> Result<
    crate::output::describe_db_cluster_parameters_output::Builder,
    smithy_xml::decode::XmlError,
> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("DescribeDBClusterParametersResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected DescribeDBClusterParametersResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("DescribeDBClusterParametersResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected DescribeDBClusterParametersResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("Parameters") /* Parameters com.amazonaws.docdb#DescribeDBClusterParametersOutput$Parameters */ =>  {
                let var_71 =
                    Some(
                        crate::xml_deser::deser_list_parameters_list(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_parameters(var_71);
            }
            ,
            s if s.matches("Marker") /* Marker com.amazonaws.docdb#DescribeDBClusterParametersOutput$Marker */ =>  {
                let var_72 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_marker(var_72);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected DescribeDBClusterParametersResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_describe_db_clusters(
    inp: &[u8],
    mut builder: crate::output::describe_db_clusters_output::Builder,
) -> Result<crate::output::describe_db_clusters_output::Builder, smithy_xml::decode::XmlError> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("DescribeDBClustersResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected DescribeDBClustersResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("DescribeDBClustersResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected DescribeDBClustersResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("Marker") /* Marker com.amazonaws.docdb#DescribeDBClustersOutput$Marker */ =>  {
                let var_73 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_marker(var_73);
            }
            ,
            s if s.matches("DBClusters") /* DBClusters com.amazonaws.docdb#DescribeDBClustersOutput$DBClusters */ =>  {
                let var_74 =
                    Some(
                        crate::xml_deser::deser_list_db_cluster_list(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_db_clusters(var_74);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected DescribeDBClustersResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_describe_db_cluster_snapshot_attributes(
    inp: &[u8],
    mut builder: crate::output::describe_db_cluster_snapshot_attributes_output::Builder,
) -> Result<
    crate::output::describe_db_cluster_snapshot_attributes_output::Builder,
    smithy_xml::decode::XmlError,
> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("DescribeDBClusterSnapshotAttributesResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected DescribeDBClusterSnapshotAttributesResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("DescribeDBClusterSnapshotAttributesResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected DescribeDBClusterSnapshotAttributesResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("DBClusterSnapshotAttributesResult") /* DBClusterSnapshotAttributesResult com.amazonaws.docdb#DescribeDBClusterSnapshotAttributesOutput$DBClusterSnapshotAttributesResult */ =>  {
                let var_75 =
                    Some(
                        crate::xml_deser::deser_structure_db_cluster_snapshot_attributes_result(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_db_cluster_snapshot_attributes_result(var_75);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected DescribeDBClusterSnapshotAttributesResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_describe_db_cluster_snapshots(
    inp: &[u8],
    mut builder: crate::output::describe_db_cluster_snapshots_output::Builder,
) -> Result<
    crate::output::describe_db_cluster_snapshots_output::Builder,
    smithy_xml::decode::XmlError,
> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("DescribeDBClusterSnapshotsResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected DescribeDBClusterSnapshotsResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("DescribeDBClusterSnapshotsResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected DescribeDBClusterSnapshotsResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("Marker") /* Marker com.amazonaws.docdb#DescribeDBClusterSnapshotsOutput$Marker */ =>  {
                let var_76 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_marker(var_76);
            }
            ,
            s if s.matches("DBClusterSnapshots") /* DBClusterSnapshots com.amazonaws.docdb#DescribeDBClusterSnapshotsOutput$DBClusterSnapshots */ =>  {
                let var_77 =
                    Some(
                        crate::xml_deser::deser_list_db_cluster_snapshot_list(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_db_cluster_snapshots(var_77);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected DescribeDBClusterSnapshotsResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_describe_db_engine_versions(
    inp: &[u8],
    mut builder: crate::output::describe_db_engine_versions_output::Builder,
) -> Result<crate::output::describe_db_engine_versions_output::Builder, smithy_xml::decode::XmlError>
{
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("DescribeDBEngineVersionsResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected DescribeDBEngineVersionsResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("DescribeDBEngineVersionsResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected DescribeDBEngineVersionsResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("Marker") /* Marker com.amazonaws.docdb#DescribeDBEngineVersionsOutput$Marker */ =>  {
                let var_78 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_marker(var_78);
            }
            ,
            s if s.matches("DBEngineVersions") /* DBEngineVersions com.amazonaws.docdb#DescribeDBEngineVersionsOutput$DBEngineVersions */ =>  {
                let var_79 =
                    Some(
                        crate::xml_deser::deser_list_db_engine_version_list(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_db_engine_versions(var_79);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected DescribeDBEngineVersionsResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_describe_db_instances(
    inp: &[u8],
    mut builder: crate::output::describe_db_instances_output::Builder,
) -> Result<crate::output::describe_db_instances_output::Builder, smithy_xml::decode::XmlError> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("DescribeDBInstancesResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected DescribeDBInstancesResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("DescribeDBInstancesResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected DescribeDBInstancesResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("Marker") /* Marker com.amazonaws.docdb#DescribeDBInstancesOutput$Marker */ =>  {
                let var_80 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_marker(var_80);
            }
            ,
            s if s.matches("DBInstances") /* DBInstances com.amazonaws.docdb#DescribeDBInstancesOutput$DBInstances */ =>  {
                let var_81 =
                    Some(
                        crate::xml_deser::deser_list_db_instance_list(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_db_instances(var_81);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected DescribeDBInstancesResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_describe_db_subnet_groups(
    inp: &[u8],
    mut builder: crate::output::describe_db_subnet_groups_output::Builder,
) -> Result<crate::output::describe_db_subnet_groups_output::Builder, smithy_xml::decode::XmlError>
{
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("DescribeDBSubnetGroupsResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected DescribeDBSubnetGroupsResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("DescribeDBSubnetGroupsResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected DescribeDBSubnetGroupsResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("Marker") /* Marker com.amazonaws.docdb#DescribeDBSubnetGroupsOutput$Marker */ =>  {
                let var_82 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_marker(var_82);
            }
            ,
            s if s.matches("DBSubnetGroups") /* DBSubnetGroups com.amazonaws.docdb#DescribeDBSubnetGroupsOutput$DBSubnetGroups */ =>  {
                let var_83 =
                    Some(
                        crate::xml_deser::deser_list_db_subnet_groups(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_db_subnet_groups(var_83);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected DescribeDBSubnetGroupsResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_describe_engine_default_cluster_parameters(
    inp: &[u8],
    mut builder: crate::output::describe_engine_default_cluster_parameters_output::Builder,
) -> Result<
    crate::output::describe_engine_default_cluster_parameters_output::Builder,
    smithy_xml::decode::XmlError,
> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("DescribeEngineDefaultClusterParametersResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected DescribeEngineDefaultClusterParametersResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("DescribeEngineDefaultClusterParametersResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected DescribeEngineDefaultClusterParametersResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("EngineDefaults") /* EngineDefaults com.amazonaws.docdb#DescribeEngineDefaultClusterParametersOutput$EngineDefaults */ =>  {
                let var_84 =
                    Some(
                        crate::xml_deser::deser_structure_engine_defaults(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_engine_defaults(var_84);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected DescribeEngineDefaultClusterParametersResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_describe_event_categories(
    inp: &[u8],
    mut builder: crate::output::describe_event_categories_output::Builder,
) -> Result<crate::output::describe_event_categories_output::Builder, smithy_xml::decode::XmlError>
{
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("DescribeEventCategoriesResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected DescribeEventCategoriesResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("DescribeEventCategoriesResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected DescribeEventCategoriesResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("EventCategoriesMapList") /* EventCategoriesMapList com.amazonaws.docdb#DescribeEventCategoriesOutput$EventCategoriesMapList */ =>  {
                let var_85 =
                    Some(
                        crate::xml_deser::deser_list_event_categories_map_list(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_event_categories_map_list(var_85);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected DescribeEventCategoriesResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_describe_events(
    inp: &[u8],
    mut builder: crate::output::describe_events_output::Builder,
) -> Result<crate::output::describe_events_output::Builder, smithy_xml::decode::XmlError> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("DescribeEventsResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected DescribeEventsResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("DescribeEventsResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected DescribeEventsResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("Marker") /* Marker com.amazonaws.docdb#DescribeEventsOutput$Marker */ =>  {
                let var_86 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_marker(var_86);
            }
            ,
            s if s.matches("Events") /* Events com.amazonaws.docdb#DescribeEventsOutput$Events */ =>  {
                let var_87 =
                    Some(
                        crate::xml_deser::deser_list_event_list(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_events(var_87);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected DescribeEventsResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_describe_event_subscriptions(
    inp: &[u8],
    mut builder: crate::output::describe_event_subscriptions_output::Builder,
) -> Result<crate::output::describe_event_subscriptions_output::Builder, smithy_xml::decode::XmlError>
{
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("DescribeEventSubscriptionsResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected DescribeEventSubscriptionsResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("DescribeEventSubscriptionsResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected DescribeEventSubscriptionsResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("Marker") /* Marker com.amazonaws.docdb#DescribeEventSubscriptionsOutput$Marker */ =>  {
                let var_88 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_marker(var_88);
            }
            ,
            s if s.matches("EventSubscriptionsList") /* EventSubscriptionsList com.amazonaws.docdb#DescribeEventSubscriptionsOutput$EventSubscriptionsList */ =>  {
                let var_89 =
                    Some(
                        crate::xml_deser::deser_list_event_subscriptions_list(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_event_subscriptions_list(var_89);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected DescribeEventSubscriptionsResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_describe_global_clusters(
    inp: &[u8],
    mut builder: crate::output::describe_global_clusters_output::Builder,
) -> Result<crate::output::describe_global_clusters_output::Builder, smithy_xml::decode::XmlError> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("DescribeGlobalClustersResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected DescribeGlobalClustersResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("DescribeGlobalClustersResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected DescribeGlobalClustersResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("Marker") /* Marker com.amazonaws.docdb#DescribeGlobalClustersOutput$Marker */ =>  {
                let var_90 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_marker(var_90);
            }
            ,
            s if s.matches("GlobalClusters") /* GlobalClusters com.amazonaws.docdb#DescribeGlobalClustersOutput$GlobalClusters */ =>  {
                let var_91 =
                    Some(
                        crate::xml_deser::deser_list_global_cluster_list(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_global_clusters(var_91);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected DescribeGlobalClustersResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_describe_orderable_db_instance_options(
    inp: &[u8],
    mut builder: crate::output::describe_orderable_db_instance_options_output::Builder,
) -> Result<
    crate::output::describe_orderable_db_instance_options_output::Builder,
    smithy_xml::decode::XmlError,
> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("DescribeOrderableDBInstanceOptionsResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected DescribeOrderableDBInstanceOptionsResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("DescribeOrderableDBInstanceOptionsResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected DescribeOrderableDBInstanceOptionsResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("OrderableDBInstanceOptions") /* OrderableDBInstanceOptions com.amazonaws.docdb#DescribeOrderableDBInstanceOptionsOutput$OrderableDBInstanceOptions */ =>  {
                let var_92 =
                    Some(
                        crate::xml_deser::deser_list_orderable_db_instance_options_list(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_orderable_db_instance_options(var_92);
            }
            ,
            s if s.matches("Marker") /* Marker com.amazonaws.docdb#DescribeOrderableDBInstanceOptionsOutput$Marker */ =>  {
                let var_93 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_marker(var_93);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected DescribeOrderableDBInstanceOptionsResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_describe_pending_maintenance_actions(
    inp: &[u8],
    mut builder: crate::output::describe_pending_maintenance_actions_output::Builder,
) -> Result<
    crate::output::describe_pending_maintenance_actions_output::Builder,
    smithy_xml::decode::XmlError,
> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("DescribePendingMaintenanceActionsResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected DescribePendingMaintenanceActionsResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("DescribePendingMaintenanceActionsResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected DescribePendingMaintenanceActionsResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("PendingMaintenanceActions") /* PendingMaintenanceActions com.amazonaws.docdb#DescribePendingMaintenanceActionsOutput$PendingMaintenanceActions */ =>  {
                let var_94 =
                    Some(
                        crate::xml_deser::deser_list_pending_maintenance_actions(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_pending_maintenance_actions(var_94);
            }
            ,
            s if s.matches("Marker") /* Marker com.amazonaws.docdb#DescribePendingMaintenanceActionsOutput$Marker */ =>  {
                let var_95 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_marker(var_95);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected DescribePendingMaintenanceActionsResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_failover_db_cluster(
    inp: &[u8],
    mut builder: crate::output::failover_db_cluster_output::Builder,
) -> Result<crate::output::failover_db_cluster_output::Builder, smithy_xml::decode::XmlError> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("FailoverDBClusterResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected FailoverDBClusterResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("FailoverDBClusterResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected FailoverDBClusterResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("DBCluster") /* DBCluster com.amazonaws.docdb#FailoverDBClusterOutput$DBCluster */ =>  {
                let var_96 =
                    Some(
                        crate::xml_deser::deser_structure_db_cluster(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_db_cluster(var_96);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected FailoverDBClusterResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_list_tags_for_resource(
    inp: &[u8],
    mut builder: crate::output::list_tags_for_resource_output::Builder,
) -> Result<crate::output::list_tags_for_resource_output::Builder, smithy_xml::decode::XmlError> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("ListTagsForResourceResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected ListTagsForResourceResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("ListTagsForResourceResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected ListTagsForResourceResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("TagList") /* TagList com.amazonaws.docdb#ListTagsForResourceOutput$TagList */ =>  {
                let var_97 =
                    Some(
                        crate::xml_deser::deser_list_tag_list(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_tag_list(var_97);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected ListTagsForResourceResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_invalid_db_security_group_state_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::invalid_db_security_group_state_fault::Builder,
) -> Result<
    crate::error::invalid_db_security_group_state_fault::Builder,
    smithy_xml::decode::XmlError,
> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#InvalidDBSecurityGroupStateFault$message */ =>  {
                let var_98 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_98);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_modify_db_cluster(
    inp: &[u8],
    mut builder: crate::output::modify_db_cluster_output::Builder,
) -> Result<crate::output::modify_db_cluster_output::Builder, smithy_xml::decode::XmlError> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("ModifyDBClusterResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected ModifyDBClusterResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("ModifyDBClusterResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected ModifyDBClusterResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("DBCluster") /* DBCluster com.amazonaws.docdb#ModifyDBClusterOutput$DBCluster */ =>  {
                let var_99 =
                    Some(
                        crate::xml_deser::deser_structure_db_cluster(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_db_cluster(var_99);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected ModifyDBClusterResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_modify_db_cluster_parameter_group(
    inp: &[u8],
    mut builder: crate::output::modify_db_cluster_parameter_group_output::Builder,
) -> Result<
    crate::output::modify_db_cluster_parameter_group_output::Builder,
    smithy_xml::decode::XmlError,
> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("ModifyDBClusterParameterGroupResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected ModifyDBClusterParameterGroupResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("ModifyDBClusterParameterGroupResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected ModifyDBClusterParameterGroupResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("DBClusterParameterGroupName") /* DBClusterParameterGroupName com.amazonaws.docdb#ModifyDBClusterParameterGroupOutput$DBClusterParameterGroupName */ =>  {
                let var_100 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_db_cluster_parameter_group_name(var_100);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected ModifyDBClusterParameterGroupResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_shared_snapshot_quota_exceeded_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::shared_snapshot_quota_exceeded_fault::Builder,
) -> Result<crate::error::shared_snapshot_quota_exceeded_fault::Builder, smithy_xml::decode::XmlError>
{
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#SharedSnapshotQuotaExceededFault$message */ =>  {
                let var_101 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_101);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_modify_db_cluster_snapshot_attribute(
    inp: &[u8],
    mut builder: crate::output::modify_db_cluster_snapshot_attribute_output::Builder,
) -> Result<
    crate::output::modify_db_cluster_snapshot_attribute_output::Builder,
    smithy_xml::decode::XmlError,
> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("ModifyDBClusterSnapshotAttributeResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected ModifyDBClusterSnapshotAttributeResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("ModifyDBClusterSnapshotAttributeResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected ModifyDBClusterSnapshotAttributeResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("DBClusterSnapshotAttributesResult") /* DBClusterSnapshotAttributesResult com.amazonaws.docdb#ModifyDBClusterSnapshotAttributeOutput$DBClusterSnapshotAttributesResult */ =>  {
                let var_102 =
                    Some(
                        crate::xml_deser::deser_structure_db_cluster_snapshot_attributes_result(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_db_cluster_snapshot_attributes_result(var_102);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected ModifyDBClusterSnapshotAttributeResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_db_upgrade_dependency_failure_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::db_upgrade_dependency_failure_fault::Builder,
) -> Result<crate::error::db_upgrade_dependency_failure_fault::Builder, smithy_xml::decode::XmlError>
{
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#DBUpgradeDependencyFailureFault$message */ =>  {
                let var_103 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_103);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_modify_db_instance(
    inp: &[u8],
    mut builder: crate::output::modify_db_instance_output::Builder,
) -> Result<crate::output::modify_db_instance_output::Builder, smithy_xml::decode::XmlError> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("ModifyDBInstanceResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected ModifyDBInstanceResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("ModifyDBInstanceResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected ModifyDBInstanceResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("DBInstance") /* DBInstance com.amazonaws.docdb#ModifyDBInstanceOutput$DBInstance */ =>  {
                let var_104 =
                    Some(
                        crate::xml_deser::deser_structure_db_instance(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_db_instance(var_104);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected ModifyDBInstanceResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_subnet_already_in_use_xml_err(
    inp: &[u8],
    mut builder: crate::error::subnet_already_in_use::Builder,
) -> Result<crate::error::subnet_already_in_use::Builder, smithy_xml::decode::XmlError> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#SubnetAlreadyInUse$message */ =>  {
                let var_105 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_105);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_modify_db_subnet_group(
    inp: &[u8],
    mut builder: crate::output::modify_db_subnet_group_output::Builder,
) -> Result<crate::output::modify_db_subnet_group_output::Builder, smithy_xml::decode::XmlError> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("ModifyDBSubnetGroupResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected ModifyDBSubnetGroupResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("ModifyDBSubnetGroupResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected ModifyDBSubnetGroupResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("DBSubnetGroup") /* DBSubnetGroup com.amazonaws.docdb#ModifyDBSubnetGroupOutput$DBSubnetGroup */ =>  {
                let var_106 =
                    Some(
                        crate::xml_deser::deser_structure_db_subnet_group(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_db_subnet_group(var_106);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected ModifyDBSubnetGroupResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_modify_event_subscription(
    inp: &[u8],
    mut builder: crate::output::modify_event_subscription_output::Builder,
) -> Result<crate::output::modify_event_subscription_output::Builder, smithy_xml::decode::XmlError>
{
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("ModifyEventSubscriptionResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected ModifyEventSubscriptionResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("ModifyEventSubscriptionResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected ModifyEventSubscriptionResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("EventSubscription") /* EventSubscription com.amazonaws.docdb#ModifyEventSubscriptionOutput$EventSubscription */ =>  {
                let var_107 =
                    Some(
                        crate::xml_deser::deser_structure_event_subscription(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_event_subscription(var_107);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected ModifyEventSubscriptionResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_modify_global_cluster(
    inp: &[u8],
    mut builder: crate::output::modify_global_cluster_output::Builder,
) -> Result<crate::output::modify_global_cluster_output::Builder, smithy_xml::decode::XmlError> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("ModifyGlobalClusterResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected ModifyGlobalClusterResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("ModifyGlobalClusterResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected ModifyGlobalClusterResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("GlobalCluster") /* GlobalCluster com.amazonaws.docdb#ModifyGlobalClusterOutput$GlobalCluster */ =>  {
                let var_108 =
                    Some(
                        crate::xml_deser::deser_structure_global_cluster(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_global_cluster(var_108);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected ModifyGlobalClusterResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_reboot_db_instance(
    inp: &[u8],
    mut builder: crate::output::reboot_db_instance_output::Builder,
) -> Result<crate::output::reboot_db_instance_output::Builder, smithy_xml::decode::XmlError> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("RebootDBInstanceResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected RebootDBInstanceResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("RebootDBInstanceResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected RebootDBInstanceResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("DBInstance") /* DBInstance com.amazonaws.docdb#RebootDBInstanceOutput$DBInstance */ =>  {
                let var_109 =
                    Some(
                        crate::xml_deser::deser_structure_db_instance(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_db_instance(var_109);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected RebootDBInstanceResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_remove_from_global_cluster(
    inp: &[u8],
    mut builder: crate::output::remove_from_global_cluster_output::Builder,
) -> Result<crate::output::remove_from_global_cluster_output::Builder, smithy_xml::decode::XmlError>
{
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("RemoveFromGlobalClusterResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected RemoveFromGlobalClusterResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("RemoveFromGlobalClusterResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected RemoveFromGlobalClusterResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("GlobalCluster") /* GlobalCluster com.amazonaws.docdb#RemoveFromGlobalClusterOutput$GlobalCluster */ =>  {
                let var_110 =
                    Some(
                        crate::xml_deser::deser_structure_global_cluster(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_global_cluster(var_110);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected RemoveFromGlobalClusterResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_remove_source_identifier_from_subscription(
    inp: &[u8],
    mut builder: crate::output::remove_source_identifier_from_subscription_output::Builder,
) -> Result<
    crate::output::remove_source_identifier_from_subscription_output::Builder,
    smithy_xml::decode::XmlError,
> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("RemoveSourceIdentifierFromSubscriptionResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected RemoveSourceIdentifierFromSubscriptionResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("RemoveSourceIdentifierFromSubscriptionResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected RemoveSourceIdentifierFromSubscriptionResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("EventSubscription") /* EventSubscription com.amazonaws.docdb#RemoveSourceIdentifierFromSubscriptionOutput$EventSubscription */ =>  {
                let var_111 =
                    Some(
                        crate::xml_deser::deser_structure_event_subscription(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_event_subscription(var_111);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected RemoveSourceIdentifierFromSubscriptionResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_reset_db_cluster_parameter_group(
    inp: &[u8],
    mut builder: crate::output::reset_db_cluster_parameter_group_output::Builder,
) -> Result<
    crate::output::reset_db_cluster_parameter_group_output::Builder,
    smithy_xml::decode::XmlError,
> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("ResetDBClusterParameterGroupResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected ResetDBClusterParameterGroupResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("ResetDBClusterParameterGroupResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected ResetDBClusterParameterGroupResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("DBClusterParameterGroupName") /* DBClusterParameterGroupName com.amazonaws.docdb#ResetDBClusterParameterGroupOutput$DBClusterParameterGroupName */ =>  {
                let var_112 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_db_cluster_parameter_group_name(var_112);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected ResetDBClusterParameterGroupResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_insufficient_db_cluster_capacity_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::insufficient_db_cluster_capacity_fault::Builder,
) -> Result<
    crate::error::insufficient_db_cluster_capacity_fault::Builder,
    smithy_xml::decode::XmlError,
> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#InsufficientDBClusterCapacityFault$message */ =>  {
                let var_113 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_113);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_invalid_db_snapshot_state_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::invalid_db_snapshot_state_fault::Builder,
) -> Result<crate::error::invalid_db_snapshot_state_fault::Builder, smithy_xml::decode::XmlError> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#InvalidDBSnapshotStateFault$message */ =>  {
                let var_114 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_114);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_structure_invalid_restore_fault_xml_err(
    inp: &[u8],
    mut builder: crate::error::invalid_restore_fault::Builder,
) -> Result<crate::error::invalid_restore_fault::Builder, smithy_xml::decode::XmlError> {
    if inp.is_empty() {
        return Ok(builder);
    }
    use std::convert::TryFrom;
    let mut document = smithy_xml::decode::Document::try_from(inp)?;
    #[allow(unused_mut)]
    let mut error_decoder = crate::rest_xml_wrapped_errors::error_scope(&mut document)?;
    while let Some(mut tag) = error_decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("message") /* message com.amazonaws.docdb#InvalidRestoreFault$message */ =>  {
                let var_115 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_115);
            }
            ,
            _ => {}
        }
    }
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_restore_db_cluster_from_snapshot(
    inp: &[u8],
    mut builder: crate::output::restore_db_cluster_from_snapshot_output::Builder,
) -> Result<
    crate::output::restore_db_cluster_from_snapshot_output::Builder,
    smithy_xml::decode::XmlError,
> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("RestoreDBClusterFromSnapshotResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected RestoreDBClusterFromSnapshotResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("RestoreDBClusterFromSnapshotResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected RestoreDBClusterFromSnapshotResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("DBCluster") /* DBCluster com.amazonaws.docdb#RestoreDBClusterFromSnapshotOutput$DBCluster */ =>  {
                let var_116 =
                    Some(
                        crate::xml_deser::deser_structure_db_cluster(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_db_cluster(var_116);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected RestoreDBClusterFromSnapshotResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_restore_db_cluster_to_point_in_time(
    inp: &[u8],
    mut builder: crate::output::restore_db_cluster_to_point_in_time_output::Builder,
) -> Result<
    crate::output::restore_db_cluster_to_point_in_time_output::Builder,
    smithy_xml::decode::XmlError,
> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("RestoreDBClusterToPointInTimeResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected RestoreDBClusterToPointInTimeResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("RestoreDBClusterToPointInTimeResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected RestoreDBClusterToPointInTimeResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("DBCluster") /* DBCluster com.amazonaws.docdb#RestoreDBClusterToPointInTimeOutput$DBCluster */ =>  {
                let var_117 =
                    Some(
                        crate::xml_deser::deser_structure_db_cluster(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_db_cluster(var_117);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected RestoreDBClusterToPointInTimeResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_start_db_cluster(
    inp: &[u8],
    mut builder: crate::output::start_db_cluster_output::Builder,
) -> Result<crate::output::start_db_cluster_output::Builder, smithy_xml::decode::XmlError> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("StartDBClusterResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected StartDBClusterResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("StartDBClusterResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected StartDBClusterResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("DBCluster") /* DBCluster com.amazonaws.docdb#StartDBClusterOutput$DBCluster */ =>  {
                let var_118 =
                    Some(
                        crate::xml_deser::deser_structure_db_cluster(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_db_cluster(var_118);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected StartDBClusterResult tag",
        ));
    };
    Ok(builder)
}

#[allow(unused_mut)]
pub fn deser_operation_stop_db_cluster(
    inp: &[u8],
    mut builder: crate::output::stop_db_cluster_output::Builder,
) -> Result<crate::output::stop_db_cluster_output::Builder, smithy_xml::decode::XmlError> {
    use std::convert::TryFrom;
    let mut doc = smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("StopDBClusterResponse")) {
        return Err(smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected StopDBClusterResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("StopDBClusterResult")) {
            return Err(smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected StopDBClusterResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("DBCluster") /* DBCluster com.amazonaws.docdb#StopDBClusterOutput$DBCluster */ =>  {
                let var_119 =
                    Some(
                        crate::xml_deser::deser_structure_db_cluster(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_db_cluster(var_119);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(smithy_xml::decode::XmlError::custom(
            "expected StopDBClusterResult tag",
        ));
    };
    Ok(builder)
}

pub fn deser_structure_event_subscription(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<crate::model::EventSubscription, smithy_xml::decode::XmlError> {
    #[allow(unused_mut)]
    let mut builder = crate::model::EventSubscription::builder();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("CustomerAwsId") /* CustomerAwsId com.amazonaws.docdb#EventSubscription$CustomerAwsId */ =>  {
                let var_120 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_customer_aws_id(var_120);
            }
            ,
            s if s.matches("CustSubscriptionId") /* CustSubscriptionId com.amazonaws.docdb#EventSubscription$CustSubscriptionId */ =>  {
                let var_121 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_cust_subscription_id(var_121);
            }
            ,
            s if s.matches("SnsTopicArn") /* SnsTopicArn com.amazonaws.docdb#EventSubscription$SnsTopicArn */ =>  {
                let var_122 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_sns_topic_arn(var_122);
            }
            ,
            s if s.matches("Status") /* Status com.amazonaws.docdb#EventSubscription$Status */ =>  {
                let var_123 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_status(var_123);
            }
            ,
            s if s.matches("SubscriptionCreationTime") /* SubscriptionCreationTime com.amazonaws.docdb#EventSubscription$SubscriptionCreationTime */ =>  {
                let var_124 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_subscription_creation_time(var_124);
            }
            ,
            s if s.matches("SourceType") /* SourceType com.amazonaws.docdb#EventSubscription$SourceType */ =>  {
                let var_125 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_source_type(var_125);
            }
            ,
            s if s.matches("SourceIdsList") /* SourceIdsList com.amazonaws.docdb#EventSubscription$SourceIdsList */ =>  {
                let var_126 =
                    Some(
                        crate::xml_deser::deser_list_source_ids_list(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_source_ids_list(var_126);
            }
            ,
            s if s.matches("EventCategoriesList") /* EventCategoriesList com.amazonaws.docdb#EventSubscription$EventCategoriesList */ =>  {
                let var_127 =
                    Some(
                        crate::xml_deser::deser_list_event_categories_list(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_event_categories_list(var_127);
            }
            ,
            s if s.matches("Enabled") /* Enabled com.amazonaws.docdb#EventSubscription$Enabled */ =>  {
                let var_128 =
                    Some(
                         {
                            <bool as smithy_types::primitive::Parse>::parse_smithy_primitive(
                                smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            )
                            .map_err(|_|smithy_xml::decode::XmlError::custom("expected (boolean: `com.amazonaws.docdb#Boolean`)"))
                        }
                        ?
                    )
                ;
                builder = builder.set_enabled(var_128);
            }
            ,
            s if s.matches("EventSubscriptionArn") /* EventSubscriptionArn com.amazonaws.docdb#EventSubscription$EventSubscriptionArn */ =>  {
                let var_129 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_event_subscription_arn(var_129);
            }
            ,
            _ => {}
        }
    }
    Ok(builder.build())
}

pub fn deser_structure_resource_pending_maintenance_actions(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<crate::model::ResourcePendingMaintenanceActions, smithy_xml::decode::XmlError> {
    #[allow(unused_mut)]
    let mut builder = crate::model::ResourcePendingMaintenanceActions::builder();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("ResourceIdentifier") /* ResourceIdentifier com.amazonaws.docdb#ResourcePendingMaintenanceActions$ResourceIdentifier */ =>  {
                let var_130 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_resource_identifier(var_130);
            }
            ,
            s if s.matches("PendingMaintenanceActionDetails") /* PendingMaintenanceActionDetails com.amazonaws.docdb#ResourcePendingMaintenanceActions$PendingMaintenanceActionDetails */ =>  {
                let var_131 =
                    Some(
                        crate::xml_deser::deser_list_pending_maintenance_action_details(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_pending_maintenance_action_details(var_131);
            }
            ,
            _ => {}
        }
    }
    Ok(builder.build())
}

pub fn deser_structure_db_cluster_parameter_group(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<crate::model::DbClusterParameterGroup, smithy_xml::decode::XmlError> {
    #[allow(unused_mut)]
    let mut builder = crate::model::DbClusterParameterGroup::builder();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("DBClusterParameterGroupName") /* DBClusterParameterGroupName com.amazonaws.docdb#DBClusterParameterGroup$DBClusterParameterGroupName */ =>  {
                let var_132 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_db_cluster_parameter_group_name(var_132);
            }
            ,
            s if s.matches("DBParameterGroupFamily") /* DBParameterGroupFamily com.amazonaws.docdb#DBClusterParameterGroup$DBParameterGroupFamily */ =>  {
                let var_133 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_db_parameter_group_family(var_133);
            }
            ,
            s if s.matches("Description") /* Description com.amazonaws.docdb#DBClusterParameterGroup$Description */ =>  {
                let var_134 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_description(var_134);
            }
            ,
            s if s.matches("DBClusterParameterGroupArn") /* DBClusterParameterGroupArn com.amazonaws.docdb#DBClusterParameterGroup$DBClusterParameterGroupArn */ =>  {
                let var_135 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_db_cluster_parameter_group_arn(var_135);
            }
            ,
            _ => {}
        }
    }
    Ok(builder.build())
}

pub fn deser_structure_db_cluster_snapshot(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<crate::model::DbClusterSnapshot, smithy_xml::decode::XmlError> {
    #[allow(unused_mut)]
    let mut builder = crate::model::DbClusterSnapshot::builder();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("AvailabilityZones") /* AvailabilityZones com.amazonaws.docdb#DBClusterSnapshot$AvailabilityZones */ =>  {
                let var_136 =
                    Some(
                        crate::xml_deser::deser_list_availability_zones(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_availability_zones(var_136);
            }
            ,
            s if s.matches("DBClusterSnapshotIdentifier") /* DBClusterSnapshotIdentifier com.amazonaws.docdb#DBClusterSnapshot$DBClusterSnapshotIdentifier */ =>  {
                let var_137 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_db_cluster_snapshot_identifier(var_137);
            }
            ,
            s if s.matches("DBClusterIdentifier") /* DBClusterIdentifier com.amazonaws.docdb#DBClusterSnapshot$DBClusterIdentifier */ =>  {
                let var_138 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_db_cluster_identifier(var_138);
            }
            ,
            s if s.matches("SnapshotCreateTime") /* SnapshotCreateTime com.amazonaws.docdb#DBClusterSnapshot$SnapshotCreateTime */ =>  {
                let var_139 =
                    Some(
                        smithy_types::Instant::from_str(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            , smithy_types::instant::Format::DateTime
                        )
                        .map_err(|_|smithy_xml::decode::XmlError::custom("expected (timestamp: `com.amazonaws.docdb#TStamp`)"))
                        ?
                    )
                ;
                builder = builder.set_snapshot_create_time(var_139);
            }
            ,
            s if s.matches("Engine") /* Engine com.amazonaws.docdb#DBClusterSnapshot$Engine */ =>  {
                let var_140 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_engine(var_140);
            }
            ,
            s if s.matches("Status") /* Status com.amazonaws.docdb#DBClusterSnapshot$Status */ =>  {
                let var_141 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_status(var_141);
            }
            ,
            s if s.matches("Port") /* Port com.amazonaws.docdb#DBClusterSnapshot$Port */ =>  {
                let var_142 =
                    Some(
                         {
                            <i32 as smithy_types::primitive::Parse>::parse_smithy_primitive(
                                smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            )
                            .map_err(|_|smithy_xml::decode::XmlError::custom("expected (integer: `com.amazonaws.docdb#Integer`)"))
                        }
                        ?
                    )
                ;
                builder = builder.set_port(var_142);
            }
            ,
            s if s.matches("VpcId") /* VpcId com.amazonaws.docdb#DBClusterSnapshot$VpcId */ =>  {
                let var_143 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_vpc_id(var_143);
            }
            ,
            s if s.matches("ClusterCreateTime") /* ClusterCreateTime com.amazonaws.docdb#DBClusterSnapshot$ClusterCreateTime */ =>  {
                let var_144 =
                    Some(
                        smithy_types::Instant::from_str(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            , smithy_types::instant::Format::DateTime
                        )
                        .map_err(|_|smithy_xml::decode::XmlError::custom("expected (timestamp: `com.amazonaws.docdb#TStamp`)"))
                        ?
                    )
                ;
                builder = builder.set_cluster_create_time(var_144);
            }
            ,
            s if s.matches("MasterUsername") /* MasterUsername com.amazonaws.docdb#DBClusterSnapshot$MasterUsername */ =>  {
                let var_145 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_master_username(var_145);
            }
            ,
            s if s.matches("EngineVersion") /* EngineVersion com.amazonaws.docdb#DBClusterSnapshot$EngineVersion */ =>  {
                let var_146 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_engine_version(var_146);
            }
            ,
            s if s.matches("SnapshotType") /* SnapshotType com.amazonaws.docdb#DBClusterSnapshot$SnapshotType */ =>  {
                let var_147 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_snapshot_type(var_147);
            }
            ,
            s if s.matches("PercentProgress") /* PercentProgress com.amazonaws.docdb#DBClusterSnapshot$PercentProgress */ =>  {
                let var_148 =
                    Some(
                         {
                            <i32 as smithy_types::primitive::Parse>::parse_smithy_primitive(
                                smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            )
                            .map_err(|_|smithy_xml::decode::XmlError::custom("expected (integer: `com.amazonaws.docdb#Integer`)"))
                        }
                        ?
                    )
                ;
                builder = builder.set_percent_progress(var_148);
            }
            ,
            s if s.matches("StorageEncrypted") /* StorageEncrypted com.amazonaws.docdb#DBClusterSnapshot$StorageEncrypted */ =>  {
                let var_149 =
                    Some(
                         {
                            <bool as smithy_types::primitive::Parse>::parse_smithy_primitive(
                                smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            )
                            .map_err(|_|smithy_xml::decode::XmlError::custom("expected (boolean: `com.amazonaws.docdb#Boolean`)"))
                        }
                        ?
                    )
                ;
                builder = builder.set_storage_encrypted(var_149);
            }
            ,
            s if s.matches("KmsKeyId") /* KmsKeyId com.amazonaws.docdb#DBClusterSnapshot$KmsKeyId */ =>  {
                let var_150 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_kms_key_id(var_150);
            }
            ,
            s if s.matches("DBClusterSnapshotArn") /* DBClusterSnapshotArn com.amazonaws.docdb#DBClusterSnapshot$DBClusterSnapshotArn */ =>  {
                let var_151 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_db_cluster_snapshot_arn(var_151);
            }
            ,
            s if s.matches("SourceDBClusterSnapshotArn") /* SourceDBClusterSnapshotArn com.amazonaws.docdb#DBClusterSnapshot$SourceDBClusterSnapshotArn */ =>  {
                let var_152 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_source_db_cluster_snapshot_arn(var_152);
            }
            ,
            _ => {}
        }
    }
    Ok(builder.build())
}

pub fn deser_structure_db_cluster(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<crate::model::DbCluster, smithy_xml::decode::XmlError> {
    #[allow(unused_mut)]
    let mut builder = crate::model::DbCluster::builder();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("AvailabilityZones") /* AvailabilityZones com.amazonaws.docdb#DBCluster$AvailabilityZones */ =>  {
                let var_153 =
                    Some(
                        crate::xml_deser::deser_list_availability_zones(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_availability_zones(var_153);
            }
            ,
            s if s.matches("BackupRetentionPeriod") /* BackupRetentionPeriod com.amazonaws.docdb#DBCluster$BackupRetentionPeriod */ =>  {
                let var_154 =
                    Some(
                         {
                            <i32 as smithy_types::primitive::Parse>::parse_smithy_primitive(
                                smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            )
                            .map_err(|_|smithy_xml::decode::XmlError::custom("expected (integer: `com.amazonaws.docdb#IntegerOptional`)"))
                        }
                        ?
                    )
                ;
                builder = builder.set_backup_retention_period(var_154);
            }
            ,
            s if s.matches("DBClusterIdentifier") /* DBClusterIdentifier com.amazonaws.docdb#DBCluster$DBClusterIdentifier */ =>  {
                let var_155 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_db_cluster_identifier(var_155);
            }
            ,
            s if s.matches("DBClusterParameterGroup") /* DBClusterParameterGroup com.amazonaws.docdb#DBCluster$DBClusterParameterGroup */ =>  {
                let var_156 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_db_cluster_parameter_group(var_156);
            }
            ,
            s if s.matches("DBSubnetGroup") /* DBSubnetGroup com.amazonaws.docdb#DBCluster$DBSubnetGroup */ =>  {
                let var_157 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_db_subnet_group(var_157);
            }
            ,
            s if s.matches("Status") /* Status com.amazonaws.docdb#DBCluster$Status */ =>  {
                let var_158 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_status(var_158);
            }
            ,
            s if s.matches("PercentProgress") /* PercentProgress com.amazonaws.docdb#DBCluster$PercentProgress */ =>  {
                let var_159 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_percent_progress(var_159);
            }
            ,
            s if s.matches("EarliestRestorableTime") /* EarliestRestorableTime com.amazonaws.docdb#DBCluster$EarliestRestorableTime */ =>  {
                let var_160 =
                    Some(
                        smithy_types::Instant::from_str(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            , smithy_types::instant::Format::DateTime
                        )
                        .map_err(|_|smithy_xml::decode::XmlError::custom("expected (timestamp: `com.amazonaws.docdb#TStamp`)"))
                        ?
                    )
                ;
                builder = builder.set_earliest_restorable_time(var_160);
            }
            ,
            s if s.matches("Endpoint") /* Endpoint com.amazonaws.docdb#DBCluster$Endpoint */ =>  {
                let var_161 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_endpoint(var_161);
            }
            ,
            s if s.matches("ReaderEndpoint") /* ReaderEndpoint com.amazonaws.docdb#DBCluster$ReaderEndpoint */ =>  {
                let var_162 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_reader_endpoint(var_162);
            }
            ,
            s if s.matches("MultiAZ") /* MultiAZ com.amazonaws.docdb#DBCluster$MultiAZ */ =>  {
                let var_163 =
                    Some(
                         {
                            <bool as smithy_types::primitive::Parse>::parse_smithy_primitive(
                                smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            )
                            .map_err(|_|smithy_xml::decode::XmlError::custom("expected (boolean: `com.amazonaws.docdb#Boolean`)"))
                        }
                        ?
                    )
                ;
                builder = builder.set_multi_az(var_163);
            }
            ,
            s if s.matches("Engine") /* Engine com.amazonaws.docdb#DBCluster$Engine */ =>  {
                let var_164 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_engine(var_164);
            }
            ,
            s if s.matches("EngineVersion") /* EngineVersion com.amazonaws.docdb#DBCluster$EngineVersion */ =>  {
                let var_165 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_engine_version(var_165);
            }
            ,
            s if s.matches("LatestRestorableTime") /* LatestRestorableTime com.amazonaws.docdb#DBCluster$LatestRestorableTime */ =>  {
                let var_166 =
                    Some(
                        smithy_types::Instant::from_str(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            , smithy_types::instant::Format::DateTime
                        )
                        .map_err(|_|smithy_xml::decode::XmlError::custom("expected (timestamp: `com.amazonaws.docdb#TStamp`)"))
                        ?
                    )
                ;
                builder = builder.set_latest_restorable_time(var_166);
            }
            ,
            s if s.matches("Port") /* Port com.amazonaws.docdb#DBCluster$Port */ =>  {
                let var_167 =
                    Some(
                         {
                            <i32 as smithy_types::primitive::Parse>::parse_smithy_primitive(
                                smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            )
                            .map_err(|_|smithy_xml::decode::XmlError::custom("expected (integer: `com.amazonaws.docdb#IntegerOptional`)"))
                        }
                        ?
                    )
                ;
                builder = builder.set_port(var_167);
            }
            ,
            s if s.matches("MasterUsername") /* MasterUsername com.amazonaws.docdb#DBCluster$MasterUsername */ =>  {
                let var_168 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_master_username(var_168);
            }
            ,
            s if s.matches("PreferredBackupWindow") /* PreferredBackupWindow com.amazonaws.docdb#DBCluster$PreferredBackupWindow */ =>  {
                let var_169 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_preferred_backup_window(var_169);
            }
            ,
            s if s.matches("PreferredMaintenanceWindow") /* PreferredMaintenanceWindow com.amazonaws.docdb#DBCluster$PreferredMaintenanceWindow */ =>  {
                let var_170 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_preferred_maintenance_window(var_170);
            }
            ,
            s if s.matches("ReplicationSourceIdentifier") /* ReplicationSourceIdentifier com.amazonaws.docdb#DBCluster$ReplicationSourceIdentifier */ =>  {
                let var_171 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_replication_source_identifier(var_171);
            }
            ,
            s if s.matches("ReadReplicaIdentifiers") /* ReadReplicaIdentifiers com.amazonaws.docdb#DBCluster$ReadReplicaIdentifiers */ =>  {
                let var_172 =
                    Some(
                        crate::xml_deser::deser_list_read_replica_identifier_list(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_read_replica_identifiers(var_172);
            }
            ,
            s if s.matches("DBClusterMembers") /* DBClusterMembers com.amazonaws.docdb#DBCluster$DBClusterMembers */ =>  {
                let var_173 =
                    Some(
                        crate::xml_deser::deser_list_db_cluster_member_list(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_db_cluster_members(var_173);
            }
            ,
            s if s.matches("VpcSecurityGroups") /* VpcSecurityGroups com.amazonaws.docdb#DBCluster$VpcSecurityGroups */ =>  {
                let var_174 =
                    Some(
                        crate::xml_deser::deser_list_vpc_security_group_membership_list(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_vpc_security_groups(var_174);
            }
            ,
            s if s.matches("HostedZoneId") /* HostedZoneId com.amazonaws.docdb#DBCluster$HostedZoneId */ =>  {
                let var_175 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_hosted_zone_id(var_175);
            }
            ,
            s if s.matches("StorageEncrypted") /* StorageEncrypted com.amazonaws.docdb#DBCluster$StorageEncrypted */ =>  {
                let var_176 =
                    Some(
                         {
                            <bool as smithy_types::primitive::Parse>::parse_smithy_primitive(
                                smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            )
                            .map_err(|_|smithy_xml::decode::XmlError::custom("expected (boolean: `com.amazonaws.docdb#Boolean`)"))
                        }
                        ?
                    )
                ;
                builder = builder.set_storage_encrypted(var_176);
            }
            ,
            s if s.matches("KmsKeyId") /* KmsKeyId com.amazonaws.docdb#DBCluster$KmsKeyId */ =>  {
                let var_177 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_kms_key_id(var_177);
            }
            ,
            s if s.matches("DbClusterResourceId") /* DbClusterResourceId com.amazonaws.docdb#DBCluster$DbClusterResourceId */ =>  {
                let var_178 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_db_cluster_resource_id(var_178);
            }
            ,
            s if s.matches("DBClusterArn") /* DBClusterArn com.amazonaws.docdb#DBCluster$DBClusterArn */ =>  {
                let var_179 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_db_cluster_arn(var_179);
            }
            ,
            s if s.matches("AssociatedRoles") /* AssociatedRoles com.amazonaws.docdb#DBCluster$AssociatedRoles */ =>  {
                let var_180 =
                    Some(
                        crate::xml_deser::deser_list_db_cluster_roles(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_associated_roles(var_180);
            }
            ,
            s if s.matches("ClusterCreateTime") /* ClusterCreateTime com.amazonaws.docdb#DBCluster$ClusterCreateTime */ =>  {
                let var_181 =
                    Some(
                        smithy_types::Instant::from_str(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            , smithy_types::instant::Format::DateTime
                        )
                        .map_err(|_|smithy_xml::decode::XmlError::custom("expected (timestamp: `com.amazonaws.docdb#TStamp`)"))
                        ?
                    )
                ;
                builder = builder.set_cluster_create_time(var_181);
            }
            ,
            s if s.matches("EnabledCloudwatchLogsExports") /* EnabledCloudwatchLogsExports com.amazonaws.docdb#DBCluster$EnabledCloudwatchLogsExports */ =>  {
                let var_182 =
                    Some(
                        crate::xml_deser::deser_list_log_type_list(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_enabled_cloudwatch_logs_exports(var_182);
            }
            ,
            s if s.matches("DeletionProtection") /* DeletionProtection com.amazonaws.docdb#DBCluster$DeletionProtection */ =>  {
                let var_183 =
                    Some(
                         {
                            <bool as smithy_types::primitive::Parse>::parse_smithy_primitive(
                                smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            )
                            .map_err(|_|smithy_xml::decode::XmlError::custom("expected (boolean: `com.amazonaws.docdb#Boolean`)"))
                        }
                        ?
                    )
                ;
                builder = builder.set_deletion_protection(var_183);
            }
            ,
            _ => {}
        }
    }
    Ok(builder.build())
}

pub fn deser_structure_db_instance(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<crate::model::DbInstance, smithy_xml::decode::XmlError> {
    #[allow(unused_mut)]
    let mut builder = crate::model::DbInstance::builder();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("DBInstanceIdentifier") /* DBInstanceIdentifier com.amazonaws.docdb#DBInstance$DBInstanceIdentifier */ =>  {
                let var_184 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_db_instance_identifier(var_184);
            }
            ,
            s if s.matches("DBInstanceClass") /* DBInstanceClass com.amazonaws.docdb#DBInstance$DBInstanceClass */ =>  {
                let var_185 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_db_instance_class(var_185);
            }
            ,
            s if s.matches("Engine") /* Engine com.amazonaws.docdb#DBInstance$Engine */ =>  {
                let var_186 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_engine(var_186);
            }
            ,
            s if s.matches("DBInstanceStatus") /* DBInstanceStatus com.amazonaws.docdb#DBInstance$DBInstanceStatus */ =>  {
                let var_187 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_db_instance_status(var_187);
            }
            ,
            s if s.matches("Endpoint") /* Endpoint com.amazonaws.docdb#DBInstance$Endpoint */ =>  {
                let var_188 =
                    Some(
                        crate::xml_deser::deser_structure_endpoint(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_endpoint(var_188);
            }
            ,
            s if s.matches("InstanceCreateTime") /* InstanceCreateTime com.amazonaws.docdb#DBInstance$InstanceCreateTime */ =>  {
                let var_189 =
                    Some(
                        smithy_types::Instant::from_str(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            , smithy_types::instant::Format::DateTime
                        )
                        .map_err(|_|smithy_xml::decode::XmlError::custom("expected (timestamp: `com.amazonaws.docdb#TStamp`)"))
                        ?
                    )
                ;
                builder = builder.set_instance_create_time(var_189);
            }
            ,
            s if s.matches("PreferredBackupWindow") /* PreferredBackupWindow com.amazonaws.docdb#DBInstance$PreferredBackupWindow */ =>  {
                let var_190 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_preferred_backup_window(var_190);
            }
            ,
            s if s.matches("BackupRetentionPeriod") /* BackupRetentionPeriod com.amazonaws.docdb#DBInstance$BackupRetentionPeriod */ =>  {
                let var_191 =
                    Some(
                         {
                            <i32 as smithy_types::primitive::Parse>::parse_smithy_primitive(
                                smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            )
                            .map_err(|_|smithy_xml::decode::XmlError::custom("expected (integer: `com.amazonaws.docdb#Integer`)"))
                        }
                        ?
                    )
                ;
                builder = builder.set_backup_retention_period(var_191);
            }
            ,
            s if s.matches("VpcSecurityGroups") /* VpcSecurityGroups com.amazonaws.docdb#DBInstance$VpcSecurityGroups */ =>  {
                let var_192 =
                    Some(
                        crate::xml_deser::deser_list_vpc_security_group_membership_list(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_vpc_security_groups(var_192);
            }
            ,
            s if s.matches("AvailabilityZone") /* AvailabilityZone com.amazonaws.docdb#DBInstance$AvailabilityZone */ =>  {
                let var_193 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_availability_zone(var_193);
            }
            ,
            s if s.matches("DBSubnetGroup") /* DBSubnetGroup com.amazonaws.docdb#DBInstance$DBSubnetGroup */ =>  {
                let var_194 =
                    Some(
                        crate::xml_deser::deser_structure_db_subnet_group(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_db_subnet_group(var_194);
            }
            ,
            s if s.matches("PreferredMaintenanceWindow") /* PreferredMaintenanceWindow com.amazonaws.docdb#DBInstance$PreferredMaintenanceWindow */ =>  {
                let var_195 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_preferred_maintenance_window(var_195);
            }
            ,
            s if s.matches("PendingModifiedValues") /* PendingModifiedValues com.amazonaws.docdb#DBInstance$PendingModifiedValues */ =>  {
                let var_196 =
                    Some(
                        crate::xml_deser::deser_structure_pending_modified_values(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_pending_modified_values(var_196);
            }
            ,
            s if s.matches("LatestRestorableTime") /* LatestRestorableTime com.amazonaws.docdb#DBInstance$LatestRestorableTime */ =>  {
                let var_197 =
                    Some(
                        smithy_types::Instant::from_str(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            , smithy_types::instant::Format::DateTime
                        )
                        .map_err(|_|smithy_xml::decode::XmlError::custom("expected (timestamp: `com.amazonaws.docdb#TStamp`)"))
                        ?
                    )
                ;
                builder = builder.set_latest_restorable_time(var_197);
            }
            ,
            s if s.matches("EngineVersion") /* EngineVersion com.amazonaws.docdb#DBInstance$EngineVersion */ =>  {
                let var_198 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_engine_version(var_198);
            }
            ,
            s if s.matches("AutoMinorVersionUpgrade") /* AutoMinorVersionUpgrade com.amazonaws.docdb#DBInstance$AutoMinorVersionUpgrade */ =>  {
                let var_199 =
                    Some(
                         {
                            <bool as smithy_types::primitive::Parse>::parse_smithy_primitive(
                                smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            )
                            .map_err(|_|smithy_xml::decode::XmlError::custom("expected (boolean: `com.amazonaws.docdb#Boolean`)"))
                        }
                        ?
                    )
                ;
                builder = builder.set_auto_minor_version_upgrade(var_199);
            }
            ,
            s if s.matches("PubliclyAccessible") /* PubliclyAccessible com.amazonaws.docdb#DBInstance$PubliclyAccessible */ =>  {
                let var_200 =
                    Some(
                         {
                            <bool as smithy_types::primitive::Parse>::parse_smithy_primitive(
                                smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            )
                            .map_err(|_|smithy_xml::decode::XmlError::custom("expected (boolean: `com.amazonaws.docdb#Boolean`)"))
                        }
                        ?
                    )
                ;
                builder = builder.set_publicly_accessible(var_200);
            }
            ,
            s if s.matches("StatusInfos") /* StatusInfos com.amazonaws.docdb#DBInstance$StatusInfos */ =>  {
                let var_201 =
                    Some(
                        crate::xml_deser::deser_list_db_instance_status_info_list(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_status_infos(var_201);
            }
            ,
            s if s.matches("DBClusterIdentifier") /* DBClusterIdentifier com.amazonaws.docdb#DBInstance$DBClusterIdentifier */ =>  {
                let var_202 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_db_cluster_identifier(var_202);
            }
            ,
            s if s.matches("StorageEncrypted") /* StorageEncrypted com.amazonaws.docdb#DBInstance$StorageEncrypted */ =>  {
                let var_203 =
                    Some(
                         {
                            <bool as smithy_types::primitive::Parse>::parse_smithy_primitive(
                                smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            )
                            .map_err(|_|smithy_xml::decode::XmlError::custom("expected (boolean: `com.amazonaws.docdb#Boolean`)"))
                        }
                        ?
                    )
                ;
                builder = builder.set_storage_encrypted(var_203);
            }
            ,
            s if s.matches("KmsKeyId") /* KmsKeyId com.amazonaws.docdb#DBInstance$KmsKeyId */ =>  {
                let var_204 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_kms_key_id(var_204);
            }
            ,
            s if s.matches("DbiResourceId") /* DbiResourceId com.amazonaws.docdb#DBInstance$DbiResourceId */ =>  {
                let var_205 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_dbi_resource_id(var_205);
            }
            ,
            s if s.matches("CACertificateIdentifier") /* CACertificateIdentifier com.amazonaws.docdb#DBInstance$CACertificateIdentifier */ =>  {
                let var_206 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_ca_certificate_identifier(var_206);
            }
            ,
            s if s.matches("PromotionTier") /* PromotionTier com.amazonaws.docdb#DBInstance$PromotionTier */ =>  {
                let var_207 =
                    Some(
                         {
                            <i32 as smithy_types::primitive::Parse>::parse_smithy_primitive(
                                smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            )
                            .map_err(|_|smithy_xml::decode::XmlError::custom("expected (integer: `com.amazonaws.docdb#IntegerOptional`)"))
                        }
                        ?
                    )
                ;
                builder = builder.set_promotion_tier(var_207);
            }
            ,
            s if s.matches("DBInstanceArn") /* DBInstanceArn com.amazonaws.docdb#DBInstance$DBInstanceArn */ =>  {
                let var_208 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_db_instance_arn(var_208);
            }
            ,
            s if s.matches("EnabledCloudwatchLogsExports") /* EnabledCloudwatchLogsExports com.amazonaws.docdb#DBInstance$EnabledCloudwatchLogsExports */ =>  {
                let var_209 =
                    Some(
                        crate::xml_deser::deser_list_log_type_list(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_enabled_cloudwatch_logs_exports(var_209);
            }
            ,
            _ => {}
        }
    }
    Ok(builder.build())
}

pub fn deser_structure_db_subnet_group(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<crate::model::DbSubnetGroup, smithy_xml::decode::XmlError> {
    #[allow(unused_mut)]
    let mut builder = crate::model::DbSubnetGroup::builder();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("DBSubnetGroupName") /* DBSubnetGroupName com.amazonaws.docdb#DBSubnetGroup$DBSubnetGroupName */ =>  {
                let var_210 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_db_subnet_group_name(var_210);
            }
            ,
            s if s.matches("DBSubnetGroupDescription") /* DBSubnetGroupDescription com.amazonaws.docdb#DBSubnetGroup$DBSubnetGroupDescription */ =>  {
                let var_211 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_db_subnet_group_description(var_211);
            }
            ,
            s if s.matches("VpcId") /* VpcId com.amazonaws.docdb#DBSubnetGroup$VpcId */ =>  {
                let var_212 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_vpc_id(var_212);
            }
            ,
            s if s.matches("SubnetGroupStatus") /* SubnetGroupStatus com.amazonaws.docdb#DBSubnetGroup$SubnetGroupStatus */ =>  {
                let var_213 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_subnet_group_status(var_213);
            }
            ,
            s if s.matches("Subnets") /* Subnets com.amazonaws.docdb#DBSubnetGroup$Subnets */ =>  {
                let var_214 =
                    Some(
                        crate::xml_deser::deser_list_subnet_list(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_subnets(var_214);
            }
            ,
            s if s.matches("DBSubnetGroupArn") /* DBSubnetGroupArn com.amazonaws.docdb#DBSubnetGroup$DBSubnetGroupArn */ =>  {
                let var_215 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_db_subnet_group_arn(var_215);
            }
            ,
            _ => {}
        }
    }
    Ok(builder.build())
}

pub fn deser_structure_global_cluster(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<crate::model::GlobalCluster, smithy_xml::decode::XmlError> {
    #[allow(unused_mut)]
    let mut builder = crate::model::GlobalCluster::builder();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("GlobalClusterIdentifier") /* GlobalClusterIdentifier com.amazonaws.docdb#GlobalCluster$GlobalClusterIdentifier */ =>  {
                let var_216 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_global_cluster_identifier(var_216);
            }
            ,
            s if s.matches("GlobalClusterResourceId") /* GlobalClusterResourceId com.amazonaws.docdb#GlobalCluster$GlobalClusterResourceId */ =>  {
                let var_217 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_global_cluster_resource_id(var_217);
            }
            ,
            s if s.matches("GlobalClusterArn") /* GlobalClusterArn com.amazonaws.docdb#GlobalCluster$GlobalClusterArn */ =>  {
                let var_218 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_global_cluster_arn(var_218);
            }
            ,
            s if s.matches("Status") /* Status com.amazonaws.docdb#GlobalCluster$Status */ =>  {
                let var_219 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_status(var_219);
            }
            ,
            s if s.matches("Engine") /* Engine com.amazonaws.docdb#GlobalCluster$Engine */ =>  {
                let var_220 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_engine(var_220);
            }
            ,
            s if s.matches("EngineVersion") /* EngineVersion com.amazonaws.docdb#GlobalCluster$EngineVersion */ =>  {
                let var_221 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_engine_version(var_221);
            }
            ,
            s if s.matches("DatabaseName") /* DatabaseName com.amazonaws.docdb#GlobalCluster$DatabaseName */ =>  {
                let var_222 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_database_name(var_222);
            }
            ,
            s if s.matches("StorageEncrypted") /* StorageEncrypted com.amazonaws.docdb#GlobalCluster$StorageEncrypted */ =>  {
                let var_223 =
                    Some(
                         {
                            <bool as smithy_types::primitive::Parse>::parse_smithy_primitive(
                                smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            )
                            .map_err(|_|smithy_xml::decode::XmlError::custom("expected (boolean: `com.amazonaws.docdb#BooleanOptional`)"))
                        }
                        ?
                    )
                ;
                builder = builder.set_storage_encrypted(var_223);
            }
            ,
            s if s.matches("DeletionProtection") /* DeletionProtection com.amazonaws.docdb#GlobalCluster$DeletionProtection */ =>  {
                let var_224 =
                    Some(
                         {
                            <bool as smithy_types::primitive::Parse>::parse_smithy_primitive(
                                smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            )
                            .map_err(|_|smithy_xml::decode::XmlError::custom("expected (boolean: `com.amazonaws.docdb#BooleanOptional`)"))
                        }
                        ?
                    )
                ;
                builder = builder.set_deletion_protection(var_224);
            }
            ,
            s if s.matches("GlobalClusterMembers") /* GlobalClusterMembers com.amazonaws.docdb#GlobalCluster$GlobalClusterMembers */ =>  {
                let var_225 =
                    Some(
                        crate::xml_deser::deser_list_global_cluster_member_list(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_global_cluster_members(var_225);
            }
            ,
            _ => {}
        }
    }
    Ok(builder.build())
}

pub fn deser_list_certificate_list(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<std::vec::Vec<crate::model::Certificate>, smithy_xml::decode::XmlError> {
    let mut out = std::vec::Vec::new();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("Certificate") /* member com.amazonaws.docdb#CertificateList$member */ =>  {
                out.push(
                    crate::xml_deser::deser_structure_certificate(&mut tag)
                    ?
                );
            }
            ,
            _ => {}
        }
    }
    Ok(out)
}

pub fn deser_list_db_cluster_parameter_group_list(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<std::vec::Vec<crate::model::DbClusterParameterGroup>, smithy_xml::decode::XmlError> {
    let mut out = std::vec::Vec::new();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("DBClusterParameterGroup") /* member com.amazonaws.docdb#DBClusterParameterGroupList$member */ =>  {
                out.push(
                    crate::xml_deser::deser_structure_db_cluster_parameter_group(&mut tag)
                    ?
                );
            }
            ,
            _ => {}
        }
    }
    Ok(out)
}

pub fn deser_list_parameters_list(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<std::vec::Vec<crate::model::Parameter>, smithy_xml::decode::XmlError> {
    let mut out = std::vec::Vec::new();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("Parameter") /* member com.amazonaws.docdb#ParametersList$member */ =>  {
                out.push(
                    crate::xml_deser::deser_structure_parameter(&mut tag)
                    ?
                );
            }
            ,
            _ => {}
        }
    }
    Ok(out)
}

pub fn deser_list_db_cluster_list(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<std::vec::Vec<crate::model::DbCluster>, smithy_xml::decode::XmlError> {
    let mut out = std::vec::Vec::new();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("DBCluster") /* member com.amazonaws.docdb#DBClusterList$member */ =>  {
                out.push(
                    crate::xml_deser::deser_structure_db_cluster(&mut tag)
                    ?
                );
            }
            ,
            _ => {}
        }
    }
    Ok(out)
}

pub fn deser_structure_db_cluster_snapshot_attributes_result(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<crate::model::DbClusterSnapshotAttributesResult, smithy_xml::decode::XmlError> {
    #[allow(unused_mut)]
    let mut builder = crate::model::DbClusterSnapshotAttributesResult::builder();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("DBClusterSnapshotIdentifier") /* DBClusterSnapshotIdentifier com.amazonaws.docdb#DBClusterSnapshotAttributesResult$DBClusterSnapshotIdentifier */ =>  {
                let var_226 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_db_cluster_snapshot_identifier(var_226);
            }
            ,
            s if s.matches("DBClusterSnapshotAttributes") /* DBClusterSnapshotAttributes com.amazonaws.docdb#DBClusterSnapshotAttributesResult$DBClusterSnapshotAttributes */ =>  {
                let var_227 =
                    Some(
                        crate::xml_deser::deser_list_db_cluster_snapshot_attribute_list(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_db_cluster_snapshot_attributes(var_227);
            }
            ,
            _ => {}
        }
    }
    Ok(builder.build())
}

pub fn deser_list_db_cluster_snapshot_list(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<std::vec::Vec<crate::model::DbClusterSnapshot>, smithy_xml::decode::XmlError> {
    let mut out = std::vec::Vec::new();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("DBClusterSnapshot") /* member com.amazonaws.docdb#DBClusterSnapshotList$member */ =>  {
                out.push(
                    crate::xml_deser::deser_structure_db_cluster_snapshot(&mut tag)
                    ?
                );
            }
            ,
            _ => {}
        }
    }
    Ok(out)
}

pub fn deser_list_db_engine_version_list(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<std::vec::Vec<crate::model::DbEngineVersion>, smithy_xml::decode::XmlError> {
    let mut out = std::vec::Vec::new();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("DBEngineVersion") /* member com.amazonaws.docdb#DBEngineVersionList$member */ =>  {
                out.push(
                    crate::xml_deser::deser_structure_db_engine_version(&mut tag)
                    ?
                );
            }
            ,
            _ => {}
        }
    }
    Ok(out)
}

pub fn deser_list_db_instance_list(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<std::vec::Vec<crate::model::DbInstance>, smithy_xml::decode::XmlError> {
    let mut out = std::vec::Vec::new();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("DBInstance") /* member com.amazonaws.docdb#DBInstanceList$member */ =>  {
                out.push(
                    crate::xml_deser::deser_structure_db_instance(&mut tag)
                    ?
                );
            }
            ,
            _ => {}
        }
    }
    Ok(out)
}

pub fn deser_list_db_subnet_groups(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<std::vec::Vec<crate::model::DbSubnetGroup>, smithy_xml::decode::XmlError> {
    let mut out = std::vec::Vec::new();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("DBSubnetGroup") /* member com.amazonaws.docdb#DBSubnetGroups$member */ =>  {
                out.push(
                    crate::xml_deser::deser_structure_db_subnet_group(&mut tag)
                    ?
                );
            }
            ,
            _ => {}
        }
    }
    Ok(out)
}

pub fn deser_structure_engine_defaults(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<crate::model::EngineDefaults, smithy_xml::decode::XmlError> {
    #[allow(unused_mut)]
    let mut builder = crate::model::EngineDefaults::builder();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("DBParameterGroupFamily") /* DBParameterGroupFamily com.amazonaws.docdb#EngineDefaults$DBParameterGroupFamily */ =>  {
                let var_228 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_db_parameter_group_family(var_228);
            }
            ,
            s if s.matches("Marker") /* Marker com.amazonaws.docdb#EngineDefaults$Marker */ =>  {
                let var_229 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_marker(var_229);
            }
            ,
            s if s.matches("Parameters") /* Parameters com.amazonaws.docdb#EngineDefaults$Parameters */ =>  {
                let var_230 =
                    Some(
                        crate::xml_deser::deser_list_parameters_list(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_parameters(var_230);
            }
            ,
            _ => {}
        }
    }
    Ok(builder.build())
}

pub fn deser_list_event_categories_map_list(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<std::vec::Vec<crate::model::EventCategoriesMap>, smithy_xml::decode::XmlError> {
    let mut out = std::vec::Vec::new();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("EventCategoriesMap") /* member com.amazonaws.docdb#EventCategoriesMapList$member */ =>  {
                out.push(
                    crate::xml_deser::deser_structure_event_categories_map(&mut tag)
                    ?
                );
            }
            ,
            _ => {}
        }
    }
    Ok(out)
}

pub fn deser_list_event_list(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<std::vec::Vec<crate::model::Event>, smithy_xml::decode::XmlError> {
    let mut out = std::vec::Vec::new();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("Event") /* member com.amazonaws.docdb#EventList$member */ =>  {
                out.push(
                    crate::xml_deser::deser_structure_event(&mut tag)
                    ?
                );
            }
            ,
            _ => {}
        }
    }
    Ok(out)
}

pub fn deser_list_event_subscriptions_list(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<std::vec::Vec<crate::model::EventSubscription>, smithy_xml::decode::XmlError> {
    let mut out = std::vec::Vec::new();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("EventSubscription") /* member com.amazonaws.docdb#EventSubscriptionsList$member */ =>  {
                out.push(
                    crate::xml_deser::deser_structure_event_subscription(&mut tag)
                    ?
                );
            }
            ,
            _ => {}
        }
    }
    Ok(out)
}

pub fn deser_list_global_cluster_list(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<std::vec::Vec<crate::model::GlobalCluster>, smithy_xml::decode::XmlError> {
    let mut out = std::vec::Vec::new();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("GlobalClusterMember") /* member com.amazonaws.docdb#GlobalClusterList$member */ =>  {
                out.push(
                    crate::xml_deser::deser_structure_global_cluster(&mut tag)
                    ?
                );
            }
            ,
            _ => {}
        }
    }
    Ok(out)
}

pub fn deser_list_orderable_db_instance_options_list(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<std::vec::Vec<crate::model::OrderableDbInstanceOption>, smithy_xml::decode::XmlError> {
    let mut out = std::vec::Vec::new();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("OrderableDBInstanceOption") /* member com.amazonaws.docdb#OrderableDBInstanceOptionsList$member */ =>  {
                out.push(
                    crate::xml_deser::deser_structure_orderable_db_instance_option(&mut tag)
                    ?
                );
            }
            ,
            _ => {}
        }
    }
    Ok(out)
}

pub fn deser_list_pending_maintenance_actions(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<
    std::vec::Vec<crate::model::ResourcePendingMaintenanceActions>,
    smithy_xml::decode::XmlError,
> {
    let mut out = std::vec::Vec::new();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("ResourcePendingMaintenanceActions") /* member com.amazonaws.docdb#PendingMaintenanceActions$member */ =>  {
                out.push(
                    crate::xml_deser::deser_structure_resource_pending_maintenance_actions(&mut tag)
                    ?
                );
            }
            ,
            _ => {}
        }
    }
    Ok(out)
}

pub fn deser_list_tag_list(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<std::vec::Vec<crate::model::Tag>, smithy_xml::decode::XmlError> {
    let mut out = std::vec::Vec::new();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("Tag") /* member com.amazonaws.docdb#TagList$member */ =>  {
                out.push(
                    crate::xml_deser::deser_structure_tag(&mut tag)
                    ?
                );
            }
            ,
            _ => {}
        }
    }
    Ok(out)
}

pub fn deser_list_source_ids_list(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<std::vec::Vec<std::string::String>, smithy_xml::decode::XmlError> {
    let mut out = std::vec::Vec::new();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("SourceId") /* member com.amazonaws.docdb#SourceIdsList$member */ =>  {
                out.push(
                    Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                        smithy_xml::decode::try_data(&mut tag)?.as_ref()
                        .into()
                    )
                    ?
                );
            }
            ,
            _ => {}
        }
    }
    Ok(out)
}

pub fn deser_list_event_categories_list(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<std::vec::Vec<std::string::String>, smithy_xml::decode::XmlError> {
    let mut out = std::vec::Vec::new();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("EventCategory") /* member com.amazonaws.docdb#EventCategoriesList$member */ =>  {
                out.push(
                    Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                        smithy_xml::decode::try_data(&mut tag)?.as_ref()
                        .into()
                    )
                    ?
                );
            }
            ,
            _ => {}
        }
    }
    Ok(out)
}

pub fn deser_list_pending_maintenance_action_details(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<std::vec::Vec<crate::model::PendingMaintenanceAction>, smithy_xml::decode::XmlError> {
    let mut out = std::vec::Vec::new();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("PendingMaintenanceAction") /* member com.amazonaws.docdb#PendingMaintenanceActionDetails$member */ =>  {
                out.push(
                    crate::xml_deser::deser_structure_pending_maintenance_action(&mut tag)
                    ?
                );
            }
            ,
            _ => {}
        }
    }
    Ok(out)
}

pub fn deser_list_availability_zones(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<std::vec::Vec<std::string::String>, smithy_xml::decode::XmlError> {
    let mut out = std::vec::Vec::new();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("AvailabilityZone") /* member com.amazonaws.docdb#AvailabilityZones$member */ =>  {
                out.push(
                    Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                        smithy_xml::decode::try_data(&mut tag)?.as_ref()
                        .into()
                    )
                    ?
                );
            }
            ,
            _ => {}
        }
    }
    Ok(out)
}

pub fn deser_list_read_replica_identifier_list(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<std::vec::Vec<std::string::String>, smithy_xml::decode::XmlError> {
    let mut out = std::vec::Vec::new();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("ReadReplicaIdentifier") /* member com.amazonaws.docdb#ReadReplicaIdentifierList$member */ =>  {
                out.push(
                    Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                        smithy_xml::decode::try_data(&mut tag)?.as_ref()
                        .into()
                    )
                    ?
                );
            }
            ,
            _ => {}
        }
    }
    Ok(out)
}

pub fn deser_list_db_cluster_member_list(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<std::vec::Vec<crate::model::DbClusterMember>, smithy_xml::decode::XmlError> {
    let mut out = std::vec::Vec::new();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("DBClusterMember") /* member com.amazonaws.docdb#DBClusterMemberList$member */ =>  {
                out.push(
                    crate::xml_deser::deser_structure_db_cluster_member(&mut tag)
                    ?
                );
            }
            ,
            _ => {}
        }
    }
    Ok(out)
}

pub fn deser_list_vpc_security_group_membership_list(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<std::vec::Vec<crate::model::VpcSecurityGroupMembership>, smithy_xml::decode::XmlError> {
    let mut out = std::vec::Vec::new();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("VpcSecurityGroupMembership") /* member com.amazonaws.docdb#VpcSecurityGroupMembershipList$member */ =>  {
                out.push(
                    crate::xml_deser::deser_structure_vpc_security_group_membership(&mut tag)
                    ?
                );
            }
            ,
            _ => {}
        }
    }
    Ok(out)
}

pub fn deser_list_db_cluster_roles(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<std::vec::Vec<crate::model::DbClusterRole>, smithy_xml::decode::XmlError> {
    let mut out = std::vec::Vec::new();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("DBClusterRole") /* member com.amazonaws.docdb#DBClusterRoles$member */ =>  {
                out.push(
                    crate::xml_deser::deser_structure_db_cluster_role(&mut tag)
                    ?
                );
            }
            ,
            _ => {}
        }
    }
    Ok(out)
}

pub fn deser_list_log_type_list(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<std::vec::Vec<std::string::String>, smithy_xml::decode::XmlError> {
    let mut out = std::vec::Vec::new();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("member") /* member com.amazonaws.docdb#LogTypeList$member */ =>  {
                out.push(
                    Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                        smithy_xml::decode::try_data(&mut tag)?.as_ref()
                        .into()
                    )
                    ?
                );
            }
            ,
            _ => {}
        }
    }
    Ok(out)
}

pub fn deser_structure_endpoint(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<crate::model::Endpoint, smithy_xml::decode::XmlError> {
    #[allow(unused_mut)]
    let mut builder = crate::model::Endpoint::builder();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("Address") /* Address com.amazonaws.docdb#Endpoint$Address */ =>  {
                let var_231 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_address(var_231);
            }
            ,
            s if s.matches("Port") /* Port com.amazonaws.docdb#Endpoint$Port */ =>  {
                let var_232 =
                    Some(
                         {
                            <i32 as smithy_types::primitive::Parse>::parse_smithy_primitive(
                                smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            )
                            .map_err(|_|smithy_xml::decode::XmlError::custom("expected (integer: `com.amazonaws.docdb#Integer`)"))
                        }
                        ?
                    )
                ;
                builder = builder.set_port(var_232);
            }
            ,
            s if s.matches("HostedZoneId") /* HostedZoneId com.amazonaws.docdb#Endpoint$HostedZoneId */ =>  {
                let var_233 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_hosted_zone_id(var_233);
            }
            ,
            _ => {}
        }
    }
    Ok(builder.build())
}

pub fn deser_structure_pending_modified_values(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<crate::model::PendingModifiedValues, smithy_xml::decode::XmlError> {
    #[allow(unused_mut)]
    let mut builder = crate::model::PendingModifiedValues::builder();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("DBInstanceClass") /* DBInstanceClass com.amazonaws.docdb#PendingModifiedValues$DBInstanceClass */ =>  {
                let var_234 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_db_instance_class(var_234);
            }
            ,
            s if s.matches("AllocatedStorage") /* AllocatedStorage com.amazonaws.docdb#PendingModifiedValues$AllocatedStorage */ =>  {
                let var_235 =
                    Some(
                         {
                            <i32 as smithy_types::primitive::Parse>::parse_smithy_primitive(
                                smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            )
                            .map_err(|_|smithy_xml::decode::XmlError::custom("expected (integer: `com.amazonaws.docdb#IntegerOptional`)"))
                        }
                        ?
                    )
                ;
                builder = builder.set_allocated_storage(var_235);
            }
            ,
            s if s.matches("MasterUserPassword") /* MasterUserPassword com.amazonaws.docdb#PendingModifiedValues$MasterUserPassword */ =>  {
                let var_236 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_master_user_password(var_236);
            }
            ,
            s if s.matches("Port") /* Port com.amazonaws.docdb#PendingModifiedValues$Port */ =>  {
                let var_237 =
                    Some(
                         {
                            <i32 as smithy_types::primitive::Parse>::parse_smithy_primitive(
                                smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            )
                            .map_err(|_|smithy_xml::decode::XmlError::custom("expected (integer: `com.amazonaws.docdb#IntegerOptional`)"))
                        }
                        ?
                    )
                ;
                builder = builder.set_port(var_237);
            }
            ,
            s if s.matches("BackupRetentionPeriod") /* BackupRetentionPeriod com.amazonaws.docdb#PendingModifiedValues$BackupRetentionPeriod */ =>  {
                let var_238 =
                    Some(
                         {
                            <i32 as smithy_types::primitive::Parse>::parse_smithy_primitive(
                                smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            )
                            .map_err(|_|smithy_xml::decode::XmlError::custom("expected (integer: `com.amazonaws.docdb#IntegerOptional`)"))
                        }
                        ?
                    )
                ;
                builder = builder.set_backup_retention_period(var_238);
            }
            ,
            s if s.matches("MultiAZ") /* MultiAZ com.amazonaws.docdb#PendingModifiedValues$MultiAZ */ =>  {
                let var_239 =
                    Some(
                         {
                            <bool as smithy_types::primitive::Parse>::parse_smithy_primitive(
                                smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            )
                            .map_err(|_|smithy_xml::decode::XmlError::custom("expected (boolean: `com.amazonaws.docdb#BooleanOptional`)"))
                        }
                        ?
                    )
                ;
                builder = builder.set_multi_az(var_239);
            }
            ,
            s if s.matches("EngineVersion") /* EngineVersion com.amazonaws.docdb#PendingModifiedValues$EngineVersion */ =>  {
                let var_240 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_engine_version(var_240);
            }
            ,
            s if s.matches("LicenseModel") /* LicenseModel com.amazonaws.docdb#PendingModifiedValues$LicenseModel */ =>  {
                let var_241 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_license_model(var_241);
            }
            ,
            s if s.matches("Iops") /* Iops com.amazonaws.docdb#PendingModifiedValues$Iops */ =>  {
                let var_242 =
                    Some(
                         {
                            <i32 as smithy_types::primitive::Parse>::parse_smithy_primitive(
                                smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            )
                            .map_err(|_|smithy_xml::decode::XmlError::custom("expected (integer: `com.amazonaws.docdb#IntegerOptional`)"))
                        }
                        ?
                    )
                ;
                builder = builder.set_iops(var_242);
            }
            ,
            s if s.matches("DBInstanceIdentifier") /* DBInstanceIdentifier com.amazonaws.docdb#PendingModifiedValues$DBInstanceIdentifier */ =>  {
                let var_243 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_db_instance_identifier(var_243);
            }
            ,
            s if s.matches("StorageType") /* StorageType com.amazonaws.docdb#PendingModifiedValues$StorageType */ =>  {
                let var_244 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_storage_type(var_244);
            }
            ,
            s if s.matches("CACertificateIdentifier") /* CACertificateIdentifier com.amazonaws.docdb#PendingModifiedValues$CACertificateIdentifier */ =>  {
                let var_245 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_ca_certificate_identifier(var_245);
            }
            ,
            s if s.matches("DBSubnetGroupName") /* DBSubnetGroupName com.amazonaws.docdb#PendingModifiedValues$DBSubnetGroupName */ =>  {
                let var_246 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_db_subnet_group_name(var_246);
            }
            ,
            s if s.matches("PendingCloudwatchLogsExports") /* PendingCloudwatchLogsExports com.amazonaws.docdb#PendingModifiedValues$PendingCloudwatchLogsExports */ =>  {
                let var_247 =
                    Some(
                        crate::xml_deser::deser_structure_pending_cloudwatch_logs_exports(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_pending_cloudwatch_logs_exports(var_247);
            }
            ,
            _ => {}
        }
    }
    Ok(builder.build())
}

pub fn deser_list_db_instance_status_info_list(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<std::vec::Vec<crate::model::DbInstanceStatusInfo>, smithy_xml::decode::XmlError> {
    let mut out = std::vec::Vec::new();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("DBInstanceStatusInfo") /* member com.amazonaws.docdb#DBInstanceStatusInfoList$member */ =>  {
                out.push(
                    crate::xml_deser::deser_structure_db_instance_status_info(&mut tag)
                    ?
                );
            }
            ,
            _ => {}
        }
    }
    Ok(out)
}

pub fn deser_list_subnet_list(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<std::vec::Vec<crate::model::Subnet>, smithy_xml::decode::XmlError> {
    let mut out = std::vec::Vec::new();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("Subnet") /* member com.amazonaws.docdb#SubnetList$member */ =>  {
                out.push(
                    crate::xml_deser::deser_structure_subnet(&mut tag)
                    ?
                );
            }
            ,
            _ => {}
        }
    }
    Ok(out)
}

pub fn deser_list_global_cluster_member_list(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<std::vec::Vec<crate::model::GlobalClusterMember>, smithy_xml::decode::XmlError> {
    let mut out = std::vec::Vec::new();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("GlobalClusterMember") /* member com.amazonaws.docdb#GlobalClusterMemberList$member */ =>  {
                out.push(
                    crate::xml_deser::deser_structure_global_cluster_member(&mut tag)
                    ?
                );
            }
            ,
            _ => {}
        }
    }
    Ok(out)
}

pub fn deser_structure_certificate(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<crate::model::Certificate, smithy_xml::decode::XmlError> {
    #[allow(unused_mut)]
    let mut builder = crate::model::Certificate::builder();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("CertificateIdentifier") /* CertificateIdentifier com.amazonaws.docdb#Certificate$CertificateIdentifier */ =>  {
                let var_248 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_certificate_identifier(var_248);
            }
            ,
            s if s.matches("CertificateType") /* CertificateType com.amazonaws.docdb#Certificate$CertificateType */ =>  {
                let var_249 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_certificate_type(var_249);
            }
            ,
            s if s.matches("Thumbprint") /* Thumbprint com.amazonaws.docdb#Certificate$Thumbprint */ =>  {
                let var_250 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_thumbprint(var_250);
            }
            ,
            s if s.matches("ValidFrom") /* ValidFrom com.amazonaws.docdb#Certificate$ValidFrom */ =>  {
                let var_251 =
                    Some(
                        smithy_types::Instant::from_str(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            , smithy_types::instant::Format::DateTime
                        )
                        .map_err(|_|smithy_xml::decode::XmlError::custom("expected (timestamp: `com.amazonaws.docdb#TStamp`)"))
                        ?
                    )
                ;
                builder = builder.set_valid_from(var_251);
            }
            ,
            s if s.matches("ValidTill") /* ValidTill com.amazonaws.docdb#Certificate$ValidTill */ =>  {
                let var_252 =
                    Some(
                        smithy_types::Instant::from_str(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            , smithy_types::instant::Format::DateTime
                        )
                        .map_err(|_|smithy_xml::decode::XmlError::custom("expected (timestamp: `com.amazonaws.docdb#TStamp`)"))
                        ?
                    )
                ;
                builder = builder.set_valid_till(var_252);
            }
            ,
            s if s.matches("CertificateArn") /* CertificateArn com.amazonaws.docdb#Certificate$CertificateArn */ =>  {
                let var_253 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_certificate_arn(var_253);
            }
            ,
            _ => {}
        }
    }
    Ok(builder.build())
}

pub fn deser_structure_parameter(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<crate::model::Parameter, smithy_xml::decode::XmlError> {
    #[allow(unused_mut)]
    let mut builder = crate::model::Parameter::builder();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("ParameterName") /* ParameterName com.amazonaws.docdb#Parameter$ParameterName */ =>  {
                let var_254 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_parameter_name(var_254);
            }
            ,
            s if s.matches("ParameterValue") /* ParameterValue com.amazonaws.docdb#Parameter$ParameterValue */ =>  {
                let var_255 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_parameter_value(var_255);
            }
            ,
            s if s.matches("Description") /* Description com.amazonaws.docdb#Parameter$Description */ =>  {
                let var_256 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_description(var_256);
            }
            ,
            s if s.matches("Source") /* Source com.amazonaws.docdb#Parameter$Source */ =>  {
                let var_257 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_source(var_257);
            }
            ,
            s if s.matches("ApplyType") /* ApplyType com.amazonaws.docdb#Parameter$ApplyType */ =>  {
                let var_258 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_apply_type(var_258);
            }
            ,
            s if s.matches("DataType") /* DataType com.amazonaws.docdb#Parameter$DataType */ =>  {
                let var_259 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_data_type(var_259);
            }
            ,
            s if s.matches("AllowedValues") /* AllowedValues com.amazonaws.docdb#Parameter$AllowedValues */ =>  {
                let var_260 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_allowed_values(var_260);
            }
            ,
            s if s.matches("IsModifiable") /* IsModifiable com.amazonaws.docdb#Parameter$IsModifiable */ =>  {
                let var_261 =
                    Some(
                         {
                            <bool as smithy_types::primitive::Parse>::parse_smithy_primitive(
                                smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            )
                            .map_err(|_|smithy_xml::decode::XmlError::custom("expected (boolean: `com.amazonaws.docdb#Boolean`)"))
                        }
                        ?
                    )
                ;
                builder = builder.set_is_modifiable(var_261);
            }
            ,
            s if s.matches("MinimumEngineVersion") /* MinimumEngineVersion com.amazonaws.docdb#Parameter$MinimumEngineVersion */ =>  {
                let var_262 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_minimum_engine_version(var_262);
            }
            ,
            s if s.matches("ApplyMethod") /* ApplyMethod com.amazonaws.docdb#Parameter$ApplyMethod */ =>  {
                let var_263 =
                    Some(
                        Result::<crate::model::ApplyMethod, smithy_xml::decode::XmlError>::Ok(
                            crate::model::ApplyMethod::from(
                                smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            )
                        )
                        ?
                    )
                ;
                builder = builder.set_apply_method(var_263);
            }
            ,
            _ => {}
        }
    }
    Ok(builder.build())
}

pub fn deser_list_db_cluster_snapshot_attribute_list(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<std::vec::Vec<crate::model::DbClusterSnapshotAttribute>, smithy_xml::decode::XmlError> {
    let mut out = std::vec::Vec::new();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("DBClusterSnapshotAttribute") /* member com.amazonaws.docdb#DBClusterSnapshotAttributeList$member */ =>  {
                out.push(
                    crate::xml_deser::deser_structure_db_cluster_snapshot_attribute(&mut tag)
                    ?
                );
            }
            ,
            _ => {}
        }
    }
    Ok(out)
}

pub fn deser_structure_db_engine_version(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<crate::model::DbEngineVersion, smithy_xml::decode::XmlError> {
    #[allow(unused_mut)]
    let mut builder = crate::model::DbEngineVersion::builder();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("Engine") /* Engine com.amazonaws.docdb#DBEngineVersion$Engine */ =>  {
                let var_264 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_engine(var_264);
            }
            ,
            s if s.matches("EngineVersion") /* EngineVersion com.amazonaws.docdb#DBEngineVersion$EngineVersion */ =>  {
                let var_265 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_engine_version(var_265);
            }
            ,
            s if s.matches("DBParameterGroupFamily") /* DBParameterGroupFamily com.amazonaws.docdb#DBEngineVersion$DBParameterGroupFamily */ =>  {
                let var_266 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_db_parameter_group_family(var_266);
            }
            ,
            s if s.matches("DBEngineDescription") /* DBEngineDescription com.amazonaws.docdb#DBEngineVersion$DBEngineDescription */ =>  {
                let var_267 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_db_engine_description(var_267);
            }
            ,
            s if s.matches("DBEngineVersionDescription") /* DBEngineVersionDescription com.amazonaws.docdb#DBEngineVersion$DBEngineVersionDescription */ =>  {
                let var_268 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_db_engine_version_description(var_268);
            }
            ,
            s if s.matches("ValidUpgradeTarget") /* ValidUpgradeTarget com.amazonaws.docdb#DBEngineVersion$ValidUpgradeTarget */ =>  {
                let var_269 =
                    Some(
                        crate::xml_deser::deser_list_valid_upgrade_target_list(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_valid_upgrade_target(var_269);
            }
            ,
            s if s.matches("ExportableLogTypes") /* ExportableLogTypes com.amazonaws.docdb#DBEngineVersion$ExportableLogTypes */ =>  {
                let var_270 =
                    Some(
                        crate::xml_deser::deser_list_log_type_list(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_exportable_log_types(var_270);
            }
            ,
            s if s.matches("SupportsLogExportsToCloudwatchLogs") /* SupportsLogExportsToCloudwatchLogs com.amazonaws.docdb#DBEngineVersion$SupportsLogExportsToCloudwatchLogs */ =>  {
                let var_271 =
                    Some(
                         {
                            <bool as smithy_types::primitive::Parse>::parse_smithy_primitive(
                                smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            )
                            .map_err(|_|smithy_xml::decode::XmlError::custom("expected (boolean: `com.amazonaws.docdb#Boolean`)"))
                        }
                        ?
                    )
                ;
                builder = builder.set_supports_log_exports_to_cloudwatch_logs(var_271);
            }
            ,
            _ => {}
        }
    }
    Ok(builder.build())
}

pub fn deser_structure_event_categories_map(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<crate::model::EventCategoriesMap, smithy_xml::decode::XmlError> {
    #[allow(unused_mut)]
    let mut builder = crate::model::EventCategoriesMap::builder();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("SourceType") /* SourceType com.amazonaws.docdb#EventCategoriesMap$SourceType */ =>  {
                let var_272 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_source_type(var_272);
            }
            ,
            s if s.matches("EventCategories") /* EventCategories com.amazonaws.docdb#EventCategoriesMap$EventCategories */ =>  {
                let var_273 =
                    Some(
                        crate::xml_deser::deser_list_event_categories_list(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_event_categories(var_273);
            }
            ,
            _ => {}
        }
    }
    Ok(builder.build())
}

pub fn deser_structure_event(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<crate::model::Event, smithy_xml::decode::XmlError> {
    #[allow(unused_mut)]
    let mut builder = crate::model::Event::builder();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("SourceIdentifier") /* SourceIdentifier com.amazonaws.docdb#Event$SourceIdentifier */ =>  {
                let var_274 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_source_identifier(var_274);
            }
            ,
            s if s.matches("SourceType") /* SourceType com.amazonaws.docdb#Event$SourceType */ =>  {
                let var_275 =
                    Some(
                        Result::<crate::model::SourceType, smithy_xml::decode::XmlError>::Ok(
                            crate::model::SourceType::from(
                                smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            )
                        )
                        ?
                    )
                ;
                builder = builder.set_source_type(var_275);
            }
            ,
            s if s.matches("Message") /* Message com.amazonaws.docdb#Event$Message */ =>  {
                let var_276 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_276);
            }
            ,
            s if s.matches("EventCategories") /* EventCategories com.amazonaws.docdb#Event$EventCategories */ =>  {
                let var_277 =
                    Some(
                        crate::xml_deser::deser_list_event_categories_list(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_event_categories(var_277);
            }
            ,
            s if s.matches("Date") /* Date com.amazonaws.docdb#Event$Date */ =>  {
                let var_278 =
                    Some(
                        smithy_types::Instant::from_str(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            , smithy_types::instant::Format::DateTime
                        )
                        .map_err(|_|smithy_xml::decode::XmlError::custom("expected (timestamp: `com.amazonaws.docdb#TStamp`)"))
                        ?
                    )
                ;
                builder = builder.set_date(var_278);
            }
            ,
            s if s.matches("SourceArn") /* SourceArn com.amazonaws.docdb#Event$SourceArn */ =>  {
                let var_279 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_source_arn(var_279);
            }
            ,
            _ => {}
        }
    }
    Ok(builder.build())
}

pub fn deser_structure_orderable_db_instance_option(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<crate::model::OrderableDbInstanceOption, smithy_xml::decode::XmlError> {
    #[allow(unused_mut)]
    let mut builder = crate::model::OrderableDbInstanceOption::builder();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("Engine") /* Engine com.amazonaws.docdb#OrderableDBInstanceOption$Engine */ =>  {
                let var_280 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_engine(var_280);
            }
            ,
            s if s.matches("EngineVersion") /* EngineVersion com.amazonaws.docdb#OrderableDBInstanceOption$EngineVersion */ =>  {
                let var_281 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_engine_version(var_281);
            }
            ,
            s if s.matches("DBInstanceClass") /* DBInstanceClass com.amazonaws.docdb#OrderableDBInstanceOption$DBInstanceClass */ =>  {
                let var_282 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_db_instance_class(var_282);
            }
            ,
            s if s.matches("LicenseModel") /* LicenseModel com.amazonaws.docdb#OrderableDBInstanceOption$LicenseModel */ =>  {
                let var_283 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_license_model(var_283);
            }
            ,
            s if s.matches("AvailabilityZones") /* AvailabilityZones com.amazonaws.docdb#OrderableDBInstanceOption$AvailabilityZones */ =>  {
                let var_284 =
                    Some(
                        crate::xml_deser::deser_list_availability_zone_list(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_availability_zones(var_284);
            }
            ,
            s if s.matches("Vpc") /* Vpc com.amazonaws.docdb#OrderableDBInstanceOption$Vpc */ =>  {
                let var_285 =
                    Some(
                         {
                            <bool as smithy_types::primitive::Parse>::parse_smithy_primitive(
                                smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            )
                            .map_err(|_|smithy_xml::decode::XmlError::custom("expected (boolean: `com.amazonaws.docdb#Boolean`)"))
                        }
                        ?
                    )
                ;
                builder = builder.set_vpc(var_285);
            }
            ,
            _ => {}
        }
    }
    Ok(builder.build())
}

pub fn deser_structure_tag(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<crate::model::Tag, smithy_xml::decode::XmlError> {
    #[allow(unused_mut)]
    let mut builder = crate::model::Tag::builder();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("Key") /* Key com.amazonaws.docdb#Tag$Key */ =>  {
                let var_286 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_key(var_286);
            }
            ,
            s if s.matches("Value") /* Value com.amazonaws.docdb#Tag$Value */ =>  {
                let var_287 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_value(var_287);
            }
            ,
            _ => {}
        }
    }
    Ok(builder.build())
}

pub fn deser_structure_pending_maintenance_action(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<crate::model::PendingMaintenanceAction, smithy_xml::decode::XmlError> {
    #[allow(unused_mut)]
    let mut builder = crate::model::PendingMaintenanceAction::builder();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("Action") /* Action com.amazonaws.docdb#PendingMaintenanceAction$Action */ =>  {
                let var_288 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_action(var_288);
            }
            ,
            s if s.matches("AutoAppliedAfterDate") /* AutoAppliedAfterDate com.amazonaws.docdb#PendingMaintenanceAction$AutoAppliedAfterDate */ =>  {
                let var_289 =
                    Some(
                        smithy_types::Instant::from_str(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            , smithy_types::instant::Format::DateTime
                        )
                        .map_err(|_|smithy_xml::decode::XmlError::custom("expected (timestamp: `com.amazonaws.docdb#TStamp`)"))
                        ?
                    )
                ;
                builder = builder.set_auto_applied_after_date(var_289);
            }
            ,
            s if s.matches("ForcedApplyDate") /* ForcedApplyDate com.amazonaws.docdb#PendingMaintenanceAction$ForcedApplyDate */ =>  {
                let var_290 =
                    Some(
                        smithy_types::Instant::from_str(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            , smithy_types::instant::Format::DateTime
                        )
                        .map_err(|_|smithy_xml::decode::XmlError::custom("expected (timestamp: `com.amazonaws.docdb#TStamp`)"))
                        ?
                    )
                ;
                builder = builder.set_forced_apply_date(var_290);
            }
            ,
            s if s.matches("OptInStatus") /* OptInStatus com.amazonaws.docdb#PendingMaintenanceAction$OptInStatus */ =>  {
                let var_291 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_opt_in_status(var_291);
            }
            ,
            s if s.matches("CurrentApplyDate") /* CurrentApplyDate com.amazonaws.docdb#PendingMaintenanceAction$CurrentApplyDate */ =>  {
                let var_292 =
                    Some(
                        smithy_types::Instant::from_str(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            , smithy_types::instant::Format::DateTime
                        )
                        .map_err(|_|smithy_xml::decode::XmlError::custom("expected (timestamp: `com.amazonaws.docdb#TStamp`)"))
                        ?
                    )
                ;
                builder = builder.set_current_apply_date(var_292);
            }
            ,
            s if s.matches("Description") /* Description com.amazonaws.docdb#PendingMaintenanceAction$Description */ =>  {
                let var_293 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_description(var_293);
            }
            ,
            _ => {}
        }
    }
    Ok(builder.build())
}

pub fn deser_structure_db_cluster_member(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<crate::model::DbClusterMember, smithy_xml::decode::XmlError> {
    #[allow(unused_mut)]
    let mut builder = crate::model::DbClusterMember::builder();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("DBInstanceIdentifier") /* DBInstanceIdentifier com.amazonaws.docdb#DBClusterMember$DBInstanceIdentifier */ =>  {
                let var_294 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_db_instance_identifier(var_294);
            }
            ,
            s if s.matches("IsClusterWriter") /* IsClusterWriter com.amazonaws.docdb#DBClusterMember$IsClusterWriter */ =>  {
                let var_295 =
                    Some(
                         {
                            <bool as smithy_types::primitive::Parse>::parse_smithy_primitive(
                                smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            )
                            .map_err(|_|smithy_xml::decode::XmlError::custom("expected (boolean: `com.amazonaws.docdb#Boolean`)"))
                        }
                        ?
                    )
                ;
                builder = builder.set_is_cluster_writer(var_295);
            }
            ,
            s if s.matches("DBClusterParameterGroupStatus") /* DBClusterParameterGroupStatus com.amazonaws.docdb#DBClusterMember$DBClusterParameterGroupStatus */ =>  {
                let var_296 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_db_cluster_parameter_group_status(var_296);
            }
            ,
            s if s.matches("PromotionTier") /* PromotionTier com.amazonaws.docdb#DBClusterMember$PromotionTier */ =>  {
                let var_297 =
                    Some(
                         {
                            <i32 as smithy_types::primitive::Parse>::parse_smithy_primitive(
                                smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            )
                            .map_err(|_|smithy_xml::decode::XmlError::custom("expected (integer: `com.amazonaws.docdb#IntegerOptional`)"))
                        }
                        ?
                    )
                ;
                builder = builder.set_promotion_tier(var_297);
            }
            ,
            _ => {}
        }
    }
    Ok(builder.build())
}

pub fn deser_structure_vpc_security_group_membership(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<crate::model::VpcSecurityGroupMembership, smithy_xml::decode::XmlError> {
    #[allow(unused_mut)]
    let mut builder = crate::model::VpcSecurityGroupMembership::builder();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("VpcSecurityGroupId") /* VpcSecurityGroupId com.amazonaws.docdb#VpcSecurityGroupMembership$VpcSecurityGroupId */ =>  {
                let var_298 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_vpc_security_group_id(var_298);
            }
            ,
            s if s.matches("Status") /* Status com.amazonaws.docdb#VpcSecurityGroupMembership$Status */ =>  {
                let var_299 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_status(var_299);
            }
            ,
            _ => {}
        }
    }
    Ok(builder.build())
}

pub fn deser_structure_db_cluster_role(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<crate::model::DbClusterRole, smithy_xml::decode::XmlError> {
    #[allow(unused_mut)]
    let mut builder = crate::model::DbClusterRole::builder();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("RoleArn") /* RoleArn com.amazonaws.docdb#DBClusterRole$RoleArn */ =>  {
                let var_300 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_role_arn(var_300);
            }
            ,
            s if s.matches("Status") /* Status com.amazonaws.docdb#DBClusterRole$Status */ =>  {
                let var_301 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_status(var_301);
            }
            ,
            _ => {}
        }
    }
    Ok(builder.build())
}

pub fn deser_structure_pending_cloudwatch_logs_exports(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<crate::model::PendingCloudwatchLogsExports, smithy_xml::decode::XmlError> {
    #[allow(unused_mut)]
    let mut builder = crate::model::PendingCloudwatchLogsExports::builder();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("LogTypesToEnable") /* LogTypesToEnable com.amazonaws.docdb#PendingCloudwatchLogsExports$LogTypesToEnable */ =>  {
                let var_302 =
                    Some(
                        crate::xml_deser::deser_list_log_type_list(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_log_types_to_enable(var_302);
            }
            ,
            s if s.matches("LogTypesToDisable") /* LogTypesToDisable com.amazonaws.docdb#PendingCloudwatchLogsExports$LogTypesToDisable */ =>  {
                let var_303 =
                    Some(
                        crate::xml_deser::deser_list_log_type_list(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_log_types_to_disable(var_303);
            }
            ,
            _ => {}
        }
    }
    Ok(builder.build())
}

pub fn deser_structure_db_instance_status_info(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<crate::model::DbInstanceStatusInfo, smithy_xml::decode::XmlError> {
    #[allow(unused_mut)]
    let mut builder = crate::model::DbInstanceStatusInfo::builder();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("StatusType") /* StatusType com.amazonaws.docdb#DBInstanceStatusInfo$StatusType */ =>  {
                let var_304 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_status_type(var_304);
            }
            ,
            s if s.matches("Normal") /* Normal com.amazonaws.docdb#DBInstanceStatusInfo$Normal */ =>  {
                let var_305 =
                    Some(
                         {
                            <bool as smithy_types::primitive::Parse>::parse_smithy_primitive(
                                smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            )
                            .map_err(|_|smithy_xml::decode::XmlError::custom("expected (boolean: `com.amazonaws.docdb#Boolean`)"))
                        }
                        ?
                    )
                ;
                builder = builder.set_normal(var_305);
            }
            ,
            s if s.matches("Status") /* Status com.amazonaws.docdb#DBInstanceStatusInfo$Status */ =>  {
                let var_306 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_status(var_306);
            }
            ,
            s if s.matches("Message") /* Message com.amazonaws.docdb#DBInstanceStatusInfo$Message */ =>  {
                let var_307 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_message(var_307);
            }
            ,
            _ => {}
        }
    }
    Ok(builder.build())
}

pub fn deser_structure_subnet(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<crate::model::Subnet, smithy_xml::decode::XmlError> {
    #[allow(unused_mut)]
    let mut builder = crate::model::Subnet::builder();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("SubnetIdentifier") /* SubnetIdentifier com.amazonaws.docdb#Subnet$SubnetIdentifier */ =>  {
                let var_308 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_subnet_identifier(var_308);
            }
            ,
            s if s.matches("SubnetAvailabilityZone") /* SubnetAvailabilityZone com.amazonaws.docdb#Subnet$SubnetAvailabilityZone */ =>  {
                let var_309 =
                    Some(
                        crate::xml_deser::deser_structure_availability_zone(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_subnet_availability_zone(var_309);
            }
            ,
            s if s.matches("SubnetStatus") /* SubnetStatus com.amazonaws.docdb#Subnet$SubnetStatus */ =>  {
                let var_310 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_subnet_status(var_310);
            }
            ,
            _ => {}
        }
    }
    Ok(builder.build())
}

pub fn deser_structure_global_cluster_member(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<crate::model::GlobalClusterMember, smithy_xml::decode::XmlError> {
    #[allow(unused_mut)]
    let mut builder = crate::model::GlobalClusterMember::builder();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("DBClusterArn") /* DBClusterArn com.amazonaws.docdb#GlobalClusterMember$DBClusterArn */ =>  {
                let var_311 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_db_cluster_arn(var_311);
            }
            ,
            s if s.matches("Readers") /* Readers com.amazonaws.docdb#GlobalClusterMember$Readers */ =>  {
                let var_312 =
                    Some(
                        crate::xml_deser::deser_list_readers_arn_list(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_readers(var_312);
            }
            ,
            s if s.matches("IsWriter") /* IsWriter com.amazonaws.docdb#GlobalClusterMember$IsWriter */ =>  {
                let var_313 =
                    Some(
                         {
                            <bool as smithy_types::primitive::Parse>::parse_smithy_primitive(
                                smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            )
                            .map_err(|_|smithy_xml::decode::XmlError::custom("expected (boolean: `com.amazonaws.docdb#Boolean`)"))
                        }
                        ?
                    )
                ;
                builder = builder.set_is_writer(var_313);
            }
            ,
            _ => {}
        }
    }
    Ok(builder.build())
}

pub fn deser_structure_db_cluster_snapshot_attribute(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<crate::model::DbClusterSnapshotAttribute, smithy_xml::decode::XmlError> {
    #[allow(unused_mut)]
    let mut builder = crate::model::DbClusterSnapshotAttribute::builder();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("AttributeName") /* AttributeName com.amazonaws.docdb#DBClusterSnapshotAttribute$AttributeName */ =>  {
                let var_314 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_attribute_name(var_314);
            }
            ,
            s if s.matches("AttributeValues") /* AttributeValues com.amazonaws.docdb#DBClusterSnapshotAttribute$AttributeValues */ =>  {
                let var_315 =
                    Some(
                        crate::xml_deser::deser_list_attribute_value_list(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_attribute_values(var_315);
            }
            ,
            _ => {}
        }
    }
    Ok(builder.build())
}

pub fn deser_list_valid_upgrade_target_list(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<std::vec::Vec<crate::model::UpgradeTarget>, smithy_xml::decode::XmlError> {
    let mut out = std::vec::Vec::new();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("UpgradeTarget") /* member com.amazonaws.docdb#ValidUpgradeTargetList$member */ =>  {
                out.push(
                    crate::xml_deser::deser_structure_upgrade_target(&mut tag)
                    ?
                );
            }
            ,
            _ => {}
        }
    }
    Ok(out)
}

pub fn deser_list_availability_zone_list(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<std::vec::Vec<crate::model::AvailabilityZone>, smithy_xml::decode::XmlError> {
    let mut out = std::vec::Vec::new();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("AvailabilityZone") /* member com.amazonaws.docdb#AvailabilityZoneList$member */ =>  {
                out.push(
                    crate::xml_deser::deser_structure_availability_zone(&mut tag)
                    ?
                );
            }
            ,
            _ => {}
        }
    }
    Ok(out)
}

pub fn deser_structure_availability_zone(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<crate::model::AvailabilityZone, smithy_xml::decode::XmlError> {
    #[allow(unused_mut)]
    let mut builder = crate::model::AvailabilityZone::builder();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("Name") /* Name com.amazonaws.docdb#AvailabilityZone$Name */ =>  {
                let var_316 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_name(var_316);
            }
            ,
            _ => {}
        }
    }
    Ok(builder.build())
}

pub fn deser_list_readers_arn_list(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<std::vec::Vec<std::string::String>, smithy_xml::decode::XmlError> {
    let mut out = std::vec::Vec::new();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("member") /* member com.amazonaws.docdb#ReadersArnList$member */ =>  {
                out.push(
                    Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                        smithy_xml::decode::try_data(&mut tag)?.as_ref()
                        .into()
                    )
                    ?
                );
            }
            ,
            _ => {}
        }
    }
    Ok(out)
}

pub fn deser_list_attribute_value_list(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<std::vec::Vec<std::string::String>, smithy_xml::decode::XmlError> {
    let mut out = std::vec::Vec::new();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("AttributeValue") /* member com.amazonaws.docdb#AttributeValueList$member */ =>  {
                out.push(
                    Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                        smithy_xml::decode::try_data(&mut tag)?.as_ref()
                        .into()
                    )
                    ?
                );
            }
            ,
            _ => {}
        }
    }
    Ok(out)
}

pub fn deser_structure_upgrade_target(
    decoder: &mut smithy_xml::decode::ScopedDecoder,
) -> Result<crate::model::UpgradeTarget, smithy_xml::decode::XmlError> {
    #[allow(unused_mut)]
    let mut builder = crate::model::UpgradeTarget::builder();
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("Engine") /* Engine com.amazonaws.docdb#UpgradeTarget$Engine */ =>  {
                let var_317 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_engine(var_317);
            }
            ,
            s if s.matches("EngineVersion") /* EngineVersion com.amazonaws.docdb#UpgradeTarget$EngineVersion */ =>  {
                let var_318 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_engine_version(var_318);
            }
            ,
            s if s.matches("Description") /* Description com.amazonaws.docdb#UpgradeTarget$Description */ =>  {
                let var_319 =
                    Some(
                        Result::<std::string::String, smithy_xml::decode::XmlError>::Ok(
                            smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            .into()
                        )
                        ?
                    )
                ;
                builder = builder.set_description(var_319);
            }
            ,
            s if s.matches("AutoUpgrade") /* AutoUpgrade com.amazonaws.docdb#UpgradeTarget$AutoUpgrade */ =>  {
                let var_320 =
                    Some(
                         {
                            <bool as smithy_types::primitive::Parse>::parse_smithy_primitive(
                                smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            )
                            .map_err(|_|smithy_xml::decode::XmlError::custom("expected (boolean: `com.amazonaws.docdb#Boolean`)"))
                        }
                        ?
                    )
                ;
                builder = builder.set_auto_upgrade(var_320);
            }
            ,
            s if s.matches("IsMajorVersionUpgrade") /* IsMajorVersionUpgrade com.amazonaws.docdb#UpgradeTarget$IsMajorVersionUpgrade */ =>  {
                let var_321 =
                    Some(
                         {
                            <bool as smithy_types::primitive::Parse>::parse_smithy_primitive(
                                smithy_xml::decode::try_data(&mut tag)?.as_ref()
                            )
                            .map_err(|_|smithy_xml::decode::XmlError::custom("expected (boolean: `com.amazonaws.docdb#Boolean`)"))
                        }
                        ?
                    )
                ;
                builder = builder.set_is_major_version_upgrade(var_321);
            }
            ,
            _ => {}
        }
    }
    Ok(builder.build())
}
