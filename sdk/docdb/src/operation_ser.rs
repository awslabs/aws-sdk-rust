// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub fn serialize_operation_crate_operation_add_source_identifier_to_subscription(
    input: &crate::input::AddSourceIdentifierToSubscriptionInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "AddSourceIdentifierToSubscription", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_1 = writer.prefix("SubscriptionName");
    if let Some(var_2) = &input.subscription_name {
        scope_1.string(var_2);
    }
    #[allow(unused_mut)]
    let mut scope_3 = writer.prefix("SourceIdentifier");
    if let Some(var_4) = &input.source_identifier {
        scope_3.string(var_4);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_add_tags_to_resource(
    input: &crate::input::AddTagsToResourceInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "AddTagsToResource", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_5 = writer.prefix("ResourceName");
    if let Some(var_6) = &input.resource_name {
        scope_5.string(var_6);
    }
    #[allow(unused_mut)]
    let mut scope_7 = writer.prefix("Tags");
    if let Some(var_8) = &input.tags {
        let mut list_10 = scope_7.start_list(false, Some("Tag"));
        for item_9 in var_8 {
            #[allow(unused_mut)]
            let mut entry_11 = list_10.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_11, item_9);
        }
        list_10.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_apply_pending_maintenance_action(
    input: &crate::input::ApplyPendingMaintenanceActionInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ApplyPendingMaintenanceAction", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_12 = writer.prefix("ResourceIdentifier");
    if let Some(var_13) = &input.resource_identifier {
        scope_12.string(var_13);
    }
    #[allow(unused_mut)]
    let mut scope_14 = writer.prefix("ApplyAction");
    if let Some(var_15) = &input.apply_action {
        scope_14.string(var_15);
    }
    #[allow(unused_mut)]
    let mut scope_16 = writer.prefix("OptInType");
    if let Some(var_17) = &input.opt_in_type {
        scope_16.string(var_17);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_copy_db_cluster_parameter_group(
    input: &crate::input::CopyDbClusterParameterGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "CopyDBClusterParameterGroup", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_18 = writer.prefix("SourceDBClusterParameterGroupIdentifier");
    if let Some(var_19) = &input.source_db_cluster_parameter_group_identifier {
        scope_18.string(var_19);
    }
    #[allow(unused_mut)]
    let mut scope_20 = writer.prefix("TargetDBClusterParameterGroupIdentifier");
    if let Some(var_21) = &input.target_db_cluster_parameter_group_identifier {
        scope_20.string(var_21);
    }
    #[allow(unused_mut)]
    let mut scope_22 = writer.prefix("TargetDBClusterParameterGroupDescription");
    if let Some(var_23) = &input.target_db_cluster_parameter_group_description {
        scope_22.string(var_23);
    }
    #[allow(unused_mut)]
    let mut scope_24 = writer.prefix("Tags");
    if let Some(var_25) = &input.tags {
        let mut list_27 = scope_24.start_list(false, Some("Tag"));
        for item_26 in var_25 {
            #[allow(unused_mut)]
            let mut entry_28 = list_27.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_28, item_26);
        }
        list_27.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_copy_db_cluster_snapshot(
    input: &crate::input::CopyDbClusterSnapshotInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "CopyDBClusterSnapshot", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_29 = writer.prefix("SourceDBClusterSnapshotIdentifier");
    if let Some(var_30) = &input.source_db_cluster_snapshot_identifier {
        scope_29.string(var_30);
    }
    #[allow(unused_mut)]
    let mut scope_31 = writer.prefix("TargetDBClusterSnapshotIdentifier");
    if let Some(var_32) = &input.target_db_cluster_snapshot_identifier {
        scope_31.string(var_32);
    }
    #[allow(unused_mut)]
    let mut scope_33 = writer.prefix("KmsKeyId");
    if let Some(var_34) = &input.kms_key_id {
        scope_33.string(var_34);
    }
    #[allow(unused_mut)]
    let mut scope_35 = writer.prefix("PreSignedUrl");
    if let Some(var_36) = &input.pre_signed_url {
        scope_35.string(var_36);
    }
    #[allow(unused_mut)]
    let mut scope_37 = writer.prefix("CopyTags");
    if let Some(var_38) = &input.copy_tags {
        scope_37.boolean(*var_38);
    }
    #[allow(unused_mut)]
    let mut scope_39 = writer.prefix("Tags");
    if let Some(var_40) = &input.tags {
        let mut list_42 = scope_39.start_list(false, Some("Tag"));
        for item_41 in var_40 {
            #[allow(unused_mut)]
            let mut entry_43 = list_42.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_43, item_41);
        }
        list_42.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_db_cluster(
    input: &crate::input::CreateDbClusterInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "CreateDBCluster", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_44 = writer.prefix("AvailabilityZones");
    if let Some(var_45) = &input.availability_zones {
        let mut list_47 = scope_44.start_list(false, Some("AvailabilityZone"));
        for item_46 in var_45 {
            #[allow(unused_mut)]
            let mut entry_48 = list_47.entry();
            entry_48.string(item_46);
        }
        list_47.finish();
    }
    #[allow(unused_mut)]
    let mut scope_49 = writer.prefix("BackupRetentionPeriod");
    if let Some(var_50) = &input.backup_retention_period {
        scope_49.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_50).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_51 = writer.prefix("DBClusterIdentifier");
    if let Some(var_52) = &input.db_cluster_identifier {
        scope_51.string(var_52);
    }
    #[allow(unused_mut)]
    let mut scope_53 = writer.prefix("DBClusterParameterGroupName");
    if let Some(var_54) = &input.db_cluster_parameter_group_name {
        scope_53.string(var_54);
    }
    #[allow(unused_mut)]
    let mut scope_55 = writer.prefix("VpcSecurityGroupIds");
    if let Some(var_56) = &input.vpc_security_group_ids {
        let mut list_58 = scope_55.start_list(false, Some("VpcSecurityGroupId"));
        for item_57 in var_56 {
            #[allow(unused_mut)]
            let mut entry_59 = list_58.entry();
            entry_59.string(item_57);
        }
        list_58.finish();
    }
    #[allow(unused_mut)]
    let mut scope_60 = writer.prefix("DBSubnetGroupName");
    if let Some(var_61) = &input.db_subnet_group_name {
        scope_60.string(var_61);
    }
    #[allow(unused_mut)]
    let mut scope_62 = writer.prefix("Engine");
    if let Some(var_63) = &input.engine {
        scope_62.string(var_63);
    }
    #[allow(unused_mut)]
    let mut scope_64 = writer.prefix("EngineVersion");
    if let Some(var_65) = &input.engine_version {
        scope_64.string(var_65);
    }
    #[allow(unused_mut)]
    let mut scope_66 = writer.prefix("Port");
    if let Some(var_67) = &input.port {
        scope_66.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_67).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_68 = writer.prefix("MasterUsername");
    if let Some(var_69) = &input.master_username {
        scope_68.string(var_69);
    }
    #[allow(unused_mut)]
    let mut scope_70 = writer.prefix("MasterUserPassword");
    if let Some(var_71) = &input.master_user_password {
        scope_70.string(var_71);
    }
    #[allow(unused_mut)]
    let mut scope_72 = writer.prefix("PreferredBackupWindow");
    if let Some(var_73) = &input.preferred_backup_window {
        scope_72.string(var_73);
    }
    #[allow(unused_mut)]
    let mut scope_74 = writer.prefix("PreferredMaintenanceWindow");
    if let Some(var_75) = &input.preferred_maintenance_window {
        scope_74.string(var_75);
    }
    #[allow(unused_mut)]
    let mut scope_76 = writer.prefix("Tags");
    if let Some(var_77) = &input.tags {
        let mut list_79 = scope_76.start_list(false, Some("Tag"));
        for item_78 in var_77 {
            #[allow(unused_mut)]
            let mut entry_80 = list_79.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_80, item_78);
        }
        list_79.finish();
    }
    #[allow(unused_mut)]
    let mut scope_81 = writer.prefix("StorageEncrypted");
    if let Some(var_82) = &input.storage_encrypted {
        scope_81.boolean(*var_82);
    }
    #[allow(unused_mut)]
    let mut scope_83 = writer.prefix("KmsKeyId");
    if let Some(var_84) = &input.kms_key_id {
        scope_83.string(var_84);
    }
    #[allow(unused_mut)]
    let mut scope_85 = writer.prefix("PreSignedUrl");
    if let Some(var_86) = &input.pre_signed_url {
        scope_85.string(var_86);
    }
    #[allow(unused_mut)]
    let mut scope_87 = writer.prefix("EnableCloudwatchLogsExports");
    if let Some(var_88) = &input.enable_cloudwatch_logs_exports {
        let mut list_90 = scope_87.start_list(false, None);
        for item_89 in var_88 {
            #[allow(unused_mut)]
            let mut entry_91 = list_90.entry();
            entry_91.string(item_89);
        }
        list_90.finish();
    }
    #[allow(unused_mut)]
    let mut scope_92 = writer.prefix("DeletionProtection");
    if let Some(var_93) = &input.deletion_protection {
        scope_92.boolean(*var_93);
    }
    #[allow(unused_mut)]
    let mut scope_94 = writer.prefix("GlobalClusterIdentifier");
    if let Some(var_95) = &input.global_cluster_identifier {
        scope_94.string(var_95);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_db_cluster_parameter_group(
    input: &crate::input::CreateDbClusterParameterGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "CreateDBClusterParameterGroup", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_96 = writer.prefix("DBClusterParameterGroupName");
    if let Some(var_97) = &input.db_cluster_parameter_group_name {
        scope_96.string(var_97);
    }
    #[allow(unused_mut)]
    let mut scope_98 = writer.prefix("DBParameterGroupFamily");
    if let Some(var_99) = &input.db_parameter_group_family {
        scope_98.string(var_99);
    }
    #[allow(unused_mut)]
    let mut scope_100 = writer.prefix("Description");
    if let Some(var_101) = &input.description {
        scope_100.string(var_101);
    }
    #[allow(unused_mut)]
    let mut scope_102 = writer.prefix("Tags");
    if let Some(var_103) = &input.tags {
        let mut list_105 = scope_102.start_list(false, Some("Tag"));
        for item_104 in var_103 {
            #[allow(unused_mut)]
            let mut entry_106 = list_105.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_106, item_104);
        }
        list_105.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_db_cluster_snapshot(
    input: &crate::input::CreateDbClusterSnapshotInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "CreateDBClusterSnapshot", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_107 = writer.prefix("DBClusterSnapshotIdentifier");
    if let Some(var_108) = &input.db_cluster_snapshot_identifier {
        scope_107.string(var_108);
    }
    #[allow(unused_mut)]
    let mut scope_109 = writer.prefix("DBClusterIdentifier");
    if let Some(var_110) = &input.db_cluster_identifier {
        scope_109.string(var_110);
    }
    #[allow(unused_mut)]
    let mut scope_111 = writer.prefix("Tags");
    if let Some(var_112) = &input.tags {
        let mut list_114 = scope_111.start_list(false, Some("Tag"));
        for item_113 in var_112 {
            #[allow(unused_mut)]
            let mut entry_115 = list_114.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_115, item_113);
        }
        list_114.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_db_instance(
    input: &crate::input::CreateDbInstanceInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "CreateDBInstance", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_116 = writer.prefix("DBInstanceIdentifier");
    if let Some(var_117) = &input.db_instance_identifier {
        scope_116.string(var_117);
    }
    #[allow(unused_mut)]
    let mut scope_118 = writer.prefix("DBInstanceClass");
    if let Some(var_119) = &input.db_instance_class {
        scope_118.string(var_119);
    }
    #[allow(unused_mut)]
    let mut scope_120 = writer.prefix("Engine");
    if let Some(var_121) = &input.engine {
        scope_120.string(var_121);
    }
    #[allow(unused_mut)]
    let mut scope_122 = writer.prefix("AvailabilityZone");
    if let Some(var_123) = &input.availability_zone {
        scope_122.string(var_123);
    }
    #[allow(unused_mut)]
    let mut scope_124 = writer.prefix("PreferredMaintenanceWindow");
    if let Some(var_125) = &input.preferred_maintenance_window {
        scope_124.string(var_125);
    }
    #[allow(unused_mut)]
    let mut scope_126 = writer.prefix("AutoMinorVersionUpgrade");
    if let Some(var_127) = &input.auto_minor_version_upgrade {
        scope_126.boolean(*var_127);
    }
    #[allow(unused_mut)]
    let mut scope_128 = writer.prefix("Tags");
    if let Some(var_129) = &input.tags {
        let mut list_131 = scope_128.start_list(false, Some("Tag"));
        for item_130 in var_129 {
            #[allow(unused_mut)]
            let mut entry_132 = list_131.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_132, item_130);
        }
        list_131.finish();
    }
    #[allow(unused_mut)]
    let mut scope_133 = writer.prefix("DBClusterIdentifier");
    if let Some(var_134) = &input.db_cluster_identifier {
        scope_133.string(var_134);
    }
    #[allow(unused_mut)]
    let mut scope_135 = writer.prefix("PromotionTier");
    if let Some(var_136) = &input.promotion_tier {
        scope_135.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_136).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_db_subnet_group(
    input: &crate::input::CreateDbSubnetGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "CreateDBSubnetGroup", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_137 = writer.prefix("DBSubnetGroupName");
    if let Some(var_138) = &input.db_subnet_group_name {
        scope_137.string(var_138);
    }
    #[allow(unused_mut)]
    let mut scope_139 = writer.prefix("DBSubnetGroupDescription");
    if let Some(var_140) = &input.db_subnet_group_description {
        scope_139.string(var_140);
    }
    #[allow(unused_mut)]
    let mut scope_141 = writer.prefix("SubnetIds");
    if let Some(var_142) = &input.subnet_ids {
        let mut list_144 = scope_141.start_list(false, Some("SubnetIdentifier"));
        for item_143 in var_142 {
            #[allow(unused_mut)]
            let mut entry_145 = list_144.entry();
            entry_145.string(item_143);
        }
        list_144.finish();
    }
    #[allow(unused_mut)]
    let mut scope_146 = writer.prefix("Tags");
    if let Some(var_147) = &input.tags {
        let mut list_149 = scope_146.start_list(false, Some("Tag"));
        for item_148 in var_147 {
            #[allow(unused_mut)]
            let mut entry_150 = list_149.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_150, item_148);
        }
        list_149.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_event_subscription(
    input: &crate::input::CreateEventSubscriptionInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "CreateEventSubscription", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_151 = writer.prefix("SubscriptionName");
    if let Some(var_152) = &input.subscription_name {
        scope_151.string(var_152);
    }
    #[allow(unused_mut)]
    let mut scope_153 = writer.prefix("SnsTopicArn");
    if let Some(var_154) = &input.sns_topic_arn {
        scope_153.string(var_154);
    }
    #[allow(unused_mut)]
    let mut scope_155 = writer.prefix("SourceType");
    if let Some(var_156) = &input.source_type {
        scope_155.string(var_156);
    }
    #[allow(unused_mut)]
    let mut scope_157 = writer.prefix("EventCategories");
    if let Some(var_158) = &input.event_categories {
        let mut list_160 = scope_157.start_list(false, Some("EventCategory"));
        for item_159 in var_158 {
            #[allow(unused_mut)]
            let mut entry_161 = list_160.entry();
            entry_161.string(item_159);
        }
        list_160.finish();
    }
    #[allow(unused_mut)]
    let mut scope_162 = writer.prefix("SourceIds");
    if let Some(var_163) = &input.source_ids {
        let mut list_165 = scope_162.start_list(false, Some("SourceId"));
        for item_164 in var_163 {
            #[allow(unused_mut)]
            let mut entry_166 = list_165.entry();
            entry_166.string(item_164);
        }
        list_165.finish();
    }
    #[allow(unused_mut)]
    let mut scope_167 = writer.prefix("Enabled");
    if let Some(var_168) = &input.enabled {
        scope_167.boolean(*var_168);
    }
    #[allow(unused_mut)]
    let mut scope_169 = writer.prefix("Tags");
    if let Some(var_170) = &input.tags {
        let mut list_172 = scope_169.start_list(false, Some("Tag"));
        for item_171 in var_170 {
            #[allow(unused_mut)]
            let mut entry_173 = list_172.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_173, item_171);
        }
        list_172.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_global_cluster(
    input: &crate::input::CreateGlobalClusterInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "CreateGlobalCluster", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_174 = writer.prefix("GlobalClusterIdentifier");
    if let Some(var_175) = &input.global_cluster_identifier {
        scope_174.string(var_175);
    }
    #[allow(unused_mut)]
    let mut scope_176 = writer.prefix("SourceDBClusterIdentifier");
    if let Some(var_177) = &input.source_db_cluster_identifier {
        scope_176.string(var_177);
    }
    #[allow(unused_mut)]
    let mut scope_178 = writer.prefix("Engine");
    if let Some(var_179) = &input.engine {
        scope_178.string(var_179);
    }
    #[allow(unused_mut)]
    let mut scope_180 = writer.prefix("EngineVersion");
    if let Some(var_181) = &input.engine_version {
        scope_180.string(var_181);
    }
    #[allow(unused_mut)]
    let mut scope_182 = writer.prefix("DeletionProtection");
    if let Some(var_183) = &input.deletion_protection {
        scope_182.boolean(*var_183);
    }
    #[allow(unused_mut)]
    let mut scope_184 = writer.prefix("DatabaseName");
    if let Some(var_185) = &input.database_name {
        scope_184.string(var_185);
    }
    #[allow(unused_mut)]
    let mut scope_186 = writer.prefix("StorageEncrypted");
    if let Some(var_187) = &input.storage_encrypted {
        scope_186.boolean(*var_187);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_db_cluster(
    input: &crate::input::DeleteDbClusterInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeleteDBCluster", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_188 = writer.prefix("DBClusterIdentifier");
    if let Some(var_189) = &input.db_cluster_identifier {
        scope_188.string(var_189);
    }
    #[allow(unused_mut)]
    let mut scope_190 = writer.prefix("SkipFinalSnapshot");
    if input.skip_final_snapshot {
        scope_190.boolean(input.skip_final_snapshot);
    }
    #[allow(unused_mut)]
    let mut scope_191 = writer.prefix("FinalDBSnapshotIdentifier");
    if let Some(var_192) = &input.final_db_snapshot_identifier {
        scope_191.string(var_192);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_db_cluster_parameter_group(
    input: &crate::input::DeleteDbClusterParameterGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeleteDBClusterParameterGroup", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_193 = writer.prefix("DBClusterParameterGroupName");
    if let Some(var_194) = &input.db_cluster_parameter_group_name {
        scope_193.string(var_194);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_db_cluster_snapshot(
    input: &crate::input::DeleteDbClusterSnapshotInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeleteDBClusterSnapshot", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_195 = writer.prefix("DBClusterSnapshotIdentifier");
    if let Some(var_196) = &input.db_cluster_snapshot_identifier {
        scope_195.string(var_196);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_db_instance(
    input: &crate::input::DeleteDbInstanceInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeleteDBInstance", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_197 = writer.prefix("DBInstanceIdentifier");
    if let Some(var_198) = &input.db_instance_identifier {
        scope_197.string(var_198);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_db_subnet_group(
    input: &crate::input::DeleteDbSubnetGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeleteDBSubnetGroup", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_199 = writer.prefix("DBSubnetGroupName");
    if let Some(var_200) = &input.db_subnet_group_name {
        scope_199.string(var_200);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_event_subscription(
    input: &crate::input::DeleteEventSubscriptionInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeleteEventSubscription", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_201 = writer.prefix("SubscriptionName");
    if let Some(var_202) = &input.subscription_name {
        scope_201.string(var_202);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_global_cluster(
    input: &crate::input::DeleteGlobalClusterInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeleteGlobalCluster", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_203 = writer.prefix("GlobalClusterIdentifier");
    if let Some(var_204) = &input.global_cluster_identifier {
        scope_203.string(var_204);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_certificates(
    input: &crate::input::DescribeCertificatesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DescribeCertificates", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_205 = writer.prefix("CertificateIdentifier");
    if let Some(var_206) = &input.certificate_identifier {
        scope_205.string(var_206);
    }
    #[allow(unused_mut)]
    let mut scope_207 = writer.prefix("Filters");
    if let Some(var_208) = &input.filters {
        let mut list_210 = scope_207.start_list(false, Some("Filter"));
        for item_209 in var_208 {
            #[allow(unused_mut)]
            let mut entry_211 = list_210.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_211, item_209);
        }
        list_210.finish();
    }
    #[allow(unused_mut)]
    let mut scope_212 = writer.prefix("MaxRecords");
    if let Some(var_213) = &input.max_records {
        scope_212.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_213).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_214 = writer.prefix("Marker");
    if let Some(var_215) = &input.marker {
        scope_214.string(var_215);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_db_cluster_parameter_groups(
    input: &crate::input::DescribeDbClusterParameterGroupsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeDBClusterParameterGroups", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_216 = writer.prefix("DBClusterParameterGroupName");
    if let Some(var_217) = &input.db_cluster_parameter_group_name {
        scope_216.string(var_217);
    }
    #[allow(unused_mut)]
    let mut scope_218 = writer.prefix("Filters");
    if let Some(var_219) = &input.filters {
        let mut list_221 = scope_218.start_list(false, Some("Filter"));
        for item_220 in var_219 {
            #[allow(unused_mut)]
            let mut entry_222 = list_221.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_222, item_220);
        }
        list_221.finish();
    }
    #[allow(unused_mut)]
    let mut scope_223 = writer.prefix("MaxRecords");
    if let Some(var_224) = &input.max_records {
        scope_223.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_224).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_225 = writer.prefix("Marker");
    if let Some(var_226) = &input.marker {
        scope_225.string(var_226);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_db_cluster_parameters(
    input: &crate::input::DescribeDbClusterParametersInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeDBClusterParameters", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_227 = writer.prefix("DBClusterParameterGroupName");
    if let Some(var_228) = &input.db_cluster_parameter_group_name {
        scope_227.string(var_228);
    }
    #[allow(unused_mut)]
    let mut scope_229 = writer.prefix("Source");
    if let Some(var_230) = &input.source {
        scope_229.string(var_230);
    }
    #[allow(unused_mut)]
    let mut scope_231 = writer.prefix("Filters");
    if let Some(var_232) = &input.filters {
        let mut list_234 = scope_231.start_list(false, Some("Filter"));
        for item_233 in var_232 {
            #[allow(unused_mut)]
            let mut entry_235 = list_234.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_235, item_233);
        }
        list_234.finish();
    }
    #[allow(unused_mut)]
    let mut scope_236 = writer.prefix("MaxRecords");
    if let Some(var_237) = &input.max_records {
        scope_236.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_237).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_238 = writer.prefix("Marker");
    if let Some(var_239) = &input.marker {
        scope_238.string(var_239);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_db_clusters(
    input: &crate::input::DescribeDbClustersInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DescribeDBClusters", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_240 = writer.prefix("DBClusterIdentifier");
    if let Some(var_241) = &input.db_cluster_identifier {
        scope_240.string(var_241);
    }
    #[allow(unused_mut)]
    let mut scope_242 = writer.prefix("Filters");
    if let Some(var_243) = &input.filters {
        let mut list_245 = scope_242.start_list(false, Some("Filter"));
        for item_244 in var_243 {
            #[allow(unused_mut)]
            let mut entry_246 = list_245.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_246, item_244);
        }
        list_245.finish();
    }
    #[allow(unused_mut)]
    let mut scope_247 = writer.prefix("MaxRecords");
    if let Some(var_248) = &input.max_records {
        scope_247.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_248).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_249 = writer.prefix("Marker");
    if let Some(var_250) = &input.marker {
        scope_249.string(var_250);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_db_cluster_snapshot_attributes(
    input: &crate::input::DescribeDbClusterSnapshotAttributesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "DescribeDBClusterSnapshotAttributes",
        "2014-10-31",
    );
    #[allow(unused_mut)]
    let mut scope_251 = writer.prefix("DBClusterSnapshotIdentifier");
    if let Some(var_252) = &input.db_cluster_snapshot_identifier {
        scope_251.string(var_252);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_db_cluster_snapshots(
    input: &crate::input::DescribeDbClusterSnapshotsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeDBClusterSnapshots", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_253 = writer.prefix("DBClusterIdentifier");
    if let Some(var_254) = &input.db_cluster_identifier {
        scope_253.string(var_254);
    }
    #[allow(unused_mut)]
    let mut scope_255 = writer.prefix("DBClusterSnapshotIdentifier");
    if let Some(var_256) = &input.db_cluster_snapshot_identifier {
        scope_255.string(var_256);
    }
    #[allow(unused_mut)]
    let mut scope_257 = writer.prefix("SnapshotType");
    if let Some(var_258) = &input.snapshot_type {
        scope_257.string(var_258);
    }
    #[allow(unused_mut)]
    let mut scope_259 = writer.prefix("Filters");
    if let Some(var_260) = &input.filters {
        let mut list_262 = scope_259.start_list(false, Some("Filter"));
        for item_261 in var_260 {
            #[allow(unused_mut)]
            let mut entry_263 = list_262.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_263, item_261);
        }
        list_262.finish();
    }
    #[allow(unused_mut)]
    let mut scope_264 = writer.prefix("MaxRecords");
    if let Some(var_265) = &input.max_records {
        scope_264.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_265).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_266 = writer.prefix("Marker");
    if let Some(var_267) = &input.marker {
        scope_266.string(var_267);
    }
    #[allow(unused_mut)]
    let mut scope_268 = writer.prefix("IncludeShared");
    if input.include_shared {
        scope_268.boolean(input.include_shared);
    }
    #[allow(unused_mut)]
    let mut scope_269 = writer.prefix("IncludePublic");
    if input.include_public {
        scope_269.boolean(input.include_public);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_db_engine_versions(
    input: &crate::input::DescribeDbEngineVersionsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeDBEngineVersions", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_270 = writer.prefix("Engine");
    if let Some(var_271) = &input.engine {
        scope_270.string(var_271);
    }
    #[allow(unused_mut)]
    let mut scope_272 = writer.prefix("EngineVersion");
    if let Some(var_273) = &input.engine_version {
        scope_272.string(var_273);
    }
    #[allow(unused_mut)]
    let mut scope_274 = writer.prefix("DBParameterGroupFamily");
    if let Some(var_275) = &input.db_parameter_group_family {
        scope_274.string(var_275);
    }
    #[allow(unused_mut)]
    let mut scope_276 = writer.prefix("Filters");
    if let Some(var_277) = &input.filters {
        let mut list_279 = scope_276.start_list(false, Some("Filter"));
        for item_278 in var_277 {
            #[allow(unused_mut)]
            let mut entry_280 = list_279.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_280, item_278);
        }
        list_279.finish();
    }
    #[allow(unused_mut)]
    let mut scope_281 = writer.prefix("MaxRecords");
    if let Some(var_282) = &input.max_records {
        scope_281.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_282).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_283 = writer.prefix("Marker");
    if let Some(var_284) = &input.marker {
        scope_283.string(var_284);
    }
    #[allow(unused_mut)]
    let mut scope_285 = writer.prefix("DefaultOnly");
    if input.default_only {
        scope_285.boolean(input.default_only);
    }
    #[allow(unused_mut)]
    let mut scope_286 = writer.prefix("ListSupportedCharacterSets");
    if let Some(var_287) = &input.list_supported_character_sets {
        scope_286.boolean(*var_287);
    }
    #[allow(unused_mut)]
    let mut scope_288 = writer.prefix("ListSupportedTimezones");
    if let Some(var_289) = &input.list_supported_timezones {
        scope_288.boolean(*var_289);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_db_instances(
    input: &crate::input::DescribeDbInstancesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DescribeDBInstances", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_290 = writer.prefix("DBInstanceIdentifier");
    if let Some(var_291) = &input.db_instance_identifier {
        scope_290.string(var_291);
    }
    #[allow(unused_mut)]
    let mut scope_292 = writer.prefix("Filters");
    if let Some(var_293) = &input.filters {
        let mut list_295 = scope_292.start_list(false, Some("Filter"));
        for item_294 in var_293 {
            #[allow(unused_mut)]
            let mut entry_296 = list_295.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_296, item_294);
        }
        list_295.finish();
    }
    #[allow(unused_mut)]
    let mut scope_297 = writer.prefix("MaxRecords");
    if let Some(var_298) = &input.max_records {
        scope_297.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_298).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_299 = writer.prefix("Marker");
    if let Some(var_300) = &input.marker {
        scope_299.string(var_300);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_db_subnet_groups(
    input: &crate::input::DescribeDbSubnetGroupsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeDBSubnetGroups", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_301 = writer.prefix("DBSubnetGroupName");
    if let Some(var_302) = &input.db_subnet_group_name {
        scope_301.string(var_302);
    }
    #[allow(unused_mut)]
    let mut scope_303 = writer.prefix("Filters");
    if let Some(var_304) = &input.filters {
        let mut list_306 = scope_303.start_list(false, Some("Filter"));
        for item_305 in var_304 {
            #[allow(unused_mut)]
            let mut entry_307 = list_306.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_307, item_305);
        }
        list_306.finish();
    }
    #[allow(unused_mut)]
    let mut scope_308 = writer.prefix("MaxRecords");
    if let Some(var_309) = &input.max_records {
        scope_308.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_309).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_310 = writer.prefix("Marker");
    if let Some(var_311) = &input.marker {
        scope_310.string(var_311);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_engine_default_cluster_parameters(
    input: &crate::input::DescribeEngineDefaultClusterParametersInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "DescribeEngineDefaultClusterParameters",
        "2014-10-31",
    );
    #[allow(unused_mut)]
    let mut scope_312 = writer.prefix("DBParameterGroupFamily");
    if let Some(var_313) = &input.db_parameter_group_family {
        scope_312.string(var_313);
    }
    #[allow(unused_mut)]
    let mut scope_314 = writer.prefix("Filters");
    if let Some(var_315) = &input.filters {
        let mut list_317 = scope_314.start_list(false, Some("Filter"));
        for item_316 in var_315 {
            #[allow(unused_mut)]
            let mut entry_318 = list_317.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_318, item_316);
        }
        list_317.finish();
    }
    #[allow(unused_mut)]
    let mut scope_319 = writer.prefix("MaxRecords");
    if let Some(var_320) = &input.max_records {
        scope_319.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_320).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_321 = writer.prefix("Marker");
    if let Some(var_322) = &input.marker {
        scope_321.string(var_322);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_event_categories(
    input: &crate::input::DescribeEventCategoriesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeEventCategories", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_323 = writer.prefix("SourceType");
    if let Some(var_324) = &input.source_type {
        scope_323.string(var_324);
    }
    #[allow(unused_mut)]
    let mut scope_325 = writer.prefix("Filters");
    if let Some(var_326) = &input.filters {
        let mut list_328 = scope_325.start_list(false, Some("Filter"));
        for item_327 in var_326 {
            #[allow(unused_mut)]
            let mut entry_329 = list_328.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_329, item_327);
        }
        list_328.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_events(
    input: &crate::input::DescribeEventsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DescribeEvents", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_330 = writer.prefix("SourceIdentifier");
    if let Some(var_331) = &input.source_identifier {
        scope_330.string(var_331);
    }
    #[allow(unused_mut)]
    let mut scope_332 = writer.prefix("SourceType");
    if let Some(var_333) = &input.source_type {
        scope_332.string(var_333.as_str());
    }
    #[allow(unused_mut)]
    let mut scope_334 = writer.prefix("StartTime");
    if let Some(var_335) = &input.start_time {
        scope_334.instant(var_335, smithy_types::instant::Format::DateTime);
    }
    #[allow(unused_mut)]
    let mut scope_336 = writer.prefix("EndTime");
    if let Some(var_337) = &input.end_time {
        scope_336.instant(var_337, smithy_types::instant::Format::DateTime);
    }
    #[allow(unused_mut)]
    let mut scope_338 = writer.prefix("Duration");
    if let Some(var_339) = &input.duration {
        scope_338.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_339).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_340 = writer.prefix("EventCategories");
    if let Some(var_341) = &input.event_categories {
        let mut list_343 = scope_340.start_list(false, Some("EventCategory"));
        for item_342 in var_341 {
            #[allow(unused_mut)]
            let mut entry_344 = list_343.entry();
            entry_344.string(item_342);
        }
        list_343.finish();
    }
    #[allow(unused_mut)]
    let mut scope_345 = writer.prefix("Filters");
    if let Some(var_346) = &input.filters {
        let mut list_348 = scope_345.start_list(false, Some("Filter"));
        for item_347 in var_346 {
            #[allow(unused_mut)]
            let mut entry_349 = list_348.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_349, item_347);
        }
        list_348.finish();
    }
    #[allow(unused_mut)]
    let mut scope_350 = writer.prefix("MaxRecords");
    if let Some(var_351) = &input.max_records {
        scope_350.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_351).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_352 = writer.prefix("Marker");
    if let Some(var_353) = &input.marker {
        scope_352.string(var_353);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_event_subscriptions(
    input: &crate::input::DescribeEventSubscriptionsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeEventSubscriptions", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_354 = writer.prefix("SubscriptionName");
    if let Some(var_355) = &input.subscription_name {
        scope_354.string(var_355);
    }
    #[allow(unused_mut)]
    let mut scope_356 = writer.prefix("Filters");
    if let Some(var_357) = &input.filters {
        let mut list_359 = scope_356.start_list(false, Some("Filter"));
        for item_358 in var_357 {
            #[allow(unused_mut)]
            let mut entry_360 = list_359.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_360, item_358);
        }
        list_359.finish();
    }
    #[allow(unused_mut)]
    let mut scope_361 = writer.prefix("MaxRecords");
    if let Some(var_362) = &input.max_records {
        scope_361.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_362).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_363 = writer.prefix("Marker");
    if let Some(var_364) = &input.marker {
        scope_363.string(var_364);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_global_clusters(
    input: &crate::input::DescribeGlobalClustersInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeGlobalClusters", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_365 = writer.prefix("GlobalClusterIdentifier");
    if let Some(var_366) = &input.global_cluster_identifier {
        scope_365.string(var_366);
    }
    #[allow(unused_mut)]
    let mut scope_367 = writer.prefix("Filters");
    if let Some(var_368) = &input.filters {
        let mut list_370 = scope_367.start_list(false, Some("Filter"));
        for item_369 in var_368 {
            #[allow(unused_mut)]
            let mut entry_371 = list_370.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_371, item_369);
        }
        list_370.finish();
    }
    #[allow(unused_mut)]
    let mut scope_372 = writer.prefix("MaxRecords");
    if let Some(var_373) = &input.max_records {
        scope_372.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_373).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_374 = writer.prefix("Marker");
    if let Some(var_375) = &input.marker {
        scope_374.string(var_375);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_orderable_db_instance_options(
    input: &crate::input::DescribeOrderableDbInstanceOptionsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "DescribeOrderableDBInstanceOptions",
        "2014-10-31",
    );
    #[allow(unused_mut)]
    let mut scope_376 = writer.prefix("Engine");
    if let Some(var_377) = &input.engine {
        scope_376.string(var_377);
    }
    #[allow(unused_mut)]
    let mut scope_378 = writer.prefix("EngineVersion");
    if let Some(var_379) = &input.engine_version {
        scope_378.string(var_379);
    }
    #[allow(unused_mut)]
    let mut scope_380 = writer.prefix("DBInstanceClass");
    if let Some(var_381) = &input.db_instance_class {
        scope_380.string(var_381);
    }
    #[allow(unused_mut)]
    let mut scope_382 = writer.prefix("LicenseModel");
    if let Some(var_383) = &input.license_model {
        scope_382.string(var_383);
    }
    #[allow(unused_mut)]
    let mut scope_384 = writer.prefix("Vpc");
    if let Some(var_385) = &input.vpc {
        scope_384.boolean(*var_385);
    }
    #[allow(unused_mut)]
    let mut scope_386 = writer.prefix("Filters");
    if let Some(var_387) = &input.filters {
        let mut list_389 = scope_386.start_list(false, Some("Filter"));
        for item_388 in var_387 {
            #[allow(unused_mut)]
            let mut entry_390 = list_389.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_390, item_388);
        }
        list_389.finish();
    }
    #[allow(unused_mut)]
    let mut scope_391 = writer.prefix("MaxRecords");
    if let Some(var_392) = &input.max_records {
        scope_391.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_392).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_393 = writer.prefix("Marker");
    if let Some(var_394) = &input.marker {
        scope_393.string(var_394);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_pending_maintenance_actions(
    input: &crate::input::DescribePendingMaintenanceActionsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribePendingMaintenanceActions", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_395 = writer.prefix("ResourceIdentifier");
    if let Some(var_396) = &input.resource_identifier {
        scope_395.string(var_396);
    }
    #[allow(unused_mut)]
    let mut scope_397 = writer.prefix("Filters");
    if let Some(var_398) = &input.filters {
        let mut list_400 = scope_397.start_list(false, Some("Filter"));
        for item_399 in var_398 {
            #[allow(unused_mut)]
            let mut entry_401 = list_400.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_401, item_399);
        }
        list_400.finish();
    }
    #[allow(unused_mut)]
    let mut scope_402 = writer.prefix("Marker");
    if let Some(var_403) = &input.marker {
        scope_402.string(var_403);
    }
    #[allow(unused_mut)]
    let mut scope_404 = writer.prefix("MaxRecords");
    if let Some(var_405) = &input.max_records {
        scope_404.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_405).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_failover_db_cluster(
    input: &crate::input::FailoverDbClusterInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "FailoverDBCluster", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_406 = writer.prefix("DBClusterIdentifier");
    if let Some(var_407) = &input.db_cluster_identifier {
        scope_406.string(var_407);
    }
    #[allow(unused_mut)]
    let mut scope_408 = writer.prefix("TargetDBInstanceIdentifier");
    if let Some(var_409) = &input.target_db_instance_identifier {
        scope_408.string(var_409);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_tags_for_resource(
    input: &crate::input::ListTagsForResourceInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ListTagsForResource", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_410 = writer.prefix("ResourceName");
    if let Some(var_411) = &input.resource_name {
        scope_410.string(var_411);
    }
    #[allow(unused_mut)]
    let mut scope_412 = writer.prefix("Filters");
    if let Some(var_413) = &input.filters {
        let mut list_415 = scope_412.start_list(false, Some("Filter"));
        for item_414 in var_413 {
            #[allow(unused_mut)]
            let mut entry_416 = list_415.entry();
            crate::query_ser::serialize_structure_crate_model_filter(entry_416, item_414);
        }
        list_415.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_db_cluster(
    input: &crate::input::ModifyDbClusterInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ModifyDBCluster", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_417 = writer.prefix("DBClusterIdentifier");
    if let Some(var_418) = &input.db_cluster_identifier {
        scope_417.string(var_418);
    }
    #[allow(unused_mut)]
    let mut scope_419 = writer.prefix("NewDBClusterIdentifier");
    if let Some(var_420) = &input.new_db_cluster_identifier {
        scope_419.string(var_420);
    }
    #[allow(unused_mut)]
    let mut scope_421 = writer.prefix("ApplyImmediately");
    if input.apply_immediately {
        scope_421.boolean(input.apply_immediately);
    }
    #[allow(unused_mut)]
    let mut scope_422 = writer.prefix("BackupRetentionPeriod");
    if let Some(var_423) = &input.backup_retention_period {
        scope_422.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_423).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_424 = writer.prefix("DBClusterParameterGroupName");
    if let Some(var_425) = &input.db_cluster_parameter_group_name {
        scope_424.string(var_425);
    }
    #[allow(unused_mut)]
    let mut scope_426 = writer.prefix("VpcSecurityGroupIds");
    if let Some(var_427) = &input.vpc_security_group_ids {
        let mut list_429 = scope_426.start_list(false, Some("VpcSecurityGroupId"));
        for item_428 in var_427 {
            #[allow(unused_mut)]
            let mut entry_430 = list_429.entry();
            entry_430.string(item_428);
        }
        list_429.finish();
    }
    #[allow(unused_mut)]
    let mut scope_431 = writer.prefix("Port");
    if let Some(var_432) = &input.port {
        scope_431.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_432).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_433 = writer.prefix("MasterUserPassword");
    if let Some(var_434) = &input.master_user_password {
        scope_433.string(var_434);
    }
    #[allow(unused_mut)]
    let mut scope_435 = writer.prefix("PreferredBackupWindow");
    if let Some(var_436) = &input.preferred_backup_window {
        scope_435.string(var_436);
    }
    #[allow(unused_mut)]
    let mut scope_437 = writer.prefix("PreferredMaintenanceWindow");
    if let Some(var_438) = &input.preferred_maintenance_window {
        scope_437.string(var_438);
    }
    #[allow(unused_mut)]
    let mut scope_439 = writer.prefix("CloudwatchLogsExportConfiguration");
    if let Some(var_440) = &input.cloudwatch_logs_export_configuration {
        crate::query_ser::serialize_structure_crate_model_cloudwatch_logs_export_configuration(
            scope_439, var_440,
        );
    }
    #[allow(unused_mut)]
    let mut scope_441 = writer.prefix("EngineVersion");
    if let Some(var_442) = &input.engine_version {
        scope_441.string(var_442);
    }
    #[allow(unused_mut)]
    let mut scope_443 = writer.prefix("DeletionProtection");
    if let Some(var_444) = &input.deletion_protection {
        scope_443.boolean(*var_444);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_db_cluster_parameter_group(
    input: &crate::input::ModifyDbClusterParameterGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ModifyDBClusterParameterGroup", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_445 = writer.prefix("DBClusterParameterGroupName");
    if let Some(var_446) = &input.db_cluster_parameter_group_name {
        scope_445.string(var_446);
    }
    #[allow(unused_mut)]
    let mut scope_447 = writer.prefix("Parameters");
    if let Some(var_448) = &input.parameters {
        let mut list_450 = scope_447.start_list(false, Some("Parameter"));
        for item_449 in var_448 {
            #[allow(unused_mut)]
            let mut entry_451 = list_450.entry();
            crate::query_ser::serialize_structure_crate_model_parameter(entry_451, item_449);
        }
        list_450.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_db_cluster_snapshot_attribute(
    input: &crate::input::ModifyDbClusterSnapshotAttributeInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ModifyDBClusterSnapshotAttribute", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_452 = writer.prefix("DBClusterSnapshotIdentifier");
    if let Some(var_453) = &input.db_cluster_snapshot_identifier {
        scope_452.string(var_453);
    }
    #[allow(unused_mut)]
    let mut scope_454 = writer.prefix("AttributeName");
    if let Some(var_455) = &input.attribute_name {
        scope_454.string(var_455);
    }
    #[allow(unused_mut)]
    let mut scope_456 = writer.prefix("ValuesToAdd");
    if let Some(var_457) = &input.values_to_add {
        let mut list_459 = scope_456.start_list(false, Some("AttributeValue"));
        for item_458 in var_457 {
            #[allow(unused_mut)]
            let mut entry_460 = list_459.entry();
            entry_460.string(item_458);
        }
        list_459.finish();
    }
    #[allow(unused_mut)]
    let mut scope_461 = writer.prefix("ValuesToRemove");
    if let Some(var_462) = &input.values_to_remove {
        let mut list_464 = scope_461.start_list(false, Some("AttributeValue"));
        for item_463 in var_462 {
            #[allow(unused_mut)]
            let mut entry_465 = list_464.entry();
            entry_465.string(item_463);
        }
        list_464.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_db_instance(
    input: &crate::input::ModifyDbInstanceInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ModifyDBInstance", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_466 = writer.prefix("DBInstanceIdentifier");
    if let Some(var_467) = &input.db_instance_identifier {
        scope_466.string(var_467);
    }
    #[allow(unused_mut)]
    let mut scope_468 = writer.prefix("DBInstanceClass");
    if let Some(var_469) = &input.db_instance_class {
        scope_468.string(var_469);
    }
    #[allow(unused_mut)]
    let mut scope_470 = writer.prefix("ApplyImmediately");
    if input.apply_immediately {
        scope_470.boolean(input.apply_immediately);
    }
    #[allow(unused_mut)]
    let mut scope_471 = writer.prefix("PreferredMaintenanceWindow");
    if let Some(var_472) = &input.preferred_maintenance_window {
        scope_471.string(var_472);
    }
    #[allow(unused_mut)]
    let mut scope_473 = writer.prefix("AutoMinorVersionUpgrade");
    if let Some(var_474) = &input.auto_minor_version_upgrade {
        scope_473.boolean(*var_474);
    }
    #[allow(unused_mut)]
    let mut scope_475 = writer.prefix("NewDBInstanceIdentifier");
    if let Some(var_476) = &input.new_db_instance_identifier {
        scope_475.string(var_476);
    }
    #[allow(unused_mut)]
    let mut scope_477 = writer.prefix("CACertificateIdentifier");
    if let Some(var_478) = &input.ca_certificate_identifier {
        scope_477.string(var_478);
    }
    #[allow(unused_mut)]
    let mut scope_479 = writer.prefix("PromotionTier");
    if let Some(var_480) = &input.promotion_tier {
        scope_479.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_480).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_db_subnet_group(
    input: &crate::input::ModifyDbSubnetGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ModifyDBSubnetGroup", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_481 = writer.prefix("DBSubnetGroupName");
    if let Some(var_482) = &input.db_subnet_group_name {
        scope_481.string(var_482);
    }
    #[allow(unused_mut)]
    let mut scope_483 = writer.prefix("DBSubnetGroupDescription");
    if let Some(var_484) = &input.db_subnet_group_description {
        scope_483.string(var_484);
    }
    #[allow(unused_mut)]
    let mut scope_485 = writer.prefix("SubnetIds");
    if let Some(var_486) = &input.subnet_ids {
        let mut list_488 = scope_485.start_list(false, Some("SubnetIdentifier"));
        for item_487 in var_486 {
            #[allow(unused_mut)]
            let mut entry_489 = list_488.entry();
            entry_489.string(item_487);
        }
        list_488.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_event_subscription(
    input: &crate::input::ModifyEventSubscriptionInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ModifyEventSubscription", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_490 = writer.prefix("SubscriptionName");
    if let Some(var_491) = &input.subscription_name {
        scope_490.string(var_491);
    }
    #[allow(unused_mut)]
    let mut scope_492 = writer.prefix("SnsTopicArn");
    if let Some(var_493) = &input.sns_topic_arn {
        scope_492.string(var_493);
    }
    #[allow(unused_mut)]
    let mut scope_494 = writer.prefix("SourceType");
    if let Some(var_495) = &input.source_type {
        scope_494.string(var_495);
    }
    #[allow(unused_mut)]
    let mut scope_496 = writer.prefix("EventCategories");
    if let Some(var_497) = &input.event_categories {
        let mut list_499 = scope_496.start_list(false, Some("EventCategory"));
        for item_498 in var_497 {
            #[allow(unused_mut)]
            let mut entry_500 = list_499.entry();
            entry_500.string(item_498);
        }
        list_499.finish();
    }
    #[allow(unused_mut)]
    let mut scope_501 = writer.prefix("Enabled");
    if let Some(var_502) = &input.enabled {
        scope_501.boolean(*var_502);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_global_cluster(
    input: &crate::input::ModifyGlobalClusterInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ModifyGlobalCluster", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_503 = writer.prefix("GlobalClusterIdentifier");
    if let Some(var_504) = &input.global_cluster_identifier {
        scope_503.string(var_504);
    }
    #[allow(unused_mut)]
    let mut scope_505 = writer.prefix("NewGlobalClusterIdentifier");
    if let Some(var_506) = &input.new_global_cluster_identifier {
        scope_505.string(var_506);
    }
    #[allow(unused_mut)]
    let mut scope_507 = writer.prefix("DeletionProtection");
    if let Some(var_508) = &input.deletion_protection {
        scope_507.boolean(*var_508);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_reboot_db_instance(
    input: &crate::input::RebootDbInstanceInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "RebootDBInstance", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_509 = writer.prefix("DBInstanceIdentifier");
    if let Some(var_510) = &input.db_instance_identifier {
        scope_509.string(var_510);
    }
    #[allow(unused_mut)]
    let mut scope_511 = writer.prefix("ForceFailover");
    if let Some(var_512) = &input.force_failover {
        scope_511.boolean(*var_512);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_remove_from_global_cluster(
    input: &crate::input::RemoveFromGlobalClusterInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "RemoveFromGlobalCluster", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_513 = writer.prefix("GlobalClusterIdentifier");
    if let Some(var_514) = &input.global_cluster_identifier {
        scope_513.string(var_514);
    }
    #[allow(unused_mut)]
    let mut scope_515 = writer.prefix("DbClusterIdentifier");
    if let Some(var_516) = &input.db_cluster_identifier {
        scope_515.string(var_516);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_remove_source_identifier_from_subscription(
    input: &crate::input::RemoveSourceIdentifierFromSubscriptionInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "RemoveSourceIdentifierFromSubscription",
        "2014-10-31",
    );
    #[allow(unused_mut)]
    let mut scope_517 = writer.prefix("SubscriptionName");
    if let Some(var_518) = &input.subscription_name {
        scope_517.string(var_518);
    }
    #[allow(unused_mut)]
    let mut scope_519 = writer.prefix("SourceIdentifier");
    if let Some(var_520) = &input.source_identifier {
        scope_519.string(var_520);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_remove_tags_from_resource(
    input: &crate::input::RemoveTagsFromResourceInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "RemoveTagsFromResource", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_521 = writer.prefix("ResourceName");
    if let Some(var_522) = &input.resource_name {
        scope_521.string(var_522);
    }
    #[allow(unused_mut)]
    let mut scope_523 = writer.prefix("TagKeys");
    if let Some(var_524) = &input.tag_keys {
        let mut list_526 = scope_523.start_list(false, None);
        for item_525 in var_524 {
            #[allow(unused_mut)]
            let mut entry_527 = list_526.entry();
            entry_527.string(item_525);
        }
        list_526.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_reset_db_cluster_parameter_group(
    input: &crate::input::ResetDbClusterParameterGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ResetDBClusterParameterGroup", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_528 = writer.prefix("DBClusterParameterGroupName");
    if let Some(var_529) = &input.db_cluster_parameter_group_name {
        scope_528.string(var_529);
    }
    #[allow(unused_mut)]
    let mut scope_530 = writer.prefix("ResetAllParameters");
    if input.reset_all_parameters {
        scope_530.boolean(input.reset_all_parameters);
    }
    #[allow(unused_mut)]
    let mut scope_531 = writer.prefix("Parameters");
    if let Some(var_532) = &input.parameters {
        let mut list_534 = scope_531.start_list(false, Some("Parameter"));
        for item_533 in var_532 {
            #[allow(unused_mut)]
            let mut entry_535 = list_534.entry();
            crate::query_ser::serialize_structure_crate_model_parameter(entry_535, item_533);
        }
        list_534.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_restore_db_cluster_from_snapshot(
    input: &crate::input::RestoreDbClusterFromSnapshotInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "RestoreDBClusterFromSnapshot", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_536 = writer.prefix("AvailabilityZones");
    if let Some(var_537) = &input.availability_zones {
        let mut list_539 = scope_536.start_list(false, Some("AvailabilityZone"));
        for item_538 in var_537 {
            #[allow(unused_mut)]
            let mut entry_540 = list_539.entry();
            entry_540.string(item_538);
        }
        list_539.finish();
    }
    #[allow(unused_mut)]
    let mut scope_541 = writer.prefix("DBClusterIdentifier");
    if let Some(var_542) = &input.db_cluster_identifier {
        scope_541.string(var_542);
    }
    #[allow(unused_mut)]
    let mut scope_543 = writer.prefix("SnapshotIdentifier");
    if let Some(var_544) = &input.snapshot_identifier {
        scope_543.string(var_544);
    }
    #[allow(unused_mut)]
    let mut scope_545 = writer.prefix("Engine");
    if let Some(var_546) = &input.engine {
        scope_545.string(var_546);
    }
    #[allow(unused_mut)]
    let mut scope_547 = writer.prefix("EngineVersion");
    if let Some(var_548) = &input.engine_version {
        scope_547.string(var_548);
    }
    #[allow(unused_mut)]
    let mut scope_549 = writer.prefix("Port");
    if let Some(var_550) = &input.port {
        scope_549.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_550).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_551 = writer.prefix("DBSubnetGroupName");
    if let Some(var_552) = &input.db_subnet_group_name {
        scope_551.string(var_552);
    }
    #[allow(unused_mut)]
    let mut scope_553 = writer.prefix("VpcSecurityGroupIds");
    if let Some(var_554) = &input.vpc_security_group_ids {
        let mut list_556 = scope_553.start_list(false, Some("VpcSecurityGroupId"));
        for item_555 in var_554 {
            #[allow(unused_mut)]
            let mut entry_557 = list_556.entry();
            entry_557.string(item_555);
        }
        list_556.finish();
    }
    #[allow(unused_mut)]
    let mut scope_558 = writer.prefix("Tags");
    if let Some(var_559) = &input.tags {
        let mut list_561 = scope_558.start_list(false, Some("Tag"));
        for item_560 in var_559 {
            #[allow(unused_mut)]
            let mut entry_562 = list_561.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_562, item_560);
        }
        list_561.finish();
    }
    #[allow(unused_mut)]
    let mut scope_563 = writer.prefix("KmsKeyId");
    if let Some(var_564) = &input.kms_key_id {
        scope_563.string(var_564);
    }
    #[allow(unused_mut)]
    let mut scope_565 = writer.prefix("EnableCloudwatchLogsExports");
    if let Some(var_566) = &input.enable_cloudwatch_logs_exports {
        let mut list_568 = scope_565.start_list(false, None);
        for item_567 in var_566 {
            #[allow(unused_mut)]
            let mut entry_569 = list_568.entry();
            entry_569.string(item_567);
        }
        list_568.finish();
    }
    #[allow(unused_mut)]
    let mut scope_570 = writer.prefix("DeletionProtection");
    if let Some(var_571) = &input.deletion_protection {
        scope_570.boolean(*var_571);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_restore_db_cluster_to_point_in_time(
    input: &crate::input::RestoreDbClusterToPointInTimeInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "RestoreDBClusterToPointInTime", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_572 = writer.prefix("DBClusterIdentifier");
    if let Some(var_573) = &input.db_cluster_identifier {
        scope_572.string(var_573);
    }
    #[allow(unused_mut)]
    let mut scope_574 = writer.prefix("SourceDBClusterIdentifier");
    if let Some(var_575) = &input.source_db_cluster_identifier {
        scope_574.string(var_575);
    }
    #[allow(unused_mut)]
    let mut scope_576 = writer.prefix("RestoreToTime");
    if let Some(var_577) = &input.restore_to_time {
        scope_576.instant(var_577, smithy_types::instant::Format::DateTime);
    }
    #[allow(unused_mut)]
    let mut scope_578 = writer.prefix("UseLatestRestorableTime");
    if input.use_latest_restorable_time {
        scope_578.boolean(input.use_latest_restorable_time);
    }
    #[allow(unused_mut)]
    let mut scope_579 = writer.prefix("Port");
    if let Some(var_580) = &input.port {
        scope_579.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_580).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_581 = writer.prefix("DBSubnetGroupName");
    if let Some(var_582) = &input.db_subnet_group_name {
        scope_581.string(var_582);
    }
    #[allow(unused_mut)]
    let mut scope_583 = writer.prefix("VpcSecurityGroupIds");
    if let Some(var_584) = &input.vpc_security_group_ids {
        let mut list_586 = scope_583.start_list(false, Some("VpcSecurityGroupId"));
        for item_585 in var_584 {
            #[allow(unused_mut)]
            let mut entry_587 = list_586.entry();
            entry_587.string(item_585);
        }
        list_586.finish();
    }
    #[allow(unused_mut)]
    let mut scope_588 = writer.prefix("Tags");
    if let Some(var_589) = &input.tags {
        let mut list_591 = scope_588.start_list(false, Some("Tag"));
        for item_590 in var_589 {
            #[allow(unused_mut)]
            let mut entry_592 = list_591.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_592, item_590);
        }
        list_591.finish();
    }
    #[allow(unused_mut)]
    let mut scope_593 = writer.prefix("KmsKeyId");
    if let Some(var_594) = &input.kms_key_id {
        scope_593.string(var_594);
    }
    #[allow(unused_mut)]
    let mut scope_595 = writer.prefix("EnableCloudwatchLogsExports");
    if let Some(var_596) = &input.enable_cloudwatch_logs_exports {
        let mut list_598 = scope_595.start_list(false, None);
        for item_597 in var_596 {
            #[allow(unused_mut)]
            let mut entry_599 = list_598.entry();
            entry_599.string(item_597);
        }
        list_598.finish();
    }
    #[allow(unused_mut)]
    let mut scope_600 = writer.prefix("DeletionProtection");
    if let Some(var_601) = &input.deletion_protection {
        scope_600.boolean(*var_601);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_start_db_cluster(
    input: &crate::input::StartDbClusterInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "StartDBCluster", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_602 = writer.prefix("DBClusterIdentifier");
    if let Some(var_603) = &input.db_cluster_identifier {
        scope_602.string(var_603);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_stop_db_cluster(
    input: &crate::input::StopDbClusterInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "StopDBCluster", "2014-10-31");
    #[allow(unused_mut)]
    let mut scope_604 = writer.prefix("DBClusterIdentifier");
    if let Some(var_605) = &input.db_cluster_identifier {
        scope_604.string(var_605);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_source_identifier_to_subscription_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AddSourceIdentifierToSubscriptionOutput,
    crate::error::AddSourceIdentifierToSubscriptionError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::AddSourceIdentifierToSubscriptionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::AddSourceIdentifierToSubscriptionError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "SourceNotFound" => crate::error::AddSourceIdentifierToSubscriptionError {
            meta: generic,
            kind: crate::error::AddSourceIdentifierToSubscriptionErrorKind::SourceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::source_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_source_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AddSourceIdentifierToSubscriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SubscriptionNotFound" => crate::error::AddSourceIdentifierToSubscriptionError {
            meta: generic,
            kind:
                crate::error::AddSourceIdentifierToSubscriptionErrorKind::SubscriptionNotFoundFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::subscription_not_found_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_subscription_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AddSourceIdentifierToSubscriptionError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        _ => crate::error::AddSourceIdentifierToSubscriptionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_source_identifier_to_subscription_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AddSourceIdentifierToSubscriptionOutput,
    crate::error::AddSourceIdentifierToSubscriptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::add_source_identifier_to_subscription_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_add_source_identifier_to_subscription(response.body().as_ref(), output).map_err(crate::error::AddSourceIdentifierToSubscriptionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_tags_to_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AddTagsToResourceOutput, crate::error::AddTagsToResourceError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::AddTagsToResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AddTagsToResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::AddTagsToResourceError {
            meta: generic,
            kind: crate::error::AddTagsToResourceErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AddTagsToResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBInstanceNotFound" => crate::error::AddTagsToResourceError {
            meta: generic,
            kind: crate::error::AddTagsToResourceErrorKind::DbInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AddTagsToResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSnapshotNotFound" => crate::error::AddTagsToResourceError {
            meta: generic,
            kind: crate::error::AddTagsToResourceErrorKind::DbSnapshotNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AddTagsToResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::AddTagsToResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_tags_to_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AddTagsToResourceOutput, crate::error::AddTagsToResourceError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::add_tags_to_resource_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_apply_pending_maintenance_action_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ApplyPendingMaintenanceActionOutput,
    crate::error::ApplyPendingMaintenanceActionError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ApplyPendingMaintenanceActionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ApplyPendingMaintenanceActionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidDBClusterStateFault" => crate::error::ApplyPendingMaintenanceActionError {
            meta: generic,
            kind: crate::error::ApplyPendingMaintenanceActionErrorKind::InvalidDbClusterStateFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_db_cluster_state_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ApplyPendingMaintenanceActionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "InvalidDBInstanceState" => crate::error::ApplyPendingMaintenanceActionError {
            meta: generic,
            kind: crate::error::ApplyPendingMaintenanceActionErrorKind::InvalidDbInstanceStateFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_db_instance_state_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ApplyPendingMaintenanceActionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "ResourceNotFoundFault" => crate::error::ApplyPendingMaintenanceActionError {
            meta: generic,
            kind: crate::error::ApplyPendingMaintenanceActionErrorKind::ResourceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_resource_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ApplyPendingMaintenanceActionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ApplyPendingMaintenanceActionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_apply_pending_maintenance_action_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ApplyPendingMaintenanceActionOutput,
    crate::error::ApplyPendingMaintenanceActionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::apply_pending_maintenance_action_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_apply_pending_maintenance_action(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ApplyPendingMaintenanceActionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_db_cluster_parameter_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CopyDbClusterParameterGroupOutput,
    crate::error::CopyDBClusterParameterGroupError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CopyDBClusterParameterGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CopyDBClusterParameterGroupError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBParameterGroupAlreadyExists" => crate::error::CopyDBClusterParameterGroupError { meta: generic, kind: crate::error::CopyDBClusterParameterGroupErrorKind::DbParameterGroupAlreadyExistsFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_parameter_group_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBClusterParameterGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBParameterGroupNotFound" => crate::error::CopyDBClusterParameterGroupError { meta: generic, kind: crate::error::CopyDBClusterParameterGroupErrorKind::DbParameterGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBClusterParameterGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBParameterGroupQuotaExceeded" => crate::error::CopyDBClusterParameterGroupError { meta: generic, kind: crate::error::CopyDBClusterParameterGroupErrorKind::DbParameterGroupQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_parameter_group_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBClusterParameterGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CopyDBClusterParameterGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_db_cluster_parameter_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CopyDbClusterParameterGroupOutput,
    crate::error::CopyDBClusterParameterGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::copy_db_cluster_parameter_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_copy_db_cluster_parameter_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CopyDBClusterParameterGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_db_cluster_snapshot_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CopyDbClusterSnapshotOutput,
    crate::error::CopyDBClusterSnapshotError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CopyDBClusterSnapshotError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CopyDBClusterSnapshotError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterSnapshotAlreadyExistsFault" => crate::error::CopyDBClusterSnapshotError {
            meta: generic,
            kind: crate::error::CopyDBClusterSnapshotErrorKind::DbClusterSnapshotAlreadyExistsFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::db_cluster_snapshot_already_exists_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_db_cluster_snapshot_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBClusterSnapshotError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "DBClusterSnapshotNotFoundFault" => crate::error::CopyDBClusterSnapshotError {
            meta: generic,
            kind: crate::error::CopyDBClusterSnapshotErrorKind::DbClusterSnapshotNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_cluster_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBClusterSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterSnapshotStateFault" => {
            crate::error::CopyDBClusterSnapshotError {
                meta: generic,
                kind:
                    crate::error::CopyDBClusterSnapshotErrorKind::InvalidDbClusterSnapshotStateFault(
                        {
                            #[allow(unused_mut)]
                            let mut tmp = {
                                #[allow(unused_mut)]let mut output = crate::error::invalid_db_cluster_snapshot_state_fault::Builder::default();
                                let _ = response;
                                output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBClusterSnapshotError::unhandled)?;
                                output.build()
                            };
                            if (&tmp.message).is_none() {
                                tmp.message = _error_message;
                            }
                            tmp
                        },
                    ),
            }
        }
        "InvalidDBClusterStateFault" => crate::error::CopyDBClusterSnapshotError {
            meta: generic,
            kind: crate::error::CopyDBClusterSnapshotErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBClusterSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "KMSKeyNotAccessibleFault" => crate::error::CopyDBClusterSnapshotError {
            meta: generic,
            kind: crate::error::CopyDBClusterSnapshotErrorKind::KmsKeyNotAccessibleFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_kms_key_not_accessible_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBClusterSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SnapshotQuotaExceeded" => crate::error::CopyDBClusterSnapshotError {
            meta: generic,
            kind: crate::error::CopyDBClusterSnapshotErrorKind::SnapshotQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::snapshot_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_snapshot_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyDBClusterSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CopyDBClusterSnapshotError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_db_cluster_snapshot_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CopyDbClusterSnapshotOutput,
    crate::error::CopyDBClusterSnapshotError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::copy_db_cluster_snapshot_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_copy_db_cluster_snapshot(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CopyDBClusterSnapshotError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDbClusterOutput, crate::error::CreateDBClusterError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateDBClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateDBClusterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterAlreadyExistsFault" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::DbClusterAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_cluster_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBClusterNotFoundFault" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBClusterParameterGroupNotFound" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::DbClusterParameterGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_cluster_parameter_group_not_found_fault::Builder::default(
                        );
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBClusterQuotaExceededFault" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::DbClusterQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_cluster_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBInstanceNotFound" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::DbInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSubnetGroupDoesNotCoverEnoughAZs" => {
            crate::error::CreateDBClusterError {
                meta: generic,
                kind: crate::error::CreateDBClusterErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::db_subnet_group_does_not_cover_enough_a_zs::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_does_not_cover_enough_a_zs_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "DBSubnetGroupNotFoundFault" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::DbSubnetGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_subnet_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "GlobalClusterNotFoundFault" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::GlobalClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::global_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_global_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InsufficientStorageClusterCapacity" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::InsufficientStorageClusterCapacityFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::insufficient_storage_cluster_capacity_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_insufficient_storage_cluster_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "InvalidDBClusterStateFault" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBInstanceState" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::InvalidDbInstanceStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_instance_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBSubnetGroupStateFault" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::InvalidDbSubnetGroupStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_subnet_group_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_subnet_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidGlobalClusterStateFault" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::InvalidGlobalClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_global_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_global_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidSubnet" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::InvalidSubnet({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_subnet::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_subnet_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidVPCNetworkStateFault" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::InvalidVpcNetworkStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_vpc_network_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_vpc_network_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "KMSKeyNotAccessibleFault" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::KmsKeyNotAccessibleFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_kms_key_not_accessible_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "StorageQuotaExceeded" => crate::error::CreateDBClusterError {
            meta: generic,
            kind: crate::error::CreateDBClusterErrorKind::StorageQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::storage_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_storage_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateDBClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDbClusterOutput, crate::error::CreateDBClusterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_db_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_db_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDBClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_cluster_parameter_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDbClusterParameterGroupOutput,
    crate::error::CreateDBClusterParameterGroupError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateDBClusterParameterGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateDBClusterParameterGroupError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBParameterGroupAlreadyExists" => crate::error::CreateDBClusterParameterGroupError { meta: generic, kind: crate::error::CreateDBClusterParameterGroupErrorKind::DbParameterGroupAlreadyExistsFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_parameter_group_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterParameterGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBParameterGroupQuotaExceeded" => crate::error::CreateDBClusterParameterGroupError { meta: generic, kind: crate::error::CreateDBClusterParameterGroupErrorKind::DbParameterGroupQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_parameter_group_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterParameterGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateDBClusterParameterGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_cluster_parameter_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDbClusterParameterGroupOutput,
    crate::error::CreateDBClusterParameterGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_db_cluster_parameter_group_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_create_db_cluster_parameter_group(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::CreateDBClusterParameterGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_cluster_snapshot_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDbClusterSnapshotOutput,
    crate::error::CreateDBClusterSnapshotError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateDBClusterSnapshotError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateDBClusterSnapshotError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::CreateDBClusterSnapshotError {
            meta: generic,
            kind: crate::error::CreateDBClusterSnapshotErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBClusterSnapshotAlreadyExistsFault" => crate::error::CreateDBClusterSnapshotError {
            meta: generic,
            kind:
                crate::error::CreateDBClusterSnapshotErrorKind::DbClusterSnapshotAlreadyExistsFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::db_cluster_snapshot_already_exists_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_db_cluster_snapshot_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterSnapshotError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "InvalidDBClusterSnapshotStateFault" => crate::error::CreateDBClusterSnapshotError {
            meta: generic,
            kind:
                crate::error::CreateDBClusterSnapshotErrorKind::InvalidDbClusterSnapshotStateFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::invalid_db_cluster_snapshot_state_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterSnapshotError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "InvalidDBClusterStateFault" => crate::error::CreateDBClusterSnapshotError {
            meta: generic,
            kind: crate::error::CreateDBClusterSnapshotErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SnapshotQuotaExceeded" => crate::error::CreateDBClusterSnapshotError {
            meta: generic,
            kind: crate::error::CreateDBClusterSnapshotErrorKind::SnapshotQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::snapshot_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_snapshot_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBClusterSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateDBClusterSnapshotError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_cluster_snapshot_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDbClusterSnapshotOutput,
    crate::error::CreateDBClusterSnapshotError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_db_cluster_snapshot_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_db_cluster_snapshot(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDBClusterSnapshotError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDbInstanceOutput, crate::error::CreateDBInstanceError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateDBInstanceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateDBInstanceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AuthorizationNotFound" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::AuthorizationNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::authorization_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_authorization_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBClusterNotFoundFault" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBInstanceAlreadyExists" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::DbInstanceAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_instance_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBParameterGroupNotFound" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::DbParameterGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSecurityGroupNotFound" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::DbSecurityGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_security_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_security_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSubnetGroupDoesNotCoverEnoughAZs" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_subnet_group_does_not_cover_enough_a_zs::Builder::default(
                        );
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_does_not_cover_enough_a_zs_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSubnetGroupNotFoundFault" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::DbSubnetGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_subnet_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InstanceQuotaExceeded" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::InstanceQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::instance_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_instance_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InsufficientDBInstanceCapacity" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::InsufficientDbInstanceCapacityFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::insufficient_db_instance_capacity_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_insufficient_db_instance_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidSubnet" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::InvalidSubnet({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_subnet::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_subnet_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidVPCNetworkStateFault" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::InvalidVpcNetworkStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_vpc_network_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_vpc_network_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "KMSKeyNotAccessibleFault" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::KmsKeyNotAccessibleFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_kms_key_not_accessible_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "StorageQuotaExceeded" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::StorageQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::storage_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_storage_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "StorageTypeNotSupported" => crate::error::CreateDBInstanceError {
            meta: generic,
            kind: crate::error::CreateDBInstanceErrorKind::StorageTypeNotSupportedFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::storage_type_not_supported_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_storage_type_not_supported_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateDBInstanceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDbInstanceOutput, crate::error::CreateDBInstanceError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_db_instance_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_db_instance(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDBInstanceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_subnet_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDbSubnetGroupOutput,
    crate::error::CreateDBSubnetGroupError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateDBSubnetGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateDBSubnetGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBSubnetGroupAlreadyExists" => crate::error::CreateDBSubnetGroupError {
            meta: generic,
            kind: crate::error::CreateDBSubnetGroupErrorKind::DbSubnetGroupAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_subnet_group_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBSubnetGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSubnetGroupDoesNotCoverEnoughAZs" => crate::error::CreateDBSubnetGroupError {
            meta: generic,
            kind: crate::error::CreateDBSubnetGroupErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_subnet_group_does_not_cover_enough_a_zs::Builder::default(
                        );
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_does_not_cover_enough_a_zs_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBSubnetGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSubnetGroupQuotaExceeded" => crate::error::CreateDBSubnetGroupError {
            meta: generic,
            kind: crate::error::CreateDBSubnetGroupErrorKind::DbSubnetGroupQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_subnet_group_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBSubnetGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSubnetQuotaExceededFault" => crate::error::CreateDBSubnetGroupError {
            meta: generic,
            kind: crate::error::CreateDBSubnetGroupErrorKind::DbSubnetQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_subnet_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateDBSubnetGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidSubnet" => crate::error::CreateDBSubnetGroupError {
            meta: generic,
            kind: crate::error::CreateDBSubnetGroupErrorKind::InvalidSubnet({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_subnet::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_subnet_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateDBSubnetGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateDBSubnetGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_db_subnet_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDbSubnetGroupOutput,
    crate::error::CreateDBSubnetGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_db_subnet_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_db_subnet_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDBSubnetGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_event_subscription_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateEventSubscriptionOutput,
    crate::error::CreateEventSubscriptionError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateEventSubscriptionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EventSubscriptionQuotaExceeded" => crate::error::CreateEventSubscriptionError {
            meta: generic,
            kind:
                crate::error::CreateEventSubscriptionErrorKind::EventSubscriptionQuotaExceededFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::event_subscription_quota_exceeded_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_event_subscription_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "SNSInvalidTopic" => crate::error::CreateEventSubscriptionError {
            meta: generic,
            kind: crate::error::CreateEventSubscriptionErrorKind::SnsInvalidTopicFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::sns_invalid_topic_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_sns_invalid_topic_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SNSNoAuthorization" => crate::error::CreateEventSubscriptionError {
            meta: generic,
            kind: crate::error::CreateEventSubscriptionErrorKind::SnsNoAuthorizationFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::sns_no_authorization_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_sns_no_authorization_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SNSTopicArnNotFound" => crate::error::CreateEventSubscriptionError {
            meta: generic,
            kind: crate::error::CreateEventSubscriptionErrorKind::SnsTopicArnNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::sns_topic_arn_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_sns_topic_arn_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SourceNotFound" => crate::error::CreateEventSubscriptionError {
            meta: generic,
            kind: crate::error::CreateEventSubscriptionErrorKind::SourceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::source_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_source_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SubscriptionAlreadyExist" => crate::error::CreateEventSubscriptionError {
            meta: generic,
            kind: crate::error::CreateEventSubscriptionErrorKind::SubscriptionAlreadyExistFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::subscription_already_exist_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_subscription_already_exist_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SubscriptionCategoryNotFound" => crate::error::CreateEventSubscriptionError {
            meta: generic,
            kind: crate::error::CreateEventSubscriptionErrorKind::SubscriptionCategoryNotFoundFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::subscription_category_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_subscription_category_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::CreateEventSubscriptionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_event_subscription_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateEventSubscriptionOutput,
    crate::error::CreateEventSubscriptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_event_subscription_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_event_subscription(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_global_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateGlobalClusterOutput,
    crate::error::CreateGlobalClusterError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateGlobalClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateGlobalClusterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::CreateGlobalClusterError {
            meta: generic,
            kind: crate::error::CreateGlobalClusterErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateGlobalClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "GlobalClusterAlreadyExistsFault" => crate::error::CreateGlobalClusterError {
            meta: generic,
            kind: crate::error::CreateGlobalClusterErrorKind::GlobalClusterAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::global_cluster_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_global_cluster_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateGlobalClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "GlobalClusterQuotaExceededFault" => crate::error::CreateGlobalClusterError {
            meta: generic,
            kind: crate::error::CreateGlobalClusterErrorKind::GlobalClusterQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::global_cluster_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_global_cluster_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateGlobalClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::CreateGlobalClusterError {
            meta: generic,
            kind: crate::error::CreateGlobalClusterErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateGlobalClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateGlobalClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_global_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateGlobalClusterOutput,
    crate::error::CreateGlobalClusterError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_global_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_global_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateGlobalClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDbClusterOutput, crate::error::DeleteDBClusterError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteDBClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteDBClusterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::DeleteDBClusterError {
            meta: generic,
            kind: crate::error::DeleteDBClusterErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBClusterSnapshotAlreadyExistsFault" => crate::error::DeleteDBClusterError {
            meta: generic,
            kind: crate::error::DeleteDBClusterErrorKind::DbClusterSnapshotAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_cluster_snapshot_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_snapshot_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterSnapshotStateFault" => crate::error::DeleteDBClusterError {
            meta: generic,
            kind: crate::error::DeleteDBClusterErrorKind::InvalidDbClusterSnapshotStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_snapshot_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::DeleteDBClusterError {
            meta: generic,
            kind: crate::error::DeleteDBClusterErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SnapshotQuotaExceeded" => crate::error::DeleteDBClusterError {
            meta: generic,
            kind: crate::error::DeleteDBClusterErrorKind::SnapshotQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::snapshot_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_snapshot_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteDBClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDbClusterOutput, crate::error::DeleteDBClusterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_db_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_db_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteDBClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_cluster_parameter_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDbClusterParameterGroupOutput,
    crate::error::DeleteDBClusterParameterGroupError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteDBClusterParameterGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteDBClusterParameterGroupError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBParameterGroupNotFound" => crate::error::DeleteDBClusterParameterGroupError { meta: generic, kind: crate::error::DeleteDBClusterParameterGroupErrorKind::DbParameterGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBClusterParameterGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidDBParameterGroupState" => crate::error::DeleteDBClusterParameterGroupError { meta: generic, kind: crate::error::DeleteDBClusterParameterGroupErrorKind::InvalidDbParameterGroupStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_db_parameter_group_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_parameter_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBClusterParameterGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteDBClusterParameterGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_cluster_parameter_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDbClusterParameterGroupOutput,
    crate::error::DeleteDBClusterParameterGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_db_cluster_parameter_group_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_cluster_snapshot_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDbClusterSnapshotOutput,
    crate::error::DeleteDBClusterSnapshotError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteDBClusterSnapshotError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteDBClusterSnapshotError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterSnapshotNotFoundFault" => crate::error::DeleteDBClusterSnapshotError {
            meta: generic,
            kind: crate::error::DeleteDBClusterSnapshotErrorKind::DbClusterSnapshotNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_cluster_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBClusterSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterSnapshotStateFault" => crate::error::DeleteDBClusterSnapshotError {
            meta: generic,
            kind:
                crate::error::DeleteDBClusterSnapshotErrorKind::InvalidDbClusterSnapshotStateFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::invalid_db_cluster_snapshot_state_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBClusterSnapshotError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        _ => crate::error::DeleteDBClusterSnapshotError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_cluster_snapshot_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDbClusterSnapshotOutput,
    crate::error::DeleteDBClusterSnapshotError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_db_cluster_snapshot_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_db_cluster_snapshot(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteDBClusterSnapshotError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDbInstanceOutput, crate::error::DeleteDBInstanceError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteDBInstanceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteDBInstanceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBInstanceNotFound" => crate::error::DeleteDBInstanceError {
            meta: generic,
            kind: crate::error::DeleteDBInstanceErrorKind::DbInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSnapshotAlreadyExists" => crate::error::DeleteDBInstanceError {
            meta: generic,
            kind: crate::error::DeleteDBInstanceErrorKind::DbSnapshotAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_snapshot_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_snapshot_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::DeleteDBInstanceError {
            meta: generic,
            kind: crate::error::DeleteDBInstanceErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBInstanceState" => crate::error::DeleteDBInstanceError {
            meta: generic,
            kind: crate::error::DeleteDBInstanceErrorKind::InvalidDbInstanceStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_instance_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SnapshotQuotaExceeded" => crate::error::DeleteDBInstanceError {
            meta: generic,
            kind: crate::error::DeleteDBInstanceErrorKind::SnapshotQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::snapshot_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_snapshot_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteDBInstanceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDbInstanceOutput, crate::error::DeleteDBInstanceError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_db_instance_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_db_instance(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteDBInstanceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_subnet_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDbSubnetGroupOutput,
    crate::error::DeleteDBSubnetGroupError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteDBSubnetGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteDBSubnetGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBSubnetGroupNotFoundFault" => crate::error::DeleteDBSubnetGroupError {
            meta: generic,
            kind: crate::error::DeleteDBSubnetGroupErrorKind::DbSubnetGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_subnet_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBSubnetGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBSubnetGroupStateFault" => crate::error::DeleteDBSubnetGroupError {
            meta: generic,
            kind: crate::error::DeleteDBSubnetGroupErrorKind::InvalidDbSubnetGroupStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_subnet_group_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_subnet_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBSubnetGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBSubnetStateFault" => crate::error::DeleteDBSubnetGroupError {
            meta: generic,
            kind: crate::error::DeleteDBSubnetGroupErrorKind::InvalidDbSubnetStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_subnet_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_subnet_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteDBSubnetGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteDBSubnetGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_db_subnet_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDbSubnetGroupOutput,
    crate::error::DeleteDBSubnetGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_db_subnet_group_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_event_subscription_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteEventSubscriptionOutput,
    crate::error::DeleteEventSubscriptionError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteEventSubscriptionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteEventSubscriptionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidEventSubscriptionState" => crate::error::DeleteEventSubscriptionError {
            meta: generic,
            kind:
                crate::error::DeleteEventSubscriptionErrorKind::InvalidEventSubscriptionStateFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::invalid_event_subscription_state_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_invalid_event_subscription_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteEventSubscriptionError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "SubscriptionNotFound" => crate::error::DeleteEventSubscriptionError {
            meta: generic,
            kind: crate::error::DeleteEventSubscriptionErrorKind::SubscriptionNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::subscription_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_subscription_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteEventSubscriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteEventSubscriptionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_event_subscription_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteEventSubscriptionOutput,
    crate::error::DeleteEventSubscriptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_event_subscription_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_event_subscription(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteEventSubscriptionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_global_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteGlobalClusterOutput,
    crate::error::DeleteGlobalClusterError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteGlobalClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteGlobalClusterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "GlobalClusterNotFoundFault" => crate::error::DeleteGlobalClusterError {
            meta: generic,
            kind: crate::error::DeleteGlobalClusterErrorKind::GlobalClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::global_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_global_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteGlobalClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidGlobalClusterStateFault" => crate::error::DeleteGlobalClusterError {
            meta: generic,
            kind: crate::error::DeleteGlobalClusterErrorKind::InvalidGlobalClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_global_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_global_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteGlobalClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteGlobalClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_global_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteGlobalClusterOutput,
    crate::error::DeleteGlobalClusterError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_global_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_global_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteGlobalClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_certificates_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeCertificatesOutput,
    crate::error::DescribeCertificatesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeCertificatesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeCertificatesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CertificateNotFound" => crate::error::DescribeCertificatesError {
            meta: generic,
            kind: crate::error::DescribeCertificatesErrorKind::CertificateNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::certificate_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_certificate_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeCertificatesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeCertificatesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_certificates_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeCertificatesOutput,
    crate::error::DescribeCertificatesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_certificates_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_certificates(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeCertificatesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_cluster_parameter_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbClusterParameterGroupsOutput,
    crate::error::DescribeDBClusterParameterGroupsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDBClusterParameterGroupsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDBClusterParameterGroupsError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBParameterGroupNotFound" => crate::error::DescribeDBClusterParameterGroupsError { meta: generic, kind: crate::error::DescribeDBClusterParameterGroupsErrorKind::DbParameterGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBClusterParameterGroupsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeDBClusterParameterGroupsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_cluster_parameter_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbClusterParameterGroupsOutput,
    crate::error::DescribeDBClusterParameterGroupsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_db_cluster_parameter_groups_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_db_cluster_parameter_groups(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeDBClusterParameterGroupsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_cluster_parameters_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbClusterParametersOutput,
    crate::error::DescribeDBClusterParametersError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDBClusterParametersError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDBClusterParametersError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBParameterGroupNotFound" => crate::error::DescribeDBClusterParametersError {
            meta: generic,
            kind: crate::error::DescribeDBClusterParametersErrorKind::DbParameterGroupNotFoundFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::db_parameter_group_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBClusterParametersError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::DescribeDBClusterParametersError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_cluster_parameters_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbClusterParametersOutput,
    crate::error::DescribeDBClusterParametersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_cluster_parameters_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_db_cluster_parameters(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBClusterParametersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_clusters_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbClustersOutput,
    crate::error::DescribeDBClustersError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDBClustersError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeDBClustersError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::DescribeDBClustersError {
            meta: generic,
            kind: crate::error::DescribeDBClustersErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBClustersError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeDBClustersError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_clusters_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbClustersOutput,
    crate::error::DescribeDBClustersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_clusters_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_db_clusters(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBClustersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_cluster_snapshot_attributes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbClusterSnapshotAttributesOutput,
    crate::error::DescribeDBClusterSnapshotAttributesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDBClusterSnapshotAttributesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDBClusterSnapshotAttributesError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterSnapshotNotFoundFault" => crate::error::DescribeDBClusterSnapshotAttributesError { meta: generic, kind: crate::error::DescribeDBClusterSnapshotAttributesErrorKind::DbClusterSnapshotNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_cluster_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBClusterSnapshotAttributesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeDBClusterSnapshotAttributesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_cluster_snapshot_attributes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbClusterSnapshotAttributesOutput,
    crate::error::DescribeDBClusterSnapshotAttributesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_db_cluster_snapshot_attributes_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_db_cluster_snapshot_attributes(response.body().as_ref(), output).map_err(crate::error::DescribeDBClusterSnapshotAttributesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_cluster_snapshots_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbClusterSnapshotsOutput,
    crate::error::DescribeDBClusterSnapshotsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDBClusterSnapshotsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDBClusterSnapshotsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterSnapshotNotFoundFault" => crate::error::DescribeDBClusterSnapshotsError {
            meta: generic,
            kind: crate::error::DescribeDBClusterSnapshotsErrorKind::DbClusterSnapshotNotFoundFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::db_cluster_snapshot_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_db_cluster_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBClusterSnapshotsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::DescribeDBClusterSnapshotsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_cluster_snapshots_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbClusterSnapshotsOutput,
    crate::error::DescribeDBClusterSnapshotsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_cluster_snapshots_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_db_cluster_snapshots(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBClusterSnapshotsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_engine_versions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbEngineVersionsOutput,
    crate::error::DescribeDBEngineVersionsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDBEngineVersionsError::unhandled)?;
    Err(crate::error::DescribeDBEngineVersionsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_engine_versions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbEngineVersionsOutput,
    crate::error::DescribeDBEngineVersionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_engine_versions_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_db_engine_versions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBEngineVersionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_instances_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbInstancesOutput,
    crate::error::DescribeDBInstancesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDBInstancesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeDBInstancesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBInstanceNotFound" => crate::error::DescribeDBInstancesError {
            meta: generic,
            kind: crate::error::DescribeDBInstancesErrorKind::DbInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBInstancesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeDBInstancesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_instances_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbInstancesOutput,
    crate::error::DescribeDBInstancesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_db_instances(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBInstancesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_subnet_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbSubnetGroupsOutput,
    crate::error::DescribeDBSubnetGroupsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDBSubnetGroupsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDBSubnetGroupsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBSubnetGroupNotFoundFault" => crate::error::DescribeDBSubnetGroupsError {
            meta: generic,
            kind: crate::error::DescribeDBSubnetGroupsErrorKind::DbSubnetGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_subnet_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDBSubnetGroupsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeDBSubnetGroupsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_db_subnet_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDbSubnetGroupsOutput,
    crate::error::DescribeDBSubnetGroupsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_db_subnet_groups_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_db_subnet_groups(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDBSubnetGroupsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_engine_default_cluster_parameters_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEngineDefaultClusterParametersOutput,
    crate::error::DescribeEngineDefaultClusterParametersError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeEngineDefaultClusterParametersError::unhandled)?;
    Err(crate::error::DescribeEngineDefaultClusterParametersError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_engine_default_cluster_parameters_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEngineDefaultClusterParametersOutput,
    crate::error::DescribeEngineDefaultClusterParametersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_engine_default_cluster_parameters_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_engine_default_cluster_parameters(response.body().as_ref(), output).map_err(crate::error::DescribeEngineDefaultClusterParametersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_event_categories_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEventCategoriesOutput,
    crate::error::DescribeEventCategoriesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeEventCategoriesError::unhandled)?;
    Err(crate::error::DescribeEventCategoriesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_event_categories_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEventCategoriesOutput,
    crate::error::DescribeEventCategoriesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_event_categories_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_event_categories(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeEventCategoriesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_events_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeEventsOutput, crate::error::DescribeEventsError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeEventsError::unhandled)?;
    Err(crate::error::DescribeEventsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_events_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeEventsOutput, crate::error::DescribeEventsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_events_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_events(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeEventsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_event_subscriptions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEventSubscriptionsOutput,
    crate::error::DescribeEventSubscriptionsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeEventSubscriptionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeEventSubscriptionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "SubscriptionNotFound" => crate::error::DescribeEventSubscriptionsError {
            meta: generic,
            kind: crate::error::DescribeEventSubscriptionsErrorKind::SubscriptionNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::subscription_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_subscription_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeEventSubscriptionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeEventSubscriptionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_event_subscriptions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEventSubscriptionsOutput,
    crate::error::DescribeEventSubscriptionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_event_subscriptions_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_event_subscriptions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeEventSubscriptionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_global_clusters_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeGlobalClustersOutput,
    crate::error::DescribeGlobalClustersError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeGlobalClustersError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeGlobalClustersError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "GlobalClusterNotFoundFault" => crate::error::DescribeGlobalClustersError {
            meta: generic,
            kind: crate::error::DescribeGlobalClustersErrorKind::GlobalClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::global_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_global_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeGlobalClustersError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeGlobalClustersError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_global_clusters_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeGlobalClustersOutput,
    crate::error::DescribeGlobalClustersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_global_clusters_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_global_clusters(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeGlobalClustersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_orderable_db_instance_options_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeOrderableDbInstanceOptionsOutput,
    crate::error::DescribeOrderableDBInstanceOptionsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeOrderableDBInstanceOptionsError::unhandled)?;
    Err(crate::error::DescribeOrderableDBInstanceOptionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_orderable_db_instance_options_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeOrderableDbInstanceOptionsOutput,
    crate::error::DescribeOrderableDBInstanceOptionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_orderable_db_instance_options_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_orderable_db_instance_options(response.body().as_ref(), output).map_err(crate::error::DescribeOrderableDBInstanceOptionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_pending_maintenance_actions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePendingMaintenanceActionsOutput,
    crate::error::DescribePendingMaintenanceActionsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribePendingMaintenanceActionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribePendingMaintenanceActionsError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundFault" => crate::error::DescribePendingMaintenanceActionsError {
            meta: generic,
            kind: crate::error::DescribePendingMaintenanceActionsErrorKind::ResourceNotFoundFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::resource_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_resource_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribePendingMaintenanceActionsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::DescribePendingMaintenanceActionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_pending_maintenance_actions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePendingMaintenanceActionsOutput,
    crate::error::DescribePendingMaintenanceActionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_pending_maintenance_actions_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_pending_maintenance_actions(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribePendingMaintenanceActionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_failover_db_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::FailoverDbClusterOutput, crate::error::FailoverDBClusterError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::FailoverDBClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::FailoverDBClusterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::FailoverDBClusterError {
            meta: generic,
            kind: crate::error::FailoverDBClusterErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::FailoverDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::FailoverDBClusterError {
            meta: generic,
            kind: crate::error::FailoverDBClusterErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::FailoverDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBInstanceState" => crate::error::FailoverDBClusterError {
            meta: generic,
            kind: crate::error::FailoverDBClusterErrorKind::InvalidDbInstanceStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_instance_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::FailoverDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::FailoverDBClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_failover_db_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::FailoverDbClusterOutput, crate::error::FailoverDBClusterError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::failover_db_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_failover_db_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::FailoverDBClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTagsForResourceOutput,
    crate::error::ListTagsForResourceError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListTagsForResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListTagsForResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::ListTagsForResourceError {
            meta: generic,
            kind: crate::error::ListTagsForResourceErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBInstanceNotFound" => crate::error::ListTagsForResourceError {
            meta: generic,
            kind: crate::error::ListTagsForResourceErrorKind::DbInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSnapshotNotFound" => crate::error::ListTagsForResourceError {
            meta: generic,
            kind: crate::error::ListTagsForResourceErrorKind::DbSnapshotNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListTagsForResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTagsForResourceOutput,
    crate::error::ListTagsForResourceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_tags_for_resource_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_tags_for_resource(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListTagsForResourceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyDbClusterOutput, crate::error::ModifyDBClusterError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyDBClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ModifyDBClusterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterAlreadyExistsFault" => crate::error::ModifyDBClusterError {
            meta: generic,
            kind: crate::error::ModifyDBClusterErrorKind::DbClusterAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_cluster_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBClusterNotFoundFault" => crate::error::ModifyDBClusterError {
            meta: generic,
            kind: crate::error::ModifyDBClusterErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBClusterParameterGroupNotFound" => crate::error::ModifyDBClusterError {
            meta: generic,
            kind: crate::error::ModifyDBClusterErrorKind::DbClusterParameterGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_cluster_parameter_group_not_found_fault::Builder::default(
                        );
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSubnetGroupNotFoundFault" => crate::error::ModifyDBClusterError {
            meta: generic,
            kind: crate::error::ModifyDBClusterErrorKind::DbSubnetGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_subnet_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::ModifyDBClusterError {
            meta: generic,
            kind: crate::error::ModifyDBClusterErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBInstanceState" => crate::error::ModifyDBClusterError {
            meta: generic,
            kind: crate::error::ModifyDBClusterErrorKind::InvalidDbInstanceStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_instance_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBSecurityGroupState" => crate::error::ModifyDBClusterError {
            meta: generic,
            kind: crate::error::ModifyDBClusterErrorKind::InvalidDbSecurityGroupStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_security_group_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_security_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBSubnetGroupStateFault" => crate::error::ModifyDBClusterError {
            meta: generic,
            kind: crate::error::ModifyDBClusterErrorKind::InvalidDbSubnetGroupStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_subnet_group_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_subnet_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidSubnet" => crate::error::ModifyDBClusterError {
            meta: generic,
            kind: crate::error::ModifyDBClusterErrorKind::InvalidSubnet({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_subnet::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_subnet_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ModifyDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidVPCNetworkStateFault" => crate::error::ModifyDBClusterError {
            meta: generic,
            kind: crate::error::ModifyDBClusterErrorKind::InvalidVpcNetworkStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_vpc_network_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_vpc_network_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "StorageQuotaExceeded" => crate::error::ModifyDBClusterError {
            meta: generic,
            kind: crate::error::ModifyDBClusterErrorKind::StorageQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::storage_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_storage_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ModifyDBClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyDbClusterOutput, crate::error::ModifyDBClusterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_db_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_db_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyDBClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_cluster_parameter_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDbClusterParameterGroupOutput,
    crate::error::ModifyDBClusterParameterGroupError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyDBClusterParameterGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ModifyDBClusterParameterGroupError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBParameterGroupNotFound" => crate::error::ModifyDBClusterParameterGroupError { meta: generic, kind: crate::error::ModifyDBClusterParameterGroupErrorKind::DbParameterGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterParameterGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidDBParameterGroupState" => crate::error::ModifyDBClusterParameterGroupError { meta: generic, kind: crate::error::ModifyDBClusterParameterGroupErrorKind::InvalidDbParameterGroupStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_db_parameter_group_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_parameter_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterParameterGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ModifyDBClusterParameterGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_cluster_parameter_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDbClusterParameterGroupOutput,
    crate::error::ModifyDBClusterParameterGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::modify_db_cluster_parameter_group_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_modify_db_cluster_parameter_group(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ModifyDBClusterParameterGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_cluster_snapshot_attribute_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDbClusterSnapshotAttributeOutput,
    crate::error::ModifyDBClusterSnapshotAttributeError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyDBClusterSnapshotAttributeError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ModifyDBClusterSnapshotAttributeError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterSnapshotNotFoundFault" => crate::error::ModifyDBClusterSnapshotAttributeError { meta: generic, kind: crate::error::ModifyDBClusterSnapshotAttributeErrorKind::DbClusterSnapshotNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_cluster_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterSnapshotAttributeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidDBClusterSnapshotStateFault" => crate::error::ModifyDBClusterSnapshotAttributeError { meta: generic, kind: crate::error::ModifyDBClusterSnapshotAttributeErrorKind::InvalidDbClusterSnapshotStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_db_cluster_snapshot_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterSnapshotAttributeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "SharedSnapshotQuotaExceeded" => crate::error::ModifyDBClusterSnapshotAttributeError { meta: generic, kind: crate::error::ModifyDBClusterSnapshotAttributeErrorKind::SharedSnapshotQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::shared_snapshot_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_shared_snapshot_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBClusterSnapshotAttributeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ModifyDBClusterSnapshotAttributeError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_cluster_snapshot_attribute_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDbClusterSnapshotAttributeOutput,
    crate::error::ModifyDBClusterSnapshotAttributeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::modify_db_cluster_snapshot_attribute_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_modify_db_cluster_snapshot_attribute(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ModifyDBClusterSnapshotAttributeError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyDbInstanceOutput, crate::error::ModifyDBInstanceError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyDBInstanceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ModifyDBInstanceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AuthorizationNotFound" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::AuthorizationNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::authorization_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_authorization_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "CertificateNotFound" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::CertificateNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::certificate_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_certificate_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBInstanceAlreadyExists" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::DbInstanceAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_instance_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBInstanceNotFound" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::DbInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBParameterGroupNotFound" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::DbParameterGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSecurityGroupNotFound" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::DbSecurityGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_security_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_security_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBUpgradeDependencyFailure" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::DbUpgradeDependencyFailureFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_upgrade_dependency_failure_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_upgrade_dependency_failure_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InsufficientDBInstanceCapacity" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::InsufficientDbInstanceCapacityFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::insufficient_db_instance_capacity_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_insufficient_db_instance_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBInstanceState" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::InvalidDbInstanceStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_instance_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBSecurityGroupState" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::InvalidDbSecurityGroupStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_security_group_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_security_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidVPCNetworkStateFault" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::InvalidVpcNetworkStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_vpc_network_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_vpc_network_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "StorageQuotaExceeded" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::StorageQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::storage_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_storage_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "StorageTypeNotSupported" => crate::error::ModifyDBInstanceError {
            meta: generic,
            kind: crate::error::ModifyDBInstanceErrorKind::StorageTypeNotSupportedFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::storage_type_not_supported_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_storage_type_not_supported_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ModifyDBInstanceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyDbInstanceOutput, crate::error::ModifyDBInstanceError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_db_instance_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_db_instance(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyDBInstanceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_subnet_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDbSubnetGroupOutput,
    crate::error::ModifyDBSubnetGroupError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyDBSubnetGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ModifyDBSubnetGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBSubnetGroupDoesNotCoverEnoughAZs" => crate::error::ModifyDBSubnetGroupError {
            meta: generic,
            kind: crate::error::ModifyDBSubnetGroupErrorKind::DbSubnetGroupDoesNotCoverEnoughAZs({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_subnet_group_does_not_cover_enough_a_zs::Builder::default(
                        );
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_does_not_cover_enough_a_zs_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBSubnetGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSubnetGroupNotFoundFault" => crate::error::ModifyDBSubnetGroupError {
            meta: generic,
            kind: crate::error::ModifyDBSubnetGroupErrorKind::DbSubnetGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_subnet_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBSubnetGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSubnetQuotaExceededFault" => crate::error::ModifyDBSubnetGroupError {
            meta: generic,
            kind: crate::error::ModifyDBSubnetGroupErrorKind::DbSubnetQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::db_subnet_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBSubnetGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidSubnet" => crate::error::ModifyDBSubnetGroupError {
            meta: generic,
            kind: crate::error::ModifyDBSubnetGroupErrorKind::InvalidSubnet({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_subnet::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_subnet_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ModifyDBSubnetGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SubnetAlreadyInUse" => crate::error::ModifyDBSubnetGroupError {
            meta: generic,
            kind: crate::error::ModifyDBSubnetGroupErrorKind::SubnetAlreadyInUse({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::subnet_already_in_use::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_subnet_already_in_use_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyDBSubnetGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ModifyDBSubnetGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_db_subnet_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDbSubnetGroupOutput,
    crate::error::ModifyDBSubnetGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_db_subnet_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_db_subnet_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyDBSubnetGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_event_subscription_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyEventSubscriptionOutput,
    crate::error::ModifyEventSubscriptionError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyEventSubscriptionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ModifyEventSubscriptionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EventSubscriptionQuotaExceeded" => crate::error::ModifyEventSubscriptionError {
            meta: generic,
            kind:
                crate::error::ModifyEventSubscriptionErrorKind::EventSubscriptionQuotaExceededFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::event_subscription_quota_exceeded_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_event_subscription_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyEventSubscriptionError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "SNSInvalidTopic" => crate::error::ModifyEventSubscriptionError {
            meta: generic,
            kind: crate::error::ModifyEventSubscriptionErrorKind::SnsInvalidTopicFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::sns_invalid_topic_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_sns_invalid_topic_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyEventSubscriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SNSNoAuthorization" => crate::error::ModifyEventSubscriptionError {
            meta: generic,
            kind: crate::error::ModifyEventSubscriptionErrorKind::SnsNoAuthorizationFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::sns_no_authorization_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_sns_no_authorization_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyEventSubscriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SNSTopicArnNotFound" => crate::error::ModifyEventSubscriptionError {
            meta: generic,
            kind: crate::error::ModifyEventSubscriptionErrorKind::SnsTopicArnNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::sns_topic_arn_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_sns_topic_arn_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyEventSubscriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SubscriptionCategoryNotFound" => crate::error::ModifyEventSubscriptionError {
            meta: generic,
            kind: crate::error::ModifyEventSubscriptionErrorKind::SubscriptionCategoryNotFoundFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::subscription_category_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_subscription_category_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyEventSubscriptionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "SubscriptionNotFound" => crate::error::ModifyEventSubscriptionError {
            meta: generic,
            kind: crate::error::ModifyEventSubscriptionErrorKind::SubscriptionNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::subscription_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_subscription_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyEventSubscriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ModifyEventSubscriptionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_event_subscription_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyEventSubscriptionOutput,
    crate::error::ModifyEventSubscriptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_event_subscription_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_event_subscription(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyEventSubscriptionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_global_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyGlobalClusterOutput,
    crate::error::ModifyGlobalClusterError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyGlobalClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ModifyGlobalClusterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "GlobalClusterNotFoundFault" => crate::error::ModifyGlobalClusterError {
            meta: generic,
            kind: crate::error::ModifyGlobalClusterErrorKind::GlobalClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::global_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_global_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyGlobalClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidGlobalClusterStateFault" => crate::error::ModifyGlobalClusterError {
            meta: generic,
            kind: crate::error::ModifyGlobalClusterErrorKind::InvalidGlobalClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_global_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_global_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyGlobalClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ModifyGlobalClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_global_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyGlobalClusterOutput,
    crate::error::ModifyGlobalClusterError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_global_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_global_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyGlobalClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reboot_db_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RebootDbInstanceOutput, crate::error::RebootDBInstanceError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::RebootDBInstanceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::RebootDBInstanceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBInstanceNotFound" => crate::error::RebootDBInstanceError {
            meta: generic,
            kind: crate::error::RebootDBInstanceErrorKind::DbInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RebootDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBInstanceState" => crate::error::RebootDBInstanceError {
            meta: generic,
            kind: crate::error::RebootDBInstanceErrorKind::InvalidDbInstanceStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_instance_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RebootDBInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::RebootDBInstanceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reboot_db_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RebootDbInstanceOutput, crate::error::RebootDBInstanceError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reboot_db_instance_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_reboot_db_instance(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RebootDBInstanceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_from_global_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveFromGlobalClusterOutput,
    crate::error::RemoveFromGlobalClusterError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::RemoveFromGlobalClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RemoveFromGlobalClusterError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::RemoveFromGlobalClusterError {
            meta: generic,
            kind: crate::error::RemoveFromGlobalClusterErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveFromGlobalClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "GlobalClusterNotFoundFault" => crate::error::RemoveFromGlobalClusterError {
            meta: generic,
            kind: crate::error::RemoveFromGlobalClusterErrorKind::GlobalClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::global_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_global_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveFromGlobalClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidGlobalClusterStateFault" => crate::error::RemoveFromGlobalClusterError {
            meta: generic,
            kind: crate::error::RemoveFromGlobalClusterErrorKind::InvalidGlobalClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_global_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_global_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveFromGlobalClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::RemoveFromGlobalClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_from_global_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveFromGlobalClusterOutput,
    crate::error::RemoveFromGlobalClusterError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::remove_from_global_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_remove_from_global_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RemoveFromGlobalClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_source_identifier_from_subscription_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveSourceIdentifierFromSubscriptionOutput,
    crate::error::RemoveSourceIdentifierFromSubscriptionError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::RemoveSourceIdentifierFromSubscriptionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::RemoveSourceIdentifierFromSubscriptionError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "SourceNotFound" => crate::error::RemoveSourceIdentifierFromSubscriptionError { meta: generic, kind: crate::error::RemoveSourceIdentifierFromSubscriptionErrorKind::SourceNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::source_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_source_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveSourceIdentifierFromSubscriptionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "SubscriptionNotFound" => crate::error::RemoveSourceIdentifierFromSubscriptionError { meta: generic, kind: crate::error::RemoveSourceIdentifierFromSubscriptionErrorKind::SubscriptionNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::subscription_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_subscription_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveSourceIdentifierFromSubscriptionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::RemoveSourceIdentifierFromSubscriptionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_source_identifier_from_subscription_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveSourceIdentifierFromSubscriptionOutput,
    crate::error::RemoveSourceIdentifierFromSubscriptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::remove_source_identifier_from_subscription_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_remove_source_identifier_from_subscription(response.body().as_ref(), output).map_err(crate::error::RemoveSourceIdentifierFromSubscriptionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_tags_from_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveTagsFromResourceOutput,
    crate::error::RemoveTagsFromResourceError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::RemoveTagsFromResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RemoveTagsFromResourceError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::RemoveTagsFromResourceError {
            meta: generic,
            kind: crate::error::RemoveTagsFromResourceErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveTagsFromResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBInstanceNotFound" => crate::error::RemoveTagsFromResourceError {
            meta: generic,
            kind: crate::error::RemoveTagsFromResourceErrorKind::DbInstanceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_instance_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_instance_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveTagsFromResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DBSnapshotNotFound" => crate::error::RemoveTagsFromResourceError {
            meta: generic,
            kind: crate::error::RemoveTagsFromResourceErrorKind::DbSnapshotNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RemoveTagsFromResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::RemoveTagsFromResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_tags_from_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveTagsFromResourceOutput,
    crate::error::RemoveTagsFromResourceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::remove_tags_from_resource_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_db_cluster_parameter_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ResetDbClusterParameterGroupOutput,
    crate::error::ResetDBClusterParameterGroupError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ResetDBClusterParameterGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ResetDBClusterParameterGroupError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBParameterGroupNotFound" => crate::error::ResetDBClusterParameterGroupError { meta: generic, kind: crate::error::ResetDBClusterParameterGroupErrorKind::DbParameterGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ResetDBClusterParameterGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidDBParameterGroupState" => crate::error::ResetDBClusterParameterGroupError { meta: generic, kind: crate::error::ResetDBClusterParameterGroupErrorKind::InvalidDbParameterGroupStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_db_parameter_group_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_parameter_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ResetDBClusterParameterGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ResetDBClusterParameterGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_db_cluster_parameter_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ResetDbClusterParameterGroupOutput,
    crate::error::ResetDBClusterParameterGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reset_db_cluster_parameter_group_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_reset_db_cluster_parameter_group(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ResetDBClusterParameterGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_db_cluster_from_snapshot_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreDbClusterFromSnapshotOutput,
    crate::error::RestoreDBClusterFromSnapshotError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RestoreDBClusterFromSnapshotError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterAlreadyExistsFault" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::DbClusterAlreadyExistsFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_cluster_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBClusterQuotaExceededFault" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::DbClusterQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_cluster_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBClusterSnapshotNotFoundFault" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::DbClusterSnapshotNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_cluster_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBSnapshotNotFound" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::DbSnapshotNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBSubnetGroupNotFoundFault" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::DbSubnetGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_subnet_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InsufficientDBClusterCapacityFault" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::InsufficientDbClusterCapacityFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::insufficient_db_cluster_capacity_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_insufficient_db_cluster_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InsufficientStorageClusterCapacity" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::InsufficientStorageClusterCapacityFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::insufficient_storage_cluster_capacity_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_insufficient_storage_cluster_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidDBClusterSnapshotStateFault" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::InvalidDbClusterSnapshotStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_db_cluster_snapshot_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidDBSnapshotState" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::InvalidDbSnapshotStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_db_snapshot_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRestoreFault" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::InvalidRestoreFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_restore_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_restore_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidSubnet" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::InvalidSubnet({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_subnet::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_subnet_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidVPCNetworkStateFault" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::InvalidVpcNetworkStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_vpc_network_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_vpc_network_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "KMSKeyNotAccessibleFault" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::KmsKeyNotAccessibleFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_kms_key_not_accessible_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "StorageQuotaExceeded" => crate::error::RestoreDBClusterFromSnapshotError { meta: generic, kind: crate::error::RestoreDBClusterFromSnapshotErrorKind::StorageQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::storage_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_storage_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::RestoreDBClusterFromSnapshotError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_db_cluster_from_snapshot_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreDbClusterFromSnapshotOutput,
    crate::error::RestoreDBClusterFromSnapshotError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::restore_db_cluster_from_snapshot_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_restore_db_cluster_from_snapshot(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::RestoreDBClusterFromSnapshotError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_db_cluster_to_point_in_time_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreDbClusterToPointInTimeOutput,
    crate::error::RestoreDBClusterToPointInTimeError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RestoreDBClusterToPointInTimeError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterAlreadyExistsFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::DbClusterAlreadyExistsFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_cluster_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBClusterNotFoundFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::DbClusterNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBClusterQuotaExceededFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::DbClusterQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_cluster_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBClusterSnapshotNotFoundFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::DbClusterSnapshotNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_cluster_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DBSubnetGroupNotFoundFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::DbSubnetGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::db_subnet_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_subnet_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InsufficientDBClusterCapacityFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::InsufficientDbClusterCapacityFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::insufficient_db_cluster_capacity_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_insufficient_db_cluster_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InsufficientStorageClusterCapacity" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::InsufficientStorageClusterCapacityFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::insufficient_storage_cluster_capacity_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_insufficient_storage_cluster_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidDBClusterSnapshotStateFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::InvalidDbClusterSnapshotStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_db_cluster_snapshot_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidDBClusterStateFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::InvalidDbClusterStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidDBSnapshotState" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::InvalidDbSnapshotStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_db_snapshot_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRestoreFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::InvalidRestoreFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_restore_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_restore_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidSubnet" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::InvalidSubnet({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_subnet::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_subnet_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidVPCNetworkStateFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::InvalidVpcNetworkStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_vpc_network_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_vpc_network_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "KMSKeyNotAccessibleFault" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::KmsKeyNotAccessibleFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::kms_key_not_accessible_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_kms_key_not_accessible_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "StorageQuotaExceeded" => crate::error::RestoreDBClusterToPointInTimeError { meta: generic, kind: crate::error::RestoreDBClusterToPointInTimeErrorKind::StorageQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::storage_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_storage_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::RestoreDBClusterToPointInTimeError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_db_cluster_to_point_in_time_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreDbClusterToPointInTimeOutput,
    crate::error::RestoreDBClusterToPointInTimeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::restore_db_cluster_to_point_in_time_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_restore_db_cluster_to_point_in_time(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::RestoreDBClusterToPointInTimeError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_db_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StartDbClusterOutput, crate::error::StartDBClusterError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::StartDBClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StartDBClusterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::StartDBClusterError {
            meta: generic,
            kind: crate::error::StartDBClusterErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::StartDBClusterError {
            meta: generic,
            kind: crate::error::StartDBClusterErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBInstanceState" => crate::error::StartDBClusterError {
            meta: generic,
            kind: crate::error::StartDBClusterErrorKind::InvalidDbInstanceStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_instance_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StartDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::StartDBClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_db_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StartDbClusterOutput, crate::error::StartDBClusterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_db_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_start_db_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StartDBClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_db_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StopDbClusterOutput, crate::error::StopDBClusterError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::StopDBClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StopDBClusterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DBClusterNotFoundFault" => crate::error::StopDBClusterError {
            meta: generic,
            kind: crate::error::StopDBClusterErrorKind::DbClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::db_cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_db_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StopDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBClusterStateFault" => crate::error::StopDBClusterError {
            meta: generic,
            kind: crate::error::StopDBClusterErrorKind::InvalidDbClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StopDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDBInstanceState" => crate::error::StopDBClusterError {
            meta: generic,
            kind: crate::error::StopDBClusterErrorKind::InvalidDbInstanceStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_db_instance_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_db_instance_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::StopDBClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::StopDBClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_db_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StopDbClusterOutput, crate::error::StopDBClusterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_db_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_stop_db_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StopDBClusterError::unhandled)?;
        output.build()
    })
}
