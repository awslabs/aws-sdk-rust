// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p> Information about all the available strategy options for migrating and modernizing an application component. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StrategyOption {
    /// <p> Type of transformation. For example, Rehost, Replatform, and so on. </p>
    #[doc(hidden)]
    pub strategy: std::option::Option<crate::model::Strategy>,
    /// <p> The name of the tool that can be used to transform an application component using this strategy. </p>
    #[doc(hidden)]
    pub tool_name: std::option::Option<crate::model::TransformationToolName>,
    /// <p> Destination information about where the application component can migrate to. For example, <code>EC2</code>, <code>ECS</code>, and so on. </p>
    #[doc(hidden)]
    pub target_destination: std::option::Option<crate::model::TargetDestination>,
    /// <p> Indicates if a specific strategy is preferred for the application component. </p>
    #[doc(hidden)]
    pub is_preferred: std::option::Option<bool>,
}
impl StrategyOption {
    /// <p> Type of transformation. For example, Rehost, Replatform, and so on. </p>
    pub fn strategy(&self) -> std::option::Option<&crate::model::Strategy> {
        self.strategy.as_ref()
    }
    /// <p> The name of the tool that can be used to transform an application component using this strategy. </p>
    pub fn tool_name(&self) -> std::option::Option<&crate::model::TransformationToolName> {
        self.tool_name.as_ref()
    }
    /// <p> Destination information about where the application component can migrate to. For example, <code>EC2</code>, <code>ECS</code>, and so on. </p>
    pub fn target_destination(&self) -> std::option::Option<&crate::model::TargetDestination> {
        self.target_destination.as_ref()
    }
    /// <p> Indicates if a specific strategy is preferred for the application component. </p>
    pub fn is_preferred(&self) -> std::option::Option<bool> {
        self.is_preferred
    }
}
/// See [`StrategyOption`](crate::model::StrategyOption).
pub mod strategy_option {

    /// A builder for [`StrategyOption`](crate::model::StrategyOption).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) strategy: std::option::Option<crate::model::Strategy>,
        pub(crate) tool_name: std::option::Option<crate::model::TransformationToolName>,
        pub(crate) target_destination: std::option::Option<crate::model::TargetDestination>,
        pub(crate) is_preferred: std::option::Option<bool>,
    }
    impl Builder {
        /// <p> Type of transformation. For example, Rehost, Replatform, and so on. </p>
        pub fn strategy(mut self, input: crate::model::Strategy) -> Self {
            self.strategy = Some(input);
            self
        }
        /// <p> Type of transformation. For example, Rehost, Replatform, and so on. </p>
        pub fn set_strategy(mut self, input: std::option::Option<crate::model::Strategy>) -> Self {
            self.strategy = input;
            self
        }
        /// <p> The name of the tool that can be used to transform an application component using this strategy. </p>
        pub fn tool_name(mut self, input: crate::model::TransformationToolName) -> Self {
            self.tool_name = Some(input);
            self
        }
        /// <p> The name of the tool that can be used to transform an application component using this strategy. </p>
        pub fn set_tool_name(
            mut self,
            input: std::option::Option<crate::model::TransformationToolName>,
        ) -> Self {
            self.tool_name = input;
            self
        }
        /// <p> Destination information about where the application component can migrate to. For example, <code>EC2</code>, <code>ECS</code>, and so on. </p>
        pub fn target_destination(mut self, input: crate::model::TargetDestination) -> Self {
            self.target_destination = Some(input);
            self
        }
        /// <p> Destination information about where the application component can migrate to. For example, <code>EC2</code>, <code>ECS</code>, and so on. </p>
        pub fn set_target_destination(
            mut self,
            input: std::option::Option<crate::model::TargetDestination>,
        ) -> Self {
            self.target_destination = input;
            self
        }
        /// <p> Indicates if a specific strategy is preferred for the application component. </p>
        pub fn is_preferred(mut self, input: bool) -> Self {
            self.is_preferred = Some(input);
            self
        }
        /// <p> Indicates if a specific strategy is preferred for the application component. </p>
        pub fn set_is_preferred(mut self, input: std::option::Option<bool>) -> Self {
            self.is_preferred = input;
            self
        }
        /// Consumes the builder and constructs a [`StrategyOption`](crate::model::StrategyOption).
        pub fn build(self) -> crate::model::StrategyOption {
            crate::model::StrategyOption {
                strategy: self.strategy,
                tool_name: self.tool_name,
                target_destination: self.target_destination,
                is_preferred: self.is_preferred,
            }
        }
    }
}
impl StrategyOption {
    /// Creates a new builder-style object to manufacture [`StrategyOption`](crate::model::StrategyOption).
    pub fn builder() -> crate::model::strategy_option::Builder {
        crate::model::strategy_option::Builder::default()
    }
}

/// When writing a match expression against `TargetDestination`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let targetdestination = unimplemented!();
/// match targetdestination {
///     TargetDestination::AwsElasticBeanstalk => { /* ... */ },
///     TargetDestination::AwsFargate => { /* ... */ },
///     TargetDestination::AmazonDocumentdb => { /* ... */ },
///     TargetDestination::AmazonDynamodb => { /* ... */ },
///     TargetDestination::AmazonElasticCloudCompute => { /* ... */ },
///     TargetDestination::AmazonElasticContainerService => { /* ... */ },
///     TargetDestination::AmazonElasticKubernetesService => { /* ... */ },
///     TargetDestination::AmazonRds => { /* ... */ },
///     TargetDestination::AmazonRdsMysql => { /* ... */ },
///     TargetDestination::AmazonRdsPostgresql => { /* ... */ },
///     TargetDestination::AuroraMysql => { /* ... */ },
///     TargetDestination::AuroraPostgresql => { /* ... */ },
///     TargetDestination::BabelfishAuroraPostgresql => { /* ... */ },
///     TargetDestination::NoneSpecified => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `targetdestination` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TargetDestination::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TargetDestination::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TargetDestination::NewFeature` is defined.
/// Specifically, when `targetdestination` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TargetDestination::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TargetDestination {
    #[allow(missing_docs)] // documentation missing in model
    AwsElasticBeanstalk,
    #[allow(missing_docs)] // documentation missing in model
    AwsFargate,
    #[allow(missing_docs)] // documentation missing in model
    AmazonDocumentdb,
    #[allow(missing_docs)] // documentation missing in model
    AmazonDynamodb,
    #[allow(missing_docs)] // documentation missing in model
    AmazonElasticCloudCompute,
    #[allow(missing_docs)] // documentation missing in model
    AmazonElasticContainerService,
    #[allow(missing_docs)] // documentation missing in model
    AmazonElasticKubernetesService,
    #[allow(missing_docs)] // documentation missing in model
    AmazonRds,
    #[allow(missing_docs)] // documentation missing in model
    AmazonRdsMysql,
    #[allow(missing_docs)] // documentation missing in model
    AmazonRdsPostgresql,
    #[allow(missing_docs)] // documentation missing in model
    AuroraMysql,
    #[allow(missing_docs)] // documentation missing in model
    AuroraPostgresql,
    #[allow(missing_docs)] // documentation missing in model
    BabelfishAuroraPostgresql,
    #[allow(missing_docs)] // documentation missing in model
    NoneSpecified,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TargetDestination {
    fn from(s: &str) -> Self {
        match s {
            "AWS Elastic BeanStalk" => TargetDestination::AwsElasticBeanstalk,
            "AWS Fargate" => TargetDestination::AwsFargate,
            "Amazon DocumentDB" => TargetDestination::AmazonDocumentdb,
            "Amazon DynamoDB" => TargetDestination::AmazonDynamodb,
            "Amazon Elastic Cloud Compute (EC2)" => TargetDestination::AmazonElasticCloudCompute,
            "Amazon Elastic Container Service (ECS)" => {
                TargetDestination::AmazonElasticContainerService
            }
            "Amazon Elastic Kubernetes Service (EKS)" => {
                TargetDestination::AmazonElasticKubernetesService
            }
            "Amazon Relational Database Service" => TargetDestination::AmazonRds,
            "Amazon Relational Database Service on MySQL" => TargetDestination::AmazonRdsMysql,
            "Amazon Relational Database Service on PostgreSQL" => {
                TargetDestination::AmazonRdsPostgresql
            }
            "Aurora MySQL" => TargetDestination::AuroraMysql,
            "Aurora PostgreSQL" => TargetDestination::AuroraPostgresql,
            "Babelfish for Aurora PostgreSQL" => TargetDestination::BabelfishAuroraPostgresql,
            "None specified" => TargetDestination::NoneSpecified,
            other => {
                TargetDestination::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for TargetDestination {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TargetDestination::from(s))
    }
}
impl TargetDestination {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TargetDestination::AwsElasticBeanstalk => "AWS Elastic BeanStalk",
            TargetDestination::AwsFargate => "AWS Fargate",
            TargetDestination::AmazonDocumentdb => "Amazon DocumentDB",
            TargetDestination::AmazonDynamodb => "Amazon DynamoDB",
            TargetDestination::AmazonElasticCloudCompute => "Amazon Elastic Cloud Compute (EC2)",
            TargetDestination::AmazonElasticContainerService => {
                "Amazon Elastic Container Service (ECS)"
            }
            TargetDestination::AmazonElasticKubernetesService => {
                "Amazon Elastic Kubernetes Service (EKS)"
            }
            TargetDestination::AmazonRds => "Amazon Relational Database Service",
            TargetDestination::AmazonRdsMysql => "Amazon Relational Database Service on MySQL",
            TargetDestination::AmazonRdsPostgresql => {
                "Amazon Relational Database Service on PostgreSQL"
            }
            TargetDestination::AuroraMysql => "Aurora MySQL",
            TargetDestination::AuroraPostgresql => "Aurora PostgreSQL",
            TargetDestination::BabelfishAuroraPostgresql => "Babelfish for Aurora PostgreSQL",
            TargetDestination::NoneSpecified => "None specified",
            TargetDestination::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AWS Elastic BeanStalk",
            "AWS Fargate",
            "Amazon DocumentDB",
            "Amazon DynamoDB",
            "Amazon Elastic Cloud Compute (EC2)",
            "Amazon Elastic Container Service (ECS)",
            "Amazon Elastic Kubernetes Service (EKS)",
            "Amazon Relational Database Service",
            "Amazon Relational Database Service on MySQL",
            "Amazon Relational Database Service on PostgreSQL",
            "Aurora MySQL",
            "Aurora PostgreSQL",
            "Babelfish for Aurora PostgreSQL",
            "None specified",
        ]
    }
}
impl AsRef<str> for TargetDestination {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `TransformationToolName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let transformationtoolname = unimplemented!();
/// match transformationtoolname {
///     TransformationToolName::App2Container => { /* ... */ },
///     TransformationToolName::Mgn => { /* ... */ },
///     TransformationToolName::Dms => { /* ... */ },
///     TransformationToolName::Emp => { /* ... */ },
///     TransformationToolName::InPlaceOsUpgrade => { /* ... */ },
///     TransformationToolName::NativeSql => { /* ... */ },
///     TransformationToolName::PortingAssistant => { /* ... */ },
///     TransformationToolName::Sct => { /* ... */ },
///     TransformationToolName::StrategyRecommendationSupport => { /* ... */ },
///     TransformationToolName::Wwama => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `transformationtoolname` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TransformationToolName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TransformationToolName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TransformationToolName::NewFeature` is defined.
/// Specifically, when `transformationtoolname` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TransformationToolName::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TransformationToolName {
    #[allow(missing_docs)] // documentation missing in model
    App2Container,
    #[allow(missing_docs)] // documentation missing in model
    Mgn,
    #[allow(missing_docs)] // documentation missing in model
    Dms,
    #[allow(missing_docs)] // documentation missing in model
    Emp,
    #[allow(missing_docs)] // documentation missing in model
    InPlaceOsUpgrade,
    #[allow(missing_docs)] // documentation missing in model
    NativeSql,
    #[allow(missing_docs)] // documentation missing in model
    PortingAssistant,
    #[allow(missing_docs)] // documentation missing in model
    Sct,
    #[allow(missing_docs)] // documentation missing in model
    StrategyRecommendationSupport,
    #[allow(missing_docs)] // documentation missing in model
    Wwama,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TransformationToolName {
    fn from(s: &str) -> Self {
        match s {
            "App2Container" => TransformationToolName::App2Container,
            "Application Migration Service" => TransformationToolName::Mgn,
            "Database Migration Service" => TransformationToolName::Dms,
            "End of Support Migration" => TransformationToolName::Emp,
            "In Place Operating System Upgrade" => TransformationToolName::InPlaceOsUpgrade,
            "Native SQL Server Backup/Restore" => TransformationToolName::NativeSql,
            "Porting Assistant For .NET" => TransformationToolName::PortingAssistant,
            "Schema Conversion Tool" => TransformationToolName::Sct,
            "Strategy Recommendation Support" => {
                TransformationToolName::StrategyRecommendationSupport
            }
            "Windows Web Application Migration Assistant" => TransformationToolName::Wwama,
            other => {
                TransformationToolName::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for TransformationToolName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TransformationToolName::from(s))
    }
}
impl TransformationToolName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TransformationToolName::App2Container => "App2Container",
            TransformationToolName::Mgn => "Application Migration Service",
            TransformationToolName::Dms => "Database Migration Service",
            TransformationToolName::Emp => "End of Support Migration",
            TransformationToolName::InPlaceOsUpgrade => "In Place Operating System Upgrade",
            TransformationToolName::NativeSql => "Native SQL Server Backup/Restore",
            TransformationToolName::PortingAssistant => "Porting Assistant For .NET",
            TransformationToolName::Sct => "Schema Conversion Tool",
            TransformationToolName::StrategyRecommendationSupport => {
                "Strategy Recommendation Support"
            }
            TransformationToolName::Wwama => "Windows Web Application Migration Assistant",
            TransformationToolName::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "App2Container",
            "Application Migration Service",
            "Database Migration Service",
            "End of Support Migration",
            "In Place Operating System Upgrade",
            "Native SQL Server Backup/Restore",
            "Porting Assistant For .NET",
            "Schema Conversion Tool",
            "Strategy Recommendation Support",
            "Windows Web Application Migration Assistant",
        ]
    }
}
impl AsRef<str> for TransformationToolName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `Strategy`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let strategy = unimplemented!();
/// match strategy {
///     Strategy::Refactor => { /* ... */ },
///     Strategy::Rehost => { /* ... */ },
///     Strategy::Relocate => { /* ... */ },
///     Strategy::Replatform => { /* ... */ },
///     Strategy::Repurchase => { /* ... */ },
///     Strategy::Retain => { /* ... */ },
///     Strategy::Retirement => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `strategy` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Strategy::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Strategy::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Strategy::NewFeature` is defined.
/// Specifically, when `strategy` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Strategy::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Strategy {
    #[allow(missing_docs)] // documentation missing in model
    Refactor,
    #[allow(missing_docs)] // documentation missing in model
    Rehost,
    #[allow(missing_docs)] // documentation missing in model
    Relocate,
    #[allow(missing_docs)] // documentation missing in model
    Replatform,
    #[allow(missing_docs)] // documentation missing in model
    Repurchase,
    #[allow(missing_docs)] // documentation missing in model
    Retain,
    #[allow(missing_docs)] // documentation missing in model
    Retirement,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Strategy {
    fn from(s: &str) -> Self {
        match s {
            "Refactor" => Strategy::Refactor,
            "Rehost" => Strategy::Rehost,
            "Relocate" => Strategy::Relocate,
            "Replatform" => Strategy::Replatform,
            "Repurchase" => Strategy::Repurchase,
            "Retain" => Strategy::Retain,
            "Retirement" => Strategy::Retirement,
            other => Strategy::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Strategy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Strategy::from(s))
    }
}
impl Strategy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Strategy::Refactor => "Refactor",
            Strategy::Rehost => "Rehost",
            Strategy::Relocate => "Relocate",
            Strategy::Replatform => "Replatform",
            Strategy::Repurchase => "Repurchase",
            Strategy::Retain => "Retain",
            Strategy::Retirement => "Retirement",
            Strategy::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "Refactor",
            "Rehost",
            "Relocate",
            "Replatform",
            "Repurchase",
            "Retain",
            "Retirement",
        ]
    }
}
impl AsRef<str> for Strategy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `AppType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let apptype = unimplemented!();
/// match apptype {
///     AppType::Cassandra => { /* ... */ },
///     AppType::Db2 => { /* ... */ },
///     AppType::DotNetFramework => { /* ... */ },
///     AppType::Dotnet => { /* ... */ },
///     AppType::Dotnetcore => { /* ... */ },
///     AppType::Websphere => { /* ... */ },
///     AppType::Iis => { /* ... */ },
///     AppType::Jboss => { /* ... */ },
///     AppType::Java => { /* ... */ },
///     AppType::Mariadb => { /* ... */ },
///     AppType::Mongodb => { /* ... */ },
///     AppType::Mysql => { /* ... */ },
///     AppType::Oracle => { /* ... */ },
///     AppType::Weblogic => { /* ... */ },
///     AppType::Other => { /* ... */ },
///     AppType::Postgresqlserver => { /* ... */ },
///     AppType::SqlServer => { /* ... */ },
///     AppType::Spring => { /* ... */ },
///     AppType::Sybase => { /* ... */ },
///     AppType::Tomcat => { /* ... */ },
///     AppType::UnknownValue => { /* ... */ },
///     AppType::Visualbasic => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `apptype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AppType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AppType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AppType::NewFeature` is defined.
/// Specifically, when `apptype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AppType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// _Note: `AppType::Unknown` has been renamed to `::UnknownValue`._
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AppType {
    #[allow(missing_docs)] // documentation missing in model
    Cassandra,
    #[allow(missing_docs)] // documentation missing in model
    Db2,
    #[allow(missing_docs)] // documentation missing in model
    DotNetFramework,
    #[allow(missing_docs)] // documentation missing in model
    Dotnet,
    #[allow(missing_docs)] // documentation missing in model
    Dotnetcore,
    #[allow(missing_docs)] // documentation missing in model
    Websphere,
    #[allow(missing_docs)] // documentation missing in model
    Iis,
    #[allow(missing_docs)] // documentation missing in model
    Jboss,
    #[allow(missing_docs)] // documentation missing in model
    Java,
    #[allow(missing_docs)] // documentation missing in model
    Mariadb,
    #[allow(missing_docs)] // documentation missing in model
    Mongodb,
    #[allow(missing_docs)] // documentation missing in model
    Mysql,
    #[allow(missing_docs)] // documentation missing in model
    Oracle,
    #[allow(missing_docs)] // documentation missing in model
    Weblogic,
    #[allow(missing_docs)] // documentation missing in model
    Other,
    #[allow(missing_docs)] // documentation missing in model
    Postgresqlserver,
    #[allow(missing_docs)] // documentation missing in model
    SqlServer,
    #[allow(missing_docs)] // documentation missing in model
    Spring,
    #[allow(missing_docs)] // documentation missing in model
    Sybase,
    #[allow(missing_docs)] // documentation missing in model
    Tomcat,
    /// _Note: `::Unknown` has been renamed to `::UnknownValue`._
    UnknownValue,
    #[allow(missing_docs)] // documentation missing in model
    Visualbasic,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AppType {
    fn from(s: &str) -> Self {
        match s {
            "Cassandra" => AppType::Cassandra,
            "DB2" => AppType::Db2,
            "DotNetFramework" => AppType::DotNetFramework,
            "Dotnet" => AppType::Dotnet,
            "DotnetCore" => AppType::Dotnetcore,
            "IBM WebSphere" => AppType::Websphere,
            "IIS" => AppType::Iis,
            "JBoss" => AppType::Jboss,
            "Java" => AppType::Java,
            "Maria DB" => AppType::Mariadb,
            "Mongo DB" => AppType::Mongodb,
            "MySQL" => AppType::Mysql,
            "Oracle" => AppType::Oracle,
            "Oracle WebLogic" => AppType::Weblogic,
            "Other" => AppType::Other,
            "PostgreSQLServer" => AppType::Postgresqlserver,
            "SQLServer" => AppType::SqlServer,
            "Spring" => AppType::Spring,
            "Sybase" => AppType::Sybase,
            "Tomcat" => AppType::Tomcat,
            "Unknown" => AppType::UnknownValue,
            "Visual Basic" => AppType::Visualbasic,
            other => AppType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AppType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AppType::from(s))
    }
}
impl AppType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AppType::Cassandra => "Cassandra",
            AppType::Db2 => "DB2",
            AppType::DotNetFramework => "DotNetFramework",
            AppType::Dotnet => "Dotnet",
            AppType::Dotnetcore => "DotnetCore",
            AppType::Websphere => "IBM WebSphere",
            AppType::Iis => "IIS",
            AppType::Jboss => "JBoss",
            AppType::Java => "Java",
            AppType::Mariadb => "Maria DB",
            AppType::Mongodb => "Mongo DB",
            AppType::Mysql => "MySQL",
            AppType::Oracle => "Oracle",
            AppType::Weblogic => "Oracle WebLogic",
            AppType::Other => "Other",
            AppType::Postgresqlserver => "PostgreSQLServer",
            AppType::SqlServer => "SQLServer",
            AppType::Spring => "Spring",
            AppType::Sybase => "Sybase",
            AppType::Tomcat => "Tomcat",
            AppType::UnknownValue => "Unknown",
            AppType::Visualbasic => "Visual Basic",
            AppType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "Cassandra",
            "DB2",
            "DotNetFramework",
            "Dotnet",
            "DotnetCore",
            "IBM WebSphere",
            "IIS",
            "JBoss",
            "Java",
            "Maria DB",
            "Mongo DB",
            "MySQL",
            "Oracle",
            "Oracle WebLogic",
            "Other",
            "PostgreSQLServer",
            "SQLServer",
            "Spring",
            "Sybase",
            "Tomcat",
            "Unknown",
            "Visual Basic",
        ]
    }
}
impl AsRef<str> for AppType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> Object containing source code information that is linked to an application component. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SourceCode {
    /// <p> The type of repository to use for the source code. </p>
    #[doc(hidden)]
    pub version_control: std::option::Option<crate::model::VersionControl>,
    /// <p> The branch of the source code. </p>
    #[doc(hidden)]
    pub source_version: std::option::Option<std::string::String>,
    /// <p> The repository name for the source code. </p>
    #[doc(hidden)]
    pub location: std::option::Option<std::string::String>,
    /// <p>The name of the project.</p>
    #[doc(hidden)]
    pub project_name: std::option::Option<std::string::String>,
}
impl SourceCode {
    /// <p> The type of repository to use for the source code. </p>
    pub fn version_control(&self) -> std::option::Option<&crate::model::VersionControl> {
        self.version_control.as_ref()
    }
    /// <p> The branch of the source code. </p>
    pub fn source_version(&self) -> std::option::Option<&str> {
        self.source_version.as_deref()
    }
    /// <p> The repository name for the source code. </p>
    pub fn location(&self) -> std::option::Option<&str> {
        self.location.as_deref()
    }
    /// <p>The name of the project.</p>
    pub fn project_name(&self) -> std::option::Option<&str> {
        self.project_name.as_deref()
    }
}
/// See [`SourceCode`](crate::model::SourceCode).
pub mod source_code {

    /// A builder for [`SourceCode`](crate::model::SourceCode).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) version_control: std::option::Option<crate::model::VersionControl>,
        pub(crate) source_version: std::option::Option<std::string::String>,
        pub(crate) location: std::option::Option<std::string::String>,
        pub(crate) project_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The type of repository to use for the source code. </p>
        pub fn version_control(mut self, input: crate::model::VersionControl) -> Self {
            self.version_control = Some(input);
            self
        }
        /// <p> The type of repository to use for the source code. </p>
        pub fn set_version_control(
            mut self,
            input: std::option::Option<crate::model::VersionControl>,
        ) -> Self {
            self.version_control = input;
            self
        }
        /// <p> The branch of the source code. </p>
        pub fn source_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_version = Some(input.into());
            self
        }
        /// <p> The branch of the source code. </p>
        pub fn set_source_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_version = input;
            self
        }
        /// <p> The repository name for the source code. </p>
        pub fn location(mut self, input: impl Into<std::string::String>) -> Self {
            self.location = Some(input.into());
            self
        }
        /// <p> The repository name for the source code. </p>
        pub fn set_location(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.location = input;
            self
        }
        /// <p>The name of the project.</p>
        pub fn project_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_name = Some(input.into());
            self
        }
        /// <p>The name of the project.</p>
        pub fn set_project_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_name = input;
            self
        }
        /// Consumes the builder and constructs a [`SourceCode`](crate::model::SourceCode).
        pub fn build(self) -> crate::model::SourceCode {
            crate::model::SourceCode {
                version_control: self.version_control,
                source_version: self.source_version,
                location: self.location,
                project_name: self.project_name,
            }
        }
    }
}
impl SourceCode {
    /// Creates a new builder-style object to manufacture [`SourceCode`](crate::model::SourceCode).
    pub fn builder() -> crate::model::source_code::Builder {
        crate::model::source_code::Builder::default()
    }
}

/// When writing a match expression against `VersionControl`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let versioncontrol = unimplemented!();
/// match versioncontrol {
///     VersionControl::AzureDevopsGit => { /* ... */ },
///     VersionControl::Github => { /* ... */ },
///     VersionControl::GithubEnterprise => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `versioncontrol` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `VersionControl::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `VersionControl::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `VersionControl::NewFeature` is defined.
/// Specifically, when `versioncontrol` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `VersionControl::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VersionControl {
    #[allow(missing_docs)] // documentation missing in model
    AzureDevopsGit,
    #[allow(missing_docs)] // documentation missing in model
    Github,
    #[allow(missing_docs)] // documentation missing in model
    GithubEnterprise,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for VersionControl {
    fn from(s: &str) -> Self {
        match s {
            "AZURE_DEVOPS_GIT" => VersionControl::AzureDevopsGit,
            "GITHUB" => VersionControl::Github,
            "GITHUB_ENTERPRISE" => VersionControl::GithubEnterprise,
            other => VersionControl::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for VersionControl {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VersionControl::from(s))
    }
}
impl VersionControl {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            VersionControl::AzureDevopsGit => "AZURE_DEVOPS_GIT",
            VersionControl::Github => "GITHUB",
            VersionControl::GithubEnterprise => "GITHUB_ENTERPRISE",
            VersionControl::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AZURE_DEVOPS_GIT", "GITHUB", "GITHUB_ENTERPRISE"]
    }
}
impl AsRef<str> for VersionControl {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `InclusionStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let inclusionstatus = unimplemented!();
/// match inclusionstatus {
///     InclusionStatus::ExcludeFromRecommendation => { /* ... */ },
///     InclusionStatus::IncludeInRecommendation => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `inclusionstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `InclusionStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `InclusionStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `InclusionStatus::NewFeature` is defined.
/// Specifically, when `inclusionstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `InclusionStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InclusionStatus {
    #[allow(missing_docs)] // documentation missing in model
    ExcludeFromRecommendation,
    #[allow(missing_docs)] // documentation missing in model
    IncludeInRecommendation,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for InclusionStatus {
    fn from(s: &str) -> Self {
        match s {
            "excludeFromAssessment" => InclusionStatus::ExcludeFromRecommendation,
            "includeInAssessment" => InclusionStatus::IncludeInRecommendation,
            other => InclusionStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for InclusionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InclusionStatus::from(s))
    }
}
impl InclusionStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            InclusionStatus::ExcludeFromRecommendation => "excludeFromAssessment",
            InclusionStatus::IncludeInRecommendation => "includeInAssessment",
            InclusionStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["excludeFromAssessment", "includeInAssessment"]
    }
}
impl AsRef<str> for InclusionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> The object containing information about distinct imports or groups for Strategy Recommendations. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Group {
    /// <p> The key of the specific import group. </p>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::GroupName>,
    /// <p> The value of the specific import group. </p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl Group {
    /// <p> The key of the specific import group. </p>
    pub fn name(&self) -> std::option::Option<&crate::model::GroupName> {
        self.name.as_ref()
    }
    /// <p> The value of the specific import group. </p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`Group`](crate::model::Group).
pub mod group {

    /// A builder for [`Group`](crate::model::Group).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::GroupName>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The key of the specific import group. </p>
        pub fn name(mut self, input: crate::model::GroupName) -> Self {
            self.name = Some(input);
            self
        }
        /// <p> The key of the specific import group. </p>
        pub fn set_name(mut self, input: std::option::Option<crate::model::GroupName>) -> Self {
            self.name = input;
            self
        }
        /// <p> The value of the specific import group. </p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p> The value of the specific import group. </p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Group`](crate::model::Group).
        pub fn build(self) -> crate::model::Group {
            crate::model::Group {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl Group {
    /// Creates a new builder-style object to manufacture [`Group`](crate::model::Group).
    pub fn builder() -> crate::model::group::Builder {
        crate::model::group::Builder::default()
    }
}

/// When writing a match expression against `GroupName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let groupname = unimplemented!();
/// match groupname {
///     GroupName::ExternalId => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `groupname` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `GroupName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `GroupName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `GroupName::NewFeature` is defined.
/// Specifically, when `groupname` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `GroupName::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum GroupName {
    #[allow(missing_docs)] // documentation missing in model
    ExternalId,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for GroupName {
    fn from(s: &str) -> Self {
        match s {
            "ExternalId" => GroupName::ExternalId,
            other => GroupName::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for GroupName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(GroupName::from(s))
    }
}
impl GroupName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            GroupName::ExternalId => "ExternalId",
            GroupName::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ExternalId"]
    }
}
impl AsRef<str> for GroupName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `OutputFormat`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let outputformat = unimplemented!();
/// match outputformat {
///     OutputFormat::Excel => { /* ... */ },
///     OutputFormat::Json => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `outputformat` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `OutputFormat::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `OutputFormat::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `OutputFormat::NewFeature` is defined.
/// Specifically, when `outputformat` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `OutputFormat::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OutputFormat {
    #[allow(missing_docs)] // documentation missing in model
    Excel,
    #[allow(missing_docs)] // documentation missing in model
    Json,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for OutputFormat {
    fn from(s: &str) -> Self {
        match s {
            "Excel" => OutputFormat::Excel,
            "Json" => OutputFormat::Json,
            other => OutputFormat::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for OutputFormat {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OutputFormat::from(s))
    }
}
impl OutputFormat {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OutputFormat::Excel => "Excel",
            OutputFormat::Json => "Json",
            OutputFormat::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Excel", "Json"]
    }
}
impl AsRef<str> for OutputFormat {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `DataSourceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let datasourcetype = unimplemented!();
/// match datasourcetype {
///     DataSourceType::Ads => { /* ... */ },
///     DataSourceType::Mpa => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `datasourcetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DataSourceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DataSourceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DataSourceType::NewFeature` is defined.
/// Specifically, when `datasourcetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DataSourceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataSourceType {
    #[allow(missing_docs)] // documentation missing in model
    Ads,
    #[allow(missing_docs)] // documentation missing in model
    Mpa,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DataSourceType {
    fn from(s: &str) -> Self {
        match s {
            "ApplicationDiscoveryService" => DataSourceType::Ads,
            "MPA" => DataSourceType::Mpa,
            other => DataSourceType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DataSourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataSourceType::from(s))
    }
}
impl DataSourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DataSourceType::Ads => "ApplicationDiscoveryService",
            DataSourceType::Mpa => "MPA",
            DataSourceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ApplicationDiscoveryService", "MPA"]
    }
}
impl AsRef<str> for DataSourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Defines the criteria of assessment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssessmentTarget {
    /// <p>Condition of an assessment.</p>
    #[doc(hidden)]
    pub condition: std::option::Option<crate::model::Condition>,
    /// <p>Name of an assessment.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Values of an assessment.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl AssessmentTarget {
    /// <p>Condition of an assessment.</p>
    pub fn condition(&self) -> std::option::Option<&crate::model::Condition> {
        self.condition.as_ref()
    }
    /// <p>Name of an assessment.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Values of an assessment.</p>
    pub fn values(&self) -> std::option::Option<&[std::string::String]> {
        self.values.as_deref()
    }
}
/// See [`AssessmentTarget`](crate::model::AssessmentTarget).
pub mod assessment_target {

    /// A builder for [`AssessmentTarget`](crate::model::AssessmentTarget).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) condition: std::option::Option<crate::model::Condition>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>Condition of an assessment.</p>
        pub fn condition(mut self, input: crate::model::Condition) -> Self {
            self.condition = Some(input);
            self
        }
        /// <p>Condition of an assessment.</p>
        pub fn set_condition(
            mut self,
            input: std::option::Option<crate::model::Condition>,
        ) -> Self {
            self.condition = input;
            self
        }
        /// <p>Name of an assessment.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Name of an assessment.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>Values of an assessment.</p>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        /// <p>Values of an assessment.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`AssessmentTarget`](crate::model::AssessmentTarget).
        pub fn build(self) -> crate::model::AssessmentTarget {
            crate::model::AssessmentTarget {
                condition: self.condition,
                name: self.name,
                values: self.values,
            }
        }
    }
}
impl AssessmentTarget {
    /// Creates a new builder-style object to manufacture [`AssessmentTarget`](crate::model::AssessmentTarget).
    pub fn builder() -> crate::model::assessment_target::Builder {
        crate::model::assessment_target::Builder::default()
    }
}

/// When writing a match expression against `Condition`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let condition = unimplemented!();
/// match condition {
///     Condition::Contains => { /* ... */ },
///     Condition::Equals => { /* ... */ },
///     Condition::NotContains => { /* ... */ },
///     Condition::NotEquals => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `condition` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Condition::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Condition::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Condition::NewFeature` is defined.
/// Specifically, when `condition` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Condition::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Condition {
    #[allow(missing_docs)] // documentation missing in model
    Contains,
    #[allow(missing_docs)] // documentation missing in model
    Equals,
    #[allow(missing_docs)] // documentation missing in model
    NotContains,
    #[allow(missing_docs)] // documentation missing in model
    NotEquals,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Condition {
    fn from(s: &str) -> Self {
        match s {
            "CONTAINS" => Condition::Contains,
            "EQUALS" => Condition::Equals,
            "NOT_CONTAINS" => Condition::NotContains,
            "NOT_EQUALS" => Condition::NotEquals,
            other => Condition::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Condition {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Condition::from(s))
    }
}
impl Condition {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Condition::Contains => "CONTAINS",
            Condition::Equals => "EQUALS",
            Condition::NotContains => "NOT_CONTAINS",
            Condition::NotEquals => "NOT_EQUALS",
            Condition::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CONTAINS", "EQUALS", "NOT_CONTAINS", "NOT_EQUALS"]
    }
}
impl AsRef<str> for Condition {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ApplicationMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let applicationmode = unimplemented!();
/// match applicationmode {
///     ApplicationMode::All => { /* ... */ },
///     ApplicationMode::Known => { /* ... */ },
///     ApplicationMode::UnknownValue => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `applicationmode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ApplicationMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ApplicationMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ApplicationMode::NewFeature` is defined.
/// Specifically, when `applicationmode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ApplicationMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// _Note: `ApplicationMode::Unknown` has been renamed to `::UnknownValue`._
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ApplicationMode {
    #[allow(missing_docs)] // documentation missing in model
    All,
    #[allow(missing_docs)] // documentation missing in model
    Known,
    /// _Note: `::Unknown` has been renamed to `::UnknownValue`._
    UnknownValue,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ApplicationMode {
    fn from(s: &str) -> Self {
        match s {
            "ALL" => ApplicationMode::All,
            "KNOWN" => ApplicationMode::Known,
            "UNKNOWN" => ApplicationMode::UnknownValue,
            other => ApplicationMode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ApplicationMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ApplicationMode::from(s))
    }
}
impl ApplicationMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ApplicationMode::All => "ALL",
            ApplicationMode::Known => "KNOWN",
            ApplicationMode::UnknownValue => "UNKNOWN",
            ApplicationMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALL", "KNOWN", "UNKNOWN"]
    }
}
impl AsRef<str> for ApplicationMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> Preferences on managing your databases on AWS. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DatabasePreferences {
    /// <p> Specifies whether you're interested in self-managed databases or databases managed by AWS. </p>
    #[doc(hidden)]
    pub database_management_preference:
        std::option::Option<crate::model::DatabaseManagementPreference>,
    /// <p> Specifies your preferred migration path. </p>
    #[doc(hidden)]
    pub database_migration_preference:
        std::option::Option<crate::model::DatabaseMigrationPreference>,
}
impl DatabasePreferences {
    /// <p> Specifies whether you're interested in self-managed databases or databases managed by AWS. </p>
    pub fn database_management_preference(
        &self,
    ) -> std::option::Option<&crate::model::DatabaseManagementPreference> {
        self.database_management_preference.as_ref()
    }
    /// <p> Specifies your preferred migration path. </p>
    pub fn database_migration_preference(
        &self,
    ) -> std::option::Option<&crate::model::DatabaseMigrationPreference> {
        self.database_migration_preference.as_ref()
    }
}
/// See [`DatabasePreferences`](crate::model::DatabasePreferences).
pub mod database_preferences {

    /// A builder for [`DatabasePreferences`](crate::model::DatabasePreferences).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) database_management_preference:
            std::option::Option<crate::model::DatabaseManagementPreference>,
        pub(crate) database_migration_preference:
            std::option::Option<crate::model::DatabaseMigrationPreference>,
    }
    impl Builder {
        /// <p> Specifies whether you're interested in self-managed databases or databases managed by AWS. </p>
        pub fn database_management_preference(
            mut self,
            input: crate::model::DatabaseManagementPreference,
        ) -> Self {
            self.database_management_preference = Some(input);
            self
        }
        /// <p> Specifies whether you're interested in self-managed databases or databases managed by AWS. </p>
        pub fn set_database_management_preference(
            mut self,
            input: std::option::Option<crate::model::DatabaseManagementPreference>,
        ) -> Self {
            self.database_management_preference = input;
            self
        }
        /// <p> Specifies your preferred migration path. </p>
        pub fn database_migration_preference(
            mut self,
            input: crate::model::DatabaseMigrationPreference,
        ) -> Self {
            self.database_migration_preference = Some(input);
            self
        }
        /// <p> Specifies your preferred migration path. </p>
        pub fn set_database_migration_preference(
            mut self,
            input: std::option::Option<crate::model::DatabaseMigrationPreference>,
        ) -> Self {
            self.database_migration_preference = input;
            self
        }
        /// Consumes the builder and constructs a [`DatabasePreferences`](crate::model::DatabasePreferences).
        pub fn build(self) -> crate::model::DatabasePreferences {
            crate::model::DatabasePreferences {
                database_management_preference: self.database_management_preference,
                database_migration_preference: self.database_migration_preference,
            }
        }
    }
}
impl DatabasePreferences {
    /// Creates a new builder-style object to manufacture [`DatabasePreferences`](crate::model::DatabasePreferences).
    pub fn builder() -> crate::model::database_preferences::Builder {
        crate::model::database_preferences::Builder::default()
    }
}

/// <p> Preferences for migrating a database to AWS. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum DatabaseMigrationPreference {
    /// <p> Indicates whether you are interested in moving from one type of database to another. For example, from SQL Server to Amazon Aurora MySQL-Compatible Edition. </p>
    Heterogeneous(crate::model::Heterogeneous),
    /// <p> Indicates whether you are interested in moving to the same type of database into AWS. For example, from SQL Server in your environment to SQL Server on AWS. </p>
    Homogeneous(crate::model::Homogeneous),
    /// <p> Indicated that you do not prefer heterogeneous or homogeneous. </p>
    NoPreference(crate::model::NoDatabaseMigrationPreference),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl DatabaseMigrationPreference {
    /// Tries to convert the enum instance into [`Heterogeneous`](crate::model::DatabaseMigrationPreference::Heterogeneous), extracting the inner [`Heterogeneous`](crate::model::Heterogeneous).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_heterogeneous(&self) -> std::result::Result<&crate::model::Heterogeneous, &Self> {
        if let DatabaseMigrationPreference::Heterogeneous(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Heterogeneous`](crate::model::DatabaseMigrationPreference::Heterogeneous).
    pub fn is_heterogeneous(&self) -> bool {
        self.as_heterogeneous().is_ok()
    }
    /// Tries to convert the enum instance into [`Homogeneous`](crate::model::DatabaseMigrationPreference::Homogeneous), extracting the inner [`Homogeneous`](crate::model::Homogeneous).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_homogeneous(&self) -> std::result::Result<&crate::model::Homogeneous, &Self> {
        if let DatabaseMigrationPreference::Homogeneous(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Homogeneous`](crate::model::DatabaseMigrationPreference::Homogeneous).
    pub fn is_homogeneous(&self) -> bool {
        self.as_homogeneous().is_ok()
    }
    /// Tries to convert the enum instance into [`NoPreference`](crate::model::DatabaseMigrationPreference::NoPreference), extracting the inner [`NoDatabaseMigrationPreference`](crate::model::NoDatabaseMigrationPreference).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_no_preference(
        &self,
    ) -> std::result::Result<&crate::model::NoDatabaseMigrationPreference, &Self> {
        if let DatabaseMigrationPreference::NoPreference(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`NoPreference`](crate::model::DatabaseMigrationPreference::NoPreference).
    pub fn is_no_preference(&self) -> bool {
        self.as_no_preference().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p> The object containing details about database migration preferences, when you have no particular preference. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NoDatabaseMigrationPreference {
    /// <p> The target database engine for database migration preference that you specify. </p>
    #[doc(hidden)]
    pub target_database_engine:
        std::option::Option<std::vec::Vec<crate::model::TargetDatabaseEngine>>,
}
impl NoDatabaseMigrationPreference {
    /// <p> The target database engine for database migration preference that you specify. </p>
    pub fn target_database_engine(
        &self,
    ) -> std::option::Option<&[crate::model::TargetDatabaseEngine]> {
        self.target_database_engine.as_deref()
    }
}
/// See [`NoDatabaseMigrationPreference`](crate::model::NoDatabaseMigrationPreference).
pub mod no_database_migration_preference {

    /// A builder for [`NoDatabaseMigrationPreference`](crate::model::NoDatabaseMigrationPreference).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) target_database_engine:
            std::option::Option<std::vec::Vec<crate::model::TargetDatabaseEngine>>,
    }
    impl Builder {
        /// Appends an item to `target_database_engine`.
        ///
        /// To override the contents of this collection use [`set_target_database_engine`](Self::set_target_database_engine).
        ///
        /// <p> The target database engine for database migration preference that you specify. </p>
        pub fn target_database_engine(mut self, input: crate::model::TargetDatabaseEngine) -> Self {
            let mut v = self.target_database_engine.unwrap_or_default();
            v.push(input);
            self.target_database_engine = Some(v);
            self
        }
        /// <p> The target database engine for database migration preference that you specify. </p>
        pub fn set_target_database_engine(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TargetDatabaseEngine>>,
        ) -> Self {
            self.target_database_engine = input;
            self
        }
        /// Consumes the builder and constructs a [`NoDatabaseMigrationPreference`](crate::model::NoDatabaseMigrationPreference).
        pub fn build(self) -> crate::model::NoDatabaseMigrationPreference {
            crate::model::NoDatabaseMigrationPreference {
                target_database_engine: self.target_database_engine,
            }
        }
    }
}
impl NoDatabaseMigrationPreference {
    /// Creates a new builder-style object to manufacture [`NoDatabaseMigrationPreference`](crate::model::NoDatabaseMigrationPreference).
    pub fn builder() -> crate::model::no_database_migration_preference::Builder {
        crate::model::no_database_migration_preference::Builder::default()
    }
}

/// When writing a match expression against `TargetDatabaseEngine`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let targetdatabaseengine = unimplemented!();
/// match targetdatabaseengine {
///     TargetDatabaseEngine::AwsPostgresql => { /* ... */ },
///     TargetDatabaseEngine::AmazonAurora => { /* ... */ },
///     TargetDatabaseEngine::Db2Luw => { /* ... */ },
///     TargetDatabaseEngine::MariaDb => { /* ... */ },
///     TargetDatabaseEngine::MicrosoftSqlServer => { /* ... */ },
///     TargetDatabaseEngine::MongoDb => { /* ... */ },
///     TargetDatabaseEngine::Mysql => { /* ... */ },
///     TargetDatabaseEngine::NoneSpecified => { /* ... */ },
///     TargetDatabaseEngine::OracleDatabase => { /* ... */ },
///     TargetDatabaseEngine::Sap => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `targetdatabaseengine` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TargetDatabaseEngine::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TargetDatabaseEngine::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TargetDatabaseEngine::NewFeature` is defined.
/// Specifically, when `targetdatabaseengine` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TargetDatabaseEngine::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TargetDatabaseEngine {
    #[allow(missing_docs)] // documentation missing in model
    AwsPostgresql,
    #[allow(missing_docs)] // documentation missing in model
    AmazonAurora,
    #[allow(missing_docs)] // documentation missing in model
    Db2Luw,
    #[allow(missing_docs)] // documentation missing in model
    MariaDb,
    #[allow(missing_docs)] // documentation missing in model
    MicrosoftSqlServer,
    #[allow(missing_docs)] // documentation missing in model
    MongoDb,
    #[allow(missing_docs)] // documentation missing in model
    Mysql,
    #[allow(missing_docs)] // documentation missing in model
    NoneSpecified,
    #[allow(missing_docs)] // documentation missing in model
    OracleDatabase,
    #[allow(missing_docs)] // documentation missing in model
    Sap,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TargetDatabaseEngine {
    fn from(s: &str) -> Self {
        match s {
            "AWS PostgreSQL" => TargetDatabaseEngine::AwsPostgresql,
            "Amazon Aurora" => TargetDatabaseEngine::AmazonAurora,
            "Db2 LUW" => TargetDatabaseEngine::Db2Luw,
            "MariaDB" => TargetDatabaseEngine::MariaDb,
            "Microsoft SQL Server" => TargetDatabaseEngine::MicrosoftSqlServer,
            "MongoDB" => TargetDatabaseEngine::MongoDb,
            "MySQL" => TargetDatabaseEngine::Mysql,
            "None specified" => TargetDatabaseEngine::NoneSpecified,
            "Oracle Database" => TargetDatabaseEngine::OracleDatabase,
            "SAP" => TargetDatabaseEngine::Sap,
            other => {
                TargetDatabaseEngine::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for TargetDatabaseEngine {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TargetDatabaseEngine::from(s))
    }
}
impl TargetDatabaseEngine {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TargetDatabaseEngine::AwsPostgresql => "AWS PostgreSQL",
            TargetDatabaseEngine::AmazonAurora => "Amazon Aurora",
            TargetDatabaseEngine::Db2Luw => "Db2 LUW",
            TargetDatabaseEngine::MariaDb => "MariaDB",
            TargetDatabaseEngine::MicrosoftSqlServer => "Microsoft SQL Server",
            TargetDatabaseEngine::MongoDb => "MongoDB",
            TargetDatabaseEngine::Mysql => "MySQL",
            TargetDatabaseEngine::NoneSpecified => "None specified",
            TargetDatabaseEngine::OracleDatabase => "Oracle Database",
            TargetDatabaseEngine::Sap => "SAP",
            TargetDatabaseEngine::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AWS PostgreSQL",
            "Amazon Aurora",
            "Db2 LUW",
            "MariaDB",
            "Microsoft SQL Server",
            "MongoDB",
            "MySQL",
            "None specified",
            "Oracle Database",
            "SAP",
        ]
    }
}
impl AsRef<str> for TargetDatabaseEngine {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> The object containing details about homogeneous database preferences. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Homogeneous {
    /// <p> The target database engine for homogeneous database migration preferences. </p>
    #[doc(hidden)]
    pub target_database_engine:
        std::option::Option<std::vec::Vec<crate::model::HomogeneousTargetDatabaseEngine>>,
}
impl Homogeneous {
    /// <p> The target database engine for homogeneous database migration preferences. </p>
    pub fn target_database_engine(
        &self,
    ) -> std::option::Option<&[crate::model::HomogeneousTargetDatabaseEngine]> {
        self.target_database_engine.as_deref()
    }
}
/// See [`Homogeneous`](crate::model::Homogeneous).
pub mod homogeneous {

    /// A builder for [`Homogeneous`](crate::model::Homogeneous).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) target_database_engine:
            std::option::Option<std::vec::Vec<crate::model::HomogeneousTargetDatabaseEngine>>,
    }
    impl Builder {
        /// Appends an item to `target_database_engine`.
        ///
        /// To override the contents of this collection use [`set_target_database_engine`](Self::set_target_database_engine).
        ///
        /// <p> The target database engine for homogeneous database migration preferences. </p>
        pub fn target_database_engine(
            mut self,
            input: crate::model::HomogeneousTargetDatabaseEngine,
        ) -> Self {
            let mut v = self.target_database_engine.unwrap_or_default();
            v.push(input);
            self.target_database_engine = Some(v);
            self
        }
        /// <p> The target database engine for homogeneous database migration preferences. </p>
        pub fn set_target_database_engine(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::HomogeneousTargetDatabaseEngine>,
            >,
        ) -> Self {
            self.target_database_engine = input;
            self
        }
        /// Consumes the builder and constructs a [`Homogeneous`](crate::model::Homogeneous).
        pub fn build(self) -> crate::model::Homogeneous {
            crate::model::Homogeneous {
                target_database_engine: self.target_database_engine,
            }
        }
    }
}
impl Homogeneous {
    /// Creates a new builder-style object to manufacture [`Homogeneous`](crate::model::Homogeneous).
    pub fn builder() -> crate::model::homogeneous::Builder {
        crate::model::homogeneous::Builder::default()
    }
}

/// When writing a match expression against `HomogeneousTargetDatabaseEngine`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let homogeneoustargetdatabaseengine = unimplemented!();
/// match homogeneoustargetdatabaseengine {
///     HomogeneousTargetDatabaseEngine::NoneSpecified => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `homogeneoustargetdatabaseengine` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `HomogeneousTargetDatabaseEngine::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `HomogeneousTargetDatabaseEngine::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `HomogeneousTargetDatabaseEngine::NewFeature` is defined.
/// Specifically, when `homogeneoustargetdatabaseengine` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `HomogeneousTargetDatabaseEngine::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HomogeneousTargetDatabaseEngine {
    #[allow(missing_docs)] // documentation missing in model
    NoneSpecified,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for HomogeneousTargetDatabaseEngine {
    fn from(s: &str) -> Self {
        match s {
            "None specified" => HomogeneousTargetDatabaseEngine::NoneSpecified,
            other => HomogeneousTargetDatabaseEngine::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for HomogeneousTargetDatabaseEngine {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HomogeneousTargetDatabaseEngine::from(s))
    }
}
impl HomogeneousTargetDatabaseEngine {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            HomogeneousTargetDatabaseEngine::NoneSpecified => "None specified",
            HomogeneousTargetDatabaseEngine::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["None specified"]
    }
}
impl AsRef<str> for HomogeneousTargetDatabaseEngine {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> The object containing details about heterogeneous database preferences. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Heterogeneous {
    /// <p> The target database engine for heterogeneous database migration preference. </p>
    #[doc(hidden)]
    pub target_database_engine:
        std::option::Option<std::vec::Vec<crate::model::HeterogeneousTargetDatabaseEngine>>,
}
impl Heterogeneous {
    /// <p> The target database engine for heterogeneous database migration preference. </p>
    pub fn target_database_engine(
        &self,
    ) -> std::option::Option<&[crate::model::HeterogeneousTargetDatabaseEngine]> {
        self.target_database_engine.as_deref()
    }
}
/// See [`Heterogeneous`](crate::model::Heterogeneous).
pub mod heterogeneous {

    /// A builder for [`Heterogeneous`](crate::model::Heterogeneous).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) target_database_engine:
            std::option::Option<std::vec::Vec<crate::model::HeterogeneousTargetDatabaseEngine>>,
    }
    impl Builder {
        /// Appends an item to `target_database_engine`.
        ///
        /// To override the contents of this collection use [`set_target_database_engine`](Self::set_target_database_engine).
        ///
        /// <p> The target database engine for heterogeneous database migration preference. </p>
        pub fn target_database_engine(
            mut self,
            input: crate::model::HeterogeneousTargetDatabaseEngine,
        ) -> Self {
            let mut v = self.target_database_engine.unwrap_or_default();
            v.push(input);
            self.target_database_engine = Some(v);
            self
        }
        /// <p> The target database engine for heterogeneous database migration preference. </p>
        pub fn set_target_database_engine(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::HeterogeneousTargetDatabaseEngine>,
            >,
        ) -> Self {
            self.target_database_engine = input;
            self
        }
        /// Consumes the builder and constructs a [`Heterogeneous`](crate::model::Heterogeneous).
        pub fn build(self) -> crate::model::Heterogeneous {
            crate::model::Heterogeneous {
                target_database_engine: self.target_database_engine,
            }
        }
    }
}
impl Heterogeneous {
    /// Creates a new builder-style object to manufacture [`Heterogeneous`](crate::model::Heterogeneous).
    pub fn builder() -> crate::model::heterogeneous::Builder {
        crate::model::heterogeneous::Builder::default()
    }
}

/// When writing a match expression against `HeterogeneousTargetDatabaseEngine`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let heterogeneoustargetdatabaseengine = unimplemented!();
/// match heterogeneoustargetdatabaseengine {
///     HeterogeneousTargetDatabaseEngine::AwsPostgresql => { /* ... */ },
///     HeterogeneousTargetDatabaseEngine::AmazonAurora => { /* ... */ },
///     HeterogeneousTargetDatabaseEngine::Db2Luw => { /* ... */ },
///     HeterogeneousTargetDatabaseEngine::MariaDb => { /* ... */ },
///     HeterogeneousTargetDatabaseEngine::MicrosoftSqlServer => { /* ... */ },
///     HeterogeneousTargetDatabaseEngine::MongoDb => { /* ... */ },
///     HeterogeneousTargetDatabaseEngine::Mysql => { /* ... */ },
///     HeterogeneousTargetDatabaseEngine::NoneSpecified => { /* ... */ },
///     HeterogeneousTargetDatabaseEngine::OracleDatabase => { /* ... */ },
///     HeterogeneousTargetDatabaseEngine::Sap => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `heterogeneoustargetdatabaseengine` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `HeterogeneousTargetDatabaseEngine::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `HeterogeneousTargetDatabaseEngine::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `HeterogeneousTargetDatabaseEngine::NewFeature` is defined.
/// Specifically, when `heterogeneoustargetdatabaseengine` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `HeterogeneousTargetDatabaseEngine::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HeterogeneousTargetDatabaseEngine {
    #[allow(missing_docs)] // documentation missing in model
    AwsPostgresql,
    #[allow(missing_docs)] // documentation missing in model
    AmazonAurora,
    #[allow(missing_docs)] // documentation missing in model
    Db2Luw,
    #[allow(missing_docs)] // documentation missing in model
    MariaDb,
    #[allow(missing_docs)] // documentation missing in model
    MicrosoftSqlServer,
    #[allow(missing_docs)] // documentation missing in model
    MongoDb,
    #[allow(missing_docs)] // documentation missing in model
    Mysql,
    #[allow(missing_docs)] // documentation missing in model
    NoneSpecified,
    #[allow(missing_docs)] // documentation missing in model
    OracleDatabase,
    #[allow(missing_docs)] // documentation missing in model
    Sap,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for HeterogeneousTargetDatabaseEngine {
    fn from(s: &str) -> Self {
        match s {
            "AWS PostgreSQL" => HeterogeneousTargetDatabaseEngine::AwsPostgresql,
            "Amazon Aurora" => HeterogeneousTargetDatabaseEngine::AmazonAurora,
            "Db2 LUW" => HeterogeneousTargetDatabaseEngine::Db2Luw,
            "MariaDB" => HeterogeneousTargetDatabaseEngine::MariaDb,
            "Microsoft SQL Server" => HeterogeneousTargetDatabaseEngine::MicrosoftSqlServer,
            "MongoDB" => HeterogeneousTargetDatabaseEngine::MongoDb,
            "MySQL" => HeterogeneousTargetDatabaseEngine::Mysql,
            "None specified" => HeterogeneousTargetDatabaseEngine::NoneSpecified,
            "Oracle Database" => HeterogeneousTargetDatabaseEngine::OracleDatabase,
            "SAP" => HeterogeneousTargetDatabaseEngine::Sap,
            other => HeterogeneousTargetDatabaseEngine::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for HeterogeneousTargetDatabaseEngine {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HeterogeneousTargetDatabaseEngine::from(s))
    }
}
impl HeterogeneousTargetDatabaseEngine {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            HeterogeneousTargetDatabaseEngine::AwsPostgresql => "AWS PostgreSQL",
            HeterogeneousTargetDatabaseEngine::AmazonAurora => "Amazon Aurora",
            HeterogeneousTargetDatabaseEngine::Db2Luw => "Db2 LUW",
            HeterogeneousTargetDatabaseEngine::MariaDb => "MariaDB",
            HeterogeneousTargetDatabaseEngine::MicrosoftSqlServer => "Microsoft SQL Server",
            HeterogeneousTargetDatabaseEngine::MongoDb => "MongoDB",
            HeterogeneousTargetDatabaseEngine::Mysql => "MySQL",
            HeterogeneousTargetDatabaseEngine::NoneSpecified => "None specified",
            HeterogeneousTargetDatabaseEngine::OracleDatabase => "Oracle Database",
            HeterogeneousTargetDatabaseEngine::Sap => "SAP",
            HeterogeneousTargetDatabaseEngine::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AWS PostgreSQL",
            "Amazon Aurora",
            "Db2 LUW",
            "MariaDB",
            "Microsoft SQL Server",
            "MongoDB",
            "MySQL",
            "None specified",
            "Oracle Database",
            "SAP",
        ]
    }
}
impl AsRef<str> for HeterogeneousTargetDatabaseEngine {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `DatabaseManagementPreference`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let databasemanagementpreference = unimplemented!();
/// match databasemanagementpreference {
///     DatabaseManagementPreference::AwsManaged => { /* ... */ },
///     DatabaseManagementPreference::NoPreference => { /* ... */ },
///     DatabaseManagementPreference::SelfManage => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `databasemanagementpreference` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DatabaseManagementPreference::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DatabaseManagementPreference::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DatabaseManagementPreference::NewFeature` is defined.
/// Specifically, when `databasemanagementpreference` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DatabaseManagementPreference::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DatabaseManagementPreference {
    #[allow(missing_docs)] // documentation missing in model
    AwsManaged,
    #[allow(missing_docs)] // documentation missing in model
    NoPreference,
    #[allow(missing_docs)] // documentation missing in model
    SelfManage,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DatabaseManagementPreference {
    fn from(s: &str) -> Self {
        match s {
            "AWS-managed" => DatabaseManagementPreference::AwsManaged,
            "No preference" => DatabaseManagementPreference::NoPreference,
            "Self-manage" => DatabaseManagementPreference::SelfManage,
            other => DatabaseManagementPreference::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for DatabaseManagementPreference {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DatabaseManagementPreference::from(s))
    }
}
impl DatabaseManagementPreference {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DatabaseManagementPreference::AwsManaged => "AWS-managed",
            DatabaseManagementPreference::NoPreference => "No preference",
            DatabaseManagementPreference::SelfManage => "Self-manage",
            DatabaseManagementPreference::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AWS-managed", "No preference", "Self-manage"]
    }
}
impl AsRef<str> for DatabaseManagementPreference {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> Application preferences that you specify. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ApplicationPreferences {
    /// <p> Application preferences that you specify to prefer managed environment. </p>
    #[doc(hidden)]
    pub management_preference: std::option::Option<crate::model::ManagementPreference>,
}
impl ApplicationPreferences {
    /// <p> Application preferences that you specify to prefer managed environment. </p>
    pub fn management_preference(
        &self,
    ) -> std::option::Option<&crate::model::ManagementPreference> {
        self.management_preference.as_ref()
    }
}
/// See [`ApplicationPreferences`](crate::model::ApplicationPreferences).
pub mod application_preferences {

    /// A builder for [`ApplicationPreferences`](crate::model::ApplicationPreferences).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) management_preference: std::option::Option<crate::model::ManagementPreference>,
    }
    impl Builder {
        /// <p> Application preferences that you specify to prefer managed environment. </p>
        pub fn management_preference(mut self, input: crate::model::ManagementPreference) -> Self {
            self.management_preference = Some(input);
            self
        }
        /// <p> Application preferences that you specify to prefer managed environment. </p>
        pub fn set_management_preference(
            mut self,
            input: std::option::Option<crate::model::ManagementPreference>,
        ) -> Self {
            self.management_preference = input;
            self
        }
        /// Consumes the builder and constructs a [`ApplicationPreferences`](crate::model::ApplicationPreferences).
        pub fn build(self) -> crate::model::ApplicationPreferences {
            crate::model::ApplicationPreferences {
                management_preference: self.management_preference,
            }
        }
    }
}
impl ApplicationPreferences {
    /// Creates a new builder-style object to manufacture [`ApplicationPreferences`](crate::model::ApplicationPreferences).
    pub fn builder() -> crate::model::application_preferences::Builder {
        crate::model::application_preferences::Builder::default()
    }
}

/// <p> Preferences for migrating an application to AWS. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum ManagementPreference {
    /// <p> Indicates interest in solutions that are managed by AWS. </p>
    AwsManagedResources(crate::model::AwsManagedResources),
    /// <p> No specific preference. </p>
    NoPreference(crate::model::NoManagementPreference),
    /// <p> Indicates interest in managing your own resources on AWS. </p>
    SelfManageResources(crate::model::SelfManageResources),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl ManagementPreference {
    /// Tries to convert the enum instance into [`AwsManagedResources`](crate::model::ManagementPreference::AwsManagedResources), extracting the inner [`AwsManagedResources`](crate::model::AwsManagedResources).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_aws_managed_resources(
        &self,
    ) -> std::result::Result<&crate::model::AwsManagedResources, &Self> {
        if let ManagementPreference::AwsManagedResources(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`AwsManagedResources`](crate::model::ManagementPreference::AwsManagedResources).
    pub fn is_aws_managed_resources(&self) -> bool {
        self.as_aws_managed_resources().is_ok()
    }
    /// Tries to convert the enum instance into [`NoPreference`](crate::model::ManagementPreference::NoPreference), extracting the inner [`NoManagementPreference`](crate::model::NoManagementPreference).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_no_preference(
        &self,
    ) -> std::result::Result<&crate::model::NoManagementPreference, &Self> {
        if let ManagementPreference::NoPreference(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`NoPreference`](crate::model::ManagementPreference::NoPreference).
    pub fn is_no_preference(&self) -> bool {
        self.as_no_preference().is_ok()
    }
    /// Tries to convert the enum instance into [`SelfManageResources`](crate::model::ManagementPreference::SelfManageResources), extracting the inner [`SelfManageResources`](crate::model::SelfManageResources).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_self_manage_resources(
        &self,
    ) -> std::result::Result<&crate::model::SelfManageResources, &Self> {
        if let ManagementPreference::SelfManageResources(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`SelfManageResources`](crate::model::ManagementPreference::SelfManageResources).
    pub fn is_self_manage_resources(&self) -> bool {
        self.as_self_manage_resources().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p> Object containing the choice of application destination that you specify. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NoManagementPreference {
    /// <p> The choice of application destination that you specify. </p>
    #[doc(hidden)]
    pub target_destination:
        std::option::Option<std::vec::Vec<crate::model::NoPreferenceTargetDestination>>,
}
impl NoManagementPreference {
    /// <p> The choice of application destination that you specify. </p>
    pub fn target_destination(
        &self,
    ) -> std::option::Option<&[crate::model::NoPreferenceTargetDestination]> {
        self.target_destination.as_deref()
    }
}
/// See [`NoManagementPreference`](crate::model::NoManagementPreference).
pub mod no_management_preference {

    /// A builder for [`NoManagementPreference`](crate::model::NoManagementPreference).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) target_destination:
            std::option::Option<std::vec::Vec<crate::model::NoPreferenceTargetDestination>>,
    }
    impl Builder {
        /// Appends an item to `target_destination`.
        ///
        /// To override the contents of this collection use [`set_target_destination`](Self::set_target_destination).
        ///
        /// <p> The choice of application destination that you specify. </p>
        pub fn target_destination(
            mut self,
            input: crate::model::NoPreferenceTargetDestination,
        ) -> Self {
            let mut v = self.target_destination.unwrap_or_default();
            v.push(input);
            self.target_destination = Some(v);
            self
        }
        /// <p> The choice of application destination that you specify. </p>
        pub fn set_target_destination(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NoPreferenceTargetDestination>>,
        ) -> Self {
            self.target_destination = input;
            self
        }
        /// Consumes the builder and constructs a [`NoManagementPreference`](crate::model::NoManagementPreference).
        pub fn build(self) -> crate::model::NoManagementPreference {
            crate::model::NoManagementPreference {
                target_destination: self.target_destination,
            }
        }
    }
}
impl NoManagementPreference {
    /// Creates a new builder-style object to manufacture [`NoManagementPreference`](crate::model::NoManagementPreference).
    pub fn builder() -> crate::model::no_management_preference::Builder {
        crate::model::no_management_preference::Builder::default()
    }
}

/// When writing a match expression against `NoPreferenceTargetDestination`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let nopreferencetargetdestination = unimplemented!();
/// match nopreferencetargetdestination {
///     NoPreferenceTargetDestination::AwsElasticBeanstalk => { /* ... */ },
///     NoPreferenceTargetDestination::AwsFargate => { /* ... */ },
///     NoPreferenceTargetDestination::AmazonElasticCloudCompute => { /* ... */ },
///     NoPreferenceTargetDestination::AmazonElasticContainerService => { /* ... */ },
///     NoPreferenceTargetDestination::AmazonElasticKubernetesService => { /* ... */ },
///     NoPreferenceTargetDestination::NoneSpecified => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `nopreferencetargetdestination` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `NoPreferenceTargetDestination::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `NoPreferenceTargetDestination::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `NoPreferenceTargetDestination::NewFeature` is defined.
/// Specifically, when `nopreferencetargetdestination` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `NoPreferenceTargetDestination::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NoPreferenceTargetDestination {
    #[allow(missing_docs)] // documentation missing in model
    AwsElasticBeanstalk,
    #[allow(missing_docs)] // documentation missing in model
    AwsFargate,
    #[allow(missing_docs)] // documentation missing in model
    AmazonElasticCloudCompute,
    #[allow(missing_docs)] // documentation missing in model
    AmazonElasticContainerService,
    #[allow(missing_docs)] // documentation missing in model
    AmazonElasticKubernetesService,
    #[allow(missing_docs)] // documentation missing in model
    NoneSpecified,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for NoPreferenceTargetDestination {
    fn from(s: &str) -> Self {
        match s {
            "AWS Elastic BeanStalk" => NoPreferenceTargetDestination::AwsElasticBeanstalk,
            "AWS Fargate" => NoPreferenceTargetDestination::AwsFargate,
            "Amazon Elastic Cloud Compute (EC2)" => {
                NoPreferenceTargetDestination::AmazonElasticCloudCompute
            }
            "Amazon Elastic Container Service (ECS)" => {
                NoPreferenceTargetDestination::AmazonElasticContainerService
            }
            "Amazon Elastic Kubernetes Service (EKS)" => {
                NoPreferenceTargetDestination::AmazonElasticKubernetesService
            }
            "None specified" => NoPreferenceTargetDestination::NoneSpecified,
            other => NoPreferenceTargetDestination::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for NoPreferenceTargetDestination {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NoPreferenceTargetDestination::from(s))
    }
}
impl NoPreferenceTargetDestination {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NoPreferenceTargetDestination::AwsElasticBeanstalk => "AWS Elastic BeanStalk",
            NoPreferenceTargetDestination::AwsFargate => "AWS Fargate",
            NoPreferenceTargetDestination::AmazonElasticCloudCompute => {
                "Amazon Elastic Cloud Compute (EC2)"
            }
            NoPreferenceTargetDestination::AmazonElasticContainerService => {
                "Amazon Elastic Container Service (ECS)"
            }
            NoPreferenceTargetDestination::AmazonElasticKubernetesService => {
                "Amazon Elastic Kubernetes Service (EKS)"
            }
            NoPreferenceTargetDestination::NoneSpecified => "None specified",
            NoPreferenceTargetDestination::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AWS Elastic BeanStalk",
            "AWS Fargate",
            "Amazon Elastic Cloud Compute (EC2)",
            "Amazon Elastic Container Service (ECS)",
            "Amazon Elastic Kubernetes Service (EKS)",
            "None specified",
        ]
    }
}
impl AsRef<str> for NoPreferenceTargetDestination {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> Self-managed resources. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SelfManageResources {
    /// <p> Self-managed resources target destination. </p>
    #[doc(hidden)]
    pub target_destination:
        std::option::Option<std::vec::Vec<crate::model::SelfManageTargetDestination>>,
}
impl SelfManageResources {
    /// <p> Self-managed resources target destination. </p>
    pub fn target_destination(
        &self,
    ) -> std::option::Option<&[crate::model::SelfManageTargetDestination]> {
        self.target_destination.as_deref()
    }
}
/// See [`SelfManageResources`](crate::model::SelfManageResources).
pub mod self_manage_resources {

    /// A builder for [`SelfManageResources`](crate::model::SelfManageResources).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) target_destination:
            std::option::Option<std::vec::Vec<crate::model::SelfManageTargetDestination>>,
    }
    impl Builder {
        /// Appends an item to `target_destination`.
        ///
        /// To override the contents of this collection use [`set_target_destination`](Self::set_target_destination).
        ///
        /// <p> Self-managed resources target destination. </p>
        pub fn target_destination(
            mut self,
            input: crate::model::SelfManageTargetDestination,
        ) -> Self {
            let mut v = self.target_destination.unwrap_or_default();
            v.push(input);
            self.target_destination = Some(v);
            self
        }
        /// <p> Self-managed resources target destination. </p>
        pub fn set_target_destination(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SelfManageTargetDestination>>,
        ) -> Self {
            self.target_destination = input;
            self
        }
        /// Consumes the builder and constructs a [`SelfManageResources`](crate::model::SelfManageResources).
        pub fn build(self) -> crate::model::SelfManageResources {
            crate::model::SelfManageResources {
                target_destination: self.target_destination,
            }
        }
    }
}
impl SelfManageResources {
    /// Creates a new builder-style object to manufacture [`SelfManageResources`](crate::model::SelfManageResources).
    pub fn builder() -> crate::model::self_manage_resources::Builder {
        crate::model::self_manage_resources::Builder::default()
    }
}

/// When writing a match expression against `SelfManageTargetDestination`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let selfmanagetargetdestination = unimplemented!();
/// match selfmanagetargetdestination {
///     SelfManageTargetDestination::AmazonElasticCloudCompute => { /* ... */ },
///     SelfManageTargetDestination::AmazonElasticContainerService => { /* ... */ },
///     SelfManageTargetDestination::AmazonElasticKubernetesService => { /* ... */ },
///     SelfManageTargetDestination::NoneSpecified => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `selfmanagetargetdestination` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SelfManageTargetDestination::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SelfManageTargetDestination::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SelfManageTargetDestination::NewFeature` is defined.
/// Specifically, when `selfmanagetargetdestination` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SelfManageTargetDestination::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SelfManageTargetDestination {
    #[allow(missing_docs)] // documentation missing in model
    AmazonElasticCloudCompute,
    #[allow(missing_docs)] // documentation missing in model
    AmazonElasticContainerService,
    #[allow(missing_docs)] // documentation missing in model
    AmazonElasticKubernetesService,
    #[allow(missing_docs)] // documentation missing in model
    NoneSpecified,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SelfManageTargetDestination {
    fn from(s: &str) -> Self {
        match s {
            "Amazon Elastic Cloud Compute (EC2)" => {
                SelfManageTargetDestination::AmazonElasticCloudCompute
            }
            "Amazon Elastic Container Service (ECS)" => {
                SelfManageTargetDestination::AmazonElasticContainerService
            }
            "Amazon Elastic Kubernetes Service (EKS)" => {
                SelfManageTargetDestination::AmazonElasticKubernetesService
            }
            "None specified" => SelfManageTargetDestination::NoneSpecified,
            other => SelfManageTargetDestination::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for SelfManageTargetDestination {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SelfManageTargetDestination::from(s))
    }
}
impl SelfManageTargetDestination {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SelfManageTargetDestination::AmazonElasticCloudCompute => {
                "Amazon Elastic Cloud Compute (EC2)"
            }
            SelfManageTargetDestination::AmazonElasticContainerService => {
                "Amazon Elastic Container Service (ECS)"
            }
            SelfManageTargetDestination::AmazonElasticKubernetesService => {
                "Amazon Elastic Kubernetes Service (EKS)"
            }
            SelfManageTargetDestination::NoneSpecified => "None specified",
            SelfManageTargetDestination::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "Amazon Elastic Cloud Compute (EC2)",
            "Amazon Elastic Container Service (ECS)",
            "Amazon Elastic Kubernetes Service (EKS)",
            "None specified",
        ]
    }
}
impl AsRef<str> for SelfManageTargetDestination {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> Object containing the choice of application destination that you specify. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AwsManagedResources {
    /// <p> The choice of application destination that you specify. </p>
    #[doc(hidden)]
    pub target_destination:
        std::option::Option<std::vec::Vec<crate::model::AwsManagedTargetDestination>>,
}
impl AwsManagedResources {
    /// <p> The choice of application destination that you specify. </p>
    pub fn target_destination(
        &self,
    ) -> std::option::Option<&[crate::model::AwsManagedTargetDestination]> {
        self.target_destination.as_deref()
    }
}
/// See [`AwsManagedResources`](crate::model::AwsManagedResources).
pub mod aws_managed_resources {

    /// A builder for [`AwsManagedResources`](crate::model::AwsManagedResources).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) target_destination:
            std::option::Option<std::vec::Vec<crate::model::AwsManagedTargetDestination>>,
    }
    impl Builder {
        /// Appends an item to `target_destination`.
        ///
        /// To override the contents of this collection use [`set_target_destination`](Self::set_target_destination).
        ///
        /// <p> The choice of application destination that you specify. </p>
        pub fn target_destination(
            mut self,
            input: crate::model::AwsManagedTargetDestination,
        ) -> Self {
            let mut v = self.target_destination.unwrap_or_default();
            v.push(input);
            self.target_destination = Some(v);
            self
        }
        /// <p> The choice of application destination that you specify. </p>
        pub fn set_target_destination(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsManagedTargetDestination>>,
        ) -> Self {
            self.target_destination = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsManagedResources`](crate::model::AwsManagedResources).
        pub fn build(self) -> crate::model::AwsManagedResources {
            crate::model::AwsManagedResources {
                target_destination: self.target_destination,
            }
        }
    }
}
impl AwsManagedResources {
    /// Creates a new builder-style object to manufacture [`AwsManagedResources`](crate::model::AwsManagedResources).
    pub fn builder() -> crate::model::aws_managed_resources::Builder {
        crate::model::aws_managed_resources::Builder::default()
    }
}

/// When writing a match expression against `AwsManagedTargetDestination`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let awsmanagedtargetdestination = unimplemented!();
/// match awsmanagedtargetdestination {
///     AwsManagedTargetDestination::AwsElasticBeanstalk => { /* ... */ },
///     AwsManagedTargetDestination::AwsFargate => { /* ... */ },
///     AwsManagedTargetDestination::NoneSpecified => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `awsmanagedtargetdestination` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AwsManagedTargetDestination::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AwsManagedTargetDestination::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AwsManagedTargetDestination::NewFeature` is defined.
/// Specifically, when `awsmanagedtargetdestination` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AwsManagedTargetDestination::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AwsManagedTargetDestination {
    #[allow(missing_docs)] // documentation missing in model
    AwsElasticBeanstalk,
    #[allow(missing_docs)] // documentation missing in model
    AwsFargate,
    #[allow(missing_docs)] // documentation missing in model
    NoneSpecified,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AwsManagedTargetDestination {
    fn from(s: &str) -> Self {
        match s {
            "AWS Elastic BeanStalk" => AwsManagedTargetDestination::AwsElasticBeanstalk,
            "AWS Fargate" => AwsManagedTargetDestination::AwsFargate,
            "None specified" => AwsManagedTargetDestination::NoneSpecified,
            other => AwsManagedTargetDestination::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for AwsManagedTargetDestination {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AwsManagedTargetDestination::from(s))
    }
}
impl AwsManagedTargetDestination {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AwsManagedTargetDestination::AwsElasticBeanstalk => "AWS Elastic BeanStalk",
            AwsManagedTargetDestination::AwsFargate => "AWS Fargate",
            AwsManagedTargetDestination::NoneSpecified => "None specified",
            AwsManagedTargetDestination::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AWS Elastic BeanStalk", "AWS Fargate", "None specified"]
    }
}
impl AsRef<str> for AwsManagedTargetDestination {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> Rank of business goals based on priority. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PrioritizeBusinessGoals {
    /// <p> Rank of business goals based on priority. </p>
    #[doc(hidden)]
    pub business_goals: std::option::Option<crate::model::BusinessGoals>,
}
impl PrioritizeBusinessGoals {
    /// <p> Rank of business goals based on priority. </p>
    pub fn business_goals(&self) -> std::option::Option<&crate::model::BusinessGoals> {
        self.business_goals.as_ref()
    }
}
/// See [`PrioritizeBusinessGoals`](crate::model::PrioritizeBusinessGoals).
pub mod prioritize_business_goals {

    /// A builder for [`PrioritizeBusinessGoals`](crate::model::PrioritizeBusinessGoals).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) business_goals: std::option::Option<crate::model::BusinessGoals>,
    }
    impl Builder {
        /// <p> Rank of business goals based on priority. </p>
        pub fn business_goals(mut self, input: crate::model::BusinessGoals) -> Self {
            self.business_goals = Some(input);
            self
        }
        /// <p> Rank of business goals based on priority. </p>
        pub fn set_business_goals(
            mut self,
            input: std::option::Option<crate::model::BusinessGoals>,
        ) -> Self {
            self.business_goals = input;
            self
        }
        /// Consumes the builder and constructs a [`PrioritizeBusinessGoals`](crate::model::PrioritizeBusinessGoals).
        pub fn build(self) -> crate::model::PrioritizeBusinessGoals {
            crate::model::PrioritizeBusinessGoals {
                business_goals: self.business_goals,
            }
        }
    }
}
impl PrioritizeBusinessGoals {
    /// Creates a new builder-style object to manufacture [`PrioritizeBusinessGoals`](crate::model::PrioritizeBusinessGoals).
    pub fn builder() -> crate::model::prioritize_business_goals::Builder {
        crate::model::prioritize_business_goals::Builder::default()
    }
}

/// <p> Business goals that you specify. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BusinessGoals {
    /// <p> Business goal to achieve migration at a fast pace. </p>
    #[doc(hidden)]
    pub speed_of_migration: std::option::Option<i32>,
    /// <p> Business goal to reduce the operational overhead on the team by moving into managed services. </p>
    #[doc(hidden)]
    pub reduce_operational_overhead_with_managed_services: std::option::Option<i32>,
    /// <p> Business goal to modernize infrastructure by moving to cloud native technologies. </p>
    #[doc(hidden)]
    pub modernize_infrastructure_with_cloud_native_technologies: std::option::Option<i32>,
    /// <p> Business goal to reduce license costs. </p>
    #[doc(hidden)]
    pub license_cost_reduction: std::option::Option<i32>,
}
impl BusinessGoals {
    /// <p> Business goal to achieve migration at a fast pace. </p>
    pub fn speed_of_migration(&self) -> std::option::Option<i32> {
        self.speed_of_migration
    }
    /// <p> Business goal to reduce the operational overhead on the team by moving into managed services. </p>
    pub fn reduce_operational_overhead_with_managed_services(&self) -> std::option::Option<i32> {
        self.reduce_operational_overhead_with_managed_services
    }
    /// <p> Business goal to modernize infrastructure by moving to cloud native technologies. </p>
    pub fn modernize_infrastructure_with_cloud_native_technologies(
        &self,
    ) -> std::option::Option<i32> {
        self.modernize_infrastructure_with_cloud_native_technologies
    }
    /// <p> Business goal to reduce license costs. </p>
    pub fn license_cost_reduction(&self) -> std::option::Option<i32> {
        self.license_cost_reduction
    }
}
/// See [`BusinessGoals`](crate::model::BusinessGoals).
pub mod business_goals {

    /// A builder for [`BusinessGoals`](crate::model::BusinessGoals).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) speed_of_migration: std::option::Option<i32>,
        pub(crate) reduce_operational_overhead_with_managed_services: std::option::Option<i32>,
        pub(crate) modernize_infrastructure_with_cloud_native_technologies:
            std::option::Option<i32>,
        pub(crate) license_cost_reduction: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> Business goal to achieve migration at a fast pace. </p>
        pub fn speed_of_migration(mut self, input: i32) -> Self {
            self.speed_of_migration = Some(input);
            self
        }
        /// <p> Business goal to achieve migration at a fast pace. </p>
        pub fn set_speed_of_migration(mut self, input: std::option::Option<i32>) -> Self {
            self.speed_of_migration = input;
            self
        }
        /// <p> Business goal to reduce the operational overhead on the team by moving into managed services. </p>
        pub fn reduce_operational_overhead_with_managed_services(mut self, input: i32) -> Self {
            self.reduce_operational_overhead_with_managed_services = Some(input);
            self
        }
        /// <p> Business goal to reduce the operational overhead on the team by moving into managed services. </p>
        pub fn set_reduce_operational_overhead_with_managed_services(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.reduce_operational_overhead_with_managed_services = input;
            self
        }
        /// <p> Business goal to modernize infrastructure by moving to cloud native technologies. </p>
        pub fn modernize_infrastructure_with_cloud_native_technologies(
            mut self,
            input: i32,
        ) -> Self {
            self.modernize_infrastructure_with_cloud_native_technologies = Some(input);
            self
        }
        /// <p> Business goal to modernize infrastructure by moving to cloud native technologies. </p>
        pub fn set_modernize_infrastructure_with_cloud_native_technologies(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.modernize_infrastructure_with_cloud_native_technologies = input;
            self
        }
        /// <p> Business goal to reduce license costs. </p>
        pub fn license_cost_reduction(mut self, input: i32) -> Self {
            self.license_cost_reduction = Some(input);
            self
        }
        /// <p> Business goal to reduce license costs. </p>
        pub fn set_license_cost_reduction(mut self, input: std::option::Option<i32>) -> Self {
            self.license_cost_reduction = input;
            self
        }
        /// Consumes the builder and constructs a [`BusinessGoals`](crate::model::BusinessGoals).
        pub fn build(self) -> crate::model::BusinessGoals {
            crate::model::BusinessGoals {
                speed_of_migration: self.speed_of_migration,
                reduce_operational_overhead_with_managed_services: self
                    .reduce_operational_overhead_with_managed_services,
                modernize_infrastructure_with_cloud_native_technologies: self
                    .modernize_infrastructure_with_cloud_native_technologies,
                license_cost_reduction: self.license_cost_reduction,
            }
        }
    }
}
impl BusinessGoals {
    /// Creates a new builder-style object to manufacture [`BusinessGoals`](crate::model::BusinessGoals).
    pub fn builder() -> crate::model::business_goals::Builder {
        crate::model::business_goals::Builder::default()
    }
}

/// <p> Detailed information about a server. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServerDetail {
    /// <p> The server ID. </p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p> The name of the server. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p> A set of recommendations. </p>
    #[doc(hidden)]
    pub recommendation_set: std::option::Option<crate::model::RecommendationSet>,
    /// <p> The status of assessment for the server. </p>
    #[doc(hidden)]
    pub data_collection_status: std::option::Option<crate::model::RunTimeAssessmentStatus>,
    /// <p> A message about the status of data collection, which contains detailed descriptions of any error messages. </p>
    #[doc(hidden)]
    pub status_message: std::option::Option<std::string::String>,
    /// <p> A list of anti-pattern severity summaries. </p>
    #[doc(hidden)]
    pub list_antipattern_severity_summary:
        std::option::Option<std::vec::Vec<crate::model::AntipatternSeveritySummary>>,
    /// <p> System information about the server. </p>
    #[doc(hidden)]
    pub system_info: std::option::Option<crate::model::SystemInfo>,
    /// <p> A list of strategy summaries. </p>
    #[doc(hidden)]
    pub application_component_strategy_summary:
        std::option::Option<std::vec::Vec<crate::model::StrategySummary>>,
    /// <p> The S3 bucket name and Amazon S3 key name for anti-pattern report. </p>
    #[doc(hidden)]
    pub antipattern_report_s3_object: std::option::Option<crate::model::S3Object>,
    /// <p> The status of the anti-pattern report generation. </p>
    #[doc(hidden)]
    pub antipattern_report_status: std::option::Option<crate::model::AntipatternReportStatus>,
    /// <p> A message about the status of the anti-pattern report generation. </p>
    #[doc(hidden)]
    pub antipattern_report_status_message: std::option::Option<std::string::String>,
    /// <p> The type of server. </p>
    #[doc(hidden)]
    pub server_type: std::option::Option<std::string::String>,
    /// <p> The timestamp of when the server was assessed. </p>
    #[doc(hidden)]
    pub last_analyzed_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The error in server analysis.</p>
    #[doc(hidden)]
    pub server_error: std::option::Option<crate::model::ServerError>,
}
impl ServerDetail {
    /// <p> The server ID. </p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p> The name of the server. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p> A set of recommendations. </p>
    pub fn recommendation_set(&self) -> std::option::Option<&crate::model::RecommendationSet> {
        self.recommendation_set.as_ref()
    }
    /// <p> The status of assessment for the server. </p>
    pub fn data_collection_status(
        &self,
    ) -> std::option::Option<&crate::model::RunTimeAssessmentStatus> {
        self.data_collection_status.as_ref()
    }
    /// <p> A message about the status of data collection, which contains detailed descriptions of any error messages. </p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
    /// <p> A list of anti-pattern severity summaries. </p>
    pub fn list_antipattern_severity_summary(
        &self,
    ) -> std::option::Option<&[crate::model::AntipatternSeveritySummary]> {
        self.list_antipattern_severity_summary.as_deref()
    }
    /// <p> System information about the server. </p>
    pub fn system_info(&self) -> std::option::Option<&crate::model::SystemInfo> {
        self.system_info.as_ref()
    }
    /// <p> A list of strategy summaries. </p>
    pub fn application_component_strategy_summary(
        &self,
    ) -> std::option::Option<&[crate::model::StrategySummary]> {
        self.application_component_strategy_summary.as_deref()
    }
    /// <p> The S3 bucket name and Amazon S3 key name for anti-pattern report. </p>
    pub fn antipattern_report_s3_object(&self) -> std::option::Option<&crate::model::S3Object> {
        self.antipattern_report_s3_object.as_ref()
    }
    /// <p> The status of the anti-pattern report generation. </p>
    pub fn antipattern_report_status(
        &self,
    ) -> std::option::Option<&crate::model::AntipatternReportStatus> {
        self.antipattern_report_status.as_ref()
    }
    /// <p> A message about the status of the anti-pattern report generation. </p>
    pub fn antipattern_report_status_message(&self) -> std::option::Option<&str> {
        self.antipattern_report_status_message.as_deref()
    }
    /// <p> The type of server. </p>
    pub fn server_type(&self) -> std::option::Option<&str> {
        self.server_type.as_deref()
    }
    /// <p> The timestamp of when the server was assessed. </p>
    pub fn last_analyzed_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_analyzed_timestamp.as_ref()
    }
    /// <p>The error in server analysis.</p>
    pub fn server_error(&self) -> std::option::Option<&crate::model::ServerError> {
        self.server_error.as_ref()
    }
}
/// See [`ServerDetail`](crate::model::ServerDetail).
pub mod server_detail {

    /// A builder for [`ServerDetail`](crate::model::ServerDetail).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) recommendation_set: std::option::Option<crate::model::RecommendationSet>,
        pub(crate) data_collection_status:
            std::option::Option<crate::model::RunTimeAssessmentStatus>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) list_antipattern_severity_summary:
            std::option::Option<std::vec::Vec<crate::model::AntipatternSeveritySummary>>,
        pub(crate) system_info: std::option::Option<crate::model::SystemInfo>,
        pub(crate) application_component_strategy_summary:
            std::option::Option<std::vec::Vec<crate::model::StrategySummary>>,
        pub(crate) antipattern_report_s3_object: std::option::Option<crate::model::S3Object>,
        pub(crate) antipattern_report_status:
            std::option::Option<crate::model::AntipatternReportStatus>,
        pub(crate) antipattern_report_status_message: std::option::Option<std::string::String>,
        pub(crate) server_type: std::option::Option<std::string::String>,
        pub(crate) last_analyzed_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) server_error: std::option::Option<crate::model::ServerError>,
    }
    impl Builder {
        /// <p> The server ID. </p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p> The server ID. </p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p> The name of the server. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of the server. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p> A set of recommendations. </p>
        pub fn recommendation_set(mut self, input: crate::model::RecommendationSet) -> Self {
            self.recommendation_set = Some(input);
            self
        }
        /// <p> A set of recommendations. </p>
        pub fn set_recommendation_set(
            mut self,
            input: std::option::Option<crate::model::RecommendationSet>,
        ) -> Self {
            self.recommendation_set = input;
            self
        }
        /// <p> The status of assessment for the server. </p>
        pub fn data_collection_status(
            mut self,
            input: crate::model::RunTimeAssessmentStatus,
        ) -> Self {
            self.data_collection_status = Some(input);
            self
        }
        /// <p> The status of assessment for the server. </p>
        pub fn set_data_collection_status(
            mut self,
            input: std::option::Option<crate::model::RunTimeAssessmentStatus>,
        ) -> Self {
            self.data_collection_status = input;
            self
        }
        /// <p> A message about the status of data collection, which contains detailed descriptions of any error messages. </p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p> A message about the status of data collection, which contains detailed descriptions of any error messages. </p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// Appends an item to `list_antipattern_severity_summary`.
        ///
        /// To override the contents of this collection use [`set_list_antipattern_severity_summary`](Self::set_list_antipattern_severity_summary).
        ///
        /// <p> A list of anti-pattern severity summaries. </p>
        pub fn list_antipattern_severity_summary(
            mut self,
            input: crate::model::AntipatternSeveritySummary,
        ) -> Self {
            let mut v = self.list_antipattern_severity_summary.unwrap_or_default();
            v.push(input);
            self.list_antipattern_severity_summary = Some(v);
            self
        }
        /// <p> A list of anti-pattern severity summaries. </p>
        pub fn set_list_antipattern_severity_summary(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AntipatternSeveritySummary>>,
        ) -> Self {
            self.list_antipattern_severity_summary = input;
            self
        }
        /// <p> System information about the server. </p>
        pub fn system_info(mut self, input: crate::model::SystemInfo) -> Self {
            self.system_info = Some(input);
            self
        }
        /// <p> System information about the server. </p>
        pub fn set_system_info(
            mut self,
            input: std::option::Option<crate::model::SystemInfo>,
        ) -> Self {
            self.system_info = input;
            self
        }
        /// Appends an item to `application_component_strategy_summary`.
        ///
        /// To override the contents of this collection use [`set_application_component_strategy_summary`](Self::set_application_component_strategy_summary).
        ///
        /// <p> A list of strategy summaries. </p>
        pub fn application_component_strategy_summary(
            mut self,
            input: crate::model::StrategySummary,
        ) -> Self {
            let mut v = self
                .application_component_strategy_summary
                .unwrap_or_default();
            v.push(input);
            self.application_component_strategy_summary = Some(v);
            self
        }
        /// <p> A list of strategy summaries. </p>
        pub fn set_application_component_strategy_summary(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StrategySummary>>,
        ) -> Self {
            self.application_component_strategy_summary = input;
            self
        }
        /// <p> The S3 bucket name and Amazon S3 key name for anti-pattern report. </p>
        pub fn antipattern_report_s3_object(mut self, input: crate::model::S3Object) -> Self {
            self.antipattern_report_s3_object = Some(input);
            self
        }
        /// <p> The S3 bucket name and Amazon S3 key name for anti-pattern report. </p>
        pub fn set_antipattern_report_s3_object(
            mut self,
            input: std::option::Option<crate::model::S3Object>,
        ) -> Self {
            self.antipattern_report_s3_object = input;
            self
        }
        /// <p> The status of the anti-pattern report generation. </p>
        pub fn antipattern_report_status(
            mut self,
            input: crate::model::AntipatternReportStatus,
        ) -> Self {
            self.antipattern_report_status = Some(input);
            self
        }
        /// <p> The status of the anti-pattern report generation. </p>
        pub fn set_antipattern_report_status(
            mut self,
            input: std::option::Option<crate::model::AntipatternReportStatus>,
        ) -> Self {
            self.antipattern_report_status = input;
            self
        }
        /// <p> A message about the status of the anti-pattern report generation. </p>
        pub fn antipattern_report_status_message(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.antipattern_report_status_message = Some(input.into());
            self
        }
        /// <p> A message about the status of the anti-pattern report generation. </p>
        pub fn set_antipattern_report_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.antipattern_report_status_message = input;
            self
        }
        /// <p> The type of server. </p>
        pub fn server_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.server_type = Some(input.into());
            self
        }
        /// <p> The type of server. </p>
        pub fn set_server_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.server_type = input;
            self
        }
        /// <p> The timestamp of when the server was assessed. </p>
        pub fn last_analyzed_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_analyzed_timestamp = Some(input);
            self
        }
        /// <p> The timestamp of when the server was assessed. </p>
        pub fn set_last_analyzed_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_analyzed_timestamp = input;
            self
        }
        /// <p>The error in server analysis.</p>
        pub fn server_error(mut self, input: crate::model::ServerError) -> Self {
            self.server_error = Some(input);
            self
        }
        /// <p>The error in server analysis.</p>
        pub fn set_server_error(
            mut self,
            input: std::option::Option<crate::model::ServerError>,
        ) -> Self {
            self.server_error = input;
            self
        }
        /// Consumes the builder and constructs a [`ServerDetail`](crate::model::ServerDetail).
        pub fn build(self) -> crate::model::ServerDetail {
            crate::model::ServerDetail {
                id: self.id,
                name: self.name,
                recommendation_set: self.recommendation_set,
                data_collection_status: self.data_collection_status,
                status_message: self.status_message,
                list_antipattern_severity_summary: self.list_antipattern_severity_summary,
                system_info: self.system_info,
                application_component_strategy_summary: self.application_component_strategy_summary,
                antipattern_report_s3_object: self.antipattern_report_s3_object,
                antipattern_report_status: self.antipattern_report_status,
                antipattern_report_status_message: self.antipattern_report_status_message,
                server_type: self.server_type,
                last_analyzed_timestamp: self.last_analyzed_timestamp,
                server_error: self.server_error,
            }
        }
    }
}
impl ServerDetail {
    /// Creates a new builder-style object to manufacture [`ServerDetail`](crate::model::ServerDetail).
    pub fn builder() -> crate::model::server_detail::Builder {
        crate::model::server_detail::Builder::default()
    }
}

/// <p>The error in server analysis.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServerError {
    /// <p>The error category of server analysis.</p>
    #[doc(hidden)]
    pub server_error_category: std::option::Option<crate::model::ServerErrorCategory>,
}
impl ServerError {
    /// <p>The error category of server analysis.</p>
    pub fn server_error_category(&self) -> std::option::Option<&crate::model::ServerErrorCategory> {
        self.server_error_category.as_ref()
    }
}
/// See [`ServerError`](crate::model::ServerError).
pub mod server_error {

    /// A builder for [`ServerError`](crate::model::ServerError).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) server_error_category: std::option::Option<crate::model::ServerErrorCategory>,
    }
    impl Builder {
        /// <p>The error category of server analysis.</p>
        pub fn server_error_category(mut self, input: crate::model::ServerErrorCategory) -> Self {
            self.server_error_category = Some(input);
            self
        }
        /// <p>The error category of server analysis.</p>
        pub fn set_server_error_category(
            mut self,
            input: std::option::Option<crate::model::ServerErrorCategory>,
        ) -> Self {
            self.server_error_category = input;
            self
        }
        /// Consumes the builder and constructs a [`ServerError`](crate::model::ServerError).
        pub fn build(self) -> crate::model::ServerError {
            crate::model::ServerError {
                server_error_category: self.server_error_category,
            }
        }
    }
}
impl ServerError {
    /// Creates a new builder-style object to manufacture [`ServerError`](crate::model::ServerError).
    pub fn builder() -> crate::model::server_error::Builder {
        crate::model::server_error::Builder::default()
    }
}

/// When writing a match expression against `ServerErrorCategory`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let servererrorcategory = unimplemented!();
/// match servererrorcategory {
///     ServerErrorCategory::ArchitectureError => { /* ... */ },
///     ServerErrorCategory::ConnectivityError => { /* ... */ },
///     ServerErrorCategory::CredentialError => { /* ... */ },
///     ServerErrorCategory::OtherError => { /* ... */ },
///     ServerErrorCategory::PermissionError => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `servererrorcategory` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ServerErrorCategory::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ServerErrorCategory::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ServerErrorCategory::NewFeature` is defined.
/// Specifically, when `servererrorcategory` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ServerErrorCategory::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ServerErrorCategory {
    #[allow(missing_docs)] // documentation missing in model
    ArchitectureError,
    #[allow(missing_docs)] // documentation missing in model
    ConnectivityError,
    #[allow(missing_docs)] // documentation missing in model
    CredentialError,
    #[allow(missing_docs)] // documentation missing in model
    OtherError,
    #[allow(missing_docs)] // documentation missing in model
    PermissionError,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ServerErrorCategory {
    fn from(s: &str) -> Self {
        match s {
            "ARCHITECTURE_ERROR" => ServerErrorCategory::ArchitectureError,
            "CONNECTIVITY_ERROR" => ServerErrorCategory::ConnectivityError,
            "CREDENTIAL_ERROR" => ServerErrorCategory::CredentialError,
            "OTHER_ERROR" => ServerErrorCategory::OtherError,
            "PERMISSION_ERROR" => ServerErrorCategory::PermissionError,
            other => {
                ServerErrorCategory::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ServerErrorCategory {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ServerErrorCategory::from(s))
    }
}
impl ServerErrorCategory {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ServerErrorCategory::ArchitectureError => "ARCHITECTURE_ERROR",
            ServerErrorCategory::ConnectivityError => "CONNECTIVITY_ERROR",
            ServerErrorCategory::CredentialError => "CREDENTIAL_ERROR",
            ServerErrorCategory::OtherError => "OTHER_ERROR",
            ServerErrorCategory::PermissionError => "PERMISSION_ERROR",
            ServerErrorCategory::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ARCHITECTURE_ERROR",
            "CONNECTIVITY_ERROR",
            "CREDENTIAL_ERROR",
            "OTHER_ERROR",
            "PERMISSION_ERROR",
        ]
    }
}
impl AsRef<str> for ServerErrorCategory {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `AntipatternReportStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let antipatternreportstatus = unimplemented!();
/// match antipatternreportstatus {
///     AntipatternReportStatus::Failed => { /* ... */ },
///     AntipatternReportStatus::InProgress => { /* ... */ },
///     AntipatternReportStatus::Success => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `antipatternreportstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AntipatternReportStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AntipatternReportStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AntipatternReportStatus::NewFeature` is defined.
/// Specifically, when `antipatternreportstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AntipatternReportStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AntipatternReportStatus {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Success,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AntipatternReportStatus {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => AntipatternReportStatus::Failed,
            "IN_PROGRESS" => AntipatternReportStatus::InProgress,
            "SUCCESS" => AntipatternReportStatus::Success,
            other => AntipatternReportStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for AntipatternReportStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AntipatternReportStatus::from(s))
    }
}
impl AntipatternReportStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AntipatternReportStatus::Failed => "FAILED",
            AntipatternReportStatus::InProgress => "IN_PROGRESS",
            AntipatternReportStatus::Success => "SUCCESS",
            AntipatternReportStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FAILED", "IN_PROGRESS", "SUCCESS"]
    }
}
impl AsRef<str> for AntipatternReportStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> Contains the S3 bucket name and the Amazon S3 key name. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct S3Object {
    /// <p> The S3 bucket name. </p>
    #[doc(hidden)]
    pub s3_bucket: std::option::Option<std::string::String>,
    /// <p> The Amazon S3 key name. </p>
    #[doc(hidden)]
    pub s3key: std::option::Option<std::string::String>,
}
impl S3Object {
    /// <p> The S3 bucket name. </p>
    pub fn s3_bucket(&self) -> std::option::Option<&str> {
        self.s3_bucket.as_deref()
    }
    /// <p> The Amazon S3 key name. </p>
    pub fn s3key(&self) -> std::option::Option<&str> {
        self.s3key.as_deref()
    }
}
/// See [`S3Object`](crate::model::S3Object).
pub mod s3_object {

    /// A builder for [`S3Object`](crate::model::S3Object).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_bucket: std::option::Option<std::string::String>,
        pub(crate) s3key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The S3 bucket name. </p>
        pub fn s3_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_bucket = Some(input.into());
            self
        }
        /// <p> The S3 bucket name. </p>
        pub fn set_s3_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_bucket = input;
            self
        }
        /// <p> The Amazon S3 key name. </p>
        pub fn s3key(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3key = Some(input.into());
            self
        }
        /// <p> The Amazon S3 key name. </p>
        pub fn set_s3key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3key = input;
            self
        }
        /// Consumes the builder and constructs a [`S3Object`](crate::model::S3Object).
        pub fn build(self) -> crate::model::S3Object {
            crate::model::S3Object {
                s3_bucket: self.s3_bucket,
                s3key: self.s3key,
            }
        }
    }
}
impl S3Object {
    /// Creates a new builder-style object to manufacture [`S3Object`](crate::model::S3Object).
    pub fn builder() -> crate::model::s3_object::Builder {
        crate::model::s3_object::Builder::default()
    }
}

/// <p> Object containing the summary of the strategy recommendations. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StrategySummary {
    /// <p> The name of recommended strategy. </p>
    #[doc(hidden)]
    pub strategy: std::option::Option<crate::model::Strategy>,
    /// <p> The count of recommendations per strategy. </p>
    #[doc(hidden)]
    pub count: std::option::Option<i32>,
}
impl StrategySummary {
    /// <p> The name of recommended strategy. </p>
    pub fn strategy(&self) -> std::option::Option<&crate::model::Strategy> {
        self.strategy.as_ref()
    }
    /// <p> The count of recommendations per strategy. </p>
    pub fn count(&self) -> std::option::Option<i32> {
        self.count
    }
}
/// See [`StrategySummary`](crate::model::StrategySummary).
pub mod strategy_summary {

    /// A builder for [`StrategySummary`](crate::model::StrategySummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) strategy: std::option::Option<crate::model::Strategy>,
        pub(crate) count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The name of recommended strategy. </p>
        pub fn strategy(mut self, input: crate::model::Strategy) -> Self {
            self.strategy = Some(input);
            self
        }
        /// <p> The name of recommended strategy. </p>
        pub fn set_strategy(mut self, input: std::option::Option<crate::model::Strategy>) -> Self {
            self.strategy = input;
            self
        }
        /// <p> The count of recommendations per strategy. </p>
        pub fn count(mut self, input: i32) -> Self {
            self.count = Some(input);
            self
        }
        /// <p> The count of recommendations per strategy. </p>
        pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
            self.count = input;
            self
        }
        /// Consumes the builder and constructs a [`StrategySummary`](crate::model::StrategySummary).
        pub fn build(self) -> crate::model::StrategySummary {
            crate::model::StrategySummary {
                strategy: self.strategy,
                count: self.count,
            }
        }
    }
}
impl StrategySummary {
    /// Creates a new builder-style object to manufacture [`StrategySummary`](crate::model::StrategySummary).
    pub fn builder() -> crate::model::strategy_summary::Builder {
        crate::model::strategy_summary::Builder::default()
    }
}

/// <p> Information about the server that hosts application components. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SystemInfo {
    /// <p> Operating system corresponding to a server. </p>
    #[doc(hidden)]
    pub os_info: std::option::Option<crate::model::OsInfo>,
    /// <p> File system type for the server. </p>
    #[doc(hidden)]
    pub file_system_type: std::option::Option<std::string::String>,
    /// <p> Networking information related to a server. </p>
    #[doc(hidden)]
    pub network_info_list: std::option::Option<std::vec::Vec<crate::model::NetworkInfo>>,
    /// <p> CPU architecture type for the server. </p>
    #[doc(hidden)]
    pub cpu_architecture: std::option::Option<std::string::String>,
}
impl SystemInfo {
    /// <p> Operating system corresponding to a server. </p>
    pub fn os_info(&self) -> std::option::Option<&crate::model::OsInfo> {
        self.os_info.as_ref()
    }
    /// <p> File system type for the server. </p>
    pub fn file_system_type(&self) -> std::option::Option<&str> {
        self.file_system_type.as_deref()
    }
    /// <p> Networking information related to a server. </p>
    pub fn network_info_list(&self) -> std::option::Option<&[crate::model::NetworkInfo]> {
        self.network_info_list.as_deref()
    }
    /// <p> CPU architecture type for the server. </p>
    pub fn cpu_architecture(&self) -> std::option::Option<&str> {
        self.cpu_architecture.as_deref()
    }
}
/// See [`SystemInfo`](crate::model::SystemInfo).
pub mod system_info {

    /// A builder for [`SystemInfo`](crate::model::SystemInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) os_info: std::option::Option<crate::model::OsInfo>,
        pub(crate) file_system_type: std::option::Option<std::string::String>,
        pub(crate) network_info_list: std::option::Option<std::vec::Vec<crate::model::NetworkInfo>>,
        pub(crate) cpu_architecture: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> Operating system corresponding to a server. </p>
        pub fn os_info(mut self, input: crate::model::OsInfo) -> Self {
            self.os_info = Some(input);
            self
        }
        /// <p> Operating system corresponding to a server. </p>
        pub fn set_os_info(mut self, input: std::option::Option<crate::model::OsInfo>) -> Self {
            self.os_info = input;
            self
        }
        /// <p> File system type for the server. </p>
        pub fn file_system_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.file_system_type = Some(input.into());
            self
        }
        /// <p> File system type for the server. </p>
        pub fn set_file_system_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.file_system_type = input;
            self
        }
        /// Appends an item to `network_info_list`.
        ///
        /// To override the contents of this collection use [`set_network_info_list`](Self::set_network_info_list).
        ///
        /// <p> Networking information related to a server. </p>
        pub fn network_info_list(mut self, input: crate::model::NetworkInfo) -> Self {
            let mut v = self.network_info_list.unwrap_or_default();
            v.push(input);
            self.network_info_list = Some(v);
            self
        }
        /// <p> Networking information related to a server. </p>
        pub fn set_network_info_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NetworkInfo>>,
        ) -> Self {
            self.network_info_list = input;
            self
        }
        /// <p> CPU architecture type for the server. </p>
        pub fn cpu_architecture(mut self, input: impl Into<std::string::String>) -> Self {
            self.cpu_architecture = Some(input.into());
            self
        }
        /// <p> CPU architecture type for the server. </p>
        pub fn set_cpu_architecture(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cpu_architecture = input;
            self
        }
        /// Consumes the builder and constructs a [`SystemInfo`](crate::model::SystemInfo).
        pub fn build(self) -> crate::model::SystemInfo {
            crate::model::SystemInfo {
                os_info: self.os_info,
                file_system_type: self.file_system_type,
                network_info_list: self.network_info_list,
                cpu_architecture: self.cpu_architecture,
            }
        }
    }
}
impl SystemInfo {
    /// Creates a new builder-style object to manufacture [`SystemInfo`](crate::model::SystemInfo).
    pub fn builder() -> crate::model::system_info::Builder {
        crate::model::system_info::Builder::default()
    }
}

/// <p> Information about the server's network for which the assessment was run. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NetworkInfo {
    /// <p> Information about the name of the interface of the server for which the assessment was run. </p>
    #[doc(hidden)]
    pub interface_name: std::option::Option<std::string::String>,
    /// <p> Information about the IP address of the server for which the assessment was run. </p>
    #[doc(hidden)]
    pub ip_address: std::option::Option<std::string::String>,
    /// <p> Information about the MAC address of the server for which the assessment was run. </p>
    #[doc(hidden)]
    pub mac_address: std::option::Option<std::string::String>,
    /// <p> Information about the subnet mask of the server for which the assessment was run. </p>
    #[doc(hidden)]
    pub net_mask: std::option::Option<std::string::String>,
}
impl NetworkInfo {
    /// <p> Information about the name of the interface of the server for which the assessment was run. </p>
    pub fn interface_name(&self) -> std::option::Option<&str> {
        self.interface_name.as_deref()
    }
    /// <p> Information about the IP address of the server for which the assessment was run. </p>
    pub fn ip_address(&self) -> std::option::Option<&str> {
        self.ip_address.as_deref()
    }
    /// <p> Information about the MAC address of the server for which the assessment was run. </p>
    pub fn mac_address(&self) -> std::option::Option<&str> {
        self.mac_address.as_deref()
    }
    /// <p> Information about the subnet mask of the server for which the assessment was run. </p>
    pub fn net_mask(&self) -> std::option::Option<&str> {
        self.net_mask.as_deref()
    }
}
/// See [`NetworkInfo`](crate::model::NetworkInfo).
pub mod network_info {

    /// A builder for [`NetworkInfo`](crate::model::NetworkInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) interface_name: std::option::Option<std::string::String>,
        pub(crate) ip_address: std::option::Option<std::string::String>,
        pub(crate) mac_address: std::option::Option<std::string::String>,
        pub(crate) net_mask: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> Information about the name of the interface of the server for which the assessment was run. </p>
        pub fn interface_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.interface_name = Some(input.into());
            self
        }
        /// <p> Information about the name of the interface of the server for which the assessment was run. </p>
        pub fn set_interface_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.interface_name = input;
            self
        }
        /// <p> Information about the IP address of the server for which the assessment was run. </p>
        pub fn ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.ip_address = Some(input.into());
            self
        }
        /// <p> Information about the IP address of the server for which the assessment was run. </p>
        pub fn set_ip_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ip_address = input;
            self
        }
        /// <p> Information about the MAC address of the server for which the assessment was run. </p>
        pub fn mac_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.mac_address = Some(input.into());
            self
        }
        /// <p> Information about the MAC address of the server for which the assessment was run. </p>
        pub fn set_mac_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.mac_address = input;
            self
        }
        /// <p> Information about the subnet mask of the server for which the assessment was run. </p>
        pub fn net_mask(mut self, input: impl Into<std::string::String>) -> Self {
            self.net_mask = Some(input.into());
            self
        }
        /// <p> Information about the subnet mask of the server for which the assessment was run. </p>
        pub fn set_net_mask(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.net_mask = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkInfo`](crate::model::NetworkInfo).
        pub fn build(self) -> crate::model::NetworkInfo {
            crate::model::NetworkInfo {
                interface_name: self.interface_name,
                ip_address: self.ip_address,
                mac_address: self.mac_address,
                net_mask: self.net_mask,
            }
        }
    }
}
impl NetworkInfo {
    /// Creates a new builder-style object to manufacture [`NetworkInfo`](crate::model::NetworkInfo).
    pub fn builder() -> crate::model::network_info::Builder {
        crate::model::network_info::Builder::default()
    }
}

/// <p> Information about the operating system. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OsInfo {
    /// <p> Information about the type of operating system. </p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::OsType>,
    /// <p> Information about the version of operating system. </p>
    #[doc(hidden)]
    pub version: std::option::Option<std::string::String>,
}
impl OsInfo {
    /// <p> Information about the type of operating system. </p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::OsType> {
        self.r#type.as_ref()
    }
    /// <p> Information about the version of operating system. </p>
    pub fn version(&self) -> std::option::Option<&str> {
        self.version.as_deref()
    }
}
/// See [`OsInfo`](crate::model::OsInfo).
pub mod os_info {

    /// A builder for [`OsInfo`](crate::model::OsInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::OsType>,
        pub(crate) version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> Information about the type of operating system. </p>
        pub fn r#type(mut self, input: crate::model::OsType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p> Information about the type of operating system. </p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::OsType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p> Information about the version of operating system. </p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p> Information about the version of operating system. </p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`OsInfo`](crate::model::OsInfo).
        pub fn build(self) -> crate::model::OsInfo {
            crate::model::OsInfo {
                r#type: self.r#type,
                version: self.version,
            }
        }
    }
}
impl OsInfo {
    /// Creates a new builder-style object to manufacture [`OsInfo`](crate::model::OsInfo).
    pub fn builder() -> crate::model::os_info::Builder {
        crate::model::os_info::Builder::default()
    }
}

/// When writing a match expression against `OsType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let ostype = unimplemented!();
/// match ostype {
///     OsType::Linux => { /* ... */ },
///     OsType::Windows => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `ostype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `OsType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `OsType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `OsType::NewFeature` is defined.
/// Specifically, when `ostype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `OsType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OsType {
    #[allow(missing_docs)] // documentation missing in model
    Linux,
    #[allow(missing_docs)] // documentation missing in model
    Windows,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for OsType {
    fn from(s: &str) -> Self {
        match s {
            "LINUX" => OsType::Linux,
            "WINDOWS" => OsType::Windows,
            other => OsType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for OsType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OsType::from(s))
    }
}
impl OsType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OsType::Linux => "LINUX",
            OsType::Windows => "WINDOWS",
            OsType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["LINUX", "WINDOWS"]
    }
}
impl AsRef<str> for OsType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> Contains the summary of anti-patterns and their severity. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AntipatternSeveritySummary {
    /// <p> Contains the severity of anti-patterns. </p>
    #[doc(hidden)]
    pub severity: std::option::Option<crate::model::Severity>,
    /// <p> Contains the count of anti-patterns. </p>
    #[doc(hidden)]
    pub count: std::option::Option<i32>,
}
impl AntipatternSeveritySummary {
    /// <p> Contains the severity of anti-patterns. </p>
    pub fn severity(&self) -> std::option::Option<&crate::model::Severity> {
        self.severity.as_ref()
    }
    /// <p> Contains the count of anti-patterns. </p>
    pub fn count(&self) -> std::option::Option<i32> {
        self.count
    }
}
/// See [`AntipatternSeveritySummary`](crate::model::AntipatternSeveritySummary).
pub mod antipattern_severity_summary {

    /// A builder for [`AntipatternSeveritySummary`](crate::model::AntipatternSeveritySummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) severity: std::option::Option<crate::model::Severity>,
        pub(crate) count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> Contains the severity of anti-patterns. </p>
        pub fn severity(mut self, input: crate::model::Severity) -> Self {
            self.severity = Some(input);
            self
        }
        /// <p> Contains the severity of anti-patterns. </p>
        pub fn set_severity(mut self, input: std::option::Option<crate::model::Severity>) -> Self {
            self.severity = input;
            self
        }
        /// <p> Contains the count of anti-patterns. </p>
        pub fn count(mut self, input: i32) -> Self {
            self.count = Some(input);
            self
        }
        /// <p> Contains the count of anti-patterns. </p>
        pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
            self.count = input;
            self
        }
        /// Consumes the builder and constructs a [`AntipatternSeveritySummary`](crate::model::AntipatternSeveritySummary).
        pub fn build(self) -> crate::model::AntipatternSeveritySummary {
            crate::model::AntipatternSeveritySummary {
                severity: self.severity,
                count: self.count,
            }
        }
    }
}
impl AntipatternSeveritySummary {
    /// Creates a new builder-style object to manufacture [`AntipatternSeveritySummary`](crate::model::AntipatternSeveritySummary).
    pub fn builder() -> crate::model::antipattern_severity_summary::Builder {
        crate::model::antipattern_severity_summary::Builder::default()
    }
}

/// When writing a match expression against `Severity`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let severity = unimplemented!();
/// match severity {
///     Severity::High => { /* ... */ },
///     Severity::Low => { /* ... */ },
///     Severity::Medium => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `severity` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Severity::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Severity::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Severity::NewFeature` is defined.
/// Specifically, when `severity` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Severity::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Severity {
    #[allow(missing_docs)] // documentation missing in model
    High,
    #[allow(missing_docs)] // documentation missing in model
    Low,
    #[allow(missing_docs)] // documentation missing in model
    Medium,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Severity {
    fn from(s: &str) -> Self {
        match s {
            "HIGH" => Severity::High,
            "LOW" => Severity::Low,
            "MEDIUM" => Severity::Medium,
            other => Severity::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Severity {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Severity::from(s))
    }
}
impl Severity {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Severity::High => "HIGH",
            Severity::Low => "LOW",
            Severity::Medium => "MEDIUM",
            Severity::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["HIGH", "LOW", "MEDIUM"]
    }
}
impl AsRef<str> for Severity {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `RunTimeAssessmentStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let runtimeassessmentstatus = unimplemented!();
/// match runtimeassessmentstatus {
///     RunTimeAssessmentStatus::DcFailed => { /* ... */ },
///     RunTimeAssessmentStatus::DcPartialSuccess => { /* ... */ },
///     RunTimeAssessmentStatus::DcReqSent => { /* ... */ },
///     RunTimeAssessmentStatus::DcStarted => { /* ... */ },
///     RunTimeAssessmentStatus::DcStopped => { /* ... */ },
///     RunTimeAssessmentStatus::DcSuccess => { /* ... */ },
///     RunTimeAssessmentStatus::DcToBeScheduled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `runtimeassessmentstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RunTimeAssessmentStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RunTimeAssessmentStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RunTimeAssessmentStatus::NewFeature` is defined.
/// Specifically, when `runtimeassessmentstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RunTimeAssessmentStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RunTimeAssessmentStatus {
    #[allow(missing_docs)] // documentation missing in model
    DcFailed,
    #[allow(missing_docs)] // documentation missing in model
    DcPartialSuccess,
    #[allow(missing_docs)] // documentation missing in model
    DcReqSent,
    #[allow(missing_docs)] // documentation missing in model
    DcStarted,
    #[allow(missing_docs)] // documentation missing in model
    DcStopped,
    #[allow(missing_docs)] // documentation missing in model
    DcSuccess,
    #[allow(missing_docs)] // documentation missing in model
    DcToBeScheduled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RunTimeAssessmentStatus {
    fn from(s: &str) -> Self {
        match s {
            "dataCollectionTaskFailed" => RunTimeAssessmentStatus::DcFailed,
            "dataCollectionTaskPartialSuccess" => RunTimeAssessmentStatus::DcPartialSuccess,
            "dataCollectionTaskScheduled" => RunTimeAssessmentStatus::DcReqSent,
            "dataCollectionTaskStarted" => RunTimeAssessmentStatus::DcStarted,
            "dataCollectionTaskStopped" => RunTimeAssessmentStatus::DcStopped,
            "dataCollectionTaskSuccess" => RunTimeAssessmentStatus::DcSuccess,
            "dataCollectionTaskToBeScheduled" => RunTimeAssessmentStatus::DcToBeScheduled,
            other => RunTimeAssessmentStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for RunTimeAssessmentStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RunTimeAssessmentStatus::from(s))
    }
}
impl RunTimeAssessmentStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RunTimeAssessmentStatus::DcFailed => "dataCollectionTaskFailed",
            RunTimeAssessmentStatus::DcPartialSuccess => "dataCollectionTaskPartialSuccess",
            RunTimeAssessmentStatus::DcReqSent => "dataCollectionTaskScheduled",
            RunTimeAssessmentStatus::DcStarted => "dataCollectionTaskStarted",
            RunTimeAssessmentStatus::DcStopped => "dataCollectionTaskStopped",
            RunTimeAssessmentStatus::DcSuccess => "dataCollectionTaskSuccess",
            RunTimeAssessmentStatus::DcToBeScheduled => "dataCollectionTaskToBeScheduled",
            RunTimeAssessmentStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "dataCollectionTaskFailed",
            "dataCollectionTaskPartialSuccess",
            "dataCollectionTaskScheduled",
            "dataCollectionTaskStarted",
            "dataCollectionTaskStopped",
            "dataCollectionTaskSuccess",
            "dataCollectionTaskToBeScheduled",
        ]
    }
}
impl AsRef<str> for RunTimeAssessmentStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> Contains a recommendation set. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RecommendationSet {
    /// <p> The target destination for the recommendation set. </p>
    #[doc(hidden)]
    pub transformation_tool: std::option::Option<crate::model::TransformationTool>,
    /// <p> The recommended target destination. </p>
    #[doc(hidden)]
    pub target_destination: std::option::Option<crate::model::TargetDestination>,
    /// <p> The recommended strategy. </p>
    #[doc(hidden)]
    pub strategy: std::option::Option<crate::model::Strategy>,
}
impl RecommendationSet {
    /// <p> The target destination for the recommendation set. </p>
    pub fn transformation_tool(&self) -> std::option::Option<&crate::model::TransformationTool> {
        self.transformation_tool.as_ref()
    }
    /// <p> The recommended target destination. </p>
    pub fn target_destination(&self) -> std::option::Option<&crate::model::TargetDestination> {
        self.target_destination.as_ref()
    }
    /// <p> The recommended strategy. </p>
    pub fn strategy(&self) -> std::option::Option<&crate::model::Strategy> {
        self.strategy.as_ref()
    }
}
/// See [`RecommendationSet`](crate::model::RecommendationSet).
pub mod recommendation_set {

    /// A builder for [`RecommendationSet`](crate::model::RecommendationSet).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transformation_tool: std::option::Option<crate::model::TransformationTool>,
        pub(crate) target_destination: std::option::Option<crate::model::TargetDestination>,
        pub(crate) strategy: std::option::Option<crate::model::Strategy>,
    }
    impl Builder {
        /// <p> The target destination for the recommendation set. </p>
        pub fn transformation_tool(mut self, input: crate::model::TransformationTool) -> Self {
            self.transformation_tool = Some(input);
            self
        }
        /// <p> The target destination for the recommendation set. </p>
        pub fn set_transformation_tool(
            mut self,
            input: std::option::Option<crate::model::TransformationTool>,
        ) -> Self {
            self.transformation_tool = input;
            self
        }
        /// <p> The recommended target destination. </p>
        pub fn target_destination(mut self, input: crate::model::TargetDestination) -> Self {
            self.target_destination = Some(input);
            self
        }
        /// <p> The recommended target destination. </p>
        pub fn set_target_destination(
            mut self,
            input: std::option::Option<crate::model::TargetDestination>,
        ) -> Self {
            self.target_destination = input;
            self
        }
        /// <p> The recommended strategy. </p>
        pub fn strategy(mut self, input: crate::model::Strategy) -> Self {
            self.strategy = Some(input);
            self
        }
        /// <p> The recommended strategy. </p>
        pub fn set_strategy(mut self, input: std::option::Option<crate::model::Strategy>) -> Self {
            self.strategy = input;
            self
        }
        /// Consumes the builder and constructs a [`RecommendationSet`](crate::model::RecommendationSet).
        pub fn build(self) -> crate::model::RecommendationSet {
            crate::model::RecommendationSet {
                transformation_tool: self.transformation_tool,
                target_destination: self.target_destination,
                strategy: self.strategy,
            }
        }
    }
}
impl RecommendationSet {
    /// Creates a new builder-style object to manufacture [`RecommendationSet`](crate::model::RecommendationSet).
    pub fn builder() -> crate::model::recommendation_set::Builder {
        crate::model::recommendation_set::Builder::default()
    }
}

/// <p> Information of the transformation tool that can be used to migrate and modernize the application. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TransformationTool {
    /// <p> Name of the tool. </p>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::TransformationToolName>,
    /// <p> Description of the tool. </p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p> URL for installing the tool. </p>
    #[doc(hidden)]
    pub tranformation_tool_installation_link: std::option::Option<std::string::String>,
}
impl TransformationTool {
    /// <p> Name of the tool. </p>
    pub fn name(&self) -> std::option::Option<&crate::model::TransformationToolName> {
        self.name.as_ref()
    }
    /// <p> Description of the tool. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p> URL for installing the tool. </p>
    pub fn tranformation_tool_installation_link(&self) -> std::option::Option<&str> {
        self.tranformation_tool_installation_link.as_deref()
    }
}
/// See [`TransformationTool`](crate::model::TransformationTool).
pub mod transformation_tool {

    /// A builder for [`TransformationTool`](crate::model::TransformationTool).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::TransformationToolName>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) tranformation_tool_installation_link: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> Name of the tool. </p>
        pub fn name(mut self, input: crate::model::TransformationToolName) -> Self {
            self.name = Some(input);
            self
        }
        /// <p> Name of the tool. </p>
        pub fn set_name(
            mut self,
            input: std::option::Option<crate::model::TransformationToolName>,
        ) -> Self {
            self.name = input;
            self
        }
        /// <p> Description of the tool. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p> Description of the tool. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p> URL for installing the tool. </p>
        pub fn tranformation_tool_installation_link(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.tranformation_tool_installation_link = Some(input.into());
            self
        }
        /// <p> URL for installing the tool. </p>
        pub fn set_tranformation_tool_installation_link(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.tranformation_tool_installation_link = input;
            self
        }
        /// Consumes the builder and constructs a [`TransformationTool`](crate::model::TransformationTool).
        pub fn build(self) -> crate::model::TransformationTool {
            crate::model::TransformationTool {
                name: self.name,
                description: self.description,
                tranformation_tool_installation_link: self.tranformation_tool_installation_link,
            }
        }
    }
}
impl TransformationTool {
    /// Creates a new builder-style object to manufacture [`TransformationTool`](crate::model::TransformationTool).
    pub fn builder() -> crate::model::transformation_tool::Builder {
        crate::model::transformation_tool::Builder::default()
    }
}

/// When writing a match expression against `SortOrder`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let sortorder = unimplemented!();
/// match sortorder {
///     SortOrder::Asc => { /* ... */ },
///     SortOrder::Desc => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `sortorder` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SortOrder::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SortOrder::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SortOrder::NewFeature` is defined.
/// Specifically, when `sortorder` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SortOrder::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortOrder {
    #[allow(missing_docs)] // documentation missing in model
    Asc,
    #[allow(missing_docs)] // documentation missing in model
    Desc,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SortOrder {
    fn from(s: &str) -> Self {
        match s {
            "ASC" => SortOrder::Asc,
            "DESC" => SortOrder::Desc,
            other => SortOrder::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SortOrder {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortOrder::from(s))
    }
}
impl SortOrder {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SortOrder::Asc => "ASC",
            SortOrder::Desc => "DESC",
            SortOrder::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ASC", "DESC"]
    }
}
impl AsRef<str> for SortOrder {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ServerCriteria`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let servercriteria = unimplemented!();
/// match servercriteria {
///     ServerCriteria::AnalysisStatus => { /* ... */ },
///     ServerCriteria::Destination => { /* ... */ },
///     ServerCriteria::ErrorCategory => { /* ... */ },
///     ServerCriteria::NotDefined => { /* ... */ },
///     ServerCriteria::OsName => { /* ... */ },
///     ServerCriteria::ServerId => { /* ... */ },
///     ServerCriteria::Strategy => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `servercriteria` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ServerCriteria::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ServerCriteria::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ServerCriteria::NewFeature` is defined.
/// Specifically, when `servercriteria` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ServerCriteria::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ServerCriteria {
    #[allow(missing_docs)] // documentation missing in model
    AnalysisStatus,
    #[allow(missing_docs)] // documentation missing in model
    Destination,
    #[allow(missing_docs)] // documentation missing in model
    ErrorCategory,
    #[allow(missing_docs)] // documentation missing in model
    NotDefined,
    #[allow(missing_docs)] // documentation missing in model
    OsName,
    #[allow(missing_docs)] // documentation missing in model
    ServerId,
    #[allow(missing_docs)] // documentation missing in model
    Strategy,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ServerCriteria {
    fn from(s: &str) -> Self {
        match s {
            "ANALYSIS_STATUS" => ServerCriteria::AnalysisStatus,
            "DESTINATION" => ServerCriteria::Destination,
            "ERROR_CATEGORY" => ServerCriteria::ErrorCategory,
            "NOT_DEFINED" => ServerCriteria::NotDefined,
            "OS_NAME" => ServerCriteria::OsName,
            "SERVER_ID" => ServerCriteria::ServerId,
            "STRATEGY" => ServerCriteria::Strategy,
            other => ServerCriteria::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ServerCriteria {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ServerCriteria::from(s))
    }
}
impl ServerCriteria {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ServerCriteria::AnalysisStatus => "ANALYSIS_STATUS",
            ServerCriteria::Destination => "DESTINATION",
            ServerCriteria::ErrorCategory => "ERROR_CATEGORY",
            ServerCriteria::NotDefined => "NOT_DEFINED",
            ServerCriteria::OsName => "OS_NAME",
            ServerCriteria::ServerId => "SERVER_ID",
            ServerCriteria::Strategy => "STRATEGY",
            ServerCriteria::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ANALYSIS_STATUS",
            "DESTINATION",
            "ERROR_CATEGORY",
            "NOT_DEFINED",
            "OS_NAME",
            "SERVER_ID",
            "STRATEGY",
        ]
    }
}
impl AsRef<str> for ServerCriteria {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> Information about the import file tasks you request. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ImportFileTaskInformation {
    /// <p> The ID of the import file task. </p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p> Status of import file task. </p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ImportFileTaskStatus>,
    /// <p> Start time of the import task. </p>
    #[doc(hidden)]
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p> The S3 bucket where the import file is located. </p>
    #[doc(hidden)]
    pub input_s3_bucket: std::option::Option<std::string::String>,
    /// <p> The Amazon S3 key name of the import file. </p>
    #[doc(hidden)]
    pub input_s3_key: std::option::Option<std::string::String>,
    /// <p> The S3 bucket name for status report of import task. </p>
    #[doc(hidden)]
    pub status_report_s3_bucket: std::option::Option<std::string::String>,
    /// <p> The Amazon S3 key name for status report of import task. The report contains details about whether each record imported successfully or why it did not. </p>
    #[doc(hidden)]
    pub status_report_s3_key: std::option::Option<std::string::String>,
    /// <p> The time that the import task completes. </p>
    #[doc(hidden)]
    pub completion_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p> The number of records successfully imported. </p>
    #[doc(hidden)]
    pub number_of_records_success: std::option::Option<i32>,
    /// <p> The number of records that failed to be imported. </p>
    #[doc(hidden)]
    pub number_of_records_failed: std::option::Option<i32>,
    /// <p> The name of the import task given in <code>StartImportFileTask</code>. </p>
    #[doc(hidden)]
    pub import_name: std::option::Option<std::string::String>,
}
impl ImportFileTaskInformation {
    /// <p> The ID of the import file task. </p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p> Status of import file task. </p>
    pub fn status(&self) -> std::option::Option<&crate::model::ImportFileTaskStatus> {
        self.status.as_ref()
    }
    /// <p> Start time of the import task. </p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p> The S3 bucket where the import file is located. </p>
    pub fn input_s3_bucket(&self) -> std::option::Option<&str> {
        self.input_s3_bucket.as_deref()
    }
    /// <p> The Amazon S3 key name of the import file. </p>
    pub fn input_s3_key(&self) -> std::option::Option<&str> {
        self.input_s3_key.as_deref()
    }
    /// <p> The S3 bucket name for status report of import task. </p>
    pub fn status_report_s3_bucket(&self) -> std::option::Option<&str> {
        self.status_report_s3_bucket.as_deref()
    }
    /// <p> The Amazon S3 key name for status report of import task. The report contains details about whether each record imported successfully or why it did not. </p>
    pub fn status_report_s3_key(&self) -> std::option::Option<&str> {
        self.status_report_s3_key.as_deref()
    }
    /// <p> The time that the import task completes. </p>
    pub fn completion_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.completion_time.as_ref()
    }
    /// <p> The number of records successfully imported. </p>
    pub fn number_of_records_success(&self) -> std::option::Option<i32> {
        self.number_of_records_success
    }
    /// <p> The number of records that failed to be imported. </p>
    pub fn number_of_records_failed(&self) -> std::option::Option<i32> {
        self.number_of_records_failed
    }
    /// <p> The name of the import task given in <code>StartImportFileTask</code>. </p>
    pub fn import_name(&self) -> std::option::Option<&str> {
        self.import_name.as_deref()
    }
}
/// See [`ImportFileTaskInformation`](crate::model::ImportFileTaskInformation).
pub mod import_file_task_information {

    /// A builder for [`ImportFileTaskInformation`](crate::model::ImportFileTaskInformation).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ImportFileTaskStatus>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) input_s3_bucket: std::option::Option<std::string::String>,
        pub(crate) input_s3_key: std::option::Option<std::string::String>,
        pub(crate) status_report_s3_bucket: std::option::Option<std::string::String>,
        pub(crate) status_report_s3_key: std::option::Option<std::string::String>,
        pub(crate) completion_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) number_of_records_success: std::option::Option<i32>,
        pub(crate) number_of_records_failed: std::option::Option<i32>,
        pub(crate) import_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The ID of the import file task. </p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p> The ID of the import file task. </p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p> Status of import file task. </p>
        pub fn status(mut self, input: crate::model::ImportFileTaskStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p> Status of import file task. </p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ImportFileTaskStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p> Start time of the import task. </p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p> Start time of the import task. </p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p> The S3 bucket where the import file is located. </p>
        pub fn input_s3_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.input_s3_bucket = Some(input.into());
            self
        }
        /// <p> The S3 bucket where the import file is located. </p>
        pub fn set_input_s3_bucket(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.input_s3_bucket = input;
            self
        }
        /// <p> The Amazon S3 key name of the import file. </p>
        pub fn input_s3_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.input_s3_key = Some(input.into());
            self
        }
        /// <p> The Amazon S3 key name of the import file. </p>
        pub fn set_input_s3_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.input_s3_key = input;
            self
        }
        /// <p> The S3 bucket name for status report of import task. </p>
        pub fn status_report_s3_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_report_s3_bucket = Some(input.into());
            self
        }
        /// <p> The S3 bucket name for status report of import task. </p>
        pub fn set_status_report_s3_bucket(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_report_s3_bucket = input;
            self
        }
        /// <p> The Amazon S3 key name for status report of import task. The report contains details about whether each record imported successfully or why it did not. </p>
        pub fn status_report_s3_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_report_s3_key = Some(input.into());
            self
        }
        /// <p> The Amazon S3 key name for status report of import task. The report contains details about whether each record imported successfully or why it did not. </p>
        pub fn set_status_report_s3_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_report_s3_key = input;
            self
        }
        /// <p> The time that the import task completes. </p>
        pub fn completion_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.completion_time = Some(input);
            self
        }
        /// <p> The time that the import task completes. </p>
        pub fn set_completion_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.completion_time = input;
            self
        }
        /// <p> The number of records successfully imported. </p>
        pub fn number_of_records_success(mut self, input: i32) -> Self {
            self.number_of_records_success = Some(input);
            self
        }
        /// <p> The number of records successfully imported. </p>
        pub fn set_number_of_records_success(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_records_success = input;
            self
        }
        /// <p> The number of records that failed to be imported. </p>
        pub fn number_of_records_failed(mut self, input: i32) -> Self {
            self.number_of_records_failed = Some(input);
            self
        }
        /// <p> The number of records that failed to be imported. </p>
        pub fn set_number_of_records_failed(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_records_failed = input;
            self
        }
        /// <p> The name of the import task given in <code>StartImportFileTask</code>. </p>
        pub fn import_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.import_name = Some(input.into());
            self
        }
        /// <p> The name of the import task given in <code>StartImportFileTask</code>. </p>
        pub fn set_import_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.import_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ImportFileTaskInformation`](crate::model::ImportFileTaskInformation).
        pub fn build(self) -> crate::model::ImportFileTaskInformation {
            crate::model::ImportFileTaskInformation {
                id: self.id,
                status: self.status,
                start_time: self.start_time,
                input_s3_bucket: self.input_s3_bucket,
                input_s3_key: self.input_s3_key,
                status_report_s3_bucket: self.status_report_s3_bucket,
                status_report_s3_key: self.status_report_s3_key,
                completion_time: self.completion_time,
                number_of_records_success: self.number_of_records_success,
                number_of_records_failed: self.number_of_records_failed,
                import_name: self.import_name,
            }
        }
    }
}
impl ImportFileTaskInformation {
    /// Creates a new builder-style object to manufacture [`ImportFileTaskInformation`](crate::model::ImportFileTaskInformation).
    pub fn builder() -> crate::model::import_file_task_information::Builder {
        crate::model::import_file_task_information::Builder::default()
    }
}

/// When writing a match expression against `ImportFileTaskStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let importfiletaskstatus = unimplemented!();
/// match importfiletaskstatus {
///     ImportFileTaskStatus::DeleteFailed => { /* ... */ },
///     ImportFileTaskStatus::DeleteInProgress => { /* ... */ },
///     ImportFileTaskStatus::DeletePartialSuccess => { /* ... */ },
///     ImportFileTaskStatus::DeleteSuccess => { /* ... */ },
///     ImportFileTaskStatus::ImportFailed => { /* ... */ },
///     ImportFileTaskStatus::ImportInProgress => { /* ... */ },
///     ImportFileTaskStatus::ImportPartialSuccess => { /* ... */ },
///     ImportFileTaskStatus::ImportSuccess => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `importfiletaskstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ImportFileTaskStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ImportFileTaskStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ImportFileTaskStatus::NewFeature` is defined.
/// Specifically, when `importfiletaskstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ImportFileTaskStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ImportFileTaskStatus {
    #[allow(missing_docs)] // documentation missing in model
    DeleteFailed,
    #[allow(missing_docs)] // documentation missing in model
    DeleteInProgress,
    #[allow(missing_docs)] // documentation missing in model
    DeletePartialSuccess,
    #[allow(missing_docs)] // documentation missing in model
    DeleteSuccess,
    #[allow(missing_docs)] // documentation missing in model
    ImportFailed,
    #[allow(missing_docs)] // documentation missing in model
    ImportInProgress,
    #[allow(missing_docs)] // documentation missing in model
    ImportPartialSuccess,
    #[allow(missing_docs)] // documentation missing in model
    ImportSuccess,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ImportFileTaskStatus {
    fn from(s: &str) -> Self {
        match s {
            "DeleteFailed" => ImportFileTaskStatus::DeleteFailed,
            "DeleteInProgress" => ImportFileTaskStatus::DeleteInProgress,
            "DeletePartialSuccess" => ImportFileTaskStatus::DeletePartialSuccess,
            "DeleteSuccess" => ImportFileTaskStatus::DeleteSuccess,
            "ImportFailed" => ImportFileTaskStatus::ImportFailed,
            "ImportInProgress" => ImportFileTaskStatus::ImportInProgress,
            "ImportPartialSuccess" => ImportFileTaskStatus::ImportPartialSuccess,
            "ImportSuccess" => ImportFileTaskStatus::ImportSuccess,
            other => {
                ImportFileTaskStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ImportFileTaskStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ImportFileTaskStatus::from(s))
    }
}
impl ImportFileTaskStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ImportFileTaskStatus::DeleteFailed => "DeleteFailed",
            ImportFileTaskStatus::DeleteInProgress => "DeleteInProgress",
            ImportFileTaskStatus::DeletePartialSuccess => "DeletePartialSuccess",
            ImportFileTaskStatus::DeleteSuccess => "DeleteSuccess",
            ImportFileTaskStatus::ImportFailed => "ImportFailed",
            ImportFileTaskStatus::ImportInProgress => "ImportInProgress",
            ImportFileTaskStatus::ImportPartialSuccess => "ImportPartialSuccess",
            ImportFileTaskStatus::ImportSuccess => "ImportSuccess",
            ImportFileTaskStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "DeleteFailed",
            "DeleteInProgress",
            "DeletePartialSuccess",
            "DeleteSuccess",
            "ImportFailed",
            "ImportInProgress",
            "ImportPartialSuccess",
            "ImportSuccess",
        ]
    }
}
impl AsRef<str> for ImportFileTaskStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> Process data collector that runs in the environment that you specify. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Collector {
    /// <p> The ID of the collector. </p>
    #[doc(hidden)]
    pub collector_id: std::option::Option<std::string::String>,
    /// <p> IP address of the server that is hosting the collector. </p>
    #[doc(hidden)]
    pub ip_address: std::option::Option<std::string::String>,
    /// <p> Hostname of the server that is hosting the collector. </p>
    #[doc(hidden)]
    pub host_name: std::option::Option<std::string::String>,
    /// <p> Indicates the health of a collector. </p>
    #[doc(hidden)]
    pub collector_health: std::option::Option<crate::model::CollectorHealth>,
    /// <p> Current version of the collector that is running in the environment that you specify. </p>
    #[doc(hidden)]
    pub collector_version: std::option::Option<std::string::String>,
    /// <p> Time when the collector registered with the service. </p>
    #[doc(hidden)]
    pub registered_time_stamp: std::option::Option<std::string::String>,
    /// <p> Time when the collector last pinged the service. </p>
    #[doc(hidden)]
    pub last_activity_time_stamp: std::option::Option<std::string::String>,
    /// <p>Summary of the collector configuration.</p>
    #[doc(hidden)]
    pub configuration_summary: std::option::Option<crate::model::ConfigurationSummary>,
}
impl Collector {
    /// <p> The ID of the collector. </p>
    pub fn collector_id(&self) -> std::option::Option<&str> {
        self.collector_id.as_deref()
    }
    /// <p> IP address of the server that is hosting the collector. </p>
    pub fn ip_address(&self) -> std::option::Option<&str> {
        self.ip_address.as_deref()
    }
    /// <p> Hostname of the server that is hosting the collector. </p>
    pub fn host_name(&self) -> std::option::Option<&str> {
        self.host_name.as_deref()
    }
    /// <p> Indicates the health of a collector. </p>
    pub fn collector_health(&self) -> std::option::Option<&crate::model::CollectorHealth> {
        self.collector_health.as_ref()
    }
    /// <p> Current version of the collector that is running in the environment that you specify. </p>
    pub fn collector_version(&self) -> std::option::Option<&str> {
        self.collector_version.as_deref()
    }
    /// <p> Time when the collector registered with the service. </p>
    pub fn registered_time_stamp(&self) -> std::option::Option<&str> {
        self.registered_time_stamp.as_deref()
    }
    /// <p> Time when the collector last pinged the service. </p>
    pub fn last_activity_time_stamp(&self) -> std::option::Option<&str> {
        self.last_activity_time_stamp.as_deref()
    }
    /// <p>Summary of the collector configuration.</p>
    pub fn configuration_summary(
        &self,
    ) -> std::option::Option<&crate::model::ConfigurationSummary> {
        self.configuration_summary.as_ref()
    }
}
/// See [`Collector`](crate::model::Collector).
pub mod collector {

    /// A builder for [`Collector`](crate::model::Collector).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) collector_id: std::option::Option<std::string::String>,
        pub(crate) ip_address: std::option::Option<std::string::String>,
        pub(crate) host_name: std::option::Option<std::string::String>,
        pub(crate) collector_health: std::option::Option<crate::model::CollectorHealth>,
        pub(crate) collector_version: std::option::Option<std::string::String>,
        pub(crate) registered_time_stamp: std::option::Option<std::string::String>,
        pub(crate) last_activity_time_stamp: std::option::Option<std::string::String>,
        pub(crate) configuration_summary: std::option::Option<crate::model::ConfigurationSummary>,
    }
    impl Builder {
        /// <p> The ID of the collector. </p>
        pub fn collector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.collector_id = Some(input.into());
            self
        }
        /// <p> The ID of the collector. </p>
        pub fn set_collector_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.collector_id = input;
            self
        }
        /// <p> IP address of the server that is hosting the collector. </p>
        pub fn ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.ip_address = Some(input.into());
            self
        }
        /// <p> IP address of the server that is hosting the collector. </p>
        pub fn set_ip_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ip_address = input;
            self
        }
        /// <p> Hostname of the server that is hosting the collector. </p>
        pub fn host_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.host_name = Some(input.into());
            self
        }
        /// <p> Hostname of the server that is hosting the collector. </p>
        pub fn set_host_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.host_name = input;
            self
        }
        /// <p> Indicates the health of a collector. </p>
        pub fn collector_health(mut self, input: crate::model::CollectorHealth) -> Self {
            self.collector_health = Some(input);
            self
        }
        /// <p> Indicates the health of a collector. </p>
        pub fn set_collector_health(
            mut self,
            input: std::option::Option<crate::model::CollectorHealth>,
        ) -> Self {
            self.collector_health = input;
            self
        }
        /// <p> Current version of the collector that is running in the environment that you specify. </p>
        pub fn collector_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.collector_version = Some(input.into());
            self
        }
        /// <p> Current version of the collector that is running in the environment that you specify. </p>
        pub fn set_collector_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.collector_version = input;
            self
        }
        /// <p> Time when the collector registered with the service. </p>
        pub fn registered_time_stamp(mut self, input: impl Into<std::string::String>) -> Self {
            self.registered_time_stamp = Some(input.into());
            self
        }
        /// <p> Time when the collector registered with the service. </p>
        pub fn set_registered_time_stamp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.registered_time_stamp = input;
            self
        }
        /// <p> Time when the collector last pinged the service. </p>
        pub fn last_activity_time_stamp(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_activity_time_stamp = Some(input.into());
            self
        }
        /// <p> Time when the collector last pinged the service. </p>
        pub fn set_last_activity_time_stamp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_activity_time_stamp = input;
            self
        }
        /// <p>Summary of the collector configuration.</p>
        pub fn configuration_summary(mut self, input: crate::model::ConfigurationSummary) -> Self {
            self.configuration_summary = Some(input);
            self
        }
        /// <p>Summary of the collector configuration.</p>
        pub fn set_configuration_summary(
            mut self,
            input: std::option::Option<crate::model::ConfigurationSummary>,
        ) -> Self {
            self.configuration_summary = input;
            self
        }
        /// Consumes the builder and constructs a [`Collector`](crate::model::Collector).
        pub fn build(self) -> crate::model::Collector {
            crate::model::Collector {
                collector_id: self.collector_id,
                ip_address: self.ip_address,
                host_name: self.host_name,
                collector_health: self.collector_health,
                collector_version: self.collector_version,
                registered_time_stamp: self.registered_time_stamp,
                last_activity_time_stamp: self.last_activity_time_stamp,
                configuration_summary: self.configuration_summary,
            }
        }
    }
}
impl Collector {
    /// Creates a new builder-style object to manufacture [`Collector`](crate::model::Collector).
    pub fn builder() -> crate::model::collector::Builder {
        crate::model::collector::Builder::default()
    }
}

/// <p>Summary of the collector configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfigurationSummary {
    /// <p>The list of vCenter configurations.</p>
    #[doc(hidden)]
    pub vcenter_based_remote_info_list:
        std::option::Option<std::vec::Vec<crate::model::VcenterBasedRemoteInfo>>,
    /// <p>IP address based configurations.</p>
    #[doc(hidden)]
    pub ip_address_based_remote_info_list:
        std::option::Option<std::vec::Vec<crate::model::IpAddressBasedRemoteInfo>>,
    /// <p>The list of the version control configurations.</p>
    #[doc(hidden)]
    pub version_control_info_list:
        std::option::Option<std::vec::Vec<crate::model::VersionControlInfo>>,
    /// <p>The list of pipeline info configurations.</p>
    #[doc(hidden)]
    pub pipeline_info_list: std::option::Option<std::vec::Vec<crate::model::PipelineInfo>>,
    /// <p>Info about the remote server source code configuration.</p>
    #[doc(hidden)]
    pub remote_source_code_analysis_server_info:
        std::option::Option<crate::model::RemoteSourceCodeAnalysisServerInfo>,
}
impl ConfigurationSummary {
    /// <p>The list of vCenter configurations.</p>
    pub fn vcenter_based_remote_info_list(
        &self,
    ) -> std::option::Option<&[crate::model::VcenterBasedRemoteInfo]> {
        self.vcenter_based_remote_info_list.as_deref()
    }
    /// <p>IP address based configurations.</p>
    pub fn ip_address_based_remote_info_list(
        &self,
    ) -> std::option::Option<&[crate::model::IpAddressBasedRemoteInfo]> {
        self.ip_address_based_remote_info_list.as_deref()
    }
    /// <p>The list of the version control configurations.</p>
    pub fn version_control_info_list(
        &self,
    ) -> std::option::Option<&[crate::model::VersionControlInfo]> {
        self.version_control_info_list.as_deref()
    }
    /// <p>The list of pipeline info configurations.</p>
    pub fn pipeline_info_list(&self) -> std::option::Option<&[crate::model::PipelineInfo]> {
        self.pipeline_info_list.as_deref()
    }
    /// <p>Info about the remote server source code configuration.</p>
    pub fn remote_source_code_analysis_server_info(
        &self,
    ) -> std::option::Option<&crate::model::RemoteSourceCodeAnalysisServerInfo> {
        self.remote_source_code_analysis_server_info.as_ref()
    }
}
/// See [`ConfigurationSummary`](crate::model::ConfigurationSummary).
pub mod configuration_summary {

    /// A builder for [`ConfigurationSummary`](crate::model::ConfigurationSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vcenter_based_remote_info_list:
            std::option::Option<std::vec::Vec<crate::model::VcenterBasedRemoteInfo>>,
        pub(crate) ip_address_based_remote_info_list:
            std::option::Option<std::vec::Vec<crate::model::IpAddressBasedRemoteInfo>>,
        pub(crate) version_control_info_list:
            std::option::Option<std::vec::Vec<crate::model::VersionControlInfo>>,
        pub(crate) pipeline_info_list:
            std::option::Option<std::vec::Vec<crate::model::PipelineInfo>>,
        pub(crate) remote_source_code_analysis_server_info:
            std::option::Option<crate::model::RemoteSourceCodeAnalysisServerInfo>,
    }
    impl Builder {
        /// Appends an item to `vcenter_based_remote_info_list`.
        ///
        /// To override the contents of this collection use [`set_vcenter_based_remote_info_list`](Self::set_vcenter_based_remote_info_list).
        ///
        /// <p>The list of vCenter configurations.</p>
        pub fn vcenter_based_remote_info_list(
            mut self,
            input: crate::model::VcenterBasedRemoteInfo,
        ) -> Self {
            let mut v = self.vcenter_based_remote_info_list.unwrap_or_default();
            v.push(input);
            self.vcenter_based_remote_info_list = Some(v);
            self
        }
        /// <p>The list of vCenter configurations.</p>
        pub fn set_vcenter_based_remote_info_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VcenterBasedRemoteInfo>>,
        ) -> Self {
            self.vcenter_based_remote_info_list = input;
            self
        }
        /// Appends an item to `ip_address_based_remote_info_list`.
        ///
        /// To override the contents of this collection use [`set_ip_address_based_remote_info_list`](Self::set_ip_address_based_remote_info_list).
        ///
        /// <p>IP address based configurations.</p>
        pub fn ip_address_based_remote_info_list(
            mut self,
            input: crate::model::IpAddressBasedRemoteInfo,
        ) -> Self {
            let mut v = self.ip_address_based_remote_info_list.unwrap_or_default();
            v.push(input);
            self.ip_address_based_remote_info_list = Some(v);
            self
        }
        /// <p>IP address based configurations.</p>
        pub fn set_ip_address_based_remote_info_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IpAddressBasedRemoteInfo>>,
        ) -> Self {
            self.ip_address_based_remote_info_list = input;
            self
        }
        /// Appends an item to `version_control_info_list`.
        ///
        /// To override the contents of this collection use [`set_version_control_info_list`](Self::set_version_control_info_list).
        ///
        /// <p>The list of the version control configurations.</p>
        pub fn version_control_info_list(
            mut self,
            input: crate::model::VersionControlInfo,
        ) -> Self {
            let mut v = self.version_control_info_list.unwrap_or_default();
            v.push(input);
            self.version_control_info_list = Some(v);
            self
        }
        /// <p>The list of the version control configurations.</p>
        pub fn set_version_control_info_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VersionControlInfo>>,
        ) -> Self {
            self.version_control_info_list = input;
            self
        }
        /// Appends an item to `pipeline_info_list`.
        ///
        /// To override the contents of this collection use [`set_pipeline_info_list`](Self::set_pipeline_info_list).
        ///
        /// <p>The list of pipeline info configurations.</p>
        pub fn pipeline_info_list(mut self, input: crate::model::PipelineInfo) -> Self {
            let mut v = self.pipeline_info_list.unwrap_or_default();
            v.push(input);
            self.pipeline_info_list = Some(v);
            self
        }
        /// <p>The list of pipeline info configurations.</p>
        pub fn set_pipeline_info_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PipelineInfo>>,
        ) -> Self {
            self.pipeline_info_list = input;
            self
        }
        /// <p>Info about the remote server source code configuration.</p>
        pub fn remote_source_code_analysis_server_info(
            mut self,
            input: crate::model::RemoteSourceCodeAnalysisServerInfo,
        ) -> Self {
            self.remote_source_code_analysis_server_info = Some(input);
            self
        }
        /// <p>Info about the remote server source code configuration.</p>
        pub fn set_remote_source_code_analysis_server_info(
            mut self,
            input: std::option::Option<crate::model::RemoteSourceCodeAnalysisServerInfo>,
        ) -> Self {
            self.remote_source_code_analysis_server_info = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfigurationSummary`](crate::model::ConfigurationSummary).
        pub fn build(self) -> crate::model::ConfigurationSummary {
            crate::model::ConfigurationSummary {
                vcenter_based_remote_info_list: self.vcenter_based_remote_info_list,
                ip_address_based_remote_info_list: self.ip_address_based_remote_info_list,
                version_control_info_list: self.version_control_info_list,
                pipeline_info_list: self.pipeline_info_list,
                remote_source_code_analysis_server_info: self
                    .remote_source_code_analysis_server_info,
            }
        }
    }
}
impl ConfigurationSummary {
    /// Creates a new builder-style object to manufacture [`ConfigurationSummary`](crate::model::ConfigurationSummary).
    pub fn builder() -> crate::model::configuration_summary::Builder {
        crate::model::configuration_summary::Builder::default()
    }
}

/// <p>Information about the server configured for source code analysis.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RemoteSourceCodeAnalysisServerInfo {
    /// <p>The time when the remote source code server was configured.</p>
    #[doc(hidden)]
    pub remote_source_code_analysis_server_configuration_timestamp:
        std::option::Option<std::string::String>,
}
impl RemoteSourceCodeAnalysisServerInfo {
    /// <p>The time when the remote source code server was configured.</p>
    pub fn remote_source_code_analysis_server_configuration_timestamp(
        &self,
    ) -> std::option::Option<&str> {
        self.remote_source_code_analysis_server_configuration_timestamp
            .as_deref()
    }
}
/// See [`RemoteSourceCodeAnalysisServerInfo`](crate::model::RemoteSourceCodeAnalysisServerInfo).
pub mod remote_source_code_analysis_server_info {

    /// A builder for [`RemoteSourceCodeAnalysisServerInfo`](crate::model::RemoteSourceCodeAnalysisServerInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) remote_source_code_analysis_server_configuration_timestamp:
            std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The time when the remote source code server was configured.</p>
        pub fn remote_source_code_analysis_server_configuration_timestamp(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.remote_source_code_analysis_server_configuration_timestamp = Some(input.into());
            self
        }
        /// <p>The time when the remote source code server was configured.</p>
        pub fn set_remote_source_code_analysis_server_configuration_timestamp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.remote_source_code_analysis_server_configuration_timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`RemoteSourceCodeAnalysisServerInfo`](crate::model::RemoteSourceCodeAnalysisServerInfo).
        pub fn build(self) -> crate::model::RemoteSourceCodeAnalysisServerInfo {
            crate::model::RemoteSourceCodeAnalysisServerInfo {
                remote_source_code_analysis_server_configuration_timestamp: self
                    .remote_source_code_analysis_server_configuration_timestamp,
            }
        }
    }
}
impl RemoteSourceCodeAnalysisServerInfo {
    /// Creates a new builder-style object to manufacture [`RemoteSourceCodeAnalysisServerInfo`](crate::model::RemoteSourceCodeAnalysisServerInfo).
    pub fn builder() -> crate::model::remote_source_code_analysis_server_info::Builder {
        crate::model::remote_source_code_analysis_server_info::Builder::default()
    }
}

/// <p>Detailed information of the pipeline.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PipelineInfo {
    /// <p>The type of pipeline.</p>
    #[doc(hidden)]
    pub pipeline_type: std::option::Option<crate::model::PipelineType>,
    /// <p>The time when the pipeline info was configured.</p>
    #[doc(hidden)]
    pub pipeline_configuration_time_stamp: std::option::Option<std::string::String>,
}
impl PipelineInfo {
    /// <p>The type of pipeline.</p>
    pub fn pipeline_type(&self) -> std::option::Option<&crate::model::PipelineType> {
        self.pipeline_type.as_ref()
    }
    /// <p>The time when the pipeline info was configured.</p>
    pub fn pipeline_configuration_time_stamp(&self) -> std::option::Option<&str> {
        self.pipeline_configuration_time_stamp.as_deref()
    }
}
/// See [`PipelineInfo`](crate::model::PipelineInfo).
pub mod pipeline_info {

    /// A builder for [`PipelineInfo`](crate::model::PipelineInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pipeline_type: std::option::Option<crate::model::PipelineType>,
        pub(crate) pipeline_configuration_time_stamp: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of pipeline.</p>
        pub fn pipeline_type(mut self, input: crate::model::PipelineType) -> Self {
            self.pipeline_type = Some(input);
            self
        }
        /// <p>The type of pipeline.</p>
        pub fn set_pipeline_type(
            mut self,
            input: std::option::Option<crate::model::PipelineType>,
        ) -> Self {
            self.pipeline_type = input;
            self
        }
        /// <p>The time when the pipeline info was configured.</p>
        pub fn pipeline_configuration_time_stamp(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.pipeline_configuration_time_stamp = Some(input.into());
            self
        }
        /// <p>The time when the pipeline info was configured.</p>
        pub fn set_pipeline_configuration_time_stamp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pipeline_configuration_time_stamp = input;
            self
        }
        /// Consumes the builder and constructs a [`PipelineInfo`](crate::model::PipelineInfo).
        pub fn build(self) -> crate::model::PipelineInfo {
            crate::model::PipelineInfo {
                pipeline_type: self.pipeline_type,
                pipeline_configuration_time_stamp: self.pipeline_configuration_time_stamp,
            }
        }
    }
}
impl PipelineInfo {
    /// Creates a new builder-style object to manufacture [`PipelineInfo`](crate::model::PipelineInfo).
    pub fn builder() -> crate::model::pipeline_info::Builder {
        crate::model::pipeline_info::Builder::default()
    }
}

/// When writing a match expression against `PipelineType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let pipelinetype = unimplemented!();
/// match pipelinetype {
///     PipelineType::AzureDevops => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `pipelinetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PipelineType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PipelineType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PipelineType::NewFeature` is defined.
/// Specifically, when `pipelinetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PipelineType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PipelineType {
    #[allow(missing_docs)] // documentation missing in model
    AzureDevops,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PipelineType {
    fn from(s: &str) -> Self {
        match s {
            "AZURE_DEVOPS" => PipelineType::AzureDevops,
            other => PipelineType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PipelineType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PipelineType::from(s))
    }
}
impl PipelineType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PipelineType::AzureDevops => "AZURE_DEVOPS",
            PipelineType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AZURE_DEVOPS"]
    }
}
impl AsRef<str> for PipelineType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Details about the version control configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VersionControlInfo {
    /// <p>The type of version control.</p>
    #[doc(hidden)]
    pub version_control_type: std::option::Option<crate::model::VersionControlType>,
    /// <p>The time when the version control system was last configured.</p>
    #[doc(hidden)]
    pub version_control_configuration_time_stamp: std::option::Option<std::string::String>,
}
impl VersionControlInfo {
    /// <p>The type of version control.</p>
    pub fn version_control_type(&self) -> std::option::Option<&crate::model::VersionControlType> {
        self.version_control_type.as_ref()
    }
    /// <p>The time when the version control system was last configured.</p>
    pub fn version_control_configuration_time_stamp(&self) -> std::option::Option<&str> {
        self.version_control_configuration_time_stamp.as_deref()
    }
}
/// See [`VersionControlInfo`](crate::model::VersionControlInfo).
pub mod version_control_info {

    /// A builder for [`VersionControlInfo`](crate::model::VersionControlInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) version_control_type: std::option::Option<crate::model::VersionControlType>,
        pub(crate) version_control_configuration_time_stamp:
            std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of version control.</p>
        pub fn version_control_type(mut self, input: crate::model::VersionControlType) -> Self {
            self.version_control_type = Some(input);
            self
        }
        /// <p>The type of version control.</p>
        pub fn set_version_control_type(
            mut self,
            input: std::option::Option<crate::model::VersionControlType>,
        ) -> Self {
            self.version_control_type = input;
            self
        }
        /// <p>The time when the version control system was last configured.</p>
        pub fn version_control_configuration_time_stamp(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.version_control_configuration_time_stamp = Some(input.into());
            self
        }
        /// <p>The time when the version control system was last configured.</p>
        pub fn set_version_control_configuration_time_stamp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.version_control_configuration_time_stamp = input;
            self
        }
        /// Consumes the builder and constructs a [`VersionControlInfo`](crate::model::VersionControlInfo).
        pub fn build(self) -> crate::model::VersionControlInfo {
            crate::model::VersionControlInfo {
                version_control_type: self.version_control_type,
                version_control_configuration_time_stamp: self
                    .version_control_configuration_time_stamp,
            }
        }
    }
}
impl VersionControlInfo {
    /// Creates a new builder-style object to manufacture [`VersionControlInfo`](crate::model::VersionControlInfo).
    pub fn builder() -> crate::model::version_control_info::Builder {
        crate::model::version_control_info::Builder::default()
    }
}

/// When writing a match expression against `VersionControlType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let versioncontroltype = unimplemented!();
/// match versioncontroltype {
///     VersionControlType::AzureDevopsGit => { /* ... */ },
///     VersionControlType::Github => { /* ... */ },
///     VersionControlType::GithubEnterprise => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `versioncontroltype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `VersionControlType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `VersionControlType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `VersionControlType::NewFeature` is defined.
/// Specifically, when `versioncontroltype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `VersionControlType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VersionControlType {
    #[allow(missing_docs)] // documentation missing in model
    AzureDevopsGit,
    #[allow(missing_docs)] // documentation missing in model
    Github,
    #[allow(missing_docs)] // documentation missing in model
    GithubEnterprise,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for VersionControlType {
    fn from(s: &str) -> Self {
        match s {
            "AZURE_DEVOPS_GIT" => VersionControlType::AzureDevopsGit,
            "GITHUB" => VersionControlType::Github,
            "GITHUB_ENTERPRISE" => VersionControlType::GithubEnterprise,
            other => {
                VersionControlType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for VersionControlType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VersionControlType::from(s))
    }
}
impl VersionControlType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            VersionControlType::AzureDevopsGit => "AZURE_DEVOPS_GIT",
            VersionControlType::Github => "GITHUB",
            VersionControlType::GithubEnterprise => "GITHUB_ENTERPRISE",
            VersionControlType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AZURE_DEVOPS_GIT", "GITHUB", "GITHUB_ENTERPRISE"]
    }
}
impl AsRef<str> for VersionControlType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>IP address based configurations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IpAddressBasedRemoteInfo {
    /// <p>The time stamp of the configuration.</p>
    #[doc(hidden)]
    pub ip_address_configuration_time_stamp: std::option::Option<std::string::String>,
    /// <p>The type of authorization.</p>
    #[doc(hidden)]
    pub auth_type: std::option::Option<crate::model::AuthType>,
    /// <p>The type of the operating system.</p>
    #[doc(hidden)]
    pub os_type: std::option::Option<crate::model::OsType>,
}
impl IpAddressBasedRemoteInfo {
    /// <p>The time stamp of the configuration.</p>
    pub fn ip_address_configuration_time_stamp(&self) -> std::option::Option<&str> {
        self.ip_address_configuration_time_stamp.as_deref()
    }
    /// <p>The type of authorization.</p>
    pub fn auth_type(&self) -> std::option::Option<&crate::model::AuthType> {
        self.auth_type.as_ref()
    }
    /// <p>The type of the operating system.</p>
    pub fn os_type(&self) -> std::option::Option<&crate::model::OsType> {
        self.os_type.as_ref()
    }
}
/// See [`IpAddressBasedRemoteInfo`](crate::model::IpAddressBasedRemoteInfo).
pub mod ip_address_based_remote_info {

    /// A builder for [`IpAddressBasedRemoteInfo`](crate::model::IpAddressBasedRemoteInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ip_address_configuration_time_stamp: std::option::Option<std::string::String>,
        pub(crate) auth_type: std::option::Option<crate::model::AuthType>,
        pub(crate) os_type: std::option::Option<crate::model::OsType>,
    }
    impl Builder {
        /// <p>The time stamp of the configuration.</p>
        pub fn ip_address_configuration_time_stamp(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.ip_address_configuration_time_stamp = Some(input.into());
            self
        }
        /// <p>The time stamp of the configuration.</p>
        pub fn set_ip_address_configuration_time_stamp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ip_address_configuration_time_stamp = input;
            self
        }
        /// <p>The type of authorization.</p>
        pub fn auth_type(mut self, input: crate::model::AuthType) -> Self {
            self.auth_type = Some(input);
            self
        }
        /// <p>The type of authorization.</p>
        pub fn set_auth_type(mut self, input: std::option::Option<crate::model::AuthType>) -> Self {
            self.auth_type = input;
            self
        }
        /// <p>The type of the operating system.</p>
        pub fn os_type(mut self, input: crate::model::OsType) -> Self {
            self.os_type = Some(input);
            self
        }
        /// <p>The type of the operating system.</p>
        pub fn set_os_type(mut self, input: std::option::Option<crate::model::OsType>) -> Self {
            self.os_type = input;
            self
        }
        /// Consumes the builder and constructs a [`IpAddressBasedRemoteInfo`](crate::model::IpAddressBasedRemoteInfo).
        pub fn build(self) -> crate::model::IpAddressBasedRemoteInfo {
            crate::model::IpAddressBasedRemoteInfo {
                ip_address_configuration_time_stamp: self.ip_address_configuration_time_stamp,
                auth_type: self.auth_type,
                os_type: self.os_type,
            }
        }
    }
}
impl IpAddressBasedRemoteInfo {
    /// Creates a new builder-style object to manufacture [`IpAddressBasedRemoteInfo`](crate::model::IpAddressBasedRemoteInfo).
    pub fn builder() -> crate::model::ip_address_based_remote_info::Builder {
        crate::model::ip_address_based_remote_info::Builder::default()
    }
}

/// When writing a match expression against `AuthType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let authtype = unimplemented!();
/// match authtype {
///     AuthType::Cert => { /* ... */ },
///     AuthType::Ntlm => { /* ... */ },
///     AuthType::Ssh => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `authtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AuthType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AuthType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AuthType::NewFeature` is defined.
/// Specifically, when `authtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AuthType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AuthType {
    #[allow(missing_docs)] // documentation missing in model
    Cert,
    #[allow(missing_docs)] // documentation missing in model
    Ntlm,
    #[allow(missing_docs)] // documentation missing in model
    Ssh,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AuthType {
    fn from(s: &str) -> Self {
        match s {
            "CERT" => AuthType::Cert,
            "NTLM" => AuthType::Ntlm,
            "SSH" => AuthType::Ssh,
            other => AuthType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AuthType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AuthType::from(s))
    }
}
impl AuthType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AuthType::Cert => "CERT",
            AuthType::Ntlm => "NTLM",
            AuthType::Ssh => "SSH",
            AuthType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CERT", "NTLM", "SSH"]
    }
}
impl AsRef<str> for AuthType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Details about the server in vCenter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VcenterBasedRemoteInfo {
    /// <p>The time when the remote server based on vCenter was last configured.</p>
    #[doc(hidden)]
    pub vcenter_configuration_time_stamp: std::option::Option<std::string::String>,
    /// <p>The type of the operating system.</p>
    #[doc(hidden)]
    pub os_type: std::option::Option<crate::model::OsType>,
}
impl VcenterBasedRemoteInfo {
    /// <p>The time when the remote server based on vCenter was last configured.</p>
    pub fn vcenter_configuration_time_stamp(&self) -> std::option::Option<&str> {
        self.vcenter_configuration_time_stamp.as_deref()
    }
    /// <p>The type of the operating system.</p>
    pub fn os_type(&self) -> std::option::Option<&crate::model::OsType> {
        self.os_type.as_ref()
    }
}
/// See [`VcenterBasedRemoteInfo`](crate::model::VcenterBasedRemoteInfo).
pub mod vcenter_based_remote_info {

    /// A builder for [`VcenterBasedRemoteInfo`](crate::model::VcenterBasedRemoteInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vcenter_configuration_time_stamp: std::option::Option<std::string::String>,
        pub(crate) os_type: std::option::Option<crate::model::OsType>,
    }
    impl Builder {
        /// <p>The time when the remote server based on vCenter was last configured.</p>
        pub fn vcenter_configuration_time_stamp(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.vcenter_configuration_time_stamp = Some(input.into());
            self
        }
        /// <p>The time when the remote server based on vCenter was last configured.</p>
        pub fn set_vcenter_configuration_time_stamp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vcenter_configuration_time_stamp = input;
            self
        }
        /// <p>The type of the operating system.</p>
        pub fn os_type(mut self, input: crate::model::OsType) -> Self {
            self.os_type = Some(input);
            self
        }
        /// <p>The type of the operating system.</p>
        pub fn set_os_type(mut self, input: std::option::Option<crate::model::OsType>) -> Self {
            self.os_type = input;
            self
        }
        /// Consumes the builder and constructs a [`VcenterBasedRemoteInfo`](crate::model::VcenterBasedRemoteInfo).
        pub fn build(self) -> crate::model::VcenterBasedRemoteInfo {
            crate::model::VcenterBasedRemoteInfo {
                vcenter_configuration_time_stamp: self.vcenter_configuration_time_stamp,
                os_type: self.os_type,
            }
        }
    }
}
impl VcenterBasedRemoteInfo {
    /// Creates a new builder-style object to manufacture [`VcenterBasedRemoteInfo`](crate::model::VcenterBasedRemoteInfo).
    pub fn builder() -> crate::model::vcenter_based_remote_info::Builder {
        crate::model::vcenter_based_remote_info::Builder::default()
    }
}

/// When writing a match expression against `CollectorHealth`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let collectorhealth = unimplemented!();
/// match collectorhealth {
///     CollectorHealth::CollectorHealthy => { /* ... */ },
///     CollectorHealth::CollectorUnhealthy => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `collectorhealth` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CollectorHealth::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CollectorHealth::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CollectorHealth::NewFeature` is defined.
/// Specifically, when `collectorhealth` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CollectorHealth::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CollectorHealth {
    #[allow(missing_docs)] // documentation missing in model
    CollectorHealthy,
    #[allow(missing_docs)] // documentation missing in model
    CollectorUnhealthy,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CollectorHealth {
    fn from(s: &str) -> Self {
        match s {
            "COLLECTOR_HEALTHY" => CollectorHealth::CollectorHealthy,
            "COLLECTOR_UNHEALTHY" => CollectorHealth::CollectorUnhealthy,
            other => CollectorHealth::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for CollectorHealth {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CollectorHealth::from(s))
    }
}
impl CollectorHealth {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CollectorHealth::CollectorHealthy => "COLLECTOR_HEALTHY",
            CollectorHealth::CollectorUnhealthy => "COLLECTOR_UNHEALTHY",
            CollectorHealth::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["COLLECTOR_HEALTHY", "COLLECTOR_UNHEALTHY"]
    }
}
impl AsRef<str> for CollectorHealth {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> Contains detailed information about an application component. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ApplicationComponentDetail {
    /// <p> The ID of the application component. </p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p> The name of application component. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p> The top recommendation set for the application component. </p>
    #[doc(hidden)]
    pub recommendation_set: std::option::Option<crate::model::RecommendationSet>,
    /// <p> The status of analysis, if the application component has source code or an associated database. </p>
    #[doc(hidden)]
    pub analysis_status: std::option::Option<crate::model::SrcCodeOrDbAnalysisStatus>,
    /// <p> A detailed description of the analysis status and any failure message. </p>
    #[doc(hidden)]
    pub status_message: std::option::Option<std::string::String>,
    /// <p> A list of anti-pattern severity summaries. </p>
    #[doc(hidden)]
    pub list_antipattern_severity_summary:
        std::option::Option<std::vec::Vec<crate::model::AntipatternSeveritySummary>>,
    /// <p> Configuration details for the database associated with the application component. </p>
    #[doc(hidden)]
    pub database_config_detail: std::option::Option<crate::model::DatabaseConfigDetail>,
    /// <p> Details about the source code repository associated with the application component. </p>
    #[doc(hidden)]
    pub source_code_repositories:
        std::option::Option<std::vec::Vec<crate::model::SourceCodeRepository>>,
    /// <p> The type of application component. </p>
    #[doc(hidden)]
    pub app_type: std::option::Option<crate::model::AppType>,
    /// <p> The application component subtype.</p>
    #[doc(hidden)]
    pub resource_sub_type: std::option::Option<crate::model::ResourceSubType>,
    /// <p> Indicates whether the application component has been included for server recommendation or not. </p>
    #[doc(hidden)]
    pub inclusion_status: std::option::Option<crate::model::InclusionStatus>,
    /// <p> The S3 bucket name and the Amazon S3 key name for the anti-pattern report. </p>
    #[doc(hidden)]
    pub antipattern_report_s3_object: std::option::Option<crate::model::S3Object>,
    /// <p> The status of the anti-pattern report generation.</p>
    #[doc(hidden)]
    pub antipattern_report_status: std::option::Option<crate::model::AntipatternReportStatus>,
    /// <p> The status message for the anti-pattern. </p>
    #[doc(hidden)]
    pub antipattern_report_status_message: std::option::Option<std::string::String>,
    /// <p> OS version. </p>
    #[doc(hidden)]
    pub os_version: std::option::Option<std::string::String>,
    /// <p> OS driver. </p>
    #[doc(hidden)]
    pub os_driver: std::option::Option<std::string::String>,
    /// <p> The timestamp of when the application component was assessed. </p>
    #[doc(hidden)]
    pub last_analyzed_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p> The ID of the server that the application component is running on. </p>
    #[doc(hidden)]
    pub associated_server_id: std::option::Option<std::string::String>,
    /// <p> Set to true if the application component is running on multiple servers.</p>
    #[doc(hidden)]
    pub more_server_association_exists: std::option::Option<bool>,
    /// <p>The status of the application unit.</p>
    #[doc(hidden)]
    pub runtime_status: std::option::Option<crate::model::RuntimeAnalysisStatus>,
    /// <p>The status message for the application unit.</p>
    #[doc(hidden)]
    pub runtime_status_message: std::option::Option<std::string::String>,
    /// <p>The error in the analysis of the source code or database.</p>
    #[doc(hidden)]
    pub app_unit_error: std::option::Option<crate::model::AppUnitError>,
}
impl ApplicationComponentDetail {
    /// <p> The ID of the application component. </p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p> The name of application component. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p> The top recommendation set for the application component. </p>
    pub fn recommendation_set(&self) -> std::option::Option<&crate::model::RecommendationSet> {
        self.recommendation_set.as_ref()
    }
    /// <p> The status of analysis, if the application component has source code or an associated database. </p>
    pub fn analysis_status(&self) -> std::option::Option<&crate::model::SrcCodeOrDbAnalysisStatus> {
        self.analysis_status.as_ref()
    }
    /// <p> A detailed description of the analysis status and any failure message. </p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
    /// <p> A list of anti-pattern severity summaries. </p>
    pub fn list_antipattern_severity_summary(
        &self,
    ) -> std::option::Option<&[crate::model::AntipatternSeveritySummary]> {
        self.list_antipattern_severity_summary.as_deref()
    }
    /// <p> Configuration details for the database associated with the application component. </p>
    pub fn database_config_detail(
        &self,
    ) -> std::option::Option<&crate::model::DatabaseConfigDetail> {
        self.database_config_detail.as_ref()
    }
    /// <p> Details about the source code repository associated with the application component. </p>
    pub fn source_code_repositories(
        &self,
    ) -> std::option::Option<&[crate::model::SourceCodeRepository]> {
        self.source_code_repositories.as_deref()
    }
    /// <p> The type of application component. </p>
    pub fn app_type(&self) -> std::option::Option<&crate::model::AppType> {
        self.app_type.as_ref()
    }
    /// <p> The application component subtype.</p>
    pub fn resource_sub_type(&self) -> std::option::Option<&crate::model::ResourceSubType> {
        self.resource_sub_type.as_ref()
    }
    /// <p> Indicates whether the application component has been included for server recommendation or not. </p>
    pub fn inclusion_status(&self) -> std::option::Option<&crate::model::InclusionStatus> {
        self.inclusion_status.as_ref()
    }
    /// <p> The S3 bucket name and the Amazon S3 key name for the anti-pattern report. </p>
    pub fn antipattern_report_s3_object(&self) -> std::option::Option<&crate::model::S3Object> {
        self.antipattern_report_s3_object.as_ref()
    }
    /// <p> The status of the anti-pattern report generation.</p>
    pub fn antipattern_report_status(
        &self,
    ) -> std::option::Option<&crate::model::AntipatternReportStatus> {
        self.antipattern_report_status.as_ref()
    }
    /// <p> The status message for the anti-pattern. </p>
    pub fn antipattern_report_status_message(&self) -> std::option::Option<&str> {
        self.antipattern_report_status_message.as_deref()
    }
    /// <p> OS version. </p>
    pub fn os_version(&self) -> std::option::Option<&str> {
        self.os_version.as_deref()
    }
    /// <p> OS driver. </p>
    pub fn os_driver(&self) -> std::option::Option<&str> {
        self.os_driver.as_deref()
    }
    /// <p> The timestamp of when the application component was assessed. </p>
    pub fn last_analyzed_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_analyzed_timestamp.as_ref()
    }
    /// <p> The ID of the server that the application component is running on. </p>
    pub fn associated_server_id(&self) -> std::option::Option<&str> {
        self.associated_server_id.as_deref()
    }
    /// <p> Set to true if the application component is running on multiple servers.</p>
    pub fn more_server_association_exists(&self) -> std::option::Option<bool> {
        self.more_server_association_exists
    }
    /// <p>The status of the application unit.</p>
    pub fn runtime_status(&self) -> std::option::Option<&crate::model::RuntimeAnalysisStatus> {
        self.runtime_status.as_ref()
    }
    /// <p>The status message for the application unit.</p>
    pub fn runtime_status_message(&self) -> std::option::Option<&str> {
        self.runtime_status_message.as_deref()
    }
    /// <p>The error in the analysis of the source code or database.</p>
    pub fn app_unit_error(&self) -> std::option::Option<&crate::model::AppUnitError> {
        self.app_unit_error.as_ref()
    }
}
/// See [`ApplicationComponentDetail`](crate::model::ApplicationComponentDetail).
pub mod application_component_detail {

    /// A builder for [`ApplicationComponentDetail`](crate::model::ApplicationComponentDetail).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) recommendation_set: std::option::Option<crate::model::RecommendationSet>,
        pub(crate) analysis_status: std::option::Option<crate::model::SrcCodeOrDbAnalysisStatus>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) list_antipattern_severity_summary:
            std::option::Option<std::vec::Vec<crate::model::AntipatternSeveritySummary>>,
        pub(crate) database_config_detail: std::option::Option<crate::model::DatabaseConfigDetail>,
        pub(crate) source_code_repositories:
            std::option::Option<std::vec::Vec<crate::model::SourceCodeRepository>>,
        pub(crate) app_type: std::option::Option<crate::model::AppType>,
        pub(crate) resource_sub_type: std::option::Option<crate::model::ResourceSubType>,
        pub(crate) inclusion_status: std::option::Option<crate::model::InclusionStatus>,
        pub(crate) antipattern_report_s3_object: std::option::Option<crate::model::S3Object>,
        pub(crate) antipattern_report_status:
            std::option::Option<crate::model::AntipatternReportStatus>,
        pub(crate) antipattern_report_status_message: std::option::Option<std::string::String>,
        pub(crate) os_version: std::option::Option<std::string::String>,
        pub(crate) os_driver: std::option::Option<std::string::String>,
        pub(crate) last_analyzed_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) associated_server_id: std::option::Option<std::string::String>,
        pub(crate) more_server_association_exists: std::option::Option<bool>,
        pub(crate) runtime_status: std::option::Option<crate::model::RuntimeAnalysisStatus>,
        pub(crate) runtime_status_message: std::option::Option<std::string::String>,
        pub(crate) app_unit_error: std::option::Option<crate::model::AppUnitError>,
    }
    impl Builder {
        /// <p> The ID of the application component. </p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p> The ID of the application component. </p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p> The name of application component. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of application component. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p> The top recommendation set for the application component. </p>
        pub fn recommendation_set(mut self, input: crate::model::RecommendationSet) -> Self {
            self.recommendation_set = Some(input);
            self
        }
        /// <p> The top recommendation set for the application component. </p>
        pub fn set_recommendation_set(
            mut self,
            input: std::option::Option<crate::model::RecommendationSet>,
        ) -> Self {
            self.recommendation_set = input;
            self
        }
        /// <p> The status of analysis, if the application component has source code or an associated database. </p>
        pub fn analysis_status(mut self, input: crate::model::SrcCodeOrDbAnalysisStatus) -> Self {
            self.analysis_status = Some(input);
            self
        }
        /// <p> The status of analysis, if the application component has source code or an associated database. </p>
        pub fn set_analysis_status(
            mut self,
            input: std::option::Option<crate::model::SrcCodeOrDbAnalysisStatus>,
        ) -> Self {
            self.analysis_status = input;
            self
        }
        /// <p> A detailed description of the analysis status and any failure message. </p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p> A detailed description of the analysis status and any failure message. </p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// Appends an item to `list_antipattern_severity_summary`.
        ///
        /// To override the contents of this collection use [`set_list_antipattern_severity_summary`](Self::set_list_antipattern_severity_summary).
        ///
        /// <p> A list of anti-pattern severity summaries. </p>
        pub fn list_antipattern_severity_summary(
            mut self,
            input: crate::model::AntipatternSeveritySummary,
        ) -> Self {
            let mut v = self.list_antipattern_severity_summary.unwrap_or_default();
            v.push(input);
            self.list_antipattern_severity_summary = Some(v);
            self
        }
        /// <p> A list of anti-pattern severity summaries. </p>
        pub fn set_list_antipattern_severity_summary(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AntipatternSeveritySummary>>,
        ) -> Self {
            self.list_antipattern_severity_summary = input;
            self
        }
        /// <p> Configuration details for the database associated with the application component. </p>
        pub fn database_config_detail(mut self, input: crate::model::DatabaseConfigDetail) -> Self {
            self.database_config_detail = Some(input);
            self
        }
        /// <p> Configuration details for the database associated with the application component. </p>
        pub fn set_database_config_detail(
            mut self,
            input: std::option::Option<crate::model::DatabaseConfigDetail>,
        ) -> Self {
            self.database_config_detail = input;
            self
        }
        /// Appends an item to `source_code_repositories`.
        ///
        /// To override the contents of this collection use [`set_source_code_repositories`](Self::set_source_code_repositories).
        ///
        /// <p> Details about the source code repository associated with the application component. </p>
        pub fn source_code_repositories(
            mut self,
            input: crate::model::SourceCodeRepository,
        ) -> Self {
            let mut v = self.source_code_repositories.unwrap_or_default();
            v.push(input);
            self.source_code_repositories = Some(v);
            self
        }
        /// <p> Details about the source code repository associated with the application component. </p>
        pub fn set_source_code_repositories(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SourceCodeRepository>>,
        ) -> Self {
            self.source_code_repositories = input;
            self
        }
        /// <p> The type of application component. </p>
        pub fn app_type(mut self, input: crate::model::AppType) -> Self {
            self.app_type = Some(input);
            self
        }
        /// <p> The type of application component. </p>
        pub fn set_app_type(mut self, input: std::option::Option<crate::model::AppType>) -> Self {
            self.app_type = input;
            self
        }
        /// <p> The application component subtype.</p>
        pub fn resource_sub_type(mut self, input: crate::model::ResourceSubType) -> Self {
            self.resource_sub_type = Some(input);
            self
        }
        /// <p> The application component subtype.</p>
        pub fn set_resource_sub_type(
            mut self,
            input: std::option::Option<crate::model::ResourceSubType>,
        ) -> Self {
            self.resource_sub_type = input;
            self
        }
        /// <p> Indicates whether the application component has been included for server recommendation or not. </p>
        pub fn inclusion_status(mut self, input: crate::model::InclusionStatus) -> Self {
            self.inclusion_status = Some(input);
            self
        }
        /// <p> Indicates whether the application component has been included for server recommendation or not. </p>
        pub fn set_inclusion_status(
            mut self,
            input: std::option::Option<crate::model::InclusionStatus>,
        ) -> Self {
            self.inclusion_status = input;
            self
        }
        /// <p> The S3 bucket name and the Amazon S3 key name for the anti-pattern report. </p>
        pub fn antipattern_report_s3_object(mut self, input: crate::model::S3Object) -> Self {
            self.antipattern_report_s3_object = Some(input);
            self
        }
        /// <p> The S3 bucket name and the Amazon S3 key name for the anti-pattern report. </p>
        pub fn set_antipattern_report_s3_object(
            mut self,
            input: std::option::Option<crate::model::S3Object>,
        ) -> Self {
            self.antipattern_report_s3_object = input;
            self
        }
        /// <p> The status of the anti-pattern report generation.</p>
        pub fn antipattern_report_status(
            mut self,
            input: crate::model::AntipatternReportStatus,
        ) -> Self {
            self.antipattern_report_status = Some(input);
            self
        }
        /// <p> The status of the anti-pattern report generation.</p>
        pub fn set_antipattern_report_status(
            mut self,
            input: std::option::Option<crate::model::AntipatternReportStatus>,
        ) -> Self {
            self.antipattern_report_status = input;
            self
        }
        /// <p> The status message for the anti-pattern. </p>
        pub fn antipattern_report_status_message(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.antipattern_report_status_message = Some(input.into());
            self
        }
        /// <p> The status message for the anti-pattern. </p>
        pub fn set_antipattern_report_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.antipattern_report_status_message = input;
            self
        }
        /// <p> OS version. </p>
        pub fn os_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.os_version = Some(input.into());
            self
        }
        /// <p> OS version. </p>
        pub fn set_os_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.os_version = input;
            self
        }
        /// <p> OS driver. </p>
        pub fn os_driver(mut self, input: impl Into<std::string::String>) -> Self {
            self.os_driver = Some(input.into());
            self
        }
        /// <p> OS driver. </p>
        pub fn set_os_driver(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.os_driver = input;
            self
        }
        /// <p> The timestamp of when the application component was assessed. </p>
        pub fn last_analyzed_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_analyzed_timestamp = Some(input);
            self
        }
        /// <p> The timestamp of when the application component was assessed. </p>
        pub fn set_last_analyzed_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_analyzed_timestamp = input;
            self
        }
        /// <p> The ID of the server that the application component is running on. </p>
        pub fn associated_server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.associated_server_id = Some(input.into());
            self
        }
        /// <p> The ID of the server that the application component is running on. </p>
        pub fn set_associated_server_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.associated_server_id = input;
            self
        }
        /// <p> Set to true if the application component is running on multiple servers.</p>
        pub fn more_server_association_exists(mut self, input: bool) -> Self {
            self.more_server_association_exists = Some(input);
            self
        }
        /// <p> Set to true if the application component is running on multiple servers.</p>
        pub fn set_more_server_association_exists(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.more_server_association_exists = input;
            self
        }
        /// <p>The status of the application unit.</p>
        pub fn runtime_status(mut self, input: crate::model::RuntimeAnalysisStatus) -> Self {
            self.runtime_status = Some(input);
            self
        }
        /// <p>The status of the application unit.</p>
        pub fn set_runtime_status(
            mut self,
            input: std::option::Option<crate::model::RuntimeAnalysisStatus>,
        ) -> Self {
            self.runtime_status = input;
            self
        }
        /// <p>The status message for the application unit.</p>
        pub fn runtime_status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.runtime_status_message = Some(input.into());
            self
        }
        /// <p>The status message for the application unit.</p>
        pub fn set_runtime_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.runtime_status_message = input;
            self
        }
        /// <p>The error in the analysis of the source code or database.</p>
        pub fn app_unit_error(mut self, input: crate::model::AppUnitError) -> Self {
            self.app_unit_error = Some(input);
            self
        }
        /// <p>The error in the analysis of the source code or database.</p>
        pub fn set_app_unit_error(
            mut self,
            input: std::option::Option<crate::model::AppUnitError>,
        ) -> Self {
            self.app_unit_error = input;
            self
        }
        /// Consumes the builder and constructs a [`ApplicationComponentDetail`](crate::model::ApplicationComponentDetail).
        pub fn build(self) -> crate::model::ApplicationComponentDetail {
            crate::model::ApplicationComponentDetail {
                id: self.id,
                name: self.name,
                recommendation_set: self.recommendation_set,
                analysis_status: self.analysis_status,
                status_message: self.status_message,
                list_antipattern_severity_summary: self.list_antipattern_severity_summary,
                database_config_detail: self.database_config_detail,
                source_code_repositories: self.source_code_repositories,
                app_type: self.app_type,
                resource_sub_type: self.resource_sub_type,
                inclusion_status: self.inclusion_status,
                antipattern_report_s3_object: self.antipattern_report_s3_object,
                antipattern_report_status: self.antipattern_report_status,
                antipattern_report_status_message: self.antipattern_report_status_message,
                os_version: self.os_version,
                os_driver: self.os_driver,
                last_analyzed_timestamp: self.last_analyzed_timestamp,
                associated_server_id: self.associated_server_id,
                more_server_association_exists: self.more_server_association_exists,
                runtime_status: self.runtime_status,
                runtime_status_message: self.runtime_status_message,
                app_unit_error: self.app_unit_error,
            }
        }
    }
}
impl ApplicationComponentDetail {
    /// Creates a new builder-style object to manufacture [`ApplicationComponentDetail`](crate::model::ApplicationComponentDetail).
    pub fn builder() -> crate::model::application_component_detail::Builder {
        crate::model::application_component_detail::Builder::default()
    }
}

/// <p>Error in the analysis of the application unit.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AppUnitError {
    /// <p>The category of the error.</p>
    #[doc(hidden)]
    pub app_unit_error_category: std::option::Option<crate::model::AppUnitErrorCategory>,
}
impl AppUnitError {
    /// <p>The category of the error.</p>
    pub fn app_unit_error_category(
        &self,
    ) -> std::option::Option<&crate::model::AppUnitErrorCategory> {
        self.app_unit_error_category.as_ref()
    }
}
/// See [`AppUnitError`](crate::model::AppUnitError).
pub mod app_unit_error {

    /// A builder for [`AppUnitError`](crate::model::AppUnitError).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_unit_error_category: std::option::Option<crate::model::AppUnitErrorCategory>,
    }
    impl Builder {
        /// <p>The category of the error.</p>
        pub fn app_unit_error_category(
            mut self,
            input: crate::model::AppUnitErrorCategory,
        ) -> Self {
            self.app_unit_error_category = Some(input);
            self
        }
        /// <p>The category of the error.</p>
        pub fn set_app_unit_error_category(
            mut self,
            input: std::option::Option<crate::model::AppUnitErrorCategory>,
        ) -> Self {
            self.app_unit_error_category = input;
            self
        }
        /// Consumes the builder and constructs a [`AppUnitError`](crate::model::AppUnitError).
        pub fn build(self) -> crate::model::AppUnitError {
            crate::model::AppUnitError {
                app_unit_error_category: self.app_unit_error_category,
            }
        }
    }
}
impl AppUnitError {
    /// Creates a new builder-style object to manufacture [`AppUnitError`](crate::model::AppUnitError).
    pub fn builder() -> crate::model::app_unit_error::Builder {
        crate::model::app_unit_error::Builder::default()
    }
}

/// When writing a match expression against `AppUnitErrorCategory`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let appuniterrorcategory = unimplemented!();
/// match appuniterrorcategory {
///     AppUnitErrorCategory::ConnectivityError => { /* ... */ },
///     AppUnitErrorCategory::CredentialError => { /* ... */ },
///     AppUnitErrorCategory::OtherError => { /* ... */ },
///     AppUnitErrorCategory::PermissionError => { /* ... */ },
///     AppUnitErrorCategory::UnsupportedError => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `appuniterrorcategory` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AppUnitErrorCategory::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AppUnitErrorCategory::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AppUnitErrorCategory::NewFeature` is defined.
/// Specifically, when `appuniterrorcategory` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AppUnitErrorCategory::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AppUnitErrorCategory {
    #[allow(missing_docs)] // documentation missing in model
    ConnectivityError,
    #[allow(missing_docs)] // documentation missing in model
    CredentialError,
    #[allow(missing_docs)] // documentation missing in model
    OtherError,
    #[allow(missing_docs)] // documentation missing in model
    PermissionError,
    #[allow(missing_docs)] // documentation missing in model
    UnsupportedError,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AppUnitErrorCategory {
    fn from(s: &str) -> Self {
        match s {
            "CONNECTIVITY_ERROR" => AppUnitErrorCategory::ConnectivityError,
            "CREDENTIAL_ERROR" => AppUnitErrorCategory::CredentialError,
            "OTHER_ERROR" => AppUnitErrorCategory::OtherError,
            "PERMISSION_ERROR" => AppUnitErrorCategory::PermissionError,
            "UNSUPPORTED_ERROR" => AppUnitErrorCategory::UnsupportedError,
            other => {
                AppUnitErrorCategory::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for AppUnitErrorCategory {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AppUnitErrorCategory::from(s))
    }
}
impl AppUnitErrorCategory {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AppUnitErrorCategory::ConnectivityError => "CONNECTIVITY_ERROR",
            AppUnitErrorCategory::CredentialError => "CREDENTIAL_ERROR",
            AppUnitErrorCategory::OtherError => "OTHER_ERROR",
            AppUnitErrorCategory::PermissionError => "PERMISSION_ERROR",
            AppUnitErrorCategory::UnsupportedError => "UNSUPPORTED_ERROR",
            AppUnitErrorCategory::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CONNECTIVITY_ERROR",
            "CREDENTIAL_ERROR",
            "OTHER_ERROR",
            "PERMISSION_ERROR",
            "UNSUPPORTED_ERROR",
        ]
    }
}
impl AsRef<str> for AppUnitErrorCategory {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `RuntimeAnalysisStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let runtimeanalysisstatus = unimplemented!();
/// match runtimeanalysisstatus {
///     RuntimeAnalysisStatus::AnalysisFailed => { /* ... */ },
///     RuntimeAnalysisStatus::AnalysisStarted => { /* ... */ },
///     RuntimeAnalysisStatus::AnalysisSuccess => { /* ... */ },
///     RuntimeAnalysisStatus::AnalysisToBeScheduled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `runtimeanalysisstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RuntimeAnalysisStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RuntimeAnalysisStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RuntimeAnalysisStatus::NewFeature` is defined.
/// Specifically, when `runtimeanalysisstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RuntimeAnalysisStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RuntimeAnalysisStatus {
    #[allow(missing_docs)] // documentation missing in model
    AnalysisFailed,
    #[allow(missing_docs)] // documentation missing in model
    AnalysisStarted,
    #[allow(missing_docs)] // documentation missing in model
    AnalysisSuccess,
    #[allow(missing_docs)] // documentation missing in model
    AnalysisToBeScheduled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RuntimeAnalysisStatus {
    fn from(s: &str) -> Self {
        match s {
            "ANALYSIS_FAILED" => RuntimeAnalysisStatus::AnalysisFailed,
            "ANALYSIS_STARTED" => RuntimeAnalysisStatus::AnalysisStarted,
            "ANALYSIS_SUCCESS" => RuntimeAnalysisStatus::AnalysisSuccess,
            "ANALYSIS_TO_BE_SCHEDULED" => RuntimeAnalysisStatus::AnalysisToBeScheduled,
            other => {
                RuntimeAnalysisStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for RuntimeAnalysisStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RuntimeAnalysisStatus::from(s))
    }
}
impl RuntimeAnalysisStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RuntimeAnalysisStatus::AnalysisFailed => "ANALYSIS_FAILED",
            RuntimeAnalysisStatus::AnalysisStarted => "ANALYSIS_STARTED",
            RuntimeAnalysisStatus::AnalysisSuccess => "ANALYSIS_SUCCESS",
            RuntimeAnalysisStatus::AnalysisToBeScheduled => "ANALYSIS_TO_BE_SCHEDULED",
            RuntimeAnalysisStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ANALYSIS_FAILED",
            "ANALYSIS_STARTED",
            "ANALYSIS_SUCCESS",
            "ANALYSIS_TO_BE_SCHEDULED",
        ]
    }
}
impl AsRef<str> for RuntimeAnalysisStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ResourceSubType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let resourcesubtype = unimplemented!();
/// match resourcesubtype {
///     ResourceSubType::Database => { /* ... */ },
///     ResourceSubType::DatabaseProcess => { /* ... */ },
///     ResourceSubType::Process => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `resourcesubtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ResourceSubType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ResourceSubType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ResourceSubType::NewFeature` is defined.
/// Specifically, when `resourcesubtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ResourceSubType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceSubType {
    #[allow(missing_docs)] // documentation missing in model
    Database,
    #[allow(missing_docs)] // documentation missing in model
    DatabaseProcess,
    #[allow(missing_docs)] // documentation missing in model
    Process,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ResourceSubType {
    fn from(s: &str) -> Self {
        match s {
            "Database" => ResourceSubType::Database,
            "DatabaseProcess" => ResourceSubType::DatabaseProcess,
            "Process" => ResourceSubType::Process,
            other => ResourceSubType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ResourceSubType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResourceSubType::from(s))
    }
}
impl ResourceSubType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ResourceSubType::Database => "Database",
            ResourceSubType::DatabaseProcess => "DatabaseProcess",
            ResourceSubType::Process => "Process",
            ResourceSubType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Database", "DatabaseProcess", "Process"]
    }
}
impl AsRef<str> for ResourceSubType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> Object containing source code information that is linked to an application component. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SourceCodeRepository {
    /// <p> The repository name for the source code. </p>
    #[doc(hidden)]
    pub repository: std::option::Option<std::string::String>,
    /// <p> The branch of the source code. </p>
    #[doc(hidden)]
    pub branch: std::option::Option<std::string::String>,
    /// <p> The type of repository to use for the source code. </p>
    #[doc(hidden)]
    pub version_control_type: std::option::Option<std::string::String>,
    /// <p>The name of the project.</p>
    #[doc(hidden)]
    pub project_name: std::option::Option<std::string::String>,
}
impl SourceCodeRepository {
    /// <p> The repository name for the source code. </p>
    pub fn repository(&self) -> std::option::Option<&str> {
        self.repository.as_deref()
    }
    /// <p> The branch of the source code. </p>
    pub fn branch(&self) -> std::option::Option<&str> {
        self.branch.as_deref()
    }
    /// <p> The type of repository to use for the source code. </p>
    pub fn version_control_type(&self) -> std::option::Option<&str> {
        self.version_control_type.as_deref()
    }
    /// <p>The name of the project.</p>
    pub fn project_name(&self) -> std::option::Option<&str> {
        self.project_name.as_deref()
    }
}
/// See [`SourceCodeRepository`](crate::model::SourceCodeRepository).
pub mod source_code_repository {

    /// A builder for [`SourceCodeRepository`](crate::model::SourceCodeRepository).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) repository: std::option::Option<std::string::String>,
        pub(crate) branch: std::option::Option<std::string::String>,
        pub(crate) version_control_type: std::option::Option<std::string::String>,
        pub(crate) project_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The repository name for the source code. </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository = Some(input.into());
            self
        }
        /// <p> The repository name for the source code. </p>
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.repository = input;
            self
        }
        /// <p> The branch of the source code. </p>
        pub fn branch(mut self, input: impl Into<std::string::String>) -> Self {
            self.branch = Some(input.into());
            self
        }
        /// <p> The branch of the source code. </p>
        pub fn set_branch(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.branch = input;
            self
        }
        /// <p> The type of repository to use for the source code. </p>
        pub fn version_control_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_control_type = Some(input.into());
            self
        }
        /// <p> The type of repository to use for the source code. </p>
        pub fn set_version_control_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.version_control_type = input;
            self
        }
        /// <p>The name of the project.</p>
        pub fn project_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_name = Some(input.into());
            self
        }
        /// <p>The name of the project.</p>
        pub fn set_project_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_name = input;
            self
        }
        /// Consumes the builder and constructs a [`SourceCodeRepository`](crate::model::SourceCodeRepository).
        pub fn build(self) -> crate::model::SourceCodeRepository {
            crate::model::SourceCodeRepository {
                repository: self.repository,
                branch: self.branch,
                version_control_type: self.version_control_type,
                project_name: self.project_name,
            }
        }
    }
}
impl SourceCodeRepository {
    /// Creates a new builder-style object to manufacture [`SourceCodeRepository`](crate::model::SourceCodeRepository).
    pub fn builder() -> crate::model::source_code_repository::Builder {
        crate::model::source_code_repository::Builder::default()
    }
}

/// <p> Configuration information used for assessing databases. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DatabaseConfigDetail {
    /// <p> AWS Secrets Manager key that holds the credentials that you use to connect to a database. </p>
    #[doc(hidden)]
    pub secret_name: std::option::Option<std::string::String>,
}
impl DatabaseConfigDetail {
    /// <p> AWS Secrets Manager key that holds the credentials that you use to connect to a database. </p>
    pub fn secret_name(&self) -> std::option::Option<&str> {
        self.secret_name.as_deref()
    }
}
/// See [`DatabaseConfigDetail`](crate::model::DatabaseConfigDetail).
pub mod database_config_detail {

    /// A builder for [`DatabaseConfigDetail`](crate::model::DatabaseConfigDetail).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) secret_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> AWS Secrets Manager key that holds the credentials that you use to connect to a database. </p>
        pub fn secret_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.secret_name = Some(input.into());
            self
        }
        /// <p> AWS Secrets Manager key that holds the credentials that you use to connect to a database. </p>
        pub fn set_secret_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.secret_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DatabaseConfigDetail`](crate::model::DatabaseConfigDetail).
        pub fn build(self) -> crate::model::DatabaseConfigDetail {
            crate::model::DatabaseConfigDetail {
                secret_name: self.secret_name,
            }
        }
    }
}
impl DatabaseConfigDetail {
    /// Creates a new builder-style object to manufacture [`DatabaseConfigDetail`](crate::model::DatabaseConfigDetail).
    pub fn builder() -> crate::model::database_config_detail::Builder {
        crate::model::database_config_detail::Builder::default()
    }
}

/// When writing a match expression against `SrcCodeOrDbAnalysisStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let srccodeordbanalysisstatus = unimplemented!();
/// match srccodeordbanalysisstatus {
///     SrcCodeOrDbAnalysisStatus::AnalysisFailed => { /* ... */ },
///     SrcCodeOrDbAnalysisStatus::AnalysisPartialSuccess => { /* ... */ },
///     SrcCodeOrDbAnalysisStatus::AnalysisStarted => { /* ... */ },
///     SrcCodeOrDbAnalysisStatus::AnalysisSuccess => { /* ... */ },
///     SrcCodeOrDbAnalysisStatus::AnalysisToBeScheduled => { /* ... */ },
///     SrcCodeOrDbAnalysisStatus::Configured => { /* ... */ },
///     SrcCodeOrDbAnalysisStatus::Unconfigured => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `srccodeordbanalysisstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SrcCodeOrDbAnalysisStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SrcCodeOrDbAnalysisStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SrcCodeOrDbAnalysisStatus::NewFeature` is defined.
/// Specifically, when `srccodeordbanalysisstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SrcCodeOrDbAnalysisStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SrcCodeOrDbAnalysisStatus {
    #[allow(missing_docs)] // documentation missing in model
    AnalysisFailed,
    #[allow(missing_docs)] // documentation missing in model
    AnalysisPartialSuccess,
    #[allow(missing_docs)] // documentation missing in model
    AnalysisStarted,
    #[allow(missing_docs)] // documentation missing in model
    AnalysisSuccess,
    #[allow(missing_docs)] // documentation missing in model
    AnalysisToBeScheduled,
    #[allow(missing_docs)] // documentation missing in model
    Configured,
    #[allow(missing_docs)] // documentation missing in model
    Unconfigured,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SrcCodeOrDbAnalysisStatus {
    fn from(s: &str) -> Self {
        match s {
            "ANALYSIS_FAILED" => SrcCodeOrDbAnalysisStatus::AnalysisFailed,
            "ANALYSIS_PARTIAL_SUCCESS" => SrcCodeOrDbAnalysisStatus::AnalysisPartialSuccess,
            "ANALYSIS_STARTED" => SrcCodeOrDbAnalysisStatus::AnalysisStarted,
            "ANALYSIS_SUCCESS" => SrcCodeOrDbAnalysisStatus::AnalysisSuccess,
            "ANALYSIS_TO_BE_SCHEDULED" => SrcCodeOrDbAnalysisStatus::AnalysisToBeScheduled,
            "CONFIGURED" => SrcCodeOrDbAnalysisStatus::Configured,
            "UNCONFIGURED" => SrcCodeOrDbAnalysisStatus::Unconfigured,
            other => SrcCodeOrDbAnalysisStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for SrcCodeOrDbAnalysisStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SrcCodeOrDbAnalysisStatus::from(s))
    }
}
impl SrcCodeOrDbAnalysisStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SrcCodeOrDbAnalysisStatus::AnalysisFailed => "ANALYSIS_FAILED",
            SrcCodeOrDbAnalysisStatus::AnalysisPartialSuccess => "ANALYSIS_PARTIAL_SUCCESS",
            SrcCodeOrDbAnalysisStatus::AnalysisStarted => "ANALYSIS_STARTED",
            SrcCodeOrDbAnalysisStatus::AnalysisSuccess => "ANALYSIS_SUCCESS",
            SrcCodeOrDbAnalysisStatus::AnalysisToBeScheduled => "ANALYSIS_TO_BE_SCHEDULED",
            SrcCodeOrDbAnalysisStatus::Configured => "CONFIGURED",
            SrcCodeOrDbAnalysisStatus::Unconfigured => "UNCONFIGURED",
            SrcCodeOrDbAnalysisStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ANALYSIS_FAILED",
            "ANALYSIS_PARTIAL_SUCCESS",
            "ANALYSIS_STARTED",
            "ANALYSIS_SUCCESS",
            "ANALYSIS_TO_BE_SCHEDULED",
            "CONFIGURED",
            "UNCONFIGURED",
        ]
    }
}
impl AsRef<str> for SrcCodeOrDbAnalysisStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ApplicationComponentCriteria`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let applicationcomponentcriteria = unimplemented!();
/// match applicationcomponentcriteria {
///     ApplicationComponentCriteria::AnalysisStatus => { /* ... */ },
///     ApplicationComponentCriteria::AppName => { /* ... */ },
///     ApplicationComponentCriteria::AppType => { /* ... */ },
///     ApplicationComponentCriteria::Destination => { /* ... */ },
///     ApplicationComponentCriteria::ErrorCategory => { /* ... */ },
///     ApplicationComponentCriteria::NotDefined => { /* ... */ },
///     ApplicationComponentCriteria::ServerId => { /* ... */ },
///     ApplicationComponentCriteria::Strategy => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `applicationcomponentcriteria` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ApplicationComponentCriteria::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ApplicationComponentCriteria::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ApplicationComponentCriteria::NewFeature` is defined.
/// Specifically, when `applicationcomponentcriteria` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ApplicationComponentCriteria::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ApplicationComponentCriteria {
    #[allow(missing_docs)] // documentation missing in model
    AnalysisStatus,
    #[allow(missing_docs)] // documentation missing in model
    AppName,
    #[allow(missing_docs)] // documentation missing in model
    AppType,
    #[allow(missing_docs)] // documentation missing in model
    Destination,
    #[allow(missing_docs)] // documentation missing in model
    ErrorCategory,
    #[allow(missing_docs)] // documentation missing in model
    NotDefined,
    #[allow(missing_docs)] // documentation missing in model
    ServerId,
    #[allow(missing_docs)] // documentation missing in model
    Strategy,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ApplicationComponentCriteria {
    fn from(s: &str) -> Self {
        match s {
            "ANALYSIS_STATUS" => ApplicationComponentCriteria::AnalysisStatus,
            "APP_NAME" => ApplicationComponentCriteria::AppName,
            "APP_TYPE" => ApplicationComponentCriteria::AppType,
            "DESTINATION" => ApplicationComponentCriteria::Destination,
            "ERROR_CATEGORY" => ApplicationComponentCriteria::ErrorCategory,
            "NOT_DEFINED" => ApplicationComponentCriteria::NotDefined,
            "SERVER_ID" => ApplicationComponentCriteria::ServerId,
            "STRATEGY" => ApplicationComponentCriteria::Strategy,
            other => ApplicationComponentCriteria::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ApplicationComponentCriteria {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ApplicationComponentCriteria::from(s))
    }
}
impl ApplicationComponentCriteria {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ApplicationComponentCriteria::AnalysisStatus => "ANALYSIS_STATUS",
            ApplicationComponentCriteria::AppName => "APP_NAME",
            ApplicationComponentCriteria::AppType => "APP_TYPE",
            ApplicationComponentCriteria::Destination => "DESTINATION",
            ApplicationComponentCriteria::ErrorCategory => "ERROR_CATEGORY",
            ApplicationComponentCriteria::NotDefined => "NOT_DEFINED",
            ApplicationComponentCriteria::ServerId => "SERVER_ID",
            ApplicationComponentCriteria::Strategy => "STRATEGY",
            ApplicationComponentCriteria::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ANALYSIS_STATUS",
            "APP_NAME",
            "APP_TYPE",
            "DESTINATION",
            "ERROR_CATEGORY",
            "NOT_DEFINED",
            "SERVER_ID",
            "STRATEGY",
        ]
    }
}
impl AsRef<str> for ApplicationComponentCriteria {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> Contains information about a strategy recommendation for a server. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServerStrategy {
    /// <p> Strategy recommendation for the server. </p>
    #[doc(hidden)]
    pub recommendation: std::option::Option<crate::model::RecommendationSet>,
    /// <p> The recommendation status of the strategy for the server. </p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::StrategyRecommendation>,
    /// <p> The number of application components with this strategy recommendation running on the server. </p>
    #[doc(hidden)]
    pub number_of_application_components: std::option::Option<i32>,
    /// <p> Set to true if the recommendation is set as preferred. </p>
    #[doc(hidden)]
    pub is_preferred: std::option::Option<bool>,
}
impl ServerStrategy {
    /// <p> Strategy recommendation for the server. </p>
    pub fn recommendation(&self) -> std::option::Option<&crate::model::RecommendationSet> {
        self.recommendation.as_ref()
    }
    /// <p> The recommendation status of the strategy for the server. </p>
    pub fn status(&self) -> std::option::Option<&crate::model::StrategyRecommendation> {
        self.status.as_ref()
    }
    /// <p> The number of application components with this strategy recommendation running on the server. </p>
    pub fn number_of_application_components(&self) -> std::option::Option<i32> {
        self.number_of_application_components
    }
    /// <p> Set to true if the recommendation is set as preferred. </p>
    pub fn is_preferred(&self) -> std::option::Option<bool> {
        self.is_preferred
    }
}
/// See [`ServerStrategy`](crate::model::ServerStrategy).
pub mod server_strategy {

    /// A builder for [`ServerStrategy`](crate::model::ServerStrategy).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) recommendation: std::option::Option<crate::model::RecommendationSet>,
        pub(crate) status: std::option::Option<crate::model::StrategyRecommendation>,
        pub(crate) number_of_application_components: std::option::Option<i32>,
        pub(crate) is_preferred: std::option::Option<bool>,
    }
    impl Builder {
        /// <p> Strategy recommendation for the server. </p>
        pub fn recommendation(mut self, input: crate::model::RecommendationSet) -> Self {
            self.recommendation = Some(input);
            self
        }
        /// <p> Strategy recommendation for the server. </p>
        pub fn set_recommendation(
            mut self,
            input: std::option::Option<crate::model::RecommendationSet>,
        ) -> Self {
            self.recommendation = input;
            self
        }
        /// <p> The recommendation status of the strategy for the server. </p>
        pub fn status(mut self, input: crate::model::StrategyRecommendation) -> Self {
            self.status = Some(input);
            self
        }
        /// <p> The recommendation status of the strategy for the server. </p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::StrategyRecommendation>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p> The number of application components with this strategy recommendation running on the server. </p>
        pub fn number_of_application_components(mut self, input: i32) -> Self {
            self.number_of_application_components = Some(input);
            self
        }
        /// <p> The number of application components with this strategy recommendation running on the server. </p>
        pub fn set_number_of_application_components(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.number_of_application_components = input;
            self
        }
        /// <p> Set to true if the recommendation is set as preferred. </p>
        pub fn is_preferred(mut self, input: bool) -> Self {
            self.is_preferred = Some(input);
            self
        }
        /// <p> Set to true if the recommendation is set as preferred. </p>
        pub fn set_is_preferred(mut self, input: std::option::Option<bool>) -> Self {
            self.is_preferred = input;
            self
        }
        /// Consumes the builder and constructs a [`ServerStrategy`](crate::model::ServerStrategy).
        pub fn build(self) -> crate::model::ServerStrategy {
            crate::model::ServerStrategy {
                recommendation: self.recommendation,
                status: self.status,
                number_of_application_components: self.number_of_application_components,
                is_preferred: self.is_preferred,
            }
        }
    }
}
impl ServerStrategy {
    /// Creates a new builder-style object to manufacture [`ServerStrategy`](crate::model::ServerStrategy).
    pub fn builder() -> crate::model::server_strategy::Builder {
        crate::model::server_strategy::Builder::default()
    }
}

/// When writing a match expression against `StrategyRecommendation`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let strategyrecommendation = unimplemented!();
/// match strategyrecommendation {
///     StrategyRecommendation::NotRecommended => { /* ... */ },
///     StrategyRecommendation::Potential => { /* ... */ },
///     StrategyRecommendation::Recommended => { /* ... */ },
///     StrategyRecommendation::ViableOption => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `strategyrecommendation` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StrategyRecommendation::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StrategyRecommendation::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StrategyRecommendation::NewFeature` is defined.
/// Specifically, when `strategyrecommendation` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StrategyRecommendation::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StrategyRecommendation {
    #[allow(missing_docs)] // documentation missing in model
    NotRecommended,
    #[allow(missing_docs)] // documentation missing in model
    Potential,
    #[allow(missing_docs)] // documentation missing in model
    Recommended,
    #[allow(missing_docs)] // documentation missing in model
    ViableOption,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StrategyRecommendation {
    fn from(s: &str) -> Self {
        match s {
            "notRecommended" => StrategyRecommendation::NotRecommended,
            "potential" => StrategyRecommendation::Potential,
            "recommended" => StrategyRecommendation::Recommended,
            "viableOption" => StrategyRecommendation::ViableOption,
            other => {
                StrategyRecommendation::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for StrategyRecommendation {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StrategyRecommendation::from(s))
    }
}
impl StrategyRecommendation {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StrategyRecommendation::NotRecommended => "notRecommended",
            StrategyRecommendation::Potential => "potential",
            StrategyRecommendation::Recommended => "recommended",
            StrategyRecommendation::ViableOption => "viableOption",
            StrategyRecommendation::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["notRecommended", "potential", "recommended", "viableOption"]
    }
}
impl AsRef<str> for StrategyRecommendation {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> Object containing details about applications as defined in Application Discovery Service. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssociatedApplication {
    /// <p> Name of the application as defined in Application Discovery Service. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p> ID of the application as defined in Application Discovery Service. </p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl AssociatedApplication {
    /// <p> Name of the application as defined in Application Discovery Service. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p> ID of the application as defined in Application Discovery Service. </p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
}
/// See [`AssociatedApplication`](crate::model::AssociatedApplication).
pub mod associated_application {

    /// A builder for [`AssociatedApplication`](crate::model::AssociatedApplication).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> Name of the application as defined in Application Discovery Service. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> Name of the application as defined in Application Discovery Service. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p> ID of the application as defined in Application Discovery Service. </p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p> ID of the application as defined in Application Discovery Service. </p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociatedApplication`](crate::model::AssociatedApplication).
        pub fn build(self) -> crate::model::AssociatedApplication {
            crate::model::AssociatedApplication {
                name: self.name,
                id: self.id,
            }
        }
    }
}
impl AssociatedApplication {
    /// Creates a new builder-style object to manufacture [`AssociatedApplication`](crate::model::AssociatedApplication).
    pub fn builder() -> crate::model::associated_application::Builder {
        crate::model::associated_application::Builder::default()
    }
}

/// <p> Contains detailed information about a recommendation report. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RecommendationReportDetails {
    /// <p> The status of the recommendation report generation task. </p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::RecommendationReportStatus>,
    /// <p> The status message for recommendation report generation. </p>
    #[doc(hidden)]
    pub status_message: std::option::Option<std::string::String>,
    /// <p> The time that the recommendation report generation task starts. </p>
    #[doc(hidden)]
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p> The time that the recommendation report generation task completes. </p>
    #[doc(hidden)]
    pub completion_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p> The S3 bucket where the report file is located. </p>
    #[doc(hidden)]
    pub s3_bucket: std::option::Option<std::string::String>,
    /// <p> The Amazon S3 key name of the report file. </p>
    #[doc(hidden)]
    pub s3_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl RecommendationReportDetails {
    /// <p> The status of the recommendation report generation task. </p>
    pub fn status(&self) -> std::option::Option<&crate::model::RecommendationReportStatus> {
        self.status.as_ref()
    }
    /// <p> The status message for recommendation report generation. </p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
    /// <p> The time that the recommendation report generation task starts. </p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p> The time that the recommendation report generation task completes. </p>
    pub fn completion_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.completion_time.as_ref()
    }
    /// <p> The S3 bucket where the report file is located. </p>
    pub fn s3_bucket(&self) -> std::option::Option<&str> {
        self.s3_bucket.as_deref()
    }
    /// <p> The Amazon S3 key name of the report file. </p>
    pub fn s3_keys(&self) -> std::option::Option<&[std::string::String]> {
        self.s3_keys.as_deref()
    }
}
/// See [`RecommendationReportDetails`](crate::model::RecommendationReportDetails).
pub mod recommendation_report_details {

    /// A builder for [`RecommendationReportDetails`](crate::model::RecommendationReportDetails).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::RecommendationReportStatus>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) completion_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) s3_bucket: std::option::Option<std::string::String>,
        pub(crate) s3_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p> The status of the recommendation report generation task. </p>
        pub fn status(mut self, input: crate::model::RecommendationReportStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p> The status of the recommendation report generation task. </p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::RecommendationReportStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p> The status message for recommendation report generation. </p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p> The status message for recommendation report generation. </p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p> The time that the recommendation report generation task starts. </p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p> The time that the recommendation report generation task starts. </p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p> The time that the recommendation report generation task completes. </p>
        pub fn completion_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.completion_time = Some(input);
            self
        }
        /// <p> The time that the recommendation report generation task completes. </p>
        pub fn set_completion_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.completion_time = input;
            self
        }
        /// <p> The S3 bucket where the report file is located. </p>
        pub fn s3_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_bucket = Some(input.into());
            self
        }
        /// <p> The S3 bucket where the report file is located. </p>
        pub fn set_s3_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_bucket = input;
            self
        }
        /// Appends an item to `s3_keys`.
        ///
        /// To override the contents of this collection use [`set_s3_keys`](Self::set_s3_keys).
        ///
        /// <p> The Amazon S3 key name of the report file. </p>
        pub fn s3_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.s3_keys.unwrap_or_default();
            v.push(input.into());
            self.s3_keys = Some(v);
            self
        }
        /// <p> The Amazon S3 key name of the report file. </p>
        pub fn set_s3_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.s3_keys = input;
            self
        }
        /// Consumes the builder and constructs a [`RecommendationReportDetails`](crate::model::RecommendationReportDetails).
        pub fn build(self) -> crate::model::RecommendationReportDetails {
            crate::model::RecommendationReportDetails {
                status: self.status,
                status_message: self.status_message,
                start_time: self.start_time,
                completion_time: self.completion_time,
                s3_bucket: self.s3_bucket,
                s3_keys: self.s3_keys,
            }
        }
    }
}
impl RecommendationReportDetails {
    /// Creates a new builder-style object to manufacture [`RecommendationReportDetails`](crate::model::RecommendationReportDetails).
    pub fn builder() -> crate::model::recommendation_report_details::Builder {
        crate::model::recommendation_report_details::Builder::default()
    }
}

/// When writing a match expression against `RecommendationReportStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let recommendationreportstatus = unimplemented!();
/// match recommendationreportstatus {
///     RecommendationReportStatus::Failed => { /* ... */ },
///     RecommendationReportStatus::InProgress => { /* ... */ },
///     RecommendationReportStatus::Success => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `recommendationreportstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RecommendationReportStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RecommendationReportStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RecommendationReportStatus::NewFeature` is defined.
/// Specifically, when `recommendationreportstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RecommendationReportStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RecommendationReportStatus {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Success,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RecommendationReportStatus {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => RecommendationReportStatus::Failed,
            "IN_PROGRESS" => RecommendationReportStatus::InProgress,
            "SUCCESS" => RecommendationReportStatus::Success,
            other => RecommendationReportStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for RecommendationReportStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RecommendationReportStatus::from(s))
    }
}
impl RecommendationReportStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RecommendationReportStatus::Failed => "FAILED",
            RecommendationReportStatus::InProgress => "IN_PROGRESS",
            RecommendationReportStatus::Success => "SUCCESS",
            RecommendationReportStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FAILED", "IN_PROGRESS", "SUCCESS"]
    }
}
impl AsRef<str> for RecommendationReportStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> Contains the summary of the assessment results. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssessmentSummary {
    /// <p> List of ServerStrategySummary. </p>
    #[doc(hidden)]
    pub list_server_strategy_summary:
        std::option::Option<std::vec::Vec<crate::model::StrategySummary>>,
    /// <p> List of ApplicationComponentStrategySummary. </p>
    #[doc(hidden)]
    pub list_application_component_strategy_summary:
        std::option::Option<std::vec::Vec<crate::model::StrategySummary>>,
    /// <p> List of AntipatternSeveritySummary. </p>
    #[doc(hidden)]
    pub list_antipattern_severity_summary:
        std::option::Option<std::vec::Vec<crate::model::AntipatternSeveritySummary>>,
    /// <p> List of ApplicationComponentSummary. </p>
    #[doc(hidden)]
    pub list_application_component_summary:
        std::option::Option<std::vec::Vec<crate::model::ApplicationComponentSummary>>,
    /// <p> List of ServerSummary. </p>
    #[doc(hidden)]
    pub list_server_summary: std::option::Option<std::vec::Vec<crate::model::ServerSummary>>,
    /// <p> The Amazon S3 object containing the anti-pattern report. </p>
    #[doc(hidden)]
    pub antipattern_report_s3_object: std::option::Option<crate::model::S3Object>,
    /// <p> The status of the anti-pattern report. </p>
    #[doc(hidden)]
    pub antipattern_report_status: std::option::Option<crate::model::AntipatternReportStatus>,
    /// <p> The status message of the anti-pattern report. </p>
    #[doc(hidden)]
    pub antipattern_report_status_message: std::option::Option<std::string::String>,
    /// <p> The time the assessment was performed. </p>
    #[doc(hidden)]
    pub last_analyzed_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>List of status summaries of the analyzed application components.</p>
    #[doc(hidden)]
    pub list_application_component_status_summary:
        std::option::Option<std::vec::Vec<crate::model::ApplicationComponentStatusSummary>>,
    /// <p>List of status summaries of the analyzed servers.</p>
    #[doc(hidden)]
    pub list_server_status_summary:
        std::option::Option<std::vec::Vec<crate::model::ServerStatusSummary>>,
}
impl AssessmentSummary {
    /// <p> List of ServerStrategySummary. </p>
    pub fn list_server_strategy_summary(
        &self,
    ) -> std::option::Option<&[crate::model::StrategySummary]> {
        self.list_server_strategy_summary.as_deref()
    }
    /// <p> List of ApplicationComponentStrategySummary. </p>
    pub fn list_application_component_strategy_summary(
        &self,
    ) -> std::option::Option<&[crate::model::StrategySummary]> {
        self.list_application_component_strategy_summary.as_deref()
    }
    /// <p> List of AntipatternSeveritySummary. </p>
    pub fn list_antipattern_severity_summary(
        &self,
    ) -> std::option::Option<&[crate::model::AntipatternSeveritySummary]> {
        self.list_antipattern_severity_summary.as_deref()
    }
    /// <p> List of ApplicationComponentSummary. </p>
    pub fn list_application_component_summary(
        &self,
    ) -> std::option::Option<&[crate::model::ApplicationComponentSummary]> {
        self.list_application_component_summary.as_deref()
    }
    /// <p> List of ServerSummary. </p>
    pub fn list_server_summary(&self) -> std::option::Option<&[crate::model::ServerSummary]> {
        self.list_server_summary.as_deref()
    }
    /// <p> The Amazon S3 object containing the anti-pattern report. </p>
    pub fn antipattern_report_s3_object(&self) -> std::option::Option<&crate::model::S3Object> {
        self.antipattern_report_s3_object.as_ref()
    }
    /// <p> The status of the anti-pattern report. </p>
    pub fn antipattern_report_status(
        &self,
    ) -> std::option::Option<&crate::model::AntipatternReportStatus> {
        self.antipattern_report_status.as_ref()
    }
    /// <p> The status message of the anti-pattern report. </p>
    pub fn antipattern_report_status_message(&self) -> std::option::Option<&str> {
        self.antipattern_report_status_message.as_deref()
    }
    /// <p> The time the assessment was performed. </p>
    pub fn last_analyzed_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_analyzed_timestamp.as_ref()
    }
    /// <p>List of status summaries of the analyzed application components.</p>
    pub fn list_application_component_status_summary(
        &self,
    ) -> std::option::Option<&[crate::model::ApplicationComponentStatusSummary]> {
        self.list_application_component_status_summary.as_deref()
    }
    /// <p>List of status summaries of the analyzed servers.</p>
    pub fn list_server_status_summary(
        &self,
    ) -> std::option::Option<&[crate::model::ServerStatusSummary]> {
        self.list_server_status_summary.as_deref()
    }
}
/// See [`AssessmentSummary`](crate::model::AssessmentSummary).
pub mod assessment_summary {

    /// A builder for [`AssessmentSummary`](crate::model::AssessmentSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) list_server_strategy_summary:
            std::option::Option<std::vec::Vec<crate::model::StrategySummary>>,
        pub(crate) list_application_component_strategy_summary:
            std::option::Option<std::vec::Vec<crate::model::StrategySummary>>,
        pub(crate) list_antipattern_severity_summary:
            std::option::Option<std::vec::Vec<crate::model::AntipatternSeveritySummary>>,
        pub(crate) list_application_component_summary:
            std::option::Option<std::vec::Vec<crate::model::ApplicationComponentSummary>>,
        pub(crate) list_server_summary:
            std::option::Option<std::vec::Vec<crate::model::ServerSummary>>,
        pub(crate) antipattern_report_s3_object: std::option::Option<crate::model::S3Object>,
        pub(crate) antipattern_report_status:
            std::option::Option<crate::model::AntipatternReportStatus>,
        pub(crate) antipattern_report_status_message: std::option::Option<std::string::String>,
        pub(crate) last_analyzed_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) list_application_component_status_summary:
            std::option::Option<std::vec::Vec<crate::model::ApplicationComponentStatusSummary>>,
        pub(crate) list_server_status_summary:
            std::option::Option<std::vec::Vec<crate::model::ServerStatusSummary>>,
    }
    impl Builder {
        /// Appends an item to `list_server_strategy_summary`.
        ///
        /// To override the contents of this collection use [`set_list_server_strategy_summary`](Self::set_list_server_strategy_summary).
        ///
        /// <p> List of ServerStrategySummary. </p>
        pub fn list_server_strategy_summary(
            mut self,
            input: crate::model::StrategySummary,
        ) -> Self {
            let mut v = self.list_server_strategy_summary.unwrap_or_default();
            v.push(input);
            self.list_server_strategy_summary = Some(v);
            self
        }
        /// <p> List of ServerStrategySummary. </p>
        pub fn set_list_server_strategy_summary(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StrategySummary>>,
        ) -> Self {
            self.list_server_strategy_summary = input;
            self
        }
        /// Appends an item to `list_application_component_strategy_summary`.
        ///
        /// To override the contents of this collection use [`set_list_application_component_strategy_summary`](Self::set_list_application_component_strategy_summary).
        ///
        /// <p> List of ApplicationComponentStrategySummary. </p>
        pub fn list_application_component_strategy_summary(
            mut self,
            input: crate::model::StrategySummary,
        ) -> Self {
            let mut v = self
                .list_application_component_strategy_summary
                .unwrap_or_default();
            v.push(input);
            self.list_application_component_strategy_summary = Some(v);
            self
        }
        /// <p> List of ApplicationComponentStrategySummary. </p>
        pub fn set_list_application_component_strategy_summary(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StrategySummary>>,
        ) -> Self {
            self.list_application_component_strategy_summary = input;
            self
        }
        /// Appends an item to `list_antipattern_severity_summary`.
        ///
        /// To override the contents of this collection use [`set_list_antipattern_severity_summary`](Self::set_list_antipattern_severity_summary).
        ///
        /// <p> List of AntipatternSeveritySummary. </p>
        pub fn list_antipattern_severity_summary(
            mut self,
            input: crate::model::AntipatternSeveritySummary,
        ) -> Self {
            let mut v = self.list_antipattern_severity_summary.unwrap_or_default();
            v.push(input);
            self.list_antipattern_severity_summary = Some(v);
            self
        }
        /// <p> List of AntipatternSeveritySummary. </p>
        pub fn set_list_antipattern_severity_summary(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AntipatternSeveritySummary>>,
        ) -> Self {
            self.list_antipattern_severity_summary = input;
            self
        }
        /// Appends an item to `list_application_component_summary`.
        ///
        /// To override the contents of this collection use [`set_list_application_component_summary`](Self::set_list_application_component_summary).
        ///
        /// <p> List of ApplicationComponentSummary. </p>
        pub fn list_application_component_summary(
            mut self,
            input: crate::model::ApplicationComponentSummary,
        ) -> Self {
            let mut v = self.list_application_component_summary.unwrap_or_default();
            v.push(input);
            self.list_application_component_summary = Some(v);
            self
        }
        /// <p> List of ApplicationComponentSummary. </p>
        pub fn set_list_application_component_summary(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ApplicationComponentSummary>>,
        ) -> Self {
            self.list_application_component_summary = input;
            self
        }
        /// Appends an item to `list_server_summary`.
        ///
        /// To override the contents of this collection use [`set_list_server_summary`](Self::set_list_server_summary).
        ///
        /// <p> List of ServerSummary. </p>
        pub fn list_server_summary(mut self, input: crate::model::ServerSummary) -> Self {
            let mut v = self.list_server_summary.unwrap_or_default();
            v.push(input);
            self.list_server_summary = Some(v);
            self
        }
        /// <p> List of ServerSummary. </p>
        pub fn set_list_server_summary(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ServerSummary>>,
        ) -> Self {
            self.list_server_summary = input;
            self
        }
        /// <p> The Amazon S3 object containing the anti-pattern report. </p>
        pub fn antipattern_report_s3_object(mut self, input: crate::model::S3Object) -> Self {
            self.antipattern_report_s3_object = Some(input);
            self
        }
        /// <p> The Amazon S3 object containing the anti-pattern report. </p>
        pub fn set_antipattern_report_s3_object(
            mut self,
            input: std::option::Option<crate::model::S3Object>,
        ) -> Self {
            self.antipattern_report_s3_object = input;
            self
        }
        /// <p> The status of the anti-pattern report. </p>
        pub fn antipattern_report_status(
            mut self,
            input: crate::model::AntipatternReportStatus,
        ) -> Self {
            self.antipattern_report_status = Some(input);
            self
        }
        /// <p> The status of the anti-pattern report. </p>
        pub fn set_antipattern_report_status(
            mut self,
            input: std::option::Option<crate::model::AntipatternReportStatus>,
        ) -> Self {
            self.antipattern_report_status = input;
            self
        }
        /// <p> The status message of the anti-pattern report. </p>
        pub fn antipattern_report_status_message(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.antipattern_report_status_message = Some(input.into());
            self
        }
        /// <p> The status message of the anti-pattern report. </p>
        pub fn set_antipattern_report_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.antipattern_report_status_message = input;
            self
        }
        /// <p> The time the assessment was performed. </p>
        pub fn last_analyzed_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_analyzed_timestamp = Some(input);
            self
        }
        /// <p> The time the assessment was performed. </p>
        pub fn set_last_analyzed_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_analyzed_timestamp = input;
            self
        }
        /// Appends an item to `list_application_component_status_summary`.
        ///
        /// To override the contents of this collection use [`set_list_application_component_status_summary`](Self::set_list_application_component_status_summary).
        ///
        /// <p>List of status summaries of the analyzed application components.</p>
        pub fn list_application_component_status_summary(
            mut self,
            input: crate::model::ApplicationComponentStatusSummary,
        ) -> Self {
            let mut v = self
                .list_application_component_status_summary
                .unwrap_or_default();
            v.push(input);
            self.list_application_component_status_summary = Some(v);
            self
        }
        /// <p>List of status summaries of the analyzed application components.</p>
        pub fn set_list_application_component_status_summary(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ApplicationComponentStatusSummary>,
            >,
        ) -> Self {
            self.list_application_component_status_summary = input;
            self
        }
        /// Appends an item to `list_server_status_summary`.
        ///
        /// To override the contents of this collection use [`set_list_server_status_summary`](Self::set_list_server_status_summary).
        ///
        /// <p>List of status summaries of the analyzed servers.</p>
        pub fn list_server_status_summary(
            mut self,
            input: crate::model::ServerStatusSummary,
        ) -> Self {
            let mut v = self.list_server_status_summary.unwrap_or_default();
            v.push(input);
            self.list_server_status_summary = Some(v);
            self
        }
        /// <p>List of status summaries of the analyzed servers.</p>
        pub fn set_list_server_status_summary(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ServerStatusSummary>>,
        ) -> Self {
            self.list_server_status_summary = input;
            self
        }
        /// Consumes the builder and constructs a [`AssessmentSummary`](crate::model::AssessmentSummary).
        pub fn build(self) -> crate::model::AssessmentSummary {
            crate::model::AssessmentSummary {
                list_server_strategy_summary: self.list_server_strategy_summary,
                list_application_component_strategy_summary: self
                    .list_application_component_strategy_summary,
                list_antipattern_severity_summary: self.list_antipattern_severity_summary,
                list_application_component_summary: self.list_application_component_summary,
                list_server_summary: self.list_server_summary,
                antipattern_report_s3_object: self.antipattern_report_s3_object,
                antipattern_report_status: self.antipattern_report_status,
                antipattern_report_status_message: self.antipattern_report_status_message,
                last_analyzed_timestamp: self.last_analyzed_timestamp,
                list_application_component_status_summary: self
                    .list_application_component_status_summary,
                list_server_status_summary: self.list_server_status_summary,
            }
        }
    }
}
impl AssessmentSummary {
    /// Creates a new builder-style object to manufacture [`AssessmentSummary`](crate::model::AssessmentSummary).
    pub fn builder() -> crate::model::assessment_summary::Builder {
        crate::model::assessment_summary::Builder::default()
    }
}

/// <p>The status summary of the server analysis.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServerStatusSummary {
    /// <p>The status of the run time.</p>
    #[doc(hidden)]
    pub run_time_assessment_status: std::option::Option<crate::model::RunTimeAssessmentStatus>,
    /// <p>The number of servers successfully analyzed, partially successful or failed analysis.</p>
    #[doc(hidden)]
    pub count: std::option::Option<i32>,
}
impl ServerStatusSummary {
    /// <p>The status of the run time.</p>
    pub fn run_time_assessment_status(
        &self,
    ) -> std::option::Option<&crate::model::RunTimeAssessmentStatus> {
        self.run_time_assessment_status.as_ref()
    }
    /// <p>The number of servers successfully analyzed, partially successful or failed analysis.</p>
    pub fn count(&self) -> std::option::Option<i32> {
        self.count
    }
}
/// See [`ServerStatusSummary`](crate::model::ServerStatusSummary).
pub mod server_status_summary {

    /// A builder for [`ServerStatusSummary`](crate::model::ServerStatusSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) run_time_assessment_status:
            std::option::Option<crate::model::RunTimeAssessmentStatus>,
        pub(crate) count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The status of the run time.</p>
        pub fn run_time_assessment_status(
            mut self,
            input: crate::model::RunTimeAssessmentStatus,
        ) -> Self {
            self.run_time_assessment_status = Some(input);
            self
        }
        /// <p>The status of the run time.</p>
        pub fn set_run_time_assessment_status(
            mut self,
            input: std::option::Option<crate::model::RunTimeAssessmentStatus>,
        ) -> Self {
            self.run_time_assessment_status = input;
            self
        }
        /// <p>The number of servers successfully analyzed, partially successful or failed analysis.</p>
        pub fn count(mut self, input: i32) -> Self {
            self.count = Some(input);
            self
        }
        /// <p>The number of servers successfully analyzed, partially successful or failed analysis.</p>
        pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
            self.count = input;
            self
        }
        /// Consumes the builder and constructs a [`ServerStatusSummary`](crate::model::ServerStatusSummary).
        pub fn build(self) -> crate::model::ServerStatusSummary {
            crate::model::ServerStatusSummary {
                run_time_assessment_status: self.run_time_assessment_status,
                count: self.count,
            }
        }
    }
}
impl ServerStatusSummary {
    /// Creates a new builder-style object to manufacture [`ServerStatusSummary`](crate::model::ServerStatusSummary).
    pub fn builder() -> crate::model::server_status_summary::Builder {
        crate::model::server_status_summary::Builder::default()
    }
}

/// <p>Summary of the analysis status of the application component.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ApplicationComponentStatusSummary {
    /// <p>The status of database analysis.</p>
    #[doc(hidden)]
    pub src_code_or_db_analysis_status:
        std::option::Option<crate::model::SrcCodeOrDbAnalysisStatus>,
    /// <p>The number of application components successfully analyzed, partially successful or failed analysis.</p>
    #[doc(hidden)]
    pub count: std::option::Option<i32>,
}
impl ApplicationComponentStatusSummary {
    /// <p>The status of database analysis.</p>
    pub fn src_code_or_db_analysis_status(
        &self,
    ) -> std::option::Option<&crate::model::SrcCodeOrDbAnalysisStatus> {
        self.src_code_or_db_analysis_status.as_ref()
    }
    /// <p>The number of application components successfully analyzed, partially successful or failed analysis.</p>
    pub fn count(&self) -> std::option::Option<i32> {
        self.count
    }
}
/// See [`ApplicationComponentStatusSummary`](crate::model::ApplicationComponentStatusSummary).
pub mod application_component_status_summary {

    /// A builder for [`ApplicationComponentStatusSummary`](crate::model::ApplicationComponentStatusSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) src_code_or_db_analysis_status:
            std::option::Option<crate::model::SrcCodeOrDbAnalysisStatus>,
        pub(crate) count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The status of database analysis.</p>
        pub fn src_code_or_db_analysis_status(
            mut self,
            input: crate::model::SrcCodeOrDbAnalysisStatus,
        ) -> Self {
            self.src_code_or_db_analysis_status = Some(input);
            self
        }
        /// <p>The status of database analysis.</p>
        pub fn set_src_code_or_db_analysis_status(
            mut self,
            input: std::option::Option<crate::model::SrcCodeOrDbAnalysisStatus>,
        ) -> Self {
            self.src_code_or_db_analysis_status = input;
            self
        }
        /// <p>The number of application components successfully analyzed, partially successful or failed analysis.</p>
        pub fn count(mut self, input: i32) -> Self {
            self.count = Some(input);
            self
        }
        /// <p>The number of application components successfully analyzed, partially successful or failed analysis.</p>
        pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
            self.count = input;
            self
        }
        /// Consumes the builder and constructs a [`ApplicationComponentStatusSummary`](crate::model::ApplicationComponentStatusSummary).
        pub fn build(self) -> crate::model::ApplicationComponentStatusSummary {
            crate::model::ApplicationComponentStatusSummary {
                src_code_or_db_analysis_status: self.src_code_or_db_analysis_status,
                count: self.count,
            }
        }
    }
}
impl ApplicationComponentStatusSummary {
    /// Creates a new builder-style object to manufacture [`ApplicationComponentStatusSummary`](crate::model::ApplicationComponentStatusSummary).
    pub fn builder() -> crate::model::application_component_status_summary::Builder {
        crate::model::application_component_status_summary::Builder::default()
    }
}

/// <p> Object containing details about the servers imported by Application Discovery Service </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServerSummary {
    /// <p> Type of operating system for the servers. </p>
    #[doc(hidden)]
    pub server_os_type: std::option::Option<crate::model::ServerOsType>,
    /// <p> Number of servers. </p>
    #[doc(hidden)]
    pub count: std::option::Option<i32>,
}
impl ServerSummary {
    /// <p> Type of operating system for the servers. </p>
    pub fn server_os_type(&self) -> std::option::Option<&crate::model::ServerOsType> {
        self.server_os_type.as_ref()
    }
    /// <p> Number of servers. </p>
    pub fn count(&self) -> std::option::Option<i32> {
        self.count
    }
}
/// See [`ServerSummary`](crate::model::ServerSummary).
pub mod server_summary {

    /// A builder for [`ServerSummary`](crate::model::ServerSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) server_os_type: std::option::Option<crate::model::ServerOsType>,
        pub(crate) count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> Type of operating system for the servers. </p>
        pub fn server_os_type(mut self, input: crate::model::ServerOsType) -> Self {
            self.server_os_type = Some(input);
            self
        }
        /// <p> Type of operating system for the servers. </p>
        pub fn set_server_os_type(
            mut self,
            input: std::option::Option<crate::model::ServerOsType>,
        ) -> Self {
            self.server_os_type = input;
            self
        }
        /// <p> Number of servers. </p>
        pub fn count(mut self, input: i32) -> Self {
            self.count = Some(input);
            self
        }
        /// <p> Number of servers. </p>
        pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
            self.count = input;
            self
        }
        /// Consumes the builder and constructs a [`ServerSummary`](crate::model::ServerSummary).
        pub fn build(self) -> crate::model::ServerSummary {
            crate::model::ServerSummary {
                server_os_type: self.server_os_type,
                count: self.count,
            }
        }
    }
}
impl ServerSummary {
    /// Creates a new builder-style object to manufacture [`ServerSummary`](crate::model::ServerSummary).
    pub fn builder() -> crate::model::server_summary::Builder {
        crate::model::server_summary::Builder::default()
    }
}

/// When writing a match expression against `ServerOsType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let serverostype = unimplemented!();
/// match serverostype {
///     ServerOsType::AmazonLinux => { /* ... */ },
///     ServerOsType::EndOfSupportWindowsServer => { /* ... */ },
///     ServerOsType::Other => { /* ... */ },
///     ServerOsType::Redhat => { /* ... */ },
///     ServerOsType::WindowsServer => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `serverostype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ServerOsType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ServerOsType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ServerOsType::NewFeature` is defined.
/// Specifically, when `serverostype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ServerOsType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ServerOsType {
    #[allow(missing_docs)] // documentation missing in model
    AmazonLinux,
    #[allow(missing_docs)] // documentation missing in model
    EndOfSupportWindowsServer,
    #[allow(missing_docs)] // documentation missing in model
    Other,
    #[allow(missing_docs)] // documentation missing in model
    Redhat,
    #[allow(missing_docs)] // documentation missing in model
    WindowsServer,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ServerOsType {
    fn from(s: &str) -> Self {
        match s {
            "AmazonLinux" => ServerOsType::AmazonLinux,
            "EndOfSupportWindowsServer" => ServerOsType::EndOfSupportWindowsServer,
            "Other" => ServerOsType::Other,
            "Redhat" => ServerOsType::Redhat,
            "WindowsServer" => ServerOsType::WindowsServer,
            other => ServerOsType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ServerOsType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ServerOsType::from(s))
    }
}
impl ServerOsType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ServerOsType::AmazonLinux => "AmazonLinux",
            ServerOsType::EndOfSupportWindowsServer => "EndOfSupportWindowsServer",
            ServerOsType::Other => "Other",
            ServerOsType::Redhat => "Redhat",
            ServerOsType::WindowsServer => "WindowsServer",
            ServerOsType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AmazonLinux",
            "EndOfSupportWindowsServer",
            "Other",
            "Redhat",
            "WindowsServer",
        ]
    }
}
impl AsRef<str> for ServerOsType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> Contains the summary of application components. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ApplicationComponentSummary {
    /// <p> Contains the name of application types. </p>
    #[doc(hidden)]
    pub app_type: std::option::Option<crate::model::AppType>,
    /// <p> Contains the count of application type. </p>
    #[doc(hidden)]
    pub count: std::option::Option<i32>,
}
impl ApplicationComponentSummary {
    /// <p> Contains the name of application types. </p>
    pub fn app_type(&self) -> std::option::Option<&crate::model::AppType> {
        self.app_type.as_ref()
    }
    /// <p> Contains the count of application type. </p>
    pub fn count(&self) -> std::option::Option<i32> {
        self.count
    }
}
/// See [`ApplicationComponentSummary`](crate::model::ApplicationComponentSummary).
pub mod application_component_summary {

    /// A builder for [`ApplicationComponentSummary`](crate::model::ApplicationComponentSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_type: std::option::Option<crate::model::AppType>,
        pub(crate) count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> Contains the name of application types. </p>
        pub fn app_type(mut self, input: crate::model::AppType) -> Self {
            self.app_type = Some(input);
            self
        }
        /// <p> Contains the name of application types. </p>
        pub fn set_app_type(mut self, input: std::option::Option<crate::model::AppType>) -> Self {
            self.app_type = input;
            self
        }
        /// <p> Contains the count of application type. </p>
        pub fn count(mut self, input: i32) -> Self {
            self.count = Some(input);
            self
        }
        /// <p> Contains the count of application type. </p>
        pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
            self.count = input;
            self
        }
        /// Consumes the builder and constructs a [`ApplicationComponentSummary`](crate::model::ApplicationComponentSummary).
        pub fn build(self) -> crate::model::ApplicationComponentSummary {
            crate::model::ApplicationComponentSummary {
                app_type: self.app_type,
                count: self.count,
            }
        }
    }
}
impl ApplicationComponentSummary {
    /// Creates a new builder-style object to manufacture [`ApplicationComponentSummary`](crate::model::ApplicationComponentSummary).
    pub fn builder() -> crate::model::application_component_summary::Builder {
        crate::model::application_component_summary::Builder::default()
    }
}

/// <p> Detailed information about an assessment. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataCollectionDetails {
    /// <p> The status of the assessment. </p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::AssessmentStatus>,
    /// <p> The total number of servers in the assessment. </p>
    #[doc(hidden)]
    pub servers: std::option::Option<i32>,
    /// <p> The number of failed servers in the assessment. </p>
    #[doc(hidden)]
    pub failed: std::option::Option<i32>,
    /// <p> The number of successful servers in the assessment. </p>
    #[doc(hidden)]
    pub success: std::option::Option<i32>,
    /// <p> The number of servers with the assessment status <code>IN_PROGESS</code>. </p>
    #[doc(hidden)]
    pub in_progress: std::option::Option<i32>,
    /// <p> The start time of assessment. </p>
    #[doc(hidden)]
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p> The time the assessment completes. </p>
    #[doc(hidden)]
    pub completion_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The status message of the assessment.</p>
    #[doc(hidden)]
    pub status_message: std::option::Option<std::string::String>,
}
impl DataCollectionDetails {
    /// <p> The status of the assessment. </p>
    pub fn status(&self) -> std::option::Option<&crate::model::AssessmentStatus> {
        self.status.as_ref()
    }
    /// <p> The total number of servers in the assessment. </p>
    pub fn servers(&self) -> std::option::Option<i32> {
        self.servers
    }
    /// <p> The number of failed servers in the assessment. </p>
    pub fn failed(&self) -> std::option::Option<i32> {
        self.failed
    }
    /// <p> The number of successful servers in the assessment. </p>
    pub fn success(&self) -> std::option::Option<i32> {
        self.success
    }
    /// <p> The number of servers with the assessment status <code>IN_PROGESS</code>. </p>
    pub fn in_progress(&self) -> std::option::Option<i32> {
        self.in_progress
    }
    /// <p> The start time of assessment. </p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p> The time the assessment completes. </p>
    pub fn completion_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.completion_time.as_ref()
    }
    /// <p>The status message of the assessment.</p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
}
/// See [`DataCollectionDetails`](crate::model::DataCollectionDetails).
pub mod data_collection_details {

    /// A builder for [`DataCollectionDetails`](crate::model::DataCollectionDetails).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::AssessmentStatus>,
        pub(crate) servers: std::option::Option<i32>,
        pub(crate) failed: std::option::Option<i32>,
        pub(crate) success: std::option::Option<i32>,
        pub(crate) in_progress: std::option::Option<i32>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) completion_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) status_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The status of the assessment. </p>
        pub fn status(mut self, input: crate::model::AssessmentStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p> The status of the assessment. </p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::AssessmentStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p> The total number of servers in the assessment. </p>
        pub fn servers(mut self, input: i32) -> Self {
            self.servers = Some(input);
            self
        }
        /// <p> The total number of servers in the assessment. </p>
        pub fn set_servers(mut self, input: std::option::Option<i32>) -> Self {
            self.servers = input;
            self
        }
        /// <p> The number of failed servers in the assessment. </p>
        pub fn failed(mut self, input: i32) -> Self {
            self.failed = Some(input);
            self
        }
        /// <p> The number of failed servers in the assessment. </p>
        pub fn set_failed(mut self, input: std::option::Option<i32>) -> Self {
            self.failed = input;
            self
        }
        /// <p> The number of successful servers in the assessment. </p>
        pub fn success(mut self, input: i32) -> Self {
            self.success = Some(input);
            self
        }
        /// <p> The number of successful servers in the assessment. </p>
        pub fn set_success(mut self, input: std::option::Option<i32>) -> Self {
            self.success = input;
            self
        }
        /// <p> The number of servers with the assessment status <code>IN_PROGESS</code>. </p>
        pub fn in_progress(mut self, input: i32) -> Self {
            self.in_progress = Some(input);
            self
        }
        /// <p> The number of servers with the assessment status <code>IN_PROGESS</code>. </p>
        pub fn set_in_progress(mut self, input: std::option::Option<i32>) -> Self {
            self.in_progress = input;
            self
        }
        /// <p> The start time of assessment. </p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p> The start time of assessment. </p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p> The time the assessment completes. </p>
        pub fn completion_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.completion_time = Some(input);
            self
        }
        /// <p> The time the assessment completes. </p>
        pub fn set_completion_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.completion_time = input;
            self
        }
        /// <p>The status message of the assessment.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>The status message of the assessment.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// Consumes the builder and constructs a [`DataCollectionDetails`](crate::model::DataCollectionDetails).
        pub fn build(self) -> crate::model::DataCollectionDetails {
            crate::model::DataCollectionDetails {
                status: self.status,
                servers: self.servers,
                failed: self.failed,
                success: self.success,
                in_progress: self.in_progress,
                start_time: self.start_time,
                completion_time: self.completion_time,
                status_message: self.status_message,
            }
        }
    }
}
impl DataCollectionDetails {
    /// Creates a new builder-style object to manufacture [`DataCollectionDetails`](crate::model::DataCollectionDetails).
    pub fn builder() -> crate::model::data_collection_details::Builder {
        crate::model::data_collection_details::Builder::default()
    }
}

/// When writing a match expression against `AssessmentStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let assessmentstatus = unimplemented!();
/// match assessmentstatus {
///     AssessmentStatus::Complete => { /* ... */ },
///     AssessmentStatus::Failed => { /* ... */ },
///     AssessmentStatus::InProgress => { /* ... */ },
///     AssessmentStatus::Stopped => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `assessmentstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AssessmentStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AssessmentStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AssessmentStatus::NewFeature` is defined.
/// Specifically, when `assessmentstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AssessmentStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AssessmentStatus {
    #[allow(missing_docs)] // documentation missing in model
    Complete,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AssessmentStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETE" => AssessmentStatus::Complete,
            "FAILED" => AssessmentStatus::Failed,
            "IN_PROGRESS" => AssessmentStatus::InProgress,
            "STOPPED" => AssessmentStatus::Stopped,
            other => AssessmentStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AssessmentStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AssessmentStatus::from(s))
    }
}
impl AssessmentStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AssessmentStatus::Complete => "COMPLETE",
            AssessmentStatus::Failed => "FAILED",
            AssessmentStatus::InProgress => "IN_PROGRESS",
            AssessmentStatus::Stopped => "STOPPED",
            AssessmentStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["COMPLETE", "FAILED", "IN_PROGRESS", "STOPPED"]
    }
}
impl AsRef<str> for AssessmentStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> Contains information about a strategy recommendation for an application component. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ApplicationComponentStrategy {
    /// <p> Strategy recommendation for the application component. </p>
    #[doc(hidden)]
    pub recommendation: std::option::Option<crate::model::RecommendationSet>,
    /// <p> The recommendation status of a strategy for an application component. </p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::StrategyRecommendation>,
    /// <p> Set to true if the recommendation is set as preferred. </p>
    #[doc(hidden)]
    pub is_preferred: std::option::Option<bool>,
}
impl ApplicationComponentStrategy {
    /// <p> Strategy recommendation for the application component. </p>
    pub fn recommendation(&self) -> std::option::Option<&crate::model::RecommendationSet> {
        self.recommendation.as_ref()
    }
    /// <p> The recommendation status of a strategy for an application component. </p>
    pub fn status(&self) -> std::option::Option<&crate::model::StrategyRecommendation> {
        self.status.as_ref()
    }
    /// <p> Set to true if the recommendation is set as preferred. </p>
    pub fn is_preferred(&self) -> std::option::Option<bool> {
        self.is_preferred
    }
}
/// See [`ApplicationComponentStrategy`](crate::model::ApplicationComponentStrategy).
pub mod application_component_strategy {

    /// A builder for [`ApplicationComponentStrategy`](crate::model::ApplicationComponentStrategy).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) recommendation: std::option::Option<crate::model::RecommendationSet>,
        pub(crate) status: std::option::Option<crate::model::StrategyRecommendation>,
        pub(crate) is_preferred: std::option::Option<bool>,
    }
    impl Builder {
        /// <p> Strategy recommendation for the application component. </p>
        pub fn recommendation(mut self, input: crate::model::RecommendationSet) -> Self {
            self.recommendation = Some(input);
            self
        }
        /// <p> Strategy recommendation for the application component. </p>
        pub fn set_recommendation(
            mut self,
            input: std::option::Option<crate::model::RecommendationSet>,
        ) -> Self {
            self.recommendation = input;
            self
        }
        /// <p> The recommendation status of a strategy for an application component. </p>
        pub fn status(mut self, input: crate::model::StrategyRecommendation) -> Self {
            self.status = Some(input);
            self
        }
        /// <p> The recommendation status of a strategy for an application component. </p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::StrategyRecommendation>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p> Set to true if the recommendation is set as preferred. </p>
        pub fn is_preferred(mut self, input: bool) -> Self {
            self.is_preferred = Some(input);
            self
        }
        /// <p> Set to true if the recommendation is set as preferred. </p>
        pub fn set_is_preferred(mut self, input: std::option::Option<bool>) -> Self {
            self.is_preferred = input;
            self
        }
        /// Consumes the builder and constructs a [`ApplicationComponentStrategy`](crate::model::ApplicationComponentStrategy).
        pub fn build(self) -> crate::model::ApplicationComponentStrategy {
            crate::model::ApplicationComponentStrategy {
                recommendation: self.recommendation,
                status: self.status,
                is_preferred: self.is_preferred,
            }
        }
    }
}
impl ApplicationComponentStrategy {
    /// Creates a new builder-style object to manufacture [`ApplicationComponentStrategy`](crate::model::ApplicationComponentStrategy).
    pub fn builder() -> crate::model::application_component_strategy::Builder {
        crate::model::application_component_strategy::Builder::default()
    }
}
