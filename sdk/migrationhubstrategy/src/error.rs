// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Error type for the `UpdateServerConfig` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateServerConfigError {
    /// Kind of error that occurred.
                    pub kind: UpdateServerConfigErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateServerConfigError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: UpdateServerConfigErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `UpdateServerConfig` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateServerConfigErrorKind {
    /// <p> The server experienced an internal error. Try again. </p>
    InternalServerException(crate::error::InternalServerException),
    /// <p> The specified ID in the request is not found. </p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p> The request was denied due to request throttling. </p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p> The request body isn't valid. </p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for UpdateServerConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateServerConfigErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateServerConfigErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateServerConfigErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateServerConfigErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateServerConfigErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateServerConfigError {
    fn code(&self) -> Option<&str> {
        UpdateServerConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateServerConfigError {
    /// Creates a new `UpdateServerConfigError`.
                    pub fn new(kind: UpdateServerConfigErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `UpdateServerConfigError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: UpdateServerConfigErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `UpdateServerConfigError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: UpdateServerConfigErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `UpdateServerConfigErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, UpdateServerConfigErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `UpdateServerConfigErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateServerConfigErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `UpdateServerConfigErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateServerConfigErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `UpdateServerConfigErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UpdateServerConfigErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UpdateServerConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateServerConfigErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            UpdateServerConfigErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            UpdateServerConfigErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            UpdateServerConfigErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            UpdateServerConfigErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// <p> The request body isn't valid. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ValidationException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ValidationException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ValidationException")?;
        if let Some(inner_1) = &self.message {
             {
                write!(f, ": {}", inner_1)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ValidationException {}
/// See [`ValidationException`](crate::error::ValidationException).
pub mod validation_exception {
    
    /// A builder for [`ValidationException`](crate::error::ValidationException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`ValidationException`](crate::error::ValidationException).
        pub fn build(self) -> crate::error::ValidationException {
            crate::error::ValidationException {
                message: self.message
                ,
            }
        }
    }
    
    
}
impl ValidationException {
    /// Creates a new builder-style object to manufacture [`ValidationException`](crate::error::ValidationException).
    pub fn builder() -> crate::error::validation_exception::Builder {
        crate::error::validation_exception::Builder::default()
    }
}

/// <p> The request was denied due to request throttling. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ThrottlingException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ThrottlingException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ThrottlingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ThrottlingException")?;
        if let Some(inner_2) = &self.message {
             {
                write!(f, ": {}", inner_2)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ThrottlingException {}
/// See [`ThrottlingException`](crate::error::ThrottlingException).
pub mod throttling_exception {
    
    /// A builder for [`ThrottlingException`](crate::error::ThrottlingException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`ThrottlingException`](crate::error::ThrottlingException).
        pub fn build(self) -> crate::error::ThrottlingException {
            crate::error::ThrottlingException {
                message: self.message
                ,
            }
        }
    }
    
    
}
impl ThrottlingException {
    /// Creates a new builder-style object to manufacture [`ThrottlingException`](crate::error::ThrottlingException).
    pub fn builder() -> crate::error::throttling_exception::Builder {
        crate::error::throttling_exception::Builder::default()
    }
}

/// <p> The specified ID in the request is not found. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceNotFoundException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ResourceNotFoundException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundException")?;
        if let Some(inner_3) = &self.message {
             {
                write!(f, ": {}", inner_3)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundException {}
/// See [`ResourceNotFoundException`](crate::error::ResourceNotFoundException).
pub mod resource_not_found_exception {
    
    /// A builder for [`ResourceNotFoundException`](crate::error::ResourceNotFoundException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException).
        pub fn build(self) -> crate::error::ResourceNotFoundException {
            crate::error::ResourceNotFoundException {
                message: self.message
                ,
            }
        }
    }
    
    
}
impl ResourceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundException`](crate::error::ResourceNotFoundException).
    pub fn builder() -> crate::error::resource_not_found_exception::Builder {
        crate::error::resource_not_found_exception::Builder::default()
    }
}

/// <p> The server experienced an internal error. Try again. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InternalServerException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl InternalServerException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for InternalServerException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServerException")?;
        if let Some(inner_4) = &self.message {
             {
                write!(f, ": {}", inner_4)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InternalServerException {}
/// See [`InternalServerException`](crate::error::InternalServerException).
pub mod internal_server_exception {
    
    /// A builder for [`InternalServerException`](crate::error::InternalServerException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`InternalServerException`](crate::error::InternalServerException).
        pub fn build(self) -> crate::error::InternalServerException {
            crate::error::InternalServerException {
                message: self.message
                ,
            }
        }
    }
    
    
}
impl InternalServerException {
    /// Creates a new builder-style object to manufacture [`InternalServerException`](crate::error::InternalServerException).
    pub fn builder() -> crate::error::internal_server_exception::Builder {
        crate::error::internal_server_exception::Builder::default()
    }
}

/// Error type for the `UpdateApplicationComponentConfig` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateApplicationComponentConfigError {
    /// Kind of error that occurred.
                    pub kind: UpdateApplicationComponentConfigErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateApplicationComponentConfigError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: UpdateApplicationComponentConfigErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `UpdateApplicationComponentConfig` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateApplicationComponentConfigErrorKind {
    /// <p> The server experienced an internal error. Try again. </p>
    InternalServerException(crate::error::InternalServerException),
    /// <p> The specified ID in the request is not found. </p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p> The request was denied due to request throttling. </p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p> The request body isn't valid. </p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for UpdateApplicationComponentConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateApplicationComponentConfigErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateApplicationComponentConfigErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateApplicationComponentConfigErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateApplicationComponentConfigErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateApplicationComponentConfigErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateApplicationComponentConfigError {
    fn code(&self) -> Option<&str> {
        UpdateApplicationComponentConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateApplicationComponentConfigError {
    /// Creates a new `UpdateApplicationComponentConfigError`.
                    pub fn new(kind: UpdateApplicationComponentConfigErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `UpdateApplicationComponentConfigError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: UpdateApplicationComponentConfigErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `UpdateApplicationComponentConfigError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: UpdateApplicationComponentConfigErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `UpdateApplicationComponentConfigErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, UpdateApplicationComponentConfigErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `UpdateApplicationComponentConfigErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateApplicationComponentConfigErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `UpdateApplicationComponentConfigErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateApplicationComponentConfigErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `UpdateApplicationComponentConfigErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UpdateApplicationComponentConfigErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UpdateApplicationComponentConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateApplicationComponentConfigErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            UpdateApplicationComponentConfigErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            UpdateApplicationComponentConfigErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            UpdateApplicationComponentConfigErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            UpdateApplicationComponentConfigErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `StopAssessment` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopAssessmentError {
    /// Kind of error that occurred.
                    pub kind: StopAssessmentErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for StopAssessmentError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: StopAssessmentErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `StopAssessment` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopAssessmentErrorKind {
    /// <p> The AWS user account does not have permission to perform the action. Check the AWS Identity and Access Management (IAM) policy associated with this account.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p> The server experienced an internal error. Try again. </p>
    InternalServerException(crate::error::InternalServerException),
    /// <p> The request was denied due to request throttling. </p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p> The request body isn't valid. </p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for StopAssessmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopAssessmentErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            StopAssessmentErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            StopAssessmentErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            StopAssessmentErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            StopAssessmentErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for StopAssessmentError {
    fn code(&self) -> Option<&str> {
        StopAssessmentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopAssessmentError {
    /// Creates a new `StopAssessmentError`.
                    pub fn new(kind: StopAssessmentErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `StopAssessmentError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: StopAssessmentErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `StopAssessmentError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: StopAssessmentErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `StopAssessmentErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, StopAssessmentErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `StopAssessmentErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, StopAssessmentErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `StopAssessmentErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, StopAssessmentErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `StopAssessmentErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, StopAssessmentErrorKind::ValidationException(_))
    }
}
impl std::error::Error for StopAssessmentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopAssessmentErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            StopAssessmentErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            StopAssessmentErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            StopAssessmentErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            StopAssessmentErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// <p> The AWS user account does not have permission to perform the action. Check the AWS Identity and Access Management (IAM) policy associated with this account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AccessDeniedException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl AccessDeniedException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccessDeniedException")?;
        if let Some(inner_5) = &self.message {
             {
                write!(f, ": {}", inner_5)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for AccessDeniedException {}
/// See [`AccessDeniedException`](crate::error::AccessDeniedException).
pub mod access_denied_exception {
    
    /// A builder for [`AccessDeniedException`](crate::error::AccessDeniedException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`AccessDeniedException`](crate::error::AccessDeniedException).
        pub fn build(self) -> crate::error::AccessDeniedException {
            crate::error::AccessDeniedException {
                message: self.message
                ,
            }
        }
    }
    
    
}
impl AccessDeniedException {
    /// Creates a new builder-style object to manufacture [`AccessDeniedException`](crate::error::AccessDeniedException).
    pub fn builder() -> crate::error::access_denied_exception::Builder {
        crate::error::access_denied_exception::Builder::default()
    }
}

/// Error type for the `StartRecommendationReportGeneration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartRecommendationReportGenerationError {
    /// Kind of error that occurred.
                    pub kind: StartRecommendationReportGenerationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for StartRecommendationReportGenerationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: StartRecommendationReportGenerationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `StartRecommendationReportGeneration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartRecommendationReportGenerationErrorKind {
    /// <p> The AWS user account does not have permission to perform the action. Check the AWS Identity and Access Management (IAM) policy associated with this account.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p> Exception to indicate that there is an ongoing task when a new task is created. Return when once the existing tasks are complete. </p>
    ConflictException(crate::error::ConflictException),
    /// <p> The server experienced an internal error. Try again. </p>
    InternalServerException(crate::error::InternalServerException),
    /// <p> The request was denied due to request throttling. </p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p> The request body isn't valid. </p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for StartRecommendationReportGenerationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartRecommendationReportGenerationErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            StartRecommendationReportGenerationErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            StartRecommendationReportGenerationErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            StartRecommendationReportGenerationErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            StartRecommendationReportGenerationErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            StartRecommendationReportGenerationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for StartRecommendationReportGenerationError {
    fn code(&self) -> Option<&str> {
        StartRecommendationReportGenerationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartRecommendationReportGenerationError {
    /// Creates a new `StartRecommendationReportGenerationError`.
                    pub fn new(kind: StartRecommendationReportGenerationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `StartRecommendationReportGenerationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: StartRecommendationReportGenerationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `StartRecommendationReportGenerationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: StartRecommendationReportGenerationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `StartRecommendationReportGenerationErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, StartRecommendationReportGenerationErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `StartRecommendationReportGenerationErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, StartRecommendationReportGenerationErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `StartRecommendationReportGenerationErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, StartRecommendationReportGenerationErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `StartRecommendationReportGenerationErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, StartRecommendationReportGenerationErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `StartRecommendationReportGenerationErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, StartRecommendationReportGenerationErrorKind::ValidationException(_))
    }
}
impl std::error::Error for StartRecommendationReportGenerationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartRecommendationReportGenerationErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            StartRecommendationReportGenerationErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            StartRecommendationReportGenerationErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            StartRecommendationReportGenerationErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            StartRecommendationReportGenerationErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            StartRecommendationReportGenerationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// <p> Exception to indicate that there is an ongoing task when a new task is created. Return when once the existing tasks are complete. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConflictException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ConflictException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_6) = &self.message {
             {
                write!(f, ": {}", inner_6)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
/// See [`ConflictException`](crate::error::ConflictException).
pub mod conflict_exception {
    
    /// A builder for [`ConflictException`](crate::error::ConflictException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException).
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                message: self.message
                ,
            }
        }
    }
    
    
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException).
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}

/// Error type for the `StartImportFileTask` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartImportFileTaskError {
    /// Kind of error that occurred.
                    pub kind: StartImportFileTaskErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for StartImportFileTaskError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: StartImportFileTaskErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `StartImportFileTask` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartImportFileTaskErrorKind {
    /// <p> The AWS user account does not have permission to perform the action. Check the AWS Identity and Access Management (IAM) policy associated with this account.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p> The server experienced an internal error. Try again. </p>
    InternalServerException(crate::error::InternalServerException),
    /// <p> The AWS account has reached its quota of imports. Contact AWS Support to increase the quota for this account. </p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p> The request was denied due to request throttling. </p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p> The request body isn't valid. </p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for StartImportFileTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartImportFileTaskErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            StartImportFileTaskErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            StartImportFileTaskErrorKind::ServiceQuotaExceededException(_inner) =>
            _inner.fmt(f)
            ,
            StartImportFileTaskErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            StartImportFileTaskErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            StartImportFileTaskErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for StartImportFileTaskError {
    fn code(&self) -> Option<&str> {
        StartImportFileTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartImportFileTaskError {
    /// Creates a new `StartImportFileTaskError`.
                    pub fn new(kind: StartImportFileTaskErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `StartImportFileTaskError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: StartImportFileTaskErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `StartImportFileTaskError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: StartImportFileTaskErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `StartImportFileTaskErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, StartImportFileTaskErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `StartImportFileTaskErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, StartImportFileTaskErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `StartImportFileTaskErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(&self.kind, StartImportFileTaskErrorKind::ServiceQuotaExceededException(_))
    }
    /// Returns `true` if the error kind is `StartImportFileTaskErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, StartImportFileTaskErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `StartImportFileTaskErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, StartImportFileTaskErrorKind::ValidationException(_))
    }
}
impl std::error::Error for StartImportFileTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartImportFileTaskErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            StartImportFileTaskErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            StartImportFileTaskErrorKind::ServiceQuotaExceededException(_inner) =>
            Some(_inner)
            ,
            StartImportFileTaskErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            StartImportFileTaskErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            StartImportFileTaskErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// <p> The AWS account has reached its quota of imports. Contact AWS Support to increase the quota for this account. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServiceQuotaExceededException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ServiceQuotaExceededException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ServiceQuotaExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceQuotaExceededException")?;
        if let Some(inner_7) = &self.message {
             {
                write!(f, ": {}", inner_7)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ServiceQuotaExceededException {}
/// See [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException).
pub mod service_quota_exceeded_exception {
    
    /// A builder for [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException).
        pub fn build(self) -> crate::error::ServiceQuotaExceededException {
            crate::error::ServiceQuotaExceededException {
                message: self.message
                ,
            }
        }
    }
    
    
}
impl ServiceQuotaExceededException {
    /// Creates a new builder-style object to manufacture [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException).
    pub fn builder() -> crate::error::service_quota_exceeded_exception::Builder {
        crate::error::service_quota_exceeded_exception::Builder::default()
    }
}

/// Error type for the `StartAssessment` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartAssessmentError {
    /// Kind of error that occurred.
                    pub kind: StartAssessmentErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for StartAssessmentError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: StartAssessmentErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `StartAssessment` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartAssessmentErrorKind {
    /// <p> The AWS user account does not have permission to perform the action. Check the AWS Identity and Access Management (IAM) policy associated with this account.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p> The server experienced an internal error. Try again. </p>
    InternalServerException(crate::error::InternalServerException),
    /// <p> The AWS account has reached its quota of imports. Contact AWS Support to increase the quota for this account. </p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p> The request was denied due to request throttling. </p>
    ThrottlingException(crate::error::ThrottlingException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for StartAssessmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartAssessmentErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            StartAssessmentErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            StartAssessmentErrorKind::ServiceQuotaExceededException(_inner) =>
            _inner.fmt(f)
            ,
            StartAssessmentErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            StartAssessmentErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for StartAssessmentError {
    fn code(&self) -> Option<&str> {
        StartAssessmentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartAssessmentError {
    /// Creates a new `StartAssessmentError`.
                    pub fn new(kind: StartAssessmentErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `StartAssessmentError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: StartAssessmentErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `StartAssessmentError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: StartAssessmentErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `StartAssessmentErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, StartAssessmentErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `StartAssessmentErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, StartAssessmentErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `StartAssessmentErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(&self.kind, StartAssessmentErrorKind::ServiceQuotaExceededException(_))
    }
    /// Returns `true` if the error kind is `StartAssessmentErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, StartAssessmentErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for StartAssessmentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartAssessmentErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            StartAssessmentErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            StartAssessmentErrorKind::ServiceQuotaExceededException(_inner) =>
            Some(_inner)
            ,
            StartAssessmentErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            StartAssessmentErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `PutPortfolioPreferences` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutPortfolioPreferencesError {
    /// Kind of error that occurred.
                    pub kind: PutPortfolioPreferencesErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for PutPortfolioPreferencesError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: PutPortfolioPreferencesErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `PutPortfolioPreferences` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutPortfolioPreferencesErrorKind {
    /// <p> The AWS user account does not have permission to perform the action. Check the AWS Identity and Access Management (IAM) policy associated with this account.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p> Exception to indicate that there is an ongoing task when a new task is created. Return when once the existing tasks are complete. </p>
    ConflictException(crate::error::ConflictException),
    /// <p> The server experienced an internal error. Try again. </p>
    InternalServerException(crate::error::InternalServerException),
    /// <p> The request was denied due to request throttling. </p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p> The request body isn't valid. </p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for PutPortfolioPreferencesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutPortfolioPreferencesErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            PutPortfolioPreferencesErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            PutPortfolioPreferencesErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            PutPortfolioPreferencesErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            PutPortfolioPreferencesErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            PutPortfolioPreferencesErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PutPortfolioPreferencesError {
    fn code(&self) -> Option<&str> {
        PutPortfolioPreferencesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutPortfolioPreferencesError {
    /// Creates a new `PutPortfolioPreferencesError`.
                    pub fn new(kind: PutPortfolioPreferencesErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `PutPortfolioPreferencesError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: PutPortfolioPreferencesErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `PutPortfolioPreferencesError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: PutPortfolioPreferencesErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `PutPortfolioPreferencesErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, PutPortfolioPreferencesErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `PutPortfolioPreferencesErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, PutPortfolioPreferencesErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `PutPortfolioPreferencesErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, PutPortfolioPreferencesErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `PutPortfolioPreferencesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, PutPortfolioPreferencesErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `PutPortfolioPreferencesErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, PutPortfolioPreferencesErrorKind::ValidationException(_))
    }
}
impl std::error::Error for PutPortfolioPreferencesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutPortfolioPreferencesErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            PutPortfolioPreferencesErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            PutPortfolioPreferencesErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            PutPortfolioPreferencesErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            PutPortfolioPreferencesErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            PutPortfolioPreferencesErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListServers` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListServersError {
    /// Kind of error that occurred.
                    pub kind: ListServersErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListServersError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListServersErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListServers` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListServersErrorKind {
    /// <p> The AWS user account does not have permission to perform the action. Check the AWS Identity and Access Management (IAM) policy associated with this account.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p> The server experienced an internal error. Try again. </p>
    InternalServerException(crate::error::InternalServerException),
    /// <p> The request was denied due to request throttling. </p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p> The request body isn't valid. </p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListServersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListServersErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListServersErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            ListServersErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            ListServersErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            ListServersErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListServersError {
    fn code(&self) -> Option<&str> {
        ListServersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListServersError {
    /// Creates a new `ListServersError`.
                    pub fn new(kind: ListServersErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListServersError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListServersErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListServersError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListServersErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListServersErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListServersErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListServersErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListServersErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `ListServersErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListServersErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListServersErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListServersErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListServersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListServersErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListServersErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            ListServersErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            ListServersErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            ListServersErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListImportFileTask` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListImportFileTaskError {
    /// Kind of error that occurred.
                    pub kind: ListImportFileTaskErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListImportFileTaskError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListImportFileTaskErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListImportFileTask` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListImportFileTaskErrorKind {
    /// <p> The AWS user account does not have permission to perform the action. Check the AWS Identity and Access Management (IAM) policy associated with this account.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p> The server experienced an internal error. Try again. </p>
    InternalServerException(crate::error::InternalServerException),
    /// <p> The request was denied due to request throttling. </p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p> The request body isn't valid. </p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListImportFileTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListImportFileTaskErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListImportFileTaskErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            ListImportFileTaskErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            ListImportFileTaskErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            ListImportFileTaskErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListImportFileTaskError {
    fn code(&self) -> Option<&str> {
        ListImportFileTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListImportFileTaskError {
    /// Creates a new `ListImportFileTaskError`.
                    pub fn new(kind: ListImportFileTaskErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListImportFileTaskError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListImportFileTaskErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListImportFileTaskError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListImportFileTaskErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListImportFileTaskErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListImportFileTaskErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListImportFileTaskErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListImportFileTaskErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `ListImportFileTaskErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListImportFileTaskErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListImportFileTaskErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListImportFileTaskErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListImportFileTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListImportFileTaskErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListImportFileTaskErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            ListImportFileTaskErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            ListImportFileTaskErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            ListImportFileTaskErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListCollectors` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListCollectorsError {
    /// Kind of error that occurred.
                    pub kind: ListCollectorsErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListCollectorsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListCollectorsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListCollectors` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListCollectorsErrorKind {
    /// <p> The AWS user account does not have permission to perform the action. Check the AWS Identity and Access Management (IAM) policy associated with this account.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p> The server experienced an internal error. Try again. </p>
    InternalServerException(crate::error::InternalServerException),
    /// <p> The request was denied due to request throttling. </p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p> The request body isn't valid. </p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListCollectorsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListCollectorsErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListCollectorsErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            ListCollectorsErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            ListCollectorsErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            ListCollectorsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListCollectorsError {
    fn code(&self) -> Option<&str> {
        ListCollectorsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListCollectorsError {
    /// Creates a new `ListCollectorsError`.
                    pub fn new(kind: ListCollectorsErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListCollectorsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListCollectorsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListCollectorsError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListCollectorsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListCollectorsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListCollectorsErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListCollectorsErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListCollectorsErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `ListCollectorsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListCollectorsErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListCollectorsErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListCollectorsErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListCollectorsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListCollectorsErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListCollectorsErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            ListCollectorsErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            ListCollectorsErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            ListCollectorsErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListApplicationComponents` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListApplicationComponentsError {
    /// Kind of error that occurred.
                    pub kind: ListApplicationComponentsErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListApplicationComponentsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListApplicationComponentsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListApplicationComponents` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListApplicationComponentsErrorKind {
    /// <p> The AWS user account does not have permission to perform the action. Check the AWS Identity and Access Management (IAM) policy associated with this account.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p> The server experienced an internal error. Try again. </p>
    InternalServerException(crate::error::InternalServerException),
    /// <p> Exception to indicate that the service-linked role (SLR) is locked. </p>
    ServiceLinkedRoleLockClientException(crate::error::ServiceLinkedRoleLockClientException),
    /// <p> The request body isn't valid. </p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListApplicationComponentsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListApplicationComponentsErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListApplicationComponentsErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            ListApplicationComponentsErrorKind::ServiceLinkedRoleLockClientException(_inner) =>
            _inner.fmt(f)
            ,
            ListApplicationComponentsErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            ListApplicationComponentsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListApplicationComponentsError {
    fn code(&self) -> Option<&str> {
        ListApplicationComponentsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListApplicationComponentsError {
    /// Creates a new `ListApplicationComponentsError`.
                    pub fn new(kind: ListApplicationComponentsErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListApplicationComponentsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListApplicationComponentsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListApplicationComponentsError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListApplicationComponentsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListApplicationComponentsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListApplicationComponentsErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListApplicationComponentsErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListApplicationComponentsErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `ListApplicationComponentsErrorKind::ServiceLinkedRoleLockClientException`.
    pub fn is_service_linked_role_lock_client_exception(&self) -> bool {
        matches!(&self.kind, ListApplicationComponentsErrorKind::ServiceLinkedRoleLockClientException(_))
    }
    /// Returns `true` if the error kind is `ListApplicationComponentsErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListApplicationComponentsErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListApplicationComponentsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListApplicationComponentsErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListApplicationComponentsErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            ListApplicationComponentsErrorKind::ServiceLinkedRoleLockClientException(_inner) =>
            Some(_inner)
            ,
            ListApplicationComponentsErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            ListApplicationComponentsErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// <p> Exception to indicate that the service-linked role (SLR) is locked. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServiceLinkedRoleLockClientException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ServiceLinkedRoleLockClientException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ServiceLinkedRoleLockClientException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceLinkedRoleLockClientException")?;
        if let Some(inner_8) = &self.message {
             {
                write!(f, ": {}", inner_8)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ServiceLinkedRoleLockClientException {}
/// See [`ServiceLinkedRoleLockClientException`](crate::error::ServiceLinkedRoleLockClientException).
pub mod service_linked_role_lock_client_exception {
    
    /// A builder for [`ServiceLinkedRoleLockClientException`](crate::error::ServiceLinkedRoleLockClientException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`ServiceLinkedRoleLockClientException`](crate::error::ServiceLinkedRoleLockClientException).
        pub fn build(self) -> crate::error::ServiceLinkedRoleLockClientException {
            crate::error::ServiceLinkedRoleLockClientException {
                message: self.message
                ,
            }
        }
    }
    
    
}
impl ServiceLinkedRoleLockClientException {
    /// Creates a new builder-style object to manufacture [`ServiceLinkedRoleLockClientException`](crate::error::ServiceLinkedRoleLockClientException).
    pub fn builder() -> crate::error::service_linked_role_lock_client_exception::Builder {
        crate::error::service_linked_role_lock_client_exception::Builder::default()
    }
}

/// Error type for the `GetServerStrategies` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetServerStrategiesError {
    /// Kind of error that occurred.
                    pub kind: GetServerStrategiesErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetServerStrategiesError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetServerStrategiesErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetServerStrategies` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetServerStrategiesErrorKind {
    /// <p> The AWS user account does not have permission to perform the action. Check the AWS Identity and Access Management (IAM) policy associated with this account.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p> The server experienced an internal error. Try again. </p>
    InternalServerException(crate::error::InternalServerException),
    /// <p> The specified ID in the request is not found. </p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p> The request was denied due to request throttling. </p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p> The request body isn't valid. </p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetServerStrategiesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetServerStrategiesErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            GetServerStrategiesErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            GetServerStrategiesErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetServerStrategiesErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            GetServerStrategiesErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            GetServerStrategiesErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetServerStrategiesError {
    fn code(&self) -> Option<&str> {
        GetServerStrategiesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetServerStrategiesError {
    /// Creates a new `GetServerStrategiesError`.
                    pub fn new(kind: GetServerStrategiesErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetServerStrategiesError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetServerStrategiesErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetServerStrategiesError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetServerStrategiesErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetServerStrategiesErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetServerStrategiesErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetServerStrategiesErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, GetServerStrategiesErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `GetServerStrategiesErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetServerStrategiesErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetServerStrategiesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetServerStrategiesErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `GetServerStrategiesErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, GetServerStrategiesErrorKind::ValidationException(_))
    }
}
impl std::error::Error for GetServerStrategiesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetServerStrategiesErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            GetServerStrategiesErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            GetServerStrategiesErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            GetServerStrategiesErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            GetServerStrategiesErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            GetServerStrategiesErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetServerDetails` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetServerDetailsError {
    /// Kind of error that occurred.
                    pub kind: GetServerDetailsErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetServerDetailsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetServerDetailsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetServerDetails` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetServerDetailsErrorKind {
    /// <p> The AWS user account does not have permission to perform the action. Check the AWS Identity and Access Management (IAM) policy associated with this account.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p> The server experienced an internal error. Try again. </p>
    InternalServerException(crate::error::InternalServerException),
    /// <p> The specified ID in the request is not found. </p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p> The request was denied due to request throttling. </p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p> The request body isn't valid. </p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetServerDetailsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetServerDetailsErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            GetServerDetailsErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            GetServerDetailsErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetServerDetailsErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            GetServerDetailsErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            GetServerDetailsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetServerDetailsError {
    fn code(&self) -> Option<&str> {
        GetServerDetailsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetServerDetailsError {
    /// Creates a new `GetServerDetailsError`.
                    pub fn new(kind: GetServerDetailsErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetServerDetailsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetServerDetailsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetServerDetailsError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetServerDetailsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetServerDetailsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetServerDetailsErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetServerDetailsErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, GetServerDetailsErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `GetServerDetailsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetServerDetailsErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetServerDetailsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetServerDetailsErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `GetServerDetailsErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, GetServerDetailsErrorKind::ValidationException(_))
    }
}
impl std::error::Error for GetServerDetailsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetServerDetailsErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            GetServerDetailsErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            GetServerDetailsErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            GetServerDetailsErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            GetServerDetailsErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            GetServerDetailsErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetRecommendationReportDetails` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRecommendationReportDetailsError {
    /// Kind of error that occurred.
                    pub kind: GetRecommendationReportDetailsErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetRecommendationReportDetailsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetRecommendationReportDetailsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetRecommendationReportDetails` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRecommendationReportDetailsErrorKind {
    /// <p> The AWS user account does not have permission to perform the action. Check the AWS Identity and Access Management (IAM) policy associated with this account.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p> The server experienced an internal error. Try again. </p>
    InternalServerException(crate::error::InternalServerException),
    /// <p> The specified ID in the request is not found. </p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p> The request was denied due to request throttling. </p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p> The request body isn't valid. </p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetRecommendationReportDetailsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRecommendationReportDetailsErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            GetRecommendationReportDetailsErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            GetRecommendationReportDetailsErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetRecommendationReportDetailsErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            GetRecommendationReportDetailsErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            GetRecommendationReportDetailsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetRecommendationReportDetailsError {
    fn code(&self) -> Option<&str> {
        GetRecommendationReportDetailsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRecommendationReportDetailsError {
    /// Creates a new `GetRecommendationReportDetailsError`.
                    pub fn new(kind: GetRecommendationReportDetailsErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetRecommendationReportDetailsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetRecommendationReportDetailsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetRecommendationReportDetailsError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetRecommendationReportDetailsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetRecommendationReportDetailsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetRecommendationReportDetailsErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetRecommendationReportDetailsErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, GetRecommendationReportDetailsErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `GetRecommendationReportDetailsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetRecommendationReportDetailsErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetRecommendationReportDetailsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetRecommendationReportDetailsErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `GetRecommendationReportDetailsErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, GetRecommendationReportDetailsErrorKind::ValidationException(_))
    }
}
impl std::error::Error for GetRecommendationReportDetailsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRecommendationReportDetailsErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            GetRecommendationReportDetailsErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            GetRecommendationReportDetailsErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            GetRecommendationReportDetailsErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            GetRecommendationReportDetailsErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            GetRecommendationReportDetailsErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetPortfolioSummary` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPortfolioSummaryError {
    /// Kind of error that occurred.
                    pub kind: GetPortfolioSummaryErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetPortfolioSummaryError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetPortfolioSummaryErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetPortfolioSummary` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPortfolioSummaryErrorKind {
    /// <p> The AWS user account does not have permission to perform the action. Check the AWS Identity and Access Management (IAM) policy associated with this account.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p> The server experienced an internal error. Try again. </p>
    InternalServerException(crate::error::InternalServerException),
    /// <p> The request was denied due to request throttling. </p>
    ThrottlingException(crate::error::ThrottlingException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetPortfolioSummaryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPortfolioSummaryErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            GetPortfolioSummaryErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            GetPortfolioSummaryErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            GetPortfolioSummaryErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetPortfolioSummaryError {
    fn code(&self) -> Option<&str> {
        GetPortfolioSummaryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPortfolioSummaryError {
    /// Creates a new `GetPortfolioSummaryError`.
                    pub fn new(kind: GetPortfolioSummaryErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetPortfolioSummaryError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetPortfolioSummaryErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetPortfolioSummaryError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetPortfolioSummaryErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetPortfolioSummaryErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetPortfolioSummaryErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetPortfolioSummaryErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, GetPortfolioSummaryErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `GetPortfolioSummaryErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetPortfolioSummaryErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for GetPortfolioSummaryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPortfolioSummaryErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            GetPortfolioSummaryErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            GetPortfolioSummaryErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            GetPortfolioSummaryErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetPortfolioPreferences` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPortfolioPreferencesError {
    /// Kind of error that occurred.
                    pub kind: GetPortfolioPreferencesErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetPortfolioPreferencesError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetPortfolioPreferencesErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetPortfolioPreferences` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPortfolioPreferencesErrorKind {
    /// <p> The AWS user account does not have permission to perform the action. Check the AWS Identity and Access Management (IAM) policy associated with this account.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p> The server experienced an internal error. Try again. </p>
    InternalServerException(crate::error::InternalServerException),
    /// <p> The specified ID in the request is not found. </p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p> The request was denied due to request throttling. </p>
    ThrottlingException(crate::error::ThrottlingException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetPortfolioPreferencesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPortfolioPreferencesErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            GetPortfolioPreferencesErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            GetPortfolioPreferencesErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetPortfolioPreferencesErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            GetPortfolioPreferencesErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetPortfolioPreferencesError {
    fn code(&self) -> Option<&str> {
        GetPortfolioPreferencesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPortfolioPreferencesError {
    /// Creates a new `GetPortfolioPreferencesError`.
                    pub fn new(kind: GetPortfolioPreferencesErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetPortfolioPreferencesError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetPortfolioPreferencesErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetPortfolioPreferencesError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetPortfolioPreferencesErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetPortfolioPreferencesErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetPortfolioPreferencesErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetPortfolioPreferencesErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, GetPortfolioPreferencesErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `GetPortfolioPreferencesErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetPortfolioPreferencesErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetPortfolioPreferencesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetPortfolioPreferencesErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for GetPortfolioPreferencesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPortfolioPreferencesErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            GetPortfolioPreferencesErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            GetPortfolioPreferencesErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            GetPortfolioPreferencesErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            GetPortfolioPreferencesErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetLatestAssessmentId` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetLatestAssessmentIdError {
    /// Kind of error that occurred.
                    pub kind: GetLatestAssessmentIdErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetLatestAssessmentIdError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetLatestAssessmentIdErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetLatestAssessmentId` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetLatestAssessmentIdErrorKind {
    /// <p> The AWS user account does not have permission to perform the action. Check the AWS Identity and Access Management (IAM) policy associated with this account.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Dependency encountered an error.</p>
    DependencyException(crate::error::DependencyException),
    /// <p> The server experienced an internal error. Try again. </p>
    InternalServerException(crate::error::InternalServerException),
    /// <p> The request body isn't valid. </p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetLatestAssessmentIdError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetLatestAssessmentIdErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            GetLatestAssessmentIdErrorKind::DependencyException(_inner) =>
            _inner.fmt(f)
            ,
            GetLatestAssessmentIdErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            GetLatestAssessmentIdErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            GetLatestAssessmentIdErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetLatestAssessmentIdError {
    fn code(&self) -> Option<&str> {
        GetLatestAssessmentIdError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetLatestAssessmentIdError {
    /// Creates a new `GetLatestAssessmentIdError`.
                    pub fn new(kind: GetLatestAssessmentIdErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetLatestAssessmentIdError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetLatestAssessmentIdErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetLatestAssessmentIdError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetLatestAssessmentIdErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetLatestAssessmentIdErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetLatestAssessmentIdErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetLatestAssessmentIdErrorKind::DependencyException`.
    pub fn is_dependency_exception(&self) -> bool {
        matches!(&self.kind, GetLatestAssessmentIdErrorKind::DependencyException(_))
    }
    /// Returns `true` if the error kind is `GetLatestAssessmentIdErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, GetLatestAssessmentIdErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `GetLatestAssessmentIdErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, GetLatestAssessmentIdErrorKind::ValidationException(_))
    }
}
impl std::error::Error for GetLatestAssessmentIdError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetLatestAssessmentIdErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            GetLatestAssessmentIdErrorKind::DependencyException(_inner) =>
            Some(_inner)
            ,
            GetLatestAssessmentIdErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            GetLatestAssessmentIdErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            GetLatestAssessmentIdErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// <p>Dependency encountered an error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DependencyException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl DependencyException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for DependencyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DependencyException")?;
        if let Some(inner_9) = &self.message {
             {
                write!(f, ": {}", inner_9)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DependencyException {}
/// See [`DependencyException`](crate::error::DependencyException).
pub mod dependency_exception {
    
    /// A builder for [`DependencyException`](crate::error::DependencyException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`DependencyException`](crate::error::DependencyException).
        pub fn build(self) -> crate::error::DependencyException {
            crate::error::DependencyException {
                message: self.message
                ,
            }
        }
    }
    
    
}
impl DependencyException {
    /// Creates a new builder-style object to manufacture [`DependencyException`](crate::error::DependencyException).
    pub fn builder() -> crate::error::dependency_exception::Builder {
        crate::error::dependency_exception::Builder::default()
    }
}

/// Error type for the `GetImportFileTask` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetImportFileTaskError {
    /// Kind of error that occurred.
                    pub kind: GetImportFileTaskErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetImportFileTaskError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetImportFileTaskErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetImportFileTask` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetImportFileTaskErrorKind {
    /// <p> The AWS user account does not have permission to perform the action. Check the AWS Identity and Access Management (IAM) policy associated with this account.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p> The server experienced an internal error. Try again. </p>
    InternalServerException(crate::error::InternalServerException),
    /// <p> The specified ID in the request is not found. </p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p> The request was denied due to request throttling. </p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p> The request body isn't valid. </p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetImportFileTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetImportFileTaskErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            GetImportFileTaskErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            GetImportFileTaskErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetImportFileTaskErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            GetImportFileTaskErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            GetImportFileTaskErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetImportFileTaskError {
    fn code(&self) -> Option<&str> {
        GetImportFileTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetImportFileTaskError {
    /// Creates a new `GetImportFileTaskError`.
                    pub fn new(kind: GetImportFileTaskErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetImportFileTaskError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetImportFileTaskErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetImportFileTaskError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetImportFileTaskErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetImportFileTaskErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetImportFileTaskErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetImportFileTaskErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, GetImportFileTaskErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `GetImportFileTaskErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetImportFileTaskErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetImportFileTaskErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetImportFileTaskErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `GetImportFileTaskErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, GetImportFileTaskErrorKind::ValidationException(_))
    }
}
impl std::error::Error for GetImportFileTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetImportFileTaskErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            GetImportFileTaskErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            GetImportFileTaskErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            GetImportFileTaskErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            GetImportFileTaskErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            GetImportFileTaskErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetAssessment` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAssessmentError {
    /// Kind of error that occurred.
                    pub kind: GetAssessmentErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetAssessmentError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetAssessmentErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetAssessment` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAssessmentErrorKind {
    /// <p> The AWS user account does not have permission to perform the action. Check the AWS Identity and Access Management (IAM) policy associated with this account.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p> The server experienced an internal error. Try again. </p>
    InternalServerException(crate::error::InternalServerException),
    /// <p> The specified ID in the request is not found. </p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p> The request was denied due to request throttling. </p>
    ThrottlingException(crate::error::ThrottlingException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetAssessmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAssessmentErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            GetAssessmentErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            GetAssessmentErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetAssessmentErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            GetAssessmentErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetAssessmentError {
    fn code(&self) -> Option<&str> {
        GetAssessmentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAssessmentError {
    /// Creates a new `GetAssessmentError`.
                    pub fn new(kind: GetAssessmentErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetAssessmentError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetAssessmentErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetAssessmentError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetAssessmentErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetAssessmentErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetAssessmentErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetAssessmentErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, GetAssessmentErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `GetAssessmentErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetAssessmentErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetAssessmentErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetAssessmentErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for GetAssessmentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAssessmentErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            GetAssessmentErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            GetAssessmentErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            GetAssessmentErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            GetAssessmentErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetApplicationComponentStrategies` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetApplicationComponentStrategiesError {
    /// Kind of error that occurred.
                    pub kind: GetApplicationComponentStrategiesErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetApplicationComponentStrategiesError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetApplicationComponentStrategiesErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetApplicationComponentStrategies` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetApplicationComponentStrategiesErrorKind {
    /// <p> The server experienced an internal error. Try again. </p>
    InternalServerException(crate::error::InternalServerException),
    /// <p> The specified ID in the request is not found. </p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p> The request was denied due to request throttling. </p>
    ThrottlingException(crate::error::ThrottlingException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetApplicationComponentStrategiesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetApplicationComponentStrategiesErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            GetApplicationComponentStrategiesErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetApplicationComponentStrategiesErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            GetApplicationComponentStrategiesErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetApplicationComponentStrategiesError {
    fn code(&self) -> Option<&str> {
        GetApplicationComponentStrategiesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetApplicationComponentStrategiesError {
    /// Creates a new `GetApplicationComponentStrategiesError`.
                    pub fn new(kind: GetApplicationComponentStrategiesErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetApplicationComponentStrategiesError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetApplicationComponentStrategiesErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetApplicationComponentStrategiesError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetApplicationComponentStrategiesErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetApplicationComponentStrategiesErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, GetApplicationComponentStrategiesErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `GetApplicationComponentStrategiesErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetApplicationComponentStrategiesErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetApplicationComponentStrategiesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetApplicationComponentStrategiesErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for GetApplicationComponentStrategiesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetApplicationComponentStrategiesErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            GetApplicationComponentStrategiesErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            GetApplicationComponentStrategiesErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            GetApplicationComponentStrategiesErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetApplicationComponentDetails` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetApplicationComponentDetailsError {
    /// Kind of error that occurred.
                    pub kind: GetApplicationComponentDetailsErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetApplicationComponentDetailsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetApplicationComponentDetailsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetApplicationComponentDetails` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetApplicationComponentDetailsErrorKind {
    /// <p> The server experienced an internal error. Try again. </p>
    InternalServerException(crate::error::InternalServerException),
    /// <p> The specified ID in the request is not found. </p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p> The request was denied due to request throttling. </p>
    ThrottlingException(crate::error::ThrottlingException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetApplicationComponentDetailsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetApplicationComponentDetailsErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            GetApplicationComponentDetailsErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetApplicationComponentDetailsErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            GetApplicationComponentDetailsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetApplicationComponentDetailsError {
    fn code(&self) -> Option<&str> {
        GetApplicationComponentDetailsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetApplicationComponentDetailsError {
    /// Creates a new `GetApplicationComponentDetailsError`.
                    pub fn new(kind: GetApplicationComponentDetailsErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetApplicationComponentDetailsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetApplicationComponentDetailsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetApplicationComponentDetailsError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetApplicationComponentDetailsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetApplicationComponentDetailsErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, GetApplicationComponentDetailsErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `GetApplicationComponentDetailsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetApplicationComponentDetailsErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetApplicationComponentDetailsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetApplicationComponentDetailsErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for GetApplicationComponentDetailsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetApplicationComponentDetailsErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            GetApplicationComponentDetailsErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            GetApplicationComponentDetailsErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            GetApplicationComponentDetailsErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// 
/// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
/// 
/// When logging an error from the SDK, it is recommended that you either wrap the error in
/// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
/// error reporter library that visits the error's cause/source chain, or call
/// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
/// 
#[derive(Debug)]
        pub struct Unhandled {
            source: Box<dyn std::error::Error + Send + Sync + 'static>,
        }
        impl Unhandled {
            #[allow(unused)]
            pub(crate) fn new(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
                Self { source }
            }
        }
        impl std::fmt::Display for Unhandled {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                write!(f, "unhandled error")
            }
        }
        impl std::error::Error for Unhandled {
            fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                Some(self.source.as_ref() as _)
            }
        }

