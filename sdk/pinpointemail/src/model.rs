// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>An object that defines the event destination. Specifically, it defines which services
/// receive events from emails sent using the configuration set that the event destination
/// is associated with. Also defines the types of events that are sent to the event
/// destination.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EventDestinationDefinition {
    /// <p>If <code>true</code>, the event destination is enabled. When the event destination is
    /// enabled, the specified event types are sent to the destinations in this
    /// <code>EventDestinationDefinition</code>.</p>
    /// <p>If <code>false</code>, the event destination is disabled. When the event destination
    /// is disabled, events aren't sent to the specified destinations.</p>
    pub enabled: bool,
    /// <p>An array that specifies which events Amazon Pinpoint should send to the destinations in this
    /// <code>EventDestinationDefinition</code>.</p>
    pub matching_event_types: std::option::Option<std::vec::Vec<crate::model::EventType>>,
    /// <p>An object that defines an Amazon Kinesis Data Firehose destination for email events. You can use Amazon Kinesis Data Firehose to
    /// stream data to other services, such as Amazon S3 and Amazon Redshift.</p>
    pub kinesis_firehose_destination: std::option::Option<crate::model::KinesisFirehoseDestination>,
    /// <p>An object that defines an Amazon CloudWatch destination for email events. You can use Amazon CloudWatch to
    /// monitor and gain insights on your email sending metrics.</p>
    pub cloud_watch_destination: std::option::Option<crate::model::CloudWatchDestination>,
    /// <p>An object that defines an Amazon SNS destination for email events. You can use Amazon SNS to
    /// send notification when certain email events occur.</p>
    pub sns_destination: std::option::Option<crate::model::SnsDestination>,
    /// <p>An object that defines a Amazon Pinpoint destination for email events. You can use Amazon Pinpoint events
    /// to create attributes in Amazon Pinpoint projects. You can use these attributes to create segments
    /// for your campaigns.</p>
    pub pinpoint_destination: std::option::Option<crate::model::PinpointDestination>,
}
impl std::fmt::Debug for EventDestinationDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EventDestinationDefinition");
        formatter.field("enabled", &self.enabled);
        formatter.field("matching_event_types", &self.matching_event_types);
        formatter.field(
            "kinesis_firehose_destination",
            &self.kinesis_firehose_destination,
        );
        formatter.field("cloud_watch_destination", &self.cloud_watch_destination);
        formatter.field("sns_destination", &self.sns_destination);
        formatter.field("pinpoint_destination", &self.pinpoint_destination);
        formatter.finish()
    }
}
/// See [`EventDestinationDefinition`](crate::model::EventDestinationDefinition)
pub mod event_destination_definition {
    /// A builder for [`EventDestinationDefinition`](crate::model::EventDestinationDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) matching_event_types:
            std::option::Option<std::vec::Vec<crate::model::EventType>>,
        pub(crate) kinesis_firehose_destination:
            std::option::Option<crate::model::KinesisFirehoseDestination>,
        pub(crate) cloud_watch_destination:
            std::option::Option<crate::model::CloudWatchDestination>,
        pub(crate) sns_destination: std::option::Option<crate::model::SnsDestination>,
        pub(crate) pinpoint_destination: std::option::Option<crate::model::PinpointDestination>,
    }
    impl Builder {
        /// <p>If <code>true</code>, the event destination is enabled. When the event destination is
        /// enabled, the specified event types are sent to the destinations in this
        /// <code>EventDestinationDefinition</code>.</p>
        /// <p>If <code>false</code>, the event destination is disabled. When the event destination
        /// is disabled, events aren't sent to the specified destinations.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        pub fn matching_event_types(mut self, input: impl Into<crate::model::EventType>) -> Self {
            let mut v = self.matching_event_types.unwrap_or_default();
            v.push(input.into());
            self.matching_event_types = Some(v);
            self
        }
        pub fn set_matching_event_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EventType>>,
        ) -> Self {
            self.matching_event_types = input;
            self
        }
        /// <p>An object that defines an Amazon Kinesis Data Firehose destination for email events. You can use Amazon Kinesis Data Firehose to
        /// stream data to other services, such as Amazon S3 and Amazon Redshift.</p>
        pub fn kinesis_firehose_destination(
            mut self,
            input: crate::model::KinesisFirehoseDestination,
        ) -> Self {
            self.kinesis_firehose_destination = Some(input);
            self
        }
        pub fn set_kinesis_firehose_destination(
            mut self,
            input: std::option::Option<crate::model::KinesisFirehoseDestination>,
        ) -> Self {
            self.kinesis_firehose_destination = input;
            self
        }
        /// <p>An object that defines an Amazon CloudWatch destination for email events. You can use Amazon CloudWatch to
        /// monitor and gain insights on your email sending metrics.</p>
        pub fn cloud_watch_destination(
            mut self,
            input: crate::model::CloudWatchDestination,
        ) -> Self {
            self.cloud_watch_destination = Some(input);
            self
        }
        pub fn set_cloud_watch_destination(
            mut self,
            input: std::option::Option<crate::model::CloudWatchDestination>,
        ) -> Self {
            self.cloud_watch_destination = input;
            self
        }
        /// <p>An object that defines an Amazon SNS destination for email events. You can use Amazon SNS to
        /// send notification when certain email events occur.</p>
        pub fn sns_destination(mut self, input: crate::model::SnsDestination) -> Self {
            self.sns_destination = Some(input);
            self
        }
        pub fn set_sns_destination(
            mut self,
            input: std::option::Option<crate::model::SnsDestination>,
        ) -> Self {
            self.sns_destination = input;
            self
        }
        /// <p>An object that defines a Amazon Pinpoint destination for email events. You can use Amazon Pinpoint events
        /// to create attributes in Amazon Pinpoint projects. You can use these attributes to create segments
        /// for your campaigns.</p>
        pub fn pinpoint_destination(mut self, input: crate::model::PinpointDestination) -> Self {
            self.pinpoint_destination = Some(input);
            self
        }
        pub fn set_pinpoint_destination(
            mut self,
            input: std::option::Option<crate::model::PinpointDestination>,
        ) -> Self {
            self.pinpoint_destination = input;
            self
        }
        /// Consumes the builder and constructs a [`EventDestinationDefinition`](crate::model::EventDestinationDefinition)
        pub fn build(self) -> crate::model::EventDestinationDefinition {
            crate::model::EventDestinationDefinition {
                enabled: self.enabled.unwrap_or_default(),
                matching_event_types: self.matching_event_types,
                kinesis_firehose_destination: self.kinesis_firehose_destination,
                cloud_watch_destination: self.cloud_watch_destination,
                sns_destination: self.sns_destination,
                pinpoint_destination: self.pinpoint_destination,
            }
        }
    }
}
impl EventDestinationDefinition {
    /// Creates a new builder-style object to manufacture [`EventDestinationDefinition`](crate::model::EventDestinationDefinition)
    pub fn builder() -> crate::model::event_destination_definition::Builder {
        crate::model::event_destination_definition::Builder::default()
    }
}

/// <p>An object that defines a Amazon Pinpoint destination for email events. You can use Amazon Pinpoint events
/// to create attributes in Amazon Pinpoint projects. You can use these attributes to create segments
/// for your campaigns.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PinpointDestination {
    /// <p>The Amazon Resource Name (ARN) of the Amazon Pinpoint project that you want to send email
    /// events to.</p>
    pub application_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PinpointDestination {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PinpointDestination");
        formatter.field("application_arn", &self.application_arn);
        formatter.finish()
    }
}
/// See [`PinpointDestination`](crate::model::PinpointDestination)
pub mod pinpoint_destination {
    /// A builder for [`PinpointDestination`](crate::model::PinpointDestination)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the Amazon Pinpoint project that you want to send email
        /// events to.</p>
        pub fn application_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_arn = Some(input.into());
            self
        }
        pub fn set_application_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`PinpointDestination`](crate::model::PinpointDestination)
        pub fn build(self) -> crate::model::PinpointDestination {
            crate::model::PinpointDestination {
                application_arn: self.application_arn,
            }
        }
    }
}
impl PinpointDestination {
    /// Creates a new builder-style object to manufacture [`PinpointDestination`](crate::model::PinpointDestination)
    pub fn builder() -> crate::model::pinpoint_destination::Builder {
        crate::model::pinpoint_destination::Builder::default()
    }
}

/// <p>An object that defines an Amazon SNS destination for email events. You can use Amazon SNS to
/// send notification when certain email events occur.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SnsDestination {
    /// <p>The Amazon Resource Name (ARN) of the Amazon SNS topic that you want to publish email
    /// events to. For more information about Amazon SNS topics, see the <a href="https://docs.aws.amazon.com/sns/latest/dg/CreateTopic.html">Amazon SNS Developer
    /// Guide</a>.</p>
    pub topic_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SnsDestination {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SnsDestination");
        formatter.field("topic_arn", &self.topic_arn);
        formatter.finish()
    }
}
/// See [`SnsDestination`](crate::model::SnsDestination)
pub mod sns_destination {
    /// A builder for [`SnsDestination`](crate::model::SnsDestination)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) topic_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the Amazon SNS topic that you want to publish email
        /// events to. For more information about Amazon SNS topics, see the <a href="https://docs.aws.amazon.com/sns/latest/dg/CreateTopic.html">Amazon SNS Developer
        /// Guide</a>.</p>
        pub fn topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.topic_arn = Some(input.into());
            self
        }
        pub fn set_topic_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.topic_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`SnsDestination`](crate::model::SnsDestination)
        pub fn build(self) -> crate::model::SnsDestination {
            crate::model::SnsDestination {
                topic_arn: self.topic_arn,
            }
        }
    }
}
impl SnsDestination {
    /// Creates a new builder-style object to manufacture [`SnsDestination`](crate::model::SnsDestination)
    pub fn builder() -> crate::model::sns_destination::Builder {
        crate::model::sns_destination::Builder::default()
    }
}

/// <p>An object that defines an Amazon CloudWatch destination for email events. You can use Amazon CloudWatch to
/// monitor and gain insights on your email sending metrics.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CloudWatchDestination {
    /// <p>An array of objects that define the dimensions to use when you send email events to
    /// Amazon CloudWatch.</p>
    pub dimension_configurations:
        std::option::Option<std::vec::Vec<crate::model::CloudWatchDimensionConfiguration>>,
}
impl std::fmt::Debug for CloudWatchDestination {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CloudWatchDestination");
        formatter.field("dimension_configurations", &self.dimension_configurations);
        formatter.finish()
    }
}
/// See [`CloudWatchDestination`](crate::model::CloudWatchDestination)
pub mod cloud_watch_destination {
    /// A builder for [`CloudWatchDestination`](crate::model::CloudWatchDestination)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dimension_configurations:
            std::option::Option<std::vec::Vec<crate::model::CloudWatchDimensionConfiguration>>,
    }
    impl Builder {
        pub fn dimension_configurations(
            mut self,
            input: impl Into<crate::model::CloudWatchDimensionConfiguration>,
        ) -> Self {
            let mut v = self.dimension_configurations.unwrap_or_default();
            v.push(input.into());
            self.dimension_configurations = Some(v);
            self
        }
        pub fn set_dimension_configurations(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::CloudWatchDimensionConfiguration>,
            >,
        ) -> Self {
            self.dimension_configurations = input;
            self
        }
        /// Consumes the builder and constructs a [`CloudWatchDestination`](crate::model::CloudWatchDestination)
        pub fn build(self) -> crate::model::CloudWatchDestination {
            crate::model::CloudWatchDestination {
                dimension_configurations: self.dimension_configurations,
            }
        }
    }
}
impl CloudWatchDestination {
    /// Creates a new builder-style object to manufacture [`CloudWatchDestination`](crate::model::CloudWatchDestination)
    pub fn builder() -> crate::model::cloud_watch_destination::Builder {
        crate::model::cloud_watch_destination::Builder::default()
    }
}

/// <p>An object that defines the dimension configuration to use when you send Amazon Pinpoint email
/// events to Amazon CloudWatch.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CloudWatchDimensionConfiguration {
    /// <p>The name of an Amazon CloudWatch dimension associated with an email sending metric. The name has to
    /// meet the following criteria:</p>
    /// <ul>
    /// <li>
    /// <p>It can only contain ASCII letters (a-z, A-Z), numbers (0-9), underscores (_),
    /// or dashes (-).</p>
    /// </li>
    /// <li>
    /// <p>It can contain no more than 256 characters.</p>
    /// </li>
    /// </ul>
    pub dimension_name: std::option::Option<std::string::String>,
    /// <p>The location where Amazon Pinpoint finds the value of a dimension to publish to Amazon CloudWatch. If you
    /// want Amazon Pinpoint to use the message tags that you specify using an X-SES-MESSAGE-TAGS header
    /// or a parameter to the SendEmail/SendRawEmail API, choose <code>messageTag</code>. If you
    /// want Amazon Pinpoint to use your own email headers, choose <code>emailHeader</code>. If you want
    /// Amazon Pinpoint to use link tags, choose <code>linkTags</code>.</p>
    pub dimension_value_source: std::option::Option<crate::model::DimensionValueSource>,
    /// <p>The default value of the dimension that is published to Amazon CloudWatch if you don't provide the
    /// value of the dimension when you send an email. This value has to meet the following
    /// criteria:</p>
    /// <ul>
    /// <li>
    /// <p>It can only contain ASCII letters (a-z, A-Z), numbers (0-9), underscores (_),
    /// or dashes (-).</p>
    /// </li>
    /// <li>
    /// <p>It can contain no more than 256 characters.</p>
    /// </li>
    /// </ul>
    pub default_dimension_value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CloudWatchDimensionConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CloudWatchDimensionConfiguration");
        formatter.field("dimension_name", &self.dimension_name);
        formatter.field("dimension_value_source", &self.dimension_value_source);
        formatter.field("default_dimension_value", &self.default_dimension_value);
        formatter.finish()
    }
}
/// See [`CloudWatchDimensionConfiguration`](crate::model::CloudWatchDimensionConfiguration)
pub mod cloud_watch_dimension_configuration {
    /// A builder for [`CloudWatchDimensionConfiguration`](crate::model::CloudWatchDimensionConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dimension_name: std::option::Option<std::string::String>,
        pub(crate) dimension_value_source: std::option::Option<crate::model::DimensionValueSource>,
        pub(crate) default_dimension_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of an Amazon CloudWatch dimension associated with an email sending metric. The name has to
        /// meet the following criteria:</p>
        /// <ul>
        /// <li>
        /// <p>It can only contain ASCII letters (a-z, A-Z), numbers (0-9), underscores (_),
        /// or dashes (-).</p>
        /// </li>
        /// <li>
        /// <p>It can contain no more than 256 characters.</p>
        /// </li>
        /// </ul>
        pub fn dimension_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.dimension_name = Some(input.into());
            self
        }
        pub fn set_dimension_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dimension_name = input;
            self
        }
        /// <p>The location where Amazon Pinpoint finds the value of a dimension to publish to Amazon CloudWatch. If you
        /// want Amazon Pinpoint to use the message tags that you specify using an X-SES-MESSAGE-TAGS header
        /// or a parameter to the SendEmail/SendRawEmail API, choose <code>messageTag</code>. If you
        /// want Amazon Pinpoint to use your own email headers, choose <code>emailHeader</code>. If you want
        /// Amazon Pinpoint to use link tags, choose <code>linkTags</code>.</p>
        pub fn dimension_value_source(mut self, input: crate::model::DimensionValueSource) -> Self {
            self.dimension_value_source = Some(input);
            self
        }
        pub fn set_dimension_value_source(
            mut self,
            input: std::option::Option<crate::model::DimensionValueSource>,
        ) -> Self {
            self.dimension_value_source = input;
            self
        }
        /// <p>The default value of the dimension that is published to Amazon CloudWatch if you don't provide the
        /// value of the dimension when you send an email. This value has to meet the following
        /// criteria:</p>
        /// <ul>
        /// <li>
        /// <p>It can only contain ASCII letters (a-z, A-Z), numbers (0-9), underscores (_),
        /// or dashes (-).</p>
        /// </li>
        /// <li>
        /// <p>It can contain no more than 256 characters.</p>
        /// </li>
        /// </ul>
        pub fn default_dimension_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_dimension_value = Some(input.into());
            self
        }
        pub fn set_default_dimension_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_dimension_value = input;
            self
        }
        /// Consumes the builder and constructs a [`CloudWatchDimensionConfiguration`](crate::model::CloudWatchDimensionConfiguration)
        pub fn build(self) -> crate::model::CloudWatchDimensionConfiguration {
            crate::model::CloudWatchDimensionConfiguration {
                dimension_name: self.dimension_name,
                dimension_value_source: self.dimension_value_source,
                default_dimension_value: self.default_dimension_value,
            }
        }
    }
}
impl CloudWatchDimensionConfiguration {
    /// Creates a new builder-style object to manufacture [`CloudWatchDimensionConfiguration`](crate::model::CloudWatchDimensionConfiguration)
    pub fn builder() -> crate::model::cloud_watch_dimension_configuration::Builder {
        crate::model::cloud_watch_dimension_configuration::Builder::default()
    }
}

/// <p>The location where Amazon Pinpoint finds the value of a dimension to publish to Amazon CloudWatch. If you
/// want Amazon Pinpoint to use the message tags that you specify using an X-SES-MESSAGE-TAGS header
/// or a parameter to the SendEmail/SendRawEmail API, choose <code>messageTag</code>. If you
/// want Amazon Pinpoint to use your own email headers, choose <code>emailHeader</code>. If you want
/// Amazon Pinpoint to use link tags, choose <code>linkTags</code>.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DimensionValueSource {
    EmailHeader,
    LinkTag,
    MessageTag,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DimensionValueSource {
    fn from(s: &str) -> Self {
        match s {
            "EMAIL_HEADER" => DimensionValueSource::EmailHeader,
            "LINK_TAG" => DimensionValueSource::LinkTag,
            "MESSAGE_TAG" => DimensionValueSource::MessageTag,
            other => DimensionValueSource::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DimensionValueSource {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DimensionValueSource::from(s))
    }
}
impl DimensionValueSource {
    pub fn as_str(&self) -> &str {
        match self {
            DimensionValueSource::EmailHeader => "EMAIL_HEADER",
            DimensionValueSource::LinkTag => "LINK_TAG",
            DimensionValueSource::MessageTag => "MESSAGE_TAG",
            DimensionValueSource::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["EMAIL_HEADER", "LINK_TAG", "MESSAGE_TAG"]
    }
}
impl AsRef<str> for DimensionValueSource {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object that defines an Amazon Kinesis Data Firehose destination for email events. You can use Amazon Kinesis Data Firehose to
/// stream data to other services, such as Amazon S3 and Amazon Redshift.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KinesisFirehoseDestination {
    /// <p>The Amazon Resource Name (ARN) of the IAM role that Amazon Pinpoint uses when sending email
    /// events to the Amazon Kinesis Data Firehose stream.</p>
    pub iam_role_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Amazon Kinesis Data Firehose stream that Amazon Pinpoint sends email events
    /// to.</p>
    pub delivery_stream_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for KinesisFirehoseDestination {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KinesisFirehoseDestination");
        formatter.field("iam_role_arn", &self.iam_role_arn);
        formatter.field("delivery_stream_arn", &self.delivery_stream_arn);
        formatter.finish()
    }
}
/// See [`KinesisFirehoseDestination`](crate::model::KinesisFirehoseDestination)
pub mod kinesis_firehose_destination {
    /// A builder for [`KinesisFirehoseDestination`](crate::model::KinesisFirehoseDestination)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) iam_role_arn: std::option::Option<std::string::String>,
        pub(crate) delivery_stream_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the IAM role that Amazon Pinpoint uses when sending email
        /// events to the Amazon Kinesis Data Firehose stream.</p>
        pub fn iam_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.iam_role_arn = Some(input.into());
            self
        }
        pub fn set_iam_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.iam_role_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon Kinesis Data Firehose stream that Amazon Pinpoint sends email events
        /// to.</p>
        pub fn delivery_stream_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.delivery_stream_arn = Some(input.into());
            self
        }
        pub fn set_delivery_stream_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.delivery_stream_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`KinesisFirehoseDestination`](crate::model::KinesisFirehoseDestination)
        pub fn build(self) -> crate::model::KinesisFirehoseDestination {
            crate::model::KinesisFirehoseDestination {
                iam_role_arn: self.iam_role_arn,
                delivery_stream_arn: self.delivery_stream_arn,
            }
        }
    }
}
impl KinesisFirehoseDestination {
    /// Creates a new builder-style object to manufacture [`KinesisFirehoseDestination`](crate::model::KinesisFirehoseDestination)
    pub fn builder() -> crate::model::kinesis_firehose_destination::Builder {
        crate::model::kinesis_firehose_destination::Builder::default()
    }
}

/// <p>An email sending event type. For example, email sends, opens, and bounces are all
/// email events.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EventType {
    Bounce,
    Click,
    Complaint,
    Delivery,
    Open,
    Reject,
    RenderingFailure,
    Send,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for EventType {
    fn from(s: &str) -> Self {
        match s {
            "BOUNCE" => EventType::Bounce,
            "CLICK" => EventType::Click,
            "COMPLAINT" => EventType::Complaint,
            "DELIVERY" => EventType::Delivery,
            "OPEN" => EventType::Open,
            "REJECT" => EventType::Reject,
            "RENDERING_FAILURE" => EventType::RenderingFailure,
            "SEND" => EventType::Send,
            other => EventType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for EventType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EventType::from(s))
    }
}
impl EventType {
    pub fn as_str(&self) -> &str {
        match self {
            EventType::Bounce => "BOUNCE",
            EventType::Click => "CLICK",
            EventType::Complaint => "COMPLAINT",
            EventType::Delivery => "DELIVERY",
            EventType::Open => "OPEN",
            EventType::Reject => "REJECT",
            EventType::RenderingFailure => "RENDERING_FAILURE",
            EventType::Send => "SEND",
            EventType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "BOUNCE",
            "CLICK",
            "COMPLAINT",
            "DELIVERY",
            "OPEN",
            "REJECT",
            "RENDERING_FAILURE",
            "SEND",
        ]
    }
}
impl AsRef<str> for EventType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object that defines the tags that are associated with a resource.
/// A <i>tag</i> is a label that you optionally define and associate with
/// a resource in Amazon Pinpoint. Tags can help you categorize and manage resources in different
/// ways, such as by purpose, owner, environment, or other criteria. A resource can have as
/// many as 50 tags.</p>
/// <p>Each tag consists of a required <i>tag key</i> and an
/// associated <i>tag value</i>, both of which you define. A tag key is a
/// general label that acts as a category for a more specific tag value. A tag value acts as
/// a descriptor within a tag key. A tag key can contain as many as 128 characters. A tag
/// value can contain as many as 256 characters. The characters can be Unicode letters,
/// digits, white space, or one of the following symbols: _ . : / = + -. The following
/// additional restrictions apply to tags:</p>
/// <ul>
/// <li>
/// <p>Tag keys and values are case sensitive.</p>
/// </li>
/// <li>
/// <p>For each associated resource, each tag key must be unique and it can have only
/// one value.</p>
/// </li>
/// <li>
/// <p>The <code>aws:</code> prefix is reserved for use by AWS; you can’t use it in
/// any tag keys or values that you define. In addition, you can't edit or remove
/// tag keys or values that use this prefix. Tags that use this prefix don’t count
/// against the limit of 50 tags per resource.</p>
/// </li>
/// <li>
/// <p>You can associate tags with public or shared resources, but the tags are
/// available only for your AWS account, not any other accounts that share the
/// resource. In addition, the tags are available only for resources that are
/// located in the specified AWS Region for your AWS account.</p>
/// </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Tag {
    /// <p>One part of a key-value pair that defines a tag. The maximum length of a tag key is
    /// 128 characters. The minimum length is 1 character.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The optional part of a key-value pair that defines a tag. The maximum length of a tag
    /// value is 256 characters. The minimum length is 0 characters. If you don’t want a
    /// resource to have a specific tag value, don’t specify a value for this parameter. Amazon Pinpoint
    /// will set the value to an empty string.</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Tag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Tag");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Tag`](crate::model::Tag)
pub mod tag {
    /// A builder for [`Tag`](crate::model::Tag)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>One part of a key-value pair that defines a tag. The maximum length of a tag key is
        /// 128 characters. The minimum length is 1 character.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The optional part of a key-value pair that defines a tag. The maximum length of a tag
        /// value is 256 characters. The minimum length is 0 characters. If you don’t want a
        /// resource to have a specific tag value, don’t specify a value for this parameter. Amazon Pinpoint
        /// will set the value to an empty string.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag)
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag)
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// <p>Contains the name and value of a tag that you apply to an email. You can use message
/// tags when you publish email sending events.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MessageTag {
    /// <p>The name of the message tag. The message tag name has to meet the following
    /// criteria:</p>
    /// <ul>
    /// <li>
    /// <p>It can only contain ASCII letters (a–z, A–Z), numbers (0–9),
    /// underscores (_), or dashes (-).</p>
    /// </li>
    /// <li>
    /// <p>It can contain no more than 256 characters.</p>
    /// </li>
    /// </ul>
    pub name: std::option::Option<std::string::String>,
    /// <p>The value of the message tag. The message tag value has to meet the following
    /// criteria:</p>
    /// <ul>
    /// <li>
    /// <p>It can only contain ASCII letters (a–z, A–Z), numbers (0–9),
    /// underscores (_), or dashes (-).</p>
    /// </li>
    /// <li>
    /// <p>It can contain no more than 256 characters.</p>
    /// </li>
    /// </ul>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MessageTag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MessageTag");
        formatter.field("name", &self.name);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`MessageTag`](crate::model::MessageTag)
pub mod message_tag {
    /// A builder for [`MessageTag`](crate::model::MessageTag)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the message tag. The message tag name has to meet the following
        /// criteria:</p>
        /// <ul>
        /// <li>
        /// <p>It can only contain ASCII letters (a–z, A–Z), numbers (0–9),
        /// underscores (_), or dashes (-).</p>
        /// </li>
        /// <li>
        /// <p>It can contain no more than 256 characters.</p>
        /// </li>
        /// </ul>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The value of the message tag. The message tag value has to meet the following
        /// criteria:</p>
        /// <ul>
        /// <li>
        /// <p>It can only contain ASCII letters (a–z, A–Z), numbers (0–9),
        /// underscores (_), or dashes (-).</p>
        /// </li>
        /// <li>
        /// <p>It can contain no more than 256 characters.</p>
        /// </li>
        /// </ul>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`MessageTag`](crate::model::MessageTag)
        pub fn build(self) -> crate::model::MessageTag {
            crate::model::MessageTag {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl MessageTag {
    /// Creates a new builder-style object to manufacture [`MessageTag`](crate::model::MessageTag)
    pub fn builder() -> crate::model::message_tag::Builder {
        crate::model::message_tag::Builder::default()
    }
}

/// <p>An object that defines the entire content of the email, including the message headers
/// and the body content. You can create a simple email message, in which you specify the
/// subject and the text and HTML versions of the message body. You can also create raw
/// messages, in which you specify a complete MIME-formatted message. Raw messages can
/// include attachments and custom headers.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EmailContent {
    /// <p>The simple email message. The message consists of a subject and a message body.</p>
    pub simple: std::option::Option<crate::model::Message>,
    /// <p>The raw email message. The message has to meet the following criteria:</p>
    /// <ul>
    /// <li>
    /// <p>The message has to contain a header and a body, separated by one blank
    /// line.</p>
    /// </li>
    /// <li>
    /// <p>All of the required header fields must be present in the message.</p>
    /// </li>
    /// <li>
    /// <p>Each part of a multipart MIME message must be formatted properly.</p>
    /// </li>
    /// <li>
    /// <p>If you include attachments, they must be in a file format that Amazon Pinpoint supports.
    /// </p>
    /// </li>
    /// <li>
    /// <p>The entire message must be Base64 encoded.</p>
    /// </li>
    /// <li>
    /// <p>If any of the MIME parts in your message contain content that is outside of
    /// the 7-bit ASCII character range, you should encode that content to ensure that
    /// recipients' email clients render the message properly.</p>
    /// </li>
    /// <li>
    /// <p>The length of any single line of text in the message can't exceed 1,000
    /// characters. This restriction is defined in <a href="https://tools.ietf.org/html/rfc5321">RFC 5321</a>.</p>
    /// </li>
    /// </ul>
    pub raw: std::option::Option<crate::model::RawMessage>,
    /// <p>The template to use for the email message.</p>
    pub template: std::option::Option<crate::model::Template>,
}
impl std::fmt::Debug for EmailContent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EmailContent");
        formatter.field("simple", &self.simple);
        formatter.field("raw", &self.raw);
        formatter.field("template", &self.template);
        formatter.finish()
    }
}
/// See [`EmailContent`](crate::model::EmailContent)
pub mod email_content {
    /// A builder for [`EmailContent`](crate::model::EmailContent)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) simple: std::option::Option<crate::model::Message>,
        pub(crate) raw: std::option::Option<crate::model::RawMessage>,
        pub(crate) template: std::option::Option<crate::model::Template>,
    }
    impl Builder {
        /// <p>The simple email message. The message consists of a subject and a message body.</p>
        pub fn simple(mut self, input: crate::model::Message) -> Self {
            self.simple = Some(input);
            self
        }
        pub fn set_simple(mut self, input: std::option::Option<crate::model::Message>) -> Self {
            self.simple = input;
            self
        }
        /// <p>The raw email message. The message has to meet the following criteria:</p>
        /// <ul>
        /// <li>
        /// <p>The message has to contain a header and a body, separated by one blank
        /// line.</p>
        /// </li>
        /// <li>
        /// <p>All of the required header fields must be present in the message.</p>
        /// </li>
        /// <li>
        /// <p>Each part of a multipart MIME message must be formatted properly.</p>
        /// </li>
        /// <li>
        /// <p>If you include attachments, they must be in a file format that Amazon Pinpoint supports.
        /// </p>
        /// </li>
        /// <li>
        /// <p>The entire message must be Base64 encoded.</p>
        /// </li>
        /// <li>
        /// <p>If any of the MIME parts in your message contain content that is outside of
        /// the 7-bit ASCII character range, you should encode that content to ensure that
        /// recipients' email clients render the message properly.</p>
        /// </li>
        /// <li>
        /// <p>The length of any single line of text in the message can't exceed 1,000
        /// characters. This restriction is defined in <a href="https://tools.ietf.org/html/rfc5321">RFC 5321</a>.</p>
        /// </li>
        /// </ul>
        pub fn raw(mut self, input: crate::model::RawMessage) -> Self {
            self.raw = Some(input);
            self
        }
        pub fn set_raw(mut self, input: std::option::Option<crate::model::RawMessage>) -> Self {
            self.raw = input;
            self
        }
        /// <p>The template to use for the email message.</p>
        pub fn template(mut self, input: crate::model::Template) -> Self {
            self.template = Some(input);
            self
        }
        pub fn set_template(mut self, input: std::option::Option<crate::model::Template>) -> Self {
            self.template = input;
            self
        }
        /// Consumes the builder and constructs a [`EmailContent`](crate::model::EmailContent)
        pub fn build(self) -> crate::model::EmailContent {
            crate::model::EmailContent {
                simple: self.simple,
                raw: self.raw,
                template: self.template,
            }
        }
    }
}
impl EmailContent {
    /// Creates a new builder-style object to manufacture [`EmailContent`](crate::model::EmailContent)
    pub fn builder() -> crate::model::email_content::Builder {
        crate::model::email_content::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Template {
    /// <p>The Amazon Resource Name (ARN) of the template.</p>
    pub template_arn: std::option::Option<std::string::String>,
    /// <p>An object that defines the values to use for message variables in the template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the value to use for that variable.</p>
    pub template_data: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Template {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Template");
        formatter.field("template_arn", &self.template_arn);
        formatter.field("template_data", &self.template_data);
        formatter.finish()
    }
}
/// See [`Template`](crate::model::Template)
pub mod template {
    /// A builder for [`Template`](crate::model::Template)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) template_arn: std::option::Option<std::string::String>,
        pub(crate) template_data: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the template.</p>
        pub fn template_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_arn = Some(input.into());
            self
        }
        pub fn set_template_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.template_arn = input;
            self
        }
        /// <p>An object that defines the values to use for message variables in the template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the value to use for that variable.</p>
        pub fn template_data(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_data = Some(input.into());
            self
        }
        pub fn set_template_data(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_data = input;
            self
        }
        /// Consumes the builder and constructs a [`Template`](crate::model::Template)
        pub fn build(self) -> crate::model::Template {
            crate::model::Template {
                template_arn: self.template_arn,
                template_data: self.template_data,
            }
        }
    }
}
impl Template {
    /// Creates a new builder-style object to manufacture [`Template`](crate::model::Template)
    pub fn builder() -> crate::model::template::Builder {
        crate::model::template::Builder::default()
    }
}

/// <p>The raw email message.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RawMessage {
    /// <p>The raw email message. The message has to meet the following criteria:</p>
    /// <ul>
    /// <li>
    /// <p>The message has to contain a header and a body, separated by one blank
    /// line.</p>
    /// </li>
    /// <li>
    /// <p>All of the required header fields must be present in the message.</p>
    /// </li>
    /// <li>
    /// <p>Each part of a multipart MIME message must be formatted properly.</p>
    /// </li>
    /// <li>
    /// <p>Attachments must be in a file format that Amazon Pinpoint supports.
    /// </p>
    /// </li>
    /// <li>
    /// <p>The entire message must be Base64 encoded.</p>
    /// </li>
    /// <li>
    /// <p>If any of the MIME parts in your message contain content that is outside of
    /// the 7-bit ASCII character range, you should encode that content to ensure that
    /// recipients' email clients render the message properly.</p>
    /// </li>
    /// <li>
    /// <p>The length of any single line of text in the message can't exceed 1,000
    /// characters. This restriction is defined in <a href="https://tools.ietf.org/html/rfc5321">RFC 5321</a>.</p>
    /// </li>
    /// </ul>
    pub data: std::option::Option<smithy_types::Blob>,
}
impl std::fmt::Debug for RawMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RawMessage");
        formatter.field("data", &self.data);
        formatter.finish()
    }
}
/// See [`RawMessage`](crate::model::RawMessage)
pub mod raw_message {
    /// A builder for [`RawMessage`](crate::model::RawMessage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data: std::option::Option<smithy_types::Blob>,
    }
    impl Builder {
        /// <p>The raw email message. The message has to meet the following criteria:</p>
        /// <ul>
        /// <li>
        /// <p>The message has to contain a header and a body, separated by one blank
        /// line.</p>
        /// </li>
        /// <li>
        /// <p>All of the required header fields must be present in the message.</p>
        /// </li>
        /// <li>
        /// <p>Each part of a multipart MIME message must be formatted properly.</p>
        /// </li>
        /// <li>
        /// <p>Attachments must be in a file format that Amazon Pinpoint supports.
        /// </p>
        /// </li>
        /// <li>
        /// <p>The entire message must be Base64 encoded.</p>
        /// </li>
        /// <li>
        /// <p>If any of the MIME parts in your message contain content that is outside of
        /// the 7-bit ASCII character range, you should encode that content to ensure that
        /// recipients' email clients render the message properly.</p>
        /// </li>
        /// <li>
        /// <p>The length of any single line of text in the message can't exceed 1,000
        /// characters. This restriction is defined in <a href="https://tools.ietf.org/html/rfc5321">RFC 5321</a>.</p>
        /// </li>
        /// </ul>
        pub fn data(mut self, input: smithy_types::Blob) -> Self {
            self.data = Some(input);
            self
        }
        pub fn set_data(mut self, input: std::option::Option<smithy_types::Blob>) -> Self {
            self.data = input;
            self
        }
        /// Consumes the builder and constructs a [`RawMessage`](crate::model::RawMessage)
        pub fn build(self) -> crate::model::RawMessage {
            crate::model::RawMessage { data: self.data }
        }
    }
}
impl RawMessage {
    /// Creates a new builder-style object to manufacture [`RawMessage`](crate::model::RawMessage)
    pub fn builder() -> crate::model::raw_message::Builder {
        crate::model::raw_message::Builder::default()
    }
}

/// <p>Represents the email message that you're sending. The <code>Message</code> object
/// consists of a subject line and a message body.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Message {
    /// <p>The subject line of the email. The subject line can only contain 7-bit ASCII
    /// characters. However, you can specify non-ASCII characters in the subject line by using
    /// encoded-word syntax, as described in <a href="https://tools.ietf.org/html/rfc2047">RFC 2047</a>.</p>
    pub subject: std::option::Option<crate::model::Content>,
    /// <p>The body of the message. You can specify an HTML version of the message, a text-only
    /// version of the message, or both.</p>
    pub body: std::option::Option<crate::model::Body>,
}
impl std::fmt::Debug for Message {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Message");
        formatter.field("subject", &self.subject);
        formatter.field("body", &self.body);
        formatter.finish()
    }
}
/// See [`Message`](crate::model::Message)
pub mod message {
    /// A builder for [`Message`](crate::model::Message)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) subject: std::option::Option<crate::model::Content>,
        pub(crate) body: std::option::Option<crate::model::Body>,
    }
    impl Builder {
        /// <p>The subject line of the email. The subject line can only contain 7-bit ASCII
        /// characters. However, you can specify non-ASCII characters in the subject line by using
        /// encoded-word syntax, as described in <a href="https://tools.ietf.org/html/rfc2047">RFC 2047</a>.</p>
        pub fn subject(mut self, input: crate::model::Content) -> Self {
            self.subject = Some(input);
            self
        }
        pub fn set_subject(mut self, input: std::option::Option<crate::model::Content>) -> Self {
            self.subject = input;
            self
        }
        /// <p>The body of the message. You can specify an HTML version of the message, a text-only
        /// version of the message, or both.</p>
        pub fn body(mut self, input: crate::model::Body) -> Self {
            self.body = Some(input);
            self
        }
        pub fn set_body(mut self, input: std::option::Option<crate::model::Body>) -> Self {
            self.body = input;
            self
        }
        /// Consumes the builder and constructs a [`Message`](crate::model::Message)
        pub fn build(self) -> crate::model::Message {
            crate::model::Message {
                subject: self.subject,
                body: self.body,
            }
        }
    }
}
impl Message {
    /// Creates a new builder-style object to manufacture [`Message`](crate::model::Message)
    pub fn builder() -> crate::model::message::Builder {
        crate::model::message::Builder::default()
    }
}

/// <p>Represents the body of the email message.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Body {
    /// <p>An object that represents the version of the message that is displayed in email
    /// clients that don't support HTML, or clients where the recipient has disabled HTML
    /// rendering.</p>
    pub text: std::option::Option<crate::model::Content>,
    /// <p>An object that represents the version of the message that is displayed in email
    /// clients that support HTML. HTML messages can include formatted text, hyperlinks, images,
    /// and more. </p>
    pub html: std::option::Option<crate::model::Content>,
}
impl std::fmt::Debug for Body {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Body");
        formatter.field("text", &self.text);
        formatter.field("html", &self.html);
        formatter.finish()
    }
}
/// See [`Body`](crate::model::Body)
pub mod body {
    /// A builder for [`Body`](crate::model::Body)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) text: std::option::Option<crate::model::Content>,
        pub(crate) html: std::option::Option<crate::model::Content>,
    }
    impl Builder {
        /// <p>An object that represents the version of the message that is displayed in email
        /// clients that don't support HTML, or clients where the recipient has disabled HTML
        /// rendering.</p>
        pub fn text(mut self, input: crate::model::Content) -> Self {
            self.text = Some(input);
            self
        }
        pub fn set_text(mut self, input: std::option::Option<crate::model::Content>) -> Self {
            self.text = input;
            self
        }
        /// <p>An object that represents the version of the message that is displayed in email
        /// clients that support HTML. HTML messages can include formatted text, hyperlinks, images,
        /// and more. </p>
        pub fn html(mut self, input: crate::model::Content) -> Self {
            self.html = Some(input);
            self
        }
        pub fn set_html(mut self, input: std::option::Option<crate::model::Content>) -> Self {
            self.html = input;
            self
        }
        /// Consumes the builder and constructs a [`Body`](crate::model::Body)
        pub fn build(self) -> crate::model::Body {
            crate::model::Body {
                text: self.text,
                html: self.html,
            }
        }
    }
}
impl Body {
    /// Creates a new builder-style object to manufacture [`Body`](crate::model::Body)
    pub fn builder() -> crate::model::body::Builder {
        crate::model::body::Builder::default()
    }
}

/// <p>An object that represents the content of the email, and optionally a character set
/// specification.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Content {
    /// <p>The content of the message itself.</p>
    pub data: std::option::Option<std::string::String>,
    /// <p>The character set for the content. Because of the constraints of the SMTP protocol,
    /// Amazon Pinpoint uses 7-bit ASCII by default. If the text includes characters outside of the ASCII
    /// range, you have to specify a character set. For example, you could specify
    /// <code>UTF-8</code>, <code>ISO-8859-1</code>, or <code>Shift_JIS</code>.</p>
    pub charset: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Content {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Content");
        formatter.field("data", &self.data);
        formatter.field("charset", &self.charset);
        formatter.finish()
    }
}
/// See [`Content`](crate::model::Content)
pub mod content {
    /// A builder for [`Content`](crate::model::Content)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data: std::option::Option<std::string::String>,
        pub(crate) charset: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The content of the message itself.</p>
        pub fn data(mut self, input: impl Into<std::string::String>) -> Self {
            self.data = Some(input.into());
            self
        }
        pub fn set_data(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.data = input;
            self
        }
        /// <p>The character set for the content. Because of the constraints of the SMTP protocol,
        /// Amazon Pinpoint uses 7-bit ASCII by default. If the text includes characters outside of the ASCII
        /// range, you have to specify a character set. For example, you could specify
        /// <code>UTF-8</code>, <code>ISO-8859-1</code>, or <code>Shift_JIS</code>.</p>
        pub fn charset(mut self, input: impl Into<std::string::String>) -> Self {
            self.charset = Some(input.into());
            self
        }
        pub fn set_charset(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.charset = input;
            self
        }
        /// Consumes the builder and constructs a [`Content`](crate::model::Content)
        pub fn build(self) -> crate::model::Content {
            crate::model::Content {
                data: self.data,
                charset: self.charset,
            }
        }
    }
}
impl Content {
    /// Creates a new builder-style object to manufacture [`Content`](crate::model::Content)
    pub fn builder() -> crate::model::content::Builder {
        crate::model::content::Builder::default()
    }
}

/// <p>An object that describes the recipients for an email.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Destination {
    /// <p>An array that contains the email addresses of the "To" recipients for the
    /// email.</p>
    pub to_addresses: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>An array that contains the email addresses of the "CC" (carbon copy) recipients for
    /// the email.</p>
    pub cc_addresses: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>An array that contains the email addresses of the "BCC" (blind carbon copy) recipients
    /// for the email.</p>
    pub bcc_addresses: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for Destination {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Destination");
        formatter.field("to_addresses", &self.to_addresses);
        formatter.field("cc_addresses", &self.cc_addresses);
        formatter.field("bcc_addresses", &self.bcc_addresses);
        formatter.finish()
    }
}
/// See [`Destination`](crate::model::Destination)
pub mod destination {
    /// A builder for [`Destination`](crate::model::Destination)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) to_addresses: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) cc_addresses: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) bcc_addresses: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        pub fn to_addresses(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.to_addresses.unwrap_or_default();
            v.push(input.into());
            self.to_addresses = Some(v);
            self
        }
        pub fn set_to_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.to_addresses = input;
            self
        }
        pub fn cc_addresses(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.cc_addresses.unwrap_or_default();
            v.push(input.into());
            self.cc_addresses = Some(v);
            self
        }
        pub fn set_cc_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.cc_addresses = input;
            self
        }
        pub fn bcc_addresses(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.bcc_addresses.unwrap_or_default();
            v.push(input.into());
            self.bcc_addresses = Some(v);
            self
        }
        pub fn set_bcc_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.bcc_addresses = input;
            self
        }
        /// Consumes the builder and constructs a [`Destination`](crate::model::Destination)
        pub fn build(self) -> crate::model::Destination {
            crate::model::Destination {
                to_addresses: self.to_addresses,
                cc_addresses: self.cc_addresses,
                bcc_addresses: self.bcc_addresses,
            }
        }
    }
}
impl Destination {
    /// Creates a new builder-style object to manufacture [`Destination`](crate::model::Destination)
    pub fn builder() -> crate::model::destination::Builder {
        crate::model::destination::Builder::default()
    }
}

/// <p>The action that you want Amazon Pinpoint to take if it can't read the required MX record for a
/// custom MAIL FROM domain. When you set this value to <code>UseDefaultValue</code>, Amazon Pinpoint
/// uses <i>amazonses.com</i> as the MAIL FROM domain. When you set this value
/// to <code>RejectMessage</code>, Amazon Pinpoint returns a <code>MailFromDomainNotVerified</code>
/// error, and doesn't attempt to deliver the email.</p>
/// <p>These behaviors are taken when the custom MAIL FROM domain configuration is in the
/// <code>Pending</code>, <code>Failed</code>, and <code>TemporaryFailure</code>
/// states.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BehaviorOnMxFailure {
    RejectMessage,
    UseDefaultValue,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for BehaviorOnMxFailure {
    fn from(s: &str) -> Self {
        match s {
            "REJECT_MESSAGE" => BehaviorOnMxFailure::RejectMessage,
            "USE_DEFAULT_VALUE" => BehaviorOnMxFailure::UseDefaultValue,
            other => BehaviorOnMxFailure::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for BehaviorOnMxFailure {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BehaviorOnMxFailure::from(s))
    }
}
impl BehaviorOnMxFailure {
    pub fn as_str(&self) -> &str {
        match self {
            BehaviorOnMxFailure::RejectMessage => "REJECT_MESSAGE",
            BehaviorOnMxFailure::UseDefaultValue => "USE_DEFAULT_VALUE",
            BehaviorOnMxFailure::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["REJECT_MESSAGE", "USE_DEFAULT_VALUE"]
    }
}
impl AsRef<str> for BehaviorOnMxFailure {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object that contains information about the Deliverability dashboard subscription for a
/// verified domain that you use to send email and currently has an active Deliverability dashboard
/// subscription. If a Deliverability dashboard subscription is active for a domain, you gain access
/// to reputation, inbox placement, and other metrics for the domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DomainDeliverabilityTrackingOption {
    /// <p>A verified domain that’s associated with your AWS account and currently has an
    /// active Deliverability dashboard subscription.</p>
    pub domain: std::option::Option<std::string::String>,
    /// <p>The date, in Unix time format, when you enabled the Deliverability dashboard for the
    /// domain.</p>
    pub subscription_start_date: std::option::Option<smithy_types::Instant>,
    /// <p>An object that contains information about the inbox placement data settings for the
    /// domain.</p>
    pub inbox_placement_tracking_option:
        std::option::Option<crate::model::InboxPlacementTrackingOption>,
}
impl std::fmt::Debug for DomainDeliverabilityTrackingOption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DomainDeliverabilityTrackingOption");
        formatter.field("domain", &self.domain);
        formatter.field("subscription_start_date", &self.subscription_start_date);
        formatter.field(
            "inbox_placement_tracking_option",
            &self.inbox_placement_tracking_option,
        );
        formatter.finish()
    }
}
/// See [`DomainDeliverabilityTrackingOption`](crate::model::DomainDeliverabilityTrackingOption)
pub mod domain_deliverability_tracking_option {
    /// A builder for [`DomainDeliverabilityTrackingOption`](crate::model::DomainDeliverabilityTrackingOption)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) subscription_start_date: std::option::Option<smithy_types::Instant>,
        pub(crate) inbox_placement_tracking_option:
            std::option::Option<crate::model::InboxPlacementTrackingOption>,
    }
    impl Builder {
        /// <p>A verified domain that’s associated with your AWS account and currently has an
        /// active Deliverability dashboard subscription.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p>The date, in Unix time format, when you enabled the Deliverability dashboard for the
        /// domain.</p>
        pub fn subscription_start_date(mut self, input: smithy_types::Instant) -> Self {
            self.subscription_start_date = Some(input);
            self
        }
        pub fn set_subscription_start_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.subscription_start_date = input;
            self
        }
        /// <p>An object that contains information about the inbox placement data settings for the
        /// domain.</p>
        pub fn inbox_placement_tracking_option(
            mut self,
            input: crate::model::InboxPlacementTrackingOption,
        ) -> Self {
            self.inbox_placement_tracking_option = Some(input);
            self
        }
        pub fn set_inbox_placement_tracking_option(
            mut self,
            input: std::option::Option<crate::model::InboxPlacementTrackingOption>,
        ) -> Self {
            self.inbox_placement_tracking_option = input;
            self
        }
        /// Consumes the builder and constructs a [`DomainDeliverabilityTrackingOption`](crate::model::DomainDeliverabilityTrackingOption)
        pub fn build(self) -> crate::model::DomainDeliverabilityTrackingOption {
            crate::model::DomainDeliverabilityTrackingOption {
                domain: self.domain,
                subscription_start_date: self.subscription_start_date,
                inbox_placement_tracking_option: self.inbox_placement_tracking_option,
            }
        }
    }
}
impl DomainDeliverabilityTrackingOption {
    /// Creates a new builder-style object to manufacture [`DomainDeliverabilityTrackingOption`](crate::model::DomainDeliverabilityTrackingOption)
    pub fn builder() -> crate::model::domain_deliverability_tracking_option::Builder {
        crate::model::domain_deliverability_tracking_option::Builder::default()
    }
}

/// <p>An object that contains information about the inbox placement data settings for a
/// verified domain that’s associated with your AWS account. This data is available only
/// if you enabled the Deliverability dashboard for the domain
/// (<code>PutDeliverabilityDashboardOption</code> operation).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InboxPlacementTrackingOption {
    /// <p>Specifies whether inbox placement data is being tracked for the domain.</p>
    pub global: bool,
    /// <p>An array of strings, one for each major email provider that the inbox placement data
    /// applies to.</p>
    pub tracked_isps: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for InboxPlacementTrackingOption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InboxPlacementTrackingOption");
        formatter.field("global", &self.global);
        formatter.field("tracked_isps", &self.tracked_isps);
        formatter.finish()
    }
}
/// See [`InboxPlacementTrackingOption`](crate::model::InboxPlacementTrackingOption)
pub mod inbox_placement_tracking_option {
    /// A builder for [`InboxPlacementTrackingOption`](crate::model::InboxPlacementTrackingOption)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global: std::option::Option<bool>,
        pub(crate) tracked_isps: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>Specifies whether inbox placement data is being tracked for the domain.</p>
        pub fn global(mut self, input: bool) -> Self {
            self.global = Some(input);
            self
        }
        pub fn set_global(mut self, input: std::option::Option<bool>) -> Self {
            self.global = input;
            self
        }
        pub fn tracked_isps(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tracked_isps.unwrap_or_default();
            v.push(input.into());
            self.tracked_isps = Some(v);
            self
        }
        pub fn set_tracked_isps(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tracked_isps = input;
            self
        }
        /// Consumes the builder and constructs a [`InboxPlacementTrackingOption`](crate::model::InboxPlacementTrackingOption)
        pub fn build(self) -> crate::model::InboxPlacementTrackingOption {
            crate::model::InboxPlacementTrackingOption {
                global: self.global.unwrap_or_default(),
                tracked_isps: self.tracked_isps,
            }
        }
    }
}
impl InboxPlacementTrackingOption {
    /// Creates a new builder-style object to manufacture [`InboxPlacementTrackingOption`](crate::model::InboxPlacementTrackingOption)
    pub fn builder() -> crate::model::inbox_placement_tracking_option::Builder {
        crate::model::inbox_placement_tracking_option::Builder::default()
    }
}

/// <p>Specifies whether messages that use the configuration set are required to use
/// Transport Layer Security (TLS). If the value is <code>Require</code>, messages are only
/// delivered if a TLS connection can be established. If the value is <code>Optional</code>,
/// messages can be delivered in plain text if a TLS connection can't be established.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TlsPolicy {
    Optional,
    Require,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TlsPolicy {
    fn from(s: &str) -> Self {
        match s {
            "OPTIONAL" => TlsPolicy::Optional,
            "REQUIRE" => TlsPolicy::Require,
            other => TlsPolicy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TlsPolicy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TlsPolicy::from(s))
    }
}
impl TlsPolicy {
    pub fn as_str(&self) -> &str {
        match self {
            TlsPolicy::Optional => "OPTIONAL",
            TlsPolicy::Require => "REQUIRE",
            TlsPolicy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["OPTIONAL", "REQUIRE"]
    }
}
impl AsRef<str> for TlsPolicy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about an email identity.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IdentityInfo {
    /// <p>The email identity type. The identity type can be one of the following:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>EMAIL_ADDRESS</code> – The identity is an email address.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DOMAIN</code> – The identity is a domain.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>MANAGED_DOMAIN</code> – The identity is a domain that is managed
    /// by AWS.</p>
    /// </li>
    /// </ul>
    pub identity_type: std::option::Option<crate::model::IdentityType>,
    /// <p>The address or domain of the identity.</p>
    pub identity_name: std::option::Option<std::string::String>,
    /// <p>Indicates whether or not you can send email from the identity.</p>
    /// <p>In Amazon Pinpoint, an identity is an email address or domain that you send email from. Before
    /// you can send email from an identity, you have to demostrate that you own the identity,
    /// and that you authorize Amazon Pinpoint to send email from that identity.</p>
    pub sending_enabled: bool,
}
impl std::fmt::Debug for IdentityInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IdentityInfo");
        formatter.field("identity_type", &self.identity_type);
        formatter.field("identity_name", &self.identity_name);
        formatter.field("sending_enabled", &self.sending_enabled);
        formatter.finish()
    }
}
/// See [`IdentityInfo`](crate::model::IdentityInfo)
pub mod identity_info {
    /// A builder for [`IdentityInfo`](crate::model::IdentityInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) identity_type: std::option::Option<crate::model::IdentityType>,
        pub(crate) identity_name: std::option::Option<std::string::String>,
        pub(crate) sending_enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The email identity type. The identity type can be one of the following:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>EMAIL_ADDRESS</code> – The identity is an email address.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DOMAIN</code> – The identity is a domain.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>MANAGED_DOMAIN</code> – The identity is a domain that is managed
        /// by AWS.</p>
        /// </li>
        /// </ul>
        pub fn identity_type(mut self, input: crate::model::IdentityType) -> Self {
            self.identity_type = Some(input);
            self
        }
        pub fn set_identity_type(
            mut self,
            input: std::option::Option<crate::model::IdentityType>,
        ) -> Self {
            self.identity_type = input;
            self
        }
        /// <p>The address or domain of the identity.</p>
        pub fn identity_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.identity_name = Some(input.into());
            self
        }
        pub fn set_identity_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.identity_name = input;
            self
        }
        /// <p>Indicates whether or not you can send email from the identity.</p>
        /// <p>In Amazon Pinpoint, an identity is an email address or domain that you send email from. Before
        /// you can send email from an identity, you have to demostrate that you own the identity,
        /// and that you authorize Amazon Pinpoint to send email from that identity.</p>
        pub fn sending_enabled(mut self, input: bool) -> Self {
            self.sending_enabled = Some(input);
            self
        }
        pub fn set_sending_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.sending_enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`IdentityInfo`](crate::model::IdentityInfo)
        pub fn build(self) -> crate::model::IdentityInfo {
            crate::model::IdentityInfo {
                identity_type: self.identity_type,
                identity_name: self.identity_name,
                sending_enabled: self.sending_enabled.unwrap_or_default(),
            }
        }
    }
}
impl IdentityInfo {
    /// Creates a new builder-style object to manufacture [`IdentityInfo`](crate::model::IdentityInfo)
    pub fn builder() -> crate::model::identity_info::Builder {
        crate::model::identity_info::Builder::default()
    }
}

/// <p>The email identity type. The identity type can be one of the following:</p>
/// <ul>
/// <li>
/// <p>
/// <code>EMAIL_ADDRESS</code> – The identity is an email address.</p>
/// </li>
/// <li>
/// <p>
/// <code>DOMAIN</code> – The identity is a domain.</p>
/// </li>
/// </ul>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum IdentityType {
    Domain,
    EmailAddress,
    ManagedDomain,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for IdentityType {
    fn from(s: &str) -> Self {
        match s {
            "DOMAIN" => IdentityType::Domain,
            "EMAIL_ADDRESS" => IdentityType::EmailAddress,
            "MANAGED_DOMAIN" => IdentityType::ManagedDomain,
            other => IdentityType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for IdentityType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(IdentityType::from(s))
    }
}
impl IdentityType {
    pub fn as_str(&self) -> &str {
        match self {
            IdentityType::Domain => "DOMAIN",
            IdentityType::EmailAddress => "EMAIL_ADDRESS",
            IdentityType::ManagedDomain => "MANAGED_DOMAIN",
            IdentityType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["DOMAIN", "EMAIL_ADDRESS", "MANAGED_DOMAIN"]
    }
}
impl AsRef<str> for IdentityType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object that contains the deliverability data for a specific campaign. This data is
/// available for a campaign only if the campaign sent email by using a domain that the
/// Deliverability dashboard is enabled for (<code>PutDeliverabilityDashboardOption</code>
/// operation).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DomainDeliverabilityCampaign {
    /// <p>The unique identifier for the campaign. Amazon Pinpoint automatically generates and assigns this
    /// identifier to a campaign. This value is not the same as the campaign identifier that
    /// Amazon Pinpoint assigns to campaigns that you create and manage by using the Amazon Pinpoint API or the
    /// Amazon Pinpoint console.</p>
    pub campaign_id: std::option::Option<std::string::String>,
    /// <p>The URL of an image that contains a snapshot of the email message that was
    /// sent.</p>
    pub image_url: std::option::Option<std::string::String>,
    /// <p>The subject line, or title, of the email message.</p>
    pub subject: std::option::Option<std::string::String>,
    /// <p>The verified email address that the email message was sent from.</p>
    pub from_address: std::option::Option<std::string::String>,
    /// <p>The IP addresses that were used to send the email message.</p>
    pub sending_ips: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The first time, in Unix time format, when the email message was delivered to any
    /// recipient's inbox. This value can help you determine how long it took for a campaign to
    /// deliver an email message.</p>
    pub first_seen_date_time: std::option::Option<smithy_types::Instant>,
    /// <p>The last time, in Unix time format, when the email message was delivered to any
    /// recipient's inbox. This value can help you determine how long it took for a campaign to
    /// deliver an email message.</p>
    pub last_seen_date_time: std::option::Option<smithy_types::Instant>,
    /// <p>The number of email messages that were delivered to recipients’ inboxes.</p>
    pub inbox_count: std::option::Option<i64>,
    /// <p>The number of email messages that were delivered to recipients' spam or junk mail
    /// folders.</p>
    pub spam_count: std::option::Option<i64>,
    /// <p>The percentage of email messages that were opened by recipients. Due to technical
    /// limitations, this value only includes recipients who opened the message by using an
    /// email client that supports images.</p>
    pub read_rate: std::option::Option<f64>,
    /// <p>The percentage of email messages that were deleted by recipients, without being opened
    /// first. Due to technical limitations, this value only includes recipients who opened the
    /// message by using an email client that supports images.</p>
    pub delete_rate: std::option::Option<f64>,
    /// <p>The percentage of email messages that were opened and then deleted by recipients. Due
    /// to technical limitations, this value only includes recipients who opened the message by
    /// using an email client that supports images.</p>
    pub read_delete_rate: std::option::Option<f64>,
    /// <p>The projected number of recipients that the email message was sent to.</p>
    pub projected_volume: std::option::Option<i64>,
    /// <p>The major email providers who handled the email message.</p>
    pub esps: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for DomainDeliverabilityCampaign {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DomainDeliverabilityCampaign");
        formatter.field("campaign_id", &self.campaign_id);
        formatter.field("image_url", &self.image_url);
        formatter.field("subject", &self.subject);
        formatter.field("from_address", &self.from_address);
        formatter.field("sending_ips", &self.sending_ips);
        formatter.field("first_seen_date_time", &self.first_seen_date_time);
        formatter.field("last_seen_date_time", &self.last_seen_date_time);
        formatter.field("inbox_count", &self.inbox_count);
        formatter.field("spam_count", &self.spam_count);
        formatter.field("read_rate", &self.read_rate);
        formatter.field("delete_rate", &self.delete_rate);
        formatter.field("read_delete_rate", &self.read_delete_rate);
        formatter.field("projected_volume", &self.projected_volume);
        formatter.field("esps", &self.esps);
        formatter.finish()
    }
}
/// See [`DomainDeliverabilityCampaign`](crate::model::DomainDeliverabilityCampaign)
pub mod domain_deliverability_campaign {
    /// A builder for [`DomainDeliverabilityCampaign`](crate::model::DomainDeliverabilityCampaign)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) campaign_id: std::option::Option<std::string::String>,
        pub(crate) image_url: std::option::Option<std::string::String>,
        pub(crate) subject: std::option::Option<std::string::String>,
        pub(crate) from_address: std::option::Option<std::string::String>,
        pub(crate) sending_ips: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) first_seen_date_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_seen_date_time: std::option::Option<smithy_types::Instant>,
        pub(crate) inbox_count: std::option::Option<i64>,
        pub(crate) spam_count: std::option::Option<i64>,
        pub(crate) read_rate: std::option::Option<f64>,
        pub(crate) delete_rate: std::option::Option<f64>,
        pub(crate) read_delete_rate: std::option::Option<f64>,
        pub(crate) projected_volume: std::option::Option<i64>,
        pub(crate) esps: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The unique identifier for the campaign. Amazon Pinpoint automatically generates and assigns this
        /// identifier to a campaign. This value is not the same as the campaign identifier that
        /// Amazon Pinpoint assigns to campaigns that you create and manage by using the Amazon Pinpoint API or the
        /// Amazon Pinpoint console.</p>
        pub fn campaign_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.campaign_id = Some(input.into());
            self
        }
        pub fn set_campaign_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.campaign_id = input;
            self
        }
        /// <p>The URL of an image that contains a snapshot of the email message that was
        /// sent.</p>
        pub fn image_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_url = Some(input.into());
            self
        }
        pub fn set_image_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_url = input;
            self
        }
        /// <p>The subject line, or title, of the email message.</p>
        pub fn subject(mut self, input: impl Into<std::string::String>) -> Self {
            self.subject = Some(input.into());
            self
        }
        pub fn set_subject(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subject = input;
            self
        }
        /// <p>The verified email address that the email message was sent from.</p>
        pub fn from_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.from_address = Some(input.into());
            self
        }
        pub fn set_from_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.from_address = input;
            self
        }
        pub fn sending_ips(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.sending_ips.unwrap_or_default();
            v.push(input.into());
            self.sending_ips = Some(v);
            self
        }
        pub fn set_sending_ips(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.sending_ips = input;
            self
        }
        /// <p>The first time, in Unix time format, when the email message was delivered to any
        /// recipient's inbox. This value can help you determine how long it took for a campaign to
        /// deliver an email message.</p>
        pub fn first_seen_date_time(mut self, input: smithy_types::Instant) -> Self {
            self.first_seen_date_time = Some(input);
            self
        }
        pub fn set_first_seen_date_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.first_seen_date_time = input;
            self
        }
        /// <p>The last time, in Unix time format, when the email message was delivered to any
        /// recipient's inbox. This value can help you determine how long it took for a campaign to
        /// deliver an email message.</p>
        pub fn last_seen_date_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_seen_date_time = Some(input);
            self
        }
        pub fn set_last_seen_date_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_seen_date_time = input;
            self
        }
        /// <p>The number of email messages that were delivered to recipients’ inboxes.</p>
        pub fn inbox_count(mut self, input: i64) -> Self {
            self.inbox_count = Some(input);
            self
        }
        pub fn set_inbox_count(mut self, input: std::option::Option<i64>) -> Self {
            self.inbox_count = input;
            self
        }
        /// <p>The number of email messages that were delivered to recipients' spam or junk mail
        /// folders.</p>
        pub fn spam_count(mut self, input: i64) -> Self {
            self.spam_count = Some(input);
            self
        }
        pub fn set_spam_count(mut self, input: std::option::Option<i64>) -> Self {
            self.spam_count = input;
            self
        }
        /// <p>The percentage of email messages that were opened by recipients. Due to technical
        /// limitations, this value only includes recipients who opened the message by using an
        /// email client that supports images.</p>
        pub fn read_rate(mut self, input: f64) -> Self {
            self.read_rate = Some(input);
            self
        }
        pub fn set_read_rate(mut self, input: std::option::Option<f64>) -> Self {
            self.read_rate = input;
            self
        }
        /// <p>The percentage of email messages that were deleted by recipients, without being opened
        /// first. Due to technical limitations, this value only includes recipients who opened the
        /// message by using an email client that supports images.</p>
        pub fn delete_rate(mut self, input: f64) -> Self {
            self.delete_rate = Some(input);
            self
        }
        pub fn set_delete_rate(mut self, input: std::option::Option<f64>) -> Self {
            self.delete_rate = input;
            self
        }
        /// <p>The percentage of email messages that were opened and then deleted by recipients. Due
        /// to technical limitations, this value only includes recipients who opened the message by
        /// using an email client that supports images.</p>
        pub fn read_delete_rate(mut self, input: f64) -> Self {
            self.read_delete_rate = Some(input);
            self
        }
        pub fn set_read_delete_rate(mut self, input: std::option::Option<f64>) -> Self {
            self.read_delete_rate = input;
            self
        }
        /// <p>The projected number of recipients that the email message was sent to.</p>
        pub fn projected_volume(mut self, input: i64) -> Self {
            self.projected_volume = Some(input);
            self
        }
        pub fn set_projected_volume(mut self, input: std::option::Option<i64>) -> Self {
            self.projected_volume = input;
            self
        }
        pub fn esps(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.esps.unwrap_or_default();
            v.push(input.into());
            self.esps = Some(v);
            self
        }
        pub fn set_esps(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.esps = input;
            self
        }
        /// Consumes the builder and constructs a [`DomainDeliverabilityCampaign`](crate::model::DomainDeliverabilityCampaign)
        pub fn build(self) -> crate::model::DomainDeliverabilityCampaign {
            crate::model::DomainDeliverabilityCampaign {
                campaign_id: self.campaign_id,
                image_url: self.image_url,
                subject: self.subject,
                from_address: self.from_address,
                sending_ips: self.sending_ips,
                first_seen_date_time: self.first_seen_date_time,
                last_seen_date_time: self.last_seen_date_time,
                inbox_count: self.inbox_count,
                spam_count: self.spam_count,
                read_rate: self.read_rate,
                delete_rate: self.delete_rate,
                read_delete_rate: self.read_delete_rate,
                projected_volume: self.projected_volume,
                esps: self.esps,
            }
        }
    }
}
impl DomainDeliverabilityCampaign {
    /// Creates a new builder-style object to manufacture [`DomainDeliverabilityCampaign`](crate::model::DomainDeliverabilityCampaign)
    pub fn builder() -> crate::model::domain_deliverability_campaign::Builder {
        crate::model::domain_deliverability_campaign::Builder::default()
    }
}

/// <p>An object that contains metadata related to a predictive inbox placement test.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeliverabilityTestReport {
    /// <p>A unique string that identifies the predictive inbox placement test.</p>
    pub report_id: std::option::Option<std::string::String>,
    /// <p>A name that helps you identify a predictive inbox placement test report.</p>
    pub report_name: std::option::Option<std::string::String>,
    /// <p>The subject line for an email that you submitted in a predictive inbox placement test.</p>
    pub subject: std::option::Option<std::string::String>,
    /// <p>The sender address that you specified for the predictive inbox placement test.</p>
    pub from_email_address: std::option::Option<std::string::String>,
    /// <p>The date and time when the predictive inbox placement test was created, in Unix time format.</p>
    pub create_date: std::option::Option<smithy_types::Instant>,
    /// <p>The status of the predictive inbox placement test. If the status is <code>IN_PROGRESS</code>, then the predictive inbox placement test
    /// is currently running. Predictive inbox placement tests are usually complete within 24 hours of creating the
    /// test. If the status is <code>COMPLETE</code>, then the test is finished, and you can use
    /// the <code>GetDeliverabilityTestReport</code> to view the results of the test.</p>
    pub deliverability_test_status: std::option::Option<crate::model::DeliverabilityTestStatus>,
}
impl std::fmt::Debug for DeliverabilityTestReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeliverabilityTestReport");
        formatter.field("report_id", &self.report_id);
        formatter.field("report_name", &self.report_name);
        formatter.field("subject", &self.subject);
        formatter.field("from_email_address", &self.from_email_address);
        formatter.field("create_date", &self.create_date);
        formatter.field(
            "deliverability_test_status",
            &self.deliverability_test_status,
        );
        formatter.finish()
    }
}
/// See [`DeliverabilityTestReport`](crate::model::DeliverabilityTestReport)
pub mod deliverability_test_report {
    /// A builder for [`DeliverabilityTestReport`](crate::model::DeliverabilityTestReport)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) report_id: std::option::Option<std::string::String>,
        pub(crate) report_name: std::option::Option<std::string::String>,
        pub(crate) subject: std::option::Option<std::string::String>,
        pub(crate) from_email_address: std::option::Option<std::string::String>,
        pub(crate) create_date: std::option::Option<smithy_types::Instant>,
        pub(crate) deliverability_test_status:
            std::option::Option<crate::model::DeliverabilityTestStatus>,
    }
    impl Builder {
        /// <p>A unique string that identifies the predictive inbox placement test.</p>
        pub fn report_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.report_id = Some(input.into());
            self
        }
        pub fn set_report_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.report_id = input;
            self
        }
        /// <p>A name that helps you identify a predictive inbox placement test report.</p>
        pub fn report_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.report_name = Some(input.into());
            self
        }
        pub fn set_report_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.report_name = input;
            self
        }
        /// <p>The subject line for an email that you submitted in a predictive inbox placement test.</p>
        pub fn subject(mut self, input: impl Into<std::string::String>) -> Self {
            self.subject = Some(input.into());
            self
        }
        pub fn set_subject(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subject = input;
            self
        }
        /// <p>The sender address that you specified for the predictive inbox placement test.</p>
        pub fn from_email_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.from_email_address = Some(input.into());
            self
        }
        pub fn set_from_email_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.from_email_address = input;
            self
        }
        /// <p>The date and time when the predictive inbox placement test was created, in Unix time format.</p>
        pub fn create_date(mut self, input: smithy_types::Instant) -> Self {
            self.create_date = Some(input);
            self
        }
        pub fn set_create_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.create_date = input;
            self
        }
        /// <p>The status of the predictive inbox placement test. If the status is <code>IN_PROGRESS</code>, then the predictive inbox placement test
        /// is currently running. Predictive inbox placement tests are usually complete within 24 hours of creating the
        /// test. If the status is <code>COMPLETE</code>, then the test is finished, and you can use
        /// the <code>GetDeliverabilityTestReport</code> to view the results of the test.</p>
        pub fn deliverability_test_status(
            mut self,
            input: crate::model::DeliverabilityTestStatus,
        ) -> Self {
            self.deliverability_test_status = Some(input);
            self
        }
        pub fn set_deliverability_test_status(
            mut self,
            input: std::option::Option<crate::model::DeliverabilityTestStatus>,
        ) -> Self {
            self.deliverability_test_status = input;
            self
        }
        /// Consumes the builder and constructs a [`DeliverabilityTestReport`](crate::model::DeliverabilityTestReport)
        pub fn build(self) -> crate::model::DeliverabilityTestReport {
            crate::model::DeliverabilityTestReport {
                report_id: self.report_id,
                report_name: self.report_name,
                subject: self.subject,
                from_email_address: self.from_email_address,
                create_date: self.create_date,
                deliverability_test_status: self.deliverability_test_status,
            }
        }
    }
}
impl DeliverabilityTestReport {
    /// Creates a new builder-style object to manufacture [`DeliverabilityTestReport`](crate::model::DeliverabilityTestReport)
    pub fn builder() -> crate::model::deliverability_test_report::Builder {
        crate::model::deliverability_test_report::Builder::default()
    }
}

/// <p>The status of a predictive inbox placement test. If the status is <code>IN_PROGRESS</code>, then the predictive inbox placement test is
/// currently running. Predictive inbox placement tests are usually complete within 24 hours of creating the test.
/// If the status is <code>COMPLETE</code>, then the test is finished, and you can use the
/// <code>GetDeliverabilityTestReport</code> operation to view the results of the
/// test.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DeliverabilityTestStatus {
    Completed,
    InProgress,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DeliverabilityTestStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => DeliverabilityTestStatus::Completed,
            "IN_PROGRESS" => DeliverabilityTestStatus::InProgress,
            other => DeliverabilityTestStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DeliverabilityTestStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DeliverabilityTestStatus::from(s))
    }
}
impl DeliverabilityTestStatus {
    pub fn as_str(&self) -> &str {
        match self {
            DeliverabilityTestStatus::Completed => "COMPLETED",
            DeliverabilityTestStatus::InProgress => "IN_PROGRESS",
            DeliverabilityTestStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["COMPLETED", "IN_PROGRESS"]
    }
}
impl AsRef<str> for DeliverabilityTestStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A list of attributes that are associated with a MAIL FROM domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MailFromAttributes {
    /// <p>The name of a domain that an email identity uses as a custom MAIL FROM domain.</p>
    pub mail_from_domain: std::option::Option<std::string::String>,
    /// <p>The status of the MAIL FROM domain. This status can have the following values:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>PENDING</code> – Amazon Pinpoint hasn't started searching for the MX record
    /// yet.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SUCCESS</code> – Amazon Pinpoint detected the required MX record for the
    /// MAIL FROM domain.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>FAILED</code> – Amazon Pinpoint can't find the required MX record, or the
    /// record no longer exists.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>TEMPORARY_FAILURE</code> – A temporary issue occurred, which
    /// prevented Amazon Pinpoint from determining the status of the MAIL FROM domain.</p>
    /// </li>
    /// </ul>
    pub mail_from_domain_status: std::option::Option<crate::model::MailFromDomainStatus>,
    /// <p>The action that Amazon Pinpoint to takes if it can't read the required MX record for a custom
    /// MAIL FROM domain. When you set this value to <code>UseDefaultValue</code>, Amazon Pinpoint uses
    /// <i>amazonses.com</i> as the MAIL FROM domain. When you set this value
    /// to <code>RejectMessage</code>, Amazon Pinpoint returns a <code>MailFromDomainNotVerified</code>
    /// error, and doesn't attempt to deliver the email.</p>
    /// <p>These behaviors are taken when the custom MAIL FROM domain configuration is in the
    /// <code>Pending</code>, <code>Failed</code>, and <code>TemporaryFailure</code>
    /// states.</p>
    pub behavior_on_mx_failure: std::option::Option<crate::model::BehaviorOnMxFailure>,
}
impl std::fmt::Debug for MailFromAttributes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MailFromAttributes");
        formatter.field("mail_from_domain", &self.mail_from_domain);
        formatter.field("mail_from_domain_status", &self.mail_from_domain_status);
        formatter.field("behavior_on_mx_failure", &self.behavior_on_mx_failure);
        formatter.finish()
    }
}
/// See [`MailFromAttributes`](crate::model::MailFromAttributes)
pub mod mail_from_attributes {
    /// A builder for [`MailFromAttributes`](crate::model::MailFromAttributes)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) mail_from_domain: std::option::Option<std::string::String>,
        pub(crate) mail_from_domain_status: std::option::Option<crate::model::MailFromDomainStatus>,
        pub(crate) behavior_on_mx_failure: std::option::Option<crate::model::BehaviorOnMxFailure>,
    }
    impl Builder {
        /// <p>The name of a domain that an email identity uses as a custom MAIL FROM domain.</p>
        pub fn mail_from_domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.mail_from_domain = Some(input.into());
            self
        }
        pub fn set_mail_from_domain(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.mail_from_domain = input;
            self
        }
        /// <p>The status of the MAIL FROM domain. This status can have the following values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>PENDING</code> – Amazon Pinpoint hasn't started searching for the MX record
        /// yet.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SUCCESS</code> – Amazon Pinpoint detected the required MX record for the
        /// MAIL FROM domain.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FAILED</code> – Amazon Pinpoint can't find the required MX record, or the
        /// record no longer exists.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>TEMPORARY_FAILURE</code> – A temporary issue occurred, which
        /// prevented Amazon Pinpoint from determining the status of the MAIL FROM domain.</p>
        /// </li>
        /// </ul>
        pub fn mail_from_domain_status(
            mut self,
            input: crate::model::MailFromDomainStatus,
        ) -> Self {
            self.mail_from_domain_status = Some(input);
            self
        }
        pub fn set_mail_from_domain_status(
            mut self,
            input: std::option::Option<crate::model::MailFromDomainStatus>,
        ) -> Self {
            self.mail_from_domain_status = input;
            self
        }
        /// <p>The action that Amazon Pinpoint to takes if it can't read the required MX record for a custom
        /// MAIL FROM domain. When you set this value to <code>UseDefaultValue</code>, Amazon Pinpoint uses
        /// <i>amazonses.com</i> as the MAIL FROM domain. When you set this value
        /// to <code>RejectMessage</code>, Amazon Pinpoint returns a <code>MailFromDomainNotVerified</code>
        /// error, and doesn't attempt to deliver the email.</p>
        /// <p>These behaviors are taken when the custom MAIL FROM domain configuration is in the
        /// <code>Pending</code>, <code>Failed</code>, and <code>TemporaryFailure</code>
        /// states.</p>
        pub fn behavior_on_mx_failure(mut self, input: crate::model::BehaviorOnMxFailure) -> Self {
            self.behavior_on_mx_failure = Some(input);
            self
        }
        pub fn set_behavior_on_mx_failure(
            mut self,
            input: std::option::Option<crate::model::BehaviorOnMxFailure>,
        ) -> Self {
            self.behavior_on_mx_failure = input;
            self
        }
        /// Consumes the builder and constructs a [`MailFromAttributes`](crate::model::MailFromAttributes)
        pub fn build(self) -> crate::model::MailFromAttributes {
            crate::model::MailFromAttributes {
                mail_from_domain: self.mail_from_domain,
                mail_from_domain_status: self.mail_from_domain_status,
                behavior_on_mx_failure: self.behavior_on_mx_failure,
            }
        }
    }
}
impl MailFromAttributes {
    /// Creates a new builder-style object to manufacture [`MailFromAttributes`](crate::model::MailFromAttributes)
    pub fn builder() -> crate::model::mail_from_attributes::Builder {
        crate::model::mail_from_attributes::Builder::default()
    }
}

/// <p>The status of the MAIL FROM domain. This status can have the following values:</p>
/// <ul>
/// <li>
/// <p>
/// <code>PENDING</code> – Amazon Pinpoint hasn't started searching for the MX record
/// yet.</p>
/// </li>
/// <li>
/// <p>
/// <code>SUCCESS</code> – Amazon Pinpoint detected the required MX record for the
/// MAIL FROM domain.</p>
/// </li>
/// <li>
/// <p>
/// <code>FAILED</code> – Amazon Pinpoint can't find the required MX record, or the
/// record no longer exists.</p>
/// </li>
/// <li>
/// <p>
/// <code>TEMPORARY_FAILURE</code> – A temporary issue occurred, which
/// prevented Amazon Pinpoint from determining the status of the MAIL FROM domain.</p>
/// </li>
/// </ul>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MailFromDomainStatus {
    Failed,
    Pending,
    Success,
    TemporaryFailure,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MailFromDomainStatus {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => MailFromDomainStatus::Failed,
            "PENDING" => MailFromDomainStatus::Pending,
            "SUCCESS" => MailFromDomainStatus::Success,
            "TEMPORARY_FAILURE" => MailFromDomainStatus::TemporaryFailure,
            other => MailFromDomainStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MailFromDomainStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MailFromDomainStatus::from(s))
    }
}
impl MailFromDomainStatus {
    pub fn as_str(&self) -> &str {
        match self {
            MailFromDomainStatus::Failed => "FAILED",
            MailFromDomainStatus::Pending => "PENDING",
            MailFromDomainStatus::Success => "SUCCESS",
            MailFromDomainStatus::TemporaryFailure => "TEMPORARY_FAILURE",
            MailFromDomainStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["FAILED", "PENDING", "SUCCESS", "TEMPORARY_FAILURE"]
    }
}
impl AsRef<str> for MailFromDomainStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object that contains information about the DKIM configuration for an email
/// identity.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DkimAttributes {
    /// <p>If the value is <code>true</code>, then the messages that Amazon Pinpoint sends from the
    /// identity are DKIM-signed. If the value is <code>false</code>, then the messages that
    /// Amazon Pinpoint sends from the identity aren't DKIM-signed.</p>
    pub signing_enabled: bool,
    /// <p>Describes whether or not Amazon Pinpoint has successfully located the DKIM records in the DNS
    /// records for the domain. The status can be one of the following:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>PENDING</code> – Amazon Pinpoint hasn't yet located the DKIM records in the
    /// DNS configuration for the domain, but will continue to attempt to locate
    /// them.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SUCCESS</code> – Amazon Pinpoint located the DKIM records in the DNS
    /// configuration for the domain and determined that they're correct. Amazon Pinpoint can now
    /// send DKIM-signed email from the identity.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>FAILED</code> – Amazon Pinpoint was unable to locate the DKIM records in the
    /// DNS settings for the domain, and won't continue to search for them.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>TEMPORARY_FAILURE</code> – A temporary issue occurred, which
    /// prevented Amazon Pinpoint from determining the DKIM status for the domain.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>NOT_STARTED</code> – Amazon Pinpoint hasn't yet started searching for the
    /// DKIM records in the DKIM records for the domain.</p>
    /// </li>
    /// </ul>
    pub status: std::option::Option<crate::model::DkimStatus>,
    /// <p>A set of unique strings that you use to create a set of CNAME records that you add to
    /// the DNS configuration for your domain. When Amazon Pinpoint detects these records in the DNS
    /// configuration for your domain, the DKIM authentication process is complete. Amazon Pinpoint
    /// usually detects these records within about 72 hours of adding them to the DNS
    /// configuration for your domain.</p>
    pub tokens: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for DkimAttributes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DkimAttributes");
        formatter.field("signing_enabled", &self.signing_enabled);
        formatter.field("status", &self.status);
        formatter.field("tokens", &self.tokens);
        formatter.finish()
    }
}
/// See [`DkimAttributes`](crate::model::DkimAttributes)
pub mod dkim_attributes {
    /// A builder for [`DkimAttributes`](crate::model::DkimAttributes)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) signing_enabled: std::option::Option<bool>,
        pub(crate) status: std::option::Option<crate::model::DkimStatus>,
        pub(crate) tokens: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>If the value is <code>true</code>, then the messages that Amazon Pinpoint sends from the
        /// identity are DKIM-signed. If the value is <code>false</code>, then the messages that
        /// Amazon Pinpoint sends from the identity aren't DKIM-signed.</p>
        pub fn signing_enabled(mut self, input: bool) -> Self {
            self.signing_enabled = Some(input);
            self
        }
        pub fn set_signing_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.signing_enabled = input;
            self
        }
        /// <p>Describes whether or not Amazon Pinpoint has successfully located the DKIM records in the DNS
        /// records for the domain. The status can be one of the following:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>PENDING</code> – Amazon Pinpoint hasn't yet located the DKIM records in the
        /// DNS configuration for the domain, but will continue to attempt to locate
        /// them.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SUCCESS</code> – Amazon Pinpoint located the DKIM records in the DNS
        /// configuration for the domain and determined that they're correct. Amazon Pinpoint can now
        /// send DKIM-signed email from the identity.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FAILED</code> – Amazon Pinpoint was unable to locate the DKIM records in the
        /// DNS settings for the domain, and won't continue to search for them.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>TEMPORARY_FAILURE</code> – A temporary issue occurred, which
        /// prevented Amazon Pinpoint from determining the DKIM status for the domain.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NOT_STARTED</code> – Amazon Pinpoint hasn't yet started searching for the
        /// DKIM records in the DKIM records for the domain.</p>
        /// </li>
        /// </ul>
        pub fn status(mut self, input: crate::model::DkimStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(mut self, input: std::option::Option<crate::model::DkimStatus>) -> Self {
            self.status = input;
            self
        }
        pub fn tokens(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tokens.unwrap_or_default();
            v.push(input.into());
            self.tokens = Some(v);
            self
        }
        pub fn set_tokens(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tokens = input;
            self
        }
        /// Consumes the builder and constructs a [`DkimAttributes`](crate::model::DkimAttributes)
        pub fn build(self) -> crate::model::DkimAttributes {
            crate::model::DkimAttributes {
                signing_enabled: self.signing_enabled.unwrap_or_default(),
                status: self.status,
                tokens: self.tokens,
            }
        }
    }
}
impl DkimAttributes {
    /// Creates a new builder-style object to manufacture [`DkimAttributes`](crate::model::DkimAttributes)
    pub fn builder() -> crate::model::dkim_attributes::Builder {
        crate::model::dkim_attributes::Builder::default()
    }
}

/// <p>The DKIM authentication status of the identity. The status can be one of the
/// following:</p>
/// <ul>
/// <li>
/// <p>
/// <code>PENDING</code> – The DKIM verification process was initiated, and
/// Amazon Pinpoint is still waiting for the required CNAME records to appear in the DNS
/// configuration for the domain.</p>
/// </li>
/// <li>
/// <p>
/// <code>SUCCESS</code> – The DKIM authentication process completed
/// successfully.</p>
/// </li>
/// <li>
/// <p>
/// <code>FAILED</code> – The DKIM authentication process failed. This can
/// happen when Amazon Pinpoint fails to find the required CNAME records in the DNS
/// configuration of the domain.</p>
/// </li>
/// <li>
/// <p>
/// <code>TEMPORARY_FAILURE</code> – A temporary issue is preventing Amazon Pinpoint
/// from determining the DKIM authentication status of the domain.</p>
/// </li>
/// <li>
/// <p>
/// <code>NOT_STARTED</code> – The DKIM verification process hasn't been
/// initiated for the domain.</p>
/// </li>
/// </ul>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DkimStatus {
    Failed,
    NotStarted,
    Pending,
    Success,
    TemporaryFailure,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DkimStatus {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => DkimStatus::Failed,
            "NOT_STARTED" => DkimStatus::NotStarted,
            "PENDING" => DkimStatus::Pending,
            "SUCCESS" => DkimStatus::Success,
            "TEMPORARY_FAILURE" => DkimStatus::TemporaryFailure,
            other => DkimStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DkimStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DkimStatus::from(s))
    }
}
impl DkimStatus {
    pub fn as_str(&self) -> &str {
        match self {
            DkimStatus::Failed => "FAILED",
            DkimStatus::NotStarted => "NOT_STARTED",
            DkimStatus::Pending => "PENDING",
            DkimStatus::Success => "SUCCESS",
            DkimStatus::TemporaryFailure => "TEMPORARY_FAILURE",
            DkimStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "FAILED",
            "NOT_STARTED",
            "PENDING",
            "SUCCESS",
            "TEMPORARY_FAILURE",
        ]
    }
}
impl AsRef<str> for DkimStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object that contains information about the volume of email sent on each day of the
/// analysis period.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DailyVolume {
    /// <p>The date that the DailyVolume metrics apply to, in Unix time.</p>
    pub start_date: std::option::Option<smithy_types::Instant>,
    /// <p>An object that contains inbox placement metrics for a specific day in the analysis
    /// period.</p>
    pub volume_statistics: std::option::Option<crate::model::VolumeStatistics>,
    /// <p>An object that contains inbox placement metrics for a specified day in the analysis
    /// period, broken out by the recipient's email provider.</p>
    pub domain_isp_placements: std::option::Option<std::vec::Vec<crate::model::DomainIspPlacement>>,
}
impl std::fmt::Debug for DailyVolume {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DailyVolume");
        formatter.field("start_date", &self.start_date);
        formatter.field("volume_statistics", &self.volume_statistics);
        formatter.field("domain_isp_placements", &self.domain_isp_placements);
        formatter.finish()
    }
}
/// See [`DailyVolume`](crate::model::DailyVolume)
pub mod daily_volume {
    /// A builder for [`DailyVolume`](crate::model::DailyVolume)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) start_date: std::option::Option<smithy_types::Instant>,
        pub(crate) volume_statistics: std::option::Option<crate::model::VolumeStatistics>,
        pub(crate) domain_isp_placements:
            std::option::Option<std::vec::Vec<crate::model::DomainIspPlacement>>,
    }
    impl Builder {
        /// <p>The date that the DailyVolume metrics apply to, in Unix time.</p>
        pub fn start_date(mut self, input: smithy_types::Instant) -> Self {
            self.start_date = Some(input);
            self
        }
        pub fn set_start_date(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.start_date = input;
            self
        }
        /// <p>An object that contains inbox placement metrics for a specific day in the analysis
        /// period.</p>
        pub fn volume_statistics(mut self, input: crate::model::VolumeStatistics) -> Self {
            self.volume_statistics = Some(input);
            self
        }
        pub fn set_volume_statistics(
            mut self,
            input: std::option::Option<crate::model::VolumeStatistics>,
        ) -> Self {
            self.volume_statistics = input;
            self
        }
        pub fn domain_isp_placements(
            mut self,
            input: impl Into<crate::model::DomainIspPlacement>,
        ) -> Self {
            let mut v = self.domain_isp_placements.unwrap_or_default();
            v.push(input.into());
            self.domain_isp_placements = Some(v);
            self
        }
        pub fn set_domain_isp_placements(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DomainIspPlacement>>,
        ) -> Self {
            self.domain_isp_placements = input;
            self
        }
        /// Consumes the builder and constructs a [`DailyVolume`](crate::model::DailyVolume)
        pub fn build(self) -> crate::model::DailyVolume {
            crate::model::DailyVolume {
                start_date: self.start_date,
                volume_statistics: self.volume_statistics,
                domain_isp_placements: self.domain_isp_placements,
            }
        }
    }
}
impl DailyVolume {
    /// Creates a new builder-style object to manufacture [`DailyVolume`](crate::model::DailyVolume)
    pub fn builder() -> crate::model::daily_volume::Builder {
        crate::model::daily_volume::Builder::default()
    }
}

/// <p>An object that contains inbox placement data for email sent from one of your email
/// domains to a specific email provider.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DomainIspPlacement {
    /// <p>The name of the email provider that the inbox placement data applies to.</p>
    pub isp_name: std::option::Option<std::string::String>,
    /// <p>The total number of messages that were sent from the selected domain to the specified
    /// email provider that arrived in recipients' inboxes.</p>
    pub inbox_raw_count: std::option::Option<i64>,
    /// <p>The total number of messages that were sent from the selected domain to the specified
    /// email provider that arrived in recipients' spam or junk mail folders.</p>
    pub spam_raw_count: std::option::Option<i64>,
    /// <p>The percentage of messages that were sent from the selected domain to the specified
    /// email provider that arrived in recipients' inboxes.</p>
    pub inbox_percentage: std::option::Option<f64>,
    /// <p>The percentage of messages that were sent from the selected domain to the specified
    /// email provider that arrived in recipients' spam or junk mail folders.</p>
    pub spam_percentage: std::option::Option<f64>,
}
impl std::fmt::Debug for DomainIspPlacement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DomainIspPlacement");
        formatter.field("isp_name", &self.isp_name);
        formatter.field("inbox_raw_count", &self.inbox_raw_count);
        formatter.field("spam_raw_count", &self.spam_raw_count);
        formatter.field("inbox_percentage", &self.inbox_percentage);
        formatter.field("spam_percentage", &self.spam_percentage);
        formatter.finish()
    }
}
/// See [`DomainIspPlacement`](crate::model::DomainIspPlacement)
pub mod domain_isp_placement {
    /// A builder for [`DomainIspPlacement`](crate::model::DomainIspPlacement)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) isp_name: std::option::Option<std::string::String>,
        pub(crate) inbox_raw_count: std::option::Option<i64>,
        pub(crate) spam_raw_count: std::option::Option<i64>,
        pub(crate) inbox_percentage: std::option::Option<f64>,
        pub(crate) spam_percentage: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The name of the email provider that the inbox placement data applies to.</p>
        pub fn isp_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.isp_name = Some(input.into());
            self
        }
        pub fn set_isp_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.isp_name = input;
            self
        }
        /// <p>The total number of messages that were sent from the selected domain to the specified
        /// email provider that arrived in recipients' inboxes.</p>
        pub fn inbox_raw_count(mut self, input: i64) -> Self {
            self.inbox_raw_count = Some(input);
            self
        }
        pub fn set_inbox_raw_count(mut self, input: std::option::Option<i64>) -> Self {
            self.inbox_raw_count = input;
            self
        }
        /// <p>The total number of messages that were sent from the selected domain to the specified
        /// email provider that arrived in recipients' spam or junk mail folders.</p>
        pub fn spam_raw_count(mut self, input: i64) -> Self {
            self.spam_raw_count = Some(input);
            self
        }
        pub fn set_spam_raw_count(mut self, input: std::option::Option<i64>) -> Self {
            self.spam_raw_count = input;
            self
        }
        /// <p>The percentage of messages that were sent from the selected domain to the specified
        /// email provider that arrived in recipients' inboxes.</p>
        pub fn inbox_percentage(mut self, input: f64) -> Self {
            self.inbox_percentage = Some(input);
            self
        }
        pub fn set_inbox_percentage(mut self, input: std::option::Option<f64>) -> Self {
            self.inbox_percentage = input;
            self
        }
        /// <p>The percentage of messages that were sent from the selected domain to the specified
        /// email provider that arrived in recipients' spam or junk mail folders.</p>
        pub fn spam_percentage(mut self, input: f64) -> Self {
            self.spam_percentage = Some(input);
            self
        }
        pub fn set_spam_percentage(mut self, input: std::option::Option<f64>) -> Self {
            self.spam_percentage = input;
            self
        }
        /// Consumes the builder and constructs a [`DomainIspPlacement`](crate::model::DomainIspPlacement)
        pub fn build(self) -> crate::model::DomainIspPlacement {
            crate::model::DomainIspPlacement {
                isp_name: self.isp_name,
                inbox_raw_count: self.inbox_raw_count,
                spam_raw_count: self.spam_raw_count,
                inbox_percentage: self.inbox_percentage,
                spam_percentage: self.spam_percentage,
            }
        }
    }
}
impl DomainIspPlacement {
    /// Creates a new builder-style object to manufacture [`DomainIspPlacement`](crate::model::DomainIspPlacement)
    pub fn builder() -> crate::model::domain_isp_placement::Builder {
        crate::model::domain_isp_placement::Builder::default()
    }
}

/// <p>An object that contains information about the amount of email that was delivered to
/// recipients.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VolumeStatistics {
    /// <p>The total number of emails that arrived in recipients' inboxes.</p>
    pub inbox_raw_count: std::option::Option<i64>,
    /// <p>The total number of emails that arrived in recipients' spam or junk mail
    /// folders.</p>
    pub spam_raw_count: std::option::Option<i64>,
    /// <p>An estimate of the percentage of emails sent from the current domain that will arrive
    /// in recipients' inboxes.</p>
    pub projected_inbox: std::option::Option<i64>,
    /// <p>An estimate of the percentage of emails sent from the current domain that will arrive
    /// in recipients' spam or junk mail folders.</p>
    pub projected_spam: std::option::Option<i64>,
}
impl std::fmt::Debug for VolumeStatistics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VolumeStatistics");
        formatter.field("inbox_raw_count", &self.inbox_raw_count);
        formatter.field("spam_raw_count", &self.spam_raw_count);
        formatter.field("projected_inbox", &self.projected_inbox);
        formatter.field("projected_spam", &self.projected_spam);
        formatter.finish()
    }
}
/// See [`VolumeStatistics`](crate::model::VolumeStatistics)
pub mod volume_statistics {
    /// A builder for [`VolumeStatistics`](crate::model::VolumeStatistics)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) inbox_raw_count: std::option::Option<i64>,
        pub(crate) spam_raw_count: std::option::Option<i64>,
        pub(crate) projected_inbox: std::option::Option<i64>,
        pub(crate) projected_spam: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The total number of emails that arrived in recipients' inboxes.</p>
        pub fn inbox_raw_count(mut self, input: i64) -> Self {
            self.inbox_raw_count = Some(input);
            self
        }
        pub fn set_inbox_raw_count(mut self, input: std::option::Option<i64>) -> Self {
            self.inbox_raw_count = input;
            self
        }
        /// <p>The total number of emails that arrived in recipients' spam or junk mail
        /// folders.</p>
        pub fn spam_raw_count(mut self, input: i64) -> Self {
            self.spam_raw_count = Some(input);
            self
        }
        pub fn set_spam_raw_count(mut self, input: std::option::Option<i64>) -> Self {
            self.spam_raw_count = input;
            self
        }
        /// <p>An estimate of the percentage of emails sent from the current domain that will arrive
        /// in recipients' inboxes.</p>
        pub fn projected_inbox(mut self, input: i64) -> Self {
            self.projected_inbox = Some(input);
            self
        }
        pub fn set_projected_inbox(mut self, input: std::option::Option<i64>) -> Self {
            self.projected_inbox = input;
            self
        }
        /// <p>An estimate of the percentage of emails sent from the current domain that will arrive
        /// in recipients' spam or junk mail folders.</p>
        pub fn projected_spam(mut self, input: i64) -> Self {
            self.projected_spam = Some(input);
            self
        }
        pub fn set_projected_spam(mut self, input: std::option::Option<i64>) -> Self {
            self.projected_spam = input;
            self
        }
        /// Consumes the builder and constructs a [`VolumeStatistics`](crate::model::VolumeStatistics)
        pub fn build(self) -> crate::model::VolumeStatistics {
            crate::model::VolumeStatistics {
                inbox_raw_count: self.inbox_raw_count,
                spam_raw_count: self.spam_raw_count,
                projected_inbox: self.projected_inbox,
                projected_spam: self.projected_spam,
            }
        }
    }
}
impl VolumeStatistics {
    /// Creates a new builder-style object to manufacture [`VolumeStatistics`](crate::model::VolumeStatistics)
    pub fn builder() -> crate::model::volume_statistics::Builder {
        crate::model::volume_statistics::Builder::default()
    }
}

/// <p>An object that contains information about email that was sent from the selected
/// domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OverallVolume {
    /// <p>An object that contains information about the numbers of messages that arrived in
    /// recipients' inboxes and junk mail folders.</p>
    pub volume_statistics: std::option::Option<crate::model::VolumeStatistics>,
    /// <p>The percentage of emails that were sent from the domain that were read by their
    /// recipients.</p>
    pub read_rate_percent: std::option::Option<f64>,
    /// <p>An object that contains inbox and junk mail placement metrics for individual email
    /// providers.</p>
    pub domain_isp_placements: std::option::Option<std::vec::Vec<crate::model::DomainIspPlacement>>,
}
impl std::fmt::Debug for OverallVolume {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OverallVolume");
        formatter.field("volume_statistics", &self.volume_statistics);
        formatter.field("read_rate_percent", &self.read_rate_percent);
        formatter.field("domain_isp_placements", &self.domain_isp_placements);
        formatter.finish()
    }
}
/// See [`OverallVolume`](crate::model::OverallVolume)
pub mod overall_volume {
    /// A builder for [`OverallVolume`](crate::model::OverallVolume)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) volume_statistics: std::option::Option<crate::model::VolumeStatistics>,
        pub(crate) read_rate_percent: std::option::Option<f64>,
        pub(crate) domain_isp_placements:
            std::option::Option<std::vec::Vec<crate::model::DomainIspPlacement>>,
    }
    impl Builder {
        /// <p>An object that contains information about the numbers of messages that arrived in
        /// recipients' inboxes and junk mail folders.</p>
        pub fn volume_statistics(mut self, input: crate::model::VolumeStatistics) -> Self {
            self.volume_statistics = Some(input);
            self
        }
        pub fn set_volume_statistics(
            mut self,
            input: std::option::Option<crate::model::VolumeStatistics>,
        ) -> Self {
            self.volume_statistics = input;
            self
        }
        /// <p>The percentage of emails that were sent from the domain that were read by their
        /// recipients.</p>
        pub fn read_rate_percent(mut self, input: f64) -> Self {
            self.read_rate_percent = Some(input);
            self
        }
        pub fn set_read_rate_percent(mut self, input: std::option::Option<f64>) -> Self {
            self.read_rate_percent = input;
            self
        }
        pub fn domain_isp_placements(
            mut self,
            input: impl Into<crate::model::DomainIspPlacement>,
        ) -> Self {
            let mut v = self.domain_isp_placements.unwrap_or_default();
            v.push(input.into());
            self.domain_isp_placements = Some(v);
            self
        }
        pub fn set_domain_isp_placements(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DomainIspPlacement>>,
        ) -> Self {
            self.domain_isp_placements = input;
            self
        }
        /// Consumes the builder and constructs a [`OverallVolume`](crate::model::OverallVolume)
        pub fn build(self) -> crate::model::OverallVolume {
            crate::model::OverallVolume {
                volume_statistics: self.volume_statistics,
                read_rate_percent: self.read_rate_percent,
                domain_isp_placements: self.domain_isp_placements,
            }
        }
    }
}
impl OverallVolume {
    /// Creates a new builder-style object to manufacture [`OverallVolume`](crate::model::OverallVolume)
    pub fn builder() -> crate::model::overall_volume::Builder {
        crate::model::overall_volume::Builder::default()
    }
}

/// <p>An object that describes how email sent during the predictive inbox placement test was handled by a certain
/// email provider.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IspPlacement {
    /// <p>The name of the email provider that the inbox placement data applies to.</p>
    pub isp_name: std::option::Option<std::string::String>,
    /// <p>An object that contains inbox placement metrics for a specific email provider.</p>
    pub placement_statistics: std::option::Option<crate::model::PlacementStatistics>,
}
impl std::fmt::Debug for IspPlacement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IspPlacement");
        formatter.field("isp_name", &self.isp_name);
        formatter.field("placement_statistics", &self.placement_statistics);
        formatter.finish()
    }
}
/// See [`IspPlacement`](crate::model::IspPlacement)
pub mod isp_placement {
    /// A builder for [`IspPlacement`](crate::model::IspPlacement)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) isp_name: std::option::Option<std::string::String>,
        pub(crate) placement_statistics: std::option::Option<crate::model::PlacementStatistics>,
    }
    impl Builder {
        /// <p>The name of the email provider that the inbox placement data applies to.</p>
        pub fn isp_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.isp_name = Some(input.into());
            self
        }
        pub fn set_isp_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.isp_name = input;
            self
        }
        /// <p>An object that contains inbox placement metrics for a specific email provider.</p>
        pub fn placement_statistics(mut self, input: crate::model::PlacementStatistics) -> Self {
            self.placement_statistics = Some(input);
            self
        }
        pub fn set_placement_statistics(
            mut self,
            input: std::option::Option<crate::model::PlacementStatistics>,
        ) -> Self {
            self.placement_statistics = input;
            self
        }
        /// Consumes the builder and constructs a [`IspPlacement`](crate::model::IspPlacement)
        pub fn build(self) -> crate::model::IspPlacement {
            crate::model::IspPlacement {
                isp_name: self.isp_name,
                placement_statistics: self.placement_statistics,
            }
        }
    }
}
impl IspPlacement {
    /// Creates a new builder-style object to manufacture [`IspPlacement`](crate::model::IspPlacement)
    pub fn builder() -> crate::model::isp_placement::Builder {
        crate::model::isp_placement::Builder::default()
    }
}

/// <p>An object that contains inbox placement data for an email provider.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PlacementStatistics {
    /// <p>The percentage of emails that arrived in recipients' inboxes during the predictive inbox placement test.</p>
    pub inbox_percentage: std::option::Option<f64>,
    /// <p>The percentage of emails that arrived in recipients' spam or junk mail folders during
    /// the predictive inbox placement test.</p>
    pub spam_percentage: std::option::Option<f64>,
    /// <p>The percentage of emails that didn't arrive in recipients' inboxes at all during the
    /// predictive inbox placement test.</p>
    pub missing_percentage: std::option::Option<f64>,
    /// <p>The percentage of emails that were authenticated by using Sender Policy Framework
    /// (SPF) during the predictive inbox placement test.</p>
    pub spf_percentage: std::option::Option<f64>,
    /// <p>The percentage of emails that were authenticated by using DomainKeys Identified Mail
    /// (DKIM) during the predictive inbox placement test.</p>
    pub dkim_percentage: std::option::Option<f64>,
}
impl std::fmt::Debug for PlacementStatistics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PlacementStatistics");
        formatter.field("inbox_percentage", &self.inbox_percentage);
        formatter.field("spam_percentage", &self.spam_percentage);
        formatter.field("missing_percentage", &self.missing_percentage);
        formatter.field("spf_percentage", &self.spf_percentage);
        formatter.field("dkim_percentage", &self.dkim_percentage);
        formatter.finish()
    }
}
/// See [`PlacementStatistics`](crate::model::PlacementStatistics)
pub mod placement_statistics {
    /// A builder for [`PlacementStatistics`](crate::model::PlacementStatistics)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) inbox_percentage: std::option::Option<f64>,
        pub(crate) spam_percentage: std::option::Option<f64>,
        pub(crate) missing_percentage: std::option::Option<f64>,
        pub(crate) spf_percentage: std::option::Option<f64>,
        pub(crate) dkim_percentage: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The percentage of emails that arrived in recipients' inboxes during the predictive inbox placement test.</p>
        pub fn inbox_percentage(mut self, input: f64) -> Self {
            self.inbox_percentage = Some(input);
            self
        }
        pub fn set_inbox_percentage(mut self, input: std::option::Option<f64>) -> Self {
            self.inbox_percentage = input;
            self
        }
        /// <p>The percentage of emails that arrived in recipients' spam or junk mail folders during
        /// the predictive inbox placement test.</p>
        pub fn spam_percentage(mut self, input: f64) -> Self {
            self.spam_percentage = Some(input);
            self
        }
        pub fn set_spam_percentage(mut self, input: std::option::Option<f64>) -> Self {
            self.spam_percentage = input;
            self
        }
        /// <p>The percentage of emails that didn't arrive in recipients' inboxes at all during the
        /// predictive inbox placement test.</p>
        pub fn missing_percentage(mut self, input: f64) -> Self {
            self.missing_percentage = Some(input);
            self
        }
        pub fn set_missing_percentage(mut self, input: std::option::Option<f64>) -> Self {
            self.missing_percentage = input;
            self
        }
        /// <p>The percentage of emails that were authenticated by using Sender Policy Framework
        /// (SPF) during the predictive inbox placement test.</p>
        pub fn spf_percentage(mut self, input: f64) -> Self {
            self.spf_percentage = Some(input);
            self
        }
        pub fn set_spf_percentage(mut self, input: std::option::Option<f64>) -> Self {
            self.spf_percentage = input;
            self
        }
        /// <p>The percentage of emails that were authenticated by using DomainKeys Identified Mail
        /// (DKIM) during the predictive inbox placement test.</p>
        pub fn dkim_percentage(mut self, input: f64) -> Self {
            self.dkim_percentage = Some(input);
            self
        }
        pub fn set_dkim_percentage(mut self, input: std::option::Option<f64>) -> Self {
            self.dkim_percentage = input;
            self
        }
        /// Consumes the builder and constructs a [`PlacementStatistics`](crate::model::PlacementStatistics)
        pub fn build(self) -> crate::model::PlacementStatistics {
            crate::model::PlacementStatistics {
                inbox_percentage: self.inbox_percentage,
                spam_percentage: self.spam_percentage,
                missing_percentage: self.missing_percentage,
                spf_percentage: self.spf_percentage,
                dkim_percentage: self.dkim_percentage,
            }
        }
    }
}
impl PlacementStatistics {
    /// Creates a new builder-style object to manufacture [`PlacementStatistics`](crate::model::PlacementStatistics)
    pub fn builder() -> crate::model::placement_statistics::Builder {
        crate::model::placement_statistics::Builder::default()
    }
}

/// <p>The current status of your Deliverability dashboard subscription. If this value is
/// <code>PENDING_EXPIRATION</code>, your subscription is scheduled to expire at the end
/// of the current calendar month.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DeliverabilityDashboardAccountStatus {
    Active,
    Disabled,
    PendingExpiration,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DeliverabilityDashboardAccountStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => DeliverabilityDashboardAccountStatus::Active,
            "DISABLED" => DeliverabilityDashboardAccountStatus::Disabled,
            "PENDING_EXPIRATION" => DeliverabilityDashboardAccountStatus::PendingExpiration,
            other => DeliverabilityDashboardAccountStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DeliverabilityDashboardAccountStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DeliverabilityDashboardAccountStatus::from(s))
    }
}
impl DeliverabilityDashboardAccountStatus {
    pub fn as_str(&self) -> &str {
        match self {
            DeliverabilityDashboardAccountStatus::Active => "ACTIVE",
            DeliverabilityDashboardAccountStatus::Disabled => "DISABLED",
            DeliverabilityDashboardAccountStatus::PendingExpiration => "PENDING_EXPIRATION",
            DeliverabilityDashboardAccountStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["ACTIVE", "DISABLED", "PENDING_EXPIRATION"]
    }
}
impl AsRef<str> for DeliverabilityDashboardAccountStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about a dedicated IP address that is associated with your Amazon Pinpoint
/// account.</p>
/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DedicatedIp {
    /// <p>An IP address that is reserved for use by your Amazon Pinpoint account.</p>
    pub ip: std::option::Option<std::string::String>,
    /// <p>The warm-up status of a dedicated IP address. The status can have one of the following
    /// values:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>IN_PROGRESS</code> – The IP address isn't ready to use because the
    /// dedicated IP warm-up process is ongoing.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DONE</code> – The dedicated IP warm-up process is complete, and
    /// the IP address is ready to use.</p>
    /// </li>
    /// </ul>
    pub warmup_status: std::option::Option<crate::model::WarmupStatus>,
    /// <p>Indicates how complete the dedicated IP warm-up process is. When this value equals 1,
    /// the address has completed the warm-up process and is ready for use.</p>
    pub warmup_percentage: std::option::Option<i32>,
    /// <p>The name of the dedicated IP pool that the IP address is associated with.</p>
    pub pool_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DedicatedIp {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DedicatedIp");
        formatter.field("ip", &self.ip);
        formatter.field("warmup_status", &self.warmup_status);
        formatter.field("warmup_percentage", &self.warmup_percentage);
        formatter.field("pool_name", &self.pool_name);
        formatter.finish()
    }
}
/// See [`DedicatedIp`](crate::model::DedicatedIp)
pub mod dedicated_ip {
    /// A builder for [`DedicatedIp`](crate::model::DedicatedIp)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ip: std::option::Option<std::string::String>,
        pub(crate) warmup_status: std::option::Option<crate::model::WarmupStatus>,
        pub(crate) warmup_percentage: std::option::Option<i32>,
        pub(crate) pool_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An IP address that is reserved for use by your Amazon Pinpoint account.</p>
        pub fn ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.ip = Some(input.into());
            self
        }
        pub fn set_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ip = input;
            self
        }
        /// <p>The warm-up status of a dedicated IP address. The status can have one of the following
        /// values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>IN_PROGRESS</code> – The IP address isn't ready to use because the
        /// dedicated IP warm-up process is ongoing.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DONE</code> – The dedicated IP warm-up process is complete, and
        /// the IP address is ready to use.</p>
        /// </li>
        /// </ul>
        pub fn warmup_status(mut self, input: crate::model::WarmupStatus) -> Self {
            self.warmup_status = Some(input);
            self
        }
        pub fn set_warmup_status(
            mut self,
            input: std::option::Option<crate::model::WarmupStatus>,
        ) -> Self {
            self.warmup_status = input;
            self
        }
        /// <p>Indicates how complete the dedicated IP warm-up process is. When this value equals 1,
        /// the address has completed the warm-up process and is ready for use.</p>
        pub fn warmup_percentage(mut self, input: i32) -> Self {
            self.warmup_percentage = Some(input);
            self
        }
        pub fn set_warmup_percentage(mut self, input: std::option::Option<i32>) -> Self {
            self.warmup_percentage = input;
            self
        }
        /// <p>The name of the dedicated IP pool that the IP address is associated with.</p>
        pub fn pool_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.pool_name = Some(input.into());
            self
        }
        pub fn set_pool_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.pool_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DedicatedIp`](crate::model::DedicatedIp)
        pub fn build(self) -> crate::model::DedicatedIp {
            crate::model::DedicatedIp {
                ip: self.ip,
                warmup_status: self.warmup_status,
                warmup_percentage: self.warmup_percentage,
                pool_name: self.pool_name,
            }
        }
    }
}
impl DedicatedIp {
    /// Creates a new builder-style object to manufacture [`DedicatedIp`](crate::model::DedicatedIp)
    pub fn builder() -> crate::model::dedicated_ip::Builder {
        crate::model::dedicated_ip::Builder::default()
    }
}

/// <p>The warmup status of a dedicated IP.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WarmupStatus {
    Done,
    InProgress,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for WarmupStatus {
    fn from(s: &str) -> Self {
        match s {
            "DONE" => WarmupStatus::Done,
            "IN_PROGRESS" => WarmupStatus::InProgress,
            other => WarmupStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for WarmupStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WarmupStatus::from(s))
    }
}
impl WarmupStatus {
    pub fn as_str(&self) -> &str {
        match self {
            WarmupStatus::Done => "DONE",
            WarmupStatus::InProgress => "IN_PROGRESS",
            WarmupStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["DONE", "IN_PROGRESS"]
    }
}
impl AsRef<str> for WarmupStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>In Amazon Pinpoint, <i>events</i> include message sends, deliveries, opens,
/// clicks, bounces, and complaints. <i>Event destinations</i> are places that
/// you can send information about these events to. For example, you can send event data to
/// Amazon SNS to receive notifications when you receive bounces or complaints, or you can use
/// Amazon Kinesis Data Firehose to stream data to Amazon S3 for long-term storage.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EventDestination {
    /// <p>A name that identifies the event destination.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>If <code>true</code>, the event destination is enabled. When the event destination is
    /// enabled, the specified event types are sent to the destinations in this
    /// <code>EventDestinationDefinition</code>.</p>
    /// <p>If <code>false</code>, the event destination is disabled. When the event destination
    /// is disabled, events aren't sent to the specified destinations.</p>
    pub enabled: bool,
    /// <p>The types of events that Amazon Pinpoint sends to the specified event destinations.</p>
    pub matching_event_types: std::option::Option<std::vec::Vec<crate::model::EventType>>,
    /// <p>An object that defines an Amazon Kinesis Data Firehose destination for email events. You can use Amazon Kinesis Data Firehose to
    /// stream data to other services, such as Amazon S3 and Amazon Redshift.</p>
    pub kinesis_firehose_destination: std::option::Option<crate::model::KinesisFirehoseDestination>,
    /// <p>An object that defines an Amazon CloudWatch destination for email events. You can use Amazon CloudWatch to
    /// monitor and gain insights on your email sending metrics.</p>
    pub cloud_watch_destination: std::option::Option<crate::model::CloudWatchDestination>,
    /// <p>An object that defines an Amazon SNS destination for email events. You can use Amazon SNS to
    /// send notification when certain email events occur.</p>
    pub sns_destination: std::option::Option<crate::model::SnsDestination>,
    /// <p>An object that defines a Amazon Pinpoint destination for email events. You can use Amazon Pinpoint events
    /// to create attributes in Amazon Pinpoint projects. You can use these attributes to create segments
    /// for your campaigns.</p>
    pub pinpoint_destination: std::option::Option<crate::model::PinpointDestination>,
}
impl std::fmt::Debug for EventDestination {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EventDestination");
        formatter.field("name", &self.name);
        formatter.field("enabled", &self.enabled);
        formatter.field("matching_event_types", &self.matching_event_types);
        formatter.field(
            "kinesis_firehose_destination",
            &self.kinesis_firehose_destination,
        );
        formatter.field("cloud_watch_destination", &self.cloud_watch_destination);
        formatter.field("sns_destination", &self.sns_destination);
        formatter.field("pinpoint_destination", &self.pinpoint_destination);
        formatter.finish()
    }
}
/// See [`EventDestination`](crate::model::EventDestination)
pub mod event_destination {
    /// A builder for [`EventDestination`](crate::model::EventDestination)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) matching_event_types:
            std::option::Option<std::vec::Vec<crate::model::EventType>>,
        pub(crate) kinesis_firehose_destination:
            std::option::Option<crate::model::KinesisFirehoseDestination>,
        pub(crate) cloud_watch_destination:
            std::option::Option<crate::model::CloudWatchDestination>,
        pub(crate) sns_destination: std::option::Option<crate::model::SnsDestination>,
        pub(crate) pinpoint_destination: std::option::Option<crate::model::PinpointDestination>,
    }
    impl Builder {
        /// <p>A name that identifies the event destination.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>If <code>true</code>, the event destination is enabled. When the event destination is
        /// enabled, the specified event types are sent to the destinations in this
        /// <code>EventDestinationDefinition</code>.</p>
        /// <p>If <code>false</code>, the event destination is disabled. When the event destination
        /// is disabled, events aren't sent to the specified destinations.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        pub fn matching_event_types(mut self, input: impl Into<crate::model::EventType>) -> Self {
            let mut v = self.matching_event_types.unwrap_or_default();
            v.push(input.into());
            self.matching_event_types = Some(v);
            self
        }
        pub fn set_matching_event_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EventType>>,
        ) -> Self {
            self.matching_event_types = input;
            self
        }
        /// <p>An object that defines an Amazon Kinesis Data Firehose destination for email events. You can use Amazon Kinesis Data Firehose to
        /// stream data to other services, such as Amazon S3 and Amazon Redshift.</p>
        pub fn kinesis_firehose_destination(
            mut self,
            input: crate::model::KinesisFirehoseDestination,
        ) -> Self {
            self.kinesis_firehose_destination = Some(input);
            self
        }
        pub fn set_kinesis_firehose_destination(
            mut self,
            input: std::option::Option<crate::model::KinesisFirehoseDestination>,
        ) -> Self {
            self.kinesis_firehose_destination = input;
            self
        }
        /// <p>An object that defines an Amazon CloudWatch destination for email events. You can use Amazon CloudWatch to
        /// monitor and gain insights on your email sending metrics.</p>
        pub fn cloud_watch_destination(
            mut self,
            input: crate::model::CloudWatchDestination,
        ) -> Self {
            self.cloud_watch_destination = Some(input);
            self
        }
        pub fn set_cloud_watch_destination(
            mut self,
            input: std::option::Option<crate::model::CloudWatchDestination>,
        ) -> Self {
            self.cloud_watch_destination = input;
            self
        }
        /// <p>An object that defines an Amazon SNS destination for email events. You can use Amazon SNS to
        /// send notification when certain email events occur.</p>
        pub fn sns_destination(mut self, input: crate::model::SnsDestination) -> Self {
            self.sns_destination = Some(input);
            self
        }
        pub fn set_sns_destination(
            mut self,
            input: std::option::Option<crate::model::SnsDestination>,
        ) -> Self {
            self.sns_destination = input;
            self
        }
        /// <p>An object that defines a Amazon Pinpoint destination for email events. You can use Amazon Pinpoint events
        /// to create attributes in Amazon Pinpoint projects. You can use these attributes to create segments
        /// for your campaigns.</p>
        pub fn pinpoint_destination(mut self, input: crate::model::PinpointDestination) -> Self {
            self.pinpoint_destination = Some(input);
            self
        }
        pub fn set_pinpoint_destination(
            mut self,
            input: std::option::Option<crate::model::PinpointDestination>,
        ) -> Self {
            self.pinpoint_destination = input;
            self
        }
        /// Consumes the builder and constructs a [`EventDestination`](crate::model::EventDestination)
        pub fn build(self) -> crate::model::EventDestination {
            crate::model::EventDestination {
                name: self.name,
                enabled: self.enabled.unwrap_or_default(),
                matching_event_types: self.matching_event_types,
                kinesis_firehose_destination: self.kinesis_firehose_destination,
                cloud_watch_destination: self.cloud_watch_destination,
                sns_destination: self.sns_destination,
                pinpoint_destination: self.pinpoint_destination,
            }
        }
    }
}
impl EventDestination {
    /// Creates a new builder-style object to manufacture [`EventDestination`](crate::model::EventDestination)
    pub fn builder() -> crate::model::event_destination::Builder {
        crate::model::event_destination::Builder::default()
    }
}

/// <p>Used to enable or disable email sending for messages that use this configuration set
/// in the current AWS Region.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SendingOptions {
    /// <p>If <code>true</code>, email sending is enabled for the configuration set. If
    /// <code>false</code>, email sending is disabled for the configuration set.</p>
    pub sending_enabled: bool,
}
impl std::fmt::Debug for SendingOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SendingOptions");
        formatter.field("sending_enabled", &self.sending_enabled);
        formatter.finish()
    }
}
/// See [`SendingOptions`](crate::model::SendingOptions)
pub mod sending_options {
    /// A builder for [`SendingOptions`](crate::model::SendingOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sending_enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>If <code>true</code>, email sending is enabled for the configuration set. If
        /// <code>false</code>, email sending is disabled for the configuration set.</p>
        pub fn sending_enabled(mut self, input: bool) -> Self {
            self.sending_enabled = Some(input);
            self
        }
        pub fn set_sending_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.sending_enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`SendingOptions`](crate::model::SendingOptions)
        pub fn build(self) -> crate::model::SendingOptions {
            crate::model::SendingOptions {
                sending_enabled: self.sending_enabled.unwrap_or_default(),
            }
        }
    }
}
impl SendingOptions {
    /// Creates a new builder-style object to manufacture [`SendingOptions`](crate::model::SendingOptions)
    pub fn builder() -> crate::model::sending_options::Builder {
        crate::model::sending_options::Builder::default()
    }
}

/// <p>Enable or disable collection of reputation metrics for emails that you send using this
/// configuration set in the current AWS Region. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReputationOptions {
    /// <p>If <code>true</code>, tracking of reputation metrics is enabled for the configuration
    /// set. If <code>false</code>, tracking of reputation metrics is disabled for the
    /// configuration set.</p>
    pub reputation_metrics_enabled: bool,
    /// <p>The date and time (in Unix time) when the reputation metrics were last given a fresh
    /// start. When your account is given a fresh start, your reputation metrics are calculated
    /// starting from the date of the fresh start.</p>
    pub last_fresh_start: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for ReputationOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReputationOptions");
        formatter.field(
            "reputation_metrics_enabled",
            &self.reputation_metrics_enabled,
        );
        formatter.field("last_fresh_start", &self.last_fresh_start);
        formatter.finish()
    }
}
/// See [`ReputationOptions`](crate::model::ReputationOptions)
pub mod reputation_options {
    /// A builder for [`ReputationOptions`](crate::model::ReputationOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) reputation_metrics_enabled: std::option::Option<bool>,
        pub(crate) last_fresh_start: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>If <code>true</code>, tracking of reputation metrics is enabled for the configuration
        /// set. If <code>false</code>, tracking of reputation metrics is disabled for the
        /// configuration set.</p>
        pub fn reputation_metrics_enabled(mut self, input: bool) -> Self {
            self.reputation_metrics_enabled = Some(input);
            self
        }
        pub fn set_reputation_metrics_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.reputation_metrics_enabled = input;
            self
        }
        /// <p>The date and time (in Unix time) when the reputation metrics were last given a fresh
        /// start. When your account is given a fresh start, your reputation metrics are calculated
        /// starting from the date of the fresh start.</p>
        pub fn last_fresh_start(mut self, input: smithy_types::Instant) -> Self {
            self.last_fresh_start = Some(input);
            self
        }
        pub fn set_last_fresh_start(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_fresh_start = input;
            self
        }
        /// Consumes the builder and constructs a [`ReputationOptions`](crate::model::ReputationOptions)
        pub fn build(self) -> crate::model::ReputationOptions {
            crate::model::ReputationOptions {
                reputation_metrics_enabled: self.reputation_metrics_enabled.unwrap_or_default(),
                last_fresh_start: self.last_fresh_start,
            }
        }
    }
}
impl ReputationOptions {
    /// Creates a new builder-style object to manufacture [`ReputationOptions`](crate::model::ReputationOptions)
    pub fn builder() -> crate::model::reputation_options::Builder {
        crate::model::reputation_options::Builder::default()
    }
}

/// <p>Used to associate a configuration set with a dedicated IP pool.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeliveryOptions {
    /// <p>Specifies whether messages that use the configuration set are required to use
    /// Transport Layer Security (TLS). If the value is <code>Require</code>, messages are only
    /// delivered if a TLS connection can be established. If the value is <code>Optional</code>,
    /// messages can be delivered in plain text if a TLS connection can't be established.</p>
    pub tls_policy: std::option::Option<crate::model::TlsPolicy>,
    /// <p>The name of the dedicated IP pool that you want to associate with the configuration
    /// set.</p>
    pub sending_pool_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeliveryOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeliveryOptions");
        formatter.field("tls_policy", &self.tls_policy);
        formatter.field("sending_pool_name", &self.sending_pool_name);
        formatter.finish()
    }
}
/// See [`DeliveryOptions`](crate::model::DeliveryOptions)
pub mod delivery_options {
    /// A builder for [`DeliveryOptions`](crate::model::DeliveryOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) tls_policy: std::option::Option<crate::model::TlsPolicy>,
        pub(crate) sending_pool_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies whether messages that use the configuration set are required to use
        /// Transport Layer Security (TLS). If the value is <code>Require</code>, messages are only
        /// delivered if a TLS connection can be established. If the value is <code>Optional</code>,
        /// messages can be delivered in plain text if a TLS connection can't be established.</p>
        pub fn tls_policy(mut self, input: crate::model::TlsPolicy) -> Self {
            self.tls_policy = Some(input);
            self
        }
        pub fn set_tls_policy(
            mut self,
            input: std::option::Option<crate::model::TlsPolicy>,
        ) -> Self {
            self.tls_policy = input;
            self
        }
        /// <p>The name of the dedicated IP pool that you want to associate with the configuration
        /// set.</p>
        pub fn sending_pool_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.sending_pool_name = Some(input.into());
            self
        }
        pub fn set_sending_pool_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sending_pool_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeliveryOptions`](crate::model::DeliveryOptions)
        pub fn build(self) -> crate::model::DeliveryOptions {
            crate::model::DeliveryOptions {
                tls_policy: self.tls_policy,
                sending_pool_name: self.sending_pool_name,
            }
        }
    }
}
impl DeliveryOptions {
    /// Creates a new builder-style object to manufacture [`DeliveryOptions`](crate::model::DeliveryOptions)
    pub fn builder() -> crate::model::delivery_options::Builder {
        crate::model::delivery_options::Builder::default()
    }
}

/// <p>An object that defines the tracking options for a configuration set. When you use
/// Amazon Pinpoint to send an email, it contains an invisible image that's used to track when
/// recipients open your email. If your email contains links, those links are changed
/// slightly in order to track when recipients click them.</p>
/// <p>These images and links include references to a domain operated by AWS. You can
/// optionally configure Amazon Pinpoint to use a domain that you operate for these images and
/// links.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrackingOptions {
    /// <p>The domain that you want to use for tracking open and click events.</p>
    pub custom_redirect_domain: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TrackingOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrackingOptions");
        formatter.field("custom_redirect_domain", &self.custom_redirect_domain);
        formatter.finish()
    }
}
/// See [`TrackingOptions`](crate::model::TrackingOptions)
pub mod tracking_options {
    /// A builder for [`TrackingOptions`](crate::model::TrackingOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) custom_redirect_domain: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The domain that you want to use for tracking open and click events.</p>
        pub fn custom_redirect_domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.custom_redirect_domain = Some(input.into());
            self
        }
        pub fn set_custom_redirect_domain(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.custom_redirect_domain = input;
            self
        }
        /// Consumes the builder and constructs a [`TrackingOptions`](crate::model::TrackingOptions)
        pub fn build(self) -> crate::model::TrackingOptions {
            crate::model::TrackingOptions {
                custom_redirect_domain: self.custom_redirect_domain,
            }
        }
    }
}
impl TrackingOptions {
    /// Creates a new builder-style object to manufacture [`TrackingOptions`](crate::model::TrackingOptions)
    pub fn builder() -> crate::model::tracking_options::Builder {
        crate::model::tracking_options::Builder::default()
    }
}

/// <p>An object that contains information about a blacklisting event that impacts one of the
/// dedicated IP addresses that is associated with your account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BlacklistEntry {
    /// <p>The name of the blacklist that the IP address appears on.</p>
    pub rbl_name: std::option::Option<std::string::String>,
    /// <p>The time when the blacklisting event occurred, shown in Unix time format.</p>
    pub listing_time: std::option::Option<smithy_types::Instant>,
    /// <p>Additional information about the blacklisting event, as provided by the blacklist
    /// maintainer.</p>
    pub description: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BlacklistEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BlacklistEntry");
        formatter.field("rbl_name", &self.rbl_name);
        formatter.field("listing_time", &self.listing_time);
        formatter.field("description", &self.description);
        formatter.finish()
    }
}
/// See [`BlacklistEntry`](crate::model::BlacklistEntry)
pub mod blacklist_entry {
    /// A builder for [`BlacklistEntry`](crate::model::BlacklistEntry)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rbl_name: std::option::Option<std::string::String>,
        pub(crate) listing_time: std::option::Option<smithy_types::Instant>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the blacklist that the IP address appears on.</p>
        pub fn rbl_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.rbl_name = Some(input.into());
            self
        }
        pub fn set_rbl_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rbl_name = input;
            self
        }
        /// <p>The time when the blacklisting event occurred, shown in Unix time format.</p>
        pub fn listing_time(mut self, input: smithy_types::Instant) -> Self {
            self.listing_time = Some(input);
            self
        }
        pub fn set_listing_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.listing_time = input;
            self
        }
        /// <p>Additional information about the blacklisting event, as provided by the blacklist
        /// maintainer.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`BlacklistEntry`](crate::model::BlacklistEntry)
        pub fn build(self) -> crate::model::BlacklistEntry {
            crate::model::BlacklistEntry {
                rbl_name: self.rbl_name,
                listing_time: self.listing_time,
                description: self.description,
            }
        }
    }
}
impl BlacklistEntry {
    /// Creates a new builder-style object to manufacture [`BlacklistEntry`](crate::model::BlacklistEntry)
    pub fn builder() -> crate::model::blacklist_entry::Builder {
        crate::model::blacklist_entry::Builder::default()
    }
}

/// <p>An object that contains information about the per-day and per-second sending limits
/// for your Amazon Pinpoint account in the current AWS Region.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SendQuota {
    /// <p>The maximum number of emails that you can send in the current AWS Region over a
    /// 24-hour period. This value is also called your <i>sending
    /// quota</i>.</p>
    pub max24_hour_send: f64,
    /// <p>The maximum number of emails that you can send per second in the current AWS Region.
    /// This value is also called your <i>maximum sending rate</i> or your
    /// <i>maximum TPS (transactions per second) rate</i>.</p>
    pub max_send_rate: f64,
    /// <p>The number of emails sent from your Amazon Pinpoint account in the current AWS Region over the
    /// past 24 hours.</p>
    pub sent_last24_hours: f64,
}
impl std::fmt::Debug for SendQuota {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SendQuota");
        formatter.field("max24_hour_send", &self.max24_hour_send);
        formatter.field("max_send_rate", &self.max_send_rate);
        formatter.field("sent_last24_hours", &self.sent_last24_hours);
        formatter.finish()
    }
}
/// See [`SendQuota`](crate::model::SendQuota)
pub mod send_quota {
    /// A builder for [`SendQuota`](crate::model::SendQuota)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max24_hour_send: std::option::Option<f64>,
        pub(crate) max_send_rate: std::option::Option<f64>,
        pub(crate) sent_last24_hours: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The maximum number of emails that you can send in the current AWS Region over a
        /// 24-hour period. This value is also called your <i>sending
        /// quota</i>.</p>
        pub fn max24_hour_send(mut self, input: f64) -> Self {
            self.max24_hour_send = Some(input);
            self
        }
        pub fn set_max24_hour_send(mut self, input: std::option::Option<f64>) -> Self {
            self.max24_hour_send = input;
            self
        }
        /// <p>The maximum number of emails that you can send per second in the current AWS Region.
        /// This value is also called your <i>maximum sending rate</i> or your
        /// <i>maximum TPS (transactions per second) rate</i>.</p>
        pub fn max_send_rate(mut self, input: f64) -> Self {
            self.max_send_rate = Some(input);
            self
        }
        pub fn set_max_send_rate(mut self, input: std::option::Option<f64>) -> Self {
            self.max_send_rate = input;
            self
        }
        /// <p>The number of emails sent from your Amazon Pinpoint account in the current AWS Region over the
        /// past 24 hours.</p>
        pub fn sent_last24_hours(mut self, input: f64) -> Self {
            self.sent_last24_hours = Some(input);
            self
        }
        pub fn set_sent_last24_hours(mut self, input: std::option::Option<f64>) -> Self {
            self.sent_last24_hours = input;
            self
        }
        /// Consumes the builder and constructs a [`SendQuota`](crate::model::SendQuota)
        pub fn build(self) -> crate::model::SendQuota {
            crate::model::SendQuota {
                max24_hour_send: self.max24_hour_send.unwrap_or_default(),
                max_send_rate: self.max_send_rate.unwrap_or_default(),
                sent_last24_hours: self.sent_last24_hours.unwrap_or_default(),
            }
        }
    }
}
impl SendQuota {
    /// Creates a new builder-style object to manufacture [`SendQuota`](crate::model::SendQuota)
    pub fn builder() -> crate::model::send_quota::Builder {
        crate::model::send_quota::Builder::default()
    }
}
