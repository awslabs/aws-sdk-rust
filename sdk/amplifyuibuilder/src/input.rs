// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;

/// See [`CreateComponentInput`](crate::input::CreateComponentInput).
pub mod create_component_input {
    
    /// A builder for [`CreateComponentInput`](crate::input::CreateComponentInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_id: std::option::Option<std::string::String>,
        pub(crate) environment_name: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) component_to_create: std::option::Option<crate::model::CreateComponentData>,
    }
    impl Builder {
        /// <p>The unique ID of the Amplify app to associate with the component.</p>
        pub fn app_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_id = Some(input.into());
            self
        }
        /// <p>The unique ID of the Amplify app to associate with the component.</p>
        pub fn set_app_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_id = input; self
        }
        /// <p>The name of the backend environment that is a part of the Amplify app.</p>
        pub fn environment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.environment_name = Some(input.into());
            self
        }
        /// <p>The name of the backend environment that is a part of the Amplify app.</p>
        pub fn set_environment_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.environment_name = input; self
        }
        /// <p>The unique client token.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>The unique client token.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// <p>Represents the configuration of the component to create.</p>
        pub fn component_to_create(mut self, input: crate::model::CreateComponentData) -> Self {
            self.component_to_create = Some(input);
            self
        }
        /// <p>Represents the configuration of the component to create.</p>
        pub fn set_component_to_create(mut self, input: std::option::Option<crate::model::CreateComponentData>) -> Self {
            self.component_to_create = input; self
        }
        /// Consumes the builder and constructs a [`CreateComponentInput`](crate::input::CreateComponentInput).
        pub fn build(self) -> Result<crate::input::CreateComponentInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateComponentInput {
                    app_id: self.app_id
                    ,
                    environment_name: self.environment_name
                    ,
                    client_token: self.client_token
                    ,
                    component_to_create: self.component_to_create
                    ,
                }
            )
        }
    }
    
    
}
impl CreateComponentInput {
    /// Consumes the builder and constructs an Operation<[`CreateComponent`](crate::operation::CreateComponent)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateComponent, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.client_token.is_none() {
                                self.client_token = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::input::CreateComponentInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_1 = &_input.app_id;
                let input_1 = input_1.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))?;
                let app_id = aws_smithy_http::label::fmt_string(input_1, aws_smithy_http::label::EncodingStrategy::Default);
                if app_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))
                            }
                let input_2 = &_input.environment_name;
                let input_2 = input_2.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))?;
                let environment_name = aws_smithy_http::label::fmt_string(input_2, aws_smithy_http::label::EncodingStrategy::Default);
                if environment_name.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))
                            }
                write!(output, "/app/{appId}/environment/{environmentName}/components", appId = app_id, environmentName = environment_name).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::CreateComponentInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_3) = &_input.client_token {
                     {
                        query.push_kv("clientToken", &aws_smithy_http::query::fmt_string(&inner_3));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateComponentInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_payload_create_component_input(& self.component_to_create)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateComponent::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateComponent", "amplifyuibuilder"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateComponentInput`](crate::input::CreateComponentInput).
    pub fn builder() -> crate::input::create_component_input::Builder {
        crate::input::create_component_input::Builder::default()
    }
}

/// See [`CreateFormInput`](crate::input::CreateFormInput).
pub mod create_form_input {
    
    /// A builder for [`CreateFormInput`](crate::input::CreateFormInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_id: std::option::Option<std::string::String>,
        pub(crate) environment_name: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) form_to_create: std::option::Option<crate::model::CreateFormData>,
    }
    impl Builder {
        /// <p>The unique ID of the Amplify app to associate with the form.</p>
        pub fn app_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_id = Some(input.into());
            self
        }
        /// <p>The unique ID of the Amplify app to associate with the form.</p>
        pub fn set_app_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_id = input; self
        }
        /// <p>The name of the backend environment that is a part of the Amplify app.</p>
        pub fn environment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.environment_name = Some(input.into());
            self
        }
        /// <p>The name of the backend environment that is a part of the Amplify app.</p>
        pub fn set_environment_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.environment_name = input; self
        }
        /// <p>The unique client token.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>The unique client token.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// <p>Represents the configuration of the form to create.</p>
        pub fn form_to_create(mut self, input: crate::model::CreateFormData) -> Self {
            self.form_to_create = Some(input);
            self
        }
        /// <p>Represents the configuration of the form to create.</p>
        pub fn set_form_to_create(mut self, input: std::option::Option<crate::model::CreateFormData>) -> Self {
            self.form_to_create = input; self
        }
        /// Consumes the builder and constructs a [`CreateFormInput`](crate::input::CreateFormInput).
        pub fn build(self) -> Result<crate::input::CreateFormInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateFormInput {
                    app_id: self.app_id
                    ,
                    environment_name: self.environment_name
                    ,
                    client_token: self.client_token
                    ,
                    form_to_create: self.form_to_create
                    ,
                }
            )
        }
    }
    
    
}
impl CreateFormInput {
    /// Consumes the builder and constructs an Operation<[`CreateForm`](crate::operation::CreateForm)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateForm, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.client_token.is_none() {
                                self.client_token = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::input::CreateFormInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_4 = &_input.app_id;
                let input_4 = input_4.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))?;
                let app_id = aws_smithy_http::label::fmt_string(input_4, aws_smithy_http::label::EncodingStrategy::Default);
                if app_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))
                            }
                let input_5 = &_input.environment_name;
                let input_5 = input_5.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))?;
                let environment_name = aws_smithy_http::label::fmt_string(input_5, aws_smithy_http::label::EncodingStrategy::Default);
                if environment_name.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))
                            }
                write!(output, "/app/{appId}/environment/{environmentName}/forms", appId = app_id, environmentName = environment_name).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::CreateFormInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_6) = &_input.client_token {
                     {
                        query.push_kv("clientToken", &aws_smithy_http::query::fmt_string(&inner_6));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateFormInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_payload_create_form_input(& self.form_to_create)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateForm::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateForm", "amplifyuibuilder"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateFormInput`](crate::input::CreateFormInput).
    pub fn builder() -> crate::input::create_form_input::Builder {
        crate::input::create_form_input::Builder::default()
    }
}

/// See [`CreateThemeInput`](crate::input::CreateThemeInput).
pub mod create_theme_input {
    
    /// A builder for [`CreateThemeInput`](crate::input::CreateThemeInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_id: std::option::Option<std::string::String>,
        pub(crate) environment_name: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) theme_to_create: std::option::Option<crate::model::CreateThemeData>,
    }
    impl Builder {
        /// <p>The unique ID of the Amplify app associated with the theme.</p>
        pub fn app_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_id = Some(input.into());
            self
        }
        /// <p>The unique ID of the Amplify app associated with the theme.</p>
        pub fn set_app_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_id = input; self
        }
        /// <p>The name of the backend environment that is a part of the Amplify app.</p>
        pub fn environment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.environment_name = Some(input.into());
            self
        }
        /// <p>The name of the backend environment that is a part of the Amplify app.</p>
        pub fn set_environment_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.environment_name = input; self
        }
        /// <p>The unique client token.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>The unique client token.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// <p>Represents the configuration of the theme to create.</p>
        pub fn theme_to_create(mut self, input: crate::model::CreateThemeData) -> Self {
            self.theme_to_create = Some(input);
            self
        }
        /// <p>Represents the configuration of the theme to create.</p>
        pub fn set_theme_to_create(mut self, input: std::option::Option<crate::model::CreateThemeData>) -> Self {
            self.theme_to_create = input; self
        }
        /// Consumes the builder and constructs a [`CreateThemeInput`](crate::input::CreateThemeInput).
        pub fn build(self) -> Result<crate::input::CreateThemeInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateThemeInput {
                    app_id: self.app_id
                    ,
                    environment_name: self.environment_name
                    ,
                    client_token: self.client_token
                    ,
                    theme_to_create: self.theme_to_create
                    ,
                }
            )
        }
    }
    
    
}
impl CreateThemeInput {
    /// Consumes the builder and constructs an Operation<[`CreateTheme`](crate::operation::CreateTheme)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateTheme, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.client_token.is_none() {
                                self.client_token = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::input::CreateThemeInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_7 = &_input.app_id;
                let input_7 = input_7.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))?;
                let app_id = aws_smithy_http::label::fmt_string(input_7, aws_smithy_http::label::EncodingStrategy::Default);
                if app_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))
                            }
                let input_8 = &_input.environment_name;
                let input_8 = input_8.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))?;
                let environment_name = aws_smithy_http::label::fmt_string(input_8, aws_smithy_http::label::EncodingStrategy::Default);
                if environment_name.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))
                            }
                write!(output, "/app/{appId}/environment/{environmentName}/themes", appId = app_id, environmentName = environment_name).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::CreateThemeInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_9) = &_input.client_token {
                     {
                        query.push_kv("clientToken", &aws_smithy_http::query::fmt_string(&inner_9));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateThemeInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_payload_create_theme_input(& self.theme_to_create)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateTheme::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateTheme", "amplifyuibuilder"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateThemeInput`](crate::input::CreateThemeInput).
    pub fn builder() -> crate::input::create_theme_input::Builder {
        crate::input::create_theme_input::Builder::default()
    }
}

/// See [`DeleteComponentInput`](crate::input::DeleteComponentInput).
pub mod delete_component_input {
    
    /// A builder for [`DeleteComponentInput`](crate::input::DeleteComponentInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_id: std::option::Option<std::string::String>,
        pub(crate) environment_name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique ID of the Amplify app associated with the component to delete.</p>
        pub fn app_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_id = Some(input.into());
            self
        }
        /// <p>The unique ID of the Amplify app associated with the component to delete.</p>
        pub fn set_app_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_id = input; self
        }
        /// <p>The name of the backend environment that is a part of the Amplify app.</p>
        pub fn environment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.environment_name = Some(input.into());
            self
        }
        /// <p>The name of the backend environment that is a part of the Amplify app.</p>
        pub fn set_environment_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.environment_name = input; self
        }
        /// <p>The unique ID of the component to delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique ID of the component to delete.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// Consumes the builder and constructs a [`DeleteComponentInput`](crate::input::DeleteComponentInput).
        pub fn build(self) -> Result<crate::input::DeleteComponentInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteComponentInput {
                    app_id: self.app_id
                    ,
                    environment_name: self.environment_name
                    ,
                    id: self.id
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteComponentInput {
    /// Consumes the builder and constructs an Operation<[`DeleteComponent`](crate::operation::DeleteComponent)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteComponent, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteComponentInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_10 = &_input.app_id;
                let input_10 = input_10.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))?;
                let app_id = aws_smithy_http::label::fmt_string(input_10, aws_smithy_http::label::EncodingStrategy::Default);
                if app_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))
                            }
                let input_11 = &_input.environment_name;
                let input_11 = input_11.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))?;
                let environment_name = aws_smithy_http::label::fmt_string(input_11, aws_smithy_http::label::EncodingStrategy::Default);
                if environment_name.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))
                            }
                let input_12 = &_input.id;
                let input_12 = input_12.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))?;
                let id = aws_smithy_http::label::fmt_string(input_12, aws_smithy_http::label::EncodingStrategy::Default);
                if id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))
                            }
                write!(output, "/app/{appId}/environment/{environmentName}/components/{id}", appId = app_id, environmentName = environment_name, id = id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteComponentInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteComponent::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteComponent", "amplifyuibuilder"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteComponentInput`](crate::input::DeleteComponentInput).
    pub fn builder() -> crate::input::delete_component_input::Builder {
        crate::input::delete_component_input::Builder::default()
    }
}

/// See [`DeleteFormInput`](crate::input::DeleteFormInput).
pub mod delete_form_input {
    
    /// A builder for [`DeleteFormInput`](crate::input::DeleteFormInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_id: std::option::Option<std::string::String>,
        pub(crate) environment_name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique ID of the Amplify app associated with the form to delete.</p>
        pub fn app_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_id = Some(input.into());
            self
        }
        /// <p>The unique ID of the Amplify app associated with the form to delete.</p>
        pub fn set_app_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_id = input; self
        }
        /// <p>The name of the backend environment that is a part of the Amplify app.</p>
        pub fn environment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.environment_name = Some(input.into());
            self
        }
        /// <p>The name of the backend environment that is a part of the Amplify app.</p>
        pub fn set_environment_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.environment_name = input; self
        }
        /// <p>The unique ID of the form to delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique ID of the form to delete.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// Consumes the builder and constructs a [`DeleteFormInput`](crate::input::DeleteFormInput).
        pub fn build(self) -> Result<crate::input::DeleteFormInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteFormInput {
                    app_id: self.app_id
                    ,
                    environment_name: self.environment_name
                    ,
                    id: self.id
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteFormInput {
    /// Consumes the builder and constructs an Operation<[`DeleteForm`](crate::operation::DeleteForm)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteForm, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteFormInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_13 = &_input.app_id;
                let input_13 = input_13.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))?;
                let app_id = aws_smithy_http::label::fmt_string(input_13, aws_smithy_http::label::EncodingStrategy::Default);
                if app_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))
                            }
                let input_14 = &_input.environment_name;
                let input_14 = input_14.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))?;
                let environment_name = aws_smithy_http::label::fmt_string(input_14, aws_smithy_http::label::EncodingStrategy::Default);
                if environment_name.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))
                            }
                let input_15 = &_input.id;
                let input_15 = input_15.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))?;
                let id = aws_smithy_http::label::fmt_string(input_15, aws_smithy_http::label::EncodingStrategy::Default);
                if id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))
                            }
                write!(output, "/app/{appId}/environment/{environmentName}/forms/{id}", appId = app_id, environmentName = environment_name, id = id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteFormInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteForm::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteForm", "amplifyuibuilder"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteFormInput`](crate::input::DeleteFormInput).
    pub fn builder() -> crate::input::delete_form_input::Builder {
        crate::input::delete_form_input::Builder::default()
    }
}

/// See [`DeleteThemeInput`](crate::input::DeleteThemeInput).
pub mod delete_theme_input {
    
    /// A builder for [`DeleteThemeInput`](crate::input::DeleteThemeInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_id: std::option::Option<std::string::String>,
        pub(crate) environment_name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique ID of the Amplify app associated with the theme to delete.</p>
        pub fn app_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_id = Some(input.into());
            self
        }
        /// <p>The unique ID of the Amplify app associated with the theme to delete.</p>
        pub fn set_app_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_id = input; self
        }
        /// <p>The name of the backend environment that is a part of the Amplify app.</p>
        pub fn environment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.environment_name = Some(input.into());
            self
        }
        /// <p>The name of the backend environment that is a part of the Amplify app.</p>
        pub fn set_environment_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.environment_name = input; self
        }
        /// <p>The unique ID of the theme to delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique ID of the theme to delete.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// Consumes the builder and constructs a [`DeleteThemeInput`](crate::input::DeleteThemeInput).
        pub fn build(self) -> Result<crate::input::DeleteThemeInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteThemeInput {
                    app_id: self.app_id
                    ,
                    environment_name: self.environment_name
                    ,
                    id: self.id
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteThemeInput {
    /// Consumes the builder and constructs an Operation<[`DeleteTheme`](crate::operation::DeleteTheme)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteTheme, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteThemeInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_16 = &_input.app_id;
                let input_16 = input_16.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))?;
                let app_id = aws_smithy_http::label::fmt_string(input_16, aws_smithy_http::label::EncodingStrategy::Default);
                if app_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))
                            }
                let input_17 = &_input.environment_name;
                let input_17 = input_17.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))?;
                let environment_name = aws_smithy_http::label::fmt_string(input_17, aws_smithy_http::label::EncodingStrategy::Default);
                if environment_name.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))
                            }
                let input_18 = &_input.id;
                let input_18 = input_18.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))?;
                let id = aws_smithy_http::label::fmt_string(input_18, aws_smithy_http::label::EncodingStrategy::Default);
                if id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))
                            }
                write!(output, "/app/{appId}/environment/{environmentName}/themes/{id}", appId = app_id, environmentName = environment_name, id = id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteThemeInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteTheme::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteTheme", "amplifyuibuilder"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteThemeInput`](crate::input::DeleteThemeInput).
    pub fn builder() -> crate::input::delete_theme_input::Builder {
        crate::input::delete_theme_input::Builder::default()
    }
}

/// See [`ExchangeCodeForTokenInput`](crate::input::ExchangeCodeForTokenInput).
pub mod exchange_code_for_token_input {
    
    /// A builder for [`ExchangeCodeForTokenInput`](crate::input::ExchangeCodeForTokenInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) provider: std::option::Option<crate::model::TokenProviders>,
        pub(crate) request: std::option::Option<crate::model::ExchangeCodeForTokenRequestBody>,
    }
    impl Builder {
        /// <p>The third-party provider for the token. The only valid value is <code>figma</code>.</p>
        pub fn provider(mut self, input: crate::model::TokenProviders) -> Self {
            self.provider = Some(input);
            self
        }
        /// <p>The third-party provider for the token. The only valid value is <code>figma</code>.</p>
        pub fn set_provider(mut self, input: std::option::Option<crate::model::TokenProviders>) -> Self {
            self.provider = input; self
        }
        /// <p>Describes the configuration of the request.</p>
        pub fn request(mut self, input: crate::model::ExchangeCodeForTokenRequestBody) -> Self {
            self.request = Some(input);
            self
        }
        /// <p>Describes the configuration of the request.</p>
        pub fn set_request(mut self, input: std::option::Option<crate::model::ExchangeCodeForTokenRequestBody>) -> Self {
            self.request = input; self
        }
        /// Consumes the builder and constructs a [`ExchangeCodeForTokenInput`](crate::input::ExchangeCodeForTokenInput).
        pub fn build(self) -> Result<crate::input::ExchangeCodeForTokenInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ExchangeCodeForTokenInput {
                    provider: self.provider
                    ,
                    request: self.request
                    ,
                }
            )
        }
    }
    
    
}
impl ExchangeCodeForTokenInput {
    /// Consumes the builder and constructs an Operation<[`ExchangeCodeForToken`](crate::operation::ExchangeCodeForToken)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ExchangeCodeForToken, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ExchangeCodeForTokenInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_19 = &_input.provider;
                let input_19 = input_19.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("provider", "cannot be empty or unset"))?;
                let provider = aws_smithy_http::label::fmt_string(input_19, aws_smithy_http::label::EncodingStrategy::Default);
                if provider.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("provider", "cannot be empty or unset"))
                            }
                write!(output, "/tokens/{provider}", provider = provider).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ExchangeCodeForTokenInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_payload_exchange_code_for_token_input(& self.request)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ExchangeCodeForToken::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ExchangeCodeForToken", "amplifyuibuilder"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ExchangeCodeForTokenInput`](crate::input::ExchangeCodeForTokenInput).
    pub fn builder() -> crate::input::exchange_code_for_token_input::Builder {
        crate::input::exchange_code_for_token_input::Builder::default()
    }
}

/// See [`ExportComponentsInput`](crate::input::ExportComponentsInput).
pub mod export_components_input {
    
    /// A builder for [`ExportComponentsInput`](crate::input::ExportComponentsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_id: std::option::Option<std::string::String>,
        pub(crate) environment_name: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique ID of the Amplify app to export components to.</p>
        pub fn app_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_id = Some(input.into());
            self
        }
        /// <p>The unique ID of the Amplify app to export components to.</p>
        pub fn set_app_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_id = input; self
        }
        /// <p>The name of the backend environment that is a part of the Amplify app.</p>
        pub fn environment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.environment_name = Some(input.into());
            self
        }
        /// <p>The name of the backend environment that is a part of the Amplify app.</p>
        pub fn set_environment_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.environment_name = input; self
        }
        /// <p>The token to request the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to request the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`ExportComponentsInput`](crate::input::ExportComponentsInput).
        pub fn build(self) -> Result<crate::input::ExportComponentsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ExportComponentsInput {
                    app_id: self.app_id
                    ,
                    environment_name: self.environment_name
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl ExportComponentsInput {
    /// Consumes the builder and constructs an Operation<[`ExportComponents`](crate::operation::ExportComponents)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ExportComponents, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ExportComponentsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_20 = &_input.app_id;
                let input_20 = input_20.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))?;
                let app_id = aws_smithy_http::label::fmt_string(input_20, aws_smithy_http::label::EncodingStrategy::Default);
                if app_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))
                            }
                let input_21 = &_input.environment_name;
                let input_21 = input_21.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))?;
                let environment_name = aws_smithy_http::label::fmt_string(input_21, aws_smithy_http::label::EncodingStrategy::Default);
                if environment_name.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))
                            }
                write!(output, "/export/app/{appId}/environment/{environmentName}/components", appId = app_id, environmentName = environment_name).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ExportComponentsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_22) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_22));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ExportComponentsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ExportComponents::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ExportComponents", "amplifyuibuilder"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ExportComponentsInput`](crate::input::ExportComponentsInput).
    pub fn builder() -> crate::input::export_components_input::Builder {
        crate::input::export_components_input::Builder::default()
    }
}

/// See [`ExportFormsInput`](crate::input::ExportFormsInput).
pub mod export_forms_input {
    
    /// A builder for [`ExportFormsInput`](crate::input::ExportFormsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_id: std::option::Option<std::string::String>,
        pub(crate) environment_name: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique ID of the Amplify app to export forms to.</p>
        pub fn app_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_id = Some(input.into());
            self
        }
        /// <p>The unique ID of the Amplify app to export forms to.</p>
        pub fn set_app_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_id = input; self
        }
        /// <p>The name of the backend environment that is a part of the Amplify app.</p>
        pub fn environment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.environment_name = Some(input.into());
            self
        }
        /// <p>The name of the backend environment that is a part of the Amplify app.</p>
        pub fn set_environment_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.environment_name = input; self
        }
        /// <p>The token to request the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to request the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`ExportFormsInput`](crate::input::ExportFormsInput).
        pub fn build(self) -> Result<crate::input::ExportFormsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ExportFormsInput {
                    app_id: self.app_id
                    ,
                    environment_name: self.environment_name
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl ExportFormsInput {
    /// Consumes the builder and constructs an Operation<[`ExportForms`](crate::operation::ExportForms)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ExportForms, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ExportFormsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_23 = &_input.app_id;
                let input_23 = input_23.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))?;
                let app_id = aws_smithy_http::label::fmt_string(input_23, aws_smithy_http::label::EncodingStrategy::Default);
                if app_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))
                            }
                let input_24 = &_input.environment_name;
                let input_24 = input_24.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))?;
                let environment_name = aws_smithy_http::label::fmt_string(input_24, aws_smithy_http::label::EncodingStrategy::Default);
                if environment_name.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))
                            }
                write!(output, "/export/app/{appId}/environment/{environmentName}/forms", appId = app_id, environmentName = environment_name).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ExportFormsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_25) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_25));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ExportFormsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ExportForms::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ExportForms", "amplifyuibuilder"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ExportFormsInput`](crate::input::ExportFormsInput).
    pub fn builder() -> crate::input::export_forms_input::Builder {
        crate::input::export_forms_input::Builder::default()
    }
}

/// See [`ExportThemesInput`](crate::input::ExportThemesInput).
pub mod export_themes_input {
    
    /// A builder for [`ExportThemesInput`](crate::input::ExportThemesInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_id: std::option::Option<std::string::String>,
        pub(crate) environment_name: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique ID of the Amplify app to export the themes to.</p>
        pub fn app_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_id = Some(input.into());
            self
        }
        /// <p>The unique ID of the Amplify app to export the themes to.</p>
        pub fn set_app_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_id = input; self
        }
        /// <p>The name of the backend environment that is part of the Amplify app.</p>
        pub fn environment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.environment_name = Some(input.into());
            self
        }
        /// <p>The name of the backend environment that is part of the Amplify app.</p>
        pub fn set_environment_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.environment_name = input; self
        }
        /// <p>The token to request the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to request the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`ExportThemesInput`](crate::input::ExportThemesInput).
        pub fn build(self) -> Result<crate::input::ExportThemesInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ExportThemesInput {
                    app_id: self.app_id
                    ,
                    environment_name: self.environment_name
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl ExportThemesInput {
    /// Consumes the builder and constructs an Operation<[`ExportThemes`](crate::operation::ExportThemes)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ExportThemes, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ExportThemesInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_26 = &_input.app_id;
                let input_26 = input_26.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))?;
                let app_id = aws_smithy_http::label::fmt_string(input_26, aws_smithy_http::label::EncodingStrategy::Default);
                if app_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))
                            }
                let input_27 = &_input.environment_name;
                let input_27 = input_27.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))?;
                let environment_name = aws_smithy_http::label::fmt_string(input_27, aws_smithy_http::label::EncodingStrategy::Default);
                if environment_name.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))
                            }
                write!(output, "/export/app/{appId}/environment/{environmentName}/themes", appId = app_id, environmentName = environment_name).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ExportThemesInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_28) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_28));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ExportThemesInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ExportThemes::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ExportThemes", "amplifyuibuilder"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ExportThemesInput`](crate::input::ExportThemesInput).
    pub fn builder() -> crate::input::export_themes_input::Builder {
        crate::input::export_themes_input::Builder::default()
    }
}

/// See [`GetComponentInput`](crate::input::GetComponentInput).
pub mod get_component_input {
    
    /// A builder for [`GetComponentInput`](crate::input::GetComponentInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_id: std::option::Option<std::string::String>,
        pub(crate) environment_name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique ID of the Amplify app.</p>
        pub fn app_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_id = Some(input.into());
            self
        }
        /// <p>The unique ID of the Amplify app.</p>
        pub fn set_app_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_id = input; self
        }
        /// <p>The name of the backend environment that is part of the Amplify app.</p>
        pub fn environment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.environment_name = Some(input.into());
            self
        }
        /// <p>The name of the backend environment that is part of the Amplify app.</p>
        pub fn set_environment_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.environment_name = input; self
        }
        /// <p>The unique ID of the component.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique ID of the component.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// Consumes the builder and constructs a [`GetComponentInput`](crate::input::GetComponentInput).
        pub fn build(self) -> Result<crate::input::GetComponentInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetComponentInput {
                    app_id: self.app_id
                    ,
                    environment_name: self.environment_name
                    ,
                    id: self.id
                    ,
                }
            )
        }
    }
    
    
}
impl GetComponentInput {
    /// Consumes the builder and constructs an Operation<[`GetComponent`](crate::operation::GetComponent)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetComponent, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetComponentInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_29 = &_input.app_id;
                let input_29 = input_29.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))?;
                let app_id = aws_smithy_http::label::fmt_string(input_29, aws_smithy_http::label::EncodingStrategy::Default);
                if app_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))
                            }
                let input_30 = &_input.environment_name;
                let input_30 = input_30.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))?;
                let environment_name = aws_smithy_http::label::fmt_string(input_30, aws_smithy_http::label::EncodingStrategy::Default);
                if environment_name.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))
                            }
                let input_31 = &_input.id;
                let input_31 = input_31.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))?;
                let id = aws_smithy_http::label::fmt_string(input_31, aws_smithy_http::label::EncodingStrategy::Default);
                if id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))
                            }
                write!(output, "/app/{appId}/environment/{environmentName}/components/{id}", appId = app_id, environmentName = environment_name, id = id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetComponentInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetComponent::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetComponent", "amplifyuibuilder"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetComponentInput`](crate::input::GetComponentInput).
    pub fn builder() -> crate::input::get_component_input::Builder {
        crate::input::get_component_input::Builder::default()
    }
}

/// See [`GetFormInput`](crate::input::GetFormInput).
pub mod get_form_input {
    
    /// A builder for [`GetFormInput`](crate::input::GetFormInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_id: std::option::Option<std::string::String>,
        pub(crate) environment_name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique ID of the Amplify app.</p>
        pub fn app_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_id = Some(input.into());
            self
        }
        /// <p>The unique ID of the Amplify app.</p>
        pub fn set_app_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_id = input; self
        }
        /// <p>The name of the backend environment that is part of the Amplify app.</p>
        pub fn environment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.environment_name = Some(input.into());
            self
        }
        /// <p>The name of the backend environment that is part of the Amplify app.</p>
        pub fn set_environment_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.environment_name = input; self
        }
        /// <p>The unique ID of the form.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique ID of the form.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// Consumes the builder and constructs a [`GetFormInput`](crate::input::GetFormInput).
        pub fn build(self) -> Result<crate::input::GetFormInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetFormInput {
                    app_id: self.app_id
                    ,
                    environment_name: self.environment_name
                    ,
                    id: self.id
                    ,
                }
            )
        }
    }
    
    
}
impl GetFormInput {
    /// Consumes the builder and constructs an Operation<[`GetForm`](crate::operation::GetForm)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetForm, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetFormInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_32 = &_input.app_id;
                let input_32 = input_32.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))?;
                let app_id = aws_smithy_http::label::fmt_string(input_32, aws_smithy_http::label::EncodingStrategy::Default);
                if app_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))
                            }
                let input_33 = &_input.environment_name;
                let input_33 = input_33.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))?;
                let environment_name = aws_smithy_http::label::fmt_string(input_33, aws_smithy_http::label::EncodingStrategy::Default);
                if environment_name.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))
                            }
                let input_34 = &_input.id;
                let input_34 = input_34.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))?;
                let id = aws_smithy_http::label::fmt_string(input_34, aws_smithy_http::label::EncodingStrategy::Default);
                if id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))
                            }
                write!(output, "/app/{appId}/environment/{environmentName}/forms/{id}", appId = app_id, environmentName = environment_name, id = id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetFormInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetForm::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetForm", "amplifyuibuilder"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetFormInput`](crate::input::GetFormInput).
    pub fn builder() -> crate::input::get_form_input::Builder {
        crate::input::get_form_input::Builder::default()
    }
}

/// See [`GetMetadataInput`](crate::input::GetMetadataInput).
pub mod get_metadata_input {
    
    /// A builder for [`GetMetadataInput`](crate::input::GetMetadataInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_id: std::option::Option<std::string::String>,
        pub(crate) environment_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique ID of the Amplify app.</p>
        pub fn app_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_id = Some(input.into());
            self
        }
        /// <p>The unique ID of the Amplify app.</p>
        pub fn set_app_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_id = input; self
        }
        /// <p>The name of the backend environment that is part of the Amplify app.</p>
        pub fn environment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.environment_name = Some(input.into());
            self
        }
        /// <p>The name of the backend environment that is part of the Amplify app.</p>
        pub fn set_environment_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.environment_name = input; self
        }
        /// Consumes the builder and constructs a [`GetMetadataInput`](crate::input::GetMetadataInput).
        pub fn build(self) -> Result<crate::input::GetMetadataInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetMetadataInput {
                    app_id: self.app_id
                    ,
                    environment_name: self.environment_name
                    ,
                }
            )
        }
    }
    
    
}
impl GetMetadataInput {
    /// Consumes the builder and constructs an Operation<[`GetMetadata`](crate::operation::GetMetadata)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetMetadata, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetMetadataInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_35 = &_input.app_id;
                let input_35 = input_35.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))?;
                let app_id = aws_smithy_http::label::fmt_string(input_35, aws_smithy_http::label::EncodingStrategy::Default);
                if app_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))
                            }
                let input_36 = &_input.environment_name;
                let input_36 = input_36.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))?;
                let environment_name = aws_smithy_http::label::fmt_string(input_36, aws_smithy_http::label::EncodingStrategy::Default);
                if environment_name.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))
                            }
                write!(output, "/app/{appId}/environment/{environmentName}/metadata", appId = app_id, environmentName = environment_name).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetMetadataInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetMetadata::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetMetadata", "amplifyuibuilder"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetMetadataInput`](crate::input::GetMetadataInput).
    pub fn builder() -> crate::input::get_metadata_input::Builder {
        crate::input::get_metadata_input::Builder::default()
    }
}

/// See [`GetThemeInput`](crate::input::GetThemeInput).
pub mod get_theme_input {
    
    /// A builder for [`GetThemeInput`](crate::input::GetThemeInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_id: std::option::Option<std::string::String>,
        pub(crate) environment_name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique ID of the Amplify app.</p>
        pub fn app_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_id = Some(input.into());
            self
        }
        /// <p>The unique ID of the Amplify app.</p>
        pub fn set_app_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_id = input; self
        }
        /// <p>The name of the backend environment that is part of the Amplify app.</p>
        pub fn environment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.environment_name = Some(input.into());
            self
        }
        /// <p>The name of the backend environment that is part of the Amplify app.</p>
        pub fn set_environment_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.environment_name = input; self
        }
        /// <p>The unique ID for the theme.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique ID for the theme.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// Consumes the builder and constructs a [`GetThemeInput`](crate::input::GetThemeInput).
        pub fn build(self) -> Result<crate::input::GetThemeInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetThemeInput {
                    app_id: self.app_id
                    ,
                    environment_name: self.environment_name
                    ,
                    id: self.id
                    ,
                }
            )
        }
    }
    
    
}
impl GetThemeInput {
    /// Consumes the builder and constructs an Operation<[`GetTheme`](crate::operation::GetTheme)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetTheme, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetThemeInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_37 = &_input.app_id;
                let input_37 = input_37.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))?;
                let app_id = aws_smithy_http::label::fmt_string(input_37, aws_smithy_http::label::EncodingStrategy::Default);
                if app_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))
                            }
                let input_38 = &_input.environment_name;
                let input_38 = input_38.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))?;
                let environment_name = aws_smithy_http::label::fmt_string(input_38, aws_smithy_http::label::EncodingStrategy::Default);
                if environment_name.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))
                            }
                let input_39 = &_input.id;
                let input_39 = input_39.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))?;
                let id = aws_smithy_http::label::fmt_string(input_39, aws_smithy_http::label::EncodingStrategy::Default);
                if id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))
                            }
                write!(output, "/app/{appId}/environment/{environmentName}/themes/{id}", appId = app_id, environmentName = environment_name, id = id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetThemeInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetTheme::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetTheme", "amplifyuibuilder"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetThemeInput`](crate::input::GetThemeInput).
    pub fn builder() -> crate::input::get_theme_input::Builder {
        crate::input::get_theme_input::Builder::default()
    }
}

/// See [`ListComponentsInput`](crate::input::ListComponentsInput).
pub mod list_components_input {
    
    /// A builder for [`ListComponentsInput`](crate::input::ListComponentsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_id: std::option::Option<std::string::String>,
        pub(crate) environment_name: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The unique ID for the Amplify app.</p>
        pub fn app_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_id = Some(input.into());
            self
        }
        /// <p>The unique ID for the Amplify app.</p>
        pub fn set_app_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_id = input; self
        }
        /// <p>The name of the backend environment that is a part of the Amplify app.</p>
        pub fn environment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.environment_name = Some(input.into());
            self
        }
        /// <p>The name of the backend environment that is a part of the Amplify app.</p>
        pub fn set_environment_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.environment_name = input; self
        }
        /// <p>The token to request the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to request the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>The maximum number of components to retrieve.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of components to retrieve.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`ListComponentsInput`](crate::input::ListComponentsInput).
        pub fn build(self) -> Result<crate::input::ListComponentsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListComponentsInput {
                    app_id: self.app_id
                    ,
                    environment_name: self.environment_name
                    ,
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                        .unwrap_or_default()
                    ,
                }
            )
        }
    }
    
    
}
impl ListComponentsInput {
    /// Consumes the builder and constructs an Operation<[`ListComponents`](crate::operation::ListComponents)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListComponents, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListComponentsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_40 = &_input.app_id;
                let input_40 = input_40.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))?;
                let app_id = aws_smithy_http::label::fmt_string(input_40, aws_smithy_http::label::EncodingStrategy::Default);
                if app_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))
                            }
                let input_41 = &_input.environment_name;
                let input_41 = input_41.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))?;
                let environment_name = aws_smithy_http::label::fmt_string(input_41, aws_smithy_http::label::EncodingStrategy::Default);
                if environment_name.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))
                            }
                write!(output, "/app/{appId}/environment/{environmentName}/components", appId = app_id, environmentName = environment_name).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListComponentsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_42) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_42));
                    }
                }
                if _input.max_results != 0 {
                    query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(_input.max_results).encode());
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListComponentsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListComponents::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListComponents", "amplifyuibuilder"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListComponentsInput`](crate::input::ListComponentsInput).
    pub fn builder() -> crate::input::list_components_input::Builder {
        crate::input::list_components_input::Builder::default()
    }
}

/// See [`ListFormsInput`](crate::input::ListFormsInput).
pub mod list_forms_input {
    
    /// A builder for [`ListFormsInput`](crate::input::ListFormsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_id: std::option::Option<std::string::String>,
        pub(crate) environment_name: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The unique ID for the Amplify app.</p>
        pub fn app_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_id = Some(input.into());
            self
        }
        /// <p>The unique ID for the Amplify app.</p>
        pub fn set_app_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_id = input; self
        }
        /// <p>The name of the backend environment that is a part of the Amplify app.</p>
        pub fn environment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.environment_name = Some(input.into());
            self
        }
        /// <p>The name of the backend environment that is a part of the Amplify app.</p>
        pub fn set_environment_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.environment_name = input; self
        }
        /// <p>The token to request the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to request the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>The maximum number of forms to retrieve.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of forms to retrieve.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`ListFormsInput`](crate::input::ListFormsInput).
        pub fn build(self) -> Result<crate::input::ListFormsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListFormsInput {
                    app_id: self.app_id
                    ,
                    environment_name: self.environment_name
                    ,
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                        .unwrap_or_default()
                    ,
                }
            )
        }
    }
    
    
}
impl ListFormsInput {
    /// Consumes the builder and constructs an Operation<[`ListForms`](crate::operation::ListForms)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListForms, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListFormsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_43 = &_input.app_id;
                let input_43 = input_43.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))?;
                let app_id = aws_smithy_http::label::fmt_string(input_43, aws_smithy_http::label::EncodingStrategy::Default);
                if app_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))
                            }
                let input_44 = &_input.environment_name;
                let input_44 = input_44.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))?;
                let environment_name = aws_smithy_http::label::fmt_string(input_44, aws_smithy_http::label::EncodingStrategy::Default);
                if environment_name.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))
                            }
                write!(output, "/app/{appId}/environment/{environmentName}/forms", appId = app_id, environmentName = environment_name).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListFormsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_45) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_45));
                    }
                }
                if _input.max_results != 0 {
                    query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(_input.max_results).encode());
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListFormsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListForms::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListForms", "amplifyuibuilder"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListFormsInput`](crate::input::ListFormsInput).
    pub fn builder() -> crate::input::list_forms_input::Builder {
        crate::input::list_forms_input::Builder::default()
    }
}

/// See [`ListThemesInput`](crate::input::ListThemesInput).
pub mod list_themes_input {
    
    /// A builder for [`ListThemesInput`](crate::input::ListThemesInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_id: std::option::Option<std::string::String>,
        pub(crate) environment_name: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The unique ID for the Amplify app.</p>
        pub fn app_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_id = Some(input.into());
            self
        }
        /// <p>The unique ID for the Amplify app.</p>
        pub fn set_app_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_id = input; self
        }
        /// <p>The name of the backend environment that is a part of the Amplify app.</p>
        pub fn environment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.environment_name = Some(input.into());
            self
        }
        /// <p>The name of the backend environment that is a part of the Amplify app.</p>
        pub fn set_environment_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.environment_name = input; self
        }
        /// <p>The token to request the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to request the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>The maximum number of theme results to return in the response.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of theme results to return in the response.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`ListThemesInput`](crate::input::ListThemesInput).
        pub fn build(self) -> Result<crate::input::ListThemesInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListThemesInput {
                    app_id: self.app_id
                    ,
                    environment_name: self.environment_name
                    ,
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                        .unwrap_or_default()
                    ,
                }
            )
        }
    }
    
    
}
impl ListThemesInput {
    /// Consumes the builder and constructs an Operation<[`ListThemes`](crate::operation::ListThemes)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListThemes, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListThemesInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_46 = &_input.app_id;
                let input_46 = input_46.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))?;
                let app_id = aws_smithy_http::label::fmt_string(input_46, aws_smithy_http::label::EncodingStrategy::Default);
                if app_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))
                            }
                let input_47 = &_input.environment_name;
                let input_47 = input_47.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))?;
                let environment_name = aws_smithy_http::label::fmt_string(input_47, aws_smithy_http::label::EncodingStrategy::Default);
                if environment_name.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))
                            }
                write!(output, "/app/{appId}/environment/{environmentName}/themes", appId = app_id, environmentName = environment_name).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListThemesInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_48) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_48));
                    }
                }
                if _input.max_results != 0 {
                    query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(_input.max_results).encode());
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListThemesInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListThemes::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListThemes", "amplifyuibuilder"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListThemesInput`](crate::input::ListThemesInput).
    pub fn builder() -> crate::input::list_themes_input::Builder {
        crate::input::list_themes_input::Builder::default()
    }
}

/// See [`PutMetadataFlagInput`](crate::input::PutMetadataFlagInput).
pub mod put_metadata_flag_input {
    
    /// A builder for [`PutMetadataFlagInput`](crate::input::PutMetadataFlagInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_id: std::option::Option<std::string::String>,
        pub(crate) environment_name: std::option::Option<std::string::String>,
        pub(crate) feature_name: std::option::Option<std::string::String>,
        pub(crate) body: std::option::Option<crate::model::PutMetadataFlagBody>,
    }
    impl Builder {
        /// <p>The unique ID for the Amplify app.</p>
        pub fn app_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_id = Some(input.into());
            self
        }
        /// <p>The unique ID for the Amplify app.</p>
        pub fn set_app_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_id = input; self
        }
        /// <p>The name of the backend environment that is part of the Amplify app.</p>
        pub fn environment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.environment_name = Some(input.into());
            self
        }
        /// <p>The name of the backend environment that is part of the Amplify app.</p>
        pub fn set_environment_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.environment_name = input; self
        }
        /// <p>The name of the feature associated with the metadata.</p>
        pub fn feature_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.feature_name = Some(input.into());
            self
        }
        /// <p>The name of the feature associated with the metadata.</p>
        pub fn set_feature_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.feature_name = input; self
        }
        /// <p>The metadata information to store.</p>
        pub fn body(mut self, input: crate::model::PutMetadataFlagBody) -> Self {
            self.body = Some(input);
            self
        }
        /// <p>The metadata information to store.</p>
        pub fn set_body(mut self, input: std::option::Option<crate::model::PutMetadataFlagBody>) -> Self {
            self.body = input; self
        }
        /// Consumes the builder and constructs a [`PutMetadataFlagInput`](crate::input::PutMetadataFlagInput).
        pub fn build(self) -> Result<crate::input::PutMetadataFlagInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::PutMetadataFlagInput {
                    app_id: self.app_id
                    ,
                    environment_name: self.environment_name
                    ,
                    feature_name: self.feature_name
                    ,
                    body: self.body
                    ,
                }
            )
        }
    }
    
    
}
impl PutMetadataFlagInput {
    /// Consumes the builder and constructs an Operation<[`PutMetadataFlag`](crate::operation::PutMetadataFlag)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::PutMetadataFlag, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::PutMetadataFlagInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_49 = &_input.app_id;
                let input_49 = input_49.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))?;
                let app_id = aws_smithy_http::label::fmt_string(input_49, aws_smithy_http::label::EncodingStrategy::Default);
                if app_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))
                            }
                let input_50 = &_input.environment_name;
                let input_50 = input_50.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))?;
                let environment_name = aws_smithy_http::label::fmt_string(input_50, aws_smithy_http::label::EncodingStrategy::Default);
                if environment_name.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))
                            }
                let input_51 = &_input.feature_name;
                let input_51 = input_51.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("feature_name", "cannot be empty or unset"))?;
                let feature_name = aws_smithy_http::label::fmt_string(input_51, aws_smithy_http::label::EncodingStrategy::Default);
                if feature_name.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("feature_name", "cannot be empty or unset"))
                            }
                write!(output, "/app/{appId}/environment/{environmentName}/metadata/features/{featureName}", appId = app_id, environmentName = environment_name, featureName = feature_name).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::PutMetadataFlagInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_payload_put_metadata_flag_input(& self.body)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::PutMetadataFlag::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("PutMetadataFlag", "amplifyuibuilder"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`PutMetadataFlagInput`](crate::input::PutMetadataFlagInput).
    pub fn builder() -> crate::input::put_metadata_flag_input::Builder {
        crate::input::put_metadata_flag_input::Builder::default()
    }
}

/// See [`RefreshTokenInput`](crate::input::RefreshTokenInput).
pub mod refresh_token_input {
    
    /// A builder for [`RefreshTokenInput`](crate::input::RefreshTokenInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) provider: std::option::Option<crate::model::TokenProviders>,
        pub(crate) refresh_token_body: std::option::Option<crate::model::RefreshTokenRequestBody>,
    }
    impl Builder {
        /// <p>The third-party provider for the token. The only valid value is <code>figma</code>.</p>
        pub fn provider(mut self, input: crate::model::TokenProviders) -> Self {
            self.provider = Some(input);
            self
        }
        /// <p>The third-party provider for the token. The only valid value is <code>figma</code>.</p>
        pub fn set_provider(mut self, input: std::option::Option<crate::model::TokenProviders>) -> Self {
            self.provider = input; self
        }
        /// <p>Information about the refresh token request.</p>
        pub fn refresh_token_body(mut self, input: crate::model::RefreshTokenRequestBody) -> Self {
            self.refresh_token_body = Some(input);
            self
        }
        /// <p>Information about the refresh token request.</p>
        pub fn set_refresh_token_body(mut self, input: std::option::Option<crate::model::RefreshTokenRequestBody>) -> Self {
            self.refresh_token_body = input; self
        }
        /// Consumes the builder and constructs a [`RefreshTokenInput`](crate::input::RefreshTokenInput).
        pub fn build(self) -> Result<crate::input::RefreshTokenInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::RefreshTokenInput {
                    provider: self.provider
                    ,
                    refresh_token_body: self.refresh_token_body
                    ,
                }
            )
        }
    }
    
    
}
impl RefreshTokenInput {
    /// Consumes the builder and constructs an Operation<[`RefreshToken`](crate::operation::RefreshToken)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::RefreshToken, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::RefreshTokenInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_52 = &_input.provider;
                let input_52 = input_52.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("provider", "cannot be empty or unset"))?;
                let provider = aws_smithy_http::label::fmt_string(input_52, aws_smithy_http::label::EncodingStrategy::Default);
                if provider.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("provider", "cannot be empty or unset"))
                            }
                write!(output, "/tokens/{provider}/refresh", provider = provider).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::RefreshTokenInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_payload_refresh_token_input(& self.refresh_token_body)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::RefreshToken::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("RefreshToken", "amplifyuibuilder"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`RefreshTokenInput`](crate::input::RefreshTokenInput).
    pub fn builder() -> crate::input::refresh_token_input::Builder {
        crate::input::refresh_token_input::Builder::default()
    }
}

/// See [`UpdateComponentInput`](crate::input::UpdateComponentInput).
pub mod update_component_input {
    
    /// A builder for [`UpdateComponentInput`](crate::input::UpdateComponentInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_id: std::option::Option<std::string::String>,
        pub(crate) environment_name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) updated_component: std::option::Option<crate::model::UpdateComponentData>,
    }
    impl Builder {
        /// <p>The unique ID for the Amplify app.</p>
        pub fn app_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_id = Some(input.into());
            self
        }
        /// <p>The unique ID for the Amplify app.</p>
        pub fn set_app_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_id = input; self
        }
        /// <p>The name of the backend environment that is part of the Amplify app.</p>
        pub fn environment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.environment_name = Some(input.into());
            self
        }
        /// <p>The name of the backend environment that is part of the Amplify app.</p>
        pub fn set_environment_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.environment_name = input; self
        }
        /// <p>The unique ID for the component.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique ID for the component.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// <p>The unique client token.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>The unique client token.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// <p>The configuration of the updated component.</p>
        pub fn updated_component(mut self, input: crate::model::UpdateComponentData) -> Self {
            self.updated_component = Some(input);
            self
        }
        /// <p>The configuration of the updated component.</p>
        pub fn set_updated_component(mut self, input: std::option::Option<crate::model::UpdateComponentData>) -> Self {
            self.updated_component = input; self
        }
        /// Consumes the builder and constructs a [`UpdateComponentInput`](crate::input::UpdateComponentInput).
        pub fn build(self) -> Result<crate::input::UpdateComponentInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateComponentInput {
                    app_id: self.app_id
                    ,
                    environment_name: self.environment_name
                    ,
                    id: self.id
                    ,
                    client_token: self.client_token
                    ,
                    updated_component: self.updated_component
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateComponentInput {
    /// Consumes the builder and constructs an Operation<[`UpdateComponent`](crate::operation::UpdateComponent)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateComponent, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.client_token.is_none() {
                                self.client_token = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateComponentInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_53 = &_input.app_id;
                let input_53 = input_53.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))?;
                let app_id = aws_smithy_http::label::fmt_string(input_53, aws_smithy_http::label::EncodingStrategy::Default);
                if app_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))
                            }
                let input_54 = &_input.environment_name;
                let input_54 = input_54.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))?;
                let environment_name = aws_smithy_http::label::fmt_string(input_54, aws_smithy_http::label::EncodingStrategy::Default);
                if environment_name.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))
                            }
                let input_55 = &_input.id;
                let input_55 = input_55.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))?;
                let id = aws_smithy_http::label::fmt_string(input_55, aws_smithy_http::label::EncodingStrategy::Default);
                if id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))
                            }
                write!(output, "/app/{appId}/environment/{environmentName}/components/{id}", appId = app_id, environmentName = environment_name, id = id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::UpdateComponentInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_56) = &_input.client_token {
                     {
                        query.push_kv("clientToken", &aws_smithy_http::query::fmt_string(&inner_56));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateComponentInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_payload_update_component_input(& self.updated_component)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateComponent::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateComponent", "amplifyuibuilder"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateComponentInput`](crate::input::UpdateComponentInput).
    pub fn builder() -> crate::input::update_component_input::Builder {
        crate::input::update_component_input::Builder::default()
    }
}

/// See [`UpdateFormInput`](crate::input::UpdateFormInput).
pub mod update_form_input {
    
    /// A builder for [`UpdateFormInput`](crate::input::UpdateFormInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_id: std::option::Option<std::string::String>,
        pub(crate) environment_name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) updated_form: std::option::Option<crate::model::UpdateFormData>,
    }
    impl Builder {
        /// <p>The unique ID for the Amplify app.</p>
        pub fn app_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_id = Some(input.into());
            self
        }
        /// <p>The unique ID for the Amplify app.</p>
        pub fn set_app_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_id = input; self
        }
        /// <p>The name of the backend environment that is part of the Amplify app.</p>
        pub fn environment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.environment_name = Some(input.into());
            self
        }
        /// <p>The name of the backend environment that is part of the Amplify app.</p>
        pub fn set_environment_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.environment_name = input; self
        }
        /// <p>The unique ID for the form.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique ID for the form.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// <p>The unique client token.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>The unique client token.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// <p>The request accepts the following data in JSON format.</p>
        pub fn updated_form(mut self, input: crate::model::UpdateFormData) -> Self {
            self.updated_form = Some(input);
            self
        }
        /// <p>The request accepts the following data in JSON format.</p>
        pub fn set_updated_form(mut self, input: std::option::Option<crate::model::UpdateFormData>) -> Self {
            self.updated_form = input; self
        }
        /// Consumes the builder and constructs a [`UpdateFormInput`](crate::input::UpdateFormInput).
        pub fn build(self) -> Result<crate::input::UpdateFormInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateFormInput {
                    app_id: self.app_id
                    ,
                    environment_name: self.environment_name
                    ,
                    id: self.id
                    ,
                    client_token: self.client_token
                    ,
                    updated_form: self.updated_form
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateFormInput {
    /// Consumes the builder and constructs an Operation<[`UpdateForm`](crate::operation::UpdateForm)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateForm, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.client_token.is_none() {
                                self.client_token = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateFormInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_57 = &_input.app_id;
                let input_57 = input_57.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))?;
                let app_id = aws_smithy_http::label::fmt_string(input_57, aws_smithy_http::label::EncodingStrategy::Default);
                if app_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))
                            }
                let input_58 = &_input.environment_name;
                let input_58 = input_58.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))?;
                let environment_name = aws_smithy_http::label::fmt_string(input_58, aws_smithy_http::label::EncodingStrategy::Default);
                if environment_name.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))
                            }
                let input_59 = &_input.id;
                let input_59 = input_59.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))?;
                let id = aws_smithy_http::label::fmt_string(input_59, aws_smithy_http::label::EncodingStrategy::Default);
                if id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))
                            }
                write!(output, "/app/{appId}/environment/{environmentName}/forms/{id}", appId = app_id, environmentName = environment_name, id = id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::UpdateFormInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_60) = &_input.client_token {
                     {
                        query.push_kv("clientToken", &aws_smithy_http::query::fmt_string(&inner_60));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateFormInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_payload_update_form_input(& self.updated_form)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateForm::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateForm", "amplifyuibuilder"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateFormInput`](crate::input::UpdateFormInput).
    pub fn builder() -> crate::input::update_form_input::Builder {
        crate::input::update_form_input::Builder::default()
    }
}

/// See [`UpdateThemeInput`](crate::input::UpdateThemeInput).
pub mod update_theme_input {
    
    /// A builder for [`UpdateThemeInput`](crate::input::UpdateThemeInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_id: std::option::Option<std::string::String>,
        pub(crate) environment_name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) updated_theme: std::option::Option<crate::model::UpdateThemeData>,
    }
    impl Builder {
        /// <p>The unique ID for the Amplify app.</p>
        pub fn app_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_id = Some(input.into());
            self
        }
        /// <p>The unique ID for the Amplify app.</p>
        pub fn set_app_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_id = input; self
        }
        /// <p>The name of the backend environment that is part of the Amplify app.</p>
        pub fn environment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.environment_name = Some(input.into());
            self
        }
        /// <p>The name of the backend environment that is part of the Amplify app.</p>
        pub fn set_environment_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.environment_name = input; self
        }
        /// <p>The unique ID for the theme.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique ID for the theme.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// <p>The unique client token.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>The unique client token.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// <p>The configuration of the updated theme.</p>
        pub fn updated_theme(mut self, input: crate::model::UpdateThemeData) -> Self {
            self.updated_theme = Some(input);
            self
        }
        /// <p>The configuration of the updated theme.</p>
        pub fn set_updated_theme(mut self, input: std::option::Option<crate::model::UpdateThemeData>) -> Self {
            self.updated_theme = input; self
        }
        /// Consumes the builder and constructs a [`UpdateThemeInput`](crate::input::UpdateThemeInput).
        pub fn build(self) -> Result<crate::input::UpdateThemeInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateThemeInput {
                    app_id: self.app_id
                    ,
                    environment_name: self.environment_name
                    ,
                    id: self.id
                    ,
                    client_token: self.client_token
                    ,
                    updated_theme: self.updated_theme
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateThemeInput {
    /// Consumes the builder and constructs an Operation<[`UpdateTheme`](crate::operation::UpdateTheme)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateTheme, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.client_token.is_none() {
                                self.client_token = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateThemeInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_61 = &_input.app_id;
                let input_61 = input_61.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))?;
                let app_id = aws_smithy_http::label::fmt_string(input_61, aws_smithy_http::label::EncodingStrategy::Default);
                if app_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("app_id", "cannot be empty or unset"))
                            }
                let input_62 = &_input.environment_name;
                let input_62 = input_62.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))?;
                let environment_name = aws_smithy_http::label::fmt_string(input_62, aws_smithy_http::label::EncodingStrategy::Default);
                if environment_name.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("environment_name", "cannot be empty or unset"))
                            }
                let input_63 = &_input.id;
                let input_63 = input_63.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))?;
                let id = aws_smithy_http::label::fmt_string(input_63, aws_smithy_http::label::EncodingStrategy::Default);
                if id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))
                            }
                write!(output, "/app/{appId}/environment/{environmentName}/themes/{id}", appId = app_id, environmentName = environment_name, id = id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::UpdateThemeInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_64) = &_input.client_token {
                     {
                        query.push_kv("clientToken", &aws_smithy_http::query::fmt_string(&inner_64));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateThemeInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_payload_update_theme_input(& self.updated_theme)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateTheme::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateTheme", "amplifyuibuilder"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateThemeInput`](crate::input::UpdateThemeInput).
    pub fn builder() -> crate::input::update_theme_input::Builder {
        crate::input::update_theme_input::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExportThemesInput  {
    /// <p>The unique ID of the Amplify app to export the themes to.</p>
    #[doc(hidden)]
    pub app_id: std::option::Option<std::string::String>,
    /// <p>The name of the backend environment that is part of the Amplify app.</p>
    #[doc(hidden)]
    pub environment_name: std::option::Option<std::string::String>,
    /// <p>The token to request the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ExportThemesInput {
    /// <p>The unique ID of the Amplify app to export the themes to.</p>
    pub fn app_id(&self) -> std::option::Option<& str> {
        self.app_id.as_deref()
    }
    /// <p>The name of the backend environment that is part of the Amplify app.</p>
    pub fn environment_name(&self) -> std::option::Option<& str> {
        self.environment_name.as_deref()
    }
    /// <p>The token to request the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListThemesInput  {
    /// <p>The unique ID for the Amplify app.</p>
    #[doc(hidden)]
    pub app_id: std::option::Option<std::string::String>,
    /// <p>The name of the backend environment that is a part of the Amplify app.</p>
    #[doc(hidden)]
    pub environment_name: std::option::Option<std::string::String>,
    /// <p>The token to request the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of theme results to return in the response.</p>
    #[doc(hidden)]
    pub max_results: i32,
}
impl ListThemesInput {
    /// <p>The unique ID for the Amplify app.</p>
    pub fn app_id(&self) -> std::option::Option<& str> {
        self.app_id.as_deref()
    }
    /// <p>The name of the backend environment that is a part of the Amplify app.</p>
    pub fn environment_name(&self) -> std::option::Option<& str> {
        self.environment_name.as_deref()
    }
    /// <p>The token to request the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of theme results to return in the response.</p>
    pub fn max_results(&self) -> i32 {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateThemeInput  {
    /// <p>The unique ID of the Amplify app associated with the theme.</p>
    #[doc(hidden)]
    pub app_id: std::option::Option<std::string::String>,
    /// <p>The name of the backend environment that is a part of the Amplify app.</p>
    #[doc(hidden)]
    pub environment_name: std::option::Option<std::string::String>,
    /// <p>The unique client token.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
    /// <p>Represents the configuration of the theme to create.</p>
    #[doc(hidden)]
    pub theme_to_create: std::option::Option<crate::model::CreateThemeData>,
}
impl CreateThemeInput {
    /// <p>The unique ID of the Amplify app associated with the theme.</p>
    pub fn app_id(&self) -> std::option::Option<& str> {
        self.app_id.as_deref()
    }
    /// <p>The name of the backend environment that is a part of the Amplify app.</p>
    pub fn environment_name(&self) -> std::option::Option<& str> {
        self.environment_name.as_deref()
    }
    /// <p>The unique client token.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
    /// <p>Represents the configuration of the theme to create.</p>
    pub fn theme_to_create(&self) -> std::option::Option<& crate::model::CreateThemeData> {
        self.theme_to_create.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteThemeInput  {
    /// <p>The unique ID of the Amplify app associated with the theme to delete.</p>
    #[doc(hidden)]
    pub app_id: std::option::Option<std::string::String>,
    /// <p>The name of the backend environment that is a part of the Amplify app.</p>
    #[doc(hidden)]
    pub environment_name: std::option::Option<std::string::String>,
    /// <p>The unique ID of the theme to delete.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl DeleteThemeInput {
    /// <p>The unique ID of the Amplify app associated with the theme to delete.</p>
    pub fn app_id(&self) -> std::option::Option<& str> {
        self.app_id.as_deref()
    }
    /// <p>The name of the backend environment that is a part of the Amplify app.</p>
    pub fn environment_name(&self) -> std::option::Option<& str> {
        self.environment_name.as_deref()
    }
    /// <p>The unique ID of the theme to delete.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateThemeInput  {
    /// <p>The unique ID for the Amplify app.</p>
    #[doc(hidden)]
    pub app_id: std::option::Option<std::string::String>,
    /// <p>The name of the backend environment that is part of the Amplify app.</p>
    #[doc(hidden)]
    pub environment_name: std::option::Option<std::string::String>,
    /// <p>The unique ID for the theme.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The unique client token.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
    /// <p>The configuration of the updated theme.</p>
    #[doc(hidden)]
    pub updated_theme: std::option::Option<crate::model::UpdateThemeData>,
}
impl UpdateThemeInput {
    /// <p>The unique ID for the Amplify app.</p>
    pub fn app_id(&self) -> std::option::Option<& str> {
        self.app_id.as_deref()
    }
    /// <p>The name of the backend environment that is part of the Amplify app.</p>
    pub fn environment_name(&self) -> std::option::Option<& str> {
        self.environment_name.as_deref()
    }
    /// <p>The unique ID for the theme.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
    /// <p>The unique client token.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
    /// <p>The configuration of the updated theme.</p>
    pub fn updated_theme(&self) -> std::option::Option<& crate::model::UpdateThemeData> {
        self.updated_theme.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetThemeInput  {
    /// <p>The unique ID of the Amplify app.</p>
    #[doc(hidden)]
    pub app_id: std::option::Option<std::string::String>,
    /// <p>The name of the backend environment that is part of the Amplify app.</p>
    #[doc(hidden)]
    pub environment_name: std::option::Option<std::string::String>,
    /// <p>The unique ID for the theme.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl GetThemeInput {
    /// <p>The unique ID of the Amplify app.</p>
    pub fn app_id(&self) -> std::option::Option<& str> {
        self.app_id.as_deref()
    }
    /// <p>The name of the backend environment that is part of the Amplify app.</p>
    pub fn environment_name(&self) -> std::option::Option<& str> {
        self.environment_name.as_deref()
    }
    /// <p>The unique ID for the theme.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExportFormsInput  {
    /// <p>The unique ID of the Amplify app to export forms to.</p>
    #[doc(hidden)]
    pub app_id: std::option::Option<std::string::String>,
    /// <p>The name of the backend environment that is a part of the Amplify app.</p>
    #[doc(hidden)]
    pub environment_name: std::option::Option<std::string::String>,
    /// <p>The token to request the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ExportFormsInput {
    /// <p>The unique ID of the Amplify app to export forms to.</p>
    pub fn app_id(&self) -> std::option::Option<& str> {
        self.app_id.as_deref()
    }
    /// <p>The name of the backend environment that is a part of the Amplify app.</p>
    pub fn environment_name(&self) -> std::option::Option<& str> {
        self.environment_name.as_deref()
    }
    /// <p>The token to request the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListFormsInput  {
    /// <p>The unique ID for the Amplify app.</p>
    #[doc(hidden)]
    pub app_id: std::option::Option<std::string::String>,
    /// <p>The name of the backend environment that is a part of the Amplify app.</p>
    #[doc(hidden)]
    pub environment_name: std::option::Option<std::string::String>,
    /// <p>The token to request the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of forms to retrieve.</p>
    #[doc(hidden)]
    pub max_results: i32,
}
impl ListFormsInput {
    /// <p>The unique ID for the Amplify app.</p>
    pub fn app_id(&self) -> std::option::Option<& str> {
        self.app_id.as_deref()
    }
    /// <p>The name of the backend environment that is a part of the Amplify app.</p>
    pub fn environment_name(&self) -> std::option::Option<& str> {
        self.environment_name.as_deref()
    }
    /// <p>The token to request the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of forms to retrieve.</p>
    pub fn max_results(&self) -> i32 {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateFormInput  {
    /// <p>The unique ID of the Amplify app to associate with the form.</p>
    #[doc(hidden)]
    pub app_id: std::option::Option<std::string::String>,
    /// <p>The name of the backend environment that is a part of the Amplify app.</p>
    #[doc(hidden)]
    pub environment_name: std::option::Option<std::string::String>,
    /// <p>The unique client token.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
    /// <p>Represents the configuration of the form to create.</p>
    #[doc(hidden)]
    pub form_to_create: std::option::Option<crate::model::CreateFormData>,
}
impl CreateFormInput {
    /// <p>The unique ID of the Amplify app to associate with the form.</p>
    pub fn app_id(&self) -> std::option::Option<& str> {
        self.app_id.as_deref()
    }
    /// <p>The name of the backend environment that is a part of the Amplify app.</p>
    pub fn environment_name(&self) -> std::option::Option<& str> {
        self.environment_name.as_deref()
    }
    /// <p>The unique client token.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
    /// <p>Represents the configuration of the form to create.</p>
    pub fn form_to_create(&self) -> std::option::Option<& crate::model::CreateFormData> {
        self.form_to_create.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteFormInput  {
    /// <p>The unique ID of the Amplify app associated with the form to delete.</p>
    #[doc(hidden)]
    pub app_id: std::option::Option<std::string::String>,
    /// <p>The name of the backend environment that is a part of the Amplify app.</p>
    #[doc(hidden)]
    pub environment_name: std::option::Option<std::string::String>,
    /// <p>The unique ID of the form to delete.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl DeleteFormInput {
    /// <p>The unique ID of the Amplify app associated with the form to delete.</p>
    pub fn app_id(&self) -> std::option::Option<& str> {
        self.app_id.as_deref()
    }
    /// <p>The name of the backend environment that is a part of the Amplify app.</p>
    pub fn environment_name(&self) -> std::option::Option<& str> {
        self.environment_name.as_deref()
    }
    /// <p>The unique ID of the form to delete.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateFormInput  {
    /// <p>The unique ID for the Amplify app.</p>
    #[doc(hidden)]
    pub app_id: std::option::Option<std::string::String>,
    /// <p>The name of the backend environment that is part of the Amplify app.</p>
    #[doc(hidden)]
    pub environment_name: std::option::Option<std::string::String>,
    /// <p>The unique ID for the form.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The unique client token.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
    /// <p>The request accepts the following data in JSON format.</p>
    #[doc(hidden)]
    pub updated_form: std::option::Option<crate::model::UpdateFormData>,
}
impl UpdateFormInput {
    /// <p>The unique ID for the Amplify app.</p>
    pub fn app_id(&self) -> std::option::Option<& str> {
        self.app_id.as_deref()
    }
    /// <p>The name of the backend environment that is part of the Amplify app.</p>
    pub fn environment_name(&self) -> std::option::Option<& str> {
        self.environment_name.as_deref()
    }
    /// <p>The unique ID for the form.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
    /// <p>The unique client token.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
    /// <p>The request accepts the following data in JSON format.</p>
    pub fn updated_form(&self) -> std::option::Option<& crate::model::UpdateFormData> {
        self.updated_form.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetFormInput  {
    /// <p>The unique ID of the Amplify app.</p>
    #[doc(hidden)]
    pub app_id: std::option::Option<std::string::String>,
    /// <p>The name of the backend environment that is part of the Amplify app.</p>
    #[doc(hidden)]
    pub environment_name: std::option::Option<std::string::String>,
    /// <p>The unique ID of the form.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl GetFormInput {
    /// <p>The unique ID of the Amplify app.</p>
    pub fn app_id(&self) -> std::option::Option<& str> {
        self.app_id.as_deref()
    }
    /// <p>The name of the backend environment that is part of the Amplify app.</p>
    pub fn environment_name(&self) -> std::option::Option<& str> {
        self.environment_name.as_deref()
    }
    /// <p>The unique ID of the form.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExportComponentsInput  {
    /// <p>The unique ID of the Amplify app to export components to.</p>
    #[doc(hidden)]
    pub app_id: std::option::Option<std::string::String>,
    /// <p>The name of the backend environment that is a part of the Amplify app.</p>
    #[doc(hidden)]
    pub environment_name: std::option::Option<std::string::String>,
    /// <p>The token to request the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ExportComponentsInput {
    /// <p>The unique ID of the Amplify app to export components to.</p>
    pub fn app_id(&self) -> std::option::Option<& str> {
        self.app_id.as_deref()
    }
    /// <p>The name of the backend environment that is a part of the Amplify app.</p>
    pub fn environment_name(&self) -> std::option::Option<& str> {
        self.environment_name.as_deref()
    }
    /// <p>The token to request the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListComponentsInput  {
    /// <p>The unique ID for the Amplify app.</p>
    #[doc(hidden)]
    pub app_id: std::option::Option<std::string::String>,
    /// <p>The name of the backend environment that is a part of the Amplify app.</p>
    #[doc(hidden)]
    pub environment_name: std::option::Option<std::string::String>,
    /// <p>The token to request the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of components to retrieve.</p>
    #[doc(hidden)]
    pub max_results: i32,
}
impl ListComponentsInput {
    /// <p>The unique ID for the Amplify app.</p>
    pub fn app_id(&self) -> std::option::Option<& str> {
        self.app_id.as_deref()
    }
    /// <p>The name of the backend environment that is a part of the Amplify app.</p>
    pub fn environment_name(&self) -> std::option::Option<& str> {
        self.environment_name.as_deref()
    }
    /// <p>The token to request the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of components to retrieve.</p>
    pub fn max_results(&self) -> i32 {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateComponentInput  {
    /// <p>The unique ID of the Amplify app to associate with the component.</p>
    #[doc(hidden)]
    pub app_id: std::option::Option<std::string::String>,
    /// <p>The name of the backend environment that is a part of the Amplify app.</p>
    #[doc(hidden)]
    pub environment_name: std::option::Option<std::string::String>,
    /// <p>The unique client token.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
    /// <p>Represents the configuration of the component to create.</p>
    #[doc(hidden)]
    pub component_to_create: std::option::Option<crate::model::CreateComponentData>,
}
impl CreateComponentInput {
    /// <p>The unique ID of the Amplify app to associate with the component.</p>
    pub fn app_id(&self) -> std::option::Option<& str> {
        self.app_id.as_deref()
    }
    /// <p>The name of the backend environment that is a part of the Amplify app.</p>
    pub fn environment_name(&self) -> std::option::Option<& str> {
        self.environment_name.as_deref()
    }
    /// <p>The unique client token.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
    /// <p>Represents the configuration of the component to create.</p>
    pub fn component_to_create(&self) -> std::option::Option<& crate::model::CreateComponentData> {
        self.component_to_create.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteComponentInput  {
    /// <p>The unique ID of the Amplify app associated with the component to delete.</p>
    #[doc(hidden)]
    pub app_id: std::option::Option<std::string::String>,
    /// <p>The name of the backend environment that is a part of the Amplify app.</p>
    #[doc(hidden)]
    pub environment_name: std::option::Option<std::string::String>,
    /// <p>The unique ID of the component to delete.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl DeleteComponentInput {
    /// <p>The unique ID of the Amplify app associated with the component to delete.</p>
    pub fn app_id(&self) -> std::option::Option<& str> {
        self.app_id.as_deref()
    }
    /// <p>The name of the backend environment that is a part of the Amplify app.</p>
    pub fn environment_name(&self) -> std::option::Option<& str> {
        self.environment_name.as_deref()
    }
    /// <p>The unique ID of the component to delete.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateComponentInput  {
    /// <p>The unique ID for the Amplify app.</p>
    #[doc(hidden)]
    pub app_id: std::option::Option<std::string::String>,
    /// <p>The name of the backend environment that is part of the Amplify app.</p>
    #[doc(hidden)]
    pub environment_name: std::option::Option<std::string::String>,
    /// <p>The unique ID for the component.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The unique client token.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
    /// <p>The configuration of the updated component.</p>
    #[doc(hidden)]
    pub updated_component: std::option::Option<crate::model::UpdateComponentData>,
}
impl UpdateComponentInput {
    /// <p>The unique ID for the Amplify app.</p>
    pub fn app_id(&self) -> std::option::Option<& str> {
        self.app_id.as_deref()
    }
    /// <p>The name of the backend environment that is part of the Amplify app.</p>
    pub fn environment_name(&self) -> std::option::Option<& str> {
        self.environment_name.as_deref()
    }
    /// <p>The unique ID for the component.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
    /// <p>The unique client token.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
    /// <p>The configuration of the updated component.</p>
    pub fn updated_component(&self) -> std::option::Option<& crate::model::UpdateComponentData> {
        self.updated_component.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetComponentInput  {
    /// <p>The unique ID of the Amplify app.</p>
    #[doc(hidden)]
    pub app_id: std::option::Option<std::string::String>,
    /// <p>The name of the backend environment that is part of the Amplify app.</p>
    #[doc(hidden)]
    pub environment_name: std::option::Option<std::string::String>,
    /// <p>The unique ID of the component.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl GetComponentInput {
    /// <p>The unique ID of the Amplify app.</p>
    pub fn app_id(&self) -> std::option::Option<& str> {
        self.app_id.as_deref()
    }
    /// <p>The name of the backend environment that is part of the Amplify app.</p>
    pub fn environment_name(&self) -> std::option::Option<& str> {
        self.environment_name.as_deref()
    }
    /// <p>The unique ID of the component.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RefreshTokenInput  {
    /// <p>The third-party provider for the token. The only valid value is <code>figma</code>.</p>
    #[doc(hidden)]
    pub provider: std::option::Option<crate::model::TokenProviders>,
    /// <p>Information about the refresh token request.</p>
    #[doc(hidden)]
    pub refresh_token_body: std::option::Option<crate::model::RefreshTokenRequestBody>,
}
impl RefreshTokenInput {
    /// <p>The third-party provider for the token. The only valid value is <code>figma</code>.</p>
    pub fn provider(&self) -> std::option::Option<& crate::model::TokenProviders> {
        self.provider.as_ref()
    }
    /// <p>Information about the refresh token request.</p>
    pub fn refresh_token_body(&self) -> std::option::Option<& crate::model::RefreshTokenRequestBody> {
        self.refresh_token_body.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PutMetadataFlagInput  {
    /// <p>The unique ID for the Amplify app.</p>
    #[doc(hidden)]
    pub app_id: std::option::Option<std::string::String>,
    /// <p>The name of the backend environment that is part of the Amplify app.</p>
    #[doc(hidden)]
    pub environment_name: std::option::Option<std::string::String>,
    /// <p>The name of the feature associated with the metadata.</p>
    #[doc(hidden)]
    pub feature_name: std::option::Option<std::string::String>,
    /// <p>The metadata information to store.</p>
    #[doc(hidden)]
    pub body: std::option::Option<crate::model::PutMetadataFlagBody>,
}
impl PutMetadataFlagInput {
    /// <p>The unique ID for the Amplify app.</p>
    pub fn app_id(&self) -> std::option::Option<& str> {
        self.app_id.as_deref()
    }
    /// <p>The name of the backend environment that is part of the Amplify app.</p>
    pub fn environment_name(&self) -> std::option::Option<& str> {
        self.environment_name.as_deref()
    }
    /// <p>The name of the feature associated with the metadata.</p>
    pub fn feature_name(&self) -> std::option::Option<& str> {
        self.feature_name.as_deref()
    }
    /// <p>The metadata information to store.</p>
    pub fn body(&self) -> std::option::Option<& crate::model::PutMetadataFlagBody> {
        self.body.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetMetadataInput  {
    /// <p>The unique ID of the Amplify app.</p>
    #[doc(hidden)]
    pub app_id: std::option::Option<std::string::String>,
    /// <p>The name of the backend environment that is part of the Amplify app.</p>
    #[doc(hidden)]
    pub environment_name: std::option::Option<std::string::String>,
}
impl GetMetadataInput {
    /// <p>The unique ID of the Amplify app.</p>
    pub fn app_id(&self) -> std::option::Option<& str> {
        self.app_id.as_deref()
    }
    /// <p>The name of the backend environment that is part of the Amplify app.</p>
    pub fn environment_name(&self) -> std::option::Option<& str> {
        self.environment_name.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExchangeCodeForTokenInput  {
    /// <p>The third-party provider for the token. The only valid value is <code>figma</code>.</p>
    #[doc(hidden)]
    pub provider: std::option::Option<crate::model::TokenProviders>,
    /// <p>Describes the configuration of the request.</p>
    #[doc(hidden)]
    pub request: std::option::Option<crate::model::ExchangeCodeForTokenRequestBody>,
}
impl ExchangeCodeForTokenInput {
    /// <p>The third-party provider for the token. The only valid value is <code>figma</code>.</p>
    pub fn provider(&self) -> std::option::Option<& crate::model::TokenProviders> {
        self.provider.as_ref()
    }
    /// <p>Describes the configuration of the request.</p>
    pub fn request(&self) -> std::option::Option<& crate::model::ExchangeCodeForTokenRequestBody> {
        self.request.as_ref()
    }
}

