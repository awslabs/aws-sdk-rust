// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A theme is a collection of style settings that apply globally to the components associated with an Amplify application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Theme {
    /// <p>The unique ID for the Amplify app associated with the theme.</p>
    #[doc(hidden)]
    pub app_id: std::option::Option<std::string::String>,
    /// <p>The name of the backend environment that is a part of the Amplify app.</p>
    #[doc(hidden)]
    pub environment_name: std::option::Option<std::string::String>,
    /// <p>The ID for the theme.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the theme.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The time that the theme was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that the theme was modified.</p>
    #[doc(hidden)]
    pub modified_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A list of key-value pairs that defines the properties of the theme.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<crate::model::ThemeValues>>,
    /// <p>Describes the properties that can be overriden to customize a theme.</p>
    #[doc(hidden)]
    pub overrides: std::option::Option<std::vec::Vec<crate::model::ThemeValues>>,
    /// <p>One or more key-value pairs to use when tagging the theme.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl Theme {
    /// <p>The unique ID for the Amplify app associated with the theme.</p>
    pub fn app_id(&self) -> std::option::Option<&str> {
        self.app_id.as_deref()
    }
    /// <p>The name of the backend environment that is a part of the Amplify app.</p>
    pub fn environment_name(&self) -> std::option::Option<&str> {
        self.environment_name.as_deref()
    }
    /// <p>The ID for the theme.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the theme.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The time that the theme was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The time that the theme was modified.</p>
    pub fn modified_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.modified_at.as_ref()
    }
    /// <p>A list of key-value pairs that defines the properties of the theme.</p>
    pub fn values(&self) -> std::option::Option<&[crate::model::ThemeValues]> {
        self.values.as_deref()
    }
    /// <p>Describes the properties that can be overriden to customize a theme.</p>
    pub fn overrides(&self) -> std::option::Option<&[crate::model::ThemeValues]> {
        self.overrides.as_deref()
    }
    /// <p>One or more key-value pairs to use when tagging the theme.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
/// See [`Theme`](crate::model::Theme).
pub mod theme {

    /// A builder for [`Theme`](crate::model::Theme).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_id: std::option::Option<std::string::String>,
        pub(crate) environment_name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) modified_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) values: std::option::Option<std::vec::Vec<crate::model::ThemeValues>>,
        pub(crate) overrides: std::option::Option<std::vec::Vec<crate::model::ThemeValues>>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The unique ID for the Amplify app associated with the theme.</p>
        pub fn app_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_id = Some(input.into());
            self
        }
        /// <p>The unique ID for the Amplify app associated with the theme.</p>
        pub fn set_app_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_id = input;
            self
        }
        /// <p>The name of the backend environment that is a part of the Amplify app.</p>
        pub fn environment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.environment_name = Some(input.into());
            self
        }
        /// <p>The name of the backend environment that is a part of the Amplify app.</p>
        pub fn set_environment_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.environment_name = input;
            self
        }
        /// <p>The ID for the theme.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID for the theme.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the theme.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the theme.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The time that the theme was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The time that the theme was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The time that the theme was modified.</p>
        pub fn modified_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.modified_at = Some(input);
            self
        }
        /// <p>The time that the theme was modified.</p>
        pub fn set_modified_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.modified_at = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>A list of key-value pairs that defines the properties of the theme.</p>
        pub fn values(mut self, input: crate::model::ThemeValues) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input);
            self.values = Some(v);
            self
        }
        /// <p>A list of key-value pairs that defines the properties of the theme.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ThemeValues>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Appends an item to `overrides`.
        ///
        /// To override the contents of this collection use [`set_overrides`](Self::set_overrides).
        ///
        /// <p>Describes the properties that can be overriden to customize a theme.</p>
        pub fn overrides(mut self, input: crate::model::ThemeValues) -> Self {
            let mut v = self.overrides.unwrap_or_default();
            v.push(input);
            self.overrides = Some(v);
            self
        }
        /// <p>Describes the properties that can be overriden to customize a theme.</p>
        pub fn set_overrides(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ThemeValues>>,
        ) -> Self {
            self.overrides = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>One or more key-value pairs to use when tagging the theme.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>One or more key-value pairs to use when tagging the theme.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`Theme`](crate::model::Theme).
        pub fn build(self) -> crate::model::Theme {
            crate::model::Theme {
                app_id: self.app_id,
                environment_name: self.environment_name,
                id: self.id,
                name: self.name,
                created_at: self.created_at,
                modified_at: self.modified_at,
                values: self.values,
                overrides: self.overrides,
                tags: self.tags,
            }
        }
    }
}
impl Theme {
    /// Creates a new builder-style object to manufacture [`Theme`](crate::model::Theme).
    pub fn builder() -> crate::model::theme::Builder {
        crate::model::theme::Builder::default()
    }
}

/// <p>A key-value pair that defines a property of a theme.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ThemeValues {
    /// <p>The name of the property.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The value of the property.</p>
    #[doc(hidden)]
    pub value: std::option::Option<crate::model::ThemeValue>,
}
impl ThemeValues {
    /// <p>The name of the property.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The value of the property.</p>
    pub fn value(&self) -> std::option::Option<&crate::model::ThemeValue> {
        self.value.as_ref()
    }
}
/// See [`ThemeValues`](crate::model::ThemeValues).
pub mod theme_values {

    /// A builder for [`ThemeValues`](crate::model::ThemeValues).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<crate::model::ThemeValue>,
    }
    impl Builder {
        /// <p>The name of the property.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The name of the property.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The value of the property.</p>
        pub fn value(mut self, input: crate::model::ThemeValue) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value of the property.</p>
        pub fn set_value(mut self, input: std::option::Option<crate::model::ThemeValue>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`ThemeValues`](crate::model::ThemeValues).
        pub fn build(self) -> crate::model::ThemeValues {
            crate::model::ThemeValues {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl ThemeValues {
    /// Creates a new builder-style object to manufacture [`ThemeValues`](crate::model::ThemeValues).
    pub fn builder() -> crate::model::theme_values::Builder {
        crate::model::theme_values::Builder::default()
    }
}

/// <p>Describes the configuration of a theme's properties.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ThemeValue {
    /// <p>The value of a theme property.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
    /// <p>A list of key-value pairs that define the theme's properties.</p>
    #[doc(hidden)]
    pub children: std::option::Option<std::vec::Vec<crate::model::ThemeValues>>,
}
impl ThemeValue {
    /// <p>The value of a theme property.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
    /// <p>A list of key-value pairs that define the theme's properties.</p>
    pub fn children(&self) -> std::option::Option<&[crate::model::ThemeValues]> {
        self.children.as_deref()
    }
}
/// See [`ThemeValue`](crate::model::ThemeValue).
pub mod theme_value {

    /// A builder for [`ThemeValue`](crate::model::ThemeValue).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) children: std::option::Option<std::vec::Vec<crate::model::ThemeValues>>,
    }
    impl Builder {
        /// <p>The value of a theme property.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of a theme property.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Appends an item to `children`.
        ///
        /// To override the contents of this collection use [`set_children`](Self::set_children).
        ///
        /// <p>A list of key-value pairs that define the theme's properties.</p>
        pub fn children(mut self, input: crate::model::ThemeValues) -> Self {
            let mut v = self.children.unwrap_or_default();
            v.push(input);
            self.children = Some(v);
            self
        }
        /// <p>A list of key-value pairs that define the theme's properties.</p>
        pub fn set_children(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ThemeValues>>,
        ) -> Self {
            self.children = input;
            self
        }
        /// Consumes the builder and constructs a [`ThemeValue`](crate::model::ThemeValue).
        pub fn build(self) -> crate::model::ThemeValue {
            crate::model::ThemeValue {
                value: self.value,
                children: self.children,
            }
        }
    }
}
impl ThemeValue {
    /// Creates a new builder-style object to manufacture [`ThemeValue`](crate::model::ThemeValue).
    pub fn builder() -> crate::model::theme_value::Builder {
        crate::model::theme_value::Builder::default()
    }
}

/// <p>Describes the basic information about a theme.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ThemeSummary {
    /// <p>The unique ID for the app associated with the theme summary.</p>
    #[doc(hidden)]
    pub app_id: std::option::Option<std::string::String>,
    /// <p>The name of the backend environment that is part of the Amplify app.</p>
    #[doc(hidden)]
    pub environment_name: std::option::Option<std::string::String>,
    /// <p>The ID of the theme.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the theme.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl ThemeSummary {
    /// <p>The unique ID for the app associated with the theme summary.</p>
    pub fn app_id(&self) -> std::option::Option<&str> {
        self.app_id.as_deref()
    }
    /// <p>The name of the backend environment that is part of the Amplify app.</p>
    pub fn environment_name(&self) -> std::option::Option<&str> {
        self.environment_name.as_deref()
    }
    /// <p>The ID of the theme.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the theme.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
/// See [`ThemeSummary`](crate::model::ThemeSummary).
pub mod theme_summary {

    /// A builder for [`ThemeSummary`](crate::model::ThemeSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_id: std::option::Option<std::string::String>,
        pub(crate) environment_name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique ID for the app associated with the theme summary.</p>
        pub fn app_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_id = Some(input.into());
            self
        }
        /// <p>The unique ID for the app associated with the theme summary.</p>
        pub fn set_app_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_id = input;
            self
        }
        /// <p>The name of the backend environment that is part of the Amplify app.</p>
        pub fn environment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.environment_name = Some(input.into());
            self
        }
        /// <p>The name of the backend environment that is part of the Amplify app.</p>
        pub fn set_environment_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.environment_name = input;
            self
        }
        /// <p>The ID of the theme.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the theme.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the theme.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the theme.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`ThemeSummary`](crate::model::ThemeSummary).
        pub fn build(self) -> crate::model::ThemeSummary {
            crate::model::ThemeSummary {
                app_id: self.app_id,
                environment_name: self.environment_name,
                id: self.id,
                name: self.name,
            }
        }
    }
}
impl ThemeSummary {
    /// Creates a new builder-style object to manufacture [`ThemeSummary`](crate::model::ThemeSummary).
    pub fn builder() -> crate::model::theme_summary::Builder {
        crate::model::theme_summary::Builder::default()
    }
}

/// <p>Represents all of the information that is required to create a theme.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateThemeData {
    /// <p>The name of the theme.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A list of key-value pairs that deﬁnes the properties of the theme.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<crate::model::ThemeValues>>,
    /// <p>Describes the properties that can be overriden to customize an instance of the theme.</p>
    #[doc(hidden)]
    pub overrides: std::option::Option<std::vec::Vec<crate::model::ThemeValues>>,
    /// <p>One or more key-value pairs to use when tagging the theme data.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateThemeData {
    /// <p>The name of the theme.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A list of key-value pairs that deﬁnes the properties of the theme.</p>
    pub fn values(&self) -> std::option::Option<&[crate::model::ThemeValues]> {
        self.values.as_deref()
    }
    /// <p>Describes the properties that can be overriden to customize an instance of the theme.</p>
    pub fn overrides(&self) -> std::option::Option<&[crate::model::ThemeValues]> {
        self.overrides.as_deref()
    }
    /// <p>One or more key-value pairs to use when tagging the theme data.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
/// See [`CreateThemeData`](crate::model::CreateThemeData).
pub mod create_theme_data {

    /// A builder for [`CreateThemeData`](crate::model::CreateThemeData).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<crate::model::ThemeValues>>,
        pub(crate) overrides: std::option::Option<std::vec::Vec<crate::model::ThemeValues>>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The name of the theme.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the theme.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>A list of key-value pairs that deﬁnes the properties of the theme.</p>
        pub fn values(mut self, input: crate::model::ThemeValues) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input);
            self.values = Some(v);
            self
        }
        /// <p>A list of key-value pairs that deﬁnes the properties of the theme.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ThemeValues>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Appends an item to `overrides`.
        ///
        /// To override the contents of this collection use [`set_overrides`](Self::set_overrides).
        ///
        /// <p>Describes the properties that can be overriden to customize an instance of the theme.</p>
        pub fn overrides(mut self, input: crate::model::ThemeValues) -> Self {
            let mut v = self.overrides.unwrap_or_default();
            v.push(input);
            self.overrides = Some(v);
            self
        }
        /// <p>Describes the properties that can be overriden to customize an instance of the theme.</p>
        pub fn set_overrides(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ThemeValues>>,
        ) -> Self {
            self.overrides = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>One or more key-value pairs to use when tagging the theme data.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>One or more key-value pairs to use when tagging the theme data.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateThemeData`](crate::model::CreateThemeData).
        pub fn build(self) -> crate::model::CreateThemeData {
            crate::model::CreateThemeData {
                name: self.name,
                values: self.values,
                overrides: self.overrides,
                tags: self.tags,
            }
        }
    }
}
impl CreateThemeData {
    /// Creates a new builder-style object to manufacture [`CreateThemeData`](crate::model::CreateThemeData).
    pub fn builder() -> crate::model::create_theme_data::Builder {
        crate::model::create_theme_data::Builder::default()
    }
}

/// <p>Saves the data binding information for a theme.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateThemeData {
    /// <p>The unique ID of the theme to update.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the theme to update.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A list of key-value pairs that define the theme's properties.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<crate::model::ThemeValues>>,
    /// <p>Describes the properties that can be overriden to customize the theme.</p>
    #[doc(hidden)]
    pub overrides: std::option::Option<std::vec::Vec<crate::model::ThemeValues>>,
}
impl UpdateThemeData {
    /// <p>The unique ID of the theme to update.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the theme to update.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A list of key-value pairs that define the theme's properties.</p>
    pub fn values(&self) -> std::option::Option<&[crate::model::ThemeValues]> {
        self.values.as_deref()
    }
    /// <p>Describes the properties that can be overriden to customize the theme.</p>
    pub fn overrides(&self) -> std::option::Option<&[crate::model::ThemeValues]> {
        self.overrides.as_deref()
    }
}
/// See [`UpdateThemeData`](crate::model::UpdateThemeData).
pub mod update_theme_data {

    /// A builder for [`UpdateThemeData`](crate::model::UpdateThemeData).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<crate::model::ThemeValues>>,
        pub(crate) overrides: std::option::Option<std::vec::Vec<crate::model::ThemeValues>>,
    }
    impl Builder {
        /// <p>The unique ID of the theme to update.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique ID of the theme to update.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the theme to update.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the theme to update.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>A list of key-value pairs that define the theme's properties.</p>
        pub fn values(mut self, input: crate::model::ThemeValues) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input);
            self.values = Some(v);
            self
        }
        /// <p>A list of key-value pairs that define the theme's properties.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ThemeValues>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Appends an item to `overrides`.
        ///
        /// To override the contents of this collection use [`set_overrides`](Self::set_overrides).
        ///
        /// <p>Describes the properties that can be overriden to customize the theme.</p>
        pub fn overrides(mut self, input: crate::model::ThemeValues) -> Self {
            let mut v = self.overrides.unwrap_or_default();
            v.push(input);
            self.overrides = Some(v);
            self
        }
        /// <p>Describes the properties that can be overriden to customize the theme.</p>
        pub fn set_overrides(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ThemeValues>>,
        ) -> Self {
            self.overrides = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateThemeData`](crate::model::UpdateThemeData).
        pub fn build(self) -> crate::model::UpdateThemeData {
            crate::model::UpdateThemeData {
                id: self.id,
                name: self.name,
                values: self.values,
                overrides: self.overrides,
            }
        }
    }
}
impl UpdateThemeData {
    /// Creates a new builder-style object to manufacture [`UpdateThemeData`](crate::model::UpdateThemeData).
    pub fn builder() -> crate::model::update_theme_data::Builder {
        crate::model::update_theme_data::Builder::default()
    }
}

/// <p>Contains the configuration settings for a <code>Form</code> user interface (UI) element for an Amplify app. A form is a component you can add to your project by specifying a data source as the default configuration for the form.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Form {
    /// <p>The unique ID of the Amplify app associated with the form.</p>
    #[doc(hidden)]
    pub app_id: std::option::Option<std::string::String>,
    /// <p>The name of the backend environment that is a part of the Amplify app.</p>
    #[doc(hidden)]
    pub environment_name: std::option::Option<std::string::String>,
    /// <p>The unique ID of the form.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the form.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The operation to perform on the specified form.</p>
    #[doc(hidden)]
    pub form_action_type: std::option::Option<crate::model::FormActionType>,
    /// <p>Stores the configuration for the form's style.</p>
    #[doc(hidden)]
    pub style: std::option::Option<crate::model::FormStyle>,
    /// <p>The type of data source to use to create the form.</p>
    #[doc(hidden)]
    pub data_type: std::option::Option<crate::model::FormDataTypeConfig>,
    /// <p>Stores the information about the form's fields.</p>
    #[doc(hidden)]
    pub fields: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::FieldConfig>,
    >,
    /// <p>Stores the visual helper elements for the form that are not associated with any data.</p>
    #[doc(hidden)]
    pub sectional_elements: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::SectionalElement>,
    >,
    /// <p>The schema version of the form when it was imported.</p>
    #[doc(hidden)]
    pub schema_version: std::option::Option<std::string::String>,
    /// <p>One or more key-value pairs to use when tagging the form.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Stores the call to action configuration for the form.</p>
    #[doc(hidden)]
    pub cta: std::option::Option<crate::model::FormCta>,
}
impl Form {
    /// <p>The unique ID of the Amplify app associated with the form.</p>
    pub fn app_id(&self) -> std::option::Option<&str> {
        self.app_id.as_deref()
    }
    /// <p>The name of the backend environment that is a part of the Amplify app.</p>
    pub fn environment_name(&self) -> std::option::Option<&str> {
        self.environment_name.as_deref()
    }
    /// <p>The unique ID of the form.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the form.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The operation to perform on the specified form.</p>
    pub fn form_action_type(&self) -> std::option::Option<&crate::model::FormActionType> {
        self.form_action_type.as_ref()
    }
    /// <p>Stores the configuration for the form's style.</p>
    pub fn style(&self) -> std::option::Option<&crate::model::FormStyle> {
        self.style.as_ref()
    }
    /// <p>The type of data source to use to create the form.</p>
    pub fn data_type(&self) -> std::option::Option<&crate::model::FormDataTypeConfig> {
        self.data_type.as_ref()
    }
    /// <p>Stores the information about the form's fields.</p>
    pub fn fields(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::FieldConfig>,
    > {
        self.fields.as_ref()
    }
    /// <p>Stores the visual helper elements for the form that are not associated with any data.</p>
    pub fn sectional_elements(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::SectionalElement>,
    > {
        self.sectional_elements.as_ref()
    }
    /// <p>The schema version of the form when it was imported.</p>
    pub fn schema_version(&self) -> std::option::Option<&str> {
        self.schema_version.as_deref()
    }
    /// <p>One or more key-value pairs to use when tagging the form.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>Stores the call to action configuration for the form.</p>
    pub fn cta(&self) -> std::option::Option<&crate::model::FormCta> {
        self.cta.as_ref()
    }
}
/// See [`Form`](crate::model::Form).
pub mod form {

    /// A builder for [`Form`](crate::model::Form).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_id: std::option::Option<std::string::String>,
        pub(crate) environment_name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) form_action_type: std::option::Option<crate::model::FormActionType>,
        pub(crate) style: std::option::Option<crate::model::FormStyle>,
        pub(crate) data_type: std::option::Option<crate::model::FormDataTypeConfig>,
        pub(crate) fields: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::FieldConfig>,
        >,
        pub(crate) sectional_elements: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::SectionalElement>,
        >,
        pub(crate) schema_version: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) cta: std::option::Option<crate::model::FormCta>,
    }
    impl Builder {
        /// <p>The unique ID of the Amplify app associated with the form.</p>
        pub fn app_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_id = Some(input.into());
            self
        }
        /// <p>The unique ID of the Amplify app associated with the form.</p>
        pub fn set_app_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_id = input;
            self
        }
        /// <p>The name of the backend environment that is a part of the Amplify app.</p>
        pub fn environment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.environment_name = Some(input.into());
            self
        }
        /// <p>The name of the backend environment that is a part of the Amplify app.</p>
        pub fn set_environment_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.environment_name = input;
            self
        }
        /// <p>The unique ID of the form.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique ID of the form.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the form.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the form.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The operation to perform on the specified form.</p>
        pub fn form_action_type(mut self, input: crate::model::FormActionType) -> Self {
            self.form_action_type = Some(input);
            self
        }
        /// <p>The operation to perform on the specified form.</p>
        pub fn set_form_action_type(
            mut self,
            input: std::option::Option<crate::model::FormActionType>,
        ) -> Self {
            self.form_action_type = input;
            self
        }
        /// <p>Stores the configuration for the form's style.</p>
        pub fn style(mut self, input: crate::model::FormStyle) -> Self {
            self.style = Some(input);
            self
        }
        /// <p>Stores the configuration for the form's style.</p>
        pub fn set_style(mut self, input: std::option::Option<crate::model::FormStyle>) -> Self {
            self.style = input;
            self
        }
        /// <p>The type of data source to use to create the form.</p>
        pub fn data_type(mut self, input: crate::model::FormDataTypeConfig) -> Self {
            self.data_type = Some(input);
            self
        }
        /// <p>The type of data source to use to create the form.</p>
        pub fn set_data_type(
            mut self,
            input: std::option::Option<crate::model::FormDataTypeConfig>,
        ) -> Self {
            self.data_type = input;
            self
        }
        /// Adds a key-value pair to `fields`.
        ///
        /// To override the contents of this collection use [`set_fields`](Self::set_fields).
        ///
        /// <p>Stores the information about the form's fields.</p>
        pub fn fields(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::FieldConfig,
        ) -> Self {
            let mut hash_map = self.fields.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.fields = Some(hash_map);
            self
        }
        /// <p>Stores the information about the form's fields.</p>
        pub fn set_fields(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::FieldConfig>,
            >,
        ) -> Self {
            self.fields = input;
            self
        }
        /// Adds a key-value pair to `sectional_elements`.
        ///
        /// To override the contents of this collection use [`set_sectional_elements`](Self::set_sectional_elements).
        ///
        /// <p>Stores the visual helper elements for the form that are not associated with any data.</p>
        pub fn sectional_elements(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::SectionalElement,
        ) -> Self {
            let mut hash_map = self.sectional_elements.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.sectional_elements = Some(hash_map);
            self
        }
        /// <p>Stores the visual helper elements for the form that are not associated with any data.</p>
        pub fn set_sectional_elements(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::SectionalElement>,
            >,
        ) -> Self {
            self.sectional_elements = input;
            self
        }
        /// <p>The schema version of the form when it was imported.</p>
        pub fn schema_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.schema_version = Some(input.into());
            self
        }
        /// <p>The schema version of the form when it was imported.</p>
        pub fn set_schema_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.schema_version = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>One or more key-value pairs to use when tagging the form.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>One or more key-value pairs to use when tagging the form.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>Stores the call to action configuration for the form.</p>
        pub fn cta(mut self, input: crate::model::FormCta) -> Self {
            self.cta = Some(input);
            self
        }
        /// <p>Stores the call to action configuration for the form.</p>
        pub fn set_cta(mut self, input: std::option::Option<crate::model::FormCta>) -> Self {
            self.cta = input;
            self
        }
        /// Consumes the builder and constructs a [`Form`](crate::model::Form).
        pub fn build(self) -> crate::model::Form {
            crate::model::Form {
                app_id: self.app_id,
                environment_name: self.environment_name,
                id: self.id,
                name: self.name,
                form_action_type: self.form_action_type,
                style: self.style,
                data_type: self.data_type,
                fields: self.fields,
                sectional_elements: self.sectional_elements,
                schema_version: self.schema_version,
                tags: self.tags,
                cta: self.cta,
            }
        }
    }
}
impl Form {
    /// Creates a new builder-style object to manufacture [`Form`](crate::model::Form).
    pub fn builder() -> crate::model::form::Builder {
        crate::model::form::Builder::default()
    }
}

/// <p>Describes the call to action button configuration for the form.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FormCta {
    /// <p>The position of the button.</p>
    #[doc(hidden)]
    pub position: std::option::Option<crate::model::FormButtonsPosition>,
    /// <p>Displays a clear button.</p>
    #[doc(hidden)]
    pub clear: std::option::Option<crate::model::FormButton>,
    /// <p>Displays a cancel button.</p>
    #[doc(hidden)]
    pub cancel: std::option::Option<crate::model::FormButton>,
    /// <p>Displays a submit button.</p>
    #[doc(hidden)]
    pub submit: std::option::Option<crate::model::FormButton>,
}
impl FormCta {
    /// <p>The position of the button.</p>
    pub fn position(&self) -> std::option::Option<&crate::model::FormButtonsPosition> {
        self.position.as_ref()
    }
    /// <p>Displays a clear button.</p>
    pub fn clear(&self) -> std::option::Option<&crate::model::FormButton> {
        self.clear.as_ref()
    }
    /// <p>Displays a cancel button.</p>
    pub fn cancel(&self) -> std::option::Option<&crate::model::FormButton> {
        self.cancel.as_ref()
    }
    /// <p>Displays a submit button.</p>
    pub fn submit(&self) -> std::option::Option<&crate::model::FormButton> {
        self.submit.as_ref()
    }
}
/// See [`FormCta`](crate::model::FormCta).
pub mod form_cta {

    /// A builder for [`FormCta`](crate::model::FormCta).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) position: std::option::Option<crate::model::FormButtonsPosition>,
        pub(crate) clear: std::option::Option<crate::model::FormButton>,
        pub(crate) cancel: std::option::Option<crate::model::FormButton>,
        pub(crate) submit: std::option::Option<crate::model::FormButton>,
    }
    impl Builder {
        /// <p>The position of the button.</p>
        pub fn position(mut self, input: crate::model::FormButtonsPosition) -> Self {
            self.position = Some(input);
            self
        }
        /// <p>The position of the button.</p>
        pub fn set_position(
            mut self,
            input: std::option::Option<crate::model::FormButtonsPosition>,
        ) -> Self {
            self.position = input;
            self
        }
        /// <p>Displays a clear button.</p>
        pub fn clear(mut self, input: crate::model::FormButton) -> Self {
            self.clear = Some(input);
            self
        }
        /// <p>Displays a clear button.</p>
        pub fn set_clear(mut self, input: std::option::Option<crate::model::FormButton>) -> Self {
            self.clear = input;
            self
        }
        /// <p>Displays a cancel button.</p>
        pub fn cancel(mut self, input: crate::model::FormButton) -> Self {
            self.cancel = Some(input);
            self
        }
        /// <p>Displays a cancel button.</p>
        pub fn set_cancel(mut self, input: std::option::Option<crate::model::FormButton>) -> Self {
            self.cancel = input;
            self
        }
        /// <p>Displays a submit button.</p>
        pub fn submit(mut self, input: crate::model::FormButton) -> Self {
            self.submit = Some(input);
            self
        }
        /// <p>Displays a submit button.</p>
        pub fn set_submit(mut self, input: std::option::Option<crate::model::FormButton>) -> Self {
            self.submit = input;
            self
        }
        /// Consumes the builder and constructs a [`FormCta`](crate::model::FormCta).
        pub fn build(self) -> crate::model::FormCta {
            crate::model::FormCta {
                position: self.position,
                clear: self.clear,
                cancel: self.cancel,
                submit: self.submit,
            }
        }
    }
}
impl FormCta {
    /// Creates a new builder-style object to manufacture [`FormCta`](crate::model::FormCta).
    pub fn builder() -> crate::model::form_cta::Builder {
        crate::model::form_cta::Builder::default()
    }
}

/// <p>Describes the configuration for a button UI element that is a part of a form.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FormButton {
    /// <p>Specifies whether the button is visible on the form.</p>
    #[doc(hidden)]
    pub excluded: std::option::Option<bool>,
    /// <p>Describes the button's properties.</p>
    #[doc(hidden)]
    pub children: std::option::Option<std::string::String>,
    /// <p>The position of the button.</p>
    #[doc(hidden)]
    pub position: std::option::Option<crate::model::FieldPosition>,
}
impl FormButton {
    /// <p>Specifies whether the button is visible on the form.</p>
    pub fn excluded(&self) -> std::option::Option<bool> {
        self.excluded
    }
    /// <p>Describes the button's properties.</p>
    pub fn children(&self) -> std::option::Option<&str> {
        self.children.as_deref()
    }
    /// <p>The position of the button.</p>
    pub fn position(&self) -> std::option::Option<&crate::model::FieldPosition> {
        self.position.as_ref()
    }
}
/// See [`FormButton`](crate::model::FormButton).
pub mod form_button {

    /// A builder for [`FormButton`](crate::model::FormButton).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) excluded: std::option::Option<bool>,
        pub(crate) children: std::option::Option<std::string::String>,
        pub(crate) position: std::option::Option<crate::model::FieldPosition>,
    }
    impl Builder {
        /// <p>Specifies whether the button is visible on the form.</p>
        pub fn excluded(mut self, input: bool) -> Self {
            self.excluded = Some(input);
            self
        }
        /// <p>Specifies whether the button is visible on the form.</p>
        pub fn set_excluded(mut self, input: std::option::Option<bool>) -> Self {
            self.excluded = input;
            self
        }
        /// <p>Describes the button's properties.</p>
        pub fn children(mut self, input: impl Into<std::string::String>) -> Self {
            self.children = Some(input.into());
            self
        }
        /// <p>Describes the button's properties.</p>
        pub fn set_children(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.children = input;
            self
        }
        /// <p>The position of the button.</p>
        pub fn position(mut self, input: crate::model::FieldPosition) -> Self {
            self.position = Some(input);
            self
        }
        /// <p>The position of the button.</p>
        pub fn set_position(
            mut self,
            input: std::option::Option<crate::model::FieldPosition>,
        ) -> Self {
            self.position = input;
            self
        }
        /// Consumes the builder and constructs a [`FormButton`](crate::model::FormButton).
        pub fn build(self) -> crate::model::FormButton {
            crate::model::FormButton {
                excluded: self.excluded,
                children: self.children,
                position: self.position,
            }
        }
    }
}
impl FormButton {
    /// Creates a new builder-style object to manufacture [`FormButton`](crate::model::FormButton).
    pub fn builder() -> crate::model::form_button::Builder {
        crate::model::form_button::Builder::default()
    }
}

/// <p>Describes the field position.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum FieldPosition {
    /// <p>The field position is below the field specified by the string.</p>
    Below(std::string::String),
    /// <p>The field position is fixed and doesn't change in relation to other fields.</p>
    Fixed(crate::model::FixedPosition),
    /// <p>The field position is to the right of the field specified by the string.</p>
    RightOf(std::string::String),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl FieldPosition {
    /// Tries to convert the enum instance into [`Below`](crate::model::FieldPosition::Below), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_below(&self) -> std::result::Result<&std::string::String, &Self> {
        if let FieldPosition::Below(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Below`](crate::model::FieldPosition::Below).
    pub fn is_below(&self) -> bool {
        self.as_below().is_ok()
    }
    /// Tries to convert the enum instance into [`Fixed`](crate::model::FieldPosition::Fixed), extracting the inner [`FixedPosition`](crate::model::FixedPosition).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_fixed(&self) -> std::result::Result<&crate::model::FixedPosition, &Self> {
        if let FieldPosition::Fixed(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Fixed`](crate::model::FieldPosition::Fixed).
    pub fn is_fixed(&self) -> bool {
        self.as_fixed().is_ok()
    }
    /// Tries to convert the enum instance into [`RightOf`](crate::model::FieldPosition::RightOf), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_right_of(&self) -> std::result::Result<&std::string::String, &Self> {
        if let FieldPosition::RightOf(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`RightOf`](crate::model::FieldPosition::RightOf).
    pub fn is_right_of(&self) -> bool {
        self.as_right_of().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// When writing a match expression against `FixedPosition`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let fixedposition = unimplemented!();
/// match fixedposition {
///     FixedPosition::First => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `fixedposition` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FixedPosition::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FixedPosition::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FixedPosition::NewFeature` is defined.
/// Specifically, when `fixedposition` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FixedPosition::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FixedPosition {
    #[allow(missing_docs)] // documentation missing in model
    First,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FixedPosition {
    fn from(s: &str) -> Self {
        match s {
            "first" => FixedPosition::First,
            other => FixedPosition::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for FixedPosition {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FixedPosition::from(s))
    }
}
impl FixedPosition {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FixedPosition::First => "first",
            FixedPosition::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["first"]
    }
}
impl AsRef<str> for FixedPosition {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `FormButtonsPosition`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let formbuttonsposition = unimplemented!();
/// match formbuttonsposition {
///     FormButtonsPosition::Bottom => { /* ... */ },
///     FormButtonsPosition::Top => { /* ... */ },
///     FormButtonsPosition::TopAndBottom => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `formbuttonsposition` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FormButtonsPosition::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FormButtonsPosition::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FormButtonsPosition::NewFeature` is defined.
/// Specifically, when `formbuttonsposition` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FormButtonsPosition::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FormButtonsPosition {
    #[allow(missing_docs)] // documentation missing in model
    Bottom,
    #[allow(missing_docs)] // documentation missing in model
    Top,
    #[allow(missing_docs)] // documentation missing in model
    TopAndBottom,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FormButtonsPosition {
    fn from(s: &str) -> Self {
        match s {
            "bottom" => FormButtonsPosition::Bottom,
            "top" => FormButtonsPosition::Top,
            "top_and_bottom" => FormButtonsPosition::TopAndBottom,
            other => {
                FormButtonsPosition::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for FormButtonsPosition {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FormButtonsPosition::from(s))
    }
}
impl FormButtonsPosition {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FormButtonsPosition::Bottom => "bottom",
            FormButtonsPosition::Top => "top",
            FormButtonsPosition::TopAndBottom => "top_and_bottom",
            FormButtonsPosition::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["bottom", "top", "top_and_bottom"]
    }
}
impl AsRef<str> for FormButtonsPosition {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Stores the configuration information for a visual helper element for a form. A sectional element can be a header, a text block, or a divider. These elements are static and not associated with any data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SectionalElement {
    /// <p>The type of sectional element. Valid values are <code>Heading</code>, <code>Text</code>, and <code>Divider</code>.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>Specifies the position of the text in a field for a <code>Text</code> sectional element.</p>
    #[doc(hidden)]
    pub position: std::option::Option<crate::model::FieldPosition>,
    /// <p>The text for a <code>Text</code> sectional element.</p>
    #[doc(hidden)]
    pub text: std::option::Option<std::string::String>,
    /// <p>Specifies the size of the font for a <code>Heading</code> sectional element. Valid values are <code>1 | 2 | 3 | 4 | 5 | 6</code>.</p>
    #[doc(hidden)]
    pub level: std::option::Option<i32>,
    /// <p>Specifies the orientation for a <code>Divider</code> sectional element. Valid values are <code>horizontal</code> or <code>vertical</code>.</p>
    #[doc(hidden)]
    pub orientation: std::option::Option<std::string::String>,
}
impl SectionalElement {
    /// <p>The type of sectional element. Valid values are <code>Heading</code>, <code>Text</code>, and <code>Divider</code>.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>Specifies the position of the text in a field for a <code>Text</code> sectional element.</p>
    pub fn position(&self) -> std::option::Option<&crate::model::FieldPosition> {
        self.position.as_ref()
    }
    /// <p>The text for a <code>Text</code> sectional element.</p>
    pub fn text(&self) -> std::option::Option<&str> {
        self.text.as_deref()
    }
    /// <p>Specifies the size of the font for a <code>Heading</code> sectional element. Valid values are <code>1 | 2 | 3 | 4 | 5 | 6</code>.</p>
    pub fn level(&self) -> std::option::Option<i32> {
        self.level
    }
    /// <p>Specifies the orientation for a <code>Divider</code> sectional element. Valid values are <code>horizontal</code> or <code>vertical</code>.</p>
    pub fn orientation(&self) -> std::option::Option<&str> {
        self.orientation.as_deref()
    }
}
/// See [`SectionalElement`](crate::model::SectionalElement).
pub mod sectional_element {

    /// A builder for [`SectionalElement`](crate::model::SectionalElement).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) position: std::option::Option<crate::model::FieldPosition>,
        pub(crate) text: std::option::Option<std::string::String>,
        pub(crate) level: std::option::Option<i32>,
        pub(crate) orientation: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of sectional element. Valid values are <code>Heading</code>, <code>Text</code>, and <code>Divider</code>.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of sectional element. Valid values are <code>Heading</code>, <code>Text</code>, and <code>Divider</code>.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Specifies the position of the text in a field for a <code>Text</code> sectional element.</p>
        pub fn position(mut self, input: crate::model::FieldPosition) -> Self {
            self.position = Some(input);
            self
        }
        /// <p>Specifies the position of the text in a field for a <code>Text</code> sectional element.</p>
        pub fn set_position(
            mut self,
            input: std::option::Option<crate::model::FieldPosition>,
        ) -> Self {
            self.position = input;
            self
        }
        /// <p>The text for a <code>Text</code> sectional element.</p>
        pub fn text(mut self, input: impl Into<std::string::String>) -> Self {
            self.text = Some(input.into());
            self
        }
        /// <p>The text for a <code>Text</code> sectional element.</p>
        pub fn set_text(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.text = input;
            self
        }
        /// <p>Specifies the size of the font for a <code>Heading</code> sectional element. Valid values are <code>1 | 2 | 3 | 4 | 5 | 6</code>.</p>
        pub fn level(mut self, input: i32) -> Self {
            self.level = Some(input);
            self
        }
        /// <p>Specifies the size of the font for a <code>Heading</code> sectional element. Valid values are <code>1 | 2 | 3 | 4 | 5 | 6</code>.</p>
        pub fn set_level(mut self, input: std::option::Option<i32>) -> Self {
            self.level = input;
            self
        }
        /// <p>Specifies the orientation for a <code>Divider</code> sectional element. Valid values are <code>horizontal</code> or <code>vertical</code>.</p>
        pub fn orientation(mut self, input: impl Into<std::string::String>) -> Self {
            self.orientation = Some(input.into());
            self
        }
        /// <p>Specifies the orientation for a <code>Divider</code> sectional element. Valid values are <code>horizontal</code> or <code>vertical</code>.</p>
        pub fn set_orientation(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.orientation = input;
            self
        }
        /// Consumes the builder and constructs a [`SectionalElement`](crate::model::SectionalElement).
        pub fn build(self) -> crate::model::SectionalElement {
            crate::model::SectionalElement {
                r#type: self.r#type,
                position: self.position,
                text: self.text,
                level: self.level,
                orientation: self.orientation,
            }
        }
    }
}
impl SectionalElement {
    /// Creates a new builder-style object to manufacture [`SectionalElement`](crate::model::SectionalElement).
    pub fn builder() -> crate::model::sectional_element::Builder {
        crate::model::sectional_element::Builder::default()
    }
}

/// <p>Describes the configuration information for a field in a table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FieldConfig {
    /// <p>The label for the field.</p>
    #[doc(hidden)]
    pub label: std::option::Option<std::string::String>,
    /// <p>Specifies the field position.</p>
    #[doc(hidden)]
    pub position: std::option::Option<crate::model::FieldPosition>,
    /// <p>Specifies whether to hide a field.</p>
    #[doc(hidden)]
    pub excluded: std::option::Option<bool>,
    /// <p>Describes the configuration for the default input value to display for a field.</p>
    #[doc(hidden)]
    pub input_type: std::option::Option<crate::model::FieldInputConfig>,
    /// <p>The validations to perform on the value in the field.</p>
    #[doc(hidden)]
    pub validations: std::option::Option<std::vec::Vec<crate::model::FieldValidationConfiguration>>,
}
impl FieldConfig {
    /// <p>The label for the field.</p>
    pub fn label(&self) -> std::option::Option<&str> {
        self.label.as_deref()
    }
    /// <p>Specifies the field position.</p>
    pub fn position(&self) -> std::option::Option<&crate::model::FieldPosition> {
        self.position.as_ref()
    }
    /// <p>Specifies whether to hide a field.</p>
    pub fn excluded(&self) -> std::option::Option<bool> {
        self.excluded
    }
    /// <p>Describes the configuration for the default input value to display for a field.</p>
    pub fn input_type(&self) -> std::option::Option<&crate::model::FieldInputConfig> {
        self.input_type.as_ref()
    }
    /// <p>The validations to perform on the value in the field.</p>
    pub fn validations(
        &self,
    ) -> std::option::Option<&[crate::model::FieldValidationConfiguration]> {
        self.validations.as_deref()
    }
}
/// See [`FieldConfig`](crate::model::FieldConfig).
pub mod field_config {

    /// A builder for [`FieldConfig`](crate::model::FieldConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) label: std::option::Option<std::string::String>,
        pub(crate) position: std::option::Option<crate::model::FieldPosition>,
        pub(crate) excluded: std::option::Option<bool>,
        pub(crate) input_type: std::option::Option<crate::model::FieldInputConfig>,
        pub(crate) validations:
            std::option::Option<std::vec::Vec<crate::model::FieldValidationConfiguration>>,
    }
    impl Builder {
        /// <p>The label for the field.</p>
        pub fn label(mut self, input: impl Into<std::string::String>) -> Self {
            self.label = Some(input.into());
            self
        }
        /// <p>The label for the field.</p>
        pub fn set_label(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.label = input;
            self
        }
        /// <p>Specifies the field position.</p>
        pub fn position(mut self, input: crate::model::FieldPosition) -> Self {
            self.position = Some(input);
            self
        }
        /// <p>Specifies the field position.</p>
        pub fn set_position(
            mut self,
            input: std::option::Option<crate::model::FieldPosition>,
        ) -> Self {
            self.position = input;
            self
        }
        /// <p>Specifies whether to hide a field.</p>
        pub fn excluded(mut self, input: bool) -> Self {
            self.excluded = Some(input);
            self
        }
        /// <p>Specifies whether to hide a field.</p>
        pub fn set_excluded(mut self, input: std::option::Option<bool>) -> Self {
            self.excluded = input;
            self
        }
        /// <p>Describes the configuration for the default input value to display for a field.</p>
        pub fn input_type(mut self, input: crate::model::FieldInputConfig) -> Self {
            self.input_type = Some(input);
            self
        }
        /// <p>Describes the configuration for the default input value to display for a field.</p>
        pub fn set_input_type(
            mut self,
            input: std::option::Option<crate::model::FieldInputConfig>,
        ) -> Self {
            self.input_type = input;
            self
        }
        /// Appends an item to `validations`.
        ///
        /// To override the contents of this collection use [`set_validations`](Self::set_validations).
        ///
        /// <p>The validations to perform on the value in the field.</p>
        pub fn validations(mut self, input: crate::model::FieldValidationConfiguration) -> Self {
            let mut v = self.validations.unwrap_or_default();
            v.push(input);
            self.validations = Some(v);
            self
        }
        /// <p>The validations to perform on the value in the field.</p>
        pub fn set_validations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FieldValidationConfiguration>>,
        ) -> Self {
            self.validations = input;
            self
        }
        /// Consumes the builder and constructs a [`FieldConfig`](crate::model::FieldConfig).
        pub fn build(self) -> crate::model::FieldConfig {
            crate::model::FieldConfig {
                label: self.label,
                position: self.position,
                excluded: self.excluded,
                input_type: self.input_type,
                validations: self.validations,
            }
        }
    }
}
impl FieldConfig {
    /// Creates a new builder-style object to manufacture [`FieldConfig`](crate::model::FieldConfig).
    pub fn builder() -> crate::model::field_config::Builder {
        crate::model::field_config::Builder::default()
    }
}

/// <p>Describes the validation configuration for a field.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FieldValidationConfiguration {
    /// <p>The validation to perform on an object type.<code></code> </p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The validation to perform on a string value.</p>
    #[doc(hidden)]
    pub str_values: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The validation to perform on a number value.</p>
    #[doc(hidden)]
    pub num_values: std::option::Option<std::vec::Vec<i32>>,
    /// <p>The validation message to display.</p>
    #[doc(hidden)]
    pub validation_message: std::option::Option<std::string::String>,
}
impl FieldValidationConfiguration {
    /// <p>The validation to perform on an object type.<code></code> </p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The validation to perform on a string value.</p>
    pub fn str_values(&self) -> std::option::Option<&[std::string::String]> {
        self.str_values.as_deref()
    }
    /// <p>The validation to perform on a number value.</p>
    pub fn num_values(&self) -> std::option::Option<&[i32]> {
        self.num_values.as_deref()
    }
    /// <p>The validation message to display.</p>
    pub fn validation_message(&self) -> std::option::Option<&str> {
        self.validation_message.as_deref()
    }
}
/// See [`FieldValidationConfiguration`](crate::model::FieldValidationConfiguration).
pub mod field_validation_configuration {

    /// A builder for [`FieldValidationConfiguration`](crate::model::FieldValidationConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) str_values: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) num_values: std::option::Option<std::vec::Vec<i32>>,
        pub(crate) validation_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The validation to perform on an object type.<code></code> </p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The validation to perform on an object type.<code></code> </p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Appends an item to `str_values`.
        ///
        /// To override the contents of this collection use [`set_str_values`](Self::set_str_values).
        ///
        /// <p>The validation to perform on a string value.</p>
        pub fn str_values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.str_values.unwrap_or_default();
            v.push(input.into());
            self.str_values = Some(v);
            self
        }
        /// <p>The validation to perform on a string value.</p>
        pub fn set_str_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.str_values = input;
            self
        }
        /// Appends an item to `num_values`.
        ///
        /// To override the contents of this collection use [`set_num_values`](Self::set_num_values).
        ///
        /// <p>The validation to perform on a number value.</p>
        pub fn num_values(mut self, input: i32) -> Self {
            let mut v = self.num_values.unwrap_or_default();
            v.push(input);
            self.num_values = Some(v);
            self
        }
        /// <p>The validation to perform on a number value.</p>
        pub fn set_num_values(mut self, input: std::option::Option<std::vec::Vec<i32>>) -> Self {
            self.num_values = input;
            self
        }
        /// <p>The validation message to display.</p>
        pub fn validation_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.validation_message = Some(input.into());
            self
        }
        /// <p>The validation message to display.</p>
        pub fn set_validation_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.validation_message = input;
            self
        }
        /// Consumes the builder and constructs a [`FieldValidationConfiguration`](crate::model::FieldValidationConfiguration).
        pub fn build(self) -> crate::model::FieldValidationConfiguration {
            crate::model::FieldValidationConfiguration {
                r#type: self.r#type,
                str_values: self.str_values,
                num_values: self.num_values,
                validation_message: self.validation_message,
            }
        }
    }
}
impl FieldValidationConfiguration {
    /// Creates a new builder-style object to manufacture [`FieldValidationConfiguration`](crate::model::FieldValidationConfiguration).
    pub fn builder() -> crate::model::field_validation_configuration::Builder {
        crate::model::field_validation_configuration::Builder::default()
    }
}

/// <p>Describes the configuration for the default input values to display for a field.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FieldInputConfig {
    /// <p>The input type for the field. </p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>Specifies a field that requires input.</p>
    #[doc(hidden)]
    pub required: std::option::Option<bool>,
    /// <p>Specifies a read only field.</p>
    #[doc(hidden)]
    pub read_only: std::option::Option<bool>,
    /// <p>The text to display as a placeholder for the field.</p>
    #[doc(hidden)]
    pub placeholder: std::option::Option<std::string::String>,
    /// <p>The default value for the field.</p>
    #[doc(hidden)]
    pub default_value: std::option::Option<std::string::String>,
    /// <p>The text to display to describe the field.</p>
    #[doc(hidden)]
    pub descriptive_text: std::option::Option<std::string::String>,
    /// <p>Specifies whether a field has a default value.</p>
    #[doc(hidden)]
    pub default_checked: std::option::Option<bool>,
    /// <p>The default country code for a phone number.</p>
    #[doc(hidden)]
    pub default_country_code: std::option::Option<std::string::String>,
    /// <p>The information to use to customize the input fields with data at runtime.</p>
    #[doc(hidden)]
    pub value_mappings: std::option::Option<crate::model::ValueMappings>,
    /// <p>The name of the field.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The minimum value to display for the field.</p>
    #[doc(hidden)]
    pub min_value: std::option::Option<f32>,
    /// <p>The maximum value to display for the field.</p>
    #[doc(hidden)]
    pub max_value: std::option::Option<f32>,
    /// <p>The stepping increment for a numeric value in a field.</p>
    #[doc(hidden)]
    pub step: std::option::Option<f32>,
    /// <p>The value for the field.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
    /// <p>Specifies whether to render the field as an array. This property is ignored if the <code>dataSourceType</code> for the form is a Data Store.</p>
    #[doc(hidden)]
    pub is_array: std::option::Option<bool>,
}
impl FieldInputConfig {
    /// <p>The input type for the field. </p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>Specifies a field that requires input.</p>
    pub fn required(&self) -> std::option::Option<bool> {
        self.required
    }
    /// <p>Specifies a read only field.</p>
    pub fn read_only(&self) -> std::option::Option<bool> {
        self.read_only
    }
    /// <p>The text to display as a placeholder for the field.</p>
    pub fn placeholder(&self) -> std::option::Option<&str> {
        self.placeholder.as_deref()
    }
    /// <p>The default value for the field.</p>
    pub fn default_value(&self) -> std::option::Option<&str> {
        self.default_value.as_deref()
    }
    /// <p>The text to display to describe the field.</p>
    pub fn descriptive_text(&self) -> std::option::Option<&str> {
        self.descriptive_text.as_deref()
    }
    /// <p>Specifies whether a field has a default value.</p>
    pub fn default_checked(&self) -> std::option::Option<bool> {
        self.default_checked
    }
    /// <p>The default country code for a phone number.</p>
    pub fn default_country_code(&self) -> std::option::Option<&str> {
        self.default_country_code.as_deref()
    }
    /// <p>The information to use to customize the input fields with data at runtime.</p>
    pub fn value_mappings(&self) -> std::option::Option<&crate::model::ValueMappings> {
        self.value_mappings.as_ref()
    }
    /// <p>The name of the field.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The minimum value to display for the field.</p>
    pub fn min_value(&self) -> std::option::Option<f32> {
        self.min_value
    }
    /// <p>The maximum value to display for the field.</p>
    pub fn max_value(&self) -> std::option::Option<f32> {
        self.max_value
    }
    /// <p>The stepping increment for a numeric value in a field.</p>
    pub fn step(&self) -> std::option::Option<f32> {
        self.step
    }
    /// <p>The value for the field.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
    /// <p>Specifies whether to render the field as an array. This property is ignored if the <code>dataSourceType</code> for the form is a Data Store.</p>
    pub fn is_array(&self) -> std::option::Option<bool> {
        self.is_array
    }
}
/// See [`FieldInputConfig`](crate::model::FieldInputConfig).
pub mod field_input_config {

    /// A builder for [`FieldInputConfig`](crate::model::FieldInputConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) required: std::option::Option<bool>,
        pub(crate) read_only: std::option::Option<bool>,
        pub(crate) placeholder: std::option::Option<std::string::String>,
        pub(crate) default_value: std::option::Option<std::string::String>,
        pub(crate) descriptive_text: std::option::Option<std::string::String>,
        pub(crate) default_checked: std::option::Option<bool>,
        pub(crate) default_country_code: std::option::Option<std::string::String>,
        pub(crate) value_mappings: std::option::Option<crate::model::ValueMappings>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) min_value: std::option::Option<f32>,
        pub(crate) max_value: std::option::Option<f32>,
        pub(crate) step: std::option::Option<f32>,
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) is_array: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The input type for the field. </p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The input type for the field. </p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Specifies a field that requires input.</p>
        pub fn required(mut self, input: bool) -> Self {
            self.required = Some(input);
            self
        }
        /// <p>Specifies a field that requires input.</p>
        pub fn set_required(mut self, input: std::option::Option<bool>) -> Self {
            self.required = input;
            self
        }
        /// <p>Specifies a read only field.</p>
        pub fn read_only(mut self, input: bool) -> Self {
            self.read_only = Some(input);
            self
        }
        /// <p>Specifies a read only field.</p>
        pub fn set_read_only(mut self, input: std::option::Option<bool>) -> Self {
            self.read_only = input;
            self
        }
        /// <p>The text to display as a placeholder for the field.</p>
        pub fn placeholder(mut self, input: impl Into<std::string::String>) -> Self {
            self.placeholder = Some(input.into());
            self
        }
        /// <p>The text to display as a placeholder for the field.</p>
        pub fn set_placeholder(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.placeholder = input;
            self
        }
        /// <p>The default value for the field.</p>
        pub fn default_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_value = Some(input.into());
            self
        }
        /// <p>The default value for the field.</p>
        pub fn set_default_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_value = input;
            self
        }
        /// <p>The text to display to describe the field.</p>
        pub fn descriptive_text(mut self, input: impl Into<std::string::String>) -> Self {
            self.descriptive_text = Some(input.into());
            self
        }
        /// <p>The text to display to describe the field.</p>
        pub fn set_descriptive_text(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.descriptive_text = input;
            self
        }
        /// <p>Specifies whether a field has a default value.</p>
        pub fn default_checked(mut self, input: bool) -> Self {
            self.default_checked = Some(input);
            self
        }
        /// <p>Specifies whether a field has a default value.</p>
        pub fn set_default_checked(mut self, input: std::option::Option<bool>) -> Self {
            self.default_checked = input;
            self
        }
        /// <p>The default country code for a phone number.</p>
        pub fn default_country_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_country_code = Some(input.into());
            self
        }
        /// <p>The default country code for a phone number.</p>
        pub fn set_default_country_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_country_code = input;
            self
        }
        /// <p>The information to use to customize the input fields with data at runtime.</p>
        pub fn value_mappings(mut self, input: crate::model::ValueMappings) -> Self {
            self.value_mappings = Some(input);
            self
        }
        /// <p>The information to use to customize the input fields with data at runtime.</p>
        pub fn set_value_mappings(
            mut self,
            input: std::option::Option<crate::model::ValueMappings>,
        ) -> Self {
            self.value_mappings = input;
            self
        }
        /// <p>The name of the field.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the field.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The minimum value to display for the field.</p>
        pub fn min_value(mut self, input: f32) -> Self {
            self.min_value = Some(input);
            self
        }
        /// <p>The minimum value to display for the field.</p>
        pub fn set_min_value(mut self, input: std::option::Option<f32>) -> Self {
            self.min_value = input;
            self
        }
        /// <p>The maximum value to display for the field.</p>
        pub fn max_value(mut self, input: f32) -> Self {
            self.max_value = Some(input);
            self
        }
        /// <p>The maximum value to display for the field.</p>
        pub fn set_max_value(mut self, input: std::option::Option<f32>) -> Self {
            self.max_value = input;
            self
        }
        /// <p>The stepping increment for a numeric value in a field.</p>
        pub fn step(mut self, input: f32) -> Self {
            self.step = Some(input);
            self
        }
        /// <p>The stepping increment for a numeric value in a field.</p>
        pub fn set_step(mut self, input: std::option::Option<f32>) -> Self {
            self.step = input;
            self
        }
        /// <p>The value for the field.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value for the field.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p>Specifies whether to render the field as an array. This property is ignored if the <code>dataSourceType</code> for the form is a Data Store.</p>
        pub fn is_array(mut self, input: bool) -> Self {
            self.is_array = Some(input);
            self
        }
        /// <p>Specifies whether to render the field as an array. This property is ignored if the <code>dataSourceType</code> for the form is a Data Store.</p>
        pub fn set_is_array(mut self, input: std::option::Option<bool>) -> Self {
            self.is_array = input;
            self
        }
        /// Consumes the builder and constructs a [`FieldInputConfig`](crate::model::FieldInputConfig).
        pub fn build(self) -> crate::model::FieldInputConfig {
            crate::model::FieldInputConfig {
                r#type: self.r#type,
                required: self.required,
                read_only: self.read_only,
                placeholder: self.placeholder,
                default_value: self.default_value,
                descriptive_text: self.descriptive_text,
                default_checked: self.default_checked,
                default_country_code: self.default_country_code,
                value_mappings: self.value_mappings,
                name: self.name,
                min_value: self.min_value,
                max_value: self.max_value,
                step: self.step,
                value: self.value,
                is_array: self.is_array,
            }
        }
    }
}
impl FieldInputConfig {
    /// Creates a new builder-style object to manufacture [`FieldInputConfig`](crate::model::FieldInputConfig).
    pub fn builder() -> crate::model::field_input_config::Builder {
        crate::model::field_input_config::Builder::default()
    }
}

/// <p>Represents the data binding configuration for a value map.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ValueMappings {
    /// <p>The value and display value pairs.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<crate::model::ValueMapping>>,
}
impl ValueMappings {
    /// <p>The value and display value pairs.</p>
    pub fn values(&self) -> std::option::Option<&[crate::model::ValueMapping]> {
        self.values.as_deref()
    }
}
/// See [`ValueMappings`](crate::model::ValueMappings).
pub mod value_mappings {

    /// A builder for [`ValueMappings`](crate::model::ValueMappings).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) values: std::option::Option<std::vec::Vec<crate::model::ValueMapping>>,
    }
    impl Builder {
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The value and display value pairs.</p>
        pub fn values(mut self, input: crate::model::ValueMapping) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input);
            self.values = Some(v);
            self
        }
        /// <p>The value and display value pairs.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ValueMapping>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`ValueMappings`](crate::model::ValueMappings).
        pub fn build(self) -> crate::model::ValueMappings {
            crate::model::ValueMappings {
                values: self.values,
            }
        }
    }
}
impl ValueMappings {
    /// Creates a new builder-style object to manufacture [`ValueMappings`](crate::model::ValueMappings).
    pub fn builder() -> crate::model::value_mappings::Builder {
        crate::model::value_mappings::Builder::default()
    }
}

/// <p>Associates a complex object with a display value. Use <code>ValueMapping</code> to store how to represent complex objects when they are displayed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ValueMapping {
    /// <p>The value to display for the complex object.</p>
    #[doc(hidden)]
    pub display_value: std::option::Option<crate::model::FormInputValueProperty>,
    /// <p>The complex object.</p>
    #[doc(hidden)]
    pub value: std::option::Option<crate::model::FormInputValueProperty>,
}
impl ValueMapping {
    /// <p>The value to display for the complex object.</p>
    pub fn display_value(&self) -> std::option::Option<&crate::model::FormInputValueProperty> {
        self.display_value.as_ref()
    }
    /// <p>The complex object.</p>
    pub fn value(&self) -> std::option::Option<&crate::model::FormInputValueProperty> {
        self.value.as_ref()
    }
}
/// See [`ValueMapping`](crate::model::ValueMapping).
pub mod value_mapping {

    /// A builder for [`ValueMapping`](crate::model::ValueMapping).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) display_value: std::option::Option<crate::model::FormInputValueProperty>,
        pub(crate) value: std::option::Option<crate::model::FormInputValueProperty>,
    }
    impl Builder {
        /// <p>The value to display for the complex object.</p>
        pub fn display_value(mut self, input: crate::model::FormInputValueProperty) -> Self {
            self.display_value = Some(input);
            self
        }
        /// <p>The value to display for the complex object.</p>
        pub fn set_display_value(
            mut self,
            input: std::option::Option<crate::model::FormInputValueProperty>,
        ) -> Self {
            self.display_value = input;
            self
        }
        /// <p>The complex object.</p>
        pub fn value(mut self, input: crate::model::FormInputValueProperty) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The complex object.</p>
        pub fn set_value(
            mut self,
            input: std::option::Option<crate::model::FormInputValueProperty>,
        ) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`ValueMapping`](crate::model::ValueMapping).
        pub fn build(self) -> crate::model::ValueMapping {
            crate::model::ValueMapping {
                display_value: self.display_value,
                value: self.value,
            }
        }
    }
}
impl ValueMapping {
    /// Creates a new builder-style object to manufacture [`ValueMapping`](crate::model::ValueMapping).
    pub fn builder() -> crate::model::value_mapping::Builder {
        crate::model::value_mapping::Builder::default()
    }
}

/// <p>Describes the configuration for an input field on a form. Use <code>FormInputValueProperty</code> to specify the values to render or bind by default.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FormInputValueProperty {
    /// <p>The value to assign to the input field.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl FormInputValueProperty {
    /// <p>The value to assign to the input field.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`FormInputValueProperty`](crate::model::FormInputValueProperty).
pub mod form_input_value_property {

    /// A builder for [`FormInputValueProperty`](crate::model::FormInputValueProperty).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The value to assign to the input field.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value to assign to the input field.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`FormInputValueProperty`](crate::model::FormInputValueProperty).
        pub fn build(self) -> crate::model::FormInputValueProperty {
            crate::model::FormInputValueProperty { value: self.value }
        }
    }
}
impl FormInputValueProperty {
    /// Creates a new builder-style object to manufacture [`FormInputValueProperty`](crate::model::FormInputValueProperty).
    pub fn builder() -> crate::model::form_input_value_property::Builder {
        crate::model::form_input_value_property::Builder::default()
    }
}

/// <p>Describes the data type configuration for the data source associated with a form.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FormDataTypeConfig {
    /// <p>The data source type, either an Amplify DataStore model or a custom data type.</p>
    #[doc(hidden)]
    pub data_source_type: std::option::Option<crate::model::FormDataSourceType>,
    /// <p>The unique name of the data type you are using as the data source for the form.</p>
    #[doc(hidden)]
    pub data_type_name: std::option::Option<std::string::String>,
}
impl FormDataTypeConfig {
    /// <p>The data source type, either an Amplify DataStore model or a custom data type.</p>
    pub fn data_source_type(&self) -> std::option::Option<&crate::model::FormDataSourceType> {
        self.data_source_type.as_ref()
    }
    /// <p>The unique name of the data type you are using as the data source for the form.</p>
    pub fn data_type_name(&self) -> std::option::Option<&str> {
        self.data_type_name.as_deref()
    }
}
/// See [`FormDataTypeConfig`](crate::model::FormDataTypeConfig).
pub mod form_data_type_config {

    /// A builder for [`FormDataTypeConfig`](crate::model::FormDataTypeConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_source_type: std::option::Option<crate::model::FormDataSourceType>,
        pub(crate) data_type_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The data source type, either an Amplify DataStore model or a custom data type.</p>
        pub fn data_source_type(mut self, input: crate::model::FormDataSourceType) -> Self {
            self.data_source_type = Some(input);
            self
        }
        /// <p>The data source type, either an Amplify DataStore model or a custom data type.</p>
        pub fn set_data_source_type(
            mut self,
            input: std::option::Option<crate::model::FormDataSourceType>,
        ) -> Self {
            self.data_source_type = input;
            self
        }
        /// <p>The unique name of the data type you are using as the data source for the form.</p>
        pub fn data_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_type_name = Some(input.into());
            self
        }
        /// <p>The unique name of the data type you are using as the data source for the form.</p>
        pub fn set_data_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_type_name = input;
            self
        }
        /// Consumes the builder and constructs a [`FormDataTypeConfig`](crate::model::FormDataTypeConfig).
        pub fn build(self) -> crate::model::FormDataTypeConfig {
            crate::model::FormDataTypeConfig {
                data_source_type: self.data_source_type,
                data_type_name: self.data_type_name,
            }
        }
    }
}
impl FormDataTypeConfig {
    /// Creates a new builder-style object to manufacture [`FormDataTypeConfig`](crate::model::FormDataTypeConfig).
    pub fn builder() -> crate::model::form_data_type_config::Builder {
        crate::model::form_data_type_config::Builder::default()
    }
}

/// When writing a match expression against `FormDataSourceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let formdatasourcetype = unimplemented!();
/// match formdatasourcetype {
///     FormDataSourceType::Custom => { /* ... */ },
///     FormDataSourceType::Datastore => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `formdatasourcetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FormDataSourceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FormDataSourceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FormDataSourceType::NewFeature` is defined.
/// Specifically, when `formdatasourcetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FormDataSourceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FormDataSourceType {
    /// Will use passed in hooks to use when creating a form from scratch
    Custom,
    /// Will use a provided Amplify DataStore enabled API
    Datastore,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FormDataSourceType {
    fn from(s: &str) -> Self {
        match s {
            "Custom" => FormDataSourceType::Custom,
            "DataStore" => FormDataSourceType::Datastore,
            other => {
                FormDataSourceType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for FormDataSourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FormDataSourceType::from(s))
    }
}
impl FormDataSourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FormDataSourceType::Custom => "Custom",
            FormDataSourceType::Datastore => "DataStore",
            FormDataSourceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Custom", "DataStore"]
    }
}
impl AsRef<str> for FormDataSourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the configuration for the form's style.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FormStyle {
    /// <p>The spacing for the horizontal gap.</p>
    #[doc(hidden)]
    pub horizontal_gap: std::option::Option<crate::model::FormStyleConfig>,
    /// <p>The spacing for the vertical gap.</p>
    #[doc(hidden)]
    pub vertical_gap: std::option::Option<crate::model::FormStyleConfig>,
    /// <p>The size of the outer padding for the form.</p>
    #[doc(hidden)]
    pub outer_padding: std::option::Option<crate::model::FormStyleConfig>,
}
impl FormStyle {
    /// <p>The spacing for the horizontal gap.</p>
    pub fn horizontal_gap(&self) -> std::option::Option<&crate::model::FormStyleConfig> {
        self.horizontal_gap.as_ref()
    }
    /// <p>The spacing for the vertical gap.</p>
    pub fn vertical_gap(&self) -> std::option::Option<&crate::model::FormStyleConfig> {
        self.vertical_gap.as_ref()
    }
    /// <p>The size of the outer padding for the form.</p>
    pub fn outer_padding(&self) -> std::option::Option<&crate::model::FormStyleConfig> {
        self.outer_padding.as_ref()
    }
}
/// See [`FormStyle`](crate::model::FormStyle).
pub mod form_style {

    /// A builder for [`FormStyle`](crate::model::FormStyle).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) horizontal_gap: std::option::Option<crate::model::FormStyleConfig>,
        pub(crate) vertical_gap: std::option::Option<crate::model::FormStyleConfig>,
        pub(crate) outer_padding: std::option::Option<crate::model::FormStyleConfig>,
    }
    impl Builder {
        /// <p>The spacing for the horizontal gap.</p>
        pub fn horizontal_gap(mut self, input: crate::model::FormStyleConfig) -> Self {
            self.horizontal_gap = Some(input);
            self
        }
        /// <p>The spacing for the horizontal gap.</p>
        pub fn set_horizontal_gap(
            mut self,
            input: std::option::Option<crate::model::FormStyleConfig>,
        ) -> Self {
            self.horizontal_gap = input;
            self
        }
        /// <p>The spacing for the vertical gap.</p>
        pub fn vertical_gap(mut self, input: crate::model::FormStyleConfig) -> Self {
            self.vertical_gap = Some(input);
            self
        }
        /// <p>The spacing for the vertical gap.</p>
        pub fn set_vertical_gap(
            mut self,
            input: std::option::Option<crate::model::FormStyleConfig>,
        ) -> Self {
            self.vertical_gap = input;
            self
        }
        /// <p>The size of the outer padding for the form.</p>
        pub fn outer_padding(mut self, input: crate::model::FormStyleConfig) -> Self {
            self.outer_padding = Some(input);
            self
        }
        /// <p>The size of the outer padding for the form.</p>
        pub fn set_outer_padding(
            mut self,
            input: std::option::Option<crate::model::FormStyleConfig>,
        ) -> Self {
            self.outer_padding = input;
            self
        }
        /// Consumes the builder and constructs a [`FormStyle`](crate::model::FormStyle).
        pub fn build(self) -> crate::model::FormStyle {
            crate::model::FormStyle {
                horizontal_gap: self.horizontal_gap,
                vertical_gap: self.vertical_gap,
                outer_padding: self.outer_padding,
            }
        }
    }
}
impl FormStyle {
    /// Creates a new builder-style object to manufacture [`FormStyle`](crate::model::FormStyle).
    pub fn builder() -> crate::model::form_style::Builder {
        crate::model::form_style::Builder::default()
    }
}

/// <p>Describes the configuration settings for the form's style properties.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum FormStyleConfig {
    /// <p>A reference to a design token to use to bind the form's style properties to an existing theme.</p>
    TokenReference(std::string::String),
    /// <p>The value of the style setting.</p>
    Value(std::string::String),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl FormStyleConfig {
    /// Tries to convert the enum instance into [`TokenReference`](crate::model::FormStyleConfig::TokenReference), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_token_reference(&self) -> std::result::Result<&std::string::String, &Self> {
        if let FormStyleConfig::TokenReference(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`TokenReference`](crate::model::FormStyleConfig::TokenReference).
    pub fn is_token_reference(&self) -> bool {
        self.as_token_reference().is_ok()
    }
    /// Tries to convert the enum instance into [`Value`](crate::model::FormStyleConfig::Value), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_value(&self) -> std::result::Result<&std::string::String, &Self> {
        if let FormStyleConfig::Value(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Value`](crate::model::FormStyleConfig::Value).
    pub fn is_value(&self) -> bool {
        self.as_value().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// When writing a match expression against `FormActionType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let formactiontype = unimplemented!();
/// match formactiontype {
///     FormActionType::Create => { /* ... */ },
///     FormActionType::Update => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `formactiontype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FormActionType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FormActionType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FormActionType::NewFeature` is defined.
/// Specifically, when `formactiontype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FormActionType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FormActionType {
    #[allow(missing_docs)] // documentation missing in model
    Create,
    #[allow(missing_docs)] // documentation missing in model
    Update,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FormActionType {
    fn from(s: &str) -> Self {
        match s {
            "create" => FormActionType::Create,
            "update" => FormActionType::Update,
            other => FormActionType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for FormActionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FormActionType::from(s))
    }
}
impl FormActionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FormActionType::Create => "create",
            FormActionType::Update => "update",
            FormActionType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["create", "update"]
    }
}
impl AsRef<str> for FormActionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the basic information about a form.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FormSummary {
    /// <p>The unique ID for the app associated with the form summary.</p>
    #[doc(hidden)]
    pub app_id: std::option::Option<std::string::String>,
    /// <p>The form's data source type.</p>
    #[doc(hidden)]
    pub data_type: std::option::Option<crate::model::FormDataTypeConfig>,
    /// <p>The name of the backend environment that is part of the Amplify app.</p>
    #[doc(hidden)]
    pub environment_name: std::option::Option<std::string::String>,
    /// <p>The type of operation to perform on the form.</p>
    #[doc(hidden)]
    pub form_action_type: std::option::Option<crate::model::FormActionType>,
    /// <p>The ID of the form.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the form.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl FormSummary {
    /// <p>The unique ID for the app associated with the form summary.</p>
    pub fn app_id(&self) -> std::option::Option<&str> {
        self.app_id.as_deref()
    }
    /// <p>The form's data source type.</p>
    pub fn data_type(&self) -> std::option::Option<&crate::model::FormDataTypeConfig> {
        self.data_type.as_ref()
    }
    /// <p>The name of the backend environment that is part of the Amplify app.</p>
    pub fn environment_name(&self) -> std::option::Option<&str> {
        self.environment_name.as_deref()
    }
    /// <p>The type of operation to perform on the form.</p>
    pub fn form_action_type(&self) -> std::option::Option<&crate::model::FormActionType> {
        self.form_action_type.as_ref()
    }
    /// <p>The ID of the form.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the form.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
/// See [`FormSummary`](crate::model::FormSummary).
pub mod form_summary {

    /// A builder for [`FormSummary`](crate::model::FormSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_id: std::option::Option<std::string::String>,
        pub(crate) data_type: std::option::Option<crate::model::FormDataTypeConfig>,
        pub(crate) environment_name: std::option::Option<std::string::String>,
        pub(crate) form_action_type: std::option::Option<crate::model::FormActionType>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique ID for the app associated with the form summary.</p>
        pub fn app_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_id = Some(input.into());
            self
        }
        /// <p>The unique ID for the app associated with the form summary.</p>
        pub fn set_app_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_id = input;
            self
        }
        /// <p>The form's data source type.</p>
        pub fn data_type(mut self, input: crate::model::FormDataTypeConfig) -> Self {
            self.data_type = Some(input);
            self
        }
        /// <p>The form's data source type.</p>
        pub fn set_data_type(
            mut self,
            input: std::option::Option<crate::model::FormDataTypeConfig>,
        ) -> Self {
            self.data_type = input;
            self
        }
        /// <p>The name of the backend environment that is part of the Amplify app.</p>
        pub fn environment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.environment_name = Some(input.into());
            self
        }
        /// <p>The name of the backend environment that is part of the Amplify app.</p>
        pub fn set_environment_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.environment_name = input;
            self
        }
        /// <p>The type of operation to perform on the form.</p>
        pub fn form_action_type(mut self, input: crate::model::FormActionType) -> Self {
            self.form_action_type = Some(input);
            self
        }
        /// <p>The type of operation to perform on the form.</p>
        pub fn set_form_action_type(
            mut self,
            input: std::option::Option<crate::model::FormActionType>,
        ) -> Self {
            self.form_action_type = input;
            self
        }
        /// <p>The ID of the form.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the form.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the form.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the form.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`FormSummary`](crate::model::FormSummary).
        pub fn build(self) -> crate::model::FormSummary {
            crate::model::FormSummary {
                app_id: self.app_id,
                data_type: self.data_type,
                environment_name: self.environment_name,
                form_action_type: self.form_action_type,
                id: self.id,
                name: self.name,
            }
        }
    }
}
impl FormSummary {
    /// Creates a new builder-style object to manufacture [`FormSummary`](crate::model::FormSummary).
    pub fn builder() -> crate::model::form_summary::Builder {
        crate::model::form_summary::Builder::default()
    }
}

/// <p>Represents all of the information that is required to create a form.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateFormData {
    /// <p>The name of the form.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of data source to use to create the form.</p>
    #[doc(hidden)]
    pub data_type: std::option::Option<crate::model::FormDataTypeConfig>,
    /// <p>Specifies whether to perform a create or update action on the form.</p>
    #[doc(hidden)]
    pub form_action_type: std::option::Option<crate::model::FormActionType>,
    /// <p>The configuration information for the form's fields.</p>
    #[doc(hidden)]
    pub fields: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::FieldConfig>,
    >,
    /// <p>The configuration for the form's style.</p>
    #[doc(hidden)]
    pub style: std::option::Option<crate::model::FormStyle>,
    /// <p>The configuration information for the visual helper elements for the form. These elements are not associated with any data.</p>
    #[doc(hidden)]
    pub sectional_elements: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::SectionalElement>,
    >,
    /// <p>The schema version of the form.</p>
    #[doc(hidden)]
    pub schema_version: std::option::Option<std::string::String>,
    /// <p>The <code>FormCTA</code> object that stores the call to action configuration for the form.</p>
    #[doc(hidden)]
    pub cta: std::option::Option<crate::model::FormCta>,
    /// <p>One or more key-value pairs to use when tagging the form data.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateFormData {
    /// <p>The name of the form.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of data source to use to create the form.</p>
    pub fn data_type(&self) -> std::option::Option<&crate::model::FormDataTypeConfig> {
        self.data_type.as_ref()
    }
    /// <p>Specifies whether to perform a create or update action on the form.</p>
    pub fn form_action_type(&self) -> std::option::Option<&crate::model::FormActionType> {
        self.form_action_type.as_ref()
    }
    /// <p>The configuration information for the form's fields.</p>
    pub fn fields(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::FieldConfig>,
    > {
        self.fields.as_ref()
    }
    /// <p>The configuration for the form's style.</p>
    pub fn style(&self) -> std::option::Option<&crate::model::FormStyle> {
        self.style.as_ref()
    }
    /// <p>The configuration information for the visual helper elements for the form. These elements are not associated with any data.</p>
    pub fn sectional_elements(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::SectionalElement>,
    > {
        self.sectional_elements.as_ref()
    }
    /// <p>The schema version of the form.</p>
    pub fn schema_version(&self) -> std::option::Option<&str> {
        self.schema_version.as_deref()
    }
    /// <p>The <code>FormCTA</code> object that stores the call to action configuration for the form.</p>
    pub fn cta(&self) -> std::option::Option<&crate::model::FormCta> {
        self.cta.as_ref()
    }
    /// <p>One or more key-value pairs to use when tagging the form data.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
/// See [`CreateFormData`](crate::model::CreateFormData).
pub mod create_form_data {

    /// A builder for [`CreateFormData`](crate::model::CreateFormData).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) data_type: std::option::Option<crate::model::FormDataTypeConfig>,
        pub(crate) form_action_type: std::option::Option<crate::model::FormActionType>,
        pub(crate) fields: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::FieldConfig>,
        >,
        pub(crate) style: std::option::Option<crate::model::FormStyle>,
        pub(crate) sectional_elements: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::SectionalElement>,
        >,
        pub(crate) schema_version: std::option::Option<std::string::String>,
        pub(crate) cta: std::option::Option<crate::model::FormCta>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The name of the form.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the form.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of data source to use to create the form.</p>
        pub fn data_type(mut self, input: crate::model::FormDataTypeConfig) -> Self {
            self.data_type = Some(input);
            self
        }
        /// <p>The type of data source to use to create the form.</p>
        pub fn set_data_type(
            mut self,
            input: std::option::Option<crate::model::FormDataTypeConfig>,
        ) -> Self {
            self.data_type = input;
            self
        }
        /// <p>Specifies whether to perform a create or update action on the form.</p>
        pub fn form_action_type(mut self, input: crate::model::FormActionType) -> Self {
            self.form_action_type = Some(input);
            self
        }
        /// <p>Specifies whether to perform a create or update action on the form.</p>
        pub fn set_form_action_type(
            mut self,
            input: std::option::Option<crate::model::FormActionType>,
        ) -> Self {
            self.form_action_type = input;
            self
        }
        /// Adds a key-value pair to `fields`.
        ///
        /// To override the contents of this collection use [`set_fields`](Self::set_fields).
        ///
        /// <p>The configuration information for the form's fields.</p>
        pub fn fields(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::FieldConfig,
        ) -> Self {
            let mut hash_map = self.fields.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.fields = Some(hash_map);
            self
        }
        /// <p>The configuration information for the form's fields.</p>
        pub fn set_fields(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::FieldConfig>,
            >,
        ) -> Self {
            self.fields = input;
            self
        }
        /// <p>The configuration for the form's style.</p>
        pub fn style(mut self, input: crate::model::FormStyle) -> Self {
            self.style = Some(input);
            self
        }
        /// <p>The configuration for the form's style.</p>
        pub fn set_style(mut self, input: std::option::Option<crate::model::FormStyle>) -> Self {
            self.style = input;
            self
        }
        /// Adds a key-value pair to `sectional_elements`.
        ///
        /// To override the contents of this collection use [`set_sectional_elements`](Self::set_sectional_elements).
        ///
        /// <p>The configuration information for the visual helper elements for the form. These elements are not associated with any data.</p>
        pub fn sectional_elements(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::SectionalElement,
        ) -> Self {
            let mut hash_map = self.sectional_elements.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.sectional_elements = Some(hash_map);
            self
        }
        /// <p>The configuration information for the visual helper elements for the form. These elements are not associated with any data.</p>
        pub fn set_sectional_elements(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::SectionalElement>,
            >,
        ) -> Self {
            self.sectional_elements = input;
            self
        }
        /// <p>The schema version of the form.</p>
        pub fn schema_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.schema_version = Some(input.into());
            self
        }
        /// <p>The schema version of the form.</p>
        pub fn set_schema_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.schema_version = input;
            self
        }
        /// <p>The <code>FormCTA</code> object that stores the call to action configuration for the form.</p>
        pub fn cta(mut self, input: crate::model::FormCta) -> Self {
            self.cta = Some(input);
            self
        }
        /// <p>The <code>FormCTA</code> object that stores the call to action configuration for the form.</p>
        pub fn set_cta(mut self, input: std::option::Option<crate::model::FormCta>) -> Self {
            self.cta = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>One or more key-value pairs to use when tagging the form data.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>One or more key-value pairs to use when tagging the form data.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateFormData`](crate::model::CreateFormData).
        pub fn build(self) -> crate::model::CreateFormData {
            crate::model::CreateFormData {
                name: self.name,
                data_type: self.data_type,
                form_action_type: self.form_action_type,
                fields: self.fields,
                style: self.style,
                sectional_elements: self.sectional_elements,
                schema_version: self.schema_version,
                cta: self.cta,
                tags: self.tags,
            }
        }
    }
}
impl CreateFormData {
    /// Creates a new builder-style object to manufacture [`CreateFormData`](crate::model::CreateFormData).
    pub fn builder() -> crate::model::create_form_data::Builder {
        crate::model::create_form_data::Builder::default()
    }
}

/// <p>Updates and saves all of the information about a form, based on form ID.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateFormData {
    /// <p>The name of the form.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of data source to use to create the form.</p>
    #[doc(hidden)]
    pub data_type: std::option::Option<crate::model::FormDataTypeConfig>,
    /// <p>Specifies whether to perform a create or update action on the form.</p>
    #[doc(hidden)]
    pub form_action_type: std::option::Option<crate::model::FormActionType>,
    /// <p>The configuration information for the form's fields.</p>
    #[doc(hidden)]
    pub fields: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::FieldConfig>,
    >,
    /// <p>The configuration for the form's style.</p>
    #[doc(hidden)]
    pub style: std::option::Option<crate::model::FormStyle>,
    /// <p>The configuration information for the visual helper elements for the form. These elements are not associated with any data.</p>
    #[doc(hidden)]
    pub sectional_elements: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::SectionalElement>,
    >,
    /// <p>The schema version of the form.</p>
    #[doc(hidden)]
    pub schema_version: std::option::Option<std::string::String>,
    /// <p>The <code>FormCTA</code> object that stores the call to action configuration for the form.</p>
    #[doc(hidden)]
    pub cta: std::option::Option<crate::model::FormCta>,
}
impl UpdateFormData {
    /// <p>The name of the form.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of data source to use to create the form.</p>
    pub fn data_type(&self) -> std::option::Option<&crate::model::FormDataTypeConfig> {
        self.data_type.as_ref()
    }
    /// <p>Specifies whether to perform a create or update action on the form.</p>
    pub fn form_action_type(&self) -> std::option::Option<&crate::model::FormActionType> {
        self.form_action_type.as_ref()
    }
    /// <p>The configuration information for the form's fields.</p>
    pub fn fields(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::FieldConfig>,
    > {
        self.fields.as_ref()
    }
    /// <p>The configuration for the form's style.</p>
    pub fn style(&self) -> std::option::Option<&crate::model::FormStyle> {
        self.style.as_ref()
    }
    /// <p>The configuration information for the visual helper elements for the form. These elements are not associated with any data.</p>
    pub fn sectional_elements(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::SectionalElement>,
    > {
        self.sectional_elements.as_ref()
    }
    /// <p>The schema version of the form.</p>
    pub fn schema_version(&self) -> std::option::Option<&str> {
        self.schema_version.as_deref()
    }
    /// <p>The <code>FormCTA</code> object that stores the call to action configuration for the form.</p>
    pub fn cta(&self) -> std::option::Option<&crate::model::FormCta> {
        self.cta.as_ref()
    }
}
/// See [`UpdateFormData`](crate::model::UpdateFormData).
pub mod update_form_data {

    /// A builder for [`UpdateFormData`](crate::model::UpdateFormData).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) data_type: std::option::Option<crate::model::FormDataTypeConfig>,
        pub(crate) form_action_type: std::option::Option<crate::model::FormActionType>,
        pub(crate) fields: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::FieldConfig>,
        >,
        pub(crate) style: std::option::Option<crate::model::FormStyle>,
        pub(crate) sectional_elements: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::SectionalElement>,
        >,
        pub(crate) schema_version: std::option::Option<std::string::String>,
        pub(crate) cta: std::option::Option<crate::model::FormCta>,
    }
    impl Builder {
        /// <p>The name of the form.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the form.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of data source to use to create the form.</p>
        pub fn data_type(mut self, input: crate::model::FormDataTypeConfig) -> Self {
            self.data_type = Some(input);
            self
        }
        /// <p>The type of data source to use to create the form.</p>
        pub fn set_data_type(
            mut self,
            input: std::option::Option<crate::model::FormDataTypeConfig>,
        ) -> Self {
            self.data_type = input;
            self
        }
        /// <p>Specifies whether to perform a create or update action on the form.</p>
        pub fn form_action_type(mut self, input: crate::model::FormActionType) -> Self {
            self.form_action_type = Some(input);
            self
        }
        /// <p>Specifies whether to perform a create or update action on the form.</p>
        pub fn set_form_action_type(
            mut self,
            input: std::option::Option<crate::model::FormActionType>,
        ) -> Self {
            self.form_action_type = input;
            self
        }
        /// Adds a key-value pair to `fields`.
        ///
        /// To override the contents of this collection use [`set_fields`](Self::set_fields).
        ///
        /// <p>The configuration information for the form's fields.</p>
        pub fn fields(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::FieldConfig,
        ) -> Self {
            let mut hash_map = self.fields.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.fields = Some(hash_map);
            self
        }
        /// <p>The configuration information for the form's fields.</p>
        pub fn set_fields(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::FieldConfig>,
            >,
        ) -> Self {
            self.fields = input;
            self
        }
        /// <p>The configuration for the form's style.</p>
        pub fn style(mut self, input: crate::model::FormStyle) -> Self {
            self.style = Some(input);
            self
        }
        /// <p>The configuration for the form's style.</p>
        pub fn set_style(mut self, input: std::option::Option<crate::model::FormStyle>) -> Self {
            self.style = input;
            self
        }
        /// Adds a key-value pair to `sectional_elements`.
        ///
        /// To override the contents of this collection use [`set_sectional_elements`](Self::set_sectional_elements).
        ///
        /// <p>The configuration information for the visual helper elements for the form. These elements are not associated with any data.</p>
        pub fn sectional_elements(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::SectionalElement,
        ) -> Self {
            let mut hash_map = self.sectional_elements.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.sectional_elements = Some(hash_map);
            self
        }
        /// <p>The configuration information for the visual helper elements for the form. These elements are not associated with any data.</p>
        pub fn set_sectional_elements(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::SectionalElement>,
            >,
        ) -> Self {
            self.sectional_elements = input;
            self
        }
        /// <p>The schema version of the form.</p>
        pub fn schema_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.schema_version = Some(input.into());
            self
        }
        /// <p>The schema version of the form.</p>
        pub fn set_schema_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.schema_version = input;
            self
        }
        /// <p>The <code>FormCTA</code> object that stores the call to action configuration for the form.</p>
        pub fn cta(mut self, input: crate::model::FormCta) -> Self {
            self.cta = Some(input);
            self
        }
        /// <p>The <code>FormCTA</code> object that stores the call to action configuration for the form.</p>
        pub fn set_cta(mut self, input: std::option::Option<crate::model::FormCta>) -> Self {
            self.cta = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateFormData`](crate::model::UpdateFormData).
        pub fn build(self) -> crate::model::UpdateFormData {
            crate::model::UpdateFormData {
                name: self.name,
                data_type: self.data_type,
                form_action_type: self.form_action_type,
                fields: self.fields,
                style: self.style,
                sectional_elements: self.sectional_elements,
                schema_version: self.schema_version,
                cta: self.cta,
            }
        }
    }
}
impl UpdateFormData {
    /// Creates a new builder-style object to manufacture [`UpdateFormData`](crate::model::UpdateFormData).
    pub fn builder() -> crate::model::update_form_data::Builder {
        crate::model::update_form_data::Builder::default()
    }
}

/// <p>Contains the configuration settings for a user interface (UI) element for an Amplify app. A component is configured as a primary, stand-alone UI element. Use <code>ComponentChild</code> to configure an instance of a <code>Component</code>. A <code>ComponentChild</code> instance inherits the configuration of the main <code>Component</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Component {
    /// <p>The unique ID of the Amplify app associated with the component.</p>
    #[doc(hidden)]
    pub app_id: std::option::Option<std::string::String>,
    /// <p>The name of the backend environment that is a part of the Amplify app.</p>
    #[doc(hidden)]
    pub environment_name: std::option::Option<std::string::String>,
    /// <p>The unique ID of the component in its original source system, such as Figma.</p>
    #[doc(hidden)]
    pub source_id: std::option::Option<std::string::String>,
    /// <p>The unique ID of the component.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the component.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of the component. This can be an Amplify custom UI component or another custom component.</p>
    #[doc(hidden)]
    pub component_type: std::option::Option<std::string::String>,
    /// <p>Describes the component's properties. You can't specify <code>tags</code> as a valid property for <code>properties</code>.</p>
    #[doc(hidden)]
    pub properties: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::ComponentProperty>,
    >,
    /// <p>A list of the component's <code>ComponentChild</code> instances.</p>
    #[doc(hidden)]
    pub children: std::option::Option<std::vec::Vec<crate::model::ComponentChild>>,
    /// <p>A list of the component's variants. A variant is a unique style configuration of a main component.</p>
    #[doc(hidden)]
    pub variants: std::option::Option<std::vec::Vec<crate::model::ComponentVariant>>,
    /// <p>Describes the component's properties that can be overriden in a customized instance of the component. You can't specify <code>tags</code> as a valid property for <code>overrides</code>.</p>
    #[doc(hidden)]
    pub overrides: std::option::Option<
        std::collections::HashMap<
            std::string::String,
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    >,
    /// <p>The information to connect a component's properties to data at runtime. You can't specify <code>tags</code> as a valid property for <code>bindingProperties</code>.</p>
    /// <p></p>
    #[doc(hidden)]
    pub binding_properties: std::option::Option<
        std::collections::HashMap<
            std::string::String,
            crate::model::ComponentBindingPropertiesValue,
        >,
    >,
    /// <p>The data binding configuration for the component's properties. Use this for a collection component. You can't specify <code>tags</code> as a valid property for <code>collectionProperties</code>.</p>
    #[doc(hidden)]
    pub collection_properties: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::ComponentDataConfiguration>,
    >,
    /// <p>The time that the component was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that the component was modified.</p>
    #[doc(hidden)]
    pub modified_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>One or more key-value pairs to use when tagging the component.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Describes the events that can be raised on the component. Use for the workflow feature in Amplify Studio that allows you to bind events and actions to components.</p>
    #[doc(hidden)]
    pub events: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::ComponentEvent>,
    >,
    /// <p>The schema version of the component when it was imported.</p>
    #[doc(hidden)]
    pub schema_version: std::option::Option<std::string::String>,
}
impl Component {
    /// <p>The unique ID of the Amplify app associated with the component.</p>
    pub fn app_id(&self) -> std::option::Option<&str> {
        self.app_id.as_deref()
    }
    /// <p>The name of the backend environment that is a part of the Amplify app.</p>
    pub fn environment_name(&self) -> std::option::Option<&str> {
        self.environment_name.as_deref()
    }
    /// <p>The unique ID of the component in its original source system, such as Figma.</p>
    pub fn source_id(&self) -> std::option::Option<&str> {
        self.source_id.as_deref()
    }
    /// <p>The unique ID of the component.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the component.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of the component. This can be an Amplify custom UI component or another custom component.</p>
    pub fn component_type(&self) -> std::option::Option<&str> {
        self.component_type.as_deref()
    }
    /// <p>Describes the component's properties. You can't specify <code>tags</code> as a valid property for <code>properties</code>.</p>
    pub fn properties(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::ComponentProperty>,
    > {
        self.properties.as_ref()
    }
    /// <p>A list of the component's <code>ComponentChild</code> instances.</p>
    pub fn children(&self) -> std::option::Option<&[crate::model::ComponentChild]> {
        self.children.as_deref()
    }
    /// <p>A list of the component's variants. A variant is a unique style configuration of a main component.</p>
    pub fn variants(&self) -> std::option::Option<&[crate::model::ComponentVariant]> {
        self.variants.as_deref()
    }
    /// <p>Describes the component's properties that can be overriden in a customized instance of the component. You can't specify <code>tags</code> as a valid property for <code>overrides</code>.</p>
    pub fn overrides(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<
            std::string::String,
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    > {
        self.overrides.as_ref()
    }
    /// <p>The information to connect a component's properties to data at runtime. You can't specify <code>tags</code> as a valid property for <code>bindingProperties</code>.</p>
    /// <p></p>
    pub fn binding_properties(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<
            std::string::String,
            crate::model::ComponentBindingPropertiesValue,
        >,
    > {
        self.binding_properties.as_ref()
    }
    /// <p>The data binding configuration for the component's properties. Use this for a collection component. You can't specify <code>tags</code> as a valid property for <code>collectionProperties</code>.</p>
    pub fn collection_properties(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::ComponentDataConfiguration>,
    > {
        self.collection_properties.as_ref()
    }
    /// <p>The time that the component was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The time that the component was modified.</p>
    pub fn modified_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.modified_at.as_ref()
    }
    /// <p>One or more key-value pairs to use when tagging the component.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>Describes the events that can be raised on the component. Use for the workflow feature in Amplify Studio that allows you to bind events and actions to components.</p>
    pub fn events(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::ComponentEvent>,
    > {
        self.events.as_ref()
    }
    /// <p>The schema version of the component when it was imported.</p>
    pub fn schema_version(&self) -> std::option::Option<&str> {
        self.schema_version.as_deref()
    }
}
/// See [`Component`](crate::model::Component).
pub mod component {

    /// A builder for [`Component`](crate::model::Component).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_id: std::option::Option<std::string::String>,
        pub(crate) environment_name: std::option::Option<std::string::String>,
        pub(crate) source_id: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) component_type: std::option::Option<std::string::String>,
        pub(crate) properties: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::ComponentProperty>,
        >,
        pub(crate) children: std::option::Option<std::vec::Vec<crate::model::ComponentChild>>,
        pub(crate) variants: std::option::Option<std::vec::Vec<crate::model::ComponentVariant>>,
        pub(crate) overrides: std::option::Option<
            std::collections::HashMap<
                std::string::String,
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        >,
        pub(crate) binding_properties: std::option::Option<
            std::collections::HashMap<
                std::string::String,
                crate::model::ComponentBindingPropertiesValue,
            >,
        >,
        pub(crate) collection_properties: std::option::Option<
            std::collections::HashMap<
                std::string::String,
                crate::model::ComponentDataConfiguration,
            >,
        >,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) modified_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) events: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::ComponentEvent>,
        >,
        pub(crate) schema_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique ID of the Amplify app associated with the component.</p>
        pub fn app_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_id = Some(input.into());
            self
        }
        /// <p>The unique ID of the Amplify app associated with the component.</p>
        pub fn set_app_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_id = input;
            self
        }
        /// <p>The name of the backend environment that is a part of the Amplify app.</p>
        pub fn environment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.environment_name = Some(input.into());
            self
        }
        /// <p>The name of the backend environment that is a part of the Amplify app.</p>
        pub fn set_environment_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.environment_name = input;
            self
        }
        /// <p>The unique ID of the component in its original source system, such as Figma.</p>
        pub fn source_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_id = Some(input.into());
            self
        }
        /// <p>The unique ID of the component in its original source system, such as Figma.</p>
        pub fn set_source_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_id = input;
            self
        }
        /// <p>The unique ID of the component.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique ID of the component.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the component.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the component.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of the component. This can be an Amplify custom UI component or another custom component.</p>
        pub fn component_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.component_type = Some(input.into());
            self
        }
        /// <p>The type of the component. This can be an Amplify custom UI component or another custom component.</p>
        pub fn set_component_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.component_type = input;
            self
        }
        /// Adds a key-value pair to `properties`.
        ///
        /// To override the contents of this collection use [`set_properties`](Self::set_properties).
        ///
        /// <p>Describes the component's properties. You can't specify <code>tags</code> as a valid property for <code>properties</code>.</p>
        pub fn properties(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::ComponentProperty,
        ) -> Self {
            let mut hash_map = self.properties.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.properties = Some(hash_map);
            self
        }
        /// <p>Describes the component's properties. You can't specify <code>tags</code> as a valid property for <code>properties</code>.</p>
        pub fn set_properties(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::ComponentProperty>,
            >,
        ) -> Self {
            self.properties = input;
            self
        }
        /// Appends an item to `children`.
        ///
        /// To override the contents of this collection use [`set_children`](Self::set_children).
        ///
        /// <p>A list of the component's <code>ComponentChild</code> instances.</p>
        pub fn children(mut self, input: crate::model::ComponentChild) -> Self {
            let mut v = self.children.unwrap_or_default();
            v.push(input);
            self.children = Some(v);
            self
        }
        /// <p>A list of the component's <code>ComponentChild</code> instances.</p>
        pub fn set_children(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ComponentChild>>,
        ) -> Self {
            self.children = input;
            self
        }
        /// Appends an item to `variants`.
        ///
        /// To override the contents of this collection use [`set_variants`](Self::set_variants).
        ///
        /// <p>A list of the component's variants. A variant is a unique style configuration of a main component.</p>
        pub fn variants(mut self, input: crate::model::ComponentVariant) -> Self {
            let mut v = self.variants.unwrap_or_default();
            v.push(input);
            self.variants = Some(v);
            self
        }
        /// <p>A list of the component's variants. A variant is a unique style configuration of a main component.</p>
        pub fn set_variants(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ComponentVariant>>,
        ) -> Self {
            self.variants = input;
            self
        }
        /// Adds a key-value pair to `overrides`.
        ///
        /// To override the contents of this collection use [`set_overrides`](Self::set_overrides).
        ///
        /// <p>Describes the component's properties that can be overriden in a customized instance of the component. You can't specify <code>tags</code> as a valid property for <code>overrides</code>.</p>
        pub fn overrides(
            mut self,
            k: impl Into<std::string::String>,
            v: std::collections::HashMap<std::string::String, std::string::String>,
        ) -> Self {
            let mut hash_map = self.overrides.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.overrides = Some(hash_map);
            self
        }
        /// <p>Describes the component's properties that can be overriden in a customized instance of the component. You can't specify <code>tags</code> as a valid property for <code>overrides</code>.</p>
        pub fn set_overrides(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    std::collections::HashMap<std::string::String, std::string::String>,
                >,
            >,
        ) -> Self {
            self.overrides = input;
            self
        }
        /// Adds a key-value pair to `binding_properties`.
        ///
        /// To override the contents of this collection use [`set_binding_properties`](Self::set_binding_properties).
        ///
        /// <p>The information to connect a component's properties to data at runtime. You can't specify <code>tags</code> as a valid property for <code>bindingProperties</code>.</p>
        /// <p></p>
        pub fn binding_properties(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::ComponentBindingPropertiesValue,
        ) -> Self {
            let mut hash_map = self.binding_properties.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.binding_properties = Some(hash_map);
            self
        }
        /// <p>The information to connect a component's properties to data at runtime. You can't specify <code>tags</code> as a valid property for <code>bindingProperties</code>.</p>
        /// <p></p>
        pub fn set_binding_properties(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    crate::model::ComponentBindingPropertiesValue,
                >,
            >,
        ) -> Self {
            self.binding_properties = input;
            self
        }
        /// Adds a key-value pair to `collection_properties`.
        ///
        /// To override the contents of this collection use [`set_collection_properties`](Self::set_collection_properties).
        ///
        /// <p>The data binding configuration for the component's properties. Use this for a collection component. You can't specify <code>tags</code> as a valid property for <code>collectionProperties</code>.</p>
        pub fn collection_properties(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::ComponentDataConfiguration,
        ) -> Self {
            let mut hash_map = self.collection_properties.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.collection_properties = Some(hash_map);
            self
        }
        /// <p>The data binding configuration for the component's properties. Use this for a collection component. You can't specify <code>tags</code> as a valid property for <code>collectionProperties</code>.</p>
        pub fn set_collection_properties(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    crate::model::ComponentDataConfiguration,
                >,
            >,
        ) -> Self {
            self.collection_properties = input;
            self
        }
        /// <p>The time that the component was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The time that the component was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The time that the component was modified.</p>
        pub fn modified_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.modified_at = Some(input);
            self
        }
        /// <p>The time that the component was modified.</p>
        pub fn set_modified_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.modified_at = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>One or more key-value pairs to use when tagging the component.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>One or more key-value pairs to use when tagging the component.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Adds a key-value pair to `events`.
        ///
        /// To override the contents of this collection use [`set_events`](Self::set_events).
        ///
        /// <p>Describes the events that can be raised on the component. Use for the workflow feature in Amplify Studio that allows you to bind events and actions to components.</p>
        pub fn events(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::ComponentEvent,
        ) -> Self {
            let mut hash_map = self.events.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.events = Some(hash_map);
            self
        }
        /// <p>Describes the events that can be raised on the component. Use for the workflow feature in Amplify Studio that allows you to bind events and actions to components.</p>
        pub fn set_events(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::ComponentEvent>,
            >,
        ) -> Self {
            self.events = input;
            self
        }
        /// <p>The schema version of the component when it was imported.</p>
        pub fn schema_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.schema_version = Some(input.into());
            self
        }
        /// <p>The schema version of the component when it was imported.</p>
        pub fn set_schema_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.schema_version = input;
            self
        }
        /// Consumes the builder and constructs a [`Component`](crate::model::Component).
        pub fn build(self) -> crate::model::Component {
            crate::model::Component {
                app_id: self.app_id,
                environment_name: self.environment_name,
                source_id: self.source_id,
                id: self.id,
                name: self.name,
                component_type: self.component_type,
                properties: self.properties,
                children: self.children,
                variants: self.variants,
                overrides: self.overrides,
                binding_properties: self.binding_properties,
                collection_properties: self.collection_properties,
                created_at: self.created_at,
                modified_at: self.modified_at,
                tags: self.tags,
                events: self.events,
                schema_version: self.schema_version,
            }
        }
    }
}
impl Component {
    /// Creates a new builder-style object to manufacture [`Component`](crate::model::Component).
    pub fn builder() -> crate::model::component::Builder {
        crate::model::component::Builder::default()
    }
}

/// <p>Describes the configuration of an event. You can bind an event and a corresponding action to a <code>Component</code> or a <code>ComponentChild</code>. A button click is an example of an event. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComponentEvent {
    /// <p>The action to perform when a specific event is raised.</p>
    #[doc(hidden)]
    pub action: std::option::Option<std::string::String>,
    /// <p>Describes information about the action.</p>
    #[doc(hidden)]
    pub parameters: std::option::Option<crate::model::ActionParameters>,
    /// <p>Binds an event to an action on a component. When you specify a <code>bindingEvent</code>, the event is called when the action is performed.</p>
    #[doc(hidden)]
    pub binding_event: std::option::Option<std::string::String>,
}
impl ComponentEvent {
    /// <p>The action to perform when a specific event is raised.</p>
    pub fn action(&self) -> std::option::Option<&str> {
        self.action.as_deref()
    }
    /// <p>Describes information about the action.</p>
    pub fn parameters(&self) -> std::option::Option<&crate::model::ActionParameters> {
        self.parameters.as_ref()
    }
    /// <p>Binds an event to an action on a component. When you specify a <code>bindingEvent</code>, the event is called when the action is performed.</p>
    pub fn binding_event(&self) -> std::option::Option<&str> {
        self.binding_event.as_deref()
    }
}
/// See [`ComponentEvent`](crate::model::ComponentEvent).
pub mod component_event {

    /// A builder for [`ComponentEvent`](crate::model::ComponentEvent).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action: std::option::Option<std::string::String>,
        pub(crate) parameters: std::option::Option<crate::model::ActionParameters>,
        pub(crate) binding_event: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The action to perform when a specific event is raised.</p>
        pub fn action(mut self, input: impl Into<std::string::String>) -> Self {
            self.action = Some(input.into());
            self
        }
        /// <p>The action to perform when a specific event is raised.</p>
        pub fn set_action(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action = input;
            self
        }
        /// <p>Describes information about the action.</p>
        pub fn parameters(mut self, input: crate::model::ActionParameters) -> Self {
            self.parameters = Some(input);
            self
        }
        /// <p>Describes information about the action.</p>
        pub fn set_parameters(
            mut self,
            input: std::option::Option<crate::model::ActionParameters>,
        ) -> Self {
            self.parameters = input;
            self
        }
        /// <p>Binds an event to an action on a component. When you specify a <code>bindingEvent</code>, the event is called when the action is performed.</p>
        pub fn binding_event(mut self, input: impl Into<std::string::String>) -> Self {
            self.binding_event = Some(input.into());
            self
        }
        /// <p>Binds an event to an action on a component. When you specify a <code>bindingEvent</code>, the event is called when the action is performed.</p>
        pub fn set_binding_event(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.binding_event = input;
            self
        }
        /// Consumes the builder and constructs a [`ComponentEvent`](crate::model::ComponentEvent).
        pub fn build(self) -> crate::model::ComponentEvent {
            crate::model::ComponentEvent {
                action: self.action,
                parameters: self.parameters,
                binding_event: self.binding_event,
            }
        }
    }
}
impl ComponentEvent {
    /// Creates a new builder-style object to manufacture [`ComponentEvent`](crate::model::ComponentEvent).
    pub fn builder() -> crate::model::component_event::Builder {
        crate::model::component_event::Builder::default()
    }
}

/// <p>Represents the event action configuration for an element of a <code>Component</code> or <code>ComponentChild</code>. Use for the workflow feature in Amplify Studio that allows you to bind events and actions to components. <code>ActionParameters</code> defines the action that is performed when an event occurs on the component.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ActionParameters {
    /// <p>The type of navigation action. Valid values are <code>url</code> and <code>anchor</code>. This value is required for a navigation action.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::ComponentProperty>,
    /// <p>The URL to the location to open. Specify this value for a navigation action.</p>
    #[doc(hidden)]
    pub url: std::option::Option<crate::model::ComponentProperty>,
    /// <p>The HTML anchor link to the location to open. Specify this value for a navigation action.</p>
    #[doc(hidden)]
    pub anchor: std::option::Option<crate::model::ComponentProperty>,
    /// <p>The element within the same component to modify when the action occurs.</p>
    #[doc(hidden)]
    pub target: std::option::Option<crate::model::ComponentProperty>,
    /// <p>Specifies whether the user should be signed out globally. Specify this value for an auth sign out action.</p>
    #[doc(hidden)]
    pub global: std::option::Option<crate::model::ComponentProperty>,
    /// <p>The name of the data model. Use when the action performs an operation on an Amplify DataStore model.</p>
    #[doc(hidden)]
    pub model: std::option::Option<std::string::String>,
    /// <p>The unique ID of the component that the <code>ActionParameters</code> apply to.</p>
    #[doc(hidden)]
    pub id: std::option::Option<crate::model::ComponentProperty>,
    /// <p>A dictionary of key-value pairs mapping Amplify Studio properties to fields in a data model. Use when the action performs an operation on an Amplify DataStore model.</p>
    #[doc(hidden)]
    pub fields: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::ComponentProperty>,
    >,
    /// <p>A key-value pair that specifies the state property name and its initial value.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::MutationActionSetStateParameter>,
}
impl ActionParameters {
    /// <p>The type of navigation action. Valid values are <code>url</code> and <code>anchor</code>. This value is required for a navigation action.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::ComponentProperty> {
        self.r#type.as_ref()
    }
    /// <p>The URL to the location to open. Specify this value for a navigation action.</p>
    pub fn url(&self) -> std::option::Option<&crate::model::ComponentProperty> {
        self.url.as_ref()
    }
    /// <p>The HTML anchor link to the location to open. Specify this value for a navigation action.</p>
    pub fn anchor(&self) -> std::option::Option<&crate::model::ComponentProperty> {
        self.anchor.as_ref()
    }
    /// <p>The element within the same component to modify when the action occurs.</p>
    pub fn target(&self) -> std::option::Option<&crate::model::ComponentProperty> {
        self.target.as_ref()
    }
    /// <p>Specifies whether the user should be signed out globally. Specify this value for an auth sign out action.</p>
    pub fn global(&self) -> std::option::Option<&crate::model::ComponentProperty> {
        self.global.as_ref()
    }
    /// <p>The name of the data model. Use when the action performs an operation on an Amplify DataStore model.</p>
    pub fn model(&self) -> std::option::Option<&str> {
        self.model.as_deref()
    }
    /// <p>The unique ID of the component that the <code>ActionParameters</code> apply to.</p>
    pub fn id(&self) -> std::option::Option<&crate::model::ComponentProperty> {
        self.id.as_ref()
    }
    /// <p>A dictionary of key-value pairs mapping Amplify Studio properties to fields in a data model. Use when the action performs an operation on an Amplify DataStore model.</p>
    pub fn fields(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::ComponentProperty>,
    > {
        self.fields.as_ref()
    }
    /// <p>A key-value pair that specifies the state property name and its initial value.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::MutationActionSetStateParameter> {
        self.state.as_ref()
    }
}
/// See [`ActionParameters`](crate::model::ActionParameters).
pub mod action_parameters {

    /// A builder for [`ActionParameters`](crate::model::ActionParameters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::ComponentProperty>,
        pub(crate) url: std::option::Option<crate::model::ComponentProperty>,
        pub(crate) anchor: std::option::Option<crate::model::ComponentProperty>,
        pub(crate) target: std::option::Option<crate::model::ComponentProperty>,
        pub(crate) global: std::option::Option<crate::model::ComponentProperty>,
        pub(crate) model: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<crate::model::ComponentProperty>,
        pub(crate) fields: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::ComponentProperty>,
        >,
        pub(crate) state: std::option::Option<crate::model::MutationActionSetStateParameter>,
    }
    impl Builder {
        /// <p>The type of navigation action. Valid values are <code>url</code> and <code>anchor</code>. This value is required for a navigation action.</p>
        pub fn r#type(mut self, input: crate::model::ComponentProperty) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of navigation action. Valid values are <code>url</code> and <code>anchor</code>. This value is required for a navigation action.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::ComponentProperty>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The URL to the location to open. Specify this value for a navigation action.</p>
        pub fn url(mut self, input: crate::model::ComponentProperty) -> Self {
            self.url = Some(input);
            self
        }
        /// <p>The URL to the location to open. Specify this value for a navigation action.</p>
        pub fn set_url(
            mut self,
            input: std::option::Option<crate::model::ComponentProperty>,
        ) -> Self {
            self.url = input;
            self
        }
        /// <p>The HTML anchor link to the location to open. Specify this value for a navigation action.</p>
        pub fn anchor(mut self, input: crate::model::ComponentProperty) -> Self {
            self.anchor = Some(input);
            self
        }
        /// <p>The HTML anchor link to the location to open. Specify this value for a navigation action.</p>
        pub fn set_anchor(
            mut self,
            input: std::option::Option<crate::model::ComponentProperty>,
        ) -> Self {
            self.anchor = input;
            self
        }
        /// <p>The element within the same component to modify when the action occurs.</p>
        pub fn target(mut self, input: crate::model::ComponentProperty) -> Self {
            self.target = Some(input);
            self
        }
        /// <p>The element within the same component to modify when the action occurs.</p>
        pub fn set_target(
            mut self,
            input: std::option::Option<crate::model::ComponentProperty>,
        ) -> Self {
            self.target = input;
            self
        }
        /// <p>Specifies whether the user should be signed out globally. Specify this value for an auth sign out action.</p>
        pub fn global(mut self, input: crate::model::ComponentProperty) -> Self {
            self.global = Some(input);
            self
        }
        /// <p>Specifies whether the user should be signed out globally. Specify this value for an auth sign out action.</p>
        pub fn set_global(
            mut self,
            input: std::option::Option<crate::model::ComponentProperty>,
        ) -> Self {
            self.global = input;
            self
        }
        /// <p>The name of the data model. Use when the action performs an operation on an Amplify DataStore model.</p>
        pub fn model(mut self, input: impl Into<std::string::String>) -> Self {
            self.model = Some(input.into());
            self
        }
        /// <p>The name of the data model. Use when the action performs an operation on an Amplify DataStore model.</p>
        pub fn set_model(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model = input;
            self
        }
        /// <p>The unique ID of the component that the <code>ActionParameters</code> apply to.</p>
        pub fn id(mut self, input: crate::model::ComponentProperty) -> Self {
            self.id = Some(input);
            self
        }
        /// <p>The unique ID of the component that the <code>ActionParameters</code> apply to.</p>
        pub fn set_id(
            mut self,
            input: std::option::Option<crate::model::ComponentProperty>,
        ) -> Self {
            self.id = input;
            self
        }
        /// Adds a key-value pair to `fields`.
        ///
        /// To override the contents of this collection use [`set_fields`](Self::set_fields).
        ///
        /// <p>A dictionary of key-value pairs mapping Amplify Studio properties to fields in a data model. Use when the action performs an operation on an Amplify DataStore model.</p>
        pub fn fields(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::ComponentProperty,
        ) -> Self {
            let mut hash_map = self.fields.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.fields = Some(hash_map);
            self
        }
        /// <p>A dictionary of key-value pairs mapping Amplify Studio properties to fields in a data model. Use when the action performs an operation on an Amplify DataStore model.</p>
        pub fn set_fields(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::ComponentProperty>,
            >,
        ) -> Self {
            self.fields = input;
            self
        }
        /// <p>A key-value pair that specifies the state property name and its initial value.</p>
        pub fn state(mut self, input: crate::model::MutationActionSetStateParameter) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>A key-value pair that specifies the state property name and its initial value.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::MutationActionSetStateParameter>,
        ) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`ActionParameters`](crate::model::ActionParameters).
        pub fn build(self) -> crate::model::ActionParameters {
            crate::model::ActionParameters {
                r#type: self.r#type,
                url: self.url,
                anchor: self.anchor,
                target: self.target,
                global: self.global,
                model: self.model,
                id: self.id,
                fields: self.fields,
                state: self.state,
            }
        }
    }
}
impl ActionParameters {
    /// Creates a new builder-style object to manufacture [`ActionParameters`](crate::model::ActionParameters).
    pub fn builder() -> crate::model::action_parameters::Builder {
        crate::model::action_parameters::Builder::default()
    }
}

/// <p>Represents the state configuration when an action modifies a property of another element within the same component.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MutationActionSetStateParameter {
    /// <p>The name of the component that is being modified.</p>
    #[doc(hidden)]
    pub component_name: std::option::Option<std::string::String>,
    /// <p>The name of the component property to apply the state configuration to.</p>
    #[doc(hidden)]
    pub property: std::option::Option<std::string::String>,
    /// <p>The state configuration to assign to the property.</p>
    #[doc(hidden)]
    pub set: std::option::Option<crate::model::ComponentProperty>,
}
impl MutationActionSetStateParameter {
    /// <p>The name of the component that is being modified.</p>
    pub fn component_name(&self) -> std::option::Option<&str> {
        self.component_name.as_deref()
    }
    /// <p>The name of the component property to apply the state configuration to.</p>
    pub fn property(&self) -> std::option::Option<&str> {
        self.property.as_deref()
    }
    /// <p>The state configuration to assign to the property.</p>
    pub fn set(&self) -> std::option::Option<&crate::model::ComponentProperty> {
        self.set.as_ref()
    }
}
/// See [`MutationActionSetStateParameter`](crate::model::MutationActionSetStateParameter).
pub mod mutation_action_set_state_parameter {

    /// A builder for [`MutationActionSetStateParameter`](crate::model::MutationActionSetStateParameter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) component_name: std::option::Option<std::string::String>,
        pub(crate) property: std::option::Option<std::string::String>,
        pub(crate) set: std::option::Option<crate::model::ComponentProperty>,
    }
    impl Builder {
        /// <p>The name of the component that is being modified.</p>
        pub fn component_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.component_name = Some(input.into());
            self
        }
        /// <p>The name of the component that is being modified.</p>
        pub fn set_component_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.component_name = input;
            self
        }
        /// <p>The name of the component property to apply the state configuration to.</p>
        pub fn property(mut self, input: impl Into<std::string::String>) -> Self {
            self.property = Some(input.into());
            self
        }
        /// <p>The name of the component property to apply the state configuration to.</p>
        pub fn set_property(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.property = input;
            self
        }
        /// <p>The state configuration to assign to the property.</p>
        pub fn set(mut self, input: crate::model::ComponentProperty) -> Self {
            self.set = Some(input);
            self
        }
        /// <p>The state configuration to assign to the property.</p>
        pub fn set_set(
            mut self,
            input: std::option::Option<crate::model::ComponentProperty>,
        ) -> Self {
            self.set = input;
            self
        }
        /// Consumes the builder and constructs a [`MutationActionSetStateParameter`](crate::model::MutationActionSetStateParameter).
        pub fn build(self) -> crate::model::MutationActionSetStateParameter {
            crate::model::MutationActionSetStateParameter {
                component_name: self.component_name,
                property: self.property,
                set: self.set,
            }
        }
    }
}
impl MutationActionSetStateParameter {
    /// Creates a new builder-style object to manufacture [`MutationActionSetStateParameter`](crate::model::MutationActionSetStateParameter).
    pub fn builder() -> crate::model::mutation_action_set_state_parameter::Builder {
        crate::model::mutation_action_set_state_parameter::Builder::default()
    }
}

/// <p>Describes the configuration for all of a component's properties. Use <code>ComponentProperty</code> to specify the values to render or bind by default.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComponentProperty {
    /// <p>The value to assign to the component property.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
    /// <p>The information to bind the component property to data at runtime.</p>
    #[doc(hidden)]
    pub binding_properties: std::option::Option<crate::model::ComponentPropertyBindingProperties>,
    /// <p>The information to bind the component property to data at runtime. Use this for collection components.</p>
    #[doc(hidden)]
    pub collection_binding_properties:
        std::option::Option<crate::model::ComponentPropertyBindingProperties>,
    /// <p>The default value to assign to the component property.</p>
    #[doc(hidden)]
    pub default_value: std::option::Option<std::string::String>,
    /// <p>The data model to use to assign a value to the component property.</p>
    #[doc(hidden)]
    pub model: std::option::Option<std::string::String>,
    /// <p>The information to bind the component property to form data.</p>
    #[doc(hidden)]
    pub bindings: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::FormBindingElement>,
    >,
    /// <p>An event that occurs in your app. Use this for workflow data binding.</p>
    #[doc(hidden)]
    pub event: std::option::Option<std::string::String>,
    /// <p>An authenticated user attribute to use to assign a value to the component property.</p>
    #[doc(hidden)]
    pub user_attribute: std::option::Option<std::string::String>,
    /// <p>A list of component properties to concatenate to create the value to assign to this component property.</p>
    #[doc(hidden)]
    pub concat: std::option::Option<std::vec::Vec<crate::model::ComponentProperty>>,
    /// <p>The conditional expression to use to assign a value to the component property.</p>
    #[doc(hidden)]
    pub condition: std::option::Option<crate::model::ComponentConditionProperty>,
    /// <p>Specifies whether the user configured the property in Amplify Studio after importing it.</p>
    #[doc(hidden)]
    pub configured: std::option::Option<bool>,
    /// <p>The component type.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The default value assigned to the property when the component is imported into an app.</p>
    #[doc(hidden)]
    pub imported_value: std::option::Option<std::string::String>,
    /// <p>The name of the component that is affected by an event.</p>
    #[doc(hidden)]
    pub component_name: std::option::Option<std::string::String>,
    /// <p>The name of the component's property that is affected by an event.</p>
    #[doc(hidden)]
    pub property: std::option::Option<std::string::String>,
}
impl ComponentProperty {
    /// <p>The value to assign to the component property.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
    /// <p>The information to bind the component property to data at runtime.</p>
    pub fn binding_properties(
        &self,
    ) -> std::option::Option<&crate::model::ComponentPropertyBindingProperties> {
        self.binding_properties.as_ref()
    }
    /// <p>The information to bind the component property to data at runtime. Use this for collection components.</p>
    pub fn collection_binding_properties(
        &self,
    ) -> std::option::Option<&crate::model::ComponentPropertyBindingProperties> {
        self.collection_binding_properties.as_ref()
    }
    /// <p>The default value to assign to the component property.</p>
    pub fn default_value(&self) -> std::option::Option<&str> {
        self.default_value.as_deref()
    }
    /// <p>The data model to use to assign a value to the component property.</p>
    pub fn model(&self) -> std::option::Option<&str> {
        self.model.as_deref()
    }
    /// <p>The information to bind the component property to form data.</p>
    pub fn bindings(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::FormBindingElement>,
    > {
        self.bindings.as_ref()
    }
    /// <p>An event that occurs in your app. Use this for workflow data binding.</p>
    pub fn event(&self) -> std::option::Option<&str> {
        self.event.as_deref()
    }
    /// <p>An authenticated user attribute to use to assign a value to the component property.</p>
    pub fn user_attribute(&self) -> std::option::Option<&str> {
        self.user_attribute.as_deref()
    }
    /// <p>A list of component properties to concatenate to create the value to assign to this component property.</p>
    pub fn concat(&self) -> std::option::Option<&[crate::model::ComponentProperty]> {
        self.concat.as_deref()
    }
    /// <p>The conditional expression to use to assign a value to the component property.</p>
    pub fn condition(&self) -> std::option::Option<&crate::model::ComponentConditionProperty> {
        self.condition.as_ref()
    }
    /// <p>Specifies whether the user configured the property in Amplify Studio after importing it.</p>
    pub fn configured(&self) -> std::option::Option<bool> {
        self.configured
    }
    /// <p>The component type.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The default value assigned to the property when the component is imported into an app.</p>
    pub fn imported_value(&self) -> std::option::Option<&str> {
        self.imported_value.as_deref()
    }
    /// <p>The name of the component that is affected by an event.</p>
    pub fn component_name(&self) -> std::option::Option<&str> {
        self.component_name.as_deref()
    }
    /// <p>The name of the component's property that is affected by an event.</p>
    pub fn property(&self) -> std::option::Option<&str> {
        self.property.as_deref()
    }
}
/// See [`ComponentProperty`](crate::model::ComponentProperty).
pub mod component_property {

    /// A builder for [`ComponentProperty`](crate::model::ComponentProperty).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) binding_properties:
            std::option::Option<crate::model::ComponentPropertyBindingProperties>,
        pub(crate) collection_binding_properties:
            std::option::Option<crate::model::ComponentPropertyBindingProperties>,
        pub(crate) default_value: std::option::Option<std::string::String>,
        pub(crate) model: std::option::Option<std::string::String>,
        pub(crate) bindings: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::FormBindingElement>,
        >,
        pub(crate) event: std::option::Option<std::string::String>,
        pub(crate) user_attribute: std::option::Option<std::string::String>,
        pub(crate) concat: std::option::Option<std::vec::Vec<crate::model::ComponentProperty>>,
        pub(crate) condition: std::option::Option<crate::model::ComponentConditionProperty>,
        pub(crate) configured: std::option::Option<bool>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) imported_value: std::option::Option<std::string::String>,
        pub(crate) component_name: std::option::Option<std::string::String>,
        pub(crate) property: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The value to assign to the component property.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value to assign to the component property.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p>The information to bind the component property to data at runtime.</p>
        pub fn binding_properties(
            mut self,
            input: crate::model::ComponentPropertyBindingProperties,
        ) -> Self {
            self.binding_properties = Some(input);
            self
        }
        /// <p>The information to bind the component property to data at runtime.</p>
        pub fn set_binding_properties(
            mut self,
            input: std::option::Option<crate::model::ComponentPropertyBindingProperties>,
        ) -> Self {
            self.binding_properties = input;
            self
        }
        /// <p>The information to bind the component property to data at runtime. Use this for collection components.</p>
        pub fn collection_binding_properties(
            mut self,
            input: crate::model::ComponentPropertyBindingProperties,
        ) -> Self {
            self.collection_binding_properties = Some(input);
            self
        }
        /// <p>The information to bind the component property to data at runtime. Use this for collection components.</p>
        pub fn set_collection_binding_properties(
            mut self,
            input: std::option::Option<crate::model::ComponentPropertyBindingProperties>,
        ) -> Self {
            self.collection_binding_properties = input;
            self
        }
        /// <p>The default value to assign to the component property.</p>
        pub fn default_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_value = Some(input.into());
            self
        }
        /// <p>The default value to assign to the component property.</p>
        pub fn set_default_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_value = input;
            self
        }
        /// <p>The data model to use to assign a value to the component property.</p>
        pub fn model(mut self, input: impl Into<std::string::String>) -> Self {
            self.model = Some(input.into());
            self
        }
        /// <p>The data model to use to assign a value to the component property.</p>
        pub fn set_model(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model = input;
            self
        }
        /// Adds a key-value pair to `bindings`.
        ///
        /// To override the contents of this collection use [`set_bindings`](Self::set_bindings).
        ///
        /// <p>The information to bind the component property to form data.</p>
        pub fn bindings(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::FormBindingElement,
        ) -> Self {
            let mut hash_map = self.bindings.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.bindings = Some(hash_map);
            self
        }
        /// <p>The information to bind the component property to form data.</p>
        pub fn set_bindings(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::FormBindingElement>,
            >,
        ) -> Self {
            self.bindings = input;
            self
        }
        /// <p>An event that occurs in your app. Use this for workflow data binding.</p>
        pub fn event(mut self, input: impl Into<std::string::String>) -> Self {
            self.event = Some(input.into());
            self
        }
        /// <p>An event that occurs in your app. Use this for workflow data binding.</p>
        pub fn set_event(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.event = input;
            self
        }
        /// <p>An authenticated user attribute to use to assign a value to the component property.</p>
        pub fn user_attribute(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_attribute = Some(input.into());
            self
        }
        /// <p>An authenticated user attribute to use to assign a value to the component property.</p>
        pub fn set_user_attribute(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.user_attribute = input;
            self
        }
        /// Appends an item to `concat`.
        ///
        /// To override the contents of this collection use [`set_concat`](Self::set_concat).
        ///
        /// <p>A list of component properties to concatenate to create the value to assign to this component property.</p>
        pub fn concat(mut self, input: crate::model::ComponentProperty) -> Self {
            let mut v = self.concat.unwrap_or_default();
            v.push(input);
            self.concat = Some(v);
            self
        }
        /// <p>A list of component properties to concatenate to create the value to assign to this component property.</p>
        pub fn set_concat(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ComponentProperty>>,
        ) -> Self {
            self.concat = input;
            self
        }
        /// <p>The conditional expression to use to assign a value to the component property.</p>
        pub fn condition(mut self, input: crate::model::ComponentConditionProperty) -> Self {
            self.condition = Some(input);
            self
        }
        /// <p>The conditional expression to use to assign a value to the component property.</p>
        pub fn set_condition(
            mut self,
            input: std::option::Option<crate::model::ComponentConditionProperty>,
        ) -> Self {
            self.condition = input;
            self
        }
        /// <p>Specifies whether the user configured the property in Amplify Studio after importing it.</p>
        pub fn configured(mut self, input: bool) -> Self {
            self.configured = Some(input);
            self
        }
        /// <p>Specifies whether the user configured the property in Amplify Studio after importing it.</p>
        pub fn set_configured(mut self, input: std::option::Option<bool>) -> Self {
            self.configured = input;
            self
        }
        /// <p>The component type.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The component type.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The default value assigned to the property when the component is imported into an app.</p>
        pub fn imported_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.imported_value = Some(input.into());
            self
        }
        /// <p>The default value assigned to the property when the component is imported into an app.</p>
        pub fn set_imported_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.imported_value = input;
            self
        }
        /// <p>The name of the component that is affected by an event.</p>
        pub fn component_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.component_name = Some(input.into());
            self
        }
        /// <p>The name of the component that is affected by an event.</p>
        pub fn set_component_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.component_name = input;
            self
        }
        /// <p>The name of the component's property that is affected by an event.</p>
        pub fn property(mut self, input: impl Into<std::string::String>) -> Self {
            self.property = Some(input.into());
            self
        }
        /// <p>The name of the component's property that is affected by an event.</p>
        pub fn set_property(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.property = input;
            self
        }
        /// Consumes the builder and constructs a [`ComponentProperty`](crate::model::ComponentProperty).
        pub fn build(self) -> crate::model::ComponentProperty {
            crate::model::ComponentProperty {
                value: self.value,
                binding_properties: self.binding_properties,
                collection_binding_properties: self.collection_binding_properties,
                default_value: self.default_value,
                model: self.model,
                bindings: self.bindings,
                event: self.event,
                user_attribute: self.user_attribute,
                concat: self.concat,
                condition: self.condition,
                configured: self.configured,
                r#type: self.r#type,
                imported_value: self.imported_value,
                component_name: self.component_name,
                property: self.property,
            }
        }
    }
}
impl ComponentProperty {
    /// Creates a new builder-style object to manufacture [`ComponentProperty`](crate::model::ComponentProperty).
    pub fn builder() -> crate::model::component_property::Builder {
        crate::model::component_property::Builder::default()
    }
}

/// <p>Represents a conditional expression to set a component property. Use <code>ComponentConditionProperty</code> to set a property to different values conditionally, based on the value of another property.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComponentConditionProperty {
    /// <p>The name of the conditional property.</p>
    #[doc(hidden)]
    pub property: std::option::Option<std::string::String>,
    /// <p>The name of a field. Specify this when the property is a data model.</p>
    #[doc(hidden)]
    pub field: std::option::Option<std::string::String>,
    /// <p>The operator to use to perform the evaluation, such as <code>eq</code> to represent equals.</p>
    #[doc(hidden)]
    pub operator: std::option::Option<std::string::String>,
    /// <p>The value of the property to evaluate.</p>
    #[doc(hidden)]
    pub operand: std::option::Option<std::string::String>,
    /// <p>The value to assign to the property if the condition is met.</p>
    #[doc(hidden)]
    pub then: std::option::Option<std::boxed::Box<crate::model::ComponentProperty>>,
    /// <p>The value to assign to the property if the condition is not met.</p>
    #[doc(hidden)]
    pub r#else: std::option::Option<std::boxed::Box<crate::model::ComponentProperty>>,
    /// <p>The type of the property to evaluate.</p>
    #[doc(hidden)]
    pub operand_type: std::option::Option<std::string::String>,
}
impl ComponentConditionProperty {
    /// <p>The name of the conditional property.</p>
    pub fn property(&self) -> std::option::Option<&str> {
        self.property.as_deref()
    }
    /// <p>The name of a field. Specify this when the property is a data model.</p>
    pub fn field(&self) -> std::option::Option<&str> {
        self.field.as_deref()
    }
    /// <p>The operator to use to perform the evaluation, such as <code>eq</code> to represent equals.</p>
    pub fn operator(&self) -> std::option::Option<&str> {
        self.operator.as_deref()
    }
    /// <p>The value of the property to evaluate.</p>
    pub fn operand(&self) -> std::option::Option<&str> {
        self.operand.as_deref()
    }
    /// <p>The value to assign to the property if the condition is met.</p>
    pub fn then(&self) -> std::option::Option<&crate::model::ComponentProperty> {
        self.then.as_deref()
    }
    /// <p>The value to assign to the property if the condition is not met.</p>
    pub fn r#else(&self) -> std::option::Option<&crate::model::ComponentProperty> {
        self.r#else.as_deref()
    }
    /// <p>The type of the property to evaluate.</p>
    pub fn operand_type(&self) -> std::option::Option<&str> {
        self.operand_type.as_deref()
    }
}
/// See [`ComponentConditionProperty`](crate::model::ComponentConditionProperty).
pub mod component_condition_property {

    /// A builder for [`ComponentConditionProperty`](crate::model::ComponentConditionProperty).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) property: std::option::Option<std::string::String>,
        pub(crate) field: std::option::Option<std::string::String>,
        pub(crate) operator: std::option::Option<std::string::String>,
        pub(crate) operand: std::option::Option<std::string::String>,
        pub(crate) then: std::option::Option<std::boxed::Box<crate::model::ComponentProperty>>,
        pub(crate) r#else: std::option::Option<std::boxed::Box<crate::model::ComponentProperty>>,
        pub(crate) operand_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the conditional property.</p>
        pub fn property(mut self, input: impl Into<std::string::String>) -> Self {
            self.property = Some(input.into());
            self
        }
        /// <p>The name of the conditional property.</p>
        pub fn set_property(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.property = input;
            self
        }
        /// <p>The name of a field. Specify this when the property is a data model.</p>
        pub fn field(mut self, input: impl Into<std::string::String>) -> Self {
            self.field = Some(input.into());
            self
        }
        /// <p>The name of a field. Specify this when the property is a data model.</p>
        pub fn set_field(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field = input;
            self
        }
        /// <p>The operator to use to perform the evaluation, such as <code>eq</code> to represent equals.</p>
        pub fn operator(mut self, input: impl Into<std::string::String>) -> Self {
            self.operator = Some(input.into());
            self
        }
        /// <p>The operator to use to perform the evaluation, such as <code>eq</code> to represent equals.</p>
        pub fn set_operator(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.operator = input;
            self
        }
        /// <p>The value of the property to evaluate.</p>
        pub fn operand(mut self, input: impl Into<std::string::String>) -> Self {
            self.operand = Some(input.into());
            self
        }
        /// <p>The value of the property to evaluate.</p>
        pub fn set_operand(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.operand = input;
            self
        }
        /// <p>The value to assign to the property if the condition is met.</p>
        pub fn then(
            mut self,
            input: impl Into<std::boxed::Box<crate::model::ComponentProperty>>,
        ) -> Self {
            self.then = Some(input.into());
            self
        }
        /// <p>The value to assign to the property if the condition is met.</p>
        pub fn set_then(
            mut self,
            input: std::option::Option<std::boxed::Box<crate::model::ComponentProperty>>,
        ) -> Self {
            self.then = input;
            self
        }
        /// <p>The value to assign to the property if the condition is not met.</p>
        pub fn r#else(
            mut self,
            input: impl Into<std::boxed::Box<crate::model::ComponentProperty>>,
        ) -> Self {
            self.r#else = Some(input.into());
            self
        }
        /// <p>The value to assign to the property if the condition is not met.</p>
        pub fn set_else(
            mut self,
            input: std::option::Option<std::boxed::Box<crate::model::ComponentProperty>>,
        ) -> Self {
            self.r#else = input;
            self
        }
        /// <p>The type of the property to evaluate.</p>
        pub fn operand_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.operand_type = Some(input.into());
            self
        }
        /// <p>The type of the property to evaluate.</p>
        pub fn set_operand_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.operand_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ComponentConditionProperty`](crate::model::ComponentConditionProperty).
        pub fn build(self) -> crate::model::ComponentConditionProperty {
            crate::model::ComponentConditionProperty {
                property: self.property,
                field: self.field,
                operator: self.operator,
                operand: self.operand,
                then: self.then,
                r#else: self.r#else,
                operand_type: self.operand_type,
            }
        }
    }
}
impl ComponentConditionProperty {
    /// Creates a new builder-style object to manufacture [`ComponentConditionProperty`](crate::model::ComponentConditionProperty).
    pub fn builder() -> crate::model::component_condition_property::Builder {
        crate::model::component_condition_property::Builder::default()
    }
}

/// <p>Describes how to bind a component property to form data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FormBindingElement {
    /// <p>The name of the component to retrieve a value from.</p>
    #[doc(hidden)]
    pub element: std::option::Option<std::string::String>,
    /// <p>The property to retrieve a value from.</p>
    #[doc(hidden)]
    pub property: std::option::Option<std::string::String>,
}
impl FormBindingElement {
    /// <p>The name of the component to retrieve a value from.</p>
    pub fn element(&self) -> std::option::Option<&str> {
        self.element.as_deref()
    }
    /// <p>The property to retrieve a value from.</p>
    pub fn property(&self) -> std::option::Option<&str> {
        self.property.as_deref()
    }
}
/// See [`FormBindingElement`](crate::model::FormBindingElement).
pub mod form_binding_element {

    /// A builder for [`FormBindingElement`](crate::model::FormBindingElement).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) element: std::option::Option<std::string::String>,
        pub(crate) property: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the component to retrieve a value from.</p>
        pub fn element(mut self, input: impl Into<std::string::String>) -> Self {
            self.element = Some(input.into());
            self
        }
        /// <p>The name of the component to retrieve a value from.</p>
        pub fn set_element(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.element = input;
            self
        }
        /// <p>The property to retrieve a value from.</p>
        pub fn property(mut self, input: impl Into<std::string::String>) -> Self {
            self.property = Some(input.into());
            self
        }
        /// <p>The property to retrieve a value from.</p>
        pub fn set_property(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.property = input;
            self
        }
        /// Consumes the builder and constructs a [`FormBindingElement`](crate::model::FormBindingElement).
        pub fn build(self) -> crate::model::FormBindingElement {
            crate::model::FormBindingElement {
                element: self.element,
                property: self.property,
            }
        }
    }
}
impl FormBindingElement {
    /// Creates a new builder-style object to manufacture [`FormBindingElement`](crate::model::FormBindingElement).
    pub fn builder() -> crate::model::form_binding_element::Builder {
        crate::model::form_binding_element::Builder::default()
    }
}

/// <p>Associates a component property to a binding property. This enables exposed properties on the top level component to propagate data to the component's property values.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComponentPropertyBindingProperties {
    /// <p>The component property to bind to the data field.</p>
    #[doc(hidden)]
    pub property: std::option::Option<std::string::String>,
    /// <p>The data field to bind the property to.</p>
    #[doc(hidden)]
    pub field: std::option::Option<std::string::String>,
}
impl ComponentPropertyBindingProperties {
    /// <p>The component property to bind to the data field.</p>
    pub fn property(&self) -> std::option::Option<&str> {
        self.property.as_deref()
    }
    /// <p>The data field to bind the property to.</p>
    pub fn field(&self) -> std::option::Option<&str> {
        self.field.as_deref()
    }
}
/// See [`ComponentPropertyBindingProperties`](crate::model::ComponentPropertyBindingProperties).
pub mod component_property_binding_properties {

    /// A builder for [`ComponentPropertyBindingProperties`](crate::model::ComponentPropertyBindingProperties).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) property: std::option::Option<std::string::String>,
        pub(crate) field: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The component property to bind to the data field.</p>
        pub fn property(mut self, input: impl Into<std::string::String>) -> Self {
            self.property = Some(input.into());
            self
        }
        /// <p>The component property to bind to the data field.</p>
        pub fn set_property(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.property = input;
            self
        }
        /// <p>The data field to bind the property to.</p>
        pub fn field(mut self, input: impl Into<std::string::String>) -> Self {
            self.field = Some(input.into());
            self
        }
        /// <p>The data field to bind the property to.</p>
        pub fn set_field(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field = input;
            self
        }
        /// Consumes the builder and constructs a [`ComponentPropertyBindingProperties`](crate::model::ComponentPropertyBindingProperties).
        pub fn build(self) -> crate::model::ComponentPropertyBindingProperties {
            crate::model::ComponentPropertyBindingProperties {
                property: self.property,
                field: self.field,
            }
        }
    }
}
impl ComponentPropertyBindingProperties {
    /// Creates a new builder-style object to manufacture [`ComponentPropertyBindingProperties`](crate::model::ComponentPropertyBindingProperties).
    pub fn builder() -> crate::model::component_property_binding_properties::Builder {
        crate::model::component_property_binding_properties::Builder::default()
    }
}

/// <p>Describes the configuration for binding a component's properties to data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComponentDataConfiguration {
    /// <p>The name of the data model to use to bind data to a component.</p>
    #[doc(hidden)]
    pub model: std::option::Option<std::string::String>,
    /// <p>Describes how to sort the component's properties.</p>
    #[doc(hidden)]
    pub sort: std::option::Option<std::vec::Vec<crate::model::SortProperty>>,
    /// <p>Represents the conditional logic to use when binding data to a component. Use this property to retrieve only a subset of the data in a collection.</p>
    #[doc(hidden)]
    pub predicate: std::option::Option<crate::model::Predicate>,
    /// <p>A list of IDs to use to bind data to a component. Use this property to bind specifically chosen data, rather than data retrieved from a query.</p>
    #[doc(hidden)]
    pub identifiers: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl ComponentDataConfiguration {
    /// <p>The name of the data model to use to bind data to a component.</p>
    pub fn model(&self) -> std::option::Option<&str> {
        self.model.as_deref()
    }
    /// <p>Describes how to sort the component's properties.</p>
    pub fn sort(&self) -> std::option::Option<&[crate::model::SortProperty]> {
        self.sort.as_deref()
    }
    /// <p>Represents the conditional logic to use when binding data to a component. Use this property to retrieve only a subset of the data in a collection.</p>
    pub fn predicate(&self) -> std::option::Option<&crate::model::Predicate> {
        self.predicate.as_ref()
    }
    /// <p>A list of IDs to use to bind data to a component. Use this property to bind specifically chosen data, rather than data retrieved from a query.</p>
    pub fn identifiers(&self) -> std::option::Option<&[std::string::String]> {
        self.identifiers.as_deref()
    }
}
/// See [`ComponentDataConfiguration`](crate::model::ComponentDataConfiguration).
pub mod component_data_configuration {

    /// A builder for [`ComponentDataConfiguration`](crate::model::ComponentDataConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model: std::option::Option<std::string::String>,
        pub(crate) sort: std::option::Option<std::vec::Vec<crate::model::SortProperty>>,
        pub(crate) predicate: std::option::Option<crate::model::Predicate>,
        pub(crate) identifiers: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the data model to use to bind data to a component.</p>
        pub fn model(mut self, input: impl Into<std::string::String>) -> Self {
            self.model = Some(input.into());
            self
        }
        /// <p>The name of the data model to use to bind data to a component.</p>
        pub fn set_model(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model = input;
            self
        }
        /// Appends an item to `sort`.
        ///
        /// To override the contents of this collection use [`set_sort`](Self::set_sort).
        ///
        /// <p>Describes how to sort the component's properties.</p>
        pub fn sort(mut self, input: crate::model::SortProperty) -> Self {
            let mut v = self.sort.unwrap_or_default();
            v.push(input);
            self.sort = Some(v);
            self
        }
        /// <p>Describes how to sort the component's properties.</p>
        pub fn set_sort(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SortProperty>>,
        ) -> Self {
            self.sort = input;
            self
        }
        /// <p>Represents the conditional logic to use when binding data to a component. Use this property to retrieve only a subset of the data in a collection.</p>
        pub fn predicate(mut self, input: crate::model::Predicate) -> Self {
            self.predicate = Some(input);
            self
        }
        /// <p>Represents the conditional logic to use when binding data to a component. Use this property to retrieve only a subset of the data in a collection.</p>
        pub fn set_predicate(
            mut self,
            input: std::option::Option<crate::model::Predicate>,
        ) -> Self {
            self.predicate = input;
            self
        }
        /// Appends an item to `identifiers`.
        ///
        /// To override the contents of this collection use [`set_identifiers`](Self::set_identifiers).
        ///
        /// <p>A list of IDs to use to bind data to a component. Use this property to bind specifically chosen data, rather than data retrieved from a query.</p>
        pub fn identifiers(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.identifiers.unwrap_or_default();
            v.push(input.into());
            self.identifiers = Some(v);
            self
        }
        /// <p>A list of IDs to use to bind data to a component. Use this property to bind specifically chosen data, rather than data retrieved from a query.</p>
        pub fn set_identifiers(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.identifiers = input;
            self
        }
        /// Consumes the builder and constructs a [`ComponentDataConfiguration`](crate::model::ComponentDataConfiguration).
        pub fn build(self) -> crate::model::ComponentDataConfiguration {
            crate::model::ComponentDataConfiguration {
                model: self.model,
                sort: self.sort,
                predicate: self.predicate,
                identifiers: self.identifiers,
            }
        }
    }
}
impl ComponentDataConfiguration {
    /// Creates a new builder-style object to manufacture [`ComponentDataConfiguration`](crate::model::ComponentDataConfiguration).
    pub fn builder() -> crate::model::component_data_configuration::Builder {
        crate::model::component_data_configuration::Builder::default()
    }
}

/// <p>Stores information for generating Amplify DataStore queries. Use a <code>Predicate</code> to retrieve a subset of the data in a collection.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Predicate {
    /// <p>A list of predicates to combine logically.</p>
    #[doc(hidden)]
    pub or: std::option::Option<std::vec::Vec<crate::model::Predicate>>,
    /// <p>A list of predicates to combine logically.</p>
    #[doc(hidden)]
    pub and: std::option::Option<std::vec::Vec<crate::model::Predicate>>,
    /// <p>The field to query.</p>
    #[doc(hidden)]
    pub field: std::option::Option<std::string::String>,
    /// <p>The operator to use to perform the evaluation.</p>
    #[doc(hidden)]
    pub operator: std::option::Option<std::string::String>,
    /// <p>The value to use when performing the evaluation.</p>
    #[doc(hidden)]
    pub operand: std::option::Option<std::string::String>,
}
impl Predicate {
    /// <p>A list of predicates to combine logically.</p>
    pub fn or(&self) -> std::option::Option<&[crate::model::Predicate]> {
        self.or.as_deref()
    }
    /// <p>A list of predicates to combine logically.</p>
    pub fn and(&self) -> std::option::Option<&[crate::model::Predicate]> {
        self.and.as_deref()
    }
    /// <p>The field to query.</p>
    pub fn field(&self) -> std::option::Option<&str> {
        self.field.as_deref()
    }
    /// <p>The operator to use to perform the evaluation.</p>
    pub fn operator(&self) -> std::option::Option<&str> {
        self.operator.as_deref()
    }
    /// <p>The value to use when performing the evaluation.</p>
    pub fn operand(&self) -> std::option::Option<&str> {
        self.operand.as_deref()
    }
}
/// See [`Predicate`](crate::model::Predicate).
pub mod predicate {

    /// A builder for [`Predicate`](crate::model::Predicate).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) or: std::option::Option<std::vec::Vec<crate::model::Predicate>>,
        pub(crate) and: std::option::Option<std::vec::Vec<crate::model::Predicate>>,
        pub(crate) field: std::option::Option<std::string::String>,
        pub(crate) operator: std::option::Option<std::string::String>,
        pub(crate) operand: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `or`.
        ///
        /// To override the contents of this collection use [`set_or`](Self::set_or).
        ///
        /// <p>A list of predicates to combine logically.</p>
        pub fn or(mut self, input: crate::model::Predicate) -> Self {
            let mut v = self.or.unwrap_or_default();
            v.push(input);
            self.or = Some(v);
            self
        }
        /// <p>A list of predicates to combine logically.</p>
        pub fn set_or(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Predicate>>,
        ) -> Self {
            self.or = input;
            self
        }
        /// Appends an item to `and`.
        ///
        /// To override the contents of this collection use [`set_and`](Self::set_and).
        ///
        /// <p>A list of predicates to combine logically.</p>
        pub fn and(mut self, input: crate::model::Predicate) -> Self {
            let mut v = self.and.unwrap_or_default();
            v.push(input);
            self.and = Some(v);
            self
        }
        /// <p>A list of predicates to combine logically.</p>
        pub fn set_and(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Predicate>>,
        ) -> Self {
            self.and = input;
            self
        }
        /// <p>The field to query.</p>
        pub fn field(mut self, input: impl Into<std::string::String>) -> Self {
            self.field = Some(input.into());
            self
        }
        /// <p>The field to query.</p>
        pub fn set_field(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field = input;
            self
        }
        /// <p>The operator to use to perform the evaluation.</p>
        pub fn operator(mut self, input: impl Into<std::string::String>) -> Self {
            self.operator = Some(input.into());
            self
        }
        /// <p>The operator to use to perform the evaluation.</p>
        pub fn set_operator(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.operator = input;
            self
        }
        /// <p>The value to use when performing the evaluation.</p>
        pub fn operand(mut self, input: impl Into<std::string::String>) -> Self {
            self.operand = Some(input.into());
            self
        }
        /// <p>The value to use when performing the evaluation.</p>
        pub fn set_operand(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.operand = input;
            self
        }
        /// Consumes the builder and constructs a [`Predicate`](crate::model::Predicate).
        pub fn build(self) -> crate::model::Predicate {
            crate::model::Predicate {
                or: self.or,
                and: self.and,
                field: self.field,
                operator: self.operator,
                operand: self.operand,
            }
        }
    }
}
impl Predicate {
    /// Creates a new builder-style object to manufacture [`Predicate`](crate::model::Predicate).
    pub fn builder() -> crate::model::predicate::Builder {
        crate::model::predicate::Builder::default()
    }
}

/// <p>Describes how to sort the data that you bind to a component.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SortProperty {
    /// <p>The field to perform the sort on.</p>
    #[doc(hidden)]
    pub field: std::option::Option<std::string::String>,
    /// <p>The direction of the sort, either ascending or descending.</p>
    #[doc(hidden)]
    pub direction: std::option::Option<crate::model::SortDirection>,
}
impl SortProperty {
    /// <p>The field to perform the sort on.</p>
    pub fn field(&self) -> std::option::Option<&str> {
        self.field.as_deref()
    }
    /// <p>The direction of the sort, either ascending or descending.</p>
    pub fn direction(&self) -> std::option::Option<&crate::model::SortDirection> {
        self.direction.as_ref()
    }
}
/// See [`SortProperty`](crate::model::SortProperty).
pub mod sort_property {

    /// A builder for [`SortProperty`](crate::model::SortProperty).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field: std::option::Option<std::string::String>,
        pub(crate) direction: std::option::Option<crate::model::SortDirection>,
    }
    impl Builder {
        /// <p>The field to perform the sort on.</p>
        pub fn field(mut self, input: impl Into<std::string::String>) -> Self {
            self.field = Some(input.into());
            self
        }
        /// <p>The field to perform the sort on.</p>
        pub fn set_field(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field = input;
            self
        }
        /// <p>The direction of the sort, either ascending or descending.</p>
        pub fn direction(mut self, input: crate::model::SortDirection) -> Self {
            self.direction = Some(input);
            self
        }
        /// <p>The direction of the sort, either ascending or descending.</p>
        pub fn set_direction(
            mut self,
            input: std::option::Option<crate::model::SortDirection>,
        ) -> Self {
            self.direction = input;
            self
        }
        /// Consumes the builder and constructs a [`SortProperty`](crate::model::SortProperty).
        pub fn build(self) -> crate::model::SortProperty {
            crate::model::SortProperty {
                field: self.field,
                direction: self.direction,
            }
        }
    }
}
impl SortProperty {
    /// Creates a new builder-style object to manufacture [`SortProperty`](crate::model::SortProperty).
    pub fn builder() -> crate::model::sort_property::Builder {
        crate::model::sort_property::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub struct SortDirection(String);
impl SortDirection {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        &self.0
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ASC", "DESC"]
    }
}
impl<T> std::convert::From<T> for SortDirection
where
    T: std::convert::AsRef<str>,
{
    fn from(s: T) -> Self {
        SortDirection(s.as_ref().to_owned())
    }
}

/// <p>Represents the data binding configuration for a component at runtime. You can use <code>ComponentBindingPropertiesValue</code> to add exposed properties to a component to allow different values to be entered when a component is reused in different places in an app.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComponentBindingPropertiesValue {
    /// <p>The property type.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>Describes the properties to customize with data at runtime.</p>
    #[doc(hidden)]
    pub binding_properties:
        std::option::Option<crate::model::ComponentBindingPropertiesValueProperties>,
    /// <p>The default value of the property.</p>
    #[doc(hidden)]
    pub default_value: std::option::Option<std::string::String>,
}
impl ComponentBindingPropertiesValue {
    /// <p>The property type.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>Describes the properties to customize with data at runtime.</p>
    pub fn binding_properties(
        &self,
    ) -> std::option::Option<&crate::model::ComponentBindingPropertiesValueProperties> {
        self.binding_properties.as_ref()
    }
    /// <p>The default value of the property.</p>
    pub fn default_value(&self) -> std::option::Option<&str> {
        self.default_value.as_deref()
    }
}
/// See [`ComponentBindingPropertiesValue`](crate::model::ComponentBindingPropertiesValue).
pub mod component_binding_properties_value {

    /// A builder for [`ComponentBindingPropertiesValue`](crate::model::ComponentBindingPropertiesValue).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) binding_properties:
            std::option::Option<crate::model::ComponentBindingPropertiesValueProperties>,
        pub(crate) default_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The property type.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The property type.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Describes the properties to customize with data at runtime.</p>
        pub fn binding_properties(
            mut self,
            input: crate::model::ComponentBindingPropertiesValueProperties,
        ) -> Self {
            self.binding_properties = Some(input);
            self
        }
        /// <p>Describes the properties to customize with data at runtime.</p>
        pub fn set_binding_properties(
            mut self,
            input: std::option::Option<crate::model::ComponentBindingPropertiesValueProperties>,
        ) -> Self {
            self.binding_properties = input;
            self
        }
        /// <p>The default value of the property.</p>
        pub fn default_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_value = Some(input.into());
            self
        }
        /// <p>The default value of the property.</p>
        pub fn set_default_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_value = input;
            self
        }
        /// Consumes the builder and constructs a [`ComponentBindingPropertiesValue`](crate::model::ComponentBindingPropertiesValue).
        pub fn build(self) -> crate::model::ComponentBindingPropertiesValue {
            crate::model::ComponentBindingPropertiesValue {
                r#type: self.r#type,
                binding_properties: self.binding_properties,
                default_value: self.default_value,
            }
        }
    }
}
impl ComponentBindingPropertiesValue {
    /// Creates a new builder-style object to manufacture [`ComponentBindingPropertiesValue`](crate::model::ComponentBindingPropertiesValue).
    pub fn builder() -> crate::model::component_binding_properties_value::Builder {
        crate::model::component_binding_properties_value::Builder::default()
    }
}

/// <p>Represents the data binding configuration for a specific property using data stored in Amazon Web Services. For Amazon Web Services connected properties, you can bind a property to data stored in an Amazon S3 bucket, an Amplify DataStore model or an authenticated user attribute.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComponentBindingPropertiesValueProperties {
    /// <p>An Amplify DataStore model.</p>
    #[doc(hidden)]
    pub model: std::option::Option<std::string::String>,
    /// <p>The field to bind the data to.</p>
    #[doc(hidden)]
    pub field: std::option::Option<std::string::String>,
    /// <p>A list of predicates for binding a component's properties to data.</p>
    #[doc(hidden)]
    pub predicates: std::option::Option<std::vec::Vec<crate::model::Predicate>>,
    /// <p>An authenticated user attribute.</p>
    #[doc(hidden)]
    pub user_attribute: std::option::Option<std::string::String>,
    /// <p>An Amazon S3 bucket.</p>
    #[doc(hidden)]
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The storage key for an Amazon S3 bucket.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The default value to assign to the property.</p>
    #[doc(hidden)]
    pub default_value: std::option::Option<std::string::String>,
    /// <p>The name of a component slot.</p>
    #[doc(hidden)]
    pub slot_name: std::option::Option<std::string::String>,
}
impl ComponentBindingPropertiesValueProperties {
    /// <p>An Amplify DataStore model.</p>
    pub fn model(&self) -> std::option::Option<&str> {
        self.model.as_deref()
    }
    /// <p>The field to bind the data to.</p>
    pub fn field(&self) -> std::option::Option<&str> {
        self.field.as_deref()
    }
    /// <p>A list of predicates for binding a component's properties to data.</p>
    pub fn predicates(&self) -> std::option::Option<&[crate::model::Predicate]> {
        self.predicates.as_deref()
    }
    /// <p>An authenticated user attribute.</p>
    pub fn user_attribute(&self) -> std::option::Option<&str> {
        self.user_attribute.as_deref()
    }
    /// <p>An Amazon S3 bucket.</p>
    pub fn bucket(&self) -> std::option::Option<&str> {
        self.bucket.as_deref()
    }
    /// <p>The storage key for an Amazon S3 bucket.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The default value to assign to the property.</p>
    pub fn default_value(&self) -> std::option::Option<&str> {
        self.default_value.as_deref()
    }
    /// <p>The name of a component slot.</p>
    pub fn slot_name(&self) -> std::option::Option<&str> {
        self.slot_name.as_deref()
    }
}
/// See [`ComponentBindingPropertiesValueProperties`](crate::model::ComponentBindingPropertiesValueProperties).
pub mod component_binding_properties_value_properties {

    /// A builder for [`ComponentBindingPropertiesValueProperties`](crate::model::ComponentBindingPropertiesValueProperties).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model: std::option::Option<std::string::String>,
        pub(crate) field: std::option::Option<std::string::String>,
        pub(crate) predicates: std::option::Option<std::vec::Vec<crate::model::Predicate>>,
        pub(crate) user_attribute: std::option::Option<std::string::String>,
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) default_value: std::option::Option<std::string::String>,
        pub(crate) slot_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An Amplify DataStore model.</p>
        pub fn model(mut self, input: impl Into<std::string::String>) -> Self {
            self.model = Some(input.into());
            self
        }
        /// <p>An Amplify DataStore model.</p>
        pub fn set_model(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model = input;
            self
        }
        /// <p>The field to bind the data to.</p>
        pub fn field(mut self, input: impl Into<std::string::String>) -> Self {
            self.field = Some(input.into());
            self
        }
        /// <p>The field to bind the data to.</p>
        pub fn set_field(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field = input;
            self
        }
        /// Appends an item to `predicates`.
        ///
        /// To override the contents of this collection use [`set_predicates`](Self::set_predicates).
        ///
        /// <p>A list of predicates for binding a component's properties to data.</p>
        pub fn predicates(mut self, input: crate::model::Predicate) -> Self {
            let mut v = self.predicates.unwrap_or_default();
            v.push(input);
            self.predicates = Some(v);
            self
        }
        /// <p>A list of predicates for binding a component's properties to data.</p>
        pub fn set_predicates(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Predicate>>,
        ) -> Self {
            self.predicates = input;
            self
        }
        /// <p>An authenticated user attribute.</p>
        pub fn user_attribute(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_attribute = Some(input.into());
            self
        }
        /// <p>An authenticated user attribute.</p>
        pub fn set_user_attribute(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.user_attribute = input;
            self
        }
        /// <p>An Amazon S3 bucket.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        /// <p>An Amazon S3 bucket.</p>
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The storage key for an Amazon S3 bucket.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The storage key for an Amazon S3 bucket.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The default value to assign to the property.</p>
        pub fn default_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_value = Some(input.into());
            self
        }
        /// <p>The default value to assign to the property.</p>
        pub fn set_default_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_value = input;
            self
        }
        /// <p>The name of a component slot.</p>
        pub fn slot_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.slot_name = Some(input.into());
            self
        }
        /// <p>The name of a component slot.</p>
        pub fn set_slot_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.slot_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ComponentBindingPropertiesValueProperties`](crate::model::ComponentBindingPropertiesValueProperties).
        pub fn build(self) -> crate::model::ComponentBindingPropertiesValueProperties {
            crate::model::ComponentBindingPropertiesValueProperties {
                model: self.model,
                field: self.field,
                predicates: self.predicates,
                user_attribute: self.user_attribute,
                bucket: self.bucket,
                key: self.key,
                default_value: self.default_value,
                slot_name: self.slot_name,
            }
        }
    }
}
impl ComponentBindingPropertiesValueProperties {
    /// Creates a new builder-style object to manufacture [`ComponentBindingPropertiesValueProperties`](crate::model::ComponentBindingPropertiesValueProperties).
    pub fn builder() -> crate::model::component_binding_properties_value_properties::Builder {
        crate::model::component_binding_properties_value_properties::Builder::default()
    }
}

/// <p>Describes the style configuration of a unique variation of a main component.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComponentVariant {
    /// <p>The combination of variants that comprise this variant. You can't specify <code>tags</code> as a valid property for <code>variantValues</code>.</p>
    #[doc(hidden)]
    pub variant_values:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The properties of the component variant that can be overriden when customizing an instance of the component. You can't specify <code>tags</code> as a valid property for <code>overrides</code>.</p>
    #[doc(hidden)]
    pub overrides: std::option::Option<
        std::collections::HashMap<
            std::string::String,
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    >,
}
impl ComponentVariant {
    /// <p>The combination of variants that comprise this variant. You can't specify <code>tags</code> as a valid property for <code>variantValues</code>.</p>
    pub fn variant_values(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.variant_values.as_ref()
    }
    /// <p>The properties of the component variant that can be overriden when customizing an instance of the component. You can't specify <code>tags</code> as a valid property for <code>overrides</code>.</p>
    pub fn overrides(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<
            std::string::String,
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    > {
        self.overrides.as_ref()
    }
}
/// See [`ComponentVariant`](crate::model::ComponentVariant).
pub mod component_variant {

    /// A builder for [`ComponentVariant`](crate::model::ComponentVariant).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) variant_values: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) overrides: std::option::Option<
            std::collections::HashMap<
                std::string::String,
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        >,
    }
    impl Builder {
        /// Adds a key-value pair to `variant_values`.
        ///
        /// To override the contents of this collection use [`set_variant_values`](Self::set_variant_values).
        ///
        /// <p>The combination of variants that comprise this variant. You can't specify <code>tags</code> as a valid property for <code>variantValues</code>.</p>
        pub fn variant_values(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.variant_values.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.variant_values = Some(hash_map);
            self
        }
        /// <p>The combination of variants that comprise this variant. You can't specify <code>tags</code> as a valid property for <code>variantValues</code>.</p>
        pub fn set_variant_values(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.variant_values = input;
            self
        }
        /// Adds a key-value pair to `overrides`.
        ///
        /// To override the contents of this collection use [`set_overrides`](Self::set_overrides).
        ///
        /// <p>The properties of the component variant that can be overriden when customizing an instance of the component. You can't specify <code>tags</code> as a valid property for <code>overrides</code>.</p>
        pub fn overrides(
            mut self,
            k: impl Into<std::string::String>,
            v: std::collections::HashMap<std::string::String, std::string::String>,
        ) -> Self {
            let mut hash_map = self.overrides.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.overrides = Some(hash_map);
            self
        }
        /// <p>The properties of the component variant that can be overriden when customizing an instance of the component. You can't specify <code>tags</code> as a valid property for <code>overrides</code>.</p>
        pub fn set_overrides(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    std::collections::HashMap<std::string::String, std::string::String>,
                >,
            >,
        ) -> Self {
            self.overrides = input;
            self
        }
        /// Consumes the builder and constructs a [`ComponentVariant`](crate::model::ComponentVariant).
        pub fn build(self) -> crate::model::ComponentVariant {
            crate::model::ComponentVariant {
                variant_values: self.variant_values,
                overrides: self.overrides,
            }
        }
    }
}
impl ComponentVariant {
    /// Creates a new builder-style object to manufacture [`ComponentVariant`](crate::model::ComponentVariant).
    pub fn builder() -> crate::model::component_variant::Builder {
        crate::model::component_variant::Builder::default()
    }
}

/// <p>A nested UI configuration within a parent <code>Component</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComponentChild {
    /// <p>The type of the child component. </p>
    #[doc(hidden)]
    pub component_type: std::option::Option<std::string::String>,
    /// <p>The name of the child component.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Describes the properties of the child component. You can't specify <code>tags</code> as a valid property for <code>properties</code>.</p>
    #[doc(hidden)]
    pub properties: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::ComponentProperty>,
    >,
    /// <p>The list of <code>ComponentChild</code> instances for this component.</p>
    #[doc(hidden)]
    pub children: std::option::Option<std::vec::Vec<crate::model::ComponentChild>>,
    /// <p>Describes the events that can be raised on the child component. Use for the workflow feature in Amplify Studio that allows you to bind events and actions to components.</p>
    #[doc(hidden)]
    pub events: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::ComponentEvent>,
    >,
    /// <p>The unique ID of the child component in its original source system, such as Figma.</p>
    #[doc(hidden)]
    pub source_id: std::option::Option<std::string::String>,
}
impl ComponentChild {
    /// <p>The type of the child component. </p>
    pub fn component_type(&self) -> std::option::Option<&str> {
        self.component_type.as_deref()
    }
    /// <p>The name of the child component.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Describes the properties of the child component. You can't specify <code>tags</code> as a valid property for <code>properties</code>.</p>
    pub fn properties(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::ComponentProperty>,
    > {
        self.properties.as_ref()
    }
    /// <p>The list of <code>ComponentChild</code> instances for this component.</p>
    pub fn children(&self) -> std::option::Option<&[crate::model::ComponentChild]> {
        self.children.as_deref()
    }
    /// <p>Describes the events that can be raised on the child component. Use for the workflow feature in Amplify Studio that allows you to bind events and actions to components.</p>
    pub fn events(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::ComponentEvent>,
    > {
        self.events.as_ref()
    }
    /// <p>The unique ID of the child component in its original source system, such as Figma.</p>
    pub fn source_id(&self) -> std::option::Option<&str> {
        self.source_id.as_deref()
    }
}
/// See [`ComponentChild`](crate::model::ComponentChild).
pub mod component_child {

    /// A builder for [`ComponentChild`](crate::model::ComponentChild).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) component_type: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) properties: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::ComponentProperty>,
        >,
        pub(crate) children: std::option::Option<std::vec::Vec<crate::model::ComponentChild>>,
        pub(crate) events: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::ComponentEvent>,
        >,
        pub(crate) source_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of the child component. </p>
        pub fn component_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.component_type = Some(input.into());
            self
        }
        /// <p>The type of the child component. </p>
        pub fn set_component_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.component_type = input;
            self
        }
        /// <p>The name of the child component.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the child component.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Adds a key-value pair to `properties`.
        ///
        /// To override the contents of this collection use [`set_properties`](Self::set_properties).
        ///
        /// <p>Describes the properties of the child component. You can't specify <code>tags</code> as a valid property for <code>properties</code>.</p>
        pub fn properties(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::ComponentProperty,
        ) -> Self {
            let mut hash_map = self.properties.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.properties = Some(hash_map);
            self
        }
        /// <p>Describes the properties of the child component. You can't specify <code>tags</code> as a valid property for <code>properties</code>.</p>
        pub fn set_properties(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::ComponentProperty>,
            >,
        ) -> Self {
            self.properties = input;
            self
        }
        /// Appends an item to `children`.
        ///
        /// To override the contents of this collection use [`set_children`](Self::set_children).
        ///
        /// <p>The list of <code>ComponentChild</code> instances for this component.</p>
        pub fn children(mut self, input: crate::model::ComponentChild) -> Self {
            let mut v = self.children.unwrap_or_default();
            v.push(input);
            self.children = Some(v);
            self
        }
        /// <p>The list of <code>ComponentChild</code> instances for this component.</p>
        pub fn set_children(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ComponentChild>>,
        ) -> Self {
            self.children = input;
            self
        }
        /// Adds a key-value pair to `events`.
        ///
        /// To override the contents of this collection use [`set_events`](Self::set_events).
        ///
        /// <p>Describes the events that can be raised on the child component. Use for the workflow feature in Amplify Studio that allows you to bind events and actions to components.</p>
        pub fn events(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::ComponentEvent,
        ) -> Self {
            let mut hash_map = self.events.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.events = Some(hash_map);
            self
        }
        /// <p>Describes the events that can be raised on the child component. Use for the workflow feature in Amplify Studio that allows you to bind events and actions to components.</p>
        pub fn set_events(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::ComponentEvent>,
            >,
        ) -> Self {
            self.events = input;
            self
        }
        /// <p>The unique ID of the child component in its original source system, such as Figma.</p>
        pub fn source_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_id = Some(input.into());
            self
        }
        /// <p>The unique ID of the child component in its original source system, such as Figma.</p>
        pub fn set_source_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ComponentChild`](crate::model::ComponentChild).
        pub fn build(self) -> crate::model::ComponentChild {
            crate::model::ComponentChild {
                component_type: self.component_type,
                name: self.name,
                properties: self.properties,
                children: self.children,
                events: self.events,
                source_id: self.source_id,
            }
        }
    }
}
impl ComponentChild {
    /// Creates a new builder-style object to manufacture [`ComponentChild`](crate::model::ComponentChild).
    pub fn builder() -> crate::model::component_child::Builder {
        crate::model::component_child::Builder::default()
    }
}

/// <p>Contains a summary of a component. This is a read-only data type that is returned by <code>ListComponents</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComponentSummary {
    /// <p>The unique ID of the Amplify app associated with the component.</p>
    #[doc(hidden)]
    pub app_id: std::option::Option<std::string::String>,
    /// <p>The name of the backend environment that is a part of the Amplify app.</p>
    #[doc(hidden)]
    pub environment_name: std::option::Option<std::string::String>,
    /// <p>The unique ID of the component.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the component.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The component type.</p>
    #[doc(hidden)]
    pub component_type: std::option::Option<std::string::String>,
}
impl ComponentSummary {
    /// <p>The unique ID of the Amplify app associated with the component.</p>
    pub fn app_id(&self) -> std::option::Option<&str> {
        self.app_id.as_deref()
    }
    /// <p>The name of the backend environment that is a part of the Amplify app.</p>
    pub fn environment_name(&self) -> std::option::Option<&str> {
        self.environment_name.as_deref()
    }
    /// <p>The unique ID of the component.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the component.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The component type.</p>
    pub fn component_type(&self) -> std::option::Option<&str> {
        self.component_type.as_deref()
    }
}
/// See [`ComponentSummary`](crate::model::ComponentSummary).
pub mod component_summary {

    /// A builder for [`ComponentSummary`](crate::model::ComponentSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_id: std::option::Option<std::string::String>,
        pub(crate) environment_name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) component_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique ID of the Amplify app associated with the component.</p>
        pub fn app_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_id = Some(input.into());
            self
        }
        /// <p>The unique ID of the Amplify app associated with the component.</p>
        pub fn set_app_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_id = input;
            self
        }
        /// <p>The name of the backend environment that is a part of the Amplify app.</p>
        pub fn environment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.environment_name = Some(input.into());
            self
        }
        /// <p>The name of the backend environment that is a part of the Amplify app.</p>
        pub fn set_environment_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.environment_name = input;
            self
        }
        /// <p>The unique ID of the component.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique ID of the component.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the component.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the component.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The component type.</p>
        pub fn component_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.component_type = Some(input.into());
            self
        }
        /// <p>The component type.</p>
        pub fn set_component_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.component_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ComponentSummary`](crate::model::ComponentSummary).
        pub fn build(self) -> crate::model::ComponentSummary {
            crate::model::ComponentSummary {
                app_id: self.app_id,
                environment_name: self.environment_name,
                id: self.id,
                name: self.name,
                component_type: self.component_type,
            }
        }
    }
}
impl ComponentSummary {
    /// Creates a new builder-style object to manufacture [`ComponentSummary`](crate::model::ComponentSummary).
    pub fn builder() -> crate::model::component_summary::Builder {
        crate::model::component_summary::Builder::default()
    }
}

/// <p>Represents all of the information that is required to create a component.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateComponentData {
    /// <p>The name of the component</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The unique ID of the component in its original source system, such as Figma.</p>
    #[doc(hidden)]
    pub source_id: std::option::Option<std::string::String>,
    /// <p>The component type. This can be an Amplify custom UI component or another custom component.</p>
    #[doc(hidden)]
    pub component_type: std::option::Option<std::string::String>,
    /// <p>Describes the component's properties.</p>
    #[doc(hidden)]
    pub properties: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::ComponentProperty>,
    >,
    /// <p>A list of child components that are instances of the main component.</p>
    #[doc(hidden)]
    pub children: std::option::Option<std::vec::Vec<crate::model::ComponentChild>>,
    /// <p>A list of the unique variants of this component.</p>
    #[doc(hidden)]
    pub variants: std::option::Option<std::vec::Vec<crate::model::ComponentVariant>>,
    /// <p>Describes the component properties that can be overriden to customize an instance of the component.</p>
    #[doc(hidden)]
    pub overrides: std::option::Option<
        std::collections::HashMap<
            std::string::String,
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    >,
    /// <p>The data binding information for the component's properties.</p>
    #[doc(hidden)]
    pub binding_properties: std::option::Option<
        std::collections::HashMap<
            std::string::String,
            crate::model::ComponentBindingPropertiesValue,
        >,
    >,
    /// <p>The data binding configuration for customizing a component's properties. Use this for a collection component.</p>
    #[doc(hidden)]
    pub collection_properties: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::ComponentDataConfiguration>,
    >,
    /// <p>One or more key-value pairs to use when tagging the component data.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The event configuration for the component. Use for the workflow feature in Amplify Studio that allows you to bind events and actions to components.</p>
    #[doc(hidden)]
    pub events: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::ComponentEvent>,
    >,
    /// <p>The schema version of the component when it was imported.</p>
    #[doc(hidden)]
    pub schema_version: std::option::Option<std::string::String>,
}
impl CreateComponentData {
    /// <p>The name of the component</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The unique ID of the component in its original source system, such as Figma.</p>
    pub fn source_id(&self) -> std::option::Option<&str> {
        self.source_id.as_deref()
    }
    /// <p>The component type. This can be an Amplify custom UI component or another custom component.</p>
    pub fn component_type(&self) -> std::option::Option<&str> {
        self.component_type.as_deref()
    }
    /// <p>Describes the component's properties.</p>
    pub fn properties(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::ComponentProperty>,
    > {
        self.properties.as_ref()
    }
    /// <p>A list of child components that are instances of the main component.</p>
    pub fn children(&self) -> std::option::Option<&[crate::model::ComponentChild]> {
        self.children.as_deref()
    }
    /// <p>A list of the unique variants of this component.</p>
    pub fn variants(&self) -> std::option::Option<&[crate::model::ComponentVariant]> {
        self.variants.as_deref()
    }
    /// <p>Describes the component properties that can be overriden to customize an instance of the component.</p>
    pub fn overrides(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<
            std::string::String,
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    > {
        self.overrides.as_ref()
    }
    /// <p>The data binding information for the component's properties.</p>
    pub fn binding_properties(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<
            std::string::String,
            crate::model::ComponentBindingPropertiesValue,
        >,
    > {
        self.binding_properties.as_ref()
    }
    /// <p>The data binding configuration for customizing a component's properties. Use this for a collection component.</p>
    pub fn collection_properties(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::ComponentDataConfiguration>,
    > {
        self.collection_properties.as_ref()
    }
    /// <p>One or more key-value pairs to use when tagging the component data.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The event configuration for the component. Use for the workflow feature in Amplify Studio that allows you to bind events and actions to components.</p>
    pub fn events(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::ComponentEvent>,
    > {
        self.events.as_ref()
    }
    /// <p>The schema version of the component when it was imported.</p>
    pub fn schema_version(&self) -> std::option::Option<&str> {
        self.schema_version.as_deref()
    }
}
/// See [`CreateComponentData`](crate::model::CreateComponentData).
pub mod create_component_data {

    /// A builder for [`CreateComponentData`](crate::model::CreateComponentData).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) source_id: std::option::Option<std::string::String>,
        pub(crate) component_type: std::option::Option<std::string::String>,
        pub(crate) properties: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::ComponentProperty>,
        >,
        pub(crate) children: std::option::Option<std::vec::Vec<crate::model::ComponentChild>>,
        pub(crate) variants: std::option::Option<std::vec::Vec<crate::model::ComponentVariant>>,
        pub(crate) overrides: std::option::Option<
            std::collections::HashMap<
                std::string::String,
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        >,
        pub(crate) binding_properties: std::option::Option<
            std::collections::HashMap<
                std::string::String,
                crate::model::ComponentBindingPropertiesValue,
            >,
        >,
        pub(crate) collection_properties: std::option::Option<
            std::collections::HashMap<
                std::string::String,
                crate::model::ComponentDataConfiguration,
            >,
        >,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) events: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::ComponentEvent>,
        >,
        pub(crate) schema_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the component</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the component</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The unique ID of the component in its original source system, such as Figma.</p>
        pub fn source_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_id = Some(input.into());
            self
        }
        /// <p>The unique ID of the component in its original source system, such as Figma.</p>
        pub fn set_source_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_id = input;
            self
        }
        /// <p>The component type. This can be an Amplify custom UI component or another custom component.</p>
        pub fn component_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.component_type = Some(input.into());
            self
        }
        /// <p>The component type. This can be an Amplify custom UI component or another custom component.</p>
        pub fn set_component_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.component_type = input;
            self
        }
        /// Adds a key-value pair to `properties`.
        ///
        /// To override the contents of this collection use [`set_properties`](Self::set_properties).
        ///
        /// <p>Describes the component's properties.</p>
        pub fn properties(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::ComponentProperty,
        ) -> Self {
            let mut hash_map = self.properties.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.properties = Some(hash_map);
            self
        }
        /// <p>Describes the component's properties.</p>
        pub fn set_properties(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::ComponentProperty>,
            >,
        ) -> Self {
            self.properties = input;
            self
        }
        /// Appends an item to `children`.
        ///
        /// To override the contents of this collection use [`set_children`](Self::set_children).
        ///
        /// <p>A list of child components that are instances of the main component.</p>
        pub fn children(mut self, input: crate::model::ComponentChild) -> Self {
            let mut v = self.children.unwrap_or_default();
            v.push(input);
            self.children = Some(v);
            self
        }
        /// <p>A list of child components that are instances of the main component.</p>
        pub fn set_children(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ComponentChild>>,
        ) -> Self {
            self.children = input;
            self
        }
        /// Appends an item to `variants`.
        ///
        /// To override the contents of this collection use [`set_variants`](Self::set_variants).
        ///
        /// <p>A list of the unique variants of this component.</p>
        pub fn variants(mut self, input: crate::model::ComponentVariant) -> Self {
            let mut v = self.variants.unwrap_or_default();
            v.push(input);
            self.variants = Some(v);
            self
        }
        /// <p>A list of the unique variants of this component.</p>
        pub fn set_variants(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ComponentVariant>>,
        ) -> Self {
            self.variants = input;
            self
        }
        /// Adds a key-value pair to `overrides`.
        ///
        /// To override the contents of this collection use [`set_overrides`](Self::set_overrides).
        ///
        /// <p>Describes the component properties that can be overriden to customize an instance of the component.</p>
        pub fn overrides(
            mut self,
            k: impl Into<std::string::String>,
            v: std::collections::HashMap<std::string::String, std::string::String>,
        ) -> Self {
            let mut hash_map = self.overrides.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.overrides = Some(hash_map);
            self
        }
        /// <p>Describes the component properties that can be overriden to customize an instance of the component.</p>
        pub fn set_overrides(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    std::collections::HashMap<std::string::String, std::string::String>,
                >,
            >,
        ) -> Self {
            self.overrides = input;
            self
        }
        /// Adds a key-value pair to `binding_properties`.
        ///
        /// To override the contents of this collection use [`set_binding_properties`](Self::set_binding_properties).
        ///
        /// <p>The data binding information for the component's properties.</p>
        pub fn binding_properties(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::ComponentBindingPropertiesValue,
        ) -> Self {
            let mut hash_map = self.binding_properties.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.binding_properties = Some(hash_map);
            self
        }
        /// <p>The data binding information for the component's properties.</p>
        pub fn set_binding_properties(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    crate::model::ComponentBindingPropertiesValue,
                >,
            >,
        ) -> Self {
            self.binding_properties = input;
            self
        }
        /// Adds a key-value pair to `collection_properties`.
        ///
        /// To override the contents of this collection use [`set_collection_properties`](Self::set_collection_properties).
        ///
        /// <p>The data binding configuration for customizing a component's properties. Use this for a collection component.</p>
        pub fn collection_properties(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::ComponentDataConfiguration,
        ) -> Self {
            let mut hash_map = self.collection_properties.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.collection_properties = Some(hash_map);
            self
        }
        /// <p>The data binding configuration for customizing a component's properties. Use this for a collection component.</p>
        pub fn set_collection_properties(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    crate::model::ComponentDataConfiguration,
                >,
            >,
        ) -> Self {
            self.collection_properties = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>One or more key-value pairs to use when tagging the component data.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>One or more key-value pairs to use when tagging the component data.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Adds a key-value pair to `events`.
        ///
        /// To override the contents of this collection use [`set_events`](Self::set_events).
        ///
        /// <p>The event configuration for the component. Use for the workflow feature in Amplify Studio that allows you to bind events and actions to components.</p>
        pub fn events(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::ComponentEvent,
        ) -> Self {
            let mut hash_map = self.events.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.events = Some(hash_map);
            self
        }
        /// <p>The event configuration for the component. Use for the workflow feature in Amplify Studio that allows you to bind events and actions to components.</p>
        pub fn set_events(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::ComponentEvent>,
            >,
        ) -> Self {
            self.events = input;
            self
        }
        /// <p>The schema version of the component when it was imported.</p>
        pub fn schema_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.schema_version = Some(input.into());
            self
        }
        /// <p>The schema version of the component when it was imported.</p>
        pub fn set_schema_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.schema_version = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateComponentData`](crate::model::CreateComponentData).
        pub fn build(self) -> crate::model::CreateComponentData {
            crate::model::CreateComponentData {
                name: self.name,
                source_id: self.source_id,
                component_type: self.component_type,
                properties: self.properties,
                children: self.children,
                variants: self.variants,
                overrides: self.overrides,
                binding_properties: self.binding_properties,
                collection_properties: self.collection_properties,
                tags: self.tags,
                events: self.events,
                schema_version: self.schema_version,
            }
        }
    }
}
impl CreateComponentData {
    /// Creates a new builder-style object to manufacture [`CreateComponentData`](crate::model::CreateComponentData).
    pub fn builder() -> crate::model::create_component_data::Builder {
        crate::model::create_component_data::Builder::default()
    }
}

/// <p>Updates and saves all of the information about a component, based on component ID.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateComponentData {
    /// <p>The unique ID of the component to update.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the component to update.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The unique ID of the component in its original source system, such as Figma.</p>
    #[doc(hidden)]
    pub source_id: std::option::Option<std::string::String>,
    /// <p>The type of the component. This can be an Amplify custom UI component or another custom component.</p>
    #[doc(hidden)]
    pub component_type: std::option::Option<std::string::String>,
    /// <p>Describes the component's properties.</p>
    #[doc(hidden)]
    pub properties: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::ComponentProperty>,
    >,
    /// <p>The components that are instances of the main component.</p>
    #[doc(hidden)]
    pub children: std::option::Option<std::vec::Vec<crate::model::ComponentChild>>,
    /// <p>A list of the unique variants of the main component being updated.</p>
    #[doc(hidden)]
    pub variants: std::option::Option<std::vec::Vec<crate::model::ComponentVariant>>,
    /// <p>Describes the properties that can be overriden to customize the component.</p>
    #[doc(hidden)]
    pub overrides: std::option::Option<
        std::collections::HashMap<
            std::string::String,
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    >,
    /// <p>The data binding information for the component's properties.</p>
    #[doc(hidden)]
    pub binding_properties: std::option::Option<
        std::collections::HashMap<
            std::string::String,
            crate::model::ComponentBindingPropertiesValue,
        >,
    >,
    /// <p>The configuration for binding a component's properties to a data model. Use this for a collection component.</p>
    #[doc(hidden)]
    pub collection_properties: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::ComponentDataConfiguration>,
    >,
    /// <p>The event configuration for the component. Use for the workflow feature in Amplify Studio that allows you to bind events and actions to components.</p>
    #[doc(hidden)]
    pub events: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::ComponentEvent>,
    >,
    /// <p>The schema version of the component when it was imported.</p>
    #[doc(hidden)]
    pub schema_version: std::option::Option<std::string::String>,
}
impl UpdateComponentData {
    /// <p>The unique ID of the component to update.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the component to update.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The unique ID of the component in its original source system, such as Figma.</p>
    pub fn source_id(&self) -> std::option::Option<&str> {
        self.source_id.as_deref()
    }
    /// <p>The type of the component. This can be an Amplify custom UI component or another custom component.</p>
    pub fn component_type(&self) -> std::option::Option<&str> {
        self.component_type.as_deref()
    }
    /// <p>Describes the component's properties.</p>
    pub fn properties(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::ComponentProperty>,
    > {
        self.properties.as_ref()
    }
    /// <p>The components that are instances of the main component.</p>
    pub fn children(&self) -> std::option::Option<&[crate::model::ComponentChild]> {
        self.children.as_deref()
    }
    /// <p>A list of the unique variants of the main component being updated.</p>
    pub fn variants(&self) -> std::option::Option<&[crate::model::ComponentVariant]> {
        self.variants.as_deref()
    }
    /// <p>Describes the properties that can be overriden to customize the component.</p>
    pub fn overrides(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<
            std::string::String,
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    > {
        self.overrides.as_ref()
    }
    /// <p>The data binding information for the component's properties.</p>
    pub fn binding_properties(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<
            std::string::String,
            crate::model::ComponentBindingPropertiesValue,
        >,
    > {
        self.binding_properties.as_ref()
    }
    /// <p>The configuration for binding a component's properties to a data model. Use this for a collection component.</p>
    pub fn collection_properties(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::ComponentDataConfiguration>,
    > {
        self.collection_properties.as_ref()
    }
    /// <p>The event configuration for the component. Use for the workflow feature in Amplify Studio that allows you to bind events and actions to components.</p>
    pub fn events(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::ComponentEvent>,
    > {
        self.events.as_ref()
    }
    /// <p>The schema version of the component when it was imported.</p>
    pub fn schema_version(&self) -> std::option::Option<&str> {
        self.schema_version.as_deref()
    }
}
/// See [`UpdateComponentData`](crate::model::UpdateComponentData).
pub mod update_component_data {

    /// A builder for [`UpdateComponentData`](crate::model::UpdateComponentData).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) source_id: std::option::Option<std::string::String>,
        pub(crate) component_type: std::option::Option<std::string::String>,
        pub(crate) properties: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::ComponentProperty>,
        >,
        pub(crate) children: std::option::Option<std::vec::Vec<crate::model::ComponentChild>>,
        pub(crate) variants: std::option::Option<std::vec::Vec<crate::model::ComponentVariant>>,
        pub(crate) overrides: std::option::Option<
            std::collections::HashMap<
                std::string::String,
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        >,
        pub(crate) binding_properties: std::option::Option<
            std::collections::HashMap<
                std::string::String,
                crate::model::ComponentBindingPropertiesValue,
            >,
        >,
        pub(crate) collection_properties: std::option::Option<
            std::collections::HashMap<
                std::string::String,
                crate::model::ComponentDataConfiguration,
            >,
        >,
        pub(crate) events: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::ComponentEvent>,
        >,
        pub(crate) schema_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique ID of the component to update.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique ID of the component to update.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the component to update.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the component to update.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The unique ID of the component in its original source system, such as Figma.</p>
        pub fn source_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_id = Some(input.into());
            self
        }
        /// <p>The unique ID of the component in its original source system, such as Figma.</p>
        pub fn set_source_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_id = input;
            self
        }
        /// <p>The type of the component. This can be an Amplify custom UI component or another custom component.</p>
        pub fn component_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.component_type = Some(input.into());
            self
        }
        /// <p>The type of the component. This can be an Amplify custom UI component or another custom component.</p>
        pub fn set_component_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.component_type = input;
            self
        }
        /// Adds a key-value pair to `properties`.
        ///
        /// To override the contents of this collection use [`set_properties`](Self::set_properties).
        ///
        /// <p>Describes the component's properties.</p>
        pub fn properties(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::ComponentProperty,
        ) -> Self {
            let mut hash_map = self.properties.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.properties = Some(hash_map);
            self
        }
        /// <p>Describes the component's properties.</p>
        pub fn set_properties(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::ComponentProperty>,
            >,
        ) -> Self {
            self.properties = input;
            self
        }
        /// Appends an item to `children`.
        ///
        /// To override the contents of this collection use [`set_children`](Self::set_children).
        ///
        /// <p>The components that are instances of the main component.</p>
        pub fn children(mut self, input: crate::model::ComponentChild) -> Self {
            let mut v = self.children.unwrap_or_default();
            v.push(input);
            self.children = Some(v);
            self
        }
        /// <p>The components that are instances of the main component.</p>
        pub fn set_children(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ComponentChild>>,
        ) -> Self {
            self.children = input;
            self
        }
        /// Appends an item to `variants`.
        ///
        /// To override the contents of this collection use [`set_variants`](Self::set_variants).
        ///
        /// <p>A list of the unique variants of the main component being updated.</p>
        pub fn variants(mut self, input: crate::model::ComponentVariant) -> Self {
            let mut v = self.variants.unwrap_or_default();
            v.push(input);
            self.variants = Some(v);
            self
        }
        /// <p>A list of the unique variants of the main component being updated.</p>
        pub fn set_variants(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ComponentVariant>>,
        ) -> Self {
            self.variants = input;
            self
        }
        /// Adds a key-value pair to `overrides`.
        ///
        /// To override the contents of this collection use [`set_overrides`](Self::set_overrides).
        ///
        /// <p>Describes the properties that can be overriden to customize the component.</p>
        pub fn overrides(
            mut self,
            k: impl Into<std::string::String>,
            v: std::collections::HashMap<std::string::String, std::string::String>,
        ) -> Self {
            let mut hash_map = self.overrides.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.overrides = Some(hash_map);
            self
        }
        /// <p>Describes the properties that can be overriden to customize the component.</p>
        pub fn set_overrides(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    std::collections::HashMap<std::string::String, std::string::String>,
                >,
            >,
        ) -> Self {
            self.overrides = input;
            self
        }
        /// Adds a key-value pair to `binding_properties`.
        ///
        /// To override the contents of this collection use [`set_binding_properties`](Self::set_binding_properties).
        ///
        /// <p>The data binding information for the component's properties.</p>
        pub fn binding_properties(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::ComponentBindingPropertiesValue,
        ) -> Self {
            let mut hash_map = self.binding_properties.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.binding_properties = Some(hash_map);
            self
        }
        /// <p>The data binding information for the component's properties.</p>
        pub fn set_binding_properties(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    crate::model::ComponentBindingPropertiesValue,
                >,
            >,
        ) -> Self {
            self.binding_properties = input;
            self
        }
        /// Adds a key-value pair to `collection_properties`.
        ///
        /// To override the contents of this collection use [`set_collection_properties`](Self::set_collection_properties).
        ///
        /// <p>The configuration for binding a component's properties to a data model. Use this for a collection component.</p>
        pub fn collection_properties(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::ComponentDataConfiguration,
        ) -> Self {
            let mut hash_map = self.collection_properties.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.collection_properties = Some(hash_map);
            self
        }
        /// <p>The configuration for binding a component's properties to a data model. Use this for a collection component.</p>
        pub fn set_collection_properties(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    crate::model::ComponentDataConfiguration,
                >,
            >,
        ) -> Self {
            self.collection_properties = input;
            self
        }
        /// Adds a key-value pair to `events`.
        ///
        /// To override the contents of this collection use [`set_events`](Self::set_events).
        ///
        /// <p>The event configuration for the component. Use for the workflow feature in Amplify Studio that allows you to bind events and actions to components.</p>
        pub fn events(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::ComponentEvent,
        ) -> Self {
            let mut hash_map = self.events.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.events = Some(hash_map);
            self
        }
        /// <p>The event configuration for the component. Use for the workflow feature in Amplify Studio that allows you to bind events and actions to components.</p>
        pub fn set_events(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::ComponentEvent>,
            >,
        ) -> Self {
            self.events = input;
            self
        }
        /// <p>The schema version of the component when it was imported.</p>
        pub fn schema_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.schema_version = Some(input.into());
            self
        }
        /// <p>The schema version of the component when it was imported.</p>
        pub fn set_schema_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.schema_version = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateComponentData`](crate::model::UpdateComponentData).
        pub fn build(self) -> crate::model::UpdateComponentData {
            crate::model::UpdateComponentData {
                id: self.id,
                name: self.name,
                source_id: self.source_id,
                component_type: self.component_type,
                properties: self.properties,
                children: self.children,
                variants: self.variants,
                overrides: self.overrides,
                binding_properties: self.binding_properties,
                collection_properties: self.collection_properties,
                events: self.events,
                schema_version: self.schema_version,
            }
        }
    }
}
impl UpdateComponentData {
    /// Creates a new builder-style object to manufacture [`UpdateComponentData`](crate::model::UpdateComponentData).
    pub fn builder() -> crate::model::update_component_data::Builder {
        crate::model::update_component_data::Builder::default()
    }
}

/// <p>Describes a refresh token.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RefreshTokenRequestBody {
    /// <p>The token to use to refresh a previously issued access token that might have expired.</p>
    #[doc(hidden)]
    pub token: std::option::Option<std::string::String>,
}
impl RefreshTokenRequestBody {
    /// <p>The token to use to refresh a previously issued access token that might have expired.</p>
    pub fn token(&self) -> std::option::Option<&str> {
        self.token.as_deref()
    }
}
impl std::fmt::Debug for RefreshTokenRequestBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RefreshTokenRequestBody");
        formatter.field("token", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`RefreshTokenRequestBody`](crate::model::RefreshTokenRequestBody).
pub mod refresh_token_request_body {

    /// A builder for [`RefreshTokenRequestBody`](crate::model::RefreshTokenRequestBody).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The token to use to refresh a previously issued access token that might have expired.</p>
        pub fn token(mut self, input: impl Into<std::string::String>) -> Self {
            self.token = Some(input.into());
            self
        }
        /// <p>The token to use to refresh a previously issued access token that might have expired.</p>
        pub fn set_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.token = input;
            self
        }
        /// Consumes the builder and constructs a [`RefreshTokenRequestBody`](crate::model::RefreshTokenRequestBody).
        pub fn build(self) -> crate::model::RefreshTokenRequestBody {
            crate::model::RefreshTokenRequestBody { token: self.token }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("token", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl RefreshTokenRequestBody {
    /// Creates a new builder-style object to manufacture [`RefreshTokenRequestBody`](crate::model::RefreshTokenRequestBody).
    pub fn builder() -> crate::model::refresh_token_request_body::Builder {
        crate::model::refresh_token_request_body::Builder::default()
    }
}

/// When writing a match expression against `TokenProviders`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let tokenproviders = unimplemented!();
/// match tokenproviders {
///     TokenProviders::Figma => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `tokenproviders` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TokenProviders::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TokenProviders::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TokenProviders::NewFeature` is defined.
/// Specifically, when `tokenproviders` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TokenProviders::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TokenProviders {
    /// The figma token provider.
    Figma,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TokenProviders {
    fn from(s: &str) -> Self {
        match s {
            "figma" => TokenProviders::Figma,
            other => TokenProviders::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for TokenProviders {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TokenProviders::from(s))
    }
}
impl TokenProviders {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TokenProviders::Figma => "figma",
            TokenProviders::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["figma"]
    }
}
impl AsRef<str> for TokenProviders {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Stores the metadata information about a feature on a form or view.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PutMetadataFlagBody {
    /// <p>The new information to store.</p>
    #[doc(hidden)]
    pub new_value: std::option::Option<std::string::String>,
}
impl PutMetadataFlagBody {
    /// <p>The new information to store.</p>
    pub fn new_value(&self) -> std::option::Option<&str> {
        self.new_value.as_deref()
    }
}
/// See [`PutMetadataFlagBody`](crate::model::PutMetadataFlagBody).
pub mod put_metadata_flag_body {

    /// A builder for [`PutMetadataFlagBody`](crate::model::PutMetadataFlagBody).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) new_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The new information to store.</p>
        pub fn new_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.new_value = Some(input.into());
            self
        }
        /// <p>The new information to store.</p>
        pub fn set_new_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.new_value = input;
            self
        }
        /// Consumes the builder and constructs a [`PutMetadataFlagBody`](crate::model::PutMetadataFlagBody).
        pub fn build(self) -> crate::model::PutMetadataFlagBody {
            crate::model::PutMetadataFlagBody {
                new_value: self.new_value,
            }
        }
    }
}
impl PutMetadataFlagBody {
    /// Creates a new builder-style object to manufacture [`PutMetadataFlagBody`](crate::model::PutMetadataFlagBody).
    pub fn builder() -> crate::model::put_metadata_flag_body::Builder {
        crate::model::put_metadata_flag_body::Builder::default()
    }
}

/// <p>Describes the configuration of a request to exchange an access code for a token.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExchangeCodeForTokenRequestBody {
    /// <p>The access code to send in the request.</p>
    #[doc(hidden)]
    pub code: std::option::Option<std::string::String>,
    /// <p>The location of the application that will receive the access code.</p>
    #[doc(hidden)]
    pub redirect_uri: std::option::Option<std::string::String>,
}
impl ExchangeCodeForTokenRequestBody {
    /// <p>The access code to send in the request.</p>
    pub fn code(&self) -> std::option::Option<&str> {
        self.code.as_deref()
    }
    /// <p>The location of the application that will receive the access code.</p>
    pub fn redirect_uri(&self) -> std::option::Option<&str> {
        self.redirect_uri.as_deref()
    }
}
impl std::fmt::Debug for ExchangeCodeForTokenRequestBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExchangeCodeForTokenRequestBody");
        formatter.field("code", &"*** Sensitive Data Redacted ***");
        formatter.field("redirect_uri", &self.redirect_uri);
        formatter.finish()
    }
}
/// See [`ExchangeCodeForTokenRequestBody`](crate::model::ExchangeCodeForTokenRequestBody).
pub mod exchange_code_for_token_request_body {

    /// A builder for [`ExchangeCodeForTokenRequestBody`](crate::model::ExchangeCodeForTokenRequestBody).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) redirect_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The access code to send in the request.</p>
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        /// <p>The access code to send in the request.</p>
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>The location of the application that will receive the access code.</p>
        pub fn redirect_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.redirect_uri = Some(input.into());
            self
        }
        /// <p>The location of the application that will receive the access code.</p>
        pub fn set_redirect_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.redirect_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`ExchangeCodeForTokenRequestBody`](crate::model::ExchangeCodeForTokenRequestBody).
        pub fn build(self) -> crate::model::ExchangeCodeForTokenRequestBody {
            crate::model::ExchangeCodeForTokenRequestBody {
                code: self.code,
                redirect_uri: self.redirect_uri,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("code", &"*** Sensitive Data Redacted ***");
            formatter.field("redirect_uri", &self.redirect_uri);
            formatter.finish()
        }
    }
}
impl ExchangeCodeForTokenRequestBody {
    /// Creates a new builder-style object to manufacture [`ExchangeCodeForTokenRequestBody`](crate::model::ExchangeCodeForTokenRequestBody).
    pub fn builder() -> crate::model::exchange_code_for_token_request_body::Builder {
        crate::model::exchange_code_for_token_request_body::Builder::default()
    }
}
