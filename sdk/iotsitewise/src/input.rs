// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;

/// See [`AssociateAssetsInput`](crate::input::AssociateAssetsInput).
pub mod associate_assets_input {
    
    /// A builder for [`AssociateAssetsInput`](crate::input::AssociateAssetsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) asset_id: std::option::Option<std::string::String>,
        pub(crate) hierarchy_id: std::option::Option<std::string::String>,
        pub(crate) child_asset_id: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the parent asset.</p>
        pub fn asset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_id = Some(input.into());
            self
        }
        /// <p>The ID of the parent asset.</p>
        pub fn set_asset_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_id = input; self
        }
        /// <p>The ID of a hierarchy in the parent asset's model. Hierarchies allow different groupings of assets to be formed that all come from the same asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html">Asset hierarchies</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn hierarchy_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hierarchy_id = Some(input.into());
            self
        }
        /// <p>The ID of a hierarchy in the parent asset's model. Hierarchies allow different groupings of assets to be formed that all come from the same asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html">Asset hierarchies</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_hierarchy_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hierarchy_id = input; self
        }
        /// <p>The ID of the child asset to be associated.</p>
        pub fn child_asset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.child_asset_id = Some(input.into());
            self
        }
        /// <p>The ID of the child asset to be associated.</p>
        pub fn set_child_asset_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.child_asset_id = input; self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// Consumes the builder and constructs a [`AssociateAssetsInput`](crate::input::AssociateAssetsInput).
        pub fn build(self) -> Result<crate::input::AssociateAssetsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::AssociateAssetsInput {
                    asset_id: self.asset_id
                    ,
                    hierarchy_id: self.hierarchy_id
                    ,
                    child_asset_id: self.child_asset_id
                    ,
                    client_token: self.client_token
                    ,
                }
            )
        }
    }
    
    
}
impl AssociateAssetsInput {
    /// Consumes the builder and constructs an Operation<[`AssociateAssets`](crate::operation::AssociateAssets)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::AssociateAssets, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.client_token.is_none() {
                                self.client_token = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::input::AssociateAssetsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_1 = &_input.asset_id;
                let input_1 = input_1.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("asset_id", "cannot be empty or unset"))?;
                let asset_id = aws_smithy_http::label::fmt_string(input_1, aws_smithy_http::label::EncodingStrategy::Default);
                if asset_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("asset_id", "cannot be empty or unset"))
                            }
                write!(output, "/assets/{assetId}/associate", assetId = asset_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::AssociateAssetsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_associate_assets(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::AssociateAssets::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("AssociateAssets", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`AssociateAssetsInput`](crate::input::AssociateAssetsInput).
    pub fn builder() -> crate::input::associate_assets_input::Builder {
        crate::input::associate_assets_input::Builder::default()
    }
}

/// See [`AssociateTimeSeriesToAssetPropertyInput`](crate::input::AssociateTimeSeriesToAssetPropertyInput).
pub mod associate_time_series_to_asset_property_input {
    
    /// A builder for [`AssociateTimeSeriesToAssetPropertyInput`](crate::input::AssociateTimeSeriesToAssetPropertyInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) alias: std::option::Option<std::string::String>,
        pub(crate) asset_id: std::option::Option<std::string::String>,
        pub(crate) property_id: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The alias that identifies the time series.</p>
        pub fn alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.alias = Some(input.into());
            self
        }
        /// <p>The alias that identifies the time series.</p>
        pub fn set_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alias = input; self
        }
        /// <p>The ID of the asset in which the asset property was created.</p>
        pub fn asset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset in which the asset property was created.</p>
        pub fn set_asset_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_id = input; self
        }
        /// <p>The ID of the asset property.</p>
        pub fn property_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset property.</p>
        pub fn set_property_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.property_id = input; self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// Consumes the builder and constructs a [`AssociateTimeSeriesToAssetPropertyInput`](crate::input::AssociateTimeSeriesToAssetPropertyInput).
        pub fn build(self) -> Result<crate::input::AssociateTimeSeriesToAssetPropertyInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::AssociateTimeSeriesToAssetPropertyInput {
                    alias: self.alias
                    ,
                    asset_id: self.asset_id
                    ,
                    property_id: self.property_id
                    ,
                    client_token: self.client_token
                    ,
                }
            )
        }
    }
    
    
}
impl AssociateTimeSeriesToAssetPropertyInput {
    /// Consumes the builder and constructs an Operation<[`AssociateTimeSeriesToAssetProperty`](crate::operation::AssociateTimeSeriesToAssetProperty)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::AssociateTimeSeriesToAssetProperty, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.client_token.is_none() {
                                self.client_token = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::input::AssociateTimeSeriesToAssetPropertyInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/timeseries/associate").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::AssociateTimeSeriesToAssetPropertyInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_2 = &_input.alias;
                let inner_2 = inner_2.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("alias", "cannot be empty or unset"))?;
                if inner_2.is_empty() {
                    return Err(aws_smithy_http::operation::error::BuildError::missing_field("alias", "cannot be empty or unset"));
                }
                query.push_kv("alias", &aws_smithy_http::query::fmt_string(&inner_2));
                let inner_3 = &_input.asset_id;
                let inner_3 = inner_3.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("asset_id", "cannot be empty or unset"))?;
                if inner_3.is_empty() {
                    return Err(aws_smithy_http::operation::error::BuildError::missing_field("asset_id", "cannot be empty or unset"));
                }
                query.push_kv("assetId", &aws_smithy_http::query::fmt_string(&inner_3));
                let inner_4 = &_input.property_id;
                let inner_4 = inner_4.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("property_id", "cannot be empty or unset"))?;
                if inner_4.is_empty() {
                    return Err(aws_smithy_http::operation::error::BuildError::missing_field("property_id", "cannot be empty or unset"));
                }
                query.push_kv("propertyId", &aws_smithy_http::query::fmt_string(&inner_4));
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::AssociateTimeSeriesToAssetPropertyInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_associate_time_series_to_asset_property(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::AssociateTimeSeriesToAssetProperty::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("AssociateTimeSeriesToAssetProperty", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`AssociateTimeSeriesToAssetPropertyInput`](crate::input::AssociateTimeSeriesToAssetPropertyInput).
    pub fn builder() -> crate::input::associate_time_series_to_asset_property_input::Builder {
        crate::input::associate_time_series_to_asset_property_input::Builder::default()
    }
}

/// See [`BatchAssociateProjectAssetsInput`](crate::input::BatchAssociateProjectAssetsInput).
pub mod batch_associate_project_assets_input {
    
    /// A builder for [`BatchAssociateProjectAssetsInput`](crate::input::BatchAssociateProjectAssetsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) project_id: std::option::Option<std::string::String>,
        pub(crate) asset_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the project to which to associate the assets.</p>
        pub fn project_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_id = Some(input.into());
            self
        }
        /// <p>The ID of the project to which to associate the assets.</p>
        pub fn set_project_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_id = input; self
        }
        /// Appends an item to `asset_ids`.
        ///
        /// To override the contents of this collection use [`set_asset_ids`](Self::set_asset_ids).
        ///
        /// <p>The IDs of the assets to be associated to the project.</p>
        pub fn asset_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.asset_ids.unwrap_or_default();
                            v.push(input.into());
                            self.asset_ids = Some(v);
                            self
        }
        /// <p>The IDs of the assets to be associated to the project.</p>
        pub fn set_asset_ids(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.asset_ids = input; self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// Consumes the builder and constructs a [`BatchAssociateProjectAssetsInput`](crate::input::BatchAssociateProjectAssetsInput).
        pub fn build(self) -> Result<crate::input::BatchAssociateProjectAssetsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::BatchAssociateProjectAssetsInput {
                    project_id: self.project_id
                    ,
                    asset_ids: self.asset_ids
                    ,
                    client_token: self.client_token
                    ,
                }
            )
        }
    }
    
    
}
impl BatchAssociateProjectAssetsInput {
    /// Consumes the builder and constructs an Operation<[`BatchAssociateProjectAssets`](crate::operation::BatchAssociateProjectAssets)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::BatchAssociateProjectAssets, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.client_token.is_none() {
                                self.client_token = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::input::BatchAssociateProjectAssetsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_5 = &_input.project_id;
                let input_5 = input_5.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("project_id", "cannot be empty or unset"))?;
                let project_id = aws_smithy_http::label::fmt_string(input_5, aws_smithy_http::label::EncodingStrategy::Default);
                if project_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("project_id", "cannot be empty or unset"))
                            }
                write!(output, "/projects/{projectId}/assets/associate", projectId = project_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::BatchAssociateProjectAssetsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_batch_associate_project_assets(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("monitor.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::BatchAssociateProjectAssets::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("BatchAssociateProjectAssets", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`BatchAssociateProjectAssetsInput`](crate::input::BatchAssociateProjectAssetsInput).
    pub fn builder() -> crate::input::batch_associate_project_assets_input::Builder {
        crate::input::batch_associate_project_assets_input::Builder::default()
    }
}

/// See [`BatchDisassociateProjectAssetsInput`](crate::input::BatchDisassociateProjectAssetsInput).
pub mod batch_disassociate_project_assets_input {
    
    /// A builder for [`BatchDisassociateProjectAssetsInput`](crate::input::BatchDisassociateProjectAssetsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) project_id: std::option::Option<std::string::String>,
        pub(crate) asset_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the project from which to disassociate the assets.</p>
        pub fn project_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_id = Some(input.into());
            self
        }
        /// <p>The ID of the project from which to disassociate the assets.</p>
        pub fn set_project_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_id = input; self
        }
        /// Appends an item to `asset_ids`.
        ///
        /// To override the contents of this collection use [`set_asset_ids`](Self::set_asset_ids).
        ///
        /// <p>The IDs of the assets to be disassociated from the project.</p>
        pub fn asset_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.asset_ids.unwrap_or_default();
                            v.push(input.into());
                            self.asset_ids = Some(v);
                            self
        }
        /// <p>The IDs of the assets to be disassociated from the project.</p>
        pub fn set_asset_ids(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.asset_ids = input; self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// Consumes the builder and constructs a [`BatchDisassociateProjectAssetsInput`](crate::input::BatchDisassociateProjectAssetsInput).
        pub fn build(self) -> Result<crate::input::BatchDisassociateProjectAssetsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::BatchDisassociateProjectAssetsInput {
                    project_id: self.project_id
                    ,
                    asset_ids: self.asset_ids
                    ,
                    client_token: self.client_token
                    ,
                }
            )
        }
    }
    
    
}
impl BatchDisassociateProjectAssetsInput {
    /// Consumes the builder and constructs an Operation<[`BatchDisassociateProjectAssets`](crate::operation::BatchDisassociateProjectAssets)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::BatchDisassociateProjectAssets, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.client_token.is_none() {
                                self.client_token = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::input::BatchDisassociateProjectAssetsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_6 = &_input.project_id;
                let input_6 = input_6.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("project_id", "cannot be empty or unset"))?;
                let project_id = aws_smithy_http::label::fmt_string(input_6, aws_smithy_http::label::EncodingStrategy::Default);
                if project_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("project_id", "cannot be empty or unset"))
                            }
                write!(output, "/projects/{projectId}/assets/disassociate", projectId = project_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::BatchDisassociateProjectAssetsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_batch_disassociate_project_assets(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("monitor.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::BatchDisassociateProjectAssets::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("BatchDisassociateProjectAssets", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`BatchDisassociateProjectAssetsInput`](crate::input::BatchDisassociateProjectAssetsInput).
    pub fn builder() -> crate::input::batch_disassociate_project_assets_input::Builder {
        crate::input::batch_disassociate_project_assets_input::Builder::default()
    }
}

/// See [`BatchGetAssetPropertyAggregatesInput`](crate::input::BatchGetAssetPropertyAggregatesInput).
pub mod batch_get_asset_property_aggregates_input {
    
    /// A builder for [`BatchGetAssetPropertyAggregatesInput`](crate::input::BatchGetAssetPropertyAggregatesInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entries: std::option::Option<std::vec::Vec<crate::model::BatchGetAssetPropertyAggregatesEntry>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// Appends an item to `entries`.
        ///
        /// To override the contents of this collection use [`set_entries`](Self::set_entries).
        ///
        /// <p>The list of asset property aggregate entries for the batch get request. You can specify up to 16 entries per request.</p>
        pub fn entries(mut self, input: crate::model::BatchGetAssetPropertyAggregatesEntry) -> Self {
            let mut v = self.entries.unwrap_or_default();
                            v.push(input);
                            self.entries = Some(v);
                            self
        }
        /// <p>The list of asset property aggregate entries for the batch get request. You can specify up to 16 entries per request.</p>
        pub fn set_entries(mut self, input: std::option::Option<std::vec::Vec<crate::model::BatchGetAssetPropertyAggregatesEntry>>) -> Self {
            self.entries = input; self
        }
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>The maximum number of results to return for each paginated request. A result set is returned in the two cases, whichever occurs first.</p> 
        /// <ul> 
        /// <li> <p>The size of the result set is less than 1 MB.</p> </li> 
        /// <li> <p>The number of data points in the result set is less than the value of <code>maxResults</code>. The maximum value of <code>maxResults</code> is 4000.</p> </li> 
        /// </ul>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return for each paginated request. A result set is returned in the two cases, whichever occurs first.</p> 
        /// <ul> 
        /// <li> <p>The size of the result set is less than 1 MB.</p> </li> 
        /// <li> <p>The number of data points in the result set is less than the value of <code>maxResults</code>. The maximum value of <code>maxResults</code> is 4000.</p> </li> 
        /// </ul>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`BatchGetAssetPropertyAggregatesInput`](crate::input::BatchGetAssetPropertyAggregatesInput).
        pub fn build(self) -> Result<crate::input::BatchGetAssetPropertyAggregatesInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::BatchGetAssetPropertyAggregatesInput {
                    entries: self.entries
                    ,
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                    ,
                }
            )
        }
    }
    
    
}
impl BatchGetAssetPropertyAggregatesInput {
    /// Consumes the builder and constructs an Operation<[`BatchGetAssetPropertyAggregates`](crate::operation::BatchGetAssetPropertyAggregates)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::BatchGetAssetPropertyAggregates, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::BatchGetAssetPropertyAggregatesInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/properties/batch/aggregates").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::BatchGetAssetPropertyAggregatesInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_batch_get_asset_property_aggregates(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("data.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::BatchGetAssetPropertyAggregates::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("BatchGetAssetPropertyAggregates", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`BatchGetAssetPropertyAggregatesInput`](crate::input::BatchGetAssetPropertyAggregatesInput).
    pub fn builder() -> crate::input::batch_get_asset_property_aggregates_input::Builder {
        crate::input::batch_get_asset_property_aggregates_input::Builder::default()
    }
}

/// See [`BatchGetAssetPropertyValueInput`](crate::input::BatchGetAssetPropertyValueInput).
pub mod batch_get_asset_property_value_input {
    
    /// A builder for [`BatchGetAssetPropertyValueInput`](crate::input::BatchGetAssetPropertyValueInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entries: std::option::Option<std::vec::Vec<crate::model::BatchGetAssetPropertyValueEntry>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `entries`.
        ///
        /// To override the contents of this collection use [`set_entries`](Self::set_entries).
        ///
        /// <p>The list of asset property value entries for the batch get request. You can specify up to 16 entries per request.</p>
        pub fn entries(mut self, input: crate::model::BatchGetAssetPropertyValueEntry) -> Self {
            let mut v = self.entries.unwrap_or_default();
                            v.push(input);
                            self.entries = Some(v);
                            self
        }
        /// <p>The list of asset property value entries for the batch get request. You can specify up to 16 entries per request.</p>
        pub fn set_entries(mut self, input: std::option::Option<std::vec::Vec<crate::model::BatchGetAssetPropertyValueEntry>>) -> Self {
            self.entries = input; self
        }
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`BatchGetAssetPropertyValueInput`](crate::input::BatchGetAssetPropertyValueInput).
        pub fn build(self) -> Result<crate::input::BatchGetAssetPropertyValueInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::BatchGetAssetPropertyValueInput {
                    entries: self.entries
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl BatchGetAssetPropertyValueInput {
    /// Consumes the builder and constructs an Operation<[`BatchGetAssetPropertyValue`](crate::operation::BatchGetAssetPropertyValue)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::BatchGetAssetPropertyValue, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::BatchGetAssetPropertyValueInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/properties/batch/latest").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::BatchGetAssetPropertyValueInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_batch_get_asset_property_value(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("data.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::BatchGetAssetPropertyValue::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("BatchGetAssetPropertyValue", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`BatchGetAssetPropertyValueInput`](crate::input::BatchGetAssetPropertyValueInput).
    pub fn builder() -> crate::input::batch_get_asset_property_value_input::Builder {
        crate::input::batch_get_asset_property_value_input::Builder::default()
    }
}

/// See [`BatchGetAssetPropertyValueHistoryInput`](crate::input::BatchGetAssetPropertyValueHistoryInput).
pub mod batch_get_asset_property_value_history_input {
    
    /// A builder for [`BatchGetAssetPropertyValueHistoryInput`](crate::input::BatchGetAssetPropertyValueHistoryInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entries: std::option::Option<std::vec::Vec<crate::model::BatchGetAssetPropertyValueHistoryEntry>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// Appends an item to `entries`.
        ///
        /// To override the contents of this collection use [`set_entries`](Self::set_entries).
        ///
        /// <p>The list of asset property historical value entries for the batch get request. You can specify up to 16 entries per request.</p>
        pub fn entries(mut self, input: crate::model::BatchGetAssetPropertyValueHistoryEntry) -> Self {
            let mut v = self.entries.unwrap_or_default();
                            v.push(input);
                            self.entries = Some(v);
                            self
        }
        /// <p>The list of asset property historical value entries for the batch get request. You can specify up to 16 entries per request.</p>
        pub fn set_entries(mut self, input: std::option::Option<std::vec::Vec<crate::model::BatchGetAssetPropertyValueHistoryEntry>>) -> Self {
            self.entries = input; self
        }
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>The maximum number of results to return for each paginated request. A result set is returned in the two cases, whichever occurs first.</p> 
        /// <ul> 
        /// <li> <p>The size of the result set is less than 1 MB.</p> </li> 
        /// <li> <p>The number of data points in the result set is less than the value of <code>maxResults</code>. The maximum value of <code>maxResults</code> is 4000.</p> </li> 
        /// </ul>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return for each paginated request. A result set is returned in the two cases, whichever occurs first.</p> 
        /// <ul> 
        /// <li> <p>The size of the result set is less than 1 MB.</p> </li> 
        /// <li> <p>The number of data points in the result set is less than the value of <code>maxResults</code>. The maximum value of <code>maxResults</code> is 4000.</p> </li> 
        /// </ul>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`BatchGetAssetPropertyValueHistoryInput`](crate::input::BatchGetAssetPropertyValueHistoryInput).
        pub fn build(self) -> Result<crate::input::BatchGetAssetPropertyValueHistoryInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::BatchGetAssetPropertyValueHistoryInput {
                    entries: self.entries
                    ,
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                    ,
                }
            )
        }
    }
    
    
}
impl BatchGetAssetPropertyValueHistoryInput {
    /// Consumes the builder and constructs an Operation<[`BatchGetAssetPropertyValueHistory`](crate::operation::BatchGetAssetPropertyValueHistory)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::BatchGetAssetPropertyValueHistory, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::BatchGetAssetPropertyValueHistoryInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/properties/batch/history").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::BatchGetAssetPropertyValueHistoryInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_batch_get_asset_property_value_history(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("data.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::BatchGetAssetPropertyValueHistory::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("BatchGetAssetPropertyValueHistory", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`BatchGetAssetPropertyValueHistoryInput`](crate::input::BatchGetAssetPropertyValueHistoryInput).
    pub fn builder() -> crate::input::batch_get_asset_property_value_history_input::Builder {
        crate::input::batch_get_asset_property_value_history_input::Builder::default()
    }
}

/// See [`BatchPutAssetPropertyValueInput`](crate::input::BatchPutAssetPropertyValueInput).
pub mod batch_put_asset_property_value_input {
    
    /// A builder for [`BatchPutAssetPropertyValueInput`](crate::input::BatchPutAssetPropertyValueInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entries: std::option::Option<std::vec::Vec<crate::model::PutAssetPropertyValueEntry>>,
    }
    impl Builder {
        /// Appends an item to `entries`.
        ///
        /// To override the contents of this collection use [`set_entries`](Self::set_entries).
        ///
        /// <p>The list of asset property value entries for the batch put request. You can specify up to 10 entries per request.</p>
        pub fn entries(mut self, input: crate::model::PutAssetPropertyValueEntry) -> Self {
            let mut v = self.entries.unwrap_or_default();
                            v.push(input);
                            self.entries = Some(v);
                            self
        }
        /// <p>The list of asset property value entries for the batch put request. You can specify up to 10 entries per request.</p>
        pub fn set_entries(mut self, input: std::option::Option<std::vec::Vec<crate::model::PutAssetPropertyValueEntry>>) -> Self {
            self.entries = input; self
        }
        /// Consumes the builder and constructs a [`BatchPutAssetPropertyValueInput`](crate::input::BatchPutAssetPropertyValueInput).
        pub fn build(self) -> Result<crate::input::BatchPutAssetPropertyValueInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::BatchPutAssetPropertyValueInput {
                    entries: self.entries
                    ,
                }
            )
        }
    }
    
    
}
impl BatchPutAssetPropertyValueInput {
    /// Consumes the builder and constructs an Operation<[`BatchPutAssetPropertyValue`](crate::operation::BatchPutAssetPropertyValue)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::BatchPutAssetPropertyValue, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::BatchPutAssetPropertyValueInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/properties").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::BatchPutAssetPropertyValueInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_batch_put_asset_property_value(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("data.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::BatchPutAssetPropertyValue::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("BatchPutAssetPropertyValue", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`BatchPutAssetPropertyValueInput`](crate::input::BatchPutAssetPropertyValueInput).
    pub fn builder() -> crate::input::batch_put_asset_property_value_input::Builder {
        crate::input::batch_put_asset_property_value_input::Builder::default()
    }
}

/// See [`CreateAccessPolicyInput`](crate::input::CreateAccessPolicyInput).
pub mod create_access_policy_input {
    
    /// A builder for [`CreateAccessPolicyInput`](crate::input::CreateAccessPolicyInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) access_policy_identity: std::option::Option<crate::model::Identity>,
        pub(crate) access_policy_resource: std::option::Option<crate::model::Resource>,
        pub(crate) access_policy_permission: std::option::Option<crate::model::Permission>,
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    }
    impl Builder {
        /// <p>The identity for this access policy. Choose an IAM Identity Center user, an IAM Identity Center group, or an IAM user.</p>
        pub fn access_policy_identity(mut self, input: crate::model::Identity) -> Self {
            self.access_policy_identity = Some(input);
            self
        }
        /// <p>The identity for this access policy. Choose an IAM Identity Center user, an IAM Identity Center group, or an IAM user.</p>
        pub fn set_access_policy_identity(mut self, input: std::option::Option<crate::model::Identity>) -> Self {
            self.access_policy_identity = input; self
        }
        /// <p>The IoT SiteWise Monitor resource for this access policy. Choose either a portal or a project.</p>
        pub fn access_policy_resource(mut self, input: crate::model::Resource) -> Self {
            self.access_policy_resource = Some(input);
            self
        }
        /// <p>The IoT SiteWise Monitor resource for this access policy. Choose either a portal or a project.</p>
        pub fn set_access_policy_resource(mut self, input: std::option::Option<crate::model::Resource>) -> Self {
            self.access_policy_resource = input; self
        }
        /// <p>The permission level for this access policy. Note that a project <code>ADMINISTRATOR</code> is also known as a project owner.</p>
        pub fn access_policy_permission(mut self, input: crate::model::Permission) -> Self {
            self.access_policy_permission = Some(input);
            self
        }
        /// <p>The permission level for this access policy. Note that a project <code>ADMINISTRATOR</code> is also known as a project owner.</p>
        pub fn set_access_policy_permission(mut self, input: std::option::Option<crate::model::Permission>) -> Self {
            self.access_policy_permission = input; self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A list of key-value pairs that contain metadata for the access policy. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise resources</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>A list of key-value pairs that contain metadata for the access policy. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise resources</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`CreateAccessPolicyInput`](crate::input::CreateAccessPolicyInput).
        pub fn build(self) -> Result<crate::input::CreateAccessPolicyInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateAccessPolicyInput {
                    access_policy_identity: self.access_policy_identity
                    ,
                    access_policy_resource: self.access_policy_resource
                    ,
                    access_policy_permission: self.access_policy_permission
                    ,
                    client_token: self.client_token
                    ,
                    tags: self.tags
                    ,
                }
            )
        }
    }
    
    
}
impl CreateAccessPolicyInput {
    /// Consumes the builder and constructs an Operation<[`CreateAccessPolicy`](crate::operation::CreateAccessPolicy)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateAccessPolicy, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.client_token.is_none() {
                                self.client_token = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::input::CreateAccessPolicyInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/access-policies").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateAccessPolicyInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_access_policy(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("monitor.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateAccessPolicy::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateAccessPolicy", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateAccessPolicyInput`](crate::input::CreateAccessPolicyInput).
    pub fn builder() -> crate::input::create_access_policy_input::Builder {
        crate::input::create_access_policy_input::Builder::default()
    }
}

/// See [`CreateAssetInput`](crate::input::CreateAssetInput).
pub mod create_asset_input {
    
    /// A builder for [`CreateAssetInput`](crate::input::CreateAssetInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) asset_name: std::option::Option<std::string::String>,
        pub(crate) asset_model_id: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
        pub(crate) asset_description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A friendly name for the asset.</p>
        pub fn asset_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_name = Some(input.into());
            self
        }
        /// <p>A friendly name for the asset.</p>
        pub fn set_asset_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_name = input; self
        }
        /// <p>The ID of the asset model from which to create the asset.</p>
        pub fn asset_model_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_model_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset model from which to create the asset.</p>
        pub fn set_asset_model_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_model_id = input; self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A list of key-value pairs that contain metadata for the asset. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise resources</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>A list of key-value pairs that contain metadata for the asset. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise resources</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// <p>A description for the asset.</p>
        pub fn asset_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_description = Some(input.into());
            self
        }
        /// <p>A description for the asset.</p>
        pub fn set_asset_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_description = input; self
        }
        /// Consumes the builder and constructs a [`CreateAssetInput`](crate::input::CreateAssetInput).
        pub fn build(self) -> Result<crate::input::CreateAssetInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateAssetInput {
                    asset_name: self.asset_name
                    ,
                    asset_model_id: self.asset_model_id
                    ,
                    client_token: self.client_token
                    ,
                    tags: self.tags
                    ,
                    asset_description: self.asset_description
                    ,
                }
            )
        }
    }
    
    
}
impl CreateAssetInput {
    /// Consumes the builder and constructs an Operation<[`CreateAsset`](crate::operation::CreateAsset)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateAsset, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.client_token.is_none() {
                                self.client_token = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::input::CreateAssetInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/assets").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateAssetInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_asset(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateAsset::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateAsset", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateAssetInput`](crate::input::CreateAssetInput).
    pub fn builder() -> crate::input::create_asset_input::Builder {
        crate::input::create_asset_input::Builder::default()
    }
}

/// See [`CreateAssetModelInput`](crate::input::CreateAssetModelInput).
pub mod create_asset_model_input {
    
    /// A builder for [`CreateAssetModelInput`](crate::input::CreateAssetModelInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) asset_model_name: std::option::Option<std::string::String>,
        pub(crate) asset_model_description: std::option::Option<std::string::String>,
        pub(crate) asset_model_properties: std::option::Option<std::vec::Vec<crate::model::AssetModelPropertyDefinition>>,
        pub(crate) asset_model_hierarchies: std::option::Option<std::vec::Vec<crate::model::AssetModelHierarchyDefinition>>,
        pub(crate) asset_model_composite_models: std::option::Option<std::vec::Vec<crate::model::AssetModelCompositeModelDefinition>>,
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    }
    impl Builder {
        /// <p>A unique, friendly name for the asset model.</p>
        pub fn asset_model_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_model_name = Some(input.into());
            self
        }
        /// <p>A unique, friendly name for the asset model.</p>
        pub fn set_asset_model_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_model_name = input; self
        }
        /// <p>A description for the asset model.</p>
        pub fn asset_model_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_model_description = Some(input.into());
            self
        }
        /// <p>A description for the asset model.</p>
        pub fn set_asset_model_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_model_description = input; self
        }
        /// Appends an item to `asset_model_properties`.
        ///
        /// To override the contents of this collection use [`set_asset_model_properties`](Self::set_asset_model_properties).
        ///
        /// <p>The property definitions of the asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html">Asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p> 
        /// <p>You can specify up to 200 properties per asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn asset_model_properties(mut self, input: crate::model::AssetModelPropertyDefinition) -> Self {
            let mut v = self.asset_model_properties.unwrap_or_default();
                            v.push(input);
                            self.asset_model_properties = Some(v);
                            self
        }
        /// <p>The property definitions of the asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html">Asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p> 
        /// <p>You can specify up to 200 properties per asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_asset_model_properties(mut self, input: std::option::Option<std::vec::Vec<crate::model::AssetModelPropertyDefinition>>) -> Self {
            self.asset_model_properties = input; self
        }
        /// Appends an item to `asset_model_hierarchies`.
        ///
        /// To override the contents of this collection use [`set_asset_model_hierarchies`](Self::set_asset_model_hierarchies).
        ///
        /// <p>The hierarchy definitions of the asset model. Each hierarchy specifies an asset model whose assets can be children of any other assets created from this asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html">Asset hierarchies</a> in the <i>IoT SiteWise User Guide</i>.</p> 
        /// <p>You can specify up to 10 hierarchies per asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn asset_model_hierarchies(mut self, input: crate::model::AssetModelHierarchyDefinition) -> Self {
            let mut v = self.asset_model_hierarchies.unwrap_or_default();
                            v.push(input);
                            self.asset_model_hierarchies = Some(v);
                            self
        }
        /// <p>The hierarchy definitions of the asset model. Each hierarchy specifies an asset model whose assets can be children of any other assets created from this asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html">Asset hierarchies</a> in the <i>IoT SiteWise User Guide</i>.</p> 
        /// <p>You can specify up to 10 hierarchies per asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_asset_model_hierarchies(mut self, input: std::option::Option<std::vec::Vec<crate::model::AssetModelHierarchyDefinition>>) -> Self {
            self.asset_model_hierarchies = input; self
        }
        /// Appends an item to `asset_model_composite_models`.
        ///
        /// To override the contents of this collection use [`set_asset_model_composite_models`](Self::set_asset_model_composite_models).
        ///
        /// <p>The composite asset models that are part of this asset model. Composite asset models are asset models that contain specific properties. Each composite model has a type that defines the properties that the composite model supports. Use composite asset models to define alarms on this asset model.</p>
        pub fn asset_model_composite_models(mut self, input: crate::model::AssetModelCompositeModelDefinition) -> Self {
            let mut v = self.asset_model_composite_models.unwrap_or_default();
                            v.push(input);
                            self.asset_model_composite_models = Some(v);
                            self
        }
        /// <p>The composite asset models that are part of this asset model. Composite asset models are asset models that contain specific properties. Each composite model has a type that defines the properties that the composite model supports. Use composite asset models to define alarms on this asset model.</p>
        pub fn set_asset_model_composite_models(mut self, input: std::option::Option<std::vec::Vec<crate::model::AssetModelCompositeModelDefinition>>) -> Self {
            self.asset_model_composite_models = input; self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A list of key-value pairs that contain metadata for the asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise resources</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>A list of key-value pairs that contain metadata for the asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise resources</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`CreateAssetModelInput`](crate::input::CreateAssetModelInput).
        pub fn build(self) -> Result<crate::input::CreateAssetModelInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateAssetModelInput {
                    asset_model_name: self.asset_model_name
                    ,
                    asset_model_description: self.asset_model_description
                    ,
                    asset_model_properties: self.asset_model_properties
                    ,
                    asset_model_hierarchies: self.asset_model_hierarchies
                    ,
                    asset_model_composite_models: self.asset_model_composite_models
                    ,
                    client_token: self.client_token
                    ,
                    tags: self.tags
                    ,
                }
            )
        }
    }
    
    
}
impl CreateAssetModelInput {
    /// Consumes the builder and constructs an Operation<[`CreateAssetModel`](crate::operation::CreateAssetModel)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateAssetModel, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.client_token.is_none() {
                                self.client_token = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::input::CreateAssetModelInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/asset-models").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateAssetModelInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_asset_model(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateAssetModel::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateAssetModel", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateAssetModelInput`](crate::input::CreateAssetModelInput).
    pub fn builder() -> crate::input::create_asset_model_input::Builder {
        crate::input::create_asset_model_input::Builder::default()
    }
}

/// See [`CreateBulkImportJobInput`](crate::input::CreateBulkImportJobInput).
pub mod create_bulk_import_job_input {
    
    /// A builder for [`CreateBulkImportJobInput`](crate::input::CreateBulkImportJobInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) job_role_arn: std::option::Option<std::string::String>,
        pub(crate) files: std::option::Option<std::vec::Vec<crate::model::File>>,
        pub(crate) error_report_location: std::option::Option<crate::model::ErrorReportLocation>,
        pub(crate) job_configuration: std::option::Option<crate::model::JobConfiguration>,
    }
    impl Builder {
        /// <p>The unique name that helps identify the job request.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p>The unique name that helps identify the job request.</p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input; self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the IAM role that allows IoT SiteWise to read Amazon S3 data.</p>
        pub fn job_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_role_arn = Some(input.into());
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the IAM role that allows IoT SiteWise to read Amazon S3 data.</p>
        pub fn set_job_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_role_arn = input; self
        }
        /// Appends an item to `files`.
        ///
        /// To override the contents of this collection use [`set_files`](Self::set_files).
        ///
        /// <p>The files in the specified Amazon S3 bucket that contain your data.</p>
        pub fn files(mut self, input: crate::model::File) -> Self {
            let mut v = self.files.unwrap_or_default();
                            v.push(input);
                            self.files = Some(v);
                            self
        }
        /// <p>The files in the specified Amazon S3 bucket that contain your data.</p>
        pub fn set_files(mut self, input: std::option::Option<std::vec::Vec<crate::model::File>>) -> Self {
            self.files = input; self
        }
        /// <p>The Amazon S3 destination where errors associated with the job creation request are saved.</p>
        pub fn error_report_location(mut self, input: crate::model::ErrorReportLocation) -> Self {
            self.error_report_location = Some(input);
            self
        }
        /// <p>The Amazon S3 destination where errors associated with the job creation request are saved.</p>
        pub fn set_error_report_location(mut self, input: std::option::Option<crate::model::ErrorReportLocation>) -> Self {
            self.error_report_location = input; self
        }
        /// <p>Contains the configuration information of a job, such as the file format used to save data in Amazon S3.</p>
        pub fn job_configuration(mut self, input: crate::model::JobConfiguration) -> Self {
            self.job_configuration = Some(input);
            self
        }
        /// <p>Contains the configuration information of a job, such as the file format used to save data in Amazon S3.</p>
        pub fn set_job_configuration(mut self, input: std::option::Option<crate::model::JobConfiguration>) -> Self {
            self.job_configuration = input; self
        }
        /// Consumes the builder and constructs a [`CreateBulkImportJobInput`](crate::input::CreateBulkImportJobInput).
        pub fn build(self) -> Result<crate::input::CreateBulkImportJobInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateBulkImportJobInput {
                    job_name: self.job_name
                    ,
                    job_role_arn: self.job_role_arn
                    ,
                    files: self.files
                    ,
                    error_report_location: self.error_report_location
                    ,
                    job_configuration: self.job_configuration
                    ,
                }
            )
        }
    }
    
    
}
impl CreateBulkImportJobInput {
    /// Consumes the builder and constructs an Operation<[`CreateBulkImportJob`](crate::operation::CreateBulkImportJob)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateBulkImportJob, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateBulkImportJobInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/jobs").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateBulkImportJobInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_bulk_import_job(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("data.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateBulkImportJob::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateBulkImportJob", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateBulkImportJobInput`](crate::input::CreateBulkImportJobInput).
    pub fn builder() -> crate::input::create_bulk_import_job_input::Builder {
        crate::input::create_bulk_import_job_input::Builder::default()
    }
}

/// See [`CreateDashboardInput`](crate::input::CreateDashboardInput).
pub mod create_dashboard_input {
    
    /// A builder for [`CreateDashboardInput`](crate::input::CreateDashboardInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) project_id: std::option::Option<std::string::String>,
        pub(crate) dashboard_name: std::option::Option<std::string::String>,
        pub(crate) dashboard_description: std::option::Option<std::string::String>,
        pub(crate) dashboard_definition: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    }
    impl Builder {
        /// <p>The ID of the project in which to create the dashboard.</p>
        pub fn project_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_id = Some(input.into());
            self
        }
        /// <p>The ID of the project in which to create the dashboard.</p>
        pub fn set_project_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_id = input; self
        }
        /// <p>A friendly name for the dashboard.</p>
        pub fn dashboard_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.dashboard_name = Some(input.into());
            self
        }
        /// <p>A friendly name for the dashboard.</p>
        pub fn set_dashboard_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.dashboard_name = input; self
        }
        /// <p>A description for the dashboard.</p>
        pub fn dashboard_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.dashboard_description = Some(input.into());
            self
        }
        /// <p>A description for the dashboard.</p>
        pub fn set_dashboard_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.dashboard_description = input; self
        }
        /// <p>The dashboard definition specified in a JSON literal. For detailed information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/create-dashboards-using-aws-cli.html">Creating dashboards (CLI)</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn dashboard_definition(mut self, input: impl Into<std::string::String>) -> Self {
            self.dashboard_definition = Some(input.into());
            self
        }
        /// <p>The dashboard definition specified in a JSON literal. For detailed information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/create-dashboards-using-aws-cli.html">Creating dashboards (CLI)</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_dashboard_definition(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.dashboard_definition = input; self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A list of key-value pairs that contain metadata for the dashboard. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise resources</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>A list of key-value pairs that contain metadata for the dashboard. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise resources</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`CreateDashboardInput`](crate::input::CreateDashboardInput).
        pub fn build(self) -> Result<crate::input::CreateDashboardInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateDashboardInput {
                    project_id: self.project_id
                    ,
                    dashboard_name: self.dashboard_name
                    ,
                    dashboard_description: self.dashboard_description
                    ,
                    dashboard_definition: self.dashboard_definition
                    ,
                    client_token: self.client_token
                    ,
                    tags: self.tags
                    ,
                }
            )
        }
    }
    
    
}
impl CreateDashboardInput {
    /// Consumes the builder and constructs an Operation<[`CreateDashboard`](crate::operation::CreateDashboard)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateDashboard, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.client_token.is_none() {
                                self.client_token = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::input::CreateDashboardInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/dashboards").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateDashboardInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_dashboard(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("monitor.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateDashboard::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateDashboard", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateDashboardInput`](crate::input::CreateDashboardInput).
    pub fn builder() -> crate::input::create_dashboard_input::Builder {
        crate::input::create_dashboard_input::Builder::default()
    }
}

/// See [`CreateGatewayInput`](crate::input::CreateGatewayInput).
pub mod create_gateway_input {
    
    /// A builder for [`CreateGatewayInput`](crate::input::CreateGatewayInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) gateway_name: std::option::Option<std::string::String>,
        pub(crate) gateway_platform: std::option::Option<crate::model::GatewayPlatform>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    }
    impl Builder {
        /// <p>A unique, friendly name for the gateway.</p>
        pub fn gateway_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.gateway_name = Some(input.into());
            self
        }
        /// <p>A unique, friendly name for the gateway.</p>
        pub fn set_gateway_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.gateway_name = input; self
        }
        /// <p>The gateway's platform. You can only specify one platform in a gateway.</p>
        pub fn gateway_platform(mut self, input: crate::model::GatewayPlatform) -> Self {
            self.gateway_platform = Some(input);
            self
        }
        /// <p>The gateway's platform. You can only specify one platform in a gateway.</p>
        pub fn set_gateway_platform(mut self, input: std::option::Option<crate::model::GatewayPlatform>) -> Self {
            self.gateway_platform = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A list of key-value pairs that contain metadata for the gateway. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise resources</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>A list of key-value pairs that contain metadata for the gateway. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise resources</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`CreateGatewayInput`](crate::input::CreateGatewayInput).
        pub fn build(self) -> Result<crate::input::CreateGatewayInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateGatewayInput {
                    gateway_name: self.gateway_name
                    ,
                    gateway_platform: self.gateway_platform
                    ,
                    tags: self.tags
                    ,
                }
            )
        }
    }
    
    
}
impl CreateGatewayInput {
    /// Consumes the builder and constructs an Operation<[`CreateGateway`](crate::operation::CreateGateway)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateGateway, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateGatewayInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/20200301/gateways").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateGatewayInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_gateway(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateGateway::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateGateway", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateGatewayInput`](crate::input::CreateGatewayInput).
    pub fn builder() -> crate::input::create_gateway_input::Builder {
        crate::input::create_gateway_input::Builder::default()
    }
}

/// See [`CreatePortalInput`](crate::input::CreatePortalInput).
pub mod create_portal_input {
    
    /// A builder for [`CreatePortalInput`](crate::input::CreatePortalInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) portal_name: std::option::Option<std::string::String>,
        pub(crate) portal_description: std::option::Option<std::string::String>,
        pub(crate) portal_contact_email: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) portal_logo_image_file: std::option::Option<crate::model::ImageFile>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
        pub(crate) portal_auth_mode: std::option::Option<crate::model::AuthMode>,
        pub(crate) notification_sender_email: std::option::Option<std::string::String>,
        pub(crate) alarms: std::option::Option<crate::model::Alarms>,
    }
    impl Builder {
        /// <p>A friendly name for the portal.</p>
        pub fn portal_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.portal_name = Some(input.into());
            self
        }
        /// <p>A friendly name for the portal.</p>
        pub fn set_portal_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.portal_name = input; self
        }
        /// <p>A description for the portal.</p>
        pub fn portal_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.portal_description = Some(input.into());
            self
        }
        /// <p>A description for the portal.</p>
        pub fn set_portal_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.portal_description = input; self
        }
        /// <p>The Amazon Web Services administrator's contact email address.</p>
        pub fn portal_contact_email(mut self, input: impl Into<std::string::String>) -> Self {
            self.portal_contact_email = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services administrator's contact email address.</p>
        pub fn set_portal_contact_email(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.portal_contact_email = input; self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// <p>A logo image to display in the portal. Upload a square, high-resolution image. The image is displayed on a dark background.</p>
        pub fn portal_logo_image_file(mut self, input: crate::model::ImageFile) -> Self {
            self.portal_logo_image_file = Some(input);
            self
        }
        /// <p>A logo image to display in the portal. Upload a square, high-resolution image. The image is displayed on a dark background.</p>
        pub fn set_portal_logo_image_file(mut self, input: std::option::Option<crate::model::ImageFile>) -> Self {
            self.portal_logo_image_file = input; self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of a service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-service-role.html">Using service roles for IoT SiteWise Monitor</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of a service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-service-role.html">Using service roles for IoT SiteWise Monitor</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A list of key-value pairs that contain metadata for the portal. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise resources</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>A list of key-value pairs that contain metadata for the portal. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise resources</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// <p>The service to use to authenticate users to the portal. Choose from the following options:</p> 
        /// <ul> 
        /// <li> <p> <code>SSO</code>  The portal uses IAM Identity Center (successor to Single Sign-On) to authenticate users and manage user permissions. Before you can create a portal that uses IAM Identity Center, you must enable IAM Identity Center. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-get-started.html#mon-gs-sso">Enabling IAM Identity Center</a> in the <i>IoT SiteWise User Guide</i>. This option is only available in Amazon Web Services Regions other than the China Regions.</p> </li> 
        /// <li> <p> <code>IAM</code>  The portal uses Identity and Access Management to authenticate users and manage user permissions.</p> </li> 
        /// </ul> 
        /// <p>You can't change this value after you create a portal.</p> 
        /// <p>Default: <code>SSO</code> </p>
        pub fn portal_auth_mode(mut self, input: crate::model::AuthMode) -> Self {
            self.portal_auth_mode = Some(input);
            self
        }
        /// <p>The service to use to authenticate users to the portal. Choose from the following options:</p> 
        /// <ul> 
        /// <li> <p> <code>SSO</code>  The portal uses IAM Identity Center (successor to Single Sign-On) to authenticate users and manage user permissions. Before you can create a portal that uses IAM Identity Center, you must enable IAM Identity Center. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-get-started.html#mon-gs-sso">Enabling IAM Identity Center</a> in the <i>IoT SiteWise User Guide</i>. This option is only available in Amazon Web Services Regions other than the China Regions.</p> </li> 
        /// <li> <p> <code>IAM</code>  The portal uses Identity and Access Management to authenticate users and manage user permissions.</p> </li> 
        /// </ul> 
        /// <p>You can't change this value after you create a portal.</p> 
        /// <p>Default: <code>SSO</code> </p>
        pub fn set_portal_auth_mode(mut self, input: std::option::Option<crate::model::AuthMode>) -> Self {
            self.portal_auth_mode = input; self
        }
        /// <p>The email address that sends alarm notifications.</p> <important> 
        /// <p>If you use the <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/lambda-support.html">IoT Events managed Lambda function</a> to manage your emails, you must <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-email-addresses.html">verify the sender email address in Amazon SES</a>.</p> 
        /// </important>
        pub fn notification_sender_email(mut self, input: impl Into<std::string::String>) -> Self {
            self.notification_sender_email = Some(input.into());
            self
        }
        /// <p>The email address that sends alarm notifications.</p> <important> 
        /// <p>If you use the <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/lambda-support.html">IoT Events managed Lambda function</a> to manage your emails, you must <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-email-addresses.html">verify the sender email address in Amazon SES</a>.</p> 
        /// </important>
        pub fn set_notification_sender_email(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.notification_sender_email = input; self
        }
        /// <p>Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal. You can use the alarm to monitor an asset property and get notified when the asset property value is outside a specified range. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/appguide/monitor-alarms.html">Monitoring with alarms</a> in the <i>IoT SiteWise Application Guide</i>.</p>
        pub fn alarms(mut self, input: crate::model::Alarms) -> Self {
            self.alarms = Some(input);
            self
        }
        /// <p>Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal. You can use the alarm to monitor an asset property and get notified when the asset property value is outside a specified range. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/appguide/monitor-alarms.html">Monitoring with alarms</a> in the <i>IoT SiteWise Application Guide</i>.</p>
        pub fn set_alarms(mut self, input: std::option::Option<crate::model::Alarms>) -> Self {
            self.alarms = input; self
        }
        /// Consumes the builder and constructs a [`CreatePortalInput`](crate::input::CreatePortalInput).
        pub fn build(self) -> Result<crate::input::CreatePortalInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreatePortalInput {
                    portal_name: self.portal_name
                    ,
                    portal_description: self.portal_description
                    ,
                    portal_contact_email: self.portal_contact_email
                    ,
                    client_token: self.client_token
                    ,
                    portal_logo_image_file: self.portal_logo_image_file
                    ,
                    role_arn: self.role_arn
                    ,
                    tags: self.tags
                    ,
                    portal_auth_mode: self.portal_auth_mode
                    ,
                    notification_sender_email: self.notification_sender_email
                    ,
                    alarms: self.alarms
                    ,
                }
            )
        }
    }
    
    
}
impl CreatePortalInput {
    /// Consumes the builder and constructs an Operation<[`CreatePortal`](crate::operation::CreatePortal)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreatePortal, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.client_token.is_none() {
                                self.client_token = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::input::CreatePortalInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/portals").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreatePortalInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_portal(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("monitor.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreatePortal::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreatePortal", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreatePortalInput`](crate::input::CreatePortalInput).
    pub fn builder() -> crate::input::create_portal_input::Builder {
        crate::input::create_portal_input::Builder::default()
    }
}

/// See [`CreateProjectInput`](crate::input::CreateProjectInput).
pub mod create_project_input {
    
    /// A builder for [`CreateProjectInput`](crate::input::CreateProjectInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) portal_id: std::option::Option<std::string::String>,
        pub(crate) project_name: std::option::Option<std::string::String>,
        pub(crate) project_description: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    }
    impl Builder {
        /// <p>The ID of the portal in which to create the project.</p>
        pub fn portal_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.portal_id = Some(input.into());
            self
        }
        /// <p>The ID of the portal in which to create the project.</p>
        pub fn set_portal_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.portal_id = input; self
        }
        /// <p>A friendly name for the project.</p>
        pub fn project_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_name = Some(input.into());
            self
        }
        /// <p>A friendly name for the project.</p>
        pub fn set_project_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_name = input; self
        }
        /// <p>A description for the project.</p>
        pub fn project_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_description = Some(input.into());
            self
        }
        /// <p>A description for the project.</p>
        pub fn set_project_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_description = input; self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A list of key-value pairs that contain metadata for the project. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise resources</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>A list of key-value pairs that contain metadata for the project. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise resources</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`CreateProjectInput`](crate::input::CreateProjectInput).
        pub fn build(self) -> Result<crate::input::CreateProjectInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateProjectInput {
                    portal_id: self.portal_id
                    ,
                    project_name: self.project_name
                    ,
                    project_description: self.project_description
                    ,
                    client_token: self.client_token
                    ,
                    tags: self.tags
                    ,
                }
            )
        }
    }
    
    
}
impl CreateProjectInput {
    /// Consumes the builder and constructs an Operation<[`CreateProject`](crate::operation::CreateProject)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateProject, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.client_token.is_none() {
                                self.client_token = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::input::CreateProjectInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/projects").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateProjectInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_project(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("monitor.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateProject::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateProject", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateProjectInput`](crate::input::CreateProjectInput).
    pub fn builder() -> crate::input::create_project_input::Builder {
        crate::input::create_project_input::Builder::default()
    }
}

/// See [`DeleteAccessPolicyInput`](crate::input::DeleteAccessPolicyInput).
pub mod delete_access_policy_input {
    
    /// A builder for [`DeleteAccessPolicyInput`](crate::input::DeleteAccessPolicyInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) access_policy_id: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the access policy to be deleted.</p>
        pub fn access_policy_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.access_policy_id = Some(input.into());
            self
        }
        /// <p>The ID of the access policy to be deleted.</p>
        pub fn set_access_policy_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.access_policy_id = input; self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// Consumes the builder and constructs a [`DeleteAccessPolicyInput`](crate::input::DeleteAccessPolicyInput).
        pub fn build(self) -> Result<crate::input::DeleteAccessPolicyInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteAccessPolicyInput {
                    access_policy_id: self.access_policy_id
                    ,
                    client_token: self.client_token
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteAccessPolicyInput {
    /// Consumes the builder and constructs an Operation<[`DeleteAccessPolicy`](crate::operation::DeleteAccessPolicy)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteAccessPolicy, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.client_token.is_none() {
                                self.client_token = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteAccessPolicyInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_7 = &_input.access_policy_id;
                let input_7 = input_7.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("access_policy_id", "cannot be empty or unset"))?;
                let access_policy_id = aws_smithy_http::label::fmt_string(input_7, aws_smithy_http::label::EncodingStrategy::Default);
                if access_policy_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("access_policy_id", "cannot be empty or unset"))
                            }
                write!(output, "/access-policies/{accessPolicyId}", accessPolicyId = access_policy_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::DeleteAccessPolicyInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_8) = &_input.client_token {
                     {
                        query.push_kv("clientToken", &aws_smithy_http::query::fmt_string(&inner_8));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteAccessPolicyInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("monitor.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteAccessPolicy::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteAccessPolicy", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteAccessPolicyInput`](crate::input::DeleteAccessPolicyInput).
    pub fn builder() -> crate::input::delete_access_policy_input::Builder {
        crate::input::delete_access_policy_input::Builder::default()
    }
}

/// See [`DeleteAssetInput`](crate::input::DeleteAssetInput).
pub mod delete_asset_input {
    
    /// A builder for [`DeleteAssetInput`](crate::input::DeleteAssetInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) asset_id: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the asset to delete.</p>
        pub fn asset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset to delete.</p>
        pub fn set_asset_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_id = input; self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// Consumes the builder and constructs a [`DeleteAssetInput`](crate::input::DeleteAssetInput).
        pub fn build(self) -> Result<crate::input::DeleteAssetInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteAssetInput {
                    asset_id: self.asset_id
                    ,
                    client_token: self.client_token
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteAssetInput {
    /// Consumes the builder and constructs an Operation<[`DeleteAsset`](crate::operation::DeleteAsset)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteAsset, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.client_token.is_none() {
                                self.client_token = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteAssetInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_9 = &_input.asset_id;
                let input_9 = input_9.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("asset_id", "cannot be empty or unset"))?;
                let asset_id = aws_smithy_http::label::fmt_string(input_9, aws_smithy_http::label::EncodingStrategy::Default);
                if asset_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("asset_id", "cannot be empty or unset"))
                            }
                write!(output, "/assets/{assetId}", assetId = asset_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::DeleteAssetInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_10) = &_input.client_token {
                     {
                        query.push_kv("clientToken", &aws_smithy_http::query::fmt_string(&inner_10));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteAssetInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteAsset::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteAsset", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteAssetInput`](crate::input::DeleteAssetInput).
    pub fn builder() -> crate::input::delete_asset_input::Builder {
        crate::input::delete_asset_input::Builder::default()
    }
}

/// See [`DeleteAssetModelInput`](crate::input::DeleteAssetModelInput).
pub mod delete_asset_model_input {
    
    /// A builder for [`DeleteAssetModelInput`](crate::input::DeleteAssetModelInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) asset_model_id: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the asset model to delete.</p>
        pub fn asset_model_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_model_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset model to delete.</p>
        pub fn set_asset_model_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_model_id = input; self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// Consumes the builder and constructs a [`DeleteAssetModelInput`](crate::input::DeleteAssetModelInput).
        pub fn build(self) -> Result<crate::input::DeleteAssetModelInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteAssetModelInput {
                    asset_model_id: self.asset_model_id
                    ,
                    client_token: self.client_token
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteAssetModelInput {
    /// Consumes the builder and constructs an Operation<[`DeleteAssetModel`](crate::operation::DeleteAssetModel)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteAssetModel, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.client_token.is_none() {
                                self.client_token = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteAssetModelInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_11 = &_input.asset_model_id;
                let input_11 = input_11.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("asset_model_id", "cannot be empty or unset"))?;
                let asset_model_id = aws_smithy_http::label::fmt_string(input_11, aws_smithy_http::label::EncodingStrategy::Default);
                if asset_model_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("asset_model_id", "cannot be empty or unset"))
                            }
                write!(output, "/asset-models/{assetModelId}", assetModelId = asset_model_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::DeleteAssetModelInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_12) = &_input.client_token {
                     {
                        query.push_kv("clientToken", &aws_smithy_http::query::fmt_string(&inner_12));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteAssetModelInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteAssetModel::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteAssetModel", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteAssetModelInput`](crate::input::DeleteAssetModelInput).
    pub fn builder() -> crate::input::delete_asset_model_input::Builder {
        crate::input::delete_asset_model_input::Builder::default()
    }
}

/// See [`DeleteDashboardInput`](crate::input::DeleteDashboardInput).
pub mod delete_dashboard_input {
    
    /// A builder for [`DeleteDashboardInput`](crate::input::DeleteDashboardInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dashboard_id: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the dashboard to delete.</p>
        pub fn dashboard_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.dashboard_id = Some(input.into());
            self
        }
        /// <p>The ID of the dashboard to delete.</p>
        pub fn set_dashboard_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.dashboard_id = input; self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// Consumes the builder and constructs a [`DeleteDashboardInput`](crate::input::DeleteDashboardInput).
        pub fn build(self) -> Result<crate::input::DeleteDashboardInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteDashboardInput {
                    dashboard_id: self.dashboard_id
                    ,
                    client_token: self.client_token
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteDashboardInput {
    /// Consumes the builder and constructs an Operation<[`DeleteDashboard`](crate::operation::DeleteDashboard)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteDashboard, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.client_token.is_none() {
                                self.client_token = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteDashboardInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_13 = &_input.dashboard_id;
                let input_13 = input_13.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("dashboard_id", "cannot be empty or unset"))?;
                let dashboard_id = aws_smithy_http::label::fmt_string(input_13, aws_smithy_http::label::EncodingStrategy::Default);
                if dashboard_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("dashboard_id", "cannot be empty or unset"))
                            }
                write!(output, "/dashboards/{dashboardId}", dashboardId = dashboard_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::DeleteDashboardInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_14) = &_input.client_token {
                     {
                        query.push_kv("clientToken", &aws_smithy_http::query::fmt_string(&inner_14));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteDashboardInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("monitor.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteDashboard::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteDashboard", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteDashboardInput`](crate::input::DeleteDashboardInput).
    pub fn builder() -> crate::input::delete_dashboard_input::Builder {
        crate::input::delete_dashboard_input::Builder::default()
    }
}

/// See [`DeleteGatewayInput`](crate::input::DeleteGatewayInput).
pub mod delete_gateway_input {
    
    /// A builder for [`DeleteGatewayInput`](crate::input::DeleteGatewayInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) gateway_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the gateway to delete.</p>
        pub fn gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.gateway_id = Some(input.into());
            self
        }
        /// <p>The ID of the gateway to delete.</p>
        pub fn set_gateway_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.gateway_id = input; self
        }
        /// Consumes the builder and constructs a [`DeleteGatewayInput`](crate::input::DeleteGatewayInput).
        pub fn build(self) -> Result<crate::input::DeleteGatewayInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteGatewayInput {
                    gateway_id: self.gateway_id
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteGatewayInput {
    /// Consumes the builder and constructs an Operation<[`DeleteGateway`](crate::operation::DeleteGateway)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteGateway, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteGatewayInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_15 = &_input.gateway_id;
                let input_15 = input_15.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("gateway_id", "cannot be empty or unset"))?;
                let gateway_id = aws_smithy_http::label::fmt_string(input_15, aws_smithy_http::label::EncodingStrategy::Default);
                if gateway_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("gateway_id", "cannot be empty or unset"))
                            }
                write!(output, "/20200301/gateways/{gatewayId}", gatewayId = gateway_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteGatewayInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteGateway::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteGateway", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteGatewayInput`](crate::input::DeleteGatewayInput).
    pub fn builder() -> crate::input::delete_gateway_input::Builder {
        crate::input::delete_gateway_input::Builder::default()
    }
}

/// See [`DeletePortalInput`](crate::input::DeletePortalInput).
pub mod delete_portal_input {
    
    /// A builder for [`DeletePortalInput`](crate::input::DeletePortalInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) portal_id: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the portal to delete.</p>
        pub fn portal_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.portal_id = Some(input.into());
            self
        }
        /// <p>The ID of the portal to delete.</p>
        pub fn set_portal_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.portal_id = input; self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// Consumes the builder and constructs a [`DeletePortalInput`](crate::input::DeletePortalInput).
        pub fn build(self) -> Result<crate::input::DeletePortalInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeletePortalInput {
                    portal_id: self.portal_id
                    ,
                    client_token: self.client_token
                    ,
                }
            )
        }
    }
    
    
}
impl DeletePortalInput {
    /// Consumes the builder and constructs an Operation<[`DeletePortal`](crate::operation::DeletePortal)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeletePortal, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.client_token.is_none() {
                                self.client_token = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::input::DeletePortalInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_16 = &_input.portal_id;
                let input_16 = input_16.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("portal_id", "cannot be empty or unset"))?;
                let portal_id = aws_smithy_http::label::fmt_string(input_16, aws_smithy_http::label::EncodingStrategy::Default);
                if portal_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("portal_id", "cannot be empty or unset"))
                            }
                write!(output, "/portals/{portalId}", portalId = portal_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::DeletePortalInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_17) = &_input.client_token {
                     {
                        query.push_kv("clientToken", &aws_smithy_http::query::fmt_string(&inner_17));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeletePortalInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("monitor.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeletePortal::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeletePortal", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeletePortalInput`](crate::input::DeletePortalInput).
    pub fn builder() -> crate::input::delete_portal_input::Builder {
        crate::input::delete_portal_input::Builder::default()
    }
}

/// See [`DeleteProjectInput`](crate::input::DeleteProjectInput).
pub mod delete_project_input {
    
    /// A builder for [`DeleteProjectInput`](crate::input::DeleteProjectInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) project_id: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the project.</p>
        pub fn project_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_id = Some(input.into());
            self
        }
        /// <p>The ID of the project.</p>
        pub fn set_project_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_id = input; self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// Consumes the builder and constructs a [`DeleteProjectInput`](crate::input::DeleteProjectInput).
        pub fn build(self) -> Result<crate::input::DeleteProjectInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteProjectInput {
                    project_id: self.project_id
                    ,
                    client_token: self.client_token
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteProjectInput {
    /// Consumes the builder and constructs an Operation<[`DeleteProject`](crate::operation::DeleteProject)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteProject, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.client_token.is_none() {
                                self.client_token = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteProjectInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_18 = &_input.project_id;
                let input_18 = input_18.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("project_id", "cannot be empty or unset"))?;
                let project_id = aws_smithy_http::label::fmt_string(input_18, aws_smithy_http::label::EncodingStrategy::Default);
                if project_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("project_id", "cannot be empty or unset"))
                            }
                write!(output, "/projects/{projectId}", projectId = project_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::DeleteProjectInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_19) = &_input.client_token {
                     {
                        query.push_kv("clientToken", &aws_smithy_http::query::fmt_string(&inner_19));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteProjectInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("monitor.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteProject::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteProject", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteProjectInput`](crate::input::DeleteProjectInput).
    pub fn builder() -> crate::input::delete_project_input::Builder {
        crate::input::delete_project_input::Builder::default()
    }
}

/// See [`DeleteTimeSeriesInput`](crate::input::DeleteTimeSeriesInput).
pub mod delete_time_series_input {
    
    /// A builder for [`DeleteTimeSeriesInput`](crate::input::DeleteTimeSeriesInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) alias: std::option::Option<std::string::String>,
        pub(crate) asset_id: std::option::Option<std::string::String>,
        pub(crate) property_id: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The alias that identifies the time series.</p>
        pub fn alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.alias = Some(input.into());
            self
        }
        /// <p>The alias that identifies the time series.</p>
        pub fn set_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alias = input; self
        }
        /// <p>The ID of the asset in which the asset property was created.</p>
        pub fn asset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset in which the asset property was created.</p>
        pub fn set_asset_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_id = input; self
        }
        /// <p>The ID of the asset property.</p>
        pub fn property_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset property.</p>
        pub fn set_property_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.property_id = input; self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// Consumes the builder and constructs a [`DeleteTimeSeriesInput`](crate::input::DeleteTimeSeriesInput).
        pub fn build(self) -> Result<crate::input::DeleteTimeSeriesInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteTimeSeriesInput {
                    alias: self.alias
                    ,
                    asset_id: self.asset_id
                    ,
                    property_id: self.property_id
                    ,
                    client_token: self.client_token
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteTimeSeriesInput {
    /// Consumes the builder and constructs an Operation<[`DeleteTimeSeries`](crate::operation::DeleteTimeSeries)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteTimeSeries, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.client_token.is_none() {
                                self.client_token = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteTimeSeriesInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/timeseries/delete").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::DeleteTimeSeriesInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_20) = &_input.alias {
                     {
                        query.push_kv("alias", &aws_smithy_http::query::fmt_string(&inner_20));
                    }
                }
                if let Some(inner_21) = &_input.asset_id {
                     {
                        query.push_kv("assetId", &aws_smithy_http::query::fmt_string(&inner_21));
                    }
                }
                if let Some(inner_22) = &_input.property_id {
                     {
                        query.push_kv("propertyId", &aws_smithy_http::query::fmt_string(&inner_22));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteTimeSeriesInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_delete_time_series(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteTimeSeries::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteTimeSeries", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteTimeSeriesInput`](crate::input::DeleteTimeSeriesInput).
    pub fn builder() -> crate::input::delete_time_series_input::Builder {
        crate::input::delete_time_series_input::Builder::default()
    }
}

/// See [`DescribeAccessPolicyInput`](crate::input::DescribeAccessPolicyInput).
pub mod describe_access_policy_input {
    
    /// A builder for [`DescribeAccessPolicyInput`](crate::input::DescribeAccessPolicyInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) access_policy_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the access policy.</p>
        pub fn access_policy_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.access_policy_id = Some(input.into());
            self
        }
        /// <p>The ID of the access policy.</p>
        pub fn set_access_policy_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.access_policy_id = input; self
        }
        /// Consumes the builder and constructs a [`DescribeAccessPolicyInput`](crate::input::DescribeAccessPolicyInput).
        pub fn build(self) -> Result<crate::input::DescribeAccessPolicyInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DescribeAccessPolicyInput {
                    access_policy_id: self.access_policy_id
                    ,
                }
            )
        }
    }
    
    
}
impl DescribeAccessPolicyInput {
    /// Consumes the builder and constructs an Operation<[`DescribeAccessPolicy`](crate::operation::DescribeAccessPolicy)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DescribeAccessPolicy, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DescribeAccessPolicyInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_23 = &_input.access_policy_id;
                let input_23 = input_23.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("access_policy_id", "cannot be empty or unset"))?;
                let access_policy_id = aws_smithy_http::label::fmt_string(input_23, aws_smithy_http::label::EncodingStrategy::Default);
                if access_policy_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("access_policy_id", "cannot be empty or unset"))
                            }
                write!(output, "/access-policies/{accessPolicyId}", accessPolicyId = access_policy_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DescribeAccessPolicyInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("monitor.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DescribeAccessPolicy::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DescribeAccessPolicy", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeAccessPolicyInput`](crate::input::DescribeAccessPolicyInput).
    pub fn builder() -> crate::input::describe_access_policy_input::Builder {
        crate::input::describe_access_policy_input::Builder::default()
    }
}

/// See [`DescribeAssetInput`](crate::input::DescribeAssetInput).
pub mod describe_asset_input {
    
    /// A builder for [`DescribeAssetInput`](crate::input::DescribeAssetInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) asset_id: std::option::Option<std::string::String>,
        pub(crate) exclude_properties: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The ID of the asset.</p>
        pub fn asset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset.</p>
        pub fn set_asset_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_id = input; self
        }
        /// <p> Whether or not to exclude asset properties from the response. </p>
        pub fn exclude_properties(mut self, input: bool) -> Self {
            self.exclude_properties = Some(input);
            self
        }
        /// <p> Whether or not to exclude asset properties from the response. </p>
        pub fn set_exclude_properties(mut self, input: std::option::Option<bool>) -> Self {
            self.exclude_properties = input; self
        }
        /// Consumes the builder and constructs a [`DescribeAssetInput`](crate::input::DescribeAssetInput).
        pub fn build(self) -> Result<crate::input::DescribeAssetInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DescribeAssetInput {
                    asset_id: self.asset_id
                    ,
                    exclude_properties: self.exclude_properties
                        .unwrap_or_default()
                    ,
                }
            )
        }
    }
    
    
}
impl DescribeAssetInput {
    /// Consumes the builder and constructs an Operation<[`DescribeAsset`](crate::operation::DescribeAsset)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DescribeAsset, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DescribeAssetInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_24 = &_input.asset_id;
                let input_24 = input_24.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("asset_id", "cannot be empty or unset"))?;
                let asset_id = aws_smithy_http::label::fmt_string(input_24, aws_smithy_http::label::EncodingStrategy::Default);
                if asset_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("asset_id", "cannot be empty or unset"))
                            }
                write!(output, "/assets/{assetId}", assetId = asset_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::DescribeAssetInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if _input.exclude_properties {
                    query.push_kv("excludeProperties", aws_smithy_types::primitive::Encoder::from(_input.exclude_properties).encode());
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DescribeAssetInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DescribeAsset::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DescribeAsset", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeAssetInput`](crate::input::DescribeAssetInput).
    pub fn builder() -> crate::input::describe_asset_input::Builder {
        crate::input::describe_asset_input::Builder::default()
    }
}

/// See [`DescribeAssetModelInput`](crate::input::DescribeAssetModelInput).
pub mod describe_asset_model_input {
    
    /// A builder for [`DescribeAssetModelInput`](crate::input::DescribeAssetModelInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) asset_model_id: std::option::Option<std::string::String>,
        pub(crate) exclude_properties: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The ID of the asset model.</p>
        pub fn asset_model_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_model_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset model.</p>
        pub fn set_asset_model_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_model_id = input; self
        }
        /// <p> Whether or not to exclude asset model properties from the response. </p>
        pub fn exclude_properties(mut self, input: bool) -> Self {
            self.exclude_properties = Some(input);
            self
        }
        /// <p> Whether or not to exclude asset model properties from the response. </p>
        pub fn set_exclude_properties(mut self, input: std::option::Option<bool>) -> Self {
            self.exclude_properties = input; self
        }
        /// Consumes the builder and constructs a [`DescribeAssetModelInput`](crate::input::DescribeAssetModelInput).
        pub fn build(self) -> Result<crate::input::DescribeAssetModelInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DescribeAssetModelInput {
                    asset_model_id: self.asset_model_id
                    ,
                    exclude_properties: self.exclude_properties
                        .unwrap_or_default()
                    ,
                }
            )
        }
    }
    
    
}
impl DescribeAssetModelInput {
    /// Consumes the builder and constructs an Operation<[`DescribeAssetModel`](crate::operation::DescribeAssetModel)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DescribeAssetModel, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DescribeAssetModelInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_25 = &_input.asset_model_id;
                let input_25 = input_25.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("asset_model_id", "cannot be empty or unset"))?;
                let asset_model_id = aws_smithy_http::label::fmt_string(input_25, aws_smithy_http::label::EncodingStrategy::Default);
                if asset_model_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("asset_model_id", "cannot be empty or unset"))
                            }
                write!(output, "/asset-models/{assetModelId}", assetModelId = asset_model_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::DescribeAssetModelInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if _input.exclude_properties {
                    query.push_kv("excludeProperties", aws_smithy_types::primitive::Encoder::from(_input.exclude_properties).encode());
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DescribeAssetModelInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DescribeAssetModel::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DescribeAssetModel", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeAssetModelInput`](crate::input::DescribeAssetModelInput).
    pub fn builder() -> crate::input::describe_asset_model_input::Builder {
        crate::input::describe_asset_model_input::Builder::default()
    }
}

/// See [`DescribeAssetPropertyInput`](crate::input::DescribeAssetPropertyInput).
pub mod describe_asset_property_input {
    
    /// A builder for [`DescribeAssetPropertyInput`](crate::input::DescribeAssetPropertyInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) asset_id: std::option::Option<std::string::String>,
        pub(crate) property_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the asset.</p>
        pub fn asset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset.</p>
        pub fn set_asset_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_id = input; self
        }
        /// <p>The ID of the asset property.</p>
        pub fn property_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset property.</p>
        pub fn set_property_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.property_id = input; self
        }
        /// Consumes the builder and constructs a [`DescribeAssetPropertyInput`](crate::input::DescribeAssetPropertyInput).
        pub fn build(self) -> Result<crate::input::DescribeAssetPropertyInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DescribeAssetPropertyInput {
                    asset_id: self.asset_id
                    ,
                    property_id: self.property_id
                    ,
                }
            )
        }
    }
    
    
}
impl DescribeAssetPropertyInput {
    /// Consumes the builder and constructs an Operation<[`DescribeAssetProperty`](crate::operation::DescribeAssetProperty)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DescribeAssetProperty, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DescribeAssetPropertyInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_26 = &_input.asset_id;
                let input_26 = input_26.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("asset_id", "cannot be empty or unset"))?;
                let asset_id = aws_smithy_http::label::fmt_string(input_26, aws_smithy_http::label::EncodingStrategy::Default);
                if asset_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("asset_id", "cannot be empty or unset"))
                            }
                let input_27 = &_input.property_id;
                let input_27 = input_27.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("property_id", "cannot be empty or unset"))?;
                let property_id = aws_smithy_http::label::fmt_string(input_27, aws_smithy_http::label::EncodingStrategy::Default);
                if property_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("property_id", "cannot be empty or unset"))
                            }
                write!(output, "/assets/{assetId}/properties/{propertyId}", assetId = asset_id, propertyId = property_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DescribeAssetPropertyInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DescribeAssetProperty::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DescribeAssetProperty", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeAssetPropertyInput`](crate::input::DescribeAssetPropertyInput).
    pub fn builder() -> crate::input::describe_asset_property_input::Builder {
        crate::input::describe_asset_property_input::Builder::default()
    }
}

/// See [`DescribeBulkImportJobInput`](crate::input::DescribeBulkImportJobInput).
pub mod describe_bulk_import_job_input {
    
    /// A builder for [`DescribeBulkImportJobInput`](crate::input::DescribeBulkImportJobInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the job.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The ID of the job.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input; self
        }
        /// Consumes the builder and constructs a [`DescribeBulkImportJobInput`](crate::input::DescribeBulkImportJobInput).
        pub fn build(self) -> Result<crate::input::DescribeBulkImportJobInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DescribeBulkImportJobInput {
                    job_id: self.job_id
                    ,
                }
            )
        }
    }
    
    
}
impl DescribeBulkImportJobInput {
    /// Consumes the builder and constructs an Operation<[`DescribeBulkImportJob`](crate::operation::DescribeBulkImportJob)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DescribeBulkImportJob, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DescribeBulkImportJobInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_28 = &_input.job_id;
                let input_28 = input_28.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("job_id", "cannot be empty or unset"))?;
                let job_id = aws_smithy_http::label::fmt_string(input_28, aws_smithy_http::label::EncodingStrategy::Default);
                if job_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("job_id", "cannot be empty or unset"))
                            }
                write!(output, "/jobs/{jobId}", jobId = job_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DescribeBulkImportJobInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("data.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DescribeBulkImportJob::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DescribeBulkImportJob", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeBulkImportJobInput`](crate::input::DescribeBulkImportJobInput).
    pub fn builder() -> crate::input::describe_bulk_import_job_input::Builder {
        crate::input::describe_bulk_import_job_input::Builder::default()
    }
}

/// See [`DescribeDashboardInput`](crate::input::DescribeDashboardInput).
pub mod describe_dashboard_input {
    
    /// A builder for [`DescribeDashboardInput`](crate::input::DescribeDashboardInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dashboard_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the dashboard.</p>
        pub fn dashboard_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.dashboard_id = Some(input.into());
            self
        }
        /// <p>The ID of the dashboard.</p>
        pub fn set_dashboard_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.dashboard_id = input; self
        }
        /// Consumes the builder and constructs a [`DescribeDashboardInput`](crate::input::DescribeDashboardInput).
        pub fn build(self) -> Result<crate::input::DescribeDashboardInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DescribeDashboardInput {
                    dashboard_id: self.dashboard_id
                    ,
                }
            )
        }
    }
    
    
}
impl DescribeDashboardInput {
    /// Consumes the builder and constructs an Operation<[`DescribeDashboard`](crate::operation::DescribeDashboard)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DescribeDashboard, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DescribeDashboardInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_29 = &_input.dashboard_id;
                let input_29 = input_29.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("dashboard_id", "cannot be empty or unset"))?;
                let dashboard_id = aws_smithy_http::label::fmt_string(input_29, aws_smithy_http::label::EncodingStrategy::Default);
                if dashboard_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("dashboard_id", "cannot be empty or unset"))
                            }
                write!(output, "/dashboards/{dashboardId}", dashboardId = dashboard_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DescribeDashboardInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("monitor.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DescribeDashboard::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DescribeDashboard", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeDashboardInput`](crate::input::DescribeDashboardInput).
    pub fn builder() -> crate::input::describe_dashboard_input::Builder {
        crate::input::describe_dashboard_input::Builder::default()
    }
}

/// See [`DescribeDefaultEncryptionConfigurationInput`](crate::input::DescribeDefaultEncryptionConfigurationInput).
pub mod describe_default_encryption_configuration_input {
    
    /// A builder for [`DescribeDefaultEncryptionConfigurationInput`](crate::input::DescribeDefaultEncryptionConfigurationInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
    }
    impl Builder {
        /// Consumes the builder and constructs a [`DescribeDefaultEncryptionConfigurationInput`](crate::input::DescribeDefaultEncryptionConfigurationInput).
        pub fn build(self) -> Result<crate::input::DescribeDefaultEncryptionConfigurationInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DescribeDefaultEncryptionConfigurationInput {
                }
            )
        }
    }
    
    
}
impl DescribeDefaultEncryptionConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`DescribeDefaultEncryptionConfiguration`](crate::operation::DescribeDefaultEncryptionConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DescribeDefaultEncryptionConfiguration, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DescribeDefaultEncryptionConfigurationInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/configuration/account/encryption").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DescribeDefaultEncryptionConfigurationInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DescribeDefaultEncryptionConfiguration::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DescribeDefaultEncryptionConfiguration", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeDefaultEncryptionConfigurationInput`](crate::input::DescribeDefaultEncryptionConfigurationInput).
    pub fn builder() -> crate::input::describe_default_encryption_configuration_input::Builder {
        crate::input::describe_default_encryption_configuration_input::Builder::default()
    }
}

/// See [`DescribeGatewayInput`](crate::input::DescribeGatewayInput).
pub mod describe_gateway_input {
    
    /// A builder for [`DescribeGatewayInput`](crate::input::DescribeGatewayInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) gateway_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the gateway device.</p>
        pub fn gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.gateway_id = Some(input.into());
            self
        }
        /// <p>The ID of the gateway device.</p>
        pub fn set_gateway_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.gateway_id = input; self
        }
        /// Consumes the builder and constructs a [`DescribeGatewayInput`](crate::input::DescribeGatewayInput).
        pub fn build(self) -> Result<crate::input::DescribeGatewayInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DescribeGatewayInput {
                    gateway_id: self.gateway_id
                    ,
                }
            )
        }
    }
    
    
}
impl DescribeGatewayInput {
    /// Consumes the builder and constructs an Operation<[`DescribeGateway`](crate::operation::DescribeGateway)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DescribeGateway, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DescribeGatewayInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_30 = &_input.gateway_id;
                let input_30 = input_30.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("gateway_id", "cannot be empty or unset"))?;
                let gateway_id = aws_smithy_http::label::fmt_string(input_30, aws_smithy_http::label::EncodingStrategy::Default);
                if gateway_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("gateway_id", "cannot be empty or unset"))
                            }
                write!(output, "/20200301/gateways/{gatewayId}", gatewayId = gateway_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DescribeGatewayInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DescribeGateway::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DescribeGateway", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeGatewayInput`](crate::input::DescribeGatewayInput).
    pub fn builder() -> crate::input::describe_gateway_input::Builder {
        crate::input::describe_gateway_input::Builder::default()
    }
}

/// See [`DescribeGatewayCapabilityConfigurationInput`](crate::input::DescribeGatewayCapabilityConfigurationInput).
pub mod describe_gateway_capability_configuration_input {
    
    /// A builder for [`DescribeGatewayCapabilityConfigurationInput`](crate::input::DescribeGatewayCapabilityConfigurationInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) gateway_id: std::option::Option<std::string::String>,
        pub(crate) capability_namespace: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the gateway that defines the capability configuration.</p>
        pub fn gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.gateway_id = Some(input.into());
            self
        }
        /// <p>The ID of the gateway that defines the capability configuration.</p>
        pub fn set_gateway_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.gateway_id = input; self
        }
        /// <p>The namespace of the capability configuration. For example, if you configure OPC-UA sources from the IoT SiteWise console, your OPC-UA capability configuration has the namespace <code>iotsitewise:opcuacollector:version</code>, where <code>version</code> is a number such as <code>1</code>.</p>
        pub fn capability_namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.capability_namespace = Some(input.into());
            self
        }
        /// <p>The namespace of the capability configuration. For example, if you configure OPC-UA sources from the IoT SiteWise console, your OPC-UA capability configuration has the namespace <code>iotsitewise:opcuacollector:version</code>, where <code>version</code> is a number such as <code>1</code>.</p>
        pub fn set_capability_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.capability_namespace = input; self
        }
        /// Consumes the builder and constructs a [`DescribeGatewayCapabilityConfigurationInput`](crate::input::DescribeGatewayCapabilityConfigurationInput).
        pub fn build(self) -> Result<crate::input::DescribeGatewayCapabilityConfigurationInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DescribeGatewayCapabilityConfigurationInput {
                    gateway_id: self.gateway_id
                    ,
                    capability_namespace: self.capability_namespace
                    ,
                }
            )
        }
    }
    
    
}
impl DescribeGatewayCapabilityConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`DescribeGatewayCapabilityConfiguration`](crate::operation::DescribeGatewayCapabilityConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DescribeGatewayCapabilityConfiguration, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DescribeGatewayCapabilityConfigurationInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_31 = &_input.gateway_id;
                let input_31 = input_31.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("gateway_id", "cannot be empty or unset"))?;
                let gateway_id = aws_smithy_http::label::fmt_string(input_31, aws_smithy_http::label::EncodingStrategy::Default);
                if gateway_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("gateway_id", "cannot be empty or unset"))
                            }
                let input_32 = &_input.capability_namespace;
                let input_32 = input_32.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("capability_namespace", "cannot be empty or unset"))?;
                let capability_namespace = aws_smithy_http::label::fmt_string(input_32, aws_smithy_http::label::EncodingStrategy::Default);
                if capability_namespace.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("capability_namespace", "cannot be empty or unset"))
                            }
                write!(output, "/20200301/gateways/{gatewayId}/capability/{capabilityNamespace}", gatewayId = gateway_id, capabilityNamespace = capability_namespace).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DescribeGatewayCapabilityConfigurationInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DescribeGatewayCapabilityConfiguration::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DescribeGatewayCapabilityConfiguration", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeGatewayCapabilityConfigurationInput`](crate::input::DescribeGatewayCapabilityConfigurationInput).
    pub fn builder() -> crate::input::describe_gateway_capability_configuration_input::Builder {
        crate::input::describe_gateway_capability_configuration_input::Builder::default()
    }
}

/// See [`DescribeLoggingOptionsInput`](crate::input::DescribeLoggingOptionsInput).
pub mod describe_logging_options_input {
    
    /// A builder for [`DescribeLoggingOptionsInput`](crate::input::DescribeLoggingOptionsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
    }
    impl Builder {
        /// Consumes the builder and constructs a [`DescribeLoggingOptionsInput`](crate::input::DescribeLoggingOptionsInput).
        pub fn build(self) -> Result<crate::input::DescribeLoggingOptionsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DescribeLoggingOptionsInput {
                }
            )
        }
    }
    
    
}
impl DescribeLoggingOptionsInput {
    /// Consumes the builder and constructs an Operation<[`DescribeLoggingOptions`](crate::operation::DescribeLoggingOptions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DescribeLoggingOptions, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DescribeLoggingOptionsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/logging").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DescribeLoggingOptionsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DescribeLoggingOptions::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DescribeLoggingOptions", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeLoggingOptionsInput`](crate::input::DescribeLoggingOptionsInput).
    pub fn builder() -> crate::input::describe_logging_options_input::Builder {
        crate::input::describe_logging_options_input::Builder::default()
    }
}

/// See [`DescribePortalInput`](crate::input::DescribePortalInput).
pub mod describe_portal_input {
    
    /// A builder for [`DescribePortalInput`](crate::input::DescribePortalInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) portal_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the portal.</p>
        pub fn portal_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.portal_id = Some(input.into());
            self
        }
        /// <p>The ID of the portal.</p>
        pub fn set_portal_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.portal_id = input; self
        }
        /// Consumes the builder and constructs a [`DescribePortalInput`](crate::input::DescribePortalInput).
        pub fn build(self) -> Result<crate::input::DescribePortalInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DescribePortalInput {
                    portal_id: self.portal_id
                    ,
                }
            )
        }
    }
    
    
}
impl DescribePortalInput {
    /// Consumes the builder and constructs an Operation<[`DescribePortal`](crate::operation::DescribePortal)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DescribePortal, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DescribePortalInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_33 = &_input.portal_id;
                let input_33 = input_33.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("portal_id", "cannot be empty or unset"))?;
                let portal_id = aws_smithy_http::label::fmt_string(input_33, aws_smithy_http::label::EncodingStrategy::Default);
                if portal_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("portal_id", "cannot be empty or unset"))
                            }
                write!(output, "/portals/{portalId}", portalId = portal_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DescribePortalInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("monitor.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DescribePortal::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DescribePortal", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribePortalInput`](crate::input::DescribePortalInput).
    pub fn builder() -> crate::input::describe_portal_input::Builder {
        crate::input::describe_portal_input::Builder::default()
    }
}

/// See [`DescribeProjectInput`](crate::input::DescribeProjectInput).
pub mod describe_project_input {
    
    /// A builder for [`DescribeProjectInput`](crate::input::DescribeProjectInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) project_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the project.</p>
        pub fn project_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_id = Some(input.into());
            self
        }
        /// <p>The ID of the project.</p>
        pub fn set_project_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_id = input; self
        }
        /// Consumes the builder and constructs a [`DescribeProjectInput`](crate::input::DescribeProjectInput).
        pub fn build(self) -> Result<crate::input::DescribeProjectInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DescribeProjectInput {
                    project_id: self.project_id
                    ,
                }
            )
        }
    }
    
    
}
impl DescribeProjectInput {
    /// Consumes the builder and constructs an Operation<[`DescribeProject`](crate::operation::DescribeProject)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DescribeProject, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DescribeProjectInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_34 = &_input.project_id;
                let input_34 = input_34.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("project_id", "cannot be empty or unset"))?;
                let project_id = aws_smithy_http::label::fmt_string(input_34, aws_smithy_http::label::EncodingStrategy::Default);
                if project_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("project_id", "cannot be empty or unset"))
                            }
                write!(output, "/projects/{projectId}", projectId = project_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DescribeProjectInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("monitor.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DescribeProject::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DescribeProject", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeProjectInput`](crate::input::DescribeProjectInput).
    pub fn builder() -> crate::input::describe_project_input::Builder {
        crate::input::describe_project_input::Builder::default()
    }
}

/// See [`DescribeStorageConfigurationInput`](crate::input::DescribeStorageConfigurationInput).
pub mod describe_storage_configuration_input {
    
    /// A builder for [`DescribeStorageConfigurationInput`](crate::input::DescribeStorageConfigurationInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
    }
    impl Builder {
        /// Consumes the builder and constructs a [`DescribeStorageConfigurationInput`](crate::input::DescribeStorageConfigurationInput).
        pub fn build(self) -> Result<crate::input::DescribeStorageConfigurationInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DescribeStorageConfigurationInput {
                }
            )
        }
    }
    
    
}
impl DescribeStorageConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`DescribeStorageConfiguration`](crate::operation::DescribeStorageConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DescribeStorageConfiguration, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DescribeStorageConfigurationInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/configuration/account/storage").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DescribeStorageConfigurationInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DescribeStorageConfiguration::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DescribeStorageConfiguration", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeStorageConfigurationInput`](crate::input::DescribeStorageConfigurationInput).
    pub fn builder() -> crate::input::describe_storage_configuration_input::Builder {
        crate::input::describe_storage_configuration_input::Builder::default()
    }
}

/// See [`DescribeTimeSeriesInput`](crate::input::DescribeTimeSeriesInput).
pub mod describe_time_series_input {
    
    /// A builder for [`DescribeTimeSeriesInput`](crate::input::DescribeTimeSeriesInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) alias: std::option::Option<std::string::String>,
        pub(crate) asset_id: std::option::Option<std::string::String>,
        pub(crate) property_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The alias that identifies the time series.</p>
        pub fn alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.alias = Some(input.into());
            self
        }
        /// <p>The alias that identifies the time series.</p>
        pub fn set_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alias = input; self
        }
        /// <p>The ID of the asset in which the asset property was created.</p>
        pub fn asset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset in which the asset property was created.</p>
        pub fn set_asset_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_id = input; self
        }
        /// <p>The ID of the asset property.</p>
        pub fn property_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset property.</p>
        pub fn set_property_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.property_id = input; self
        }
        /// Consumes the builder and constructs a [`DescribeTimeSeriesInput`](crate::input::DescribeTimeSeriesInput).
        pub fn build(self) -> Result<crate::input::DescribeTimeSeriesInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DescribeTimeSeriesInput {
                    alias: self.alias
                    ,
                    asset_id: self.asset_id
                    ,
                    property_id: self.property_id
                    ,
                }
            )
        }
    }
    
    
}
impl DescribeTimeSeriesInput {
    /// Consumes the builder and constructs an Operation<[`DescribeTimeSeries`](crate::operation::DescribeTimeSeries)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DescribeTimeSeries, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DescribeTimeSeriesInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/timeseries/describe").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::DescribeTimeSeriesInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_35) = &_input.alias {
                     {
                        query.push_kv("alias", &aws_smithy_http::query::fmt_string(&inner_35));
                    }
                }
                if let Some(inner_36) = &_input.asset_id {
                     {
                        query.push_kv("assetId", &aws_smithy_http::query::fmt_string(&inner_36));
                    }
                }
                if let Some(inner_37) = &_input.property_id {
                     {
                        query.push_kv("propertyId", &aws_smithy_http::query::fmt_string(&inner_37));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DescribeTimeSeriesInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DescribeTimeSeries::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DescribeTimeSeries", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeTimeSeriesInput`](crate::input::DescribeTimeSeriesInput).
    pub fn builder() -> crate::input::describe_time_series_input::Builder {
        crate::input::describe_time_series_input::Builder::default()
    }
}

/// See [`DisassociateAssetsInput`](crate::input::DisassociateAssetsInput).
pub mod disassociate_assets_input {
    
    /// A builder for [`DisassociateAssetsInput`](crate::input::DisassociateAssetsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) asset_id: std::option::Option<std::string::String>,
        pub(crate) hierarchy_id: std::option::Option<std::string::String>,
        pub(crate) child_asset_id: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the parent asset from which to disassociate the child asset.</p>
        pub fn asset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_id = Some(input.into());
            self
        }
        /// <p>The ID of the parent asset from which to disassociate the child asset.</p>
        pub fn set_asset_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_id = input; self
        }
        /// <p>The ID of a hierarchy in the parent asset's model. Hierarchies allow different groupings of assets to be formed that all come from the same asset model. You can use the hierarchy ID to identify the correct asset to disassociate. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html">Asset hierarchies</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn hierarchy_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hierarchy_id = Some(input.into());
            self
        }
        /// <p>The ID of a hierarchy in the parent asset's model. Hierarchies allow different groupings of assets to be formed that all come from the same asset model. You can use the hierarchy ID to identify the correct asset to disassociate. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html">Asset hierarchies</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_hierarchy_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hierarchy_id = input; self
        }
        /// <p>The ID of the child asset to disassociate.</p>
        pub fn child_asset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.child_asset_id = Some(input.into());
            self
        }
        /// <p>The ID of the child asset to disassociate.</p>
        pub fn set_child_asset_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.child_asset_id = input; self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// Consumes the builder and constructs a [`DisassociateAssetsInput`](crate::input::DisassociateAssetsInput).
        pub fn build(self) -> Result<crate::input::DisassociateAssetsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DisassociateAssetsInput {
                    asset_id: self.asset_id
                    ,
                    hierarchy_id: self.hierarchy_id
                    ,
                    child_asset_id: self.child_asset_id
                    ,
                    client_token: self.client_token
                    ,
                }
            )
        }
    }
    
    
}
impl DisassociateAssetsInput {
    /// Consumes the builder and constructs an Operation<[`DisassociateAssets`](crate::operation::DisassociateAssets)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DisassociateAssets, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.client_token.is_none() {
                                self.client_token = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::input::DisassociateAssetsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_38 = &_input.asset_id;
                let input_38 = input_38.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("asset_id", "cannot be empty or unset"))?;
                let asset_id = aws_smithy_http::label::fmt_string(input_38, aws_smithy_http::label::EncodingStrategy::Default);
                if asset_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("asset_id", "cannot be empty or unset"))
                            }
                write!(output, "/assets/{assetId}/disassociate", assetId = asset_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DisassociateAssetsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_disassociate_assets(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DisassociateAssets::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DisassociateAssets", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DisassociateAssetsInput`](crate::input::DisassociateAssetsInput).
    pub fn builder() -> crate::input::disassociate_assets_input::Builder {
        crate::input::disassociate_assets_input::Builder::default()
    }
}

/// See [`DisassociateTimeSeriesFromAssetPropertyInput`](crate::input::DisassociateTimeSeriesFromAssetPropertyInput).
pub mod disassociate_time_series_from_asset_property_input {
    
    /// A builder for [`DisassociateTimeSeriesFromAssetPropertyInput`](crate::input::DisassociateTimeSeriesFromAssetPropertyInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) alias: std::option::Option<std::string::String>,
        pub(crate) asset_id: std::option::Option<std::string::String>,
        pub(crate) property_id: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The alias that identifies the time series.</p>
        pub fn alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.alias = Some(input.into());
            self
        }
        /// <p>The alias that identifies the time series.</p>
        pub fn set_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alias = input; self
        }
        /// <p>The ID of the asset in which the asset property was created.</p>
        pub fn asset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset in which the asset property was created.</p>
        pub fn set_asset_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_id = input; self
        }
        /// <p>The ID of the asset property.</p>
        pub fn property_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset property.</p>
        pub fn set_property_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.property_id = input; self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// Consumes the builder and constructs a [`DisassociateTimeSeriesFromAssetPropertyInput`](crate::input::DisassociateTimeSeriesFromAssetPropertyInput).
        pub fn build(self) -> Result<crate::input::DisassociateTimeSeriesFromAssetPropertyInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DisassociateTimeSeriesFromAssetPropertyInput {
                    alias: self.alias
                    ,
                    asset_id: self.asset_id
                    ,
                    property_id: self.property_id
                    ,
                    client_token: self.client_token
                    ,
                }
            )
        }
    }
    
    
}
impl DisassociateTimeSeriesFromAssetPropertyInput {
    /// Consumes the builder and constructs an Operation<[`DisassociateTimeSeriesFromAssetProperty`](crate::operation::DisassociateTimeSeriesFromAssetProperty)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DisassociateTimeSeriesFromAssetProperty, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.client_token.is_none() {
                                self.client_token = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::input::DisassociateTimeSeriesFromAssetPropertyInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/timeseries/disassociate").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::DisassociateTimeSeriesFromAssetPropertyInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_39 = &_input.alias;
                let inner_39 = inner_39.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("alias", "cannot be empty or unset"))?;
                if inner_39.is_empty() {
                    return Err(aws_smithy_http::operation::error::BuildError::missing_field("alias", "cannot be empty or unset"));
                }
                query.push_kv("alias", &aws_smithy_http::query::fmt_string(&inner_39));
                let inner_40 = &_input.asset_id;
                let inner_40 = inner_40.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("asset_id", "cannot be empty or unset"))?;
                if inner_40.is_empty() {
                    return Err(aws_smithy_http::operation::error::BuildError::missing_field("asset_id", "cannot be empty or unset"));
                }
                query.push_kv("assetId", &aws_smithy_http::query::fmt_string(&inner_40));
                let inner_41 = &_input.property_id;
                let inner_41 = inner_41.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("property_id", "cannot be empty or unset"))?;
                if inner_41.is_empty() {
                    return Err(aws_smithy_http::operation::error::BuildError::missing_field("property_id", "cannot be empty or unset"));
                }
                query.push_kv("propertyId", &aws_smithy_http::query::fmt_string(&inner_41));
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DisassociateTimeSeriesFromAssetPropertyInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_disassociate_time_series_from_asset_property(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DisassociateTimeSeriesFromAssetProperty::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DisassociateTimeSeriesFromAssetProperty", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DisassociateTimeSeriesFromAssetPropertyInput`](crate::input::DisassociateTimeSeriesFromAssetPropertyInput).
    pub fn builder() -> crate::input::disassociate_time_series_from_asset_property_input::Builder {
        crate::input::disassociate_time_series_from_asset_property_input::Builder::default()
    }
}

/// See [`GetAssetPropertyAggregatesInput`](crate::input::GetAssetPropertyAggregatesInput).
pub mod get_asset_property_aggregates_input {
    
    /// A builder for [`GetAssetPropertyAggregatesInput`](crate::input::GetAssetPropertyAggregatesInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) asset_id: std::option::Option<std::string::String>,
        pub(crate) property_id: std::option::Option<std::string::String>,
        pub(crate) property_alias: std::option::Option<std::string::String>,
        pub(crate) aggregate_types: std::option::Option<std::vec::Vec<crate::model::AggregateType>>,
        pub(crate) resolution: std::option::Option<std::string::String>,
        pub(crate) qualities: std::option::Option<std::vec::Vec<crate::model::Quality>>,
        pub(crate) start_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) time_ordering: std::option::Option<crate::model::TimeOrdering>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID of the asset.</p>
        pub fn asset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset.</p>
        pub fn set_asset_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_id = input; self
        }
        /// <p>The ID of the asset property.</p>
        pub fn property_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset property.</p>
        pub fn set_property_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.property_id = input; self
        }
        /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn property_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_alias = Some(input.into());
            self
        }
        /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_property_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.property_alias = input; self
        }
        /// Appends an item to `aggregate_types`.
        ///
        /// To override the contents of this collection use [`set_aggregate_types`](Self::set_aggregate_types).
        ///
        /// <p>The data aggregating function.</p>
        pub fn aggregate_types(mut self, input: crate::model::AggregateType) -> Self {
            let mut v = self.aggregate_types.unwrap_or_default();
                            v.push(input);
                            self.aggregate_types = Some(v);
                            self
        }
        /// <p>The data aggregating function.</p>
        pub fn set_aggregate_types(mut self, input: std::option::Option<std::vec::Vec<crate::model::AggregateType>>) -> Self {
            self.aggregate_types = input; self
        }
        /// <p>The time interval over which to aggregate data.</p>
        pub fn resolution(mut self, input: impl Into<std::string::String>) -> Self {
            self.resolution = Some(input.into());
            self
        }
        /// <p>The time interval over which to aggregate data.</p>
        pub fn set_resolution(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resolution = input; self
        }
        /// Appends an item to `qualities`.
        ///
        /// To override the contents of this collection use [`set_qualities`](Self::set_qualities).
        ///
        /// <p>The quality by which to filter asset data.</p>
        pub fn qualities(mut self, input: crate::model::Quality) -> Self {
            let mut v = self.qualities.unwrap_or_default();
                            v.push(input);
                            self.qualities = Some(v);
                            self
        }
        /// <p>The quality by which to filter asset data.</p>
        pub fn set_qualities(mut self, input: std::option::Option<std::vec::Vec<crate::model::Quality>>) -> Self {
            self.qualities = input; self
        }
        /// <p>The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.</p>
        pub fn start_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_date = Some(input);
            self
        }
        /// <p>The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.</p>
        pub fn set_start_date(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.start_date = input; self
        }
        /// <p>The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.</p>
        pub fn end_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_date = Some(input);
            self
        }
        /// <p>The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.</p>
        pub fn set_end_date(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.end_date = input; self
        }
        /// <p>The chronological sorting order of the requested information.</p> 
        /// <p>Default: <code>ASCENDING</code> </p>
        pub fn time_ordering(mut self, input: crate::model::TimeOrdering) -> Self {
            self.time_ordering = Some(input);
            self
        }
        /// <p>The chronological sorting order of the requested information.</p> 
        /// <p>Default: <code>ASCENDING</code> </p>
        pub fn set_time_ordering(mut self, input: std::option::Option<crate::model::TimeOrdering>) -> Self {
            self.time_ordering = input; self
        }
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>The maximum number of results to return for each paginated request.</p> 
        /// <p>Default: 100</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return for each paginated request.</p> 
        /// <p>Default: 100</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`GetAssetPropertyAggregatesInput`](crate::input::GetAssetPropertyAggregatesInput).
        pub fn build(self) -> Result<crate::input::GetAssetPropertyAggregatesInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetAssetPropertyAggregatesInput {
                    asset_id: self.asset_id
                    ,
                    property_id: self.property_id
                    ,
                    property_alias: self.property_alias
                    ,
                    aggregate_types: self.aggregate_types
                    ,
                    resolution: self.resolution
                    ,
                    qualities: self.qualities
                    ,
                    start_date: self.start_date
                    ,
                    end_date: self.end_date
                    ,
                    time_ordering: self.time_ordering
                    ,
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                    ,
                }
            )
        }
    }
    
    
}
impl GetAssetPropertyAggregatesInput {
    /// Consumes the builder and constructs an Operation<[`GetAssetPropertyAggregates`](crate::operation::GetAssetPropertyAggregates)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetAssetPropertyAggregates, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetAssetPropertyAggregatesInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/properties/aggregates").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::GetAssetPropertyAggregatesInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_42) = &_input.asset_id {
                     {
                        query.push_kv("assetId", &aws_smithy_http::query::fmt_string(&inner_42));
                    }
                }
                if let Some(inner_43) = &_input.property_id {
                     {
                        query.push_kv("propertyId", &aws_smithy_http::query::fmt_string(&inner_43));
                    }
                }
                if let Some(inner_44) = &_input.property_alias {
                     {
                        query.push_kv("propertyAlias", &aws_smithy_http::query::fmt_string(&inner_44));
                    }
                }
                let inner_45 = &_input.aggregate_types;
                let inner_45 = inner_45.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("aggregate_types", "cannot be empty or unset"))?;
                for inner_46 in inner_45 {
                    query.push_kv("aggregateTypes", &aws_smithy_http::query::fmt_string(&inner_46));
                }
                let inner_47 = &_input.resolution;
                let inner_47 = inner_47.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("resolution", "cannot be empty or unset"))?;
                if inner_47.is_empty() {
                    return Err(aws_smithy_http::operation::error::BuildError::missing_field("resolution", "cannot be empty or unset"));
                }
                query.push_kv("resolution", &aws_smithy_http::query::fmt_string(&inner_47));
                if let Some(inner_48) = &_input.qualities {
                     {
                        for inner_49 in inner_48 {
                            query.push_kv("qualities", &aws_smithy_http::query::fmt_string(&inner_49));
                        }
                    }
                }
                let inner_50 = &_input.start_date;
                let inner_50 = inner_50.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("start_date", "cannot be empty or unset"))?;
                query.push_kv("startDate", &aws_smithy_http::query::fmt_timestamp(inner_50, aws_smithy_types::date_time::Format::DateTime)?);
                let inner_51 = &_input.end_date;
                let inner_51 = inner_51.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("end_date", "cannot be empty or unset"))?;
                query.push_kv("endDate", &aws_smithy_http::query::fmt_timestamp(inner_51, aws_smithy_types::date_time::Format::DateTime)?);
                if let Some(inner_52) = &_input.time_ordering {
                     {
                        query.push_kv("timeOrdering", &aws_smithy_http::query::fmt_string(&inner_52));
                    }
                }
                if let Some(inner_53) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_53));
                    }
                }
                if let Some(inner_54) = &_input.max_results {
                    if *inner_54 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_54).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetAssetPropertyAggregatesInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("data.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetAssetPropertyAggregates::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetAssetPropertyAggregates", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetAssetPropertyAggregatesInput`](crate::input::GetAssetPropertyAggregatesInput).
    pub fn builder() -> crate::input::get_asset_property_aggregates_input::Builder {
        crate::input::get_asset_property_aggregates_input::Builder::default()
    }
}

/// See [`GetAssetPropertyValueInput`](crate::input::GetAssetPropertyValueInput).
pub mod get_asset_property_value_input {
    
    /// A builder for [`GetAssetPropertyValueInput`](crate::input::GetAssetPropertyValueInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) asset_id: std::option::Option<std::string::String>,
        pub(crate) property_id: std::option::Option<std::string::String>,
        pub(crate) property_alias: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the asset.</p>
        pub fn asset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset.</p>
        pub fn set_asset_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_id = input; self
        }
        /// <p>The ID of the asset property.</p>
        pub fn property_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset property.</p>
        pub fn set_property_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.property_id = input; self
        }
        /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn property_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_alias = Some(input.into());
            self
        }
        /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_property_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.property_alias = input; self
        }
        /// Consumes the builder and constructs a [`GetAssetPropertyValueInput`](crate::input::GetAssetPropertyValueInput).
        pub fn build(self) -> Result<crate::input::GetAssetPropertyValueInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetAssetPropertyValueInput {
                    asset_id: self.asset_id
                    ,
                    property_id: self.property_id
                    ,
                    property_alias: self.property_alias
                    ,
                }
            )
        }
    }
    
    
}
impl GetAssetPropertyValueInput {
    /// Consumes the builder and constructs an Operation<[`GetAssetPropertyValue`](crate::operation::GetAssetPropertyValue)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetAssetPropertyValue, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetAssetPropertyValueInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/properties/latest").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::GetAssetPropertyValueInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_55) = &_input.asset_id {
                     {
                        query.push_kv("assetId", &aws_smithy_http::query::fmt_string(&inner_55));
                    }
                }
                if let Some(inner_56) = &_input.property_id {
                     {
                        query.push_kv("propertyId", &aws_smithy_http::query::fmt_string(&inner_56));
                    }
                }
                if let Some(inner_57) = &_input.property_alias {
                     {
                        query.push_kv("propertyAlias", &aws_smithy_http::query::fmt_string(&inner_57));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetAssetPropertyValueInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("data.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetAssetPropertyValue::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetAssetPropertyValue", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetAssetPropertyValueInput`](crate::input::GetAssetPropertyValueInput).
    pub fn builder() -> crate::input::get_asset_property_value_input::Builder {
        crate::input::get_asset_property_value_input::Builder::default()
    }
}

/// See [`GetAssetPropertyValueHistoryInput`](crate::input::GetAssetPropertyValueHistoryInput).
pub mod get_asset_property_value_history_input {
    
    /// A builder for [`GetAssetPropertyValueHistoryInput`](crate::input::GetAssetPropertyValueHistoryInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) asset_id: std::option::Option<std::string::String>,
        pub(crate) property_id: std::option::Option<std::string::String>,
        pub(crate) property_alias: std::option::Option<std::string::String>,
        pub(crate) start_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) qualities: std::option::Option<std::vec::Vec<crate::model::Quality>>,
        pub(crate) time_ordering: std::option::Option<crate::model::TimeOrdering>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID of the asset.</p>
        pub fn asset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset.</p>
        pub fn set_asset_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_id = input; self
        }
        /// <p>The ID of the asset property.</p>
        pub fn property_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset property.</p>
        pub fn set_property_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.property_id = input; self
        }
        /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn property_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_alias = Some(input.into());
            self
        }
        /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_property_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.property_alias = input; self
        }
        /// <p>The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.</p>
        pub fn start_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_date = Some(input);
            self
        }
        /// <p>The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.</p>
        pub fn set_start_date(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.start_date = input; self
        }
        /// <p>The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.</p>
        pub fn end_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_date = Some(input);
            self
        }
        /// <p>The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.</p>
        pub fn set_end_date(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.end_date = input; self
        }
        /// Appends an item to `qualities`.
        ///
        /// To override the contents of this collection use [`set_qualities`](Self::set_qualities).
        ///
        /// <p>The quality by which to filter asset data.</p>
        pub fn qualities(mut self, input: crate::model::Quality) -> Self {
            let mut v = self.qualities.unwrap_or_default();
                            v.push(input);
                            self.qualities = Some(v);
                            self
        }
        /// <p>The quality by which to filter asset data.</p>
        pub fn set_qualities(mut self, input: std::option::Option<std::vec::Vec<crate::model::Quality>>) -> Self {
            self.qualities = input; self
        }
        /// <p>The chronological sorting order of the requested information.</p> 
        /// <p>Default: <code>ASCENDING</code> </p>
        pub fn time_ordering(mut self, input: crate::model::TimeOrdering) -> Self {
            self.time_ordering = Some(input);
            self
        }
        /// <p>The chronological sorting order of the requested information.</p> 
        /// <p>Default: <code>ASCENDING</code> </p>
        pub fn set_time_ordering(mut self, input: std::option::Option<crate::model::TimeOrdering>) -> Self {
            self.time_ordering = input; self
        }
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>The maximum number of results to return for each paginated request.</p> 
        /// <p>Default: 100</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return for each paginated request.</p> 
        /// <p>Default: 100</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`GetAssetPropertyValueHistoryInput`](crate::input::GetAssetPropertyValueHistoryInput).
        pub fn build(self) -> Result<crate::input::GetAssetPropertyValueHistoryInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetAssetPropertyValueHistoryInput {
                    asset_id: self.asset_id
                    ,
                    property_id: self.property_id
                    ,
                    property_alias: self.property_alias
                    ,
                    start_date: self.start_date
                    ,
                    end_date: self.end_date
                    ,
                    qualities: self.qualities
                    ,
                    time_ordering: self.time_ordering
                    ,
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                    ,
                }
            )
        }
    }
    
    
}
impl GetAssetPropertyValueHistoryInput {
    /// Consumes the builder and constructs an Operation<[`GetAssetPropertyValueHistory`](crate::operation::GetAssetPropertyValueHistory)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetAssetPropertyValueHistory, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetAssetPropertyValueHistoryInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/properties/history").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::GetAssetPropertyValueHistoryInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_58) = &_input.asset_id {
                     {
                        query.push_kv("assetId", &aws_smithy_http::query::fmt_string(&inner_58));
                    }
                }
                if let Some(inner_59) = &_input.property_id {
                     {
                        query.push_kv("propertyId", &aws_smithy_http::query::fmt_string(&inner_59));
                    }
                }
                if let Some(inner_60) = &_input.property_alias {
                     {
                        query.push_kv("propertyAlias", &aws_smithy_http::query::fmt_string(&inner_60));
                    }
                }
                if let Some(inner_61) = &_input.start_date {
                     {
                        query.push_kv("startDate", &aws_smithy_http::query::fmt_timestamp(inner_61, aws_smithy_types::date_time::Format::DateTime)?);
                    }
                }
                if let Some(inner_62) = &_input.end_date {
                     {
                        query.push_kv("endDate", &aws_smithy_http::query::fmt_timestamp(inner_62, aws_smithy_types::date_time::Format::DateTime)?);
                    }
                }
                if let Some(inner_63) = &_input.qualities {
                     {
                        for inner_64 in inner_63 {
                            query.push_kv("qualities", &aws_smithy_http::query::fmt_string(&inner_64));
                        }
                    }
                }
                if let Some(inner_65) = &_input.time_ordering {
                     {
                        query.push_kv("timeOrdering", &aws_smithy_http::query::fmt_string(&inner_65));
                    }
                }
                if let Some(inner_66) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_66));
                    }
                }
                if let Some(inner_67) = &_input.max_results {
                    if *inner_67 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_67).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetAssetPropertyValueHistoryInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("data.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetAssetPropertyValueHistory::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetAssetPropertyValueHistory", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetAssetPropertyValueHistoryInput`](crate::input::GetAssetPropertyValueHistoryInput).
    pub fn builder() -> crate::input::get_asset_property_value_history_input::Builder {
        crate::input::get_asset_property_value_history_input::Builder::default()
    }
}

/// See [`GetInterpolatedAssetPropertyValuesInput`](crate::input::GetInterpolatedAssetPropertyValuesInput).
pub mod get_interpolated_asset_property_values_input {
    
    /// A builder for [`GetInterpolatedAssetPropertyValuesInput`](crate::input::GetInterpolatedAssetPropertyValuesInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) asset_id: std::option::Option<std::string::String>,
        pub(crate) property_id: std::option::Option<std::string::String>,
        pub(crate) property_alias: std::option::Option<std::string::String>,
        pub(crate) start_time_in_seconds: std::option::Option<i64>,
        pub(crate) start_time_offset_in_nanos: std::option::Option<i32>,
        pub(crate) end_time_in_seconds: std::option::Option<i64>,
        pub(crate) end_time_offset_in_nanos: std::option::Option<i32>,
        pub(crate) quality: std::option::Option<crate::model::Quality>,
        pub(crate) interval_in_seconds: std::option::Option<i64>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) interval_window_in_seconds: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The ID of the asset.</p>
        pub fn asset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset.</p>
        pub fn set_asset_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_id = input; self
        }
        /// <p>The ID of the asset property.</p>
        pub fn property_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset property.</p>
        pub fn set_property_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.property_id = input; self
        }
        /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn property_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_alias = Some(input.into());
            self
        }
        /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_property_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.property_alias = input; self
        }
        /// <p>The exclusive start of the range from which to interpolate data, expressed in seconds in Unix epoch time.</p>
        pub fn start_time_in_seconds(mut self, input: i64) -> Self {
            self.start_time_in_seconds = Some(input);
            self
        }
        /// <p>The exclusive start of the range from which to interpolate data, expressed in seconds in Unix epoch time.</p>
        pub fn set_start_time_in_seconds(mut self, input: std::option::Option<i64>) -> Self {
            self.start_time_in_seconds = input; self
        }
        /// <p>The nanosecond offset converted from <code>startTimeInSeconds</code>.</p>
        pub fn start_time_offset_in_nanos(mut self, input: i32) -> Self {
            self.start_time_offset_in_nanos = Some(input);
            self
        }
        /// <p>The nanosecond offset converted from <code>startTimeInSeconds</code>.</p>
        pub fn set_start_time_offset_in_nanos(mut self, input: std::option::Option<i32>) -> Self {
            self.start_time_offset_in_nanos = input; self
        }
        /// <p>The inclusive end of the range from which to interpolate data, expressed in seconds in Unix epoch time.</p>
        pub fn end_time_in_seconds(mut self, input: i64) -> Self {
            self.end_time_in_seconds = Some(input);
            self
        }
        /// <p>The inclusive end of the range from which to interpolate data, expressed in seconds in Unix epoch time.</p>
        pub fn set_end_time_in_seconds(mut self, input: std::option::Option<i64>) -> Self {
            self.end_time_in_seconds = input; self
        }
        /// <p>The nanosecond offset converted from <code>endTimeInSeconds</code>.</p>
        pub fn end_time_offset_in_nanos(mut self, input: i32) -> Self {
            self.end_time_offset_in_nanos = Some(input);
            self
        }
        /// <p>The nanosecond offset converted from <code>endTimeInSeconds</code>.</p>
        pub fn set_end_time_offset_in_nanos(mut self, input: std::option::Option<i32>) -> Self {
            self.end_time_offset_in_nanos = input; self
        }
        /// <p>The quality of the asset property value. You can use this parameter as a filter to choose only the asset property values that have a specific quality.</p>
        pub fn quality(mut self, input: crate::model::Quality) -> Self {
            self.quality = Some(input);
            self
        }
        /// <p>The quality of the asset property value. You can use this parameter as a filter to choose only the asset property values that have a specific quality.</p>
        pub fn set_quality(mut self, input: std::option::Option<crate::model::Quality>) -> Self {
            self.quality = input; self
        }
        /// <p>The time interval in seconds over which to interpolate data. Each interval starts when the previous one ends.</p>
        pub fn interval_in_seconds(mut self, input: i64) -> Self {
            self.interval_in_seconds = Some(input);
            self
        }
        /// <p>The time interval in seconds over which to interpolate data. Each interval starts when the previous one ends.</p>
        pub fn set_interval_in_seconds(mut self, input: std::option::Option<i64>) -> Self {
            self.interval_in_seconds = input; self
        }
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>The maximum number of results to return for each paginated request. If not specified, the default value is 10.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return for each paginated request. If not specified, the default value is 10.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// <p>The interpolation type.</p> 
        /// <p>Valid values: <code>LINEAR_INTERPOLATION | LOCF_INTERPOLATION</code> </p> 
        /// <ul> 
        /// <li> <p> <code>LINEAR_INTERPOLATION</code>  Estimates missing data using <a href="https://en.wikipedia.org/wiki/Linear_interpolation">linear interpolation</a>.</p> <p>For example, you can use this operation to return the interpolated temperature values for a wind turbine every 24 hours over a duration of 7 days. If the interpolation starts July 1, 2021, at 9 AM, IoT SiteWise returns the first interpolated value on July 2, 2021, at 9 AM, the second interpolated value on July 3, 2021, at 9 AM, and so on.</p> </li> 
        /// <li> <p> <code>LOCF_INTERPOLATION</code>  Estimates missing data using last observation carried forward interpolation</p> <p>If no data point is found for an interval, IoT SiteWise returns the last observed data point for the previous interval and carries forward this interpolated value until a new data point is found.</p> <p>For example, you can get the state of an on-off valve every 24 hours over a duration of 7 days. If the interpolation starts July 1, 2021, at 9 AM, IoT SiteWise returns the last observed data point between July 1, 2021, at 9 AM and July 2, 2021, at 9 AM as the first interpolated value. If a data point isn't found after 9 AM on July 2, 2021, IoT SiteWise uses the same interpolated value for the rest of the days.</p> </li> 
        /// </ul>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The interpolation type.</p> 
        /// <p>Valid values: <code>LINEAR_INTERPOLATION | LOCF_INTERPOLATION</code> </p> 
        /// <ul> 
        /// <li> <p> <code>LINEAR_INTERPOLATION</code>  Estimates missing data using <a href="https://en.wikipedia.org/wiki/Linear_interpolation">linear interpolation</a>.</p> <p>For example, you can use this operation to return the interpolated temperature values for a wind turbine every 24 hours over a duration of 7 days. If the interpolation starts July 1, 2021, at 9 AM, IoT SiteWise returns the first interpolated value on July 2, 2021, at 9 AM, the second interpolated value on July 3, 2021, at 9 AM, and so on.</p> </li> 
        /// <li> <p> <code>LOCF_INTERPOLATION</code>  Estimates missing data using last observation carried forward interpolation</p> <p>If no data point is found for an interval, IoT SiteWise returns the last observed data point for the previous interval and carries forward this interpolated value until a new data point is found.</p> <p>For example, you can get the state of an on-off valve every 24 hours over a duration of 7 days. If the interpolation starts July 1, 2021, at 9 AM, IoT SiteWise returns the last observed data point between July 1, 2021, at 9 AM and July 2, 2021, at 9 AM as the first interpolated value. If a data point isn't found after 9 AM on July 2, 2021, IoT SiteWise uses the same interpolated value for the rest of the days.</p> </li> 
        /// </ul>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input; self
        }
        /// <p>The query interval for the window, in seconds. IoT SiteWise computes each interpolated value by using data points from the timestamp of each interval, minus the window to the timestamp of each interval plus the window. If not specified, the window ranges between the start time minus the interval and the end time plus the interval.</p> <note> 
        /// <ul> 
        /// <li> <p>If you specify a value for the <code>intervalWindowInSeconds</code> parameter, the value for the <code>type</code> parameter must be <code>LINEAR_INTERPOLATION</code>.</p> </li> 
        /// <li> <p>If a data point isn't found during the specified query window, IoT SiteWise won't return an interpolated value for the interval. This indicates that there's a gap in the ingested data points.</p> </li> 
        /// </ul> 
        /// </note> 
        /// <p>For example, you can get the interpolated temperature values for a wind turbine every 24 hours over a duration of 7 days. If the interpolation starts on July 1, 2021, at 9 AM with a window of 2 hours, IoT SiteWise uses the data points from 7 AM (9 AM minus 2 hours) to 11 AM (9 AM plus 2 hours) on July 2, 2021 to compute the first interpolated value. Next, IoT SiteWise uses the data points from 7 AM (9 AM minus 2 hours) to 11 AM (9 AM plus 2 hours) on July 3, 2021 to compute the second interpolated value, and so on. </p>
        pub fn interval_window_in_seconds(mut self, input: i64) -> Self {
            self.interval_window_in_seconds = Some(input);
            self
        }
        /// <p>The query interval for the window, in seconds. IoT SiteWise computes each interpolated value by using data points from the timestamp of each interval, minus the window to the timestamp of each interval plus the window. If not specified, the window ranges between the start time minus the interval and the end time plus the interval.</p> <note> 
        /// <ul> 
        /// <li> <p>If you specify a value for the <code>intervalWindowInSeconds</code> parameter, the value for the <code>type</code> parameter must be <code>LINEAR_INTERPOLATION</code>.</p> </li> 
        /// <li> <p>If a data point isn't found during the specified query window, IoT SiteWise won't return an interpolated value for the interval. This indicates that there's a gap in the ingested data points.</p> </li> 
        /// </ul> 
        /// </note> 
        /// <p>For example, you can get the interpolated temperature values for a wind turbine every 24 hours over a duration of 7 days. If the interpolation starts on July 1, 2021, at 9 AM with a window of 2 hours, IoT SiteWise uses the data points from 7 AM (9 AM minus 2 hours) to 11 AM (9 AM plus 2 hours) on July 2, 2021 to compute the first interpolated value. Next, IoT SiteWise uses the data points from 7 AM (9 AM minus 2 hours) to 11 AM (9 AM plus 2 hours) on July 3, 2021 to compute the second interpolated value, and so on. </p>
        pub fn set_interval_window_in_seconds(mut self, input: std::option::Option<i64>) -> Self {
            self.interval_window_in_seconds = input; self
        }
        /// Consumes the builder and constructs a [`GetInterpolatedAssetPropertyValuesInput`](crate::input::GetInterpolatedAssetPropertyValuesInput).
        pub fn build(self) -> Result<crate::input::GetInterpolatedAssetPropertyValuesInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetInterpolatedAssetPropertyValuesInput {
                    asset_id: self.asset_id
                    ,
                    property_id: self.property_id
                    ,
                    property_alias: self.property_alias
                    ,
                    start_time_in_seconds: self.start_time_in_seconds
                    ,
                    start_time_offset_in_nanos: self.start_time_offset_in_nanos
                    ,
                    end_time_in_seconds: self.end_time_in_seconds
                    ,
                    end_time_offset_in_nanos: self.end_time_offset_in_nanos
                    ,
                    quality: self.quality
                    ,
                    interval_in_seconds: self.interval_in_seconds
                    ,
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                    ,
                    r#type: self.r#type
                    ,
                    interval_window_in_seconds: self.interval_window_in_seconds
                    ,
                }
            )
        }
    }
    
    
}
impl GetInterpolatedAssetPropertyValuesInput {
    /// Consumes the builder and constructs an Operation<[`GetInterpolatedAssetPropertyValues`](crate::operation::GetInterpolatedAssetPropertyValues)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetInterpolatedAssetPropertyValues, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetInterpolatedAssetPropertyValuesInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/properties/interpolated").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::GetInterpolatedAssetPropertyValuesInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_68) = &_input.asset_id {
                     {
                        query.push_kv("assetId", &aws_smithy_http::query::fmt_string(&inner_68));
                    }
                }
                if let Some(inner_69) = &_input.property_id {
                     {
                        query.push_kv("propertyId", &aws_smithy_http::query::fmt_string(&inner_69));
                    }
                }
                if let Some(inner_70) = &_input.property_alias {
                     {
                        query.push_kv("propertyAlias", &aws_smithy_http::query::fmt_string(&inner_70));
                    }
                }
                let inner_71 = &_input.start_time_in_seconds;
                let inner_71 = inner_71.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("start_time_in_seconds", "cannot be empty or unset"))?;
                query.push_kv("startTimeInSeconds", aws_smithy_types::primitive::Encoder::from(*inner_71).encode());
                if let Some(inner_72) = &_input.start_time_offset_in_nanos {
                    if *inner_72 != 0 {
                        query.push_kv("startTimeOffsetInNanos", aws_smithy_types::primitive::Encoder::from(*inner_72).encode());
                    }
                }
                let inner_73 = &_input.end_time_in_seconds;
                let inner_73 = inner_73.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("end_time_in_seconds", "cannot be empty or unset"))?;
                query.push_kv("endTimeInSeconds", aws_smithy_types::primitive::Encoder::from(*inner_73).encode());
                if let Some(inner_74) = &_input.end_time_offset_in_nanos {
                    if *inner_74 != 0 {
                        query.push_kv("endTimeOffsetInNanos", aws_smithy_types::primitive::Encoder::from(*inner_74).encode());
                    }
                }
                let inner_75 = &_input.quality;
                let inner_75 = inner_75.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("quality", "cannot be empty or unset"))?;
                query.push_kv("quality", &aws_smithy_http::query::fmt_string(&inner_75));
                let inner_76 = &_input.interval_in_seconds;
                let inner_76 = inner_76.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("interval_in_seconds", "cannot be empty or unset"))?;
                query.push_kv("intervalInSeconds", aws_smithy_types::primitive::Encoder::from(*inner_76).encode());
                if let Some(inner_77) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_77));
                    }
                }
                if let Some(inner_78) = &_input.max_results {
                    if *inner_78 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_78).encode());
                    }
                }
                let inner_79 = &_input.r#type;
                let inner_79 = inner_79.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("r#type", "cannot be empty or unset"))?;
                if inner_79.is_empty() {
                    return Err(aws_smithy_http::operation::error::BuildError::missing_field("r#type", "cannot be empty or unset"));
                }
                query.push_kv("type", &aws_smithy_http::query::fmt_string(&inner_79));
                if let Some(inner_80) = &_input.interval_window_in_seconds {
                    if *inner_80 != 0 {
                        query.push_kv("intervalWindowInSeconds", aws_smithy_types::primitive::Encoder::from(*inner_80).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetInterpolatedAssetPropertyValuesInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("data.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetInterpolatedAssetPropertyValues::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetInterpolatedAssetPropertyValues", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetInterpolatedAssetPropertyValuesInput`](crate::input::GetInterpolatedAssetPropertyValuesInput).
    pub fn builder() -> crate::input::get_interpolated_asset_property_values_input::Builder {
        crate::input::get_interpolated_asset_property_values_input::Builder::default()
    }
}

/// See [`ListAccessPoliciesInput`](crate::input::ListAccessPoliciesInput).
pub mod list_access_policies_input {
    
    /// A builder for [`ListAccessPoliciesInput`](crate::input::ListAccessPoliciesInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) identity_type: std::option::Option<crate::model::IdentityType>,
        pub(crate) identity_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<crate::model::ResourceType>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) iam_arn: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The type of identity (IAM Identity Center user, IAM Identity Center group, or IAM user). This parameter is required if you specify <code>identityId</code>.</p>
        pub fn identity_type(mut self, input: crate::model::IdentityType) -> Self {
            self.identity_type = Some(input);
            self
        }
        /// <p>The type of identity (IAM Identity Center user, IAM Identity Center group, or IAM user). This parameter is required if you specify <code>identityId</code>.</p>
        pub fn set_identity_type(mut self, input: std::option::Option<crate::model::IdentityType>) -> Self {
            self.identity_type = input; self
        }
        /// <p>The ID of the identity. This parameter is required if you specify <code>USER</code> or <code>GROUP</code> for <code>identityType</code>.</p>
        pub fn identity_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.identity_id = Some(input.into());
            self
        }
        /// <p>The ID of the identity. This parameter is required if you specify <code>USER</code> or <code>GROUP</code> for <code>identityType</code>.</p>
        pub fn set_identity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.identity_id = input; self
        }
        /// <p>The type of resource (portal or project). This parameter is required if you specify <code>resourceId</code>.</p>
        pub fn resource_type(mut self, input: crate::model::ResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        /// <p>The type of resource (portal or project). This parameter is required if you specify <code>resourceId</code>.</p>
        pub fn set_resource_type(mut self, input: std::option::Option<crate::model::ResourceType>) -> Self {
            self.resource_type = input; self
        }
        /// <p>The ID of the resource. This parameter is required if you specify <code>resourceType</code>.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        /// <p>The ID of the resource. This parameter is required if you specify <code>resourceType</code>.</p>
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input; self
        }
        /// <p>The ARN of the IAM user. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM ARNs</a> in the <i>IAM User Guide</i>. This parameter is required if you specify <code>IAM</code> for <code>identityType</code>.</p>
        pub fn iam_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.iam_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the IAM user. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM ARNs</a> in the <i>IAM User Guide</i>. This parameter is required if you specify <code>IAM</code> for <code>identityType</code>.</p>
        pub fn set_iam_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.iam_arn = input; self
        }
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>The maximum number of results to return for each paginated request.</p> 
        /// <p>Default: 50</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return for each paginated request.</p> 
        /// <p>Default: 50</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`ListAccessPoliciesInput`](crate::input::ListAccessPoliciesInput).
        pub fn build(self) -> Result<crate::input::ListAccessPoliciesInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListAccessPoliciesInput {
                    identity_type: self.identity_type
                    ,
                    identity_id: self.identity_id
                    ,
                    resource_type: self.resource_type
                    ,
                    resource_id: self.resource_id
                    ,
                    iam_arn: self.iam_arn
                    ,
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                    ,
                }
            )
        }
    }
    
    
}
impl ListAccessPoliciesInput {
    /// Consumes the builder and constructs an Operation<[`ListAccessPolicies`](crate::operation::ListAccessPolicies)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListAccessPolicies, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListAccessPoliciesInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/access-policies").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListAccessPoliciesInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_81) = &_input.identity_type {
                     {
                        query.push_kv("identityType", &aws_smithy_http::query::fmt_string(&inner_81));
                    }
                }
                if let Some(inner_82) = &_input.identity_id {
                     {
                        query.push_kv("identityId", &aws_smithy_http::query::fmt_string(&inner_82));
                    }
                }
                if let Some(inner_83) = &_input.resource_type {
                     {
                        query.push_kv("resourceType", &aws_smithy_http::query::fmt_string(&inner_83));
                    }
                }
                if let Some(inner_84) = &_input.resource_id {
                     {
                        query.push_kv("resourceId", &aws_smithy_http::query::fmt_string(&inner_84));
                    }
                }
                if let Some(inner_85) = &_input.iam_arn {
                     {
                        query.push_kv("iamArn", &aws_smithy_http::query::fmt_string(&inner_85));
                    }
                }
                if let Some(inner_86) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_86));
                    }
                }
                if let Some(inner_87) = &_input.max_results {
                    if *inner_87 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_87).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListAccessPoliciesInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("monitor.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListAccessPolicies::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListAccessPolicies", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListAccessPoliciesInput`](crate::input::ListAccessPoliciesInput).
    pub fn builder() -> crate::input::list_access_policies_input::Builder {
        crate::input::list_access_policies_input::Builder::default()
    }
}

/// See [`ListAssetModelPropertiesInput`](crate::input::ListAssetModelPropertiesInput).
pub mod list_asset_model_properties_input {
    
    /// A builder for [`ListAssetModelPropertiesInput`](crate::input::ListAssetModelPropertiesInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) asset_model_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) filter: std::option::Option<crate::model::ListAssetModelPropertiesFilter>,
    }
    impl Builder {
        /// <p>The ID of the asset model.</p>
        pub fn asset_model_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_model_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset model.</p>
        pub fn set_asset_model_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_model_id = input; self
        }
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>The maximum number of results to return for each paginated request. If not specified, the default value is 50.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return for each paginated request. If not specified, the default value is 50.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// <p> Filters the requested list of asset model properties. You can choose one of the following options:</p> 
        /// <ul> 
        /// <li> <p> <code>ALL</code>  The list includes all asset model properties for a given asset model ID. </p> </li> 
        /// <li> <p> <code>BASE</code>  The list includes only base asset model properties for a given asset model ID. </p> </li> 
        /// </ul> 
        /// <p>Default: <code>BASE</code> </p>
        pub fn filter(mut self, input: crate::model::ListAssetModelPropertiesFilter) -> Self {
            self.filter = Some(input);
            self
        }
        /// <p> Filters the requested list of asset model properties. You can choose one of the following options:</p> 
        /// <ul> 
        /// <li> <p> <code>ALL</code>  The list includes all asset model properties for a given asset model ID. </p> </li> 
        /// <li> <p> <code>BASE</code>  The list includes only base asset model properties for a given asset model ID. </p> </li> 
        /// </ul> 
        /// <p>Default: <code>BASE</code> </p>
        pub fn set_filter(mut self, input: std::option::Option<crate::model::ListAssetModelPropertiesFilter>) -> Self {
            self.filter = input; self
        }
        /// Consumes the builder and constructs a [`ListAssetModelPropertiesInput`](crate::input::ListAssetModelPropertiesInput).
        pub fn build(self) -> Result<crate::input::ListAssetModelPropertiesInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListAssetModelPropertiesInput {
                    asset_model_id: self.asset_model_id
                    ,
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                    ,
                    filter: self.filter
                    ,
                }
            )
        }
    }
    
    
}
impl ListAssetModelPropertiesInput {
    /// Consumes the builder and constructs an Operation<[`ListAssetModelProperties`](crate::operation::ListAssetModelProperties)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListAssetModelProperties, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListAssetModelPropertiesInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_88 = &_input.asset_model_id;
                let input_88 = input_88.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("asset_model_id", "cannot be empty or unset"))?;
                let asset_model_id = aws_smithy_http::label::fmt_string(input_88, aws_smithy_http::label::EncodingStrategy::Default);
                if asset_model_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("asset_model_id", "cannot be empty or unset"))
                            }
                write!(output, "/asset-models/{assetModelId}/properties", assetModelId = asset_model_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListAssetModelPropertiesInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_89) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_89));
                    }
                }
                if let Some(inner_90) = &_input.max_results {
                    if *inner_90 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_90).encode());
                    }
                }
                if let Some(inner_91) = &_input.filter {
                     {
                        query.push_kv("filter", &aws_smithy_http::query::fmt_string(&inner_91));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListAssetModelPropertiesInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListAssetModelProperties::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListAssetModelProperties", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListAssetModelPropertiesInput`](crate::input::ListAssetModelPropertiesInput).
    pub fn builder() -> crate::input::list_asset_model_properties_input::Builder {
        crate::input::list_asset_model_properties_input::Builder::default()
    }
}

/// See [`ListAssetModelsInput`](crate::input::ListAssetModelsInput).
pub mod list_asset_models_input {
    
    /// A builder for [`ListAssetModelsInput`](crate::input::ListAssetModelsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>The maximum number of results to return for each paginated request.</p> 
        /// <p>Default: 50</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return for each paginated request.</p> 
        /// <p>Default: 50</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`ListAssetModelsInput`](crate::input::ListAssetModelsInput).
        pub fn build(self) -> Result<crate::input::ListAssetModelsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListAssetModelsInput {
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                    ,
                }
            )
        }
    }
    
    
}
impl ListAssetModelsInput {
    /// Consumes the builder and constructs an Operation<[`ListAssetModels`](crate::operation::ListAssetModels)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListAssetModels, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListAssetModelsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/asset-models").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListAssetModelsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_92) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_92));
                    }
                }
                if let Some(inner_93) = &_input.max_results {
                    if *inner_93 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_93).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListAssetModelsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListAssetModels::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListAssetModels", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListAssetModelsInput`](crate::input::ListAssetModelsInput).
    pub fn builder() -> crate::input::list_asset_models_input::Builder {
        crate::input::list_asset_models_input::Builder::default()
    }
}

/// See [`ListAssetPropertiesInput`](crate::input::ListAssetPropertiesInput).
pub mod list_asset_properties_input {
    
    /// A builder for [`ListAssetPropertiesInput`](crate::input::ListAssetPropertiesInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) asset_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) filter: std::option::Option<crate::model::ListAssetPropertiesFilter>,
    }
    impl Builder {
        /// <p>The ID of the asset.</p>
        pub fn asset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset.</p>
        pub fn set_asset_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_id = input; self
        }
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>The maximum number of results to return for each paginated request. If not specified, the default value is 50.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return for each paginated request. If not specified, the default value is 50.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// <p> Filters the requested list of asset properties. You can choose one of the following options:</p> 
        /// <ul> 
        /// <li> <p> <code>ALL</code>  The list includes all asset properties for a given asset model ID. </p> </li> 
        /// <li> <p> <code>BASE</code>  The list includes only base asset properties for a given asset model ID. </p> </li> 
        /// </ul> 
        /// <p>Default: <code>BASE</code> </p>
        pub fn filter(mut self, input: crate::model::ListAssetPropertiesFilter) -> Self {
            self.filter = Some(input);
            self
        }
        /// <p> Filters the requested list of asset properties. You can choose one of the following options:</p> 
        /// <ul> 
        /// <li> <p> <code>ALL</code>  The list includes all asset properties for a given asset model ID. </p> </li> 
        /// <li> <p> <code>BASE</code>  The list includes only base asset properties for a given asset model ID. </p> </li> 
        /// </ul> 
        /// <p>Default: <code>BASE</code> </p>
        pub fn set_filter(mut self, input: std::option::Option<crate::model::ListAssetPropertiesFilter>) -> Self {
            self.filter = input; self
        }
        /// Consumes the builder and constructs a [`ListAssetPropertiesInput`](crate::input::ListAssetPropertiesInput).
        pub fn build(self) -> Result<crate::input::ListAssetPropertiesInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListAssetPropertiesInput {
                    asset_id: self.asset_id
                    ,
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                    ,
                    filter: self.filter
                    ,
                }
            )
        }
    }
    
    
}
impl ListAssetPropertiesInput {
    /// Consumes the builder and constructs an Operation<[`ListAssetProperties`](crate::operation::ListAssetProperties)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListAssetProperties, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListAssetPropertiesInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_94 = &_input.asset_id;
                let input_94 = input_94.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("asset_id", "cannot be empty or unset"))?;
                let asset_id = aws_smithy_http::label::fmt_string(input_94, aws_smithy_http::label::EncodingStrategy::Default);
                if asset_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("asset_id", "cannot be empty or unset"))
                            }
                write!(output, "/assets/{assetId}/properties", assetId = asset_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListAssetPropertiesInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_95) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_95));
                    }
                }
                if let Some(inner_96) = &_input.max_results {
                    if *inner_96 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_96).encode());
                    }
                }
                if let Some(inner_97) = &_input.filter {
                     {
                        query.push_kv("filter", &aws_smithy_http::query::fmt_string(&inner_97));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListAssetPropertiesInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListAssetProperties::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListAssetProperties", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListAssetPropertiesInput`](crate::input::ListAssetPropertiesInput).
    pub fn builder() -> crate::input::list_asset_properties_input::Builder {
        crate::input::list_asset_properties_input::Builder::default()
    }
}

/// See [`ListAssetRelationshipsInput`](crate::input::ListAssetRelationshipsInput).
pub mod list_asset_relationships_input {
    
    /// A builder for [`ListAssetRelationshipsInput`](crate::input::ListAssetRelationshipsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) asset_id: std::option::Option<std::string::String>,
        pub(crate) traversal_type: std::option::Option<crate::model::TraversalType>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID of the asset.</p>
        pub fn asset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset.</p>
        pub fn set_asset_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_id = input; self
        }
        /// <p>The type of traversal to use to identify asset relationships. Choose the following option:</p> 
        /// <ul> 
        /// <li> <p> <code>PATH_TO_ROOT</code>  Identify the asset's parent assets up to the root asset. The asset that you specify in <code>assetId</code> is the first result in the list of <code>assetRelationshipSummaries</code>, and the root asset is the last result.</p> </li> 
        /// </ul>
        pub fn traversal_type(mut self, input: crate::model::TraversalType) -> Self {
            self.traversal_type = Some(input);
            self
        }
        /// <p>The type of traversal to use to identify asset relationships. Choose the following option:</p> 
        /// <ul> 
        /// <li> <p> <code>PATH_TO_ROOT</code>  Identify the asset's parent assets up to the root asset. The asset that you specify in <code>assetId</code> is the first result in the list of <code>assetRelationshipSummaries</code>, and the root asset is the last result.</p> </li> 
        /// </ul>
        pub fn set_traversal_type(mut self, input: std::option::Option<crate::model::TraversalType>) -> Self {
            self.traversal_type = input; self
        }
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>The maximum number of results to return for each paginated request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return for each paginated request.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`ListAssetRelationshipsInput`](crate::input::ListAssetRelationshipsInput).
        pub fn build(self) -> Result<crate::input::ListAssetRelationshipsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListAssetRelationshipsInput {
                    asset_id: self.asset_id
                    ,
                    traversal_type: self.traversal_type
                    ,
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                    ,
                }
            )
        }
    }
    
    
}
impl ListAssetRelationshipsInput {
    /// Consumes the builder and constructs an Operation<[`ListAssetRelationships`](crate::operation::ListAssetRelationships)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListAssetRelationships, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListAssetRelationshipsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_98 = &_input.asset_id;
                let input_98 = input_98.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("asset_id", "cannot be empty or unset"))?;
                let asset_id = aws_smithy_http::label::fmt_string(input_98, aws_smithy_http::label::EncodingStrategy::Default);
                if asset_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("asset_id", "cannot be empty or unset"))
                            }
                write!(output, "/assets/{assetId}/assetRelationships", assetId = asset_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListAssetRelationshipsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_99 = &_input.traversal_type;
                let inner_99 = inner_99.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("traversal_type", "cannot be empty or unset"))?;
                query.push_kv("traversalType", &aws_smithy_http::query::fmt_string(&inner_99));
                if let Some(inner_100) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_100));
                    }
                }
                if let Some(inner_101) = &_input.max_results {
                    if *inner_101 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_101).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListAssetRelationshipsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListAssetRelationships::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListAssetRelationships", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListAssetRelationshipsInput`](crate::input::ListAssetRelationshipsInput).
    pub fn builder() -> crate::input::list_asset_relationships_input::Builder {
        crate::input::list_asset_relationships_input::Builder::default()
    }
}

/// See [`ListAssetsInput`](crate::input::ListAssetsInput).
pub mod list_assets_input {
    
    /// A builder for [`ListAssetsInput`](crate::input::ListAssetsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) asset_model_id: std::option::Option<std::string::String>,
        pub(crate) filter: std::option::Option<crate::model::ListAssetsFilter>,
    }
    impl Builder {
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>The maximum number of results to return for each paginated request.</p> 
        /// <p>Default: 50</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return for each paginated request.</p> 
        /// <p>Default: 50</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// <p>The ID of the asset model by which to filter the list of assets. This parameter is required if you choose <code>ALL</code> for <code>filter</code>.</p>
        pub fn asset_model_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_model_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset model by which to filter the list of assets. This parameter is required if you choose <code>ALL</code> for <code>filter</code>.</p>
        pub fn set_asset_model_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_model_id = input; self
        }
        /// <p>The filter for the requested list of assets. Choose one of the following options:</p> 
        /// <ul> 
        /// <li> <p> <code>ALL</code>  The list includes all assets for a given asset model ID. The <code>assetModelId</code> parameter is required if you filter by <code>ALL</code>.</p> </li> 
        /// <li> <p> <code>TOP_LEVEL</code>  The list includes only top-level assets in the asset hierarchy tree.</p> </li> 
        /// </ul> 
        /// <p>Default: <code>ALL</code> </p>
        pub fn filter(mut self, input: crate::model::ListAssetsFilter) -> Self {
            self.filter = Some(input);
            self
        }
        /// <p>The filter for the requested list of assets. Choose one of the following options:</p> 
        /// <ul> 
        /// <li> <p> <code>ALL</code>  The list includes all assets for a given asset model ID. The <code>assetModelId</code> parameter is required if you filter by <code>ALL</code>.</p> </li> 
        /// <li> <p> <code>TOP_LEVEL</code>  The list includes only top-level assets in the asset hierarchy tree.</p> </li> 
        /// </ul> 
        /// <p>Default: <code>ALL</code> </p>
        pub fn set_filter(mut self, input: std::option::Option<crate::model::ListAssetsFilter>) -> Self {
            self.filter = input; self
        }
        /// Consumes the builder and constructs a [`ListAssetsInput`](crate::input::ListAssetsInput).
        pub fn build(self) -> Result<crate::input::ListAssetsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListAssetsInput {
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                    ,
                    asset_model_id: self.asset_model_id
                    ,
                    filter: self.filter
                    ,
                }
            )
        }
    }
    
    
}
impl ListAssetsInput {
    /// Consumes the builder and constructs an Operation<[`ListAssets`](crate::operation::ListAssets)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListAssets, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListAssetsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/assets").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListAssetsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_102) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_102));
                    }
                }
                if let Some(inner_103) = &_input.max_results {
                    if *inner_103 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_103).encode());
                    }
                }
                if let Some(inner_104) = &_input.asset_model_id {
                     {
                        query.push_kv("assetModelId", &aws_smithy_http::query::fmt_string(&inner_104));
                    }
                }
                if let Some(inner_105) = &_input.filter {
                     {
                        query.push_kv("filter", &aws_smithy_http::query::fmt_string(&inner_105));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListAssetsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListAssets::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListAssets", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListAssetsInput`](crate::input::ListAssetsInput).
    pub fn builder() -> crate::input::list_assets_input::Builder {
        crate::input::list_assets_input::Builder::default()
    }
}

/// See [`ListAssociatedAssetsInput`](crate::input::ListAssociatedAssetsInput).
pub mod list_associated_assets_input {
    
    /// A builder for [`ListAssociatedAssetsInput`](crate::input::ListAssociatedAssetsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) asset_id: std::option::Option<std::string::String>,
        pub(crate) hierarchy_id: std::option::Option<std::string::String>,
        pub(crate) traversal_direction: std::option::Option<crate::model::TraversalDirection>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID of the asset to query.</p>
        pub fn asset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset to query.</p>
        pub fn set_asset_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_id = input; self
        }
        /// <p>The ID of the hierarchy by which child assets are associated to the asset. To find a hierarchy ID, use the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_DescribeAsset.html">DescribeAsset</a> or <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_DescribeAssetModel.html">DescribeAssetModel</a> operations. This parameter is required if you choose <code>CHILD</code> for <code>traversalDirection</code>.</p> 
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html">Asset hierarchies</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn hierarchy_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hierarchy_id = Some(input.into());
            self
        }
        /// <p>The ID of the hierarchy by which child assets are associated to the asset. To find a hierarchy ID, use the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_DescribeAsset.html">DescribeAsset</a> or <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_DescribeAssetModel.html">DescribeAssetModel</a> operations. This parameter is required if you choose <code>CHILD</code> for <code>traversalDirection</code>.</p> 
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html">Asset hierarchies</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_hierarchy_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hierarchy_id = input; self
        }
        /// <p>The direction to list associated assets. Choose one of the following options:</p> 
        /// <ul> 
        /// <li> <p> <code>CHILD</code>  The list includes all child assets associated to the asset. The <code>hierarchyId</code> parameter is required if you choose <code>CHILD</code>.</p> </li> 
        /// <li> <p> <code>PARENT</code>  The list includes the asset's parent asset.</p> </li> 
        /// </ul> 
        /// <p>Default: <code>CHILD</code> </p>
        pub fn traversal_direction(mut self, input: crate::model::TraversalDirection) -> Self {
            self.traversal_direction = Some(input);
            self
        }
        /// <p>The direction to list associated assets. Choose one of the following options:</p> 
        /// <ul> 
        /// <li> <p> <code>CHILD</code>  The list includes all child assets associated to the asset. The <code>hierarchyId</code> parameter is required if you choose <code>CHILD</code>.</p> </li> 
        /// <li> <p> <code>PARENT</code>  The list includes the asset's parent asset.</p> </li> 
        /// </ul> 
        /// <p>Default: <code>CHILD</code> </p>
        pub fn set_traversal_direction(mut self, input: std::option::Option<crate::model::TraversalDirection>) -> Self {
            self.traversal_direction = input; self
        }
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>The maximum number of results to return for each paginated request.</p> 
        /// <p>Default: 50</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return for each paginated request.</p> 
        /// <p>Default: 50</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`ListAssociatedAssetsInput`](crate::input::ListAssociatedAssetsInput).
        pub fn build(self) -> Result<crate::input::ListAssociatedAssetsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListAssociatedAssetsInput {
                    asset_id: self.asset_id
                    ,
                    hierarchy_id: self.hierarchy_id
                    ,
                    traversal_direction: self.traversal_direction
                    ,
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                    ,
                }
            )
        }
    }
    
    
}
impl ListAssociatedAssetsInput {
    /// Consumes the builder and constructs an Operation<[`ListAssociatedAssets`](crate::operation::ListAssociatedAssets)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListAssociatedAssets, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListAssociatedAssetsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_106 = &_input.asset_id;
                let input_106 = input_106.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("asset_id", "cannot be empty or unset"))?;
                let asset_id = aws_smithy_http::label::fmt_string(input_106, aws_smithy_http::label::EncodingStrategy::Default);
                if asset_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("asset_id", "cannot be empty or unset"))
                            }
                write!(output, "/assets/{assetId}/hierarchies", assetId = asset_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListAssociatedAssetsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_107) = &_input.hierarchy_id {
                     {
                        query.push_kv("hierarchyId", &aws_smithy_http::query::fmt_string(&inner_107));
                    }
                }
                if let Some(inner_108) = &_input.traversal_direction {
                     {
                        query.push_kv("traversalDirection", &aws_smithy_http::query::fmt_string(&inner_108));
                    }
                }
                if let Some(inner_109) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_109));
                    }
                }
                if let Some(inner_110) = &_input.max_results {
                    if *inner_110 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_110).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListAssociatedAssetsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListAssociatedAssets::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListAssociatedAssets", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListAssociatedAssetsInput`](crate::input::ListAssociatedAssetsInput).
    pub fn builder() -> crate::input::list_associated_assets_input::Builder {
        crate::input::list_associated_assets_input::Builder::default()
    }
}

/// See [`ListBulkImportJobsInput`](crate::input::ListBulkImportJobsInput).
pub mod list_bulk_import_jobs_input {
    
    /// A builder for [`ListBulkImportJobsInput`](crate::input::ListBulkImportJobsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) filter: std::option::Option<crate::model::ListBulkImportJobsFilter>,
    }
    impl Builder {
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>The maximum number of results to return for each paginated request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return for each paginated request.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// <p>You can use a filter to select the bulk import jobs that you want to retrieve.</p>
        pub fn filter(mut self, input: crate::model::ListBulkImportJobsFilter) -> Self {
            self.filter = Some(input);
            self
        }
        /// <p>You can use a filter to select the bulk import jobs that you want to retrieve.</p>
        pub fn set_filter(mut self, input: std::option::Option<crate::model::ListBulkImportJobsFilter>) -> Self {
            self.filter = input; self
        }
        /// Consumes the builder and constructs a [`ListBulkImportJobsInput`](crate::input::ListBulkImportJobsInput).
        pub fn build(self) -> Result<crate::input::ListBulkImportJobsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListBulkImportJobsInput {
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                    ,
                    filter: self.filter
                    ,
                }
            )
        }
    }
    
    
}
impl ListBulkImportJobsInput {
    /// Consumes the builder and constructs an Operation<[`ListBulkImportJobs`](crate::operation::ListBulkImportJobs)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListBulkImportJobs, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListBulkImportJobsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/jobs").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListBulkImportJobsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_111) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_111));
                    }
                }
                if let Some(inner_112) = &_input.max_results {
                    if *inner_112 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_112).encode());
                    }
                }
                if let Some(inner_113) = &_input.filter {
                     {
                        query.push_kv("filter", &aws_smithy_http::query::fmt_string(&inner_113));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListBulkImportJobsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("data.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListBulkImportJobs::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListBulkImportJobs", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListBulkImportJobsInput`](crate::input::ListBulkImportJobsInput).
    pub fn builder() -> crate::input::list_bulk_import_jobs_input::Builder {
        crate::input::list_bulk_import_jobs_input::Builder::default()
    }
}

/// See [`ListDashboardsInput`](crate::input::ListDashboardsInput).
pub mod list_dashboards_input {
    
    /// A builder for [`ListDashboardsInput`](crate::input::ListDashboardsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) project_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID of the project.</p>
        pub fn project_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_id = Some(input.into());
            self
        }
        /// <p>The ID of the project.</p>
        pub fn set_project_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_id = input; self
        }
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>The maximum number of results to return for each paginated request.</p> 
        /// <p>Default: 50</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return for each paginated request.</p> 
        /// <p>Default: 50</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`ListDashboardsInput`](crate::input::ListDashboardsInput).
        pub fn build(self) -> Result<crate::input::ListDashboardsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListDashboardsInput {
                    project_id: self.project_id
                    ,
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                    ,
                }
            )
        }
    }
    
    
}
impl ListDashboardsInput {
    /// Consumes the builder and constructs an Operation<[`ListDashboards`](crate::operation::ListDashboards)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListDashboards, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListDashboardsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/dashboards").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListDashboardsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_114 = &_input.project_id;
                let inner_114 = inner_114.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("project_id", "cannot be empty or unset"))?;
                if inner_114.is_empty() {
                    return Err(aws_smithy_http::operation::error::BuildError::missing_field("project_id", "cannot be empty or unset"));
                }
                query.push_kv("projectId", &aws_smithy_http::query::fmt_string(&inner_114));
                if let Some(inner_115) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_115));
                    }
                }
                if let Some(inner_116) = &_input.max_results {
                    if *inner_116 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_116).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListDashboardsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("monitor.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListDashboards::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListDashboards", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListDashboardsInput`](crate::input::ListDashboardsInput).
    pub fn builder() -> crate::input::list_dashboards_input::Builder {
        crate::input::list_dashboards_input::Builder::default()
    }
}

/// See [`ListGatewaysInput`](crate::input::ListGatewaysInput).
pub mod list_gateways_input {
    
    /// A builder for [`ListGatewaysInput`](crate::input::ListGatewaysInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>The maximum number of results to return for each paginated request.</p> 
        /// <p>Default: 50</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return for each paginated request.</p> 
        /// <p>Default: 50</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`ListGatewaysInput`](crate::input::ListGatewaysInput).
        pub fn build(self) -> Result<crate::input::ListGatewaysInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListGatewaysInput {
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                    ,
                }
            )
        }
    }
    
    
}
impl ListGatewaysInput {
    /// Consumes the builder and constructs an Operation<[`ListGateways`](crate::operation::ListGateways)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListGateways, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListGatewaysInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/20200301/gateways").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListGatewaysInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_117) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_117));
                    }
                }
                if let Some(inner_118) = &_input.max_results {
                    if *inner_118 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_118).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListGatewaysInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListGateways::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListGateways", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListGatewaysInput`](crate::input::ListGatewaysInput).
    pub fn builder() -> crate::input::list_gateways_input::Builder {
        crate::input::list_gateways_input::Builder::default()
    }
}

/// See [`ListPortalsInput`](crate::input::ListPortalsInput).
pub mod list_portals_input {
    
    /// A builder for [`ListPortalsInput`](crate::input::ListPortalsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>The maximum number of results to return for each paginated request.</p> 
        /// <p>Default: 50</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return for each paginated request.</p> 
        /// <p>Default: 50</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`ListPortalsInput`](crate::input::ListPortalsInput).
        pub fn build(self) -> Result<crate::input::ListPortalsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListPortalsInput {
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                    ,
                }
            )
        }
    }
    
    
}
impl ListPortalsInput {
    /// Consumes the builder and constructs an Operation<[`ListPortals`](crate::operation::ListPortals)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListPortals, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListPortalsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/portals").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListPortalsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_119) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_119));
                    }
                }
                if let Some(inner_120) = &_input.max_results {
                    if *inner_120 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_120).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListPortalsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("monitor.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListPortals::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListPortals", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListPortalsInput`](crate::input::ListPortalsInput).
    pub fn builder() -> crate::input::list_portals_input::Builder {
        crate::input::list_portals_input::Builder::default()
    }
}

/// See [`ListProjectAssetsInput`](crate::input::ListProjectAssetsInput).
pub mod list_project_assets_input {
    
    /// A builder for [`ListProjectAssetsInput`](crate::input::ListProjectAssetsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) project_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID of the project.</p>
        pub fn project_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_id = Some(input.into());
            self
        }
        /// <p>The ID of the project.</p>
        pub fn set_project_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_id = input; self
        }
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>The maximum number of results to return for each paginated request.</p> 
        /// <p>Default: 50</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return for each paginated request.</p> 
        /// <p>Default: 50</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`ListProjectAssetsInput`](crate::input::ListProjectAssetsInput).
        pub fn build(self) -> Result<crate::input::ListProjectAssetsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListProjectAssetsInput {
                    project_id: self.project_id
                    ,
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                    ,
                }
            )
        }
    }
    
    
}
impl ListProjectAssetsInput {
    /// Consumes the builder and constructs an Operation<[`ListProjectAssets`](crate::operation::ListProjectAssets)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListProjectAssets, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListProjectAssetsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_121 = &_input.project_id;
                let input_121 = input_121.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("project_id", "cannot be empty or unset"))?;
                let project_id = aws_smithy_http::label::fmt_string(input_121, aws_smithy_http::label::EncodingStrategy::Default);
                if project_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("project_id", "cannot be empty or unset"))
                            }
                write!(output, "/projects/{projectId}/assets", projectId = project_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListProjectAssetsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_122) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_122));
                    }
                }
                if let Some(inner_123) = &_input.max_results {
                    if *inner_123 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_123).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListProjectAssetsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("monitor.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListProjectAssets::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListProjectAssets", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListProjectAssetsInput`](crate::input::ListProjectAssetsInput).
    pub fn builder() -> crate::input::list_project_assets_input::Builder {
        crate::input::list_project_assets_input::Builder::default()
    }
}

/// See [`ListProjectsInput`](crate::input::ListProjectsInput).
pub mod list_projects_input {
    
    /// A builder for [`ListProjectsInput`](crate::input::ListProjectsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) portal_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID of the portal.</p>
        pub fn portal_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.portal_id = Some(input.into());
            self
        }
        /// <p>The ID of the portal.</p>
        pub fn set_portal_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.portal_id = input; self
        }
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>The maximum number of results to return for each paginated request.</p> 
        /// <p>Default: 50</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return for each paginated request.</p> 
        /// <p>Default: 50</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`ListProjectsInput`](crate::input::ListProjectsInput).
        pub fn build(self) -> Result<crate::input::ListProjectsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListProjectsInput {
                    portal_id: self.portal_id
                    ,
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                    ,
                }
            )
        }
    }
    
    
}
impl ListProjectsInput {
    /// Consumes the builder and constructs an Operation<[`ListProjects`](crate::operation::ListProjects)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListProjects, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListProjectsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/projects").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListProjectsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_124 = &_input.portal_id;
                let inner_124 = inner_124.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("portal_id", "cannot be empty or unset"))?;
                if inner_124.is_empty() {
                    return Err(aws_smithy_http::operation::error::BuildError::missing_field("portal_id", "cannot be empty or unset"));
                }
                query.push_kv("portalId", &aws_smithy_http::query::fmt_string(&inner_124));
                if let Some(inner_125) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_125));
                    }
                }
                if let Some(inner_126) = &_input.max_results {
                    if *inner_126 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_126).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListProjectsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("monitor.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListProjects::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListProjects", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListProjectsInput`](crate::input::ListProjectsInput).
    pub fn builder() -> crate::input::list_projects_input::Builder {
        crate::input::list_projects_input::Builder::default()
    }
}

/// See [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
pub mod list_tags_for_resource_input {
    
    /// A builder for [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input; self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
        pub fn build(self) -> Result<crate::input::ListTagsForResourceInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListTagsForResourceInput {
                    resource_arn: self.resource_arn
                    ,
                }
            )
        }
    }
    
    
}
impl ListTagsForResourceInput {
    /// Consumes the builder and constructs an Operation<[`ListTagsForResource`](crate::operation::ListTagsForResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListTagsForResource, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListTagsForResourceInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/tags").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListTagsForResourceInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_127 = &_input.resource_arn;
                let inner_127 = inner_127.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("resource_arn", "cannot be empty or unset"))?;
                if inner_127.is_empty() {
                    return Err(aws_smithy_http::operation::error::BuildError::missing_field("resource_arn", "cannot be empty or unset"));
                }
                query.push_kv("resourceArn", &aws_smithy_http::query::fmt_string(&inner_127));
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListTagsForResourceInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListTagsForResource::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListTagsForResource", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
}

/// See [`ListTimeSeriesInput`](crate::input::ListTimeSeriesInput).
pub mod list_time_series_input {
    
    /// A builder for [`ListTimeSeriesInput`](crate::input::ListTimeSeriesInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) asset_id: std::option::Option<std::string::String>,
        pub(crate) alias_prefix: std::option::Option<std::string::String>,
        pub(crate) time_series_type: std::option::Option<crate::model::ListTimeSeriesType>,
    }
    impl Builder {
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to be used for the next set of paginated results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>The maximum number of results to return for each paginated request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return for each paginated request.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// <p>The ID of the asset in which the asset property was created.</p>
        pub fn asset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset in which the asset property was created.</p>
        pub fn set_asset_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_id = input; self
        }
        /// <p>The alias prefix of the time series.</p>
        pub fn alias_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.alias_prefix = Some(input.into());
            self
        }
        /// <p>The alias prefix of the time series.</p>
        pub fn set_alias_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alias_prefix = input; self
        }
        /// <p>The type of the time series. The time series type can be one of the following values:</p> 
        /// <ul> 
        /// <li> <p> <code>ASSOCIATED</code>  The time series is associated with an asset property.</p> </li> 
        /// <li> <p> <code>DISASSOCIATED</code>  The time series isn't associated with any asset property.</p> </li> 
        /// </ul>
        pub fn time_series_type(mut self, input: crate::model::ListTimeSeriesType) -> Self {
            self.time_series_type = Some(input);
            self
        }
        /// <p>The type of the time series. The time series type can be one of the following values:</p> 
        /// <ul> 
        /// <li> <p> <code>ASSOCIATED</code>  The time series is associated with an asset property.</p> </li> 
        /// <li> <p> <code>DISASSOCIATED</code>  The time series isn't associated with any asset property.</p> </li> 
        /// </ul>
        pub fn set_time_series_type(mut self, input: std::option::Option<crate::model::ListTimeSeriesType>) -> Self {
            self.time_series_type = input; self
        }
        /// Consumes the builder and constructs a [`ListTimeSeriesInput`](crate::input::ListTimeSeriesInput).
        pub fn build(self) -> Result<crate::input::ListTimeSeriesInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListTimeSeriesInput {
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                    ,
                    asset_id: self.asset_id
                    ,
                    alias_prefix: self.alias_prefix
                    ,
                    time_series_type: self.time_series_type
                    ,
                }
            )
        }
    }
    
    
}
impl ListTimeSeriesInput {
    /// Consumes the builder and constructs an Operation<[`ListTimeSeries`](crate::operation::ListTimeSeries)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListTimeSeries, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListTimeSeriesInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/timeseries").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListTimeSeriesInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_128) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_128));
                    }
                }
                if let Some(inner_129) = &_input.max_results {
                    if *inner_129 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_129).encode());
                    }
                }
                if let Some(inner_130) = &_input.asset_id {
                     {
                        query.push_kv("assetId", &aws_smithy_http::query::fmt_string(&inner_130));
                    }
                }
                if let Some(inner_131) = &_input.alias_prefix {
                     {
                        query.push_kv("aliasPrefix", &aws_smithy_http::query::fmt_string(&inner_131));
                    }
                }
                if let Some(inner_132) = &_input.time_series_type {
                     {
                        query.push_kv("timeSeriesType", &aws_smithy_http::query::fmt_string(&inner_132));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListTimeSeriesInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListTimeSeries::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListTimeSeries", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListTimeSeriesInput`](crate::input::ListTimeSeriesInput).
    pub fn builder() -> crate::input::list_time_series_input::Builder {
        crate::input::list_time_series_input::Builder::default()
    }
}

/// See [`PutDefaultEncryptionConfigurationInput`](crate::input::PutDefaultEncryptionConfigurationInput).
pub mod put_default_encryption_configuration_input {
    
    /// A builder for [`PutDefaultEncryptionConfigurationInput`](crate::input::PutDefaultEncryptionConfigurationInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) encryption_type: std::option::Option<crate::model::EncryptionType>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of encryption used for the encryption configuration.</p>
        pub fn encryption_type(mut self, input: crate::model::EncryptionType) -> Self {
            self.encryption_type = Some(input);
            self
        }
        /// <p>The type of encryption used for the encryption configuration.</p>
        pub fn set_encryption_type(mut self, input: std::option::Option<crate::model::EncryptionType>) -> Self {
            self.encryption_type = input; self
        }
        /// <p>The Key ID of the customer managed key used for KMS encryption. This is required if you use <code>KMS_BASED_ENCRYPTION</code>.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The Key ID of the customer managed key used for KMS encryption. This is required if you use <code>KMS_BASED_ENCRYPTION</code>.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input; self
        }
        /// Consumes the builder and constructs a [`PutDefaultEncryptionConfigurationInput`](crate::input::PutDefaultEncryptionConfigurationInput).
        pub fn build(self) -> Result<crate::input::PutDefaultEncryptionConfigurationInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::PutDefaultEncryptionConfigurationInput {
                    encryption_type: self.encryption_type
                    ,
                    kms_key_id: self.kms_key_id
                    ,
                }
            )
        }
    }
    
    
}
impl PutDefaultEncryptionConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`PutDefaultEncryptionConfiguration`](crate::operation::PutDefaultEncryptionConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::PutDefaultEncryptionConfiguration, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::PutDefaultEncryptionConfigurationInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/configuration/account/encryption").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::PutDefaultEncryptionConfigurationInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_put_default_encryption_configuration(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::PutDefaultEncryptionConfiguration::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("PutDefaultEncryptionConfiguration", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`PutDefaultEncryptionConfigurationInput`](crate::input::PutDefaultEncryptionConfigurationInput).
    pub fn builder() -> crate::input::put_default_encryption_configuration_input::Builder {
        crate::input::put_default_encryption_configuration_input::Builder::default()
    }
}

/// See [`PutLoggingOptionsInput`](crate::input::PutLoggingOptionsInput).
pub mod put_logging_options_input {
    
    /// A builder for [`PutLoggingOptionsInput`](crate::input::PutLoggingOptionsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) logging_options: std::option::Option<crate::model::LoggingOptions>,
    }
    impl Builder {
        /// <p>The logging options to set.</p>
        pub fn logging_options(mut self, input: crate::model::LoggingOptions) -> Self {
            self.logging_options = Some(input);
            self
        }
        /// <p>The logging options to set.</p>
        pub fn set_logging_options(mut self, input: std::option::Option<crate::model::LoggingOptions>) -> Self {
            self.logging_options = input; self
        }
        /// Consumes the builder and constructs a [`PutLoggingOptionsInput`](crate::input::PutLoggingOptionsInput).
        pub fn build(self) -> Result<crate::input::PutLoggingOptionsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::PutLoggingOptionsInput {
                    logging_options: self.logging_options
                    ,
                }
            )
        }
    }
    
    
}
impl PutLoggingOptionsInput {
    /// Consumes the builder and constructs an Operation<[`PutLoggingOptions`](crate::operation::PutLoggingOptions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::PutLoggingOptions, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::PutLoggingOptionsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/logging").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::PutLoggingOptionsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_put_logging_options(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::PutLoggingOptions::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("PutLoggingOptions", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`PutLoggingOptionsInput`](crate::input::PutLoggingOptionsInput).
    pub fn builder() -> crate::input::put_logging_options_input::Builder {
        crate::input::put_logging_options_input::Builder::default()
    }
}

/// See [`PutStorageConfigurationInput`](crate::input::PutStorageConfigurationInput).
pub mod put_storage_configuration_input {
    
    /// A builder for [`PutStorageConfigurationInput`](crate::input::PutStorageConfigurationInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) storage_type: std::option::Option<crate::model::StorageType>,
        pub(crate) multi_layer_storage: std::option::Option<crate::model::MultiLayerStorage>,
        pub(crate) disassociated_data_storage: std::option::Option<crate::model::DisassociatedDataStorageState>,
        pub(crate) retention_period: std::option::Option<crate::model::RetentionPeriod>,
    }
    impl Builder {
        /// <p>The storage tier that you specified for your data. The <code>storageType</code> parameter can be one of the following values:</p> 
        /// <ul> 
        /// <li> <p> <code>SITEWISE_DEFAULT_STORAGE</code>  IoT SiteWise saves your data into the hot tier. The hot tier is a service-managed database.</p> </li> 
        /// <li> <p> <code>MULTI_LAYER_STORAGE</code>  IoT SiteWise saves your data in both the cold tier and the hot tier. The cold tier is a customer-managed Amazon S3 bucket.</p> </li> 
        /// </ul>
        pub fn storage_type(mut self, input: crate::model::StorageType) -> Self {
            self.storage_type = Some(input);
            self
        }
        /// <p>The storage tier that you specified for your data. The <code>storageType</code> parameter can be one of the following values:</p> 
        /// <ul> 
        /// <li> <p> <code>SITEWISE_DEFAULT_STORAGE</code>  IoT SiteWise saves your data into the hot tier. The hot tier is a service-managed database.</p> </li> 
        /// <li> <p> <code>MULTI_LAYER_STORAGE</code>  IoT SiteWise saves your data in both the cold tier and the hot tier. The cold tier is a customer-managed Amazon S3 bucket.</p> </li> 
        /// </ul>
        pub fn set_storage_type(mut self, input: std::option::Option<crate::model::StorageType>) -> Self {
            self.storage_type = input; self
        }
        /// <p>Identifies a storage destination. If you specified <code>MULTI_LAYER_STORAGE</code> for the storage type, you must specify a <code>MultiLayerStorage</code> object.</p>
        pub fn multi_layer_storage(mut self, input: crate::model::MultiLayerStorage) -> Self {
            self.multi_layer_storage = Some(input);
            self
        }
        /// <p>Identifies a storage destination. If you specified <code>MULTI_LAYER_STORAGE</code> for the storage type, you must specify a <code>MultiLayerStorage</code> object.</p>
        pub fn set_multi_layer_storage(mut self, input: std::option::Option<crate::model::MultiLayerStorage>) -> Self {
            self.multi_layer_storage = input; self
        }
        /// <p>Contains the storage configuration for time series (data streams) that aren't associated with asset properties. The <code>disassociatedDataStorage</code> can be one of the following values:</p> 
        /// <ul> 
        /// <li> <p> <code>ENABLED</code>  IoT SiteWise accepts time series that aren't associated with asset properties.</p> <important> 
        /// <p>After the <code>disassociatedDataStorage</code> is enabled, you can't disable it.</p> 
        /// </important> </li> 
        /// <li> <p> <code>DISABLED</code>  IoT SiteWise doesn't accept time series (data streams) that aren't associated with asset properties.</p> </li> 
        /// </ul> 
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/data-streams.html">Data streams</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn disassociated_data_storage(mut self, input: crate::model::DisassociatedDataStorageState) -> Self {
            self.disassociated_data_storage = Some(input);
            self
        }
        /// <p>Contains the storage configuration for time series (data streams) that aren't associated with asset properties. The <code>disassociatedDataStorage</code> can be one of the following values:</p> 
        /// <ul> 
        /// <li> <p> <code>ENABLED</code>  IoT SiteWise accepts time series that aren't associated with asset properties.</p> <important> 
        /// <p>After the <code>disassociatedDataStorage</code> is enabled, you can't disable it.</p> 
        /// </important> </li> 
        /// <li> <p> <code>DISABLED</code>  IoT SiteWise doesn't accept time series (data streams) that aren't associated with asset properties.</p> </li> 
        /// </ul> 
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/data-streams.html">Data streams</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_disassociated_data_storage(mut self, input: std::option::Option<crate::model::DisassociatedDataStorageState>) -> Self {
            self.disassociated_data_storage = input; self
        }
        /// <p>How many days your data is kept in the hot tier. By default, your data is kept indefinitely in the hot tier.</p>
        pub fn retention_period(mut self, input: crate::model::RetentionPeriod) -> Self {
            self.retention_period = Some(input);
            self
        }
        /// <p>How many days your data is kept in the hot tier. By default, your data is kept indefinitely in the hot tier.</p>
        pub fn set_retention_period(mut self, input: std::option::Option<crate::model::RetentionPeriod>) -> Self {
            self.retention_period = input; self
        }
        /// Consumes the builder and constructs a [`PutStorageConfigurationInput`](crate::input::PutStorageConfigurationInput).
        pub fn build(self) -> Result<crate::input::PutStorageConfigurationInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::PutStorageConfigurationInput {
                    storage_type: self.storage_type
                    ,
                    multi_layer_storage: self.multi_layer_storage
                    ,
                    disassociated_data_storage: self.disassociated_data_storage
                    ,
                    retention_period: self.retention_period
                    ,
                }
            )
        }
    }
    
    
}
impl PutStorageConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`PutStorageConfiguration`](crate::operation::PutStorageConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::PutStorageConfiguration, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::PutStorageConfigurationInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/configuration/account/storage").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::PutStorageConfigurationInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_put_storage_configuration(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::PutStorageConfiguration::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("PutStorageConfiguration", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`PutStorageConfigurationInput`](crate::input::PutStorageConfigurationInput).
    pub fn builder() -> crate::input::put_storage_configuration_input::Builder {
        crate::input::put_storage_configuration_input::Builder::default()
    }
}

/// See [`TagResourceInput`](crate::input::TagResourceInput).
pub mod tag_resource_input {
    
    /// A builder for [`TagResourceInput`](crate::input::TagResourceInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    }
    impl Builder {
        /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the resource to tag.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the resource to tag.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A list of key-value pairs that contain metadata for the resource. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise resources</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>A list of key-value pairs that contain metadata for the resource. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise resources</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`TagResourceInput`](crate::input::TagResourceInput).
        pub fn build(self) -> Result<crate::input::TagResourceInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::TagResourceInput {
                    resource_arn: self.resource_arn
                    ,
                    tags: self.tags
                    ,
                }
            )
        }
    }
    
    
}
impl TagResourceInput {
    /// Consumes the builder and constructs an Operation<[`TagResource`](crate::operation::TagResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::TagResource, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::TagResourceInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/tags").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::TagResourceInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_133 = &_input.resource_arn;
                let inner_133 = inner_133.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("resource_arn", "cannot be empty or unset"))?;
                if inner_133.is_empty() {
                    return Err(aws_smithy_http::operation::error::BuildError::missing_field("resource_arn", "cannot be empty or unset"));
                }
                query.push_kv("resourceArn", &aws_smithy_http::query::fmt_string(&inner_133));
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::TagResourceInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_tag_resource(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::TagResource::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("TagResource", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput).
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
}

/// See [`UntagResourceInput`](crate::input::UntagResourceInput).
pub mod untag_resource_input {
    
    /// A builder for [`UntagResourceInput`](crate::input::UntagResourceInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the resource to untag.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the resource to untag.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input; self
        }
        /// Appends an item to `tag_keys`.
        ///
        /// To override the contents of this collection use [`set_tag_keys`](Self::set_tag_keys).
        ///
        /// <p>A list of keys for tags to remove from the resource.</p>
        pub fn tag_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
                            v.push(input.into());
                            self.tag_keys = Some(v);
                            self
        }
        /// <p>A list of keys for tags to remove from the resource.</p>
        pub fn set_tag_keys(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.tag_keys = input; self
        }
        /// Consumes the builder and constructs a [`UntagResourceInput`](crate::input::UntagResourceInput).
        pub fn build(self) -> Result<crate::input::UntagResourceInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UntagResourceInput {
                    resource_arn: self.resource_arn
                    ,
                    tag_keys: self.tag_keys
                    ,
                }
            )
        }
    }
    
    
}
impl UntagResourceInput {
    /// Consumes the builder and constructs an Operation<[`UntagResource`](crate::operation::UntagResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UntagResource, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UntagResourceInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/tags").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::UntagResourceInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_134 = &_input.resource_arn;
                let inner_134 = inner_134.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("resource_arn", "cannot be empty or unset"))?;
                if inner_134.is_empty() {
                    return Err(aws_smithy_http::operation::error::BuildError::missing_field("resource_arn", "cannot be empty or unset"));
                }
                query.push_kv("resourceArn", &aws_smithy_http::query::fmt_string(&inner_134));
                let inner_135 = &_input.tag_keys;
                let inner_135 = inner_135.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("tag_keys", "cannot be empty or unset"))?;
                for inner_136 in inner_135 {
                    query.push_kv("tagKeys", &aws_smithy_http::query::fmt_string(&inner_136));
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UntagResourceInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UntagResource::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UntagResource", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput).
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
}

/// See [`UpdateAccessPolicyInput`](crate::input::UpdateAccessPolicyInput).
pub mod update_access_policy_input {
    
    /// A builder for [`UpdateAccessPolicyInput`](crate::input::UpdateAccessPolicyInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) access_policy_id: std::option::Option<std::string::String>,
        pub(crate) access_policy_identity: std::option::Option<crate::model::Identity>,
        pub(crate) access_policy_resource: std::option::Option<crate::model::Resource>,
        pub(crate) access_policy_permission: std::option::Option<crate::model::Permission>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the access policy.</p>
        pub fn access_policy_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.access_policy_id = Some(input.into());
            self
        }
        /// <p>The ID of the access policy.</p>
        pub fn set_access_policy_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.access_policy_id = input; self
        }
        /// <p>The identity for this access policy. Choose an IAM Identity Center user, an IAM Identity Center group, or an IAM user.</p>
        pub fn access_policy_identity(mut self, input: crate::model::Identity) -> Self {
            self.access_policy_identity = Some(input);
            self
        }
        /// <p>The identity for this access policy. Choose an IAM Identity Center user, an IAM Identity Center group, or an IAM user.</p>
        pub fn set_access_policy_identity(mut self, input: std::option::Option<crate::model::Identity>) -> Self {
            self.access_policy_identity = input; self
        }
        /// <p>The IoT SiteWise Monitor resource for this access policy. Choose either a portal or a project.</p>
        pub fn access_policy_resource(mut self, input: crate::model::Resource) -> Self {
            self.access_policy_resource = Some(input);
            self
        }
        /// <p>The IoT SiteWise Monitor resource for this access policy. Choose either a portal or a project.</p>
        pub fn set_access_policy_resource(mut self, input: std::option::Option<crate::model::Resource>) -> Self {
            self.access_policy_resource = input; self
        }
        /// <p>The permission level for this access policy. Note that a project <code>ADMINISTRATOR</code> is also known as a project owner.</p>
        pub fn access_policy_permission(mut self, input: crate::model::Permission) -> Self {
            self.access_policy_permission = Some(input);
            self
        }
        /// <p>The permission level for this access policy. Note that a project <code>ADMINISTRATOR</code> is also known as a project owner.</p>
        pub fn set_access_policy_permission(mut self, input: std::option::Option<crate::model::Permission>) -> Self {
            self.access_policy_permission = input; self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// Consumes the builder and constructs a [`UpdateAccessPolicyInput`](crate::input::UpdateAccessPolicyInput).
        pub fn build(self) -> Result<crate::input::UpdateAccessPolicyInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateAccessPolicyInput {
                    access_policy_id: self.access_policy_id
                    ,
                    access_policy_identity: self.access_policy_identity
                    ,
                    access_policy_resource: self.access_policy_resource
                    ,
                    access_policy_permission: self.access_policy_permission
                    ,
                    client_token: self.client_token
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateAccessPolicyInput {
    /// Consumes the builder and constructs an Operation<[`UpdateAccessPolicy`](crate::operation::UpdateAccessPolicy)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateAccessPolicy, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.client_token.is_none() {
                                self.client_token = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateAccessPolicyInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_137 = &_input.access_policy_id;
                let input_137 = input_137.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("access_policy_id", "cannot be empty or unset"))?;
                let access_policy_id = aws_smithy_http::label::fmt_string(input_137, aws_smithy_http::label::EncodingStrategy::Default);
                if access_policy_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("access_policy_id", "cannot be empty or unset"))
                            }
                write!(output, "/access-policies/{accessPolicyId}", accessPolicyId = access_policy_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateAccessPolicyInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_access_policy(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("monitor.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateAccessPolicy::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateAccessPolicy", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateAccessPolicyInput`](crate::input::UpdateAccessPolicyInput).
    pub fn builder() -> crate::input::update_access_policy_input::Builder {
        crate::input::update_access_policy_input::Builder::default()
    }
}

/// See [`UpdateAssetInput`](crate::input::UpdateAssetInput).
pub mod update_asset_input {
    
    /// A builder for [`UpdateAssetInput`](crate::input::UpdateAssetInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) asset_id: std::option::Option<std::string::String>,
        pub(crate) asset_name: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) asset_description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the asset to update.</p>
        pub fn asset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset to update.</p>
        pub fn set_asset_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_id = input; self
        }
        /// <p>A friendly name for the asset.</p>
        pub fn asset_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_name = Some(input.into());
            self
        }
        /// <p>A friendly name for the asset.</p>
        pub fn set_asset_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_name = input; self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// <p>A description for the asset.</p>
        pub fn asset_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_description = Some(input.into());
            self
        }
        /// <p>A description for the asset.</p>
        pub fn set_asset_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_description = input; self
        }
        /// Consumes the builder and constructs a [`UpdateAssetInput`](crate::input::UpdateAssetInput).
        pub fn build(self) -> Result<crate::input::UpdateAssetInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateAssetInput {
                    asset_id: self.asset_id
                    ,
                    asset_name: self.asset_name
                    ,
                    client_token: self.client_token
                    ,
                    asset_description: self.asset_description
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateAssetInput {
    /// Consumes the builder and constructs an Operation<[`UpdateAsset`](crate::operation::UpdateAsset)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateAsset, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.client_token.is_none() {
                                self.client_token = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateAssetInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_138 = &_input.asset_id;
                let input_138 = input_138.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("asset_id", "cannot be empty or unset"))?;
                let asset_id = aws_smithy_http::label::fmt_string(input_138, aws_smithy_http::label::EncodingStrategy::Default);
                if asset_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("asset_id", "cannot be empty or unset"))
                            }
                write!(output, "/assets/{assetId}", assetId = asset_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateAssetInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_asset(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateAsset::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateAsset", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateAssetInput`](crate::input::UpdateAssetInput).
    pub fn builder() -> crate::input::update_asset_input::Builder {
        crate::input::update_asset_input::Builder::default()
    }
}

/// See [`UpdateAssetModelInput`](crate::input::UpdateAssetModelInput).
pub mod update_asset_model_input {
    
    /// A builder for [`UpdateAssetModelInput`](crate::input::UpdateAssetModelInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) asset_model_id: std::option::Option<std::string::String>,
        pub(crate) asset_model_name: std::option::Option<std::string::String>,
        pub(crate) asset_model_description: std::option::Option<std::string::String>,
        pub(crate) asset_model_properties: std::option::Option<std::vec::Vec<crate::model::AssetModelProperty>>,
        pub(crate) asset_model_hierarchies: std::option::Option<std::vec::Vec<crate::model::AssetModelHierarchy>>,
        pub(crate) asset_model_composite_models: std::option::Option<std::vec::Vec<crate::model::AssetModelCompositeModel>>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the asset model to update.</p>
        pub fn asset_model_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_model_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset model to update.</p>
        pub fn set_asset_model_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_model_id = input; self
        }
        /// <p>A unique, friendly name for the asset model.</p>
        pub fn asset_model_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_model_name = Some(input.into());
            self
        }
        /// <p>A unique, friendly name for the asset model.</p>
        pub fn set_asset_model_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_model_name = input; self
        }
        /// <p>A description for the asset model.</p>
        pub fn asset_model_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_model_description = Some(input.into());
            self
        }
        /// <p>A description for the asset model.</p>
        pub fn set_asset_model_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_model_description = input; self
        }
        /// Appends an item to `asset_model_properties`.
        ///
        /// To override the contents of this collection use [`set_asset_model_properties`](Self::set_asset_model_properties).
        ///
        /// <p>The updated property definitions of the asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html">Asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p> 
        /// <p>You can specify up to 200 properties per asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn asset_model_properties(mut self, input: crate::model::AssetModelProperty) -> Self {
            let mut v = self.asset_model_properties.unwrap_or_default();
                            v.push(input);
                            self.asset_model_properties = Some(v);
                            self
        }
        /// <p>The updated property definitions of the asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html">Asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p> 
        /// <p>You can specify up to 200 properties per asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_asset_model_properties(mut self, input: std::option::Option<std::vec::Vec<crate::model::AssetModelProperty>>) -> Self {
            self.asset_model_properties = input; self
        }
        /// Appends an item to `asset_model_hierarchies`.
        ///
        /// To override the contents of this collection use [`set_asset_model_hierarchies`](Self::set_asset_model_hierarchies).
        ///
        /// <p>The updated hierarchy definitions of the asset model. Each hierarchy specifies an asset model whose assets can be children of any other assets created from this asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html">Asset hierarchies</a> in the <i>IoT SiteWise User Guide</i>.</p> 
        /// <p>You can specify up to 10 hierarchies per asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn asset_model_hierarchies(mut self, input: crate::model::AssetModelHierarchy) -> Self {
            let mut v = self.asset_model_hierarchies.unwrap_or_default();
                            v.push(input);
                            self.asset_model_hierarchies = Some(v);
                            self
        }
        /// <p>The updated hierarchy definitions of the asset model. Each hierarchy specifies an asset model whose assets can be children of any other assets created from this asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html">Asset hierarchies</a> in the <i>IoT SiteWise User Guide</i>.</p> 
        /// <p>You can specify up to 10 hierarchies per asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_asset_model_hierarchies(mut self, input: std::option::Option<std::vec::Vec<crate::model::AssetModelHierarchy>>) -> Self {
            self.asset_model_hierarchies = input; self
        }
        /// Appends an item to `asset_model_composite_models`.
        ///
        /// To override the contents of this collection use [`set_asset_model_composite_models`](Self::set_asset_model_composite_models).
        ///
        /// <p>The composite asset models that are part of this asset model. Composite asset models are asset models that contain specific properties. Each composite model has a type that defines the properties that the composite model supports. Use composite asset models to define alarms on this asset model.</p>
        pub fn asset_model_composite_models(mut self, input: crate::model::AssetModelCompositeModel) -> Self {
            let mut v = self.asset_model_composite_models.unwrap_or_default();
                            v.push(input);
                            self.asset_model_composite_models = Some(v);
                            self
        }
        /// <p>The composite asset models that are part of this asset model. Composite asset models are asset models that contain specific properties. Each composite model has a type that defines the properties that the composite model supports. Use composite asset models to define alarms on this asset model.</p>
        pub fn set_asset_model_composite_models(mut self, input: std::option::Option<std::vec::Vec<crate::model::AssetModelCompositeModel>>) -> Self {
            self.asset_model_composite_models = input; self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// Consumes the builder and constructs a [`UpdateAssetModelInput`](crate::input::UpdateAssetModelInput).
        pub fn build(self) -> Result<crate::input::UpdateAssetModelInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateAssetModelInput {
                    asset_model_id: self.asset_model_id
                    ,
                    asset_model_name: self.asset_model_name
                    ,
                    asset_model_description: self.asset_model_description
                    ,
                    asset_model_properties: self.asset_model_properties
                    ,
                    asset_model_hierarchies: self.asset_model_hierarchies
                    ,
                    asset_model_composite_models: self.asset_model_composite_models
                    ,
                    client_token: self.client_token
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateAssetModelInput {
    /// Consumes the builder and constructs an Operation<[`UpdateAssetModel`](crate::operation::UpdateAssetModel)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateAssetModel, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.client_token.is_none() {
                                self.client_token = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateAssetModelInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_139 = &_input.asset_model_id;
                let input_139 = input_139.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("asset_model_id", "cannot be empty or unset"))?;
                let asset_model_id = aws_smithy_http::label::fmt_string(input_139, aws_smithy_http::label::EncodingStrategy::Default);
                if asset_model_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("asset_model_id", "cannot be empty or unset"))
                            }
                write!(output, "/asset-models/{assetModelId}", assetModelId = asset_model_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateAssetModelInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_asset_model(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateAssetModel::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateAssetModel", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateAssetModelInput`](crate::input::UpdateAssetModelInput).
    pub fn builder() -> crate::input::update_asset_model_input::Builder {
        crate::input::update_asset_model_input::Builder::default()
    }
}

/// See [`UpdateAssetPropertyInput`](crate::input::UpdateAssetPropertyInput).
pub mod update_asset_property_input {
    
    /// A builder for [`UpdateAssetPropertyInput`](crate::input::UpdateAssetPropertyInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) asset_id: std::option::Option<std::string::String>,
        pub(crate) property_id: std::option::Option<std::string::String>,
        pub(crate) property_alias: std::option::Option<std::string::String>,
        pub(crate) property_notification_state: std::option::Option<crate::model::PropertyNotificationState>,
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) property_unit: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the asset to be updated.</p>
        pub fn asset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset to be updated.</p>
        pub fn set_asset_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_id = input; self
        }
        /// <p>The ID of the asset property to be updated.</p>
        pub fn property_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset property to be updated.</p>
        pub fn set_property_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.property_id = input; self
        }
        /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p> 
        /// <p>If you omit this parameter, the alias is removed from the property.</p>
        pub fn property_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_alias = Some(input.into());
            self
        }
        /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p> 
        /// <p>If you omit this parameter, the alias is removed from the property.</p>
        pub fn set_property_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.property_alias = input; self
        }
        /// <p>The MQTT notification state (enabled or disabled) for this asset property. When the notification state is enabled, IoT SiteWise publishes property value updates to a unique MQTT topic. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/interact-with-other-services.html">Interacting with other services</a> in the <i>IoT SiteWise User Guide</i>.</p> 
        /// <p>If you omit this parameter, the notification state is set to <code>DISABLED</code>.</p>
        pub fn property_notification_state(mut self, input: crate::model::PropertyNotificationState) -> Self {
            self.property_notification_state = Some(input);
            self
        }
        /// <p>The MQTT notification state (enabled or disabled) for this asset property. When the notification state is enabled, IoT SiteWise publishes property value updates to a unique MQTT topic. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/interact-with-other-services.html">Interacting with other services</a> in the <i>IoT SiteWise User Guide</i>.</p> 
        /// <p>If you omit this parameter, the notification state is set to <code>DISABLED</code>.</p>
        pub fn set_property_notification_state(mut self, input: std::option::Option<crate::model::PropertyNotificationState>) -> Self {
            self.property_notification_state = input; self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// <p>The unit of measure (such as Newtons or RPM) of the asset property. If you don't specify a value for this parameter, the service uses the value of the <code>assetModelProperty</code> in the asset model.</p>
        pub fn property_unit(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_unit = Some(input.into());
            self
        }
        /// <p>The unit of measure (such as Newtons or RPM) of the asset property. If you don't specify a value for this parameter, the service uses the value of the <code>assetModelProperty</code> in the asset model.</p>
        pub fn set_property_unit(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.property_unit = input; self
        }
        /// Consumes the builder and constructs a [`UpdateAssetPropertyInput`](crate::input::UpdateAssetPropertyInput).
        pub fn build(self) -> Result<crate::input::UpdateAssetPropertyInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateAssetPropertyInput {
                    asset_id: self.asset_id
                    ,
                    property_id: self.property_id
                    ,
                    property_alias: self.property_alias
                    ,
                    property_notification_state: self.property_notification_state
                    ,
                    client_token: self.client_token
                    ,
                    property_unit: self.property_unit
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateAssetPropertyInput {
    /// Consumes the builder and constructs an Operation<[`UpdateAssetProperty`](crate::operation::UpdateAssetProperty)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateAssetProperty, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.client_token.is_none() {
                                self.client_token = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateAssetPropertyInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_140 = &_input.asset_id;
                let input_140 = input_140.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("asset_id", "cannot be empty or unset"))?;
                let asset_id = aws_smithy_http::label::fmt_string(input_140, aws_smithy_http::label::EncodingStrategy::Default);
                if asset_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("asset_id", "cannot be empty or unset"))
                            }
                let input_141 = &_input.property_id;
                let input_141 = input_141.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("property_id", "cannot be empty or unset"))?;
                let property_id = aws_smithy_http::label::fmt_string(input_141, aws_smithy_http::label::EncodingStrategy::Default);
                if property_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("property_id", "cannot be empty or unset"))
                            }
                write!(output, "/assets/{assetId}/properties/{propertyId}", assetId = asset_id, propertyId = property_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateAssetPropertyInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_asset_property(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateAssetProperty::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateAssetProperty", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateAssetPropertyInput`](crate::input::UpdateAssetPropertyInput).
    pub fn builder() -> crate::input::update_asset_property_input::Builder {
        crate::input::update_asset_property_input::Builder::default()
    }
}

/// See [`UpdateDashboardInput`](crate::input::UpdateDashboardInput).
pub mod update_dashboard_input {
    
    /// A builder for [`UpdateDashboardInput`](crate::input::UpdateDashboardInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dashboard_id: std::option::Option<std::string::String>,
        pub(crate) dashboard_name: std::option::Option<std::string::String>,
        pub(crate) dashboard_description: std::option::Option<std::string::String>,
        pub(crate) dashboard_definition: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the dashboard to update.</p>
        pub fn dashboard_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.dashboard_id = Some(input.into());
            self
        }
        /// <p>The ID of the dashboard to update.</p>
        pub fn set_dashboard_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.dashboard_id = input; self
        }
        /// <p>A new friendly name for the dashboard.</p>
        pub fn dashboard_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.dashboard_name = Some(input.into());
            self
        }
        /// <p>A new friendly name for the dashboard.</p>
        pub fn set_dashboard_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.dashboard_name = input; self
        }
        /// <p>A new description for the dashboard.</p>
        pub fn dashboard_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.dashboard_description = Some(input.into());
            self
        }
        /// <p>A new description for the dashboard.</p>
        pub fn set_dashboard_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.dashboard_description = input; self
        }
        /// <p>The new dashboard definition, as specified in a JSON literal. For detailed information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/create-dashboards-using-aws-cli.html">Creating dashboards (CLI)</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn dashboard_definition(mut self, input: impl Into<std::string::String>) -> Self {
            self.dashboard_definition = Some(input.into());
            self
        }
        /// <p>The new dashboard definition, as specified in a JSON literal. For detailed information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/create-dashboards-using-aws-cli.html">Creating dashboards (CLI)</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_dashboard_definition(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.dashboard_definition = input; self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// Consumes the builder and constructs a [`UpdateDashboardInput`](crate::input::UpdateDashboardInput).
        pub fn build(self) -> Result<crate::input::UpdateDashboardInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateDashboardInput {
                    dashboard_id: self.dashboard_id
                    ,
                    dashboard_name: self.dashboard_name
                    ,
                    dashboard_description: self.dashboard_description
                    ,
                    dashboard_definition: self.dashboard_definition
                    ,
                    client_token: self.client_token
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateDashboardInput {
    /// Consumes the builder and constructs an Operation<[`UpdateDashboard`](crate::operation::UpdateDashboard)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateDashboard, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.client_token.is_none() {
                                self.client_token = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateDashboardInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_142 = &_input.dashboard_id;
                let input_142 = input_142.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("dashboard_id", "cannot be empty or unset"))?;
                let dashboard_id = aws_smithy_http::label::fmt_string(input_142, aws_smithy_http::label::EncodingStrategy::Default);
                if dashboard_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("dashboard_id", "cannot be empty or unset"))
                            }
                write!(output, "/dashboards/{dashboardId}", dashboardId = dashboard_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateDashboardInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_dashboard(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("monitor.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateDashboard::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateDashboard", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateDashboardInput`](crate::input::UpdateDashboardInput).
    pub fn builder() -> crate::input::update_dashboard_input::Builder {
        crate::input::update_dashboard_input::Builder::default()
    }
}

/// See [`UpdateGatewayInput`](crate::input::UpdateGatewayInput).
pub mod update_gateway_input {
    
    /// A builder for [`UpdateGatewayInput`](crate::input::UpdateGatewayInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) gateway_id: std::option::Option<std::string::String>,
        pub(crate) gateway_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the gateway to update.</p>
        pub fn gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.gateway_id = Some(input.into());
            self
        }
        /// <p>The ID of the gateway to update.</p>
        pub fn set_gateway_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.gateway_id = input; self
        }
        /// <p>A unique, friendly name for the gateway.</p>
        pub fn gateway_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.gateway_name = Some(input.into());
            self
        }
        /// <p>A unique, friendly name for the gateway.</p>
        pub fn set_gateway_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.gateway_name = input; self
        }
        /// Consumes the builder and constructs a [`UpdateGatewayInput`](crate::input::UpdateGatewayInput).
        pub fn build(self) -> Result<crate::input::UpdateGatewayInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateGatewayInput {
                    gateway_id: self.gateway_id
                    ,
                    gateway_name: self.gateway_name
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateGatewayInput {
    /// Consumes the builder and constructs an Operation<[`UpdateGateway`](crate::operation::UpdateGateway)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateGateway, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateGatewayInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_143 = &_input.gateway_id;
                let input_143 = input_143.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("gateway_id", "cannot be empty or unset"))?;
                let gateway_id = aws_smithy_http::label::fmt_string(input_143, aws_smithy_http::label::EncodingStrategy::Default);
                if gateway_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("gateway_id", "cannot be empty or unset"))
                            }
                write!(output, "/20200301/gateways/{gatewayId}", gatewayId = gateway_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateGatewayInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_gateway(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateGateway::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateGateway", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateGatewayInput`](crate::input::UpdateGatewayInput).
    pub fn builder() -> crate::input::update_gateway_input::Builder {
        crate::input::update_gateway_input::Builder::default()
    }
}

/// See [`UpdateGatewayCapabilityConfigurationInput`](crate::input::UpdateGatewayCapabilityConfigurationInput).
pub mod update_gateway_capability_configuration_input {
    
    /// A builder for [`UpdateGatewayCapabilityConfigurationInput`](crate::input::UpdateGatewayCapabilityConfigurationInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) gateway_id: std::option::Option<std::string::String>,
        pub(crate) capability_namespace: std::option::Option<std::string::String>,
        pub(crate) capability_configuration: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the gateway to be updated.</p>
        pub fn gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.gateway_id = Some(input.into());
            self
        }
        /// <p>The ID of the gateway to be updated.</p>
        pub fn set_gateway_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.gateway_id = input; self
        }
        /// <p>The namespace of the gateway capability configuration to be updated. For example, if you configure OPC-UA sources from the IoT SiteWise console, your OPC-UA capability configuration has the namespace <code>iotsitewise:opcuacollector:version</code>, where <code>version</code> is a number such as <code>1</code>.</p>
        pub fn capability_namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.capability_namespace = Some(input.into());
            self
        }
        /// <p>The namespace of the gateway capability configuration to be updated. For example, if you configure OPC-UA sources from the IoT SiteWise console, your OPC-UA capability configuration has the namespace <code>iotsitewise:opcuacollector:version</code>, where <code>version</code> is a number such as <code>1</code>.</p>
        pub fn set_capability_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.capability_namespace = input; self
        }
        /// <p>The JSON document that defines the configuration for the gateway capability. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/configure-sources.html#configure-source-cli">Configuring data sources (CLI)</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn capability_configuration(mut self, input: impl Into<std::string::String>) -> Self {
            self.capability_configuration = Some(input.into());
            self
        }
        /// <p>The JSON document that defines the configuration for the gateway capability. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/configure-sources.html#configure-source-cli">Configuring data sources (CLI)</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_capability_configuration(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.capability_configuration = input; self
        }
        /// Consumes the builder and constructs a [`UpdateGatewayCapabilityConfigurationInput`](crate::input::UpdateGatewayCapabilityConfigurationInput).
        pub fn build(self) -> Result<crate::input::UpdateGatewayCapabilityConfigurationInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateGatewayCapabilityConfigurationInput {
                    gateway_id: self.gateway_id
                    ,
                    capability_namespace: self.capability_namespace
                    ,
                    capability_configuration: self.capability_configuration
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateGatewayCapabilityConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`UpdateGatewayCapabilityConfiguration`](crate::operation::UpdateGatewayCapabilityConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateGatewayCapabilityConfiguration, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateGatewayCapabilityConfigurationInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_144 = &_input.gateway_id;
                let input_144 = input_144.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("gateway_id", "cannot be empty or unset"))?;
                let gateway_id = aws_smithy_http::label::fmt_string(input_144, aws_smithy_http::label::EncodingStrategy::Default);
                if gateway_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("gateway_id", "cannot be empty or unset"))
                            }
                write!(output, "/20200301/gateways/{gatewayId}/capability", gatewayId = gateway_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateGatewayCapabilityConfigurationInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_gateway_capability_configuration(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("api.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateGatewayCapabilityConfiguration::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateGatewayCapabilityConfiguration", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateGatewayCapabilityConfigurationInput`](crate::input::UpdateGatewayCapabilityConfigurationInput).
    pub fn builder() -> crate::input::update_gateway_capability_configuration_input::Builder {
        crate::input::update_gateway_capability_configuration_input::Builder::default()
    }
}

/// See [`UpdatePortalInput`](crate::input::UpdatePortalInput).
pub mod update_portal_input {
    
    /// A builder for [`UpdatePortalInput`](crate::input::UpdatePortalInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) portal_id: std::option::Option<std::string::String>,
        pub(crate) portal_name: std::option::Option<std::string::String>,
        pub(crate) portal_description: std::option::Option<std::string::String>,
        pub(crate) portal_contact_email: std::option::Option<std::string::String>,
        pub(crate) portal_logo_image: std::option::Option<crate::model::Image>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) notification_sender_email: std::option::Option<std::string::String>,
        pub(crate) alarms: std::option::Option<crate::model::Alarms>,
    }
    impl Builder {
        /// <p>The ID of the portal to update.</p>
        pub fn portal_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.portal_id = Some(input.into());
            self
        }
        /// <p>The ID of the portal to update.</p>
        pub fn set_portal_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.portal_id = input; self
        }
        /// <p>A new friendly name for the portal.</p>
        pub fn portal_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.portal_name = Some(input.into());
            self
        }
        /// <p>A new friendly name for the portal.</p>
        pub fn set_portal_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.portal_name = input; self
        }
        /// <p>A new description for the portal.</p>
        pub fn portal_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.portal_description = Some(input.into());
            self
        }
        /// <p>A new description for the portal.</p>
        pub fn set_portal_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.portal_description = input; self
        }
        /// <p>The Amazon Web Services administrator's contact email address.</p>
        pub fn portal_contact_email(mut self, input: impl Into<std::string::String>) -> Self {
            self.portal_contact_email = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services administrator's contact email address.</p>
        pub fn set_portal_contact_email(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.portal_contact_email = input; self
        }
        /// <p>Contains an image that is one of the following:</p> 
        /// <ul> 
        /// <li> <p>An image file. Choose this option to upload a new image.</p> </li> 
        /// <li> <p>The ID of an existing image. Choose this option to keep an existing image.</p> </li> 
        /// </ul>
        pub fn portal_logo_image(mut self, input: crate::model::Image) -> Self {
            self.portal_logo_image = Some(input);
            self
        }
        /// <p>Contains an image that is one of the following:</p> 
        /// <ul> 
        /// <li> <p>An image file. Choose this option to upload a new image.</p> </li> 
        /// <li> <p>The ID of an existing image. Choose this option to keep an existing image.</p> </li> 
        /// </ul>
        pub fn set_portal_logo_image(mut self, input: std::option::Option<crate::model::Image>) -> Self {
            self.portal_logo_image = input; self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of a service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-service-role.html">Using service roles for IoT SiteWise Monitor</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of a service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-service-role.html">Using service roles for IoT SiteWise Monitor</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input; self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// <p>The email address that sends alarm notifications.</p>
        pub fn notification_sender_email(mut self, input: impl Into<std::string::String>) -> Self {
            self.notification_sender_email = Some(input.into());
            self
        }
        /// <p>The email address that sends alarm notifications.</p>
        pub fn set_notification_sender_email(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.notification_sender_email = input; self
        }
        /// <p>Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal. You can use the alarm to monitor an asset property and get notified when the asset property value is outside a specified range. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/appguide/monitor-alarms.html">Monitoring with alarms</a> in the <i>IoT SiteWise Application Guide</i>.</p>
        pub fn alarms(mut self, input: crate::model::Alarms) -> Self {
            self.alarms = Some(input);
            self
        }
        /// <p>Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal. You can use the alarm to monitor an asset property and get notified when the asset property value is outside a specified range. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/appguide/monitor-alarms.html">Monitoring with alarms</a> in the <i>IoT SiteWise Application Guide</i>.</p>
        pub fn set_alarms(mut self, input: std::option::Option<crate::model::Alarms>) -> Self {
            self.alarms = input; self
        }
        /// Consumes the builder and constructs a [`UpdatePortalInput`](crate::input::UpdatePortalInput).
        pub fn build(self) -> Result<crate::input::UpdatePortalInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdatePortalInput {
                    portal_id: self.portal_id
                    ,
                    portal_name: self.portal_name
                    ,
                    portal_description: self.portal_description
                    ,
                    portal_contact_email: self.portal_contact_email
                    ,
                    portal_logo_image: self.portal_logo_image
                    ,
                    role_arn: self.role_arn
                    ,
                    client_token: self.client_token
                    ,
                    notification_sender_email: self.notification_sender_email
                    ,
                    alarms: self.alarms
                    ,
                }
            )
        }
    }
    
    
}
impl UpdatePortalInput {
    /// Consumes the builder and constructs an Operation<[`UpdatePortal`](crate::operation::UpdatePortal)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdatePortal, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.client_token.is_none() {
                                self.client_token = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::input::UpdatePortalInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_145 = &_input.portal_id;
                let input_145 = input_145.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("portal_id", "cannot be empty or unset"))?;
                let portal_id = aws_smithy_http::label::fmt_string(input_145, aws_smithy_http::label::EncodingStrategy::Default);
                if portal_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("portal_id", "cannot be empty or unset"))
                            }
                write!(output, "/portals/{portalId}", portalId = portal_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdatePortalInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_portal(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("monitor.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdatePortal::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdatePortal", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdatePortalInput`](crate::input::UpdatePortalInput).
    pub fn builder() -> crate::input::update_portal_input::Builder {
        crate::input::update_portal_input::Builder::default()
    }
}

/// See [`UpdateProjectInput`](crate::input::UpdateProjectInput).
pub mod update_project_input {
    
    /// A builder for [`UpdateProjectInput`](crate::input::UpdateProjectInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) project_id: std::option::Option<std::string::String>,
        pub(crate) project_name: std::option::Option<std::string::String>,
        pub(crate) project_description: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the project to update.</p>
        pub fn project_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_id = Some(input.into());
            self
        }
        /// <p>The ID of the project to update.</p>
        pub fn set_project_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_id = input; self
        }
        /// <p>A new friendly name for the project.</p>
        pub fn project_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_name = Some(input.into());
            self
        }
        /// <p>A new friendly name for the project.</p>
        pub fn set_project_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_name = input; self
        }
        /// <p>A new description for the project.</p>
        pub fn project_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_description = Some(input.into());
            self
        }
        /// <p>A new description for the project.</p>
        pub fn set_project_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_description = input; self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// Consumes the builder and constructs a [`UpdateProjectInput`](crate::input::UpdateProjectInput).
        pub fn build(self) -> Result<crate::input::UpdateProjectInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateProjectInput {
                    project_id: self.project_id
                    ,
                    project_name: self.project_name
                    ,
                    project_description: self.project_description
                    ,
                    client_token: self.client_token
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateProjectInput {
    /// Consumes the builder and constructs an Operation<[`UpdateProject`](crate::operation::UpdateProject)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateProject, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.client_token.is_none() {
                                self.client_token = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateProjectInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_146 = &_input.project_id;
                let input_146 = input_146.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("project_id", "cannot be empty or unset"))?;
                let project_id = aws_smithy_http::label::fmt_string(input_146, aws_smithy_http::label::EncodingStrategy::Default);
                if project_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("project_id", "cannot be empty or unset"))
                            }
                write!(output, "/projects/{projectId}", projectId = project_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateProjectInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_project(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        let endpoint_prefix =
            aws_smithy_http::endpoint::EndpointPrefix::new("monitor.")
        ?;
        request.properties_mut().insert(endpoint_prefix);
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateProject::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateProject", "iotsitewise"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateProjectInput`](crate::input::UpdateProjectInput).
    pub fn builder() -> crate::input::update_project_input::Builder {
        crate::input::update_project_input::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateProjectInput  {
    /// <p>The ID of the project to update.</p>
    #[doc(hidden)]
    pub project_id: std::option::Option<std::string::String>,
    /// <p>A new friendly name for the project.</p>
    #[doc(hidden)]
    pub project_name: std::option::Option<std::string::String>,
    /// <p>A new description for the project.</p>
    #[doc(hidden)]
    pub project_description: std::option::Option<std::string::String>,
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl UpdateProjectInput {
    /// <p>The ID of the project to update.</p>
    pub fn project_id(&self) -> std::option::Option<& str> {
        self.project_id.as_deref()
    }
    /// <p>A new friendly name for the project.</p>
    pub fn project_name(&self) -> std::option::Option<& str> {
        self.project_name.as_deref()
    }
    /// <p>A new description for the project.</p>
    pub fn project_description(&self) -> std::option::Option<& str> {
        self.project_description.as_deref()
    }
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdatePortalInput  {
    /// <p>The ID of the portal to update.</p>
    #[doc(hidden)]
    pub portal_id: std::option::Option<std::string::String>,
    /// <p>A new friendly name for the portal.</p>
    #[doc(hidden)]
    pub portal_name: std::option::Option<std::string::String>,
    /// <p>A new description for the portal.</p>
    #[doc(hidden)]
    pub portal_description: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services administrator's contact email address.</p>
    #[doc(hidden)]
    pub portal_contact_email: std::option::Option<std::string::String>,
    /// <p>Contains an image that is one of the following:</p> 
    /// <ul> 
    /// <li> <p>An image file. Choose this option to upload a new image.</p> </li> 
    /// <li> <p>The ID of an existing image. Choose this option to keep an existing image.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub portal_logo_image: std::option::Option<crate::model::Image>,
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of a service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-service-role.html">Using service roles for IoT SiteWise Monitor</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
    /// <p>The email address that sends alarm notifications.</p>
    #[doc(hidden)]
    pub notification_sender_email: std::option::Option<std::string::String>,
    /// <p>Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal. You can use the alarm to monitor an asset property and get notified when the asset property value is outside a specified range. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/appguide/monitor-alarms.html">Monitoring with alarms</a> in the <i>IoT SiteWise Application Guide</i>.</p>
    #[doc(hidden)]
    pub alarms: std::option::Option<crate::model::Alarms>,
}
impl UpdatePortalInput {
    /// <p>The ID of the portal to update.</p>
    pub fn portal_id(&self) -> std::option::Option<& str> {
        self.portal_id.as_deref()
    }
    /// <p>A new friendly name for the portal.</p>
    pub fn portal_name(&self) -> std::option::Option<& str> {
        self.portal_name.as_deref()
    }
    /// <p>A new description for the portal.</p>
    pub fn portal_description(&self) -> std::option::Option<& str> {
        self.portal_description.as_deref()
    }
    /// <p>The Amazon Web Services administrator's contact email address.</p>
    pub fn portal_contact_email(&self) -> std::option::Option<& str> {
        self.portal_contact_email.as_deref()
    }
    /// <p>Contains an image that is one of the following:</p> 
    /// <ul> 
    /// <li> <p>An image file. Choose this option to upload a new image.</p> </li> 
    /// <li> <p>The ID of an existing image. Choose this option to keep an existing image.</p> </li> 
    /// </ul>
    pub fn portal_logo_image(&self) -> std::option::Option<& crate::model::Image> {
        self.portal_logo_image.as_ref()
    }
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of a service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-service-role.html">Using service roles for IoT SiteWise Monitor</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn role_arn(&self) -> std::option::Option<& str> {
        self.role_arn.as_deref()
    }
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
    /// <p>The email address that sends alarm notifications.</p>
    pub fn notification_sender_email(&self) -> std::option::Option<& str> {
        self.notification_sender_email.as_deref()
    }
    /// <p>Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal. You can use the alarm to monitor an asset property and get notified when the asset property value is outside a specified range. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/appguide/monitor-alarms.html">Monitoring with alarms</a> in the <i>IoT SiteWise Application Guide</i>.</p>
    pub fn alarms(&self) -> std::option::Option<& crate::model::Alarms> {
        self.alarms.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateGatewayCapabilityConfigurationInput  {
    /// <p>The ID of the gateway to be updated.</p>
    #[doc(hidden)]
    pub gateway_id: std::option::Option<std::string::String>,
    /// <p>The namespace of the gateway capability configuration to be updated. For example, if you configure OPC-UA sources from the IoT SiteWise console, your OPC-UA capability configuration has the namespace <code>iotsitewise:opcuacollector:version</code>, where <code>version</code> is a number such as <code>1</code>.</p>
    #[doc(hidden)]
    pub capability_namespace: std::option::Option<std::string::String>,
    /// <p>The JSON document that defines the configuration for the gateway capability. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/configure-sources.html#configure-source-cli">Configuring data sources (CLI)</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub capability_configuration: std::option::Option<std::string::String>,
}
impl UpdateGatewayCapabilityConfigurationInput {
    /// <p>The ID of the gateway to be updated.</p>
    pub fn gateway_id(&self) -> std::option::Option<& str> {
        self.gateway_id.as_deref()
    }
    /// <p>The namespace of the gateway capability configuration to be updated. For example, if you configure OPC-UA sources from the IoT SiteWise console, your OPC-UA capability configuration has the namespace <code>iotsitewise:opcuacollector:version</code>, where <code>version</code> is a number such as <code>1</code>.</p>
    pub fn capability_namespace(&self) -> std::option::Option<& str> {
        self.capability_namespace.as_deref()
    }
    /// <p>The JSON document that defines the configuration for the gateway capability. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/configure-sources.html#configure-source-cli">Configuring data sources (CLI)</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn capability_configuration(&self) -> std::option::Option<& str> {
        self.capability_configuration.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateGatewayInput  {
    /// <p>The ID of the gateway to update.</p>
    #[doc(hidden)]
    pub gateway_id: std::option::Option<std::string::String>,
    /// <p>A unique, friendly name for the gateway.</p>
    #[doc(hidden)]
    pub gateway_name: std::option::Option<std::string::String>,
}
impl UpdateGatewayInput {
    /// <p>The ID of the gateway to update.</p>
    pub fn gateway_id(&self) -> std::option::Option<& str> {
        self.gateway_id.as_deref()
    }
    /// <p>A unique, friendly name for the gateway.</p>
    pub fn gateway_name(&self) -> std::option::Option<& str> {
        self.gateway_name.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateDashboardInput  {
    /// <p>The ID of the dashboard to update.</p>
    #[doc(hidden)]
    pub dashboard_id: std::option::Option<std::string::String>,
    /// <p>A new friendly name for the dashboard.</p>
    #[doc(hidden)]
    pub dashboard_name: std::option::Option<std::string::String>,
    /// <p>A new description for the dashboard.</p>
    #[doc(hidden)]
    pub dashboard_description: std::option::Option<std::string::String>,
    /// <p>The new dashboard definition, as specified in a JSON literal. For detailed information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/create-dashboards-using-aws-cli.html">Creating dashboards (CLI)</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub dashboard_definition: std::option::Option<std::string::String>,
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl UpdateDashboardInput {
    /// <p>The ID of the dashboard to update.</p>
    pub fn dashboard_id(&self) -> std::option::Option<& str> {
        self.dashboard_id.as_deref()
    }
    /// <p>A new friendly name for the dashboard.</p>
    pub fn dashboard_name(&self) -> std::option::Option<& str> {
        self.dashboard_name.as_deref()
    }
    /// <p>A new description for the dashboard.</p>
    pub fn dashboard_description(&self) -> std::option::Option<& str> {
        self.dashboard_description.as_deref()
    }
    /// <p>The new dashboard definition, as specified in a JSON literal. For detailed information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/create-dashboards-using-aws-cli.html">Creating dashboards (CLI)</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn dashboard_definition(&self) -> std::option::Option<& str> {
        self.dashboard_definition.as_deref()
    }
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateAssetPropertyInput  {
    /// <p>The ID of the asset to be updated.</p>
    #[doc(hidden)]
    pub asset_id: std::option::Option<std::string::String>,
    /// <p>The ID of the asset property to be updated.</p>
    #[doc(hidden)]
    pub property_id: std::option::Option<std::string::String>,
    /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p> 
    /// <p>If you omit this parameter, the alias is removed from the property.</p>
    #[doc(hidden)]
    pub property_alias: std::option::Option<std::string::String>,
    /// <p>The MQTT notification state (enabled or disabled) for this asset property. When the notification state is enabled, IoT SiteWise publishes property value updates to a unique MQTT topic. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/interact-with-other-services.html">Interacting with other services</a> in the <i>IoT SiteWise User Guide</i>.</p> 
    /// <p>If you omit this parameter, the notification state is set to <code>DISABLED</code>.</p>
    #[doc(hidden)]
    pub property_notification_state: std::option::Option<crate::model::PropertyNotificationState>,
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
    /// <p>The unit of measure (such as Newtons or RPM) of the asset property. If you don't specify a value for this parameter, the service uses the value of the <code>assetModelProperty</code> in the asset model.</p>
    #[doc(hidden)]
    pub property_unit: std::option::Option<std::string::String>,
}
impl UpdateAssetPropertyInput {
    /// <p>The ID of the asset to be updated.</p>
    pub fn asset_id(&self) -> std::option::Option<& str> {
        self.asset_id.as_deref()
    }
    /// <p>The ID of the asset property to be updated.</p>
    pub fn property_id(&self) -> std::option::Option<& str> {
        self.property_id.as_deref()
    }
    /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p> 
    /// <p>If you omit this parameter, the alias is removed from the property.</p>
    pub fn property_alias(&self) -> std::option::Option<& str> {
        self.property_alias.as_deref()
    }
    /// <p>The MQTT notification state (enabled or disabled) for this asset property. When the notification state is enabled, IoT SiteWise publishes property value updates to a unique MQTT topic. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/interact-with-other-services.html">Interacting with other services</a> in the <i>IoT SiteWise User Guide</i>.</p> 
    /// <p>If you omit this parameter, the notification state is set to <code>DISABLED</code>.</p>
    pub fn property_notification_state(&self) -> std::option::Option<& crate::model::PropertyNotificationState> {
        self.property_notification_state.as_ref()
    }
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
    /// <p>The unit of measure (such as Newtons or RPM) of the asset property. If you don't specify a value for this parameter, the service uses the value of the <code>assetModelProperty</code> in the asset model.</p>
    pub fn property_unit(&self) -> std::option::Option<& str> {
        self.property_unit.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateAssetModelInput  {
    /// <p>The ID of the asset model to update.</p>
    #[doc(hidden)]
    pub asset_model_id: std::option::Option<std::string::String>,
    /// <p>A unique, friendly name for the asset model.</p>
    #[doc(hidden)]
    pub asset_model_name: std::option::Option<std::string::String>,
    /// <p>A description for the asset model.</p>
    #[doc(hidden)]
    pub asset_model_description: std::option::Option<std::string::String>,
    /// <p>The updated property definitions of the asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html">Asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p> 
    /// <p>You can specify up to 200 properties per asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub asset_model_properties: std::option::Option<std::vec::Vec<crate::model::AssetModelProperty>>,
    /// <p>The updated hierarchy definitions of the asset model. Each hierarchy specifies an asset model whose assets can be children of any other assets created from this asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html">Asset hierarchies</a> in the <i>IoT SiteWise User Guide</i>.</p> 
    /// <p>You can specify up to 10 hierarchies per asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub asset_model_hierarchies: std::option::Option<std::vec::Vec<crate::model::AssetModelHierarchy>>,
    /// <p>The composite asset models that are part of this asset model. Composite asset models are asset models that contain specific properties. Each composite model has a type that defines the properties that the composite model supports. Use composite asset models to define alarms on this asset model.</p>
    #[doc(hidden)]
    pub asset_model_composite_models: std::option::Option<std::vec::Vec<crate::model::AssetModelCompositeModel>>,
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl UpdateAssetModelInput {
    /// <p>The ID of the asset model to update.</p>
    pub fn asset_model_id(&self) -> std::option::Option<& str> {
        self.asset_model_id.as_deref()
    }
    /// <p>A unique, friendly name for the asset model.</p>
    pub fn asset_model_name(&self) -> std::option::Option<& str> {
        self.asset_model_name.as_deref()
    }
    /// <p>A description for the asset model.</p>
    pub fn asset_model_description(&self) -> std::option::Option<& str> {
        self.asset_model_description.as_deref()
    }
    /// <p>The updated property definitions of the asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html">Asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p> 
    /// <p>You can specify up to 200 properties per asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn asset_model_properties(&self) -> std::option::Option<& [crate::model::AssetModelProperty]> {
        self.asset_model_properties.as_deref()
    }
    /// <p>The updated hierarchy definitions of the asset model. Each hierarchy specifies an asset model whose assets can be children of any other assets created from this asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html">Asset hierarchies</a> in the <i>IoT SiteWise User Guide</i>.</p> 
    /// <p>You can specify up to 10 hierarchies per asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn asset_model_hierarchies(&self) -> std::option::Option<& [crate::model::AssetModelHierarchy]> {
        self.asset_model_hierarchies.as_deref()
    }
    /// <p>The composite asset models that are part of this asset model. Composite asset models are asset models that contain specific properties. Each composite model has a type that defines the properties that the composite model supports. Use composite asset models to define alarms on this asset model.</p>
    pub fn asset_model_composite_models(&self) -> std::option::Option<& [crate::model::AssetModelCompositeModel]> {
        self.asset_model_composite_models.as_deref()
    }
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateAssetInput  {
    /// <p>The ID of the asset to update.</p>
    #[doc(hidden)]
    pub asset_id: std::option::Option<std::string::String>,
    /// <p>A friendly name for the asset.</p>
    #[doc(hidden)]
    pub asset_name: std::option::Option<std::string::String>,
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
    /// <p>A description for the asset.</p>
    #[doc(hidden)]
    pub asset_description: std::option::Option<std::string::String>,
}
impl UpdateAssetInput {
    /// <p>The ID of the asset to update.</p>
    pub fn asset_id(&self) -> std::option::Option<& str> {
        self.asset_id.as_deref()
    }
    /// <p>A friendly name for the asset.</p>
    pub fn asset_name(&self) -> std::option::Option<& str> {
        self.asset_name.as_deref()
    }
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
    /// <p>A description for the asset.</p>
    pub fn asset_description(&self) -> std::option::Option<& str> {
        self.asset_description.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateAccessPolicyInput  {
    /// <p>The ID of the access policy.</p>
    #[doc(hidden)]
    pub access_policy_id: std::option::Option<std::string::String>,
    /// <p>The identity for this access policy. Choose an IAM Identity Center user, an IAM Identity Center group, or an IAM user.</p>
    #[doc(hidden)]
    pub access_policy_identity: std::option::Option<crate::model::Identity>,
    /// <p>The IoT SiteWise Monitor resource for this access policy. Choose either a portal or a project.</p>
    #[doc(hidden)]
    pub access_policy_resource: std::option::Option<crate::model::Resource>,
    /// <p>The permission level for this access policy. Note that a project <code>ADMINISTRATOR</code> is also known as a project owner.</p>
    #[doc(hidden)]
    pub access_policy_permission: std::option::Option<crate::model::Permission>,
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl UpdateAccessPolicyInput {
    /// <p>The ID of the access policy.</p>
    pub fn access_policy_id(&self) -> std::option::Option<& str> {
        self.access_policy_id.as_deref()
    }
    /// <p>The identity for this access policy. Choose an IAM Identity Center user, an IAM Identity Center group, or an IAM user.</p>
    pub fn access_policy_identity(&self) -> std::option::Option<& crate::model::Identity> {
        self.access_policy_identity.as_ref()
    }
    /// <p>The IoT SiteWise Monitor resource for this access policy. Choose either a portal or a project.</p>
    pub fn access_policy_resource(&self) -> std::option::Option<& crate::model::Resource> {
        self.access_policy_resource.as_ref()
    }
    /// <p>The permission level for this access policy. Note that a project <code>ADMINISTRATOR</code> is also known as a project owner.</p>
    pub fn access_policy_permission(&self) -> std::option::Option<& crate::model::Permission> {
        self.access_policy_permission.as_ref()
    }
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UntagResourceInput  {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the resource to untag.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>A list of keys for tags to remove from the resource.</p>
    #[doc(hidden)]
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl UntagResourceInput {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the resource to untag.</p>
    pub fn resource_arn(&self) -> std::option::Option<& str> {
        self.resource_arn.as_deref()
    }
    /// <p>A list of keys for tags to remove from the resource.</p>
    pub fn tag_keys(&self) -> std::option::Option<& [std::string::String]> {
        self.tag_keys.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TagResourceInput  {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the resource to tag.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>A list of key-value pairs that contain metadata for the resource. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise resources</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl TagResourceInput {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the resource to tag.</p>
    pub fn resource_arn(&self) -> std::option::Option<& str> {
        self.resource_arn.as_deref()
    }
    /// <p>A list of key-value pairs that contain metadata for the resource. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise resources</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PutStorageConfigurationInput  {
    /// <p>The storage tier that you specified for your data. The <code>storageType</code> parameter can be one of the following values:</p> 
    /// <ul> 
    /// <li> <p> <code>SITEWISE_DEFAULT_STORAGE</code>  IoT SiteWise saves your data into the hot tier. The hot tier is a service-managed database.</p> </li> 
    /// <li> <p> <code>MULTI_LAYER_STORAGE</code>  IoT SiteWise saves your data in both the cold tier and the hot tier. The cold tier is a customer-managed Amazon S3 bucket.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub storage_type: std::option::Option<crate::model::StorageType>,
    /// <p>Identifies a storage destination. If you specified <code>MULTI_LAYER_STORAGE</code> for the storage type, you must specify a <code>MultiLayerStorage</code> object.</p>
    #[doc(hidden)]
    pub multi_layer_storage: std::option::Option<crate::model::MultiLayerStorage>,
    /// <p>Contains the storage configuration for time series (data streams) that aren't associated with asset properties. The <code>disassociatedDataStorage</code> can be one of the following values:</p> 
    /// <ul> 
    /// <li> <p> <code>ENABLED</code>  IoT SiteWise accepts time series that aren't associated with asset properties.</p> <important> 
    /// <p>After the <code>disassociatedDataStorage</code> is enabled, you can't disable it.</p> 
    /// </important> </li> 
    /// <li> <p> <code>DISABLED</code>  IoT SiteWise doesn't accept time series (data streams) that aren't associated with asset properties.</p> </li> 
    /// </ul> 
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/data-streams.html">Data streams</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub disassociated_data_storage: std::option::Option<crate::model::DisassociatedDataStorageState>,
    /// <p>How many days your data is kept in the hot tier. By default, your data is kept indefinitely in the hot tier.</p>
    #[doc(hidden)]
    pub retention_period: std::option::Option<crate::model::RetentionPeriod>,
}
impl PutStorageConfigurationInput {
    /// <p>The storage tier that you specified for your data. The <code>storageType</code> parameter can be one of the following values:</p> 
    /// <ul> 
    /// <li> <p> <code>SITEWISE_DEFAULT_STORAGE</code>  IoT SiteWise saves your data into the hot tier. The hot tier is a service-managed database.</p> </li> 
    /// <li> <p> <code>MULTI_LAYER_STORAGE</code>  IoT SiteWise saves your data in both the cold tier and the hot tier. The cold tier is a customer-managed Amazon S3 bucket.</p> </li> 
    /// </ul>
    pub fn storage_type(&self) -> std::option::Option<& crate::model::StorageType> {
        self.storage_type.as_ref()
    }
    /// <p>Identifies a storage destination. If you specified <code>MULTI_LAYER_STORAGE</code> for the storage type, you must specify a <code>MultiLayerStorage</code> object.</p>
    pub fn multi_layer_storage(&self) -> std::option::Option<& crate::model::MultiLayerStorage> {
        self.multi_layer_storage.as_ref()
    }
    /// <p>Contains the storage configuration for time series (data streams) that aren't associated with asset properties. The <code>disassociatedDataStorage</code> can be one of the following values:</p> 
    /// <ul> 
    /// <li> <p> <code>ENABLED</code>  IoT SiteWise accepts time series that aren't associated with asset properties.</p> <important> 
    /// <p>After the <code>disassociatedDataStorage</code> is enabled, you can't disable it.</p> 
    /// </important> </li> 
    /// <li> <p> <code>DISABLED</code>  IoT SiteWise doesn't accept time series (data streams) that aren't associated with asset properties.</p> </li> 
    /// </ul> 
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/data-streams.html">Data streams</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn disassociated_data_storage(&self) -> std::option::Option<& crate::model::DisassociatedDataStorageState> {
        self.disassociated_data_storage.as_ref()
    }
    /// <p>How many days your data is kept in the hot tier. By default, your data is kept indefinitely in the hot tier.</p>
    pub fn retention_period(&self) -> std::option::Option<& crate::model::RetentionPeriod> {
        self.retention_period.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PutLoggingOptionsInput  {
    /// <p>The logging options to set.</p>
    #[doc(hidden)]
    pub logging_options: std::option::Option<crate::model::LoggingOptions>,
}
impl PutLoggingOptionsInput {
    /// <p>The logging options to set.</p>
    pub fn logging_options(&self) -> std::option::Option<& crate::model::LoggingOptions> {
        self.logging_options.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PutDefaultEncryptionConfigurationInput  {
    /// <p>The type of encryption used for the encryption configuration.</p>
    #[doc(hidden)]
    pub encryption_type: std::option::Option<crate::model::EncryptionType>,
    /// <p>The Key ID of the customer managed key used for KMS encryption. This is required if you use <code>KMS_BASED_ENCRYPTION</code>.</p>
    #[doc(hidden)]
    pub kms_key_id: std::option::Option<std::string::String>,
}
impl PutDefaultEncryptionConfigurationInput {
    /// <p>The type of encryption used for the encryption configuration.</p>
    pub fn encryption_type(&self) -> std::option::Option<& crate::model::EncryptionType> {
        self.encryption_type.as_ref()
    }
    /// <p>The Key ID of the customer managed key used for KMS encryption. This is required if you use <code>KMS_BASED_ENCRYPTION</code>.</p>
    pub fn kms_key_id(&self) -> std::option::Option<& str> {
        self.kms_key_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListTimeSeriesInput  {
    /// <p>The token to be used for the next set of paginated results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return for each paginated request.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The ID of the asset in which the asset property was created.</p>
    #[doc(hidden)]
    pub asset_id: std::option::Option<std::string::String>,
    /// <p>The alias prefix of the time series.</p>
    #[doc(hidden)]
    pub alias_prefix: std::option::Option<std::string::String>,
    /// <p>The type of the time series. The time series type can be one of the following values:</p> 
    /// <ul> 
    /// <li> <p> <code>ASSOCIATED</code>  The time series is associated with an asset property.</p> </li> 
    /// <li> <p> <code>DISASSOCIATED</code>  The time series isn't associated with any asset property.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub time_series_type: std::option::Option<crate::model::ListTimeSeriesType>,
}
impl ListTimeSeriesInput {
    /// <p>The token to be used for the next set of paginated results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return for each paginated request.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The ID of the asset in which the asset property was created.</p>
    pub fn asset_id(&self) -> std::option::Option<& str> {
        self.asset_id.as_deref()
    }
    /// <p>The alias prefix of the time series.</p>
    pub fn alias_prefix(&self) -> std::option::Option<& str> {
        self.alias_prefix.as_deref()
    }
    /// <p>The type of the time series. The time series type can be one of the following values:</p> 
    /// <ul> 
    /// <li> <p> <code>ASSOCIATED</code>  The time series is associated with an asset property.</p> </li> 
    /// <li> <p> <code>DISASSOCIATED</code>  The time series isn't associated with any asset property.</p> </li> 
    /// </ul>
    pub fn time_series_type(&self) -> std::option::Option<& crate::model::ListTimeSeriesType> {
        self.time_series_type.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListTagsForResourceInput  {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the resource.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
}
impl ListTagsForResourceInput {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<& str> {
        self.resource_arn.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListProjectsInput  {
    /// <p>The ID of the portal.</p>
    #[doc(hidden)]
    pub portal_id: std::option::Option<std::string::String>,
    /// <p>The token to be used for the next set of paginated results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return for each paginated request.</p> 
    /// <p>Default: 50</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListProjectsInput {
    /// <p>The ID of the portal.</p>
    pub fn portal_id(&self) -> std::option::Option<& str> {
        self.portal_id.as_deref()
    }
    /// <p>The token to be used for the next set of paginated results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return for each paginated request.</p> 
    /// <p>Default: 50</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListProjectAssetsInput  {
    /// <p>The ID of the project.</p>
    #[doc(hidden)]
    pub project_id: std::option::Option<std::string::String>,
    /// <p>The token to be used for the next set of paginated results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return for each paginated request.</p> 
    /// <p>Default: 50</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListProjectAssetsInput {
    /// <p>The ID of the project.</p>
    pub fn project_id(&self) -> std::option::Option<& str> {
        self.project_id.as_deref()
    }
    /// <p>The token to be used for the next set of paginated results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return for each paginated request.</p> 
    /// <p>Default: 50</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListPortalsInput  {
    /// <p>The token to be used for the next set of paginated results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return for each paginated request.</p> 
    /// <p>Default: 50</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListPortalsInput {
    /// <p>The token to be used for the next set of paginated results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return for each paginated request.</p> 
    /// <p>Default: 50</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListGatewaysInput  {
    /// <p>The token to be used for the next set of paginated results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return for each paginated request.</p> 
    /// <p>Default: 50</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListGatewaysInput {
    /// <p>The token to be used for the next set of paginated results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return for each paginated request.</p> 
    /// <p>Default: 50</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListDashboardsInput  {
    /// <p>The ID of the project.</p>
    #[doc(hidden)]
    pub project_id: std::option::Option<std::string::String>,
    /// <p>The token to be used for the next set of paginated results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return for each paginated request.</p> 
    /// <p>Default: 50</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListDashboardsInput {
    /// <p>The ID of the project.</p>
    pub fn project_id(&self) -> std::option::Option<& str> {
        self.project_id.as_deref()
    }
    /// <p>The token to be used for the next set of paginated results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return for each paginated request.</p> 
    /// <p>Default: 50</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListBulkImportJobsInput  {
    /// <p>The token to be used for the next set of paginated results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return for each paginated request.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>You can use a filter to select the bulk import jobs that you want to retrieve.</p>
    #[doc(hidden)]
    pub filter: std::option::Option<crate::model::ListBulkImportJobsFilter>,
}
impl ListBulkImportJobsInput {
    /// <p>The token to be used for the next set of paginated results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return for each paginated request.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>You can use a filter to select the bulk import jobs that you want to retrieve.</p>
    pub fn filter(&self) -> std::option::Option<& crate::model::ListBulkImportJobsFilter> {
        self.filter.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListAssociatedAssetsInput  {
    /// <p>The ID of the asset to query.</p>
    #[doc(hidden)]
    pub asset_id: std::option::Option<std::string::String>,
    /// <p>The ID of the hierarchy by which child assets are associated to the asset. To find a hierarchy ID, use the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_DescribeAsset.html">DescribeAsset</a> or <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_DescribeAssetModel.html">DescribeAssetModel</a> operations. This parameter is required if you choose <code>CHILD</code> for <code>traversalDirection</code>.</p> 
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html">Asset hierarchies</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub hierarchy_id: std::option::Option<std::string::String>,
    /// <p>The direction to list associated assets. Choose one of the following options:</p> 
    /// <ul> 
    /// <li> <p> <code>CHILD</code>  The list includes all child assets associated to the asset. The <code>hierarchyId</code> parameter is required if you choose <code>CHILD</code>.</p> </li> 
    /// <li> <p> <code>PARENT</code>  The list includes the asset's parent asset.</p> </li> 
    /// </ul> 
    /// <p>Default: <code>CHILD</code> </p>
    #[doc(hidden)]
    pub traversal_direction: std::option::Option<crate::model::TraversalDirection>,
    /// <p>The token to be used for the next set of paginated results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return for each paginated request.</p> 
    /// <p>Default: 50</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListAssociatedAssetsInput {
    /// <p>The ID of the asset to query.</p>
    pub fn asset_id(&self) -> std::option::Option<& str> {
        self.asset_id.as_deref()
    }
    /// <p>The ID of the hierarchy by which child assets are associated to the asset. To find a hierarchy ID, use the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_DescribeAsset.html">DescribeAsset</a> or <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_DescribeAssetModel.html">DescribeAssetModel</a> operations. This parameter is required if you choose <code>CHILD</code> for <code>traversalDirection</code>.</p> 
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html">Asset hierarchies</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn hierarchy_id(&self) -> std::option::Option<& str> {
        self.hierarchy_id.as_deref()
    }
    /// <p>The direction to list associated assets. Choose one of the following options:</p> 
    /// <ul> 
    /// <li> <p> <code>CHILD</code>  The list includes all child assets associated to the asset. The <code>hierarchyId</code> parameter is required if you choose <code>CHILD</code>.</p> </li> 
    /// <li> <p> <code>PARENT</code>  The list includes the asset's parent asset.</p> </li> 
    /// </ul> 
    /// <p>Default: <code>CHILD</code> </p>
    pub fn traversal_direction(&self) -> std::option::Option<& crate::model::TraversalDirection> {
        self.traversal_direction.as_ref()
    }
    /// <p>The token to be used for the next set of paginated results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return for each paginated request.</p> 
    /// <p>Default: 50</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListAssetsInput  {
    /// <p>The token to be used for the next set of paginated results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return for each paginated request.</p> 
    /// <p>Default: 50</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The ID of the asset model by which to filter the list of assets. This parameter is required if you choose <code>ALL</code> for <code>filter</code>.</p>
    #[doc(hidden)]
    pub asset_model_id: std::option::Option<std::string::String>,
    /// <p>The filter for the requested list of assets. Choose one of the following options:</p> 
    /// <ul> 
    /// <li> <p> <code>ALL</code>  The list includes all assets for a given asset model ID. The <code>assetModelId</code> parameter is required if you filter by <code>ALL</code>.</p> </li> 
    /// <li> <p> <code>TOP_LEVEL</code>  The list includes only top-level assets in the asset hierarchy tree.</p> </li> 
    /// </ul> 
    /// <p>Default: <code>ALL</code> </p>
    #[doc(hidden)]
    pub filter: std::option::Option<crate::model::ListAssetsFilter>,
}
impl ListAssetsInput {
    /// <p>The token to be used for the next set of paginated results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return for each paginated request.</p> 
    /// <p>Default: 50</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The ID of the asset model by which to filter the list of assets. This parameter is required if you choose <code>ALL</code> for <code>filter</code>.</p>
    pub fn asset_model_id(&self) -> std::option::Option<& str> {
        self.asset_model_id.as_deref()
    }
    /// <p>The filter for the requested list of assets. Choose one of the following options:</p> 
    /// <ul> 
    /// <li> <p> <code>ALL</code>  The list includes all assets for a given asset model ID. The <code>assetModelId</code> parameter is required if you filter by <code>ALL</code>.</p> </li> 
    /// <li> <p> <code>TOP_LEVEL</code>  The list includes only top-level assets in the asset hierarchy tree.</p> </li> 
    /// </ul> 
    /// <p>Default: <code>ALL</code> </p>
    pub fn filter(&self) -> std::option::Option<& crate::model::ListAssetsFilter> {
        self.filter.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListAssetRelationshipsInput  {
    /// <p>The ID of the asset.</p>
    #[doc(hidden)]
    pub asset_id: std::option::Option<std::string::String>,
    /// <p>The type of traversal to use to identify asset relationships. Choose the following option:</p> 
    /// <ul> 
    /// <li> <p> <code>PATH_TO_ROOT</code>  Identify the asset's parent assets up to the root asset. The asset that you specify in <code>assetId</code> is the first result in the list of <code>assetRelationshipSummaries</code>, and the root asset is the last result.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub traversal_type: std::option::Option<crate::model::TraversalType>,
    /// <p>The token to be used for the next set of paginated results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return for each paginated request.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListAssetRelationshipsInput {
    /// <p>The ID of the asset.</p>
    pub fn asset_id(&self) -> std::option::Option<& str> {
        self.asset_id.as_deref()
    }
    /// <p>The type of traversal to use to identify asset relationships. Choose the following option:</p> 
    /// <ul> 
    /// <li> <p> <code>PATH_TO_ROOT</code>  Identify the asset's parent assets up to the root asset. The asset that you specify in <code>assetId</code> is the first result in the list of <code>assetRelationshipSummaries</code>, and the root asset is the last result.</p> </li> 
    /// </ul>
    pub fn traversal_type(&self) -> std::option::Option<& crate::model::TraversalType> {
        self.traversal_type.as_ref()
    }
    /// <p>The token to be used for the next set of paginated results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return for each paginated request.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListAssetPropertiesInput  {
    /// <p>The ID of the asset.</p>
    #[doc(hidden)]
    pub asset_id: std::option::Option<std::string::String>,
    /// <p>The token to be used for the next set of paginated results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return for each paginated request. If not specified, the default value is 50.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p> Filters the requested list of asset properties. You can choose one of the following options:</p> 
    /// <ul> 
    /// <li> <p> <code>ALL</code>  The list includes all asset properties for a given asset model ID. </p> </li> 
    /// <li> <p> <code>BASE</code>  The list includes only base asset properties for a given asset model ID. </p> </li> 
    /// </ul> 
    /// <p>Default: <code>BASE</code> </p>
    #[doc(hidden)]
    pub filter: std::option::Option<crate::model::ListAssetPropertiesFilter>,
}
impl ListAssetPropertiesInput {
    /// <p>The ID of the asset.</p>
    pub fn asset_id(&self) -> std::option::Option<& str> {
        self.asset_id.as_deref()
    }
    /// <p>The token to be used for the next set of paginated results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return for each paginated request. If not specified, the default value is 50.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p> Filters the requested list of asset properties. You can choose one of the following options:</p> 
    /// <ul> 
    /// <li> <p> <code>ALL</code>  The list includes all asset properties for a given asset model ID. </p> </li> 
    /// <li> <p> <code>BASE</code>  The list includes only base asset properties for a given asset model ID. </p> </li> 
    /// </ul> 
    /// <p>Default: <code>BASE</code> </p>
    pub fn filter(&self) -> std::option::Option<& crate::model::ListAssetPropertiesFilter> {
        self.filter.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListAssetModelsInput  {
    /// <p>The token to be used for the next set of paginated results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return for each paginated request.</p> 
    /// <p>Default: 50</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListAssetModelsInput {
    /// <p>The token to be used for the next set of paginated results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return for each paginated request.</p> 
    /// <p>Default: 50</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListAssetModelPropertiesInput  {
    /// <p>The ID of the asset model.</p>
    #[doc(hidden)]
    pub asset_model_id: std::option::Option<std::string::String>,
    /// <p>The token to be used for the next set of paginated results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return for each paginated request. If not specified, the default value is 50.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p> Filters the requested list of asset model properties. You can choose one of the following options:</p> 
    /// <ul> 
    /// <li> <p> <code>ALL</code>  The list includes all asset model properties for a given asset model ID. </p> </li> 
    /// <li> <p> <code>BASE</code>  The list includes only base asset model properties for a given asset model ID. </p> </li> 
    /// </ul> 
    /// <p>Default: <code>BASE</code> </p>
    #[doc(hidden)]
    pub filter: std::option::Option<crate::model::ListAssetModelPropertiesFilter>,
}
impl ListAssetModelPropertiesInput {
    /// <p>The ID of the asset model.</p>
    pub fn asset_model_id(&self) -> std::option::Option<& str> {
        self.asset_model_id.as_deref()
    }
    /// <p>The token to be used for the next set of paginated results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return for each paginated request. If not specified, the default value is 50.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p> Filters the requested list of asset model properties. You can choose one of the following options:</p> 
    /// <ul> 
    /// <li> <p> <code>ALL</code>  The list includes all asset model properties for a given asset model ID. </p> </li> 
    /// <li> <p> <code>BASE</code>  The list includes only base asset model properties for a given asset model ID. </p> </li> 
    /// </ul> 
    /// <p>Default: <code>BASE</code> </p>
    pub fn filter(&self) -> std::option::Option<& crate::model::ListAssetModelPropertiesFilter> {
        self.filter.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListAccessPoliciesInput  {
    /// <p>The type of identity (IAM Identity Center user, IAM Identity Center group, or IAM user). This parameter is required if you specify <code>identityId</code>.</p>
    #[doc(hidden)]
    pub identity_type: std::option::Option<crate::model::IdentityType>,
    /// <p>The ID of the identity. This parameter is required if you specify <code>USER</code> or <code>GROUP</code> for <code>identityType</code>.</p>
    #[doc(hidden)]
    pub identity_id: std::option::Option<std::string::String>,
    /// <p>The type of resource (portal or project). This parameter is required if you specify <code>resourceId</code>.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<crate::model::ResourceType>,
    /// <p>The ID of the resource. This parameter is required if you specify <code>resourceType</code>.</p>
    #[doc(hidden)]
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The ARN of the IAM user. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM ARNs</a> in the <i>IAM User Guide</i>. This parameter is required if you specify <code>IAM</code> for <code>identityType</code>.</p>
    #[doc(hidden)]
    pub iam_arn: std::option::Option<std::string::String>,
    /// <p>The token to be used for the next set of paginated results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return for each paginated request.</p> 
    /// <p>Default: 50</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListAccessPoliciesInput {
    /// <p>The type of identity (IAM Identity Center user, IAM Identity Center group, or IAM user). This parameter is required if you specify <code>identityId</code>.</p>
    pub fn identity_type(&self) -> std::option::Option<& crate::model::IdentityType> {
        self.identity_type.as_ref()
    }
    /// <p>The ID of the identity. This parameter is required if you specify <code>USER</code> or <code>GROUP</code> for <code>identityType</code>.</p>
    pub fn identity_id(&self) -> std::option::Option<& str> {
        self.identity_id.as_deref()
    }
    /// <p>The type of resource (portal or project). This parameter is required if you specify <code>resourceId</code>.</p>
    pub fn resource_type(&self) -> std::option::Option<& crate::model::ResourceType> {
        self.resource_type.as_ref()
    }
    /// <p>The ID of the resource. This parameter is required if you specify <code>resourceType</code>.</p>
    pub fn resource_id(&self) -> std::option::Option<& str> {
        self.resource_id.as_deref()
    }
    /// <p>The ARN of the IAM user. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM ARNs</a> in the <i>IAM User Guide</i>. This parameter is required if you specify <code>IAM</code> for <code>identityType</code>.</p>
    pub fn iam_arn(&self) -> std::option::Option<& str> {
        self.iam_arn.as_deref()
    }
    /// <p>The token to be used for the next set of paginated results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return for each paginated request.</p> 
    /// <p>Default: 50</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetInterpolatedAssetPropertyValuesInput  {
    /// <p>The ID of the asset.</p>
    #[doc(hidden)]
    pub asset_id: std::option::Option<std::string::String>,
    /// <p>The ID of the asset property.</p>
    #[doc(hidden)]
    pub property_id: std::option::Option<std::string::String>,
    /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub property_alias: std::option::Option<std::string::String>,
    /// <p>The exclusive start of the range from which to interpolate data, expressed in seconds in Unix epoch time.</p>
    #[doc(hidden)]
    pub start_time_in_seconds: std::option::Option<i64>,
    /// <p>The nanosecond offset converted from <code>startTimeInSeconds</code>.</p>
    #[doc(hidden)]
    pub start_time_offset_in_nanos: std::option::Option<i32>,
    /// <p>The inclusive end of the range from which to interpolate data, expressed in seconds in Unix epoch time.</p>
    #[doc(hidden)]
    pub end_time_in_seconds: std::option::Option<i64>,
    /// <p>The nanosecond offset converted from <code>endTimeInSeconds</code>.</p>
    #[doc(hidden)]
    pub end_time_offset_in_nanos: std::option::Option<i32>,
    /// <p>The quality of the asset property value. You can use this parameter as a filter to choose only the asset property values that have a specific quality.</p>
    #[doc(hidden)]
    pub quality: std::option::Option<crate::model::Quality>,
    /// <p>The time interval in seconds over which to interpolate data. Each interval starts when the previous one ends.</p>
    #[doc(hidden)]
    pub interval_in_seconds: std::option::Option<i64>,
    /// <p>The token to be used for the next set of paginated results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return for each paginated request. If not specified, the default value is 10.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The interpolation type.</p> 
    /// <p>Valid values: <code>LINEAR_INTERPOLATION | LOCF_INTERPOLATION</code> </p> 
    /// <ul> 
    /// <li> <p> <code>LINEAR_INTERPOLATION</code>  Estimates missing data using <a href="https://en.wikipedia.org/wiki/Linear_interpolation">linear interpolation</a>.</p> <p>For example, you can use this operation to return the interpolated temperature values for a wind turbine every 24 hours over a duration of 7 days. If the interpolation starts July 1, 2021, at 9 AM, IoT SiteWise returns the first interpolated value on July 2, 2021, at 9 AM, the second interpolated value on July 3, 2021, at 9 AM, and so on.</p> </li> 
    /// <li> <p> <code>LOCF_INTERPOLATION</code>  Estimates missing data using last observation carried forward interpolation</p> <p>If no data point is found for an interval, IoT SiteWise returns the last observed data point for the previous interval and carries forward this interpolated value until a new data point is found.</p> <p>For example, you can get the state of an on-off valve every 24 hours over a duration of 7 days. If the interpolation starts July 1, 2021, at 9 AM, IoT SiteWise returns the last observed data point between July 1, 2021, at 9 AM and July 2, 2021, at 9 AM as the first interpolated value. If a data point isn't found after 9 AM on July 2, 2021, IoT SiteWise uses the same interpolated value for the rest of the days.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The query interval for the window, in seconds. IoT SiteWise computes each interpolated value by using data points from the timestamp of each interval, minus the window to the timestamp of each interval plus the window. If not specified, the window ranges between the start time minus the interval and the end time plus the interval.</p> <note> 
    /// <ul> 
    /// <li> <p>If you specify a value for the <code>intervalWindowInSeconds</code> parameter, the value for the <code>type</code> parameter must be <code>LINEAR_INTERPOLATION</code>.</p> </li> 
    /// <li> <p>If a data point isn't found during the specified query window, IoT SiteWise won't return an interpolated value for the interval. This indicates that there's a gap in the ingested data points.</p> </li> 
    /// </ul> 
    /// </note> 
    /// <p>For example, you can get the interpolated temperature values for a wind turbine every 24 hours over a duration of 7 days. If the interpolation starts on July 1, 2021, at 9 AM with a window of 2 hours, IoT SiteWise uses the data points from 7 AM (9 AM minus 2 hours) to 11 AM (9 AM plus 2 hours) on July 2, 2021 to compute the first interpolated value. Next, IoT SiteWise uses the data points from 7 AM (9 AM minus 2 hours) to 11 AM (9 AM plus 2 hours) on July 3, 2021 to compute the second interpolated value, and so on. </p>
    #[doc(hidden)]
    pub interval_window_in_seconds: std::option::Option<i64>,
}
impl GetInterpolatedAssetPropertyValuesInput {
    /// <p>The ID of the asset.</p>
    pub fn asset_id(&self) -> std::option::Option<& str> {
        self.asset_id.as_deref()
    }
    /// <p>The ID of the asset property.</p>
    pub fn property_id(&self) -> std::option::Option<& str> {
        self.property_id.as_deref()
    }
    /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn property_alias(&self) -> std::option::Option<& str> {
        self.property_alias.as_deref()
    }
    /// <p>The exclusive start of the range from which to interpolate data, expressed in seconds in Unix epoch time.</p>
    pub fn start_time_in_seconds(&self) -> std::option::Option<i64> {
        self.start_time_in_seconds
    }
    /// <p>The nanosecond offset converted from <code>startTimeInSeconds</code>.</p>
    pub fn start_time_offset_in_nanos(&self) -> std::option::Option<i32> {
        self.start_time_offset_in_nanos
    }
    /// <p>The inclusive end of the range from which to interpolate data, expressed in seconds in Unix epoch time.</p>
    pub fn end_time_in_seconds(&self) -> std::option::Option<i64> {
        self.end_time_in_seconds
    }
    /// <p>The nanosecond offset converted from <code>endTimeInSeconds</code>.</p>
    pub fn end_time_offset_in_nanos(&self) -> std::option::Option<i32> {
        self.end_time_offset_in_nanos
    }
    /// <p>The quality of the asset property value. You can use this parameter as a filter to choose only the asset property values that have a specific quality.</p>
    pub fn quality(&self) -> std::option::Option<& crate::model::Quality> {
        self.quality.as_ref()
    }
    /// <p>The time interval in seconds over which to interpolate data. Each interval starts when the previous one ends.</p>
    pub fn interval_in_seconds(&self) -> std::option::Option<i64> {
        self.interval_in_seconds
    }
    /// <p>The token to be used for the next set of paginated results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return for each paginated request. If not specified, the default value is 10.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The interpolation type.</p> 
    /// <p>Valid values: <code>LINEAR_INTERPOLATION | LOCF_INTERPOLATION</code> </p> 
    /// <ul> 
    /// <li> <p> <code>LINEAR_INTERPOLATION</code>  Estimates missing data using <a href="https://en.wikipedia.org/wiki/Linear_interpolation">linear interpolation</a>.</p> <p>For example, you can use this operation to return the interpolated temperature values for a wind turbine every 24 hours over a duration of 7 days. If the interpolation starts July 1, 2021, at 9 AM, IoT SiteWise returns the first interpolated value on July 2, 2021, at 9 AM, the second interpolated value on July 3, 2021, at 9 AM, and so on.</p> </li> 
    /// <li> <p> <code>LOCF_INTERPOLATION</code>  Estimates missing data using last observation carried forward interpolation</p> <p>If no data point is found for an interval, IoT SiteWise returns the last observed data point for the previous interval and carries forward this interpolated value until a new data point is found.</p> <p>For example, you can get the state of an on-off valve every 24 hours over a duration of 7 days. If the interpolation starts July 1, 2021, at 9 AM, IoT SiteWise returns the last observed data point between July 1, 2021, at 9 AM and July 2, 2021, at 9 AM as the first interpolated value. If a data point isn't found after 9 AM on July 2, 2021, IoT SiteWise uses the same interpolated value for the rest of the days.</p> </li> 
    /// </ul>
    pub fn r#type(&self) -> std::option::Option<& str> {
        self.r#type.as_deref()
    }
    /// <p>The query interval for the window, in seconds. IoT SiteWise computes each interpolated value by using data points from the timestamp of each interval, minus the window to the timestamp of each interval plus the window. If not specified, the window ranges between the start time minus the interval and the end time plus the interval.</p> <note> 
    /// <ul> 
    /// <li> <p>If you specify a value for the <code>intervalWindowInSeconds</code> parameter, the value for the <code>type</code> parameter must be <code>LINEAR_INTERPOLATION</code>.</p> </li> 
    /// <li> <p>If a data point isn't found during the specified query window, IoT SiteWise won't return an interpolated value for the interval. This indicates that there's a gap in the ingested data points.</p> </li> 
    /// </ul> 
    /// </note> 
    /// <p>For example, you can get the interpolated temperature values for a wind turbine every 24 hours over a duration of 7 days. If the interpolation starts on July 1, 2021, at 9 AM with a window of 2 hours, IoT SiteWise uses the data points from 7 AM (9 AM minus 2 hours) to 11 AM (9 AM plus 2 hours) on July 2, 2021 to compute the first interpolated value. Next, IoT SiteWise uses the data points from 7 AM (9 AM minus 2 hours) to 11 AM (9 AM plus 2 hours) on July 3, 2021 to compute the second interpolated value, and so on. </p>
    pub fn interval_window_in_seconds(&self) -> std::option::Option<i64> {
        self.interval_window_in_seconds
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetAssetPropertyValueHistoryInput  {
    /// <p>The ID of the asset.</p>
    #[doc(hidden)]
    pub asset_id: std::option::Option<std::string::String>,
    /// <p>The ID of the asset property.</p>
    #[doc(hidden)]
    pub property_id: std::option::Option<std::string::String>,
    /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub property_alias: std::option::Option<std::string::String>,
    /// <p>The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.</p>
    #[doc(hidden)]
    pub start_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.</p>
    #[doc(hidden)]
    pub end_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The quality by which to filter asset data.</p>
    #[doc(hidden)]
    pub qualities: std::option::Option<std::vec::Vec<crate::model::Quality>>,
    /// <p>The chronological sorting order of the requested information.</p> 
    /// <p>Default: <code>ASCENDING</code> </p>
    #[doc(hidden)]
    pub time_ordering: std::option::Option<crate::model::TimeOrdering>,
    /// <p>The token to be used for the next set of paginated results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return for each paginated request.</p> 
    /// <p>Default: 100</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl GetAssetPropertyValueHistoryInput {
    /// <p>The ID of the asset.</p>
    pub fn asset_id(&self) -> std::option::Option<& str> {
        self.asset_id.as_deref()
    }
    /// <p>The ID of the asset property.</p>
    pub fn property_id(&self) -> std::option::Option<& str> {
        self.property_id.as_deref()
    }
    /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn property_alias(&self) -> std::option::Option<& str> {
        self.property_alias.as_deref()
    }
    /// <p>The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.</p>
    pub fn start_date(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.start_date.as_ref()
    }
    /// <p>The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.</p>
    pub fn end_date(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.end_date.as_ref()
    }
    /// <p>The quality by which to filter asset data.</p>
    pub fn qualities(&self) -> std::option::Option<& [crate::model::Quality]> {
        self.qualities.as_deref()
    }
    /// <p>The chronological sorting order of the requested information.</p> 
    /// <p>Default: <code>ASCENDING</code> </p>
    pub fn time_ordering(&self) -> std::option::Option<& crate::model::TimeOrdering> {
        self.time_ordering.as_ref()
    }
    /// <p>The token to be used for the next set of paginated results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return for each paginated request.</p> 
    /// <p>Default: 100</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetAssetPropertyValueInput  {
    /// <p>The ID of the asset.</p>
    #[doc(hidden)]
    pub asset_id: std::option::Option<std::string::String>,
    /// <p>The ID of the asset property.</p>
    #[doc(hidden)]
    pub property_id: std::option::Option<std::string::String>,
    /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub property_alias: std::option::Option<std::string::String>,
}
impl GetAssetPropertyValueInput {
    /// <p>The ID of the asset.</p>
    pub fn asset_id(&self) -> std::option::Option<& str> {
        self.asset_id.as_deref()
    }
    /// <p>The ID of the asset property.</p>
    pub fn property_id(&self) -> std::option::Option<& str> {
        self.property_id.as_deref()
    }
    /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn property_alias(&self) -> std::option::Option<& str> {
        self.property_alias.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetAssetPropertyAggregatesInput  {
    /// <p>The ID of the asset.</p>
    #[doc(hidden)]
    pub asset_id: std::option::Option<std::string::String>,
    /// <p>The ID of the asset property.</p>
    #[doc(hidden)]
    pub property_id: std::option::Option<std::string::String>,
    /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub property_alias: std::option::Option<std::string::String>,
    /// <p>The data aggregating function.</p>
    #[doc(hidden)]
    pub aggregate_types: std::option::Option<std::vec::Vec<crate::model::AggregateType>>,
    /// <p>The time interval over which to aggregate data.</p>
    #[doc(hidden)]
    pub resolution: std::option::Option<std::string::String>,
    /// <p>The quality by which to filter asset data.</p>
    #[doc(hidden)]
    pub qualities: std::option::Option<std::vec::Vec<crate::model::Quality>>,
    /// <p>The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.</p>
    #[doc(hidden)]
    pub start_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.</p>
    #[doc(hidden)]
    pub end_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The chronological sorting order of the requested information.</p> 
    /// <p>Default: <code>ASCENDING</code> </p>
    #[doc(hidden)]
    pub time_ordering: std::option::Option<crate::model::TimeOrdering>,
    /// <p>The token to be used for the next set of paginated results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return for each paginated request.</p> 
    /// <p>Default: 100</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl GetAssetPropertyAggregatesInput {
    /// <p>The ID of the asset.</p>
    pub fn asset_id(&self) -> std::option::Option<& str> {
        self.asset_id.as_deref()
    }
    /// <p>The ID of the asset property.</p>
    pub fn property_id(&self) -> std::option::Option<& str> {
        self.property_id.as_deref()
    }
    /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn property_alias(&self) -> std::option::Option<& str> {
        self.property_alias.as_deref()
    }
    /// <p>The data aggregating function.</p>
    pub fn aggregate_types(&self) -> std::option::Option<& [crate::model::AggregateType]> {
        self.aggregate_types.as_deref()
    }
    /// <p>The time interval over which to aggregate data.</p>
    pub fn resolution(&self) -> std::option::Option<& str> {
        self.resolution.as_deref()
    }
    /// <p>The quality by which to filter asset data.</p>
    pub fn qualities(&self) -> std::option::Option<& [crate::model::Quality]> {
        self.qualities.as_deref()
    }
    /// <p>The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.</p>
    pub fn start_date(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.start_date.as_ref()
    }
    /// <p>The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.</p>
    pub fn end_date(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.end_date.as_ref()
    }
    /// <p>The chronological sorting order of the requested information.</p> 
    /// <p>Default: <code>ASCENDING</code> </p>
    pub fn time_ordering(&self) -> std::option::Option<& crate::model::TimeOrdering> {
        self.time_ordering.as_ref()
    }
    /// <p>The token to be used for the next set of paginated results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return for each paginated request.</p> 
    /// <p>Default: 100</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DisassociateTimeSeriesFromAssetPropertyInput  {
    /// <p>The alias that identifies the time series.</p>
    #[doc(hidden)]
    pub alias: std::option::Option<std::string::String>,
    /// <p>The ID of the asset in which the asset property was created.</p>
    #[doc(hidden)]
    pub asset_id: std::option::Option<std::string::String>,
    /// <p>The ID of the asset property.</p>
    #[doc(hidden)]
    pub property_id: std::option::Option<std::string::String>,
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl DisassociateTimeSeriesFromAssetPropertyInput {
    /// <p>The alias that identifies the time series.</p>
    pub fn alias(&self) -> std::option::Option<& str> {
        self.alias.as_deref()
    }
    /// <p>The ID of the asset in which the asset property was created.</p>
    pub fn asset_id(&self) -> std::option::Option<& str> {
        self.asset_id.as_deref()
    }
    /// <p>The ID of the asset property.</p>
    pub fn property_id(&self) -> std::option::Option<& str> {
        self.property_id.as_deref()
    }
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DisassociateAssetsInput  {
    /// <p>The ID of the parent asset from which to disassociate the child asset.</p>
    #[doc(hidden)]
    pub asset_id: std::option::Option<std::string::String>,
    /// <p>The ID of a hierarchy in the parent asset's model. Hierarchies allow different groupings of assets to be formed that all come from the same asset model. You can use the hierarchy ID to identify the correct asset to disassociate. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html">Asset hierarchies</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub hierarchy_id: std::option::Option<std::string::String>,
    /// <p>The ID of the child asset to disassociate.</p>
    #[doc(hidden)]
    pub child_asset_id: std::option::Option<std::string::String>,
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl DisassociateAssetsInput {
    /// <p>The ID of the parent asset from which to disassociate the child asset.</p>
    pub fn asset_id(&self) -> std::option::Option<& str> {
        self.asset_id.as_deref()
    }
    /// <p>The ID of a hierarchy in the parent asset's model. Hierarchies allow different groupings of assets to be formed that all come from the same asset model. You can use the hierarchy ID to identify the correct asset to disassociate. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html">Asset hierarchies</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn hierarchy_id(&self) -> std::option::Option<& str> {
        self.hierarchy_id.as_deref()
    }
    /// <p>The ID of the child asset to disassociate.</p>
    pub fn child_asset_id(&self) -> std::option::Option<& str> {
        self.child_asset_id.as_deref()
    }
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeTimeSeriesInput  {
    /// <p>The alias that identifies the time series.</p>
    #[doc(hidden)]
    pub alias: std::option::Option<std::string::String>,
    /// <p>The ID of the asset in which the asset property was created.</p>
    #[doc(hidden)]
    pub asset_id: std::option::Option<std::string::String>,
    /// <p>The ID of the asset property.</p>
    #[doc(hidden)]
    pub property_id: std::option::Option<std::string::String>,
}
impl DescribeTimeSeriesInput {
    /// <p>The alias that identifies the time series.</p>
    pub fn alias(&self) -> std::option::Option<& str> {
        self.alias.as_deref()
    }
    /// <p>The ID of the asset in which the asset property was created.</p>
    pub fn asset_id(&self) -> std::option::Option<& str> {
        self.asset_id.as_deref()
    }
    /// <p>The ID of the asset property.</p>
    pub fn property_id(&self) -> std::option::Option<& str> {
        self.property_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeStorageConfigurationInput  {
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeProjectInput  {
    /// <p>The ID of the project.</p>
    #[doc(hidden)]
    pub project_id: std::option::Option<std::string::String>,
}
impl DescribeProjectInput {
    /// <p>The ID of the project.</p>
    pub fn project_id(&self) -> std::option::Option<& str> {
        self.project_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribePortalInput  {
    /// <p>The ID of the portal.</p>
    #[doc(hidden)]
    pub portal_id: std::option::Option<std::string::String>,
}
impl DescribePortalInput {
    /// <p>The ID of the portal.</p>
    pub fn portal_id(&self) -> std::option::Option<& str> {
        self.portal_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeLoggingOptionsInput  {
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeGatewayCapabilityConfigurationInput  {
    /// <p>The ID of the gateway that defines the capability configuration.</p>
    #[doc(hidden)]
    pub gateway_id: std::option::Option<std::string::String>,
    /// <p>The namespace of the capability configuration. For example, if you configure OPC-UA sources from the IoT SiteWise console, your OPC-UA capability configuration has the namespace <code>iotsitewise:opcuacollector:version</code>, where <code>version</code> is a number such as <code>1</code>.</p>
    #[doc(hidden)]
    pub capability_namespace: std::option::Option<std::string::String>,
}
impl DescribeGatewayCapabilityConfigurationInput {
    /// <p>The ID of the gateway that defines the capability configuration.</p>
    pub fn gateway_id(&self) -> std::option::Option<& str> {
        self.gateway_id.as_deref()
    }
    /// <p>The namespace of the capability configuration. For example, if you configure OPC-UA sources from the IoT SiteWise console, your OPC-UA capability configuration has the namespace <code>iotsitewise:opcuacollector:version</code>, where <code>version</code> is a number such as <code>1</code>.</p>
    pub fn capability_namespace(&self) -> std::option::Option<& str> {
        self.capability_namespace.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeGatewayInput  {
    /// <p>The ID of the gateway device.</p>
    #[doc(hidden)]
    pub gateway_id: std::option::Option<std::string::String>,
}
impl DescribeGatewayInput {
    /// <p>The ID of the gateway device.</p>
    pub fn gateway_id(&self) -> std::option::Option<& str> {
        self.gateway_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeDefaultEncryptionConfigurationInput  {
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeDashboardInput  {
    /// <p>The ID of the dashboard.</p>
    #[doc(hidden)]
    pub dashboard_id: std::option::Option<std::string::String>,
}
impl DescribeDashboardInput {
    /// <p>The ID of the dashboard.</p>
    pub fn dashboard_id(&self) -> std::option::Option<& str> {
        self.dashboard_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeBulkImportJobInput  {
    /// <p>The ID of the job.</p>
    #[doc(hidden)]
    pub job_id: std::option::Option<std::string::String>,
}
impl DescribeBulkImportJobInput {
    /// <p>The ID of the job.</p>
    pub fn job_id(&self) -> std::option::Option<& str> {
        self.job_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeAssetPropertyInput  {
    /// <p>The ID of the asset.</p>
    #[doc(hidden)]
    pub asset_id: std::option::Option<std::string::String>,
    /// <p>The ID of the asset property.</p>
    #[doc(hidden)]
    pub property_id: std::option::Option<std::string::String>,
}
impl DescribeAssetPropertyInput {
    /// <p>The ID of the asset.</p>
    pub fn asset_id(&self) -> std::option::Option<& str> {
        self.asset_id.as_deref()
    }
    /// <p>The ID of the asset property.</p>
    pub fn property_id(&self) -> std::option::Option<& str> {
        self.property_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeAssetModelInput  {
    /// <p>The ID of the asset model.</p>
    #[doc(hidden)]
    pub asset_model_id: std::option::Option<std::string::String>,
    /// <p> Whether or not to exclude asset model properties from the response. </p>
    #[doc(hidden)]
    pub exclude_properties: bool,
}
impl DescribeAssetModelInput {
    /// <p>The ID of the asset model.</p>
    pub fn asset_model_id(&self) -> std::option::Option<& str> {
        self.asset_model_id.as_deref()
    }
    /// <p> Whether or not to exclude asset model properties from the response. </p>
    pub fn exclude_properties(&self) -> bool {
        self.exclude_properties
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeAssetInput  {
    /// <p>The ID of the asset.</p>
    #[doc(hidden)]
    pub asset_id: std::option::Option<std::string::String>,
    /// <p> Whether or not to exclude asset properties from the response. </p>
    #[doc(hidden)]
    pub exclude_properties: bool,
}
impl DescribeAssetInput {
    /// <p>The ID of the asset.</p>
    pub fn asset_id(&self) -> std::option::Option<& str> {
        self.asset_id.as_deref()
    }
    /// <p> Whether or not to exclude asset properties from the response. </p>
    pub fn exclude_properties(&self) -> bool {
        self.exclude_properties
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeAccessPolicyInput  {
    /// <p>The ID of the access policy.</p>
    #[doc(hidden)]
    pub access_policy_id: std::option::Option<std::string::String>,
}
impl DescribeAccessPolicyInput {
    /// <p>The ID of the access policy.</p>
    pub fn access_policy_id(&self) -> std::option::Option<& str> {
        self.access_policy_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteTimeSeriesInput  {
    /// <p>The alias that identifies the time series.</p>
    #[doc(hidden)]
    pub alias: std::option::Option<std::string::String>,
    /// <p>The ID of the asset in which the asset property was created.</p>
    #[doc(hidden)]
    pub asset_id: std::option::Option<std::string::String>,
    /// <p>The ID of the asset property.</p>
    #[doc(hidden)]
    pub property_id: std::option::Option<std::string::String>,
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl DeleteTimeSeriesInput {
    /// <p>The alias that identifies the time series.</p>
    pub fn alias(&self) -> std::option::Option<& str> {
        self.alias.as_deref()
    }
    /// <p>The ID of the asset in which the asset property was created.</p>
    pub fn asset_id(&self) -> std::option::Option<& str> {
        self.asset_id.as_deref()
    }
    /// <p>The ID of the asset property.</p>
    pub fn property_id(&self) -> std::option::Option<& str> {
        self.property_id.as_deref()
    }
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteProjectInput  {
    /// <p>The ID of the project.</p>
    #[doc(hidden)]
    pub project_id: std::option::Option<std::string::String>,
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl DeleteProjectInput {
    /// <p>The ID of the project.</p>
    pub fn project_id(&self) -> std::option::Option<& str> {
        self.project_id.as_deref()
    }
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeletePortalInput  {
    /// <p>The ID of the portal to delete.</p>
    #[doc(hidden)]
    pub portal_id: std::option::Option<std::string::String>,
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl DeletePortalInput {
    /// <p>The ID of the portal to delete.</p>
    pub fn portal_id(&self) -> std::option::Option<& str> {
        self.portal_id.as_deref()
    }
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteGatewayInput  {
    /// <p>The ID of the gateway to delete.</p>
    #[doc(hidden)]
    pub gateway_id: std::option::Option<std::string::String>,
}
impl DeleteGatewayInput {
    /// <p>The ID of the gateway to delete.</p>
    pub fn gateway_id(&self) -> std::option::Option<& str> {
        self.gateway_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteDashboardInput  {
    /// <p>The ID of the dashboard to delete.</p>
    #[doc(hidden)]
    pub dashboard_id: std::option::Option<std::string::String>,
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl DeleteDashboardInput {
    /// <p>The ID of the dashboard to delete.</p>
    pub fn dashboard_id(&self) -> std::option::Option<& str> {
        self.dashboard_id.as_deref()
    }
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteAssetModelInput  {
    /// <p>The ID of the asset model to delete.</p>
    #[doc(hidden)]
    pub asset_model_id: std::option::Option<std::string::String>,
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl DeleteAssetModelInput {
    /// <p>The ID of the asset model to delete.</p>
    pub fn asset_model_id(&self) -> std::option::Option<& str> {
        self.asset_model_id.as_deref()
    }
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteAssetInput  {
    /// <p>The ID of the asset to delete.</p>
    #[doc(hidden)]
    pub asset_id: std::option::Option<std::string::String>,
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl DeleteAssetInput {
    /// <p>The ID of the asset to delete.</p>
    pub fn asset_id(&self) -> std::option::Option<& str> {
        self.asset_id.as_deref()
    }
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteAccessPolicyInput  {
    /// <p>The ID of the access policy to be deleted.</p>
    #[doc(hidden)]
    pub access_policy_id: std::option::Option<std::string::String>,
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl DeleteAccessPolicyInput {
    /// <p>The ID of the access policy to be deleted.</p>
    pub fn access_policy_id(&self) -> std::option::Option<& str> {
        self.access_policy_id.as_deref()
    }
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateProjectInput  {
    /// <p>The ID of the portal in which to create the project.</p>
    #[doc(hidden)]
    pub portal_id: std::option::Option<std::string::String>,
    /// <p>A friendly name for the project.</p>
    #[doc(hidden)]
    pub project_name: std::option::Option<std::string::String>,
    /// <p>A description for the project.</p>
    #[doc(hidden)]
    pub project_description: std::option::Option<std::string::String>,
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
    /// <p>A list of key-value pairs that contain metadata for the project. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise resources</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateProjectInput {
    /// <p>The ID of the portal in which to create the project.</p>
    pub fn portal_id(&self) -> std::option::Option<& str> {
        self.portal_id.as_deref()
    }
    /// <p>A friendly name for the project.</p>
    pub fn project_name(&self) -> std::option::Option<& str> {
        self.project_name.as_deref()
    }
    /// <p>A description for the project.</p>
    pub fn project_description(&self) -> std::option::Option<& str> {
        self.project_description.as_deref()
    }
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
    /// <p>A list of key-value pairs that contain metadata for the project. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise resources</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreatePortalInput  {
    /// <p>A friendly name for the portal.</p>
    #[doc(hidden)]
    pub portal_name: std::option::Option<std::string::String>,
    /// <p>A description for the portal.</p>
    #[doc(hidden)]
    pub portal_description: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services administrator's contact email address.</p>
    #[doc(hidden)]
    pub portal_contact_email: std::option::Option<std::string::String>,
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
    /// <p>A logo image to display in the portal. Upload a square, high-resolution image. The image is displayed on a dark background.</p>
    #[doc(hidden)]
    pub portal_logo_image_file: std::option::Option<crate::model::ImageFile>,
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of a service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-service-role.html">Using service roles for IoT SiteWise Monitor</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>A list of key-value pairs that contain metadata for the portal. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise resources</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The service to use to authenticate users to the portal. Choose from the following options:</p> 
    /// <ul> 
    /// <li> <p> <code>SSO</code>  The portal uses IAM Identity Center (successor to Single Sign-On) to authenticate users and manage user permissions. Before you can create a portal that uses IAM Identity Center, you must enable IAM Identity Center. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-get-started.html#mon-gs-sso">Enabling IAM Identity Center</a> in the <i>IoT SiteWise User Guide</i>. This option is only available in Amazon Web Services Regions other than the China Regions.</p> </li> 
    /// <li> <p> <code>IAM</code>  The portal uses Identity and Access Management to authenticate users and manage user permissions.</p> </li> 
    /// </ul> 
    /// <p>You can't change this value after you create a portal.</p> 
    /// <p>Default: <code>SSO</code> </p>
    #[doc(hidden)]
    pub portal_auth_mode: std::option::Option<crate::model::AuthMode>,
    /// <p>The email address that sends alarm notifications.</p> <important> 
    /// <p>If you use the <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/lambda-support.html">IoT Events managed Lambda function</a> to manage your emails, you must <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-email-addresses.html">verify the sender email address in Amazon SES</a>.</p> 
    /// </important>
    #[doc(hidden)]
    pub notification_sender_email: std::option::Option<std::string::String>,
    /// <p>Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal. You can use the alarm to monitor an asset property and get notified when the asset property value is outside a specified range. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/appguide/monitor-alarms.html">Monitoring with alarms</a> in the <i>IoT SiteWise Application Guide</i>.</p>
    #[doc(hidden)]
    pub alarms: std::option::Option<crate::model::Alarms>,
}
impl CreatePortalInput {
    /// <p>A friendly name for the portal.</p>
    pub fn portal_name(&self) -> std::option::Option<& str> {
        self.portal_name.as_deref()
    }
    /// <p>A description for the portal.</p>
    pub fn portal_description(&self) -> std::option::Option<& str> {
        self.portal_description.as_deref()
    }
    /// <p>The Amazon Web Services administrator's contact email address.</p>
    pub fn portal_contact_email(&self) -> std::option::Option<& str> {
        self.portal_contact_email.as_deref()
    }
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
    /// <p>A logo image to display in the portal. Upload a square, high-resolution image. The image is displayed on a dark background.</p>
    pub fn portal_logo_image_file(&self) -> std::option::Option<& crate::model::ImageFile> {
        self.portal_logo_image_file.as_ref()
    }
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of a service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-service-role.html">Using service roles for IoT SiteWise Monitor</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn role_arn(&self) -> std::option::Option<& str> {
        self.role_arn.as_deref()
    }
    /// <p>A list of key-value pairs that contain metadata for the portal. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise resources</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
    /// <p>The service to use to authenticate users to the portal. Choose from the following options:</p> 
    /// <ul> 
    /// <li> <p> <code>SSO</code>  The portal uses IAM Identity Center (successor to Single Sign-On) to authenticate users and manage user permissions. Before you can create a portal that uses IAM Identity Center, you must enable IAM Identity Center. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-get-started.html#mon-gs-sso">Enabling IAM Identity Center</a> in the <i>IoT SiteWise User Guide</i>. This option is only available in Amazon Web Services Regions other than the China Regions.</p> </li> 
    /// <li> <p> <code>IAM</code>  The portal uses Identity and Access Management to authenticate users and manage user permissions.</p> </li> 
    /// </ul> 
    /// <p>You can't change this value after you create a portal.</p> 
    /// <p>Default: <code>SSO</code> </p>
    pub fn portal_auth_mode(&self) -> std::option::Option<& crate::model::AuthMode> {
        self.portal_auth_mode.as_ref()
    }
    /// <p>The email address that sends alarm notifications.</p> <important> 
    /// <p>If you use the <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/lambda-support.html">IoT Events managed Lambda function</a> to manage your emails, you must <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-email-addresses.html">verify the sender email address in Amazon SES</a>.</p> 
    /// </important>
    pub fn notification_sender_email(&self) -> std::option::Option<& str> {
        self.notification_sender_email.as_deref()
    }
    /// <p>Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal. You can use the alarm to monitor an asset property and get notified when the asset property value is outside a specified range. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/appguide/monitor-alarms.html">Monitoring with alarms</a> in the <i>IoT SiteWise Application Guide</i>.</p>
    pub fn alarms(&self) -> std::option::Option<& crate::model::Alarms> {
        self.alarms.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateGatewayInput  {
    /// <p>A unique, friendly name for the gateway.</p>
    #[doc(hidden)]
    pub gateway_name: std::option::Option<std::string::String>,
    /// <p>The gateway's platform. You can only specify one platform in a gateway.</p>
    #[doc(hidden)]
    pub gateway_platform: std::option::Option<crate::model::GatewayPlatform>,
    /// <p>A list of key-value pairs that contain metadata for the gateway. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise resources</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateGatewayInput {
    /// <p>A unique, friendly name for the gateway.</p>
    pub fn gateway_name(&self) -> std::option::Option<& str> {
        self.gateway_name.as_deref()
    }
    /// <p>The gateway's platform. You can only specify one platform in a gateway.</p>
    pub fn gateway_platform(&self) -> std::option::Option<& crate::model::GatewayPlatform> {
        self.gateway_platform.as_ref()
    }
    /// <p>A list of key-value pairs that contain metadata for the gateway. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise resources</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateDashboardInput  {
    /// <p>The ID of the project in which to create the dashboard.</p>
    #[doc(hidden)]
    pub project_id: std::option::Option<std::string::String>,
    /// <p>A friendly name for the dashboard.</p>
    #[doc(hidden)]
    pub dashboard_name: std::option::Option<std::string::String>,
    /// <p>A description for the dashboard.</p>
    #[doc(hidden)]
    pub dashboard_description: std::option::Option<std::string::String>,
    /// <p>The dashboard definition specified in a JSON literal. For detailed information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/create-dashboards-using-aws-cli.html">Creating dashboards (CLI)</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub dashboard_definition: std::option::Option<std::string::String>,
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
    /// <p>A list of key-value pairs that contain metadata for the dashboard. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise resources</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateDashboardInput {
    /// <p>The ID of the project in which to create the dashboard.</p>
    pub fn project_id(&self) -> std::option::Option<& str> {
        self.project_id.as_deref()
    }
    /// <p>A friendly name for the dashboard.</p>
    pub fn dashboard_name(&self) -> std::option::Option<& str> {
        self.dashboard_name.as_deref()
    }
    /// <p>A description for the dashboard.</p>
    pub fn dashboard_description(&self) -> std::option::Option<& str> {
        self.dashboard_description.as_deref()
    }
    /// <p>The dashboard definition specified in a JSON literal. For detailed information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/create-dashboards-using-aws-cli.html">Creating dashboards (CLI)</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn dashboard_definition(&self) -> std::option::Option<& str> {
        self.dashboard_definition.as_deref()
    }
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
    /// <p>A list of key-value pairs that contain metadata for the dashboard. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise resources</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateBulkImportJobInput  {
    /// <p>The unique name that helps identify the job request.</p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the IAM role that allows IoT SiteWise to read Amazon S3 data.</p>
    #[doc(hidden)]
    pub job_role_arn: std::option::Option<std::string::String>,
    /// <p>The files in the specified Amazon S3 bucket that contain your data.</p>
    #[doc(hidden)]
    pub files: std::option::Option<std::vec::Vec<crate::model::File>>,
    /// <p>The Amazon S3 destination where errors associated with the job creation request are saved.</p>
    #[doc(hidden)]
    pub error_report_location: std::option::Option<crate::model::ErrorReportLocation>,
    /// <p>Contains the configuration information of a job, such as the file format used to save data in Amazon S3.</p>
    #[doc(hidden)]
    pub job_configuration: std::option::Option<crate::model::JobConfiguration>,
}
impl CreateBulkImportJobInput {
    /// <p>The unique name that helps identify the job request.</p>
    pub fn job_name(&self) -> std::option::Option<& str> {
        self.job_name.as_deref()
    }
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the IAM role that allows IoT SiteWise to read Amazon S3 data.</p>
    pub fn job_role_arn(&self) -> std::option::Option<& str> {
        self.job_role_arn.as_deref()
    }
    /// <p>The files in the specified Amazon S3 bucket that contain your data.</p>
    pub fn files(&self) -> std::option::Option<& [crate::model::File]> {
        self.files.as_deref()
    }
    /// <p>The Amazon S3 destination where errors associated with the job creation request are saved.</p>
    pub fn error_report_location(&self) -> std::option::Option<& crate::model::ErrorReportLocation> {
        self.error_report_location.as_ref()
    }
    /// <p>Contains the configuration information of a job, such as the file format used to save data in Amazon S3.</p>
    pub fn job_configuration(&self) -> std::option::Option<& crate::model::JobConfiguration> {
        self.job_configuration.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateAssetModelInput  {
    /// <p>A unique, friendly name for the asset model.</p>
    #[doc(hidden)]
    pub asset_model_name: std::option::Option<std::string::String>,
    /// <p>A description for the asset model.</p>
    #[doc(hidden)]
    pub asset_model_description: std::option::Option<std::string::String>,
    /// <p>The property definitions of the asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html">Asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p> 
    /// <p>You can specify up to 200 properties per asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub asset_model_properties: std::option::Option<std::vec::Vec<crate::model::AssetModelPropertyDefinition>>,
    /// <p>The hierarchy definitions of the asset model. Each hierarchy specifies an asset model whose assets can be children of any other assets created from this asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html">Asset hierarchies</a> in the <i>IoT SiteWise User Guide</i>.</p> 
    /// <p>You can specify up to 10 hierarchies per asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub asset_model_hierarchies: std::option::Option<std::vec::Vec<crate::model::AssetModelHierarchyDefinition>>,
    /// <p>The composite asset models that are part of this asset model. Composite asset models are asset models that contain specific properties. Each composite model has a type that defines the properties that the composite model supports. Use composite asset models to define alarms on this asset model.</p>
    #[doc(hidden)]
    pub asset_model_composite_models: std::option::Option<std::vec::Vec<crate::model::AssetModelCompositeModelDefinition>>,
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
    /// <p>A list of key-value pairs that contain metadata for the asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise resources</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateAssetModelInput {
    /// <p>A unique, friendly name for the asset model.</p>
    pub fn asset_model_name(&self) -> std::option::Option<& str> {
        self.asset_model_name.as_deref()
    }
    /// <p>A description for the asset model.</p>
    pub fn asset_model_description(&self) -> std::option::Option<& str> {
        self.asset_model_description.as_deref()
    }
    /// <p>The property definitions of the asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html">Asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p> 
    /// <p>You can specify up to 200 properties per asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn asset_model_properties(&self) -> std::option::Option<& [crate::model::AssetModelPropertyDefinition]> {
        self.asset_model_properties.as_deref()
    }
    /// <p>The hierarchy definitions of the asset model. Each hierarchy specifies an asset model whose assets can be children of any other assets created from this asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html">Asset hierarchies</a> in the <i>IoT SiteWise User Guide</i>.</p> 
    /// <p>You can specify up to 10 hierarchies per asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn asset_model_hierarchies(&self) -> std::option::Option<& [crate::model::AssetModelHierarchyDefinition]> {
        self.asset_model_hierarchies.as_deref()
    }
    /// <p>The composite asset models that are part of this asset model. Composite asset models are asset models that contain specific properties. Each composite model has a type that defines the properties that the composite model supports. Use composite asset models to define alarms on this asset model.</p>
    pub fn asset_model_composite_models(&self) -> std::option::Option<& [crate::model::AssetModelCompositeModelDefinition]> {
        self.asset_model_composite_models.as_deref()
    }
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
    /// <p>A list of key-value pairs that contain metadata for the asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise resources</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateAssetInput  {
    /// <p>A friendly name for the asset.</p>
    #[doc(hidden)]
    pub asset_name: std::option::Option<std::string::String>,
    /// <p>The ID of the asset model from which to create the asset.</p>
    #[doc(hidden)]
    pub asset_model_id: std::option::Option<std::string::String>,
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
    /// <p>A list of key-value pairs that contain metadata for the asset. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise resources</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A description for the asset.</p>
    #[doc(hidden)]
    pub asset_description: std::option::Option<std::string::String>,
}
impl CreateAssetInput {
    /// <p>A friendly name for the asset.</p>
    pub fn asset_name(&self) -> std::option::Option<& str> {
        self.asset_name.as_deref()
    }
    /// <p>The ID of the asset model from which to create the asset.</p>
    pub fn asset_model_id(&self) -> std::option::Option<& str> {
        self.asset_model_id.as_deref()
    }
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
    /// <p>A list of key-value pairs that contain metadata for the asset. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise resources</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
    /// <p>A description for the asset.</p>
    pub fn asset_description(&self) -> std::option::Option<& str> {
        self.asset_description.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateAccessPolicyInput  {
    /// <p>The identity for this access policy. Choose an IAM Identity Center user, an IAM Identity Center group, or an IAM user.</p>
    #[doc(hidden)]
    pub access_policy_identity: std::option::Option<crate::model::Identity>,
    /// <p>The IoT SiteWise Monitor resource for this access policy. Choose either a portal or a project.</p>
    #[doc(hidden)]
    pub access_policy_resource: std::option::Option<crate::model::Resource>,
    /// <p>The permission level for this access policy. Note that a project <code>ADMINISTRATOR</code> is also known as a project owner.</p>
    #[doc(hidden)]
    pub access_policy_permission: std::option::Option<crate::model::Permission>,
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
    /// <p>A list of key-value pairs that contain metadata for the access policy. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise resources</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateAccessPolicyInput {
    /// <p>The identity for this access policy. Choose an IAM Identity Center user, an IAM Identity Center group, or an IAM user.</p>
    pub fn access_policy_identity(&self) -> std::option::Option<& crate::model::Identity> {
        self.access_policy_identity.as_ref()
    }
    /// <p>The IoT SiteWise Monitor resource for this access policy. Choose either a portal or a project.</p>
    pub fn access_policy_resource(&self) -> std::option::Option<& crate::model::Resource> {
        self.access_policy_resource.as_ref()
    }
    /// <p>The permission level for this access policy. Note that a project <code>ADMINISTRATOR</code> is also known as a project owner.</p>
    pub fn access_policy_permission(&self) -> std::option::Option<& crate::model::Permission> {
        self.access_policy_permission.as_ref()
    }
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
    /// <p>A list of key-value pairs that contain metadata for the access policy. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise resources</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchPutAssetPropertyValueInput  {
    /// <p>The list of asset property value entries for the batch put request. You can specify up to 10 entries per request.</p>
    #[doc(hidden)]
    pub entries: std::option::Option<std::vec::Vec<crate::model::PutAssetPropertyValueEntry>>,
}
impl BatchPutAssetPropertyValueInput {
    /// <p>The list of asset property value entries for the batch put request. You can specify up to 10 entries per request.</p>
    pub fn entries(&self) -> std::option::Option<& [crate::model::PutAssetPropertyValueEntry]> {
        self.entries.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchGetAssetPropertyValueHistoryInput  {
    /// <p>The list of asset property historical value entries for the batch get request. You can specify up to 16 entries per request.</p>
    #[doc(hidden)]
    pub entries: std::option::Option<std::vec::Vec<crate::model::BatchGetAssetPropertyValueHistoryEntry>>,
    /// <p>The token to be used for the next set of paginated results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return for each paginated request. A result set is returned in the two cases, whichever occurs first.</p> 
    /// <ul> 
    /// <li> <p>The size of the result set is less than 1 MB.</p> </li> 
    /// <li> <p>The number of data points in the result set is less than the value of <code>maxResults</code>. The maximum value of <code>maxResults</code> is 4000.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl BatchGetAssetPropertyValueHistoryInput {
    /// <p>The list of asset property historical value entries for the batch get request. You can specify up to 16 entries per request.</p>
    pub fn entries(&self) -> std::option::Option<& [crate::model::BatchGetAssetPropertyValueHistoryEntry]> {
        self.entries.as_deref()
    }
    /// <p>The token to be used for the next set of paginated results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return for each paginated request. A result set is returned in the two cases, whichever occurs first.</p> 
    /// <ul> 
    /// <li> <p>The size of the result set is less than 1 MB.</p> </li> 
    /// <li> <p>The number of data points in the result set is less than the value of <code>maxResults</code>. The maximum value of <code>maxResults</code> is 4000.</p> </li> 
    /// </ul>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchGetAssetPropertyValueInput  {
    /// <p>The list of asset property value entries for the batch get request. You can specify up to 16 entries per request.</p>
    #[doc(hidden)]
    pub entries: std::option::Option<std::vec::Vec<crate::model::BatchGetAssetPropertyValueEntry>>,
    /// <p>The token to be used for the next set of paginated results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl BatchGetAssetPropertyValueInput {
    /// <p>The list of asset property value entries for the batch get request. You can specify up to 16 entries per request.</p>
    pub fn entries(&self) -> std::option::Option<& [crate::model::BatchGetAssetPropertyValueEntry]> {
        self.entries.as_deref()
    }
    /// <p>The token to be used for the next set of paginated results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchGetAssetPropertyAggregatesInput  {
    /// <p>The list of asset property aggregate entries for the batch get request. You can specify up to 16 entries per request.</p>
    #[doc(hidden)]
    pub entries: std::option::Option<std::vec::Vec<crate::model::BatchGetAssetPropertyAggregatesEntry>>,
    /// <p>The token to be used for the next set of paginated results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return for each paginated request. A result set is returned in the two cases, whichever occurs first.</p> 
    /// <ul> 
    /// <li> <p>The size of the result set is less than 1 MB.</p> </li> 
    /// <li> <p>The number of data points in the result set is less than the value of <code>maxResults</code>. The maximum value of <code>maxResults</code> is 4000.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl BatchGetAssetPropertyAggregatesInput {
    /// <p>The list of asset property aggregate entries for the batch get request. You can specify up to 16 entries per request.</p>
    pub fn entries(&self) -> std::option::Option<& [crate::model::BatchGetAssetPropertyAggregatesEntry]> {
        self.entries.as_deref()
    }
    /// <p>The token to be used for the next set of paginated results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return for each paginated request. A result set is returned in the two cases, whichever occurs first.</p> 
    /// <ul> 
    /// <li> <p>The size of the result set is less than 1 MB.</p> </li> 
    /// <li> <p>The number of data points in the result set is less than the value of <code>maxResults</code>. The maximum value of <code>maxResults</code> is 4000.</p> </li> 
    /// </ul>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchDisassociateProjectAssetsInput  {
    /// <p>The ID of the project from which to disassociate the assets.</p>
    #[doc(hidden)]
    pub project_id: std::option::Option<std::string::String>,
    /// <p>The IDs of the assets to be disassociated from the project.</p>
    #[doc(hidden)]
    pub asset_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl BatchDisassociateProjectAssetsInput {
    /// <p>The ID of the project from which to disassociate the assets.</p>
    pub fn project_id(&self) -> std::option::Option<& str> {
        self.project_id.as_deref()
    }
    /// <p>The IDs of the assets to be disassociated from the project.</p>
    pub fn asset_ids(&self) -> std::option::Option<& [std::string::String]> {
        self.asset_ids.as_deref()
    }
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchAssociateProjectAssetsInput  {
    /// <p>The ID of the project to which to associate the assets.</p>
    #[doc(hidden)]
    pub project_id: std::option::Option<std::string::String>,
    /// <p>The IDs of the assets to be associated to the project.</p>
    #[doc(hidden)]
    pub asset_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl BatchAssociateProjectAssetsInput {
    /// <p>The ID of the project to which to associate the assets.</p>
    pub fn project_id(&self) -> std::option::Option<& str> {
        self.project_id.as_deref()
    }
    /// <p>The IDs of the assets to be associated to the project.</p>
    pub fn asset_ids(&self) -> std::option::Option<& [std::string::String]> {
        self.asset_ids.as_deref()
    }
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssociateTimeSeriesToAssetPropertyInput  {
    /// <p>The alias that identifies the time series.</p>
    #[doc(hidden)]
    pub alias: std::option::Option<std::string::String>,
    /// <p>The ID of the asset in which the asset property was created.</p>
    #[doc(hidden)]
    pub asset_id: std::option::Option<std::string::String>,
    /// <p>The ID of the asset property.</p>
    #[doc(hidden)]
    pub property_id: std::option::Option<std::string::String>,
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl AssociateTimeSeriesToAssetPropertyInput {
    /// <p>The alias that identifies the time series.</p>
    pub fn alias(&self) -> std::option::Option<& str> {
        self.alias.as_deref()
    }
    /// <p>The ID of the asset in which the asset property was created.</p>
    pub fn asset_id(&self) -> std::option::Option<& str> {
        self.asset_id.as_deref()
    }
    /// <p>The ID of the asset property.</p>
    pub fn property_id(&self) -> std::option::Option<& str> {
        self.property_id.as_deref()
    }
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssociateAssetsInput  {
    /// <p>The ID of the parent asset.</p>
    #[doc(hidden)]
    pub asset_id: std::option::Option<std::string::String>,
    /// <p>The ID of a hierarchy in the parent asset's model. Hierarchies allow different groupings of assets to be formed that all come from the same asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html">Asset hierarchies</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub hierarchy_id: std::option::Option<std::string::String>,
    /// <p>The ID of the child asset to be associated.</p>
    #[doc(hidden)]
    pub child_asset_id: std::option::Option<std::string::String>,
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl AssociateAssetsInput {
    /// <p>The ID of the parent asset.</p>
    pub fn asset_id(&self) -> std::option::Option<& str> {
        self.asset_id.as_deref()
    }
    /// <p>The ID of a hierarchy in the parent asset's model. Hierarchies allow different groupings of assets to be formed that all come from the same asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html">Asset hierarchies</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn hierarchy_id(&self) -> std::option::Option<& str> {
        self.hierarchy_id.as_deref()
    }
    /// <p>The ID of the child asset to be associated.</p>
    pub fn child_asset_id(&self) -> std::option::Option<& str> {
        self.child_asset_id.as_deref()
    }
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
}

