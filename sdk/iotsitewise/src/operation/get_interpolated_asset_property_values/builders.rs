// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::get_interpolated_asset_property_values::_get_interpolated_asset_property_values_output::GetInterpolatedAssetPropertyValuesOutputBuilder;

pub use crate::operation::get_interpolated_asset_property_values::_get_interpolated_asset_property_values_input::GetInterpolatedAssetPropertyValuesInputBuilder;

impl GetInterpolatedAssetPropertyValuesInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::get_interpolated_asset_property_values::GetInterpolatedAssetPropertyValuesOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::get_interpolated_asset_property_values::GetInterpolatedAssetPropertyValuesError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.get_interpolated_asset_property_values();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `GetInterpolatedAssetPropertyValues`.
///
/// <p>Get interpolated values for an asset property for a specified time interval, during a period of time. If your time series is missing data points during the specified time interval, you can use interpolation to estimate the missing data.</p>
/// <p>For example, you can use this operation to return the interpolated temperature values for a wind turbine every 24 hours over a duration of 7 days.</p>
/// <p>To identify an asset property, you must specify one of the following:</p>
/// <ul>
/// <li>
/// <p>The <code>assetId</code> and <code>propertyId</code> of an asset property.</p></li>
/// <li>
/// <p>A <code>propertyAlias</code>, which is a data stream alias (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). To define an asset property's alias, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetProperty.html">UpdateAssetProperty</a>.</p></li>
/// </ul>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct GetInterpolatedAssetPropertyValuesFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::get_interpolated_asset_property_values::builders::GetInterpolatedAssetPropertyValuesInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::get_interpolated_asset_property_values::GetInterpolatedAssetPropertyValuesOutput,
        crate::operation::get_interpolated_asset_property_values::GetInterpolatedAssetPropertyValuesError,
    > for GetInterpolatedAssetPropertyValuesFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::get_interpolated_asset_property_values::GetInterpolatedAssetPropertyValuesOutput,
            crate::operation::get_interpolated_asset_property_values::GetInterpolatedAssetPropertyValuesError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl GetInterpolatedAssetPropertyValuesFluentBuilder {
    /// Creates a new `GetInterpolatedAssetPropertyValues`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the GetInterpolatedAssetPropertyValues as a reference.
    pub fn as_input(&self) -> &crate::operation::get_interpolated_asset_property_values::builders::GetInterpolatedAssetPropertyValuesInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::get_interpolated_asset_property_values::GetInterpolatedAssetPropertyValuesOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::get_interpolated_asset_property_values::GetInterpolatedAssetPropertyValuesError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::get_interpolated_asset_property_values::GetInterpolatedAssetPropertyValues::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::get_interpolated_asset_property_values::GetInterpolatedAssetPropertyValues::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::get_interpolated_asset_property_values::GetInterpolatedAssetPropertyValuesOutput,
        crate::operation::get_interpolated_asset_property_values::GetInterpolatedAssetPropertyValuesError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl Into<crate::config::Builder>) -> Self {
        self.set_config_override(Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// Create a paginator for this request
    ///
    /// Paginators are used by calling [`send().await`](crate::operation::get_interpolated_asset_property_values::paginator::GetInterpolatedAssetPropertyValuesPaginator::send) which returns a [`PaginationStream`](aws_smithy_async::future::pagination_stream::PaginationStream).
    pub fn into_paginator(self) -> crate::operation::get_interpolated_asset_property_values::paginator::GetInterpolatedAssetPropertyValuesPaginator {
        crate::operation::get_interpolated_asset_property_values::paginator::GetInterpolatedAssetPropertyValuesPaginator::new(self.handle, self.inner)
    }
    /// <p>The ID of the asset, in UUID format.</p>
    pub fn asset_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.asset_id(input.into());
        self
    }
    /// <p>The ID of the asset, in UUID format.</p>
    pub fn set_asset_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_asset_id(input);
        self
    }
    /// <p>The ID of the asset, in UUID format.</p>
    pub fn get_asset_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_asset_id()
    }
    /// <p>The ID of the asset property, in UUID format.</p>
    pub fn property_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.property_id(input.into());
        self
    }
    /// <p>The ID of the asset property, in UUID format.</p>
    pub fn set_property_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_property_id(input);
        self
    }
    /// <p>The ID of the asset property, in UUID format.</p>
    pub fn get_property_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_property_id()
    }
    /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn property_alias(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.property_alias(input.into());
        self
    }
    /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn set_property_alias(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_property_alias(input);
        self
    }
    /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn get_property_alias(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_property_alias()
    }
    /// <p>The exclusive start of the range from which to interpolate data, expressed in seconds in Unix epoch time.</p>
    pub fn start_time_in_seconds(mut self, input: i64) -> Self {
        self.inner = self.inner.start_time_in_seconds(input);
        self
    }
    /// <p>The exclusive start of the range from which to interpolate data, expressed in seconds in Unix epoch time.</p>
    pub fn set_start_time_in_seconds(mut self, input: ::std::option::Option<i64>) -> Self {
        self.inner = self.inner.set_start_time_in_seconds(input);
        self
    }
    /// <p>The exclusive start of the range from which to interpolate data, expressed in seconds in Unix epoch time.</p>
    pub fn get_start_time_in_seconds(&self) -> &::std::option::Option<i64> {
        self.inner.get_start_time_in_seconds()
    }
    /// <p>The nanosecond offset converted from <code>startTimeInSeconds</code>.</p>
    pub fn start_time_offset_in_nanos(mut self, input: i32) -> Self {
        self.inner = self.inner.start_time_offset_in_nanos(input);
        self
    }
    /// <p>The nanosecond offset converted from <code>startTimeInSeconds</code>.</p>
    pub fn set_start_time_offset_in_nanos(mut self, input: ::std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_start_time_offset_in_nanos(input);
        self
    }
    /// <p>The nanosecond offset converted from <code>startTimeInSeconds</code>.</p>
    pub fn get_start_time_offset_in_nanos(&self) -> &::std::option::Option<i32> {
        self.inner.get_start_time_offset_in_nanos()
    }
    /// <p>The inclusive end of the range from which to interpolate data, expressed in seconds in Unix epoch time.</p>
    pub fn end_time_in_seconds(mut self, input: i64) -> Self {
        self.inner = self.inner.end_time_in_seconds(input);
        self
    }
    /// <p>The inclusive end of the range from which to interpolate data, expressed in seconds in Unix epoch time.</p>
    pub fn set_end_time_in_seconds(mut self, input: ::std::option::Option<i64>) -> Self {
        self.inner = self.inner.set_end_time_in_seconds(input);
        self
    }
    /// <p>The inclusive end of the range from which to interpolate data, expressed in seconds in Unix epoch time.</p>
    pub fn get_end_time_in_seconds(&self) -> &::std::option::Option<i64> {
        self.inner.get_end_time_in_seconds()
    }
    /// <p>The nanosecond offset converted from <code>endTimeInSeconds</code>.</p>
    pub fn end_time_offset_in_nanos(mut self, input: i32) -> Self {
        self.inner = self.inner.end_time_offset_in_nanos(input);
        self
    }
    /// <p>The nanosecond offset converted from <code>endTimeInSeconds</code>.</p>
    pub fn set_end_time_offset_in_nanos(mut self, input: ::std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_end_time_offset_in_nanos(input);
        self
    }
    /// <p>The nanosecond offset converted from <code>endTimeInSeconds</code>.</p>
    pub fn get_end_time_offset_in_nanos(&self) -> &::std::option::Option<i32> {
        self.inner.get_end_time_offset_in_nanos()
    }
    /// <p>The quality of the asset property value. You can use this parameter as a filter to choose only the asset property values that have a specific quality.</p>
    pub fn quality(mut self, input: crate::types::Quality) -> Self {
        self.inner = self.inner.quality(input);
        self
    }
    /// <p>The quality of the asset property value. You can use this parameter as a filter to choose only the asset property values that have a specific quality.</p>
    pub fn set_quality(mut self, input: ::std::option::Option<crate::types::Quality>) -> Self {
        self.inner = self.inner.set_quality(input);
        self
    }
    /// <p>The quality of the asset property value. You can use this parameter as a filter to choose only the asset property values that have a specific quality.</p>
    pub fn get_quality(&self) -> &::std::option::Option<crate::types::Quality> {
        self.inner.get_quality()
    }
    /// <p>The time interval in seconds over which to interpolate data. Each interval starts when the previous one ends.</p>
    pub fn interval_in_seconds(mut self, input: i64) -> Self {
        self.inner = self.inner.interval_in_seconds(input);
        self
    }
    /// <p>The time interval in seconds over which to interpolate data. Each interval starts when the previous one ends.</p>
    pub fn set_interval_in_seconds(mut self, input: ::std::option::Option<i64>) -> Self {
        self.inner = self.inner.set_interval_in_seconds(input);
        self
    }
    /// <p>The time interval in seconds over which to interpolate data. Each interval starts when the previous one ends.</p>
    pub fn get_interval_in_seconds(&self) -> &::std::option::Option<i64> {
        self.inner.get_interval_in_seconds()
    }
    /// <p>The token to be used for the next set of paginated results.</p>
    pub fn next_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.next_token(input.into());
        self
    }
    /// <p>The token to be used for the next set of paginated results.</p>
    pub fn set_next_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_next_token(input);
        self
    }
    /// <p>The token to be used for the next set of paginated results.</p>
    pub fn get_next_token(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_next_token()
    }
    /// <p>The maximum number of results to return for each paginated request. If not specified, the default value is 10.</p>
    pub fn max_results(mut self, input: i32) -> Self {
        self.inner = self.inner.max_results(input);
        self
    }
    /// <p>The maximum number of results to return for each paginated request. If not specified, the default value is 10.</p>
    pub fn set_max_results(mut self, input: ::std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_max_results(input);
        self
    }
    /// <p>The maximum number of results to return for each paginated request. If not specified, the default value is 10.</p>
    pub fn get_max_results(&self) -> &::std::option::Option<i32> {
        self.inner.get_max_results()
    }
    /// <p>The interpolation type.</p>
    /// <p>Valid values: <code>LINEAR_INTERPOLATION | LOCF_INTERPOLATION</code></p>
    /// <ul>
    /// <li>
    /// <p><code>LINEAR_INTERPOLATION</code> – Estimates missing data using <a href="https://en.wikipedia.org/wiki/Linear_interpolation">linear interpolation</a>.</p>
    /// <p>For example, you can use this operation to return the interpolated temperature values for a wind turbine every 24 hours over a duration of 7 days. If the interpolation starts July 1, 2021, at 9 AM, IoT SiteWise returns the first interpolated value on July 2, 2021, at 9 AM, the second interpolated value on July 3, 2021, at 9 AM, and so on.</p></li>
    /// <li>
    /// <p><code>LOCF_INTERPOLATION</code> – Estimates missing data using last observation carried forward interpolation</p>
    /// <p>If no data point is found for an interval, IoT SiteWise returns the last observed data point for the previous interval and carries forward this interpolated value until a new data point is found.</p>
    /// <p>For example, you can get the state of an on-off valve every 24 hours over a duration of 7 days. If the interpolation starts July 1, 2021, at 9 AM, IoT SiteWise returns the last observed data point between July 1, 2021, at 9 AM and July 2, 2021, at 9 AM as the first interpolated value. If a data point isn't found after 9 AM on July 2, 2021, IoT SiteWise uses the same interpolated value for the rest of the days.</p></li>
    /// </ul>
    pub fn r#type(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.r#type(input.into());
        self
    }
    /// <p>The interpolation type.</p>
    /// <p>Valid values: <code>LINEAR_INTERPOLATION | LOCF_INTERPOLATION</code></p>
    /// <ul>
    /// <li>
    /// <p><code>LINEAR_INTERPOLATION</code> – Estimates missing data using <a href="https://en.wikipedia.org/wiki/Linear_interpolation">linear interpolation</a>.</p>
    /// <p>For example, you can use this operation to return the interpolated temperature values for a wind turbine every 24 hours over a duration of 7 days. If the interpolation starts July 1, 2021, at 9 AM, IoT SiteWise returns the first interpolated value on July 2, 2021, at 9 AM, the second interpolated value on July 3, 2021, at 9 AM, and so on.</p></li>
    /// <li>
    /// <p><code>LOCF_INTERPOLATION</code> – Estimates missing data using last observation carried forward interpolation</p>
    /// <p>If no data point is found for an interval, IoT SiteWise returns the last observed data point for the previous interval and carries forward this interpolated value until a new data point is found.</p>
    /// <p>For example, you can get the state of an on-off valve every 24 hours over a duration of 7 days. If the interpolation starts July 1, 2021, at 9 AM, IoT SiteWise returns the last observed data point between July 1, 2021, at 9 AM and July 2, 2021, at 9 AM as the first interpolated value. If a data point isn't found after 9 AM on July 2, 2021, IoT SiteWise uses the same interpolated value for the rest of the days.</p></li>
    /// </ul>
    pub fn set_type(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_type(input);
        self
    }
    /// <p>The interpolation type.</p>
    /// <p>Valid values: <code>LINEAR_INTERPOLATION | LOCF_INTERPOLATION</code></p>
    /// <ul>
    /// <li>
    /// <p><code>LINEAR_INTERPOLATION</code> – Estimates missing data using <a href="https://en.wikipedia.org/wiki/Linear_interpolation">linear interpolation</a>.</p>
    /// <p>For example, you can use this operation to return the interpolated temperature values for a wind turbine every 24 hours over a duration of 7 days. If the interpolation starts July 1, 2021, at 9 AM, IoT SiteWise returns the first interpolated value on July 2, 2021, at 9 AM, the second interpolated value on July 3, 2021, at 9 AM, and so on.</p></li>
    /// <li>
    /// <p><code>LOCF_INTERPOLATION</code> – Estimates missing data using last observation carried forward interpolation</p>
    /// <p>If no data point is found for an interval, IoT SiteWise returns the last observed data point for the previous interval and carries forward this interpolated value until a new data point is found.</p>
    /// <p>For example, you can get the state of an on-off valve every 24 hours over a duration of 7 days. If the interpolation starts July 1, 2021, at 9 AM, IoT SiteWise returns the last observed data point between July 1, 2021, at 9 AM and July 2, 2021, at 9 AM as the first interpolated value. If a data point isn't found after 9 AM on July 2, 2021, IoT SiteWise uses the same interpolated value for the rest of the days.</p></li>
    /// </ul>
    pub fn get_type(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_type()
    }
    /// <p>The query interval for the window, in seconds. IoT SiteWise computes each interpolated value by using data points from the timestamp of each interval, minus the window to the timestamp of each interval plus the window. If not specified, the window ranges between the start time minus the interval and the end time plus the interval.</p><note>
    /// <ul>
    /// <li>
    /// <p>If you specify a value for the <code>intervalWindowInSeconds</code> parameter, the value for the <code>type</code> parameter must be <code>LINEAR_INTERPOLATION</code>.</p></li>
    /// <li>
    /// <p>If a data point isn't found during the specified query window, IoT SiteWise won't return an interpolated value for the interval. This indicates that there's a gap in the ingested data points.</p></li>
    /// </ul>
    /// </note>
    /// <p>For example, you can get the interpolated temperature values for a wind turbine every 24 hours over a duration of 7 days. If the interpolation starts on July 1, 2021, at 9 AM with a window of 2 hours, IoT SiteWise uses the data points from 7 AM (9 AM minus 2 hours) to 11 AM (9 AM plus 2 hours) on July 2, 2021 to compute the first interpolated value. Next, IoT SiteWise uses the data points from 7 AM (9 AM minus 2 hours) to 11 AM (9 AM plus 2 hours) on July 3, 2021 to compute the second interpolated value, and so on.</p>
    pub fn interval_window_in_seconds(mut self, input: i64) -> Self {
        self.inner = self.inner.interval_window_in_seconds(input);
        self
    }
    /// <p>The query interval for the window, in seconds. IoT SiteWise computes each interpolated value by using data points from the timestamp of each interval, minus the window to the timestamp of each interval plus the window. If not specified, the window ranges between the start time minus the interval and the end time plus the interval.</p><note>
    /// <ul>
    /// <li>
    /// <p>If you specify a value for the <code>intervalWindowInSeconds</code> parameter, the value for the <code>type</code> parameter must be <code>LINEAR_INTERPOLATION</code>.</p></li>
    /// <li>
    /// <p>If a data point isn't found during the specified query window, IoT SiteWise won't return an interpolated value for the interval. This indicates that there's a gap in the ingested data points.</p></li>
    /// </ul>
    /// </note>
    /// <p>For example, you can get the interpolated temperature values for a wind turbine every 24 hours over a duration of 7 days. If the interpolation starts on July 1, 2021, at 9 AM with a window of 2 hours, IoT SiteWise uses the data points from 7 AM (9 AM minus 2 hours) to 11 AM (9 AM plus 2 hours) on July 2, 2021 to compute the first interpolated value. Next, IoT SiteWise uses the data points from 7 AM (9 AM minus 2 hours) to 11 AM (9 AM plus 2 hours) on July 3, 2021 to compute the second interpolated value, and so on.</p>
    pub fn set_interval_window_in_seconds(mut self, input: ::std::option::Option<i64>) -> Self {
        self.inner = self.inner.set_interval_window_in_seconds(input);
        self
    }
    /// <p>The query interval for the window, in seconds. IoT SiteWise computes each interpolated value by using data points from the timestamp of each interval, minus the window to the timestamp of each interval plus the window. If not specified, the window ranges between the start time minus the interval and the end time plus the interval.</p><note>
    /// <ul>
    /// <li>
    /// <p>If you specify a value for the <code>intervalWindowInSeconds</code> parameter, the value for the <code>type</code> parameter must be <code>LINEAR_INTERPOLATION</code>.</p></li>
    /// <li>
    /// <p>If a data point isn't found during the specified query window, IoT SiteWise won't return an interpolated value for the interval. This indicates that there's a gap in the ingested data points.</p></li>
    /// </ul>
    /// </note>
    /// <p>For example, you can get the interpolated temperature values for a wind turbine every 24 hours over a duration of 7 days. If the interpolation starts on July 1, 2021, at 9 AM with a window of 2 hours, IoT SiteWise uses the data points from 7 AM (9 AM minus 2 hours) to 11 AM (9 AM plus 2 hours) on July 2, 2021 to compute the first interpolated value. Next, IoT SiteWise uses the data points from 7 AM (9 AM minus 2 hours) to 11 AM (9 AM plus 2 hours) on July 3, 2021 to compute the second interpolated value, and so on.</p>
    pub fn get_interval_window_in_seconds(&self) -> &::std::option::Option<i64> {
        self.inner.get_interval_window_in_seconds()
    }
}
