// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Contains information about the current status of a portal.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PortalStatus {
    /// <p>The current state of the portal.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::PortalState>,
    /// <p>Contains associated error information, if any.</p>
    #[doc(hidden)]
    pub error: std::option::Option<crate::model::MonitorErrorDetails>,
}
impl PortalStatus {
    /// <p>The current state of the portal.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::PortalState> {
        self.state.as_ref()
    }
    /// <p>Contains associated error information, if any.</p>
    pub fn error(&self) -> std::option::Option<&crate::model::MonitorErrorDetails> {
        self.error.as_ref()
    }
}
/// See [`PortalStatus`](crate::model::PortalStatus).
pub mod portal_status {

    /// A builder for [`PortalStatus`](crate::model::PortalStatus).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) state: std::option::Option<crate::model::PortalState>,
        pub(crate) error: std::option::Option<crate::model::MonitorErrorDetails>,
    }
    impl Builder {
        /// <p>The current state of the portal.</p>
        pub fn state(mut self, input: crate::model::PortalState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current state of the portal.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::PortalState>) -> Self {
            self.state = input;
            self
        }
        /// <p>Contains associated error information, if any.</p>
        pub fn error(mut self, input: crate::model::MonitorErrorDetails) -> Self {
            self.error = Some(input);
            self
        }
        /// <p>Contains associated error information, if any.</p>
        pub fn set_error(
            mut self,
            input: std::option::Option<crate::model::MonitorErrorDetails>,
        ) -> Self {
            self.error = input;
            self
        }
        /// Consumes the builder and constructs a [`PortalStatus`](crate::model::PortalStatus).
        pub fn build(self) -> crate::model::PortalStatus {
            crate::model::PortalStatus {
                state: self.state,
                error: self.error,
            }
        }
    }
}
impl PortalStatus {
    /// Creates a new builder-style object to manufacture [`PortalStatus`](crate::model::PortalStatus).
    pub fn builder() -> crate::model::portal_status::Builder {
        crate::model::portal_status::Builder::default()
    }
}

/// <p>Contains IoT SiteWise Monitor error details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MonitorErrorDetails {
    /// <p>The error code.</p>
    #[doc(hidden)]
    pub code: std::option::Option<crate::model::MonitorErrorCode>,
    /// <p>The error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl MonitorErrorDetails {
    /// <p>The error code.</p>
    pub fn code(&self) -> std::option::Option<&crate::model::MonitorErrorCode> {
        self.code.as_ref()
    }
    /// <p>The error message.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
/// See [`MonitorErrorDetails`](crate::model::MonitorErrorDetails).
pub mod monitor_error_details {

    /// A builder for [`MonitorErrorDetails`](crate::model::MonitorErrorDetails).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::MonitorErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The error code.</p>
        pub fn code(mut self, input: crate::model::MonitorErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        /// <p>The error code.</p>
        pub fn set_code(
            mut self,
            input: std::option::Option<crate::model::MonitorErrorCode>,
        ) -> Self {
            self.code = input;
            self
        }
        /// <p>The error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitorErrorDetails`](crate::model::MonitorErrorDetails).
        pub fn build(self) -> crate::model::MonitorErrorDetails {
            crate::model::MonitorErrorDetails {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl MonitorErrorDetails {
    /// Creates a new builder-style object to manufacture [`MonitorErrorDetails`](crate::model::MonitorErrorDetails).
    pub fn builder() -> crate::model::monitor_error_details::Builder {
        crate::model::monitor_error_details::Builder::default()
    }
}

/// When writing a match expression against `MonitorErrorCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let monitorerrorcode = unimplemented!();
/// match monitorerrorcode {
///     MonitorErrorCode::InternalFailure => { /* ... */ },
///     MonitorErrorCode::LimitExceeded => { /* ... */ },
///     MonitorErrorCode::ValidationError => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `monitorerrorcode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `MonitorErrorCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `MonitorErrorCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `MonitorErrorCode::NewFeature` is defined.
/// Specifically, when `monitorerrorcode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `MonitorErrorCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MonitorErrorCode {
    #[allow(missing_docs)] // documentation missing in model
    InternalFailure,
    #[allow(missing_docs)] // documentation missing in model
    LimitExceeded,
    #[allow(missing_docs)] // documentation missing in model
    ValidationError,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for MonitorErrorCode {
    fn from(s: &str) -> Self {
        match s {
            "INTERNAL_FAILURE" => MonitorErrorCode::InternalFailure,
            "LIMIT_EXCEEDED" => MonitorErrorCode::LimitExceeded,
            "VALIDATION_ERROR" => MonitorErrorCode::ValidationError,
            other => MonitorErrorCode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for MonitorErrorCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MonitorErrorCode::from(s))
    }
}
impl MonitorErrorCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MonitorErrorCode::InternalFailure => "INTERNAL_FAILURE",
            MonitorErrorCode::LimitExceeded => "LIMIT_EXCEEDED",
            MonitorErrorCode::ValidationError => "VALIDATION_ERROR",
            MonitorErrorCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["INTERNAL_FAILURE", "LIMIT_EXCEEDED", "VALIDATION_ERROR"]
    }
}
impl AsRef<str> for MonitorErrorCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PortalState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let portalstate = unimplemented!();
/// match portalstate {
///     PortalState::Active => { /* ... */ },
///     PortalState::Creating => { /* ... */ },
///     PortalState::Deleting => { /* ... */ },
///     PortalState::Failed => { /* ... */ },
///     PortalState::Updating => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `portalstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PortalState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PortalState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PortalState::NewFeature` is defined.
/// Specifically, when `portalstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PortalState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PortalState {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PortalState {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => PortalState::Active,
            "CREATING" => PortalState::Creating,
            "DELETING" => PortalState::Deleting,
            "FAILED" => PortalState::Failed,
            "UPDATING" => PortalState::Updating,
            other => PortalState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PortalState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PortalState::from(s))
    }
}
impl PortalState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PortalState::Active => "ACTIVE",
            PortalState::Creating => "CREATING",
            PortalState::Deleting => "DELETING",
            PortalState::Failed => "FAILED",
            PortalState::Updating => "UPDATING",
            PortalState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "CREATING", "DELETING", "FAILED", "UPDATING"]
    }
}
impl AsRef<str> for PortalState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal. You can use the alarm to monitor an asset property and get notified when the asset property value is outside a specified range. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/appguide/monitor-alarms.html">Monitoring with alarms</a> in the <i>IoT SiteWise Application Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Alarms {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the IAM role that allows the alarm to perform actions and access Amazon Web Services resources and services, such as IoT Events.</p>
    #[doc(hidden)]
    pub alarm_role_arn: std::option::Option<std::string::String>,
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the Lambda function that manages alarm notifications. For more information, see <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/lambda-support.html">Managing alarm notifications</a> in the <i>IoT Events Developer Guide</i>.</p>
    #[doc(hidden)]
    pub notification_lambda_arn: std::option::Option<std::string::String>,
}
impl Alarms {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the IAM role that allows the alarm to perform actions and access Amazon Web Services resources and services, such as IoT Events.</p>
    pub fn alarm_role_arn(&self) -> std::option::Option<&str> {
        self.alarm_role_arn.as_deref()
    }
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the Lambda function that manages alarm notifications. For more information, see <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/lambda-support.html">Managing alarm notifications</a> in the <i>IoT Events Developer Guide</i>.</p>
    pub fn notification_lambda_arn(&self) -> std::option::Option<&str> {
        self.notification_lambda_arn.as_deref()
    }
}
/// See [`Alarms`](crate::model::Alarms).
pub mod alarms {

    /// A builder for [`Alarms`](crate::model::Alarms).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) alarm_role_arn: std::option::Option<std::string::String>,
        pub(crate) notification_lambda_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the IAM role that allows the alarm to perform actions and access Amazon Web Services resources and services, such as IoT Events.</p>
        pub fn alarm_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.alarm_role_arn = Some(input.into());
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the IAM role that allows the alarm to perform actions and access Amazon Web Services resources and services, such as IoT Events.</p>
        pub fn set_alarm_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.alarm_role_arn = input;
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the Lambda function that manages alarm notifications. For more information, see <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/lambda-support.html">Managing alarm notifications</a> in the <i>IoT Events Developer Guide</i>.</p>
        pub fn notification_lambda_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.notification_lambda_arn = Some(input.into());
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the Lambda function that manages alarm notifications. For more information, see <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/lambda-support.html">Managing alarm notifications</a> in the <i>IoT Events Developer Guide</i>.</p>
        pub fn set_notification_lambda_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.notification_lambda_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`Alarms`](crate::model::Alarms).
        pub fn build(self) -> crate::model::Alarms {
            crate::model::Alarms {
                alarm_role_arn: self.alarm_role_arn,
                notification_lambda_arn: self.notification_lambda_arn,
            }
        }
    }
}
impl Alarms {
    /// Creates a new builder-style object to manufacture [`Alarms`](crate::model::Alarms).
    pub fn builder() -> crate::model::alarms::Builder {
        crate::model::alarms::Builder::default()
    }
}

/// <p>Contains an image that is one of the following:</p>
/// <ul>
/// <li> <p>An image file. Choose this option to upload a new image.</p> </li>
/// <li> <p>The ID of an existing image. Choose this option to keep an existing image.</p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Image {
    /// <p>The ID of an existing image. Specify this parameter to keep an existing image.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>Contains an image file.</p>
    #[doc(hidden)]
    pub file: std::option::Option<crate::model::ImageFile>,
}
impl Image {
    /// <p>The ID of an existing image. Specify this parameter to keep an existing image.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>Contains an image file.</p>
    pub fn file(&self) -> std::option::Option<&crate::model::ImageFile> {
        self.file.as_ref()
    }
}
/// See [`Image`](crate::model::Image).
pub mod image {

    /// A builder for [`Image`](crate::model::Image).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) file: std::option::Option<crate::model::ImageFile>,
    }
    impl Builder {
        /// <p>The ID of an existing image. Specify this parameter to keep an existing image.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of an existing image. Specify this parameter to keep an existing image.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>Contains an image file.</p>
        pub fn file(mut self, input: crate::model::ImageFile) -> Self {
            self.file = Some(input);
            self
        }
        /// <p>Contains an image file.</p>
        pub fn set_file(mut self, input: std::option::Option<crate::model::ImageFile>) -> Self {
            self.file = input;
            self
        }
        /// Consumes the builder and constructs a [`Image`](crate::model::Image).
        pub fn build(self) -> crate::model::Image {
            crate::model::Image {
                id: self.id,
                file: self.file,
            }
        }
    }
}
impl Image {
    /// Creates a new builder-style object to manufacture [`Image`](crate::model::Image).
    pub fn builder() -> crate::model::image::Builder {
        crate::model::image::Builder::default()
    }
}

/// <p>Contains an image file.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ImageFile {
    /// <p>The image file contents, represented as a base64-encoded string. The file size must be less than 1 MB.</p>
    #[doc(hidden)]
    pub data: std::option::Option<aws_smithy_types::Blob>,
    /// <p>The file type of the image.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::ImageFileType>,
}
impl ImageFile {
    /// <p>The image file contents, represented as a base64-encoded string. The file size must be less than 1 MB.</p>
    pub fn data(&self) -> std::option::Option<&aws_smithy_types::Blob> {
        self.data.as_ref()
    }
    /// <p>The file type of the image.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::ImageFileType> {
        self.r#type.as_ref()
    }
}
/// See [`ImageFile`](crate::model::ImageFile).
pub mod image_file {

    /// A builder for [`ImageFile`](crate::model::ImageFile).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data: std::option::Option<aws_smithy_types::Blob>,
        pub(crate) r#type: std::option::Option<crate::model::ImageFileType>,
    }
    impl Builder {
        /// <p>The image file contents, represented as a base64-encoded string. The file size must be less than 1 MB.</p>
        pub fn data(mut self, input: aws_smithy_types::Blob) -> Self {
            self.data = Some(input);
            self
        }
        /// <p>The image file contents, represented as a base64-encoded string. The file size must be less than 1 MB.</p>
        pub fn set_data(mut self, input: std::option::Option<aws_smithy_types::Blob>) -> Self {
            self.data = input;
            self
        }
        /// <p>The file type of the image.</p>
        pub fn r#type(mut self, input: crate::model::ImageFileType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The file type of the image.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::ImageFileType>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`ImageFile`](crate::model::ImageFile).
        pub fn build(self) -> crate::model::ImageFile {
            crate::model::ImageFile {
                data: self.data,
                r#type: self.r#type,
            }
        }
    }
}
impl ImageFile {
    /// Creates a new builder-style object to manufacture [`ImageFile`](crate::model::ImageFile).
    pub fn builder() -> crate::model::image_file::Builder {
        crate::model::image_file::Builder::default()
    }
}

/// When writing a match expression against `ImageFileType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let imagefiletype = unimplemented!();
/// match imagefiletype {
///     ImageFileType::Png => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `imagefiletype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ImageFileType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ImageFileType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ImageFileType::NewFeature` is defined.
/// Specifically, when `imagefiletype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ImageFileType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ImageFileType {
    #[allow(missing_docs)] // documentation missing in model
    Png,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ImageFileType {
    fn from(s: &str) -> Self {
        match s {
            "PNG" => ImageFileType::Png,
            other => ImageFileType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ImageFileType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ImageFileType::from(s))
    }
}
impl ImageFileType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ImageFileType::Png => "PNG",
            ImageFileType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["PNG"]
    }
}
impl AsRef<str> for ImageFileType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `CapabilitySyncStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let capabilitysyncstatus = unimplemented!();
/// match capabilitysyncstatus {
///     CapabilitySyncStatus::InSync => { /* ... */ },
///     CapabilitySyncStatus::OutOfSync => { /* ... */ },
///     CapabilitySyncStatus::SyncFailed => { /* ... */ },
///     CapabilitySyncStatus::UnknownValue => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `capabilitysyncstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CapabilitySyncStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CapabilitySyncStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CapabilitySyncStatus::NewFeature` is defined.
/// Specifically, when `capabilitysyncstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CapabilitySyncStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// _Note: `CapabilitySyncStatus::Unknown` has been renamed to `::UnknownValue`._
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CapabilitySyncStatus {
    #[allow(missing_docs)] // documentation missing in model
    InSync,
    #[allow(missing_docs)] // documentation missing in model
    OutOfSync,
    #[allow(missing_docs)] // documentation missing in model
    SyncFailed,
    /// _Note: `::Unknown` has been renamed to `::UnknownValue`._
    UnknownValue,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CapabilitySyncStatus {
    fn from(s: &str) -> Self {
        match s {
            "IN_SYNC" => CapabilitySyncStatus::InSync,
            "OUT_OF_SYNC" => CapabilitySyncStatus::OutOfSync,
            "SYNC_FAILED" => CapabilitySyncStatus::SyncFailed,
            "UNKNOWN" => CapabilitySyncStatus::UnknownValue,
            other => {
                CapabilitySyncStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for CapabilitySyncStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CapabilitySyncStatus::from(s))
    }
}
impl CapabilitySyncStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CapabilitySyncStatus::InSync => "IN_SYNC",
            CapabilitySyncStatus::OutOfSync => "OUT_OF_SYNC",
            CapabilitySyncStatus::SyncFailed => "SYNC_FAILED",
            CapabilitySyncStatus::UnknownValue => "UNKNOWN",
            CapabilitySyncStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["IN_SYNC", "OUT_OF_SYNC", "SYNC_FAILED", "UNKNOWN"]
    }
}
impl AsRef<str> for CapabilitySyncStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PropertyNotificationState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let propertynotificationstate = unimplemented!();
/// match propertynotificationstate {
///     PropertyNotificationState::Disabled => { /* ... */ },
///     PropertyNotificationState::Enabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `propertynotificationstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PropertyNotificationState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PropertyNotificationState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PropertyNotificationState::NewFeature` is defined.
/// Specifically, when `propertynotificationstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PropertyNotificationState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PropertyNotificationState {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PropertyNotificationState {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => PropertyNotificationState::Disabled,
            "ENABLED" => PropertyNotificationState::Enabled,
            other => PropertyNotificationState::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for PropertyNotificationState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PropertyNotificationState::from(s))
    }
}
impl PropertyNotificationState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PropertyNotificationState::Disabled => "DISABLED",
            PropertyNotificationState::Enabled => "ENABLED",
            PropertyNotificationState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for PropertyNotificationState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains current status information for an asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-and-model-states.html">Asset and model states</a> in the <i>IoT SiteWise User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssetModelStatus {
    /// <p>The current state of the asset model.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::AssetModelState>,
    /// <p>Contains associated error information, if any.</p>
    #[doc(hidden)]
    pub error: std::option::Option<crate::model::ErrorDetails>,
}
impl AssetModelStatus {
    /// <p>The current state of the asset model.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::AssetModelState> {
        self.state.as_ref()
    }
    /// <p>Contains associated error information, if any.</p>
    pub fn error(&self) -> std::option::Option<&crate::model::ErrorDetails> {
        self.error.as_ref()
    }
}
/// See [`AssetModelStatus`](crate::model::AssetModelStatus).
pub mod asset_model_status {

    /// A builder for [`AssetModelStatus`](crate::model::AssetModelStatus).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) state: std::option::Option<crate::model::AssetModelState>,
        pub(crate) error: std::option::Option<crate::model::ErrorDetails>,
    }
    impl Builder {
        /// <p>The current state of the asset model.</p>
        pub fn state(mut self, input: crate::model::AssetModelState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current state of the asset model.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::AssetModelState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>Contains associated error information, if any.</p>
        pub fn error(mut self, input: crate::model::ErrorDetails) -> Self {
            self.error = Some(input);
            self
        }
        /// <p>Contains associated error information, if any.</p>
        pub fn set_error(mut self, input: std::option::Option<crate::model::ErrorDetails>) -> Self {
            self.error = input;
            self
        }
        /// Consumes the builder and constructs a [`AssetModelStatus`](crate::model::AssetModelStatus).
        pub fn build(self) -> crate::model::AssetModelStatus {
            crate::model::AssetModelStatus {
                state: self.state,
                error: self.error,
            }
        }
    }
}
impl AssetModelStatus {
    /// Creates a new builder-style object to manufacture [`AssetModelStatus`](crate::model::AssetModelStatus).
    pub fn builder() -> crate::model::asset_model_status::Builder {
        crate::model::asset_model_status::Builder::default()
    }
}

/// <p>Contains the details of an IoT SiteWise error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ErrorDetails {
    /// <p>The error code.</p>
    #[doc(hidden)]
    pub code: std::option::Option<crate::model::ErrorCode>,
    /// <p>The error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p> A list of detailed errors. </p>
    #[doc(hidden)]
    pub details: std::option::Option<std::vec::Vec<crate::model::DetailedError>>,
}
impl ErrorDetails {
    /// <p>The error code.</p>
    pub fn code(&self) -> std::option::Option<&crate::model::ErrorCode> {
        self.code.as_ref()
    }
    /// <p>The error message.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p> A list of detailed errors. </p>
    pub fn details(&self) -> std::option::Option<&[crate::model::DetailedError]> {
        self.details.as_deref()
    }
}
/// See [`ErrorDetails`](crate::model::ErrorDetails).
pub mod error_details {

    /// A builder for [`ErrorDetails`](crate::model::ErrorDetails).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) details: std::option::Option<std::vec::Vec<crate::model::DetailedError>>,
    }
    impl Builder {
        /// <p>The error code.</p>
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        /// <p>The error code.</p>
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        /// <p>The error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Appends an item to `details`.
        ///
        /// To override the contents of this collection use [`set_details`](Self::set_details).
        ///
        /// <p> A list of detailed errors. </p>
        pub fn details(mut self, input: crate::model::DetailedError) -> Self {
            let mut v = self.details.unwrap_or_default();
            v.push(input);
            self.details = Some(v);
            self
        }
        /// <p> A list of detailed errors. </p>
        pub fn set_details(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DetailedError>>,
        ) -> Self {
            self.details = input;
            self
        }
        /// Consumes the builder and constructs a [`ErrorDetails`](crate::model::ErrorDetails).
        pub fn build(self) -> crate::model::ErrorDetails {
            crate::model::ErrorDetails {
                code: self.code,
                message: self.message,
                details: self.details,
            }
        }
    }
}
impl ErrorDetails {
    /// Creates a new builder-style object to manufacture [`ErrorDetails`](crate::model::ErrorDetails).
    pub fn builder() -> crate::model::error_details::Builder {
        crate::model::error_details::Builder::default()
    }
}

/// <p>Contains detailed error information. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DetailedError {
    /// <p>The error code. </p>
    #[doc(hidden)]
    pub code: std::option::Option<crate::model::DetailedErrorCode>,
    /// <p>The error message. </p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl DetailedError {
    /// <p>The error code. </p>
    pub fn code(&self) -> std::option::Option<&crate::model::DetailedErrorCode> {
        self.code.as_ref()
    }
    /// <p>The error message. </p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
/// See [`DetailedError`](crate::model::DetailedError).
pub mod detailed_error {

    /// A builder for [`DetailedError`](crate::model::DetailedError).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::DetailedErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The error code. </p>
        pub fn code(mut self, input: crate::model::DetailedErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        /// <p>The error code. </p>
        pub fn set_code(
            mut self,
            input: std::option::Option<crate::model::DetailedErrorCode>,
        ) -> Self {
            self.code = input;
            self
        }
        /// <p>The error message. </p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The error message. </p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DetailedError`](crate::model::DetailedError).
        pub fn build(self) -> crate::model::DetailedError {
            crate::model::DetailedError {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl DetailedError {
    /// Creates a new builder-style object to manufacture [`DetailedError`](crate::model::DetailedError).
    pub fn builder() -> crate::model::detailed_error::Builder {
        crate::model::detailed_error::Builder::default()
    }
}

/// When writing a match expression against `DetailedErrorCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let detailederrorcode = unimplemented!();
/// match detailederrorcode {
///     DetailedErrorCode::IncompatibleComputeLocation => { /* ... */ },
///     DetailedErrorCode::IncompatibleForwardingConfiguration => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `detailederrorcode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DetailedErrorCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DetailedErrorCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DetailedErrorCode::NewFeature` is defined.
/// Specifically, when `detailederrorcode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DetailedErrorCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DetailedErrorCode {
    #[allow(missing_docs)] // documentation missing in model
    IncompatibleComputeLocation,
    #[allow(missing_docs)] // documentation missing in model
    IncompatibleForwardingConfiguration,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DetailedErrorCode {
    fn from(s: &str) -> Self {
        match s {
            "INCOMPATIBLE_COMPUTE_LOCATION" => DetailedErrorCode::IncompatibleComputeLocation,
            "INCOMPATIBLE_FORWARDING_CONFIGURATION" => {
                DetailedErrorCode::IncompatibleForwardingConfiguration
            }
            other => {
                DetailedErrorCode::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for DetailedErrorCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DetailedErrorCode::from(s))
    }
}
impl DetailedErrorCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DetailedErrorCode::IncompatibleComputeLocation => "INCOMPATIBLE_COMPUTE_LOCATION",
            DetailedErrorCode::IncompatibleForwardingConfiguration => {
                "INCOMPATIBLE_FORWARDING_CONFIGURATION"
            }
            DetailedErrorCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "INCOMPATIBLE_COMPUTE_LOCATION",
            "INCOMPATIBLE_FORWARDING_CONFIGURATION",
        ]
    }
}
impl AsRef<str> for DetailedErrorCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ErrorCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let errorcode = unimplemented!();
/// match errorcode {
///     ErrorCode::InternalFailure => { /* ... */ },
///     ErrorCode::ValidationError => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `errorcode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ErrorCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ErrorCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ErrorCode::NewFeature` is defined.
/// Specifically, when `errorcode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ErrorCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ErrorCode {
    #[allow(missing_docs)] // documentation missing in model
    InternalFailure,
    #[allow(missing_docs)] // documentation missing in model
    ValidationError,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ErrorCode {
    fn from(s: &str) -> Self {
        match s {
            "INTERNAL_FAILURE" => ErrorCode::InternalFailure,
            "VALIDATION_ERROR" => ErrorCode::ValidationError,
            other => ErrorCode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ErrorCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ErrorCode::from(s))
    }
}
impl ErrorCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ErrorCode::InternalFailure => "INTERNAL_FAILURE",
            ErrorCode::ValidationError => "VALIDATION_ERROR",
            ErrorCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["INTERNAL_FAILURE", "VALIDATION_ERROR"]
    }
}
impl AsRef<str> for ErrorCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `AssetModelState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let assetmodelstate = unimplemented!();
/// match assetmodelstate {
///     AssetModelState::Active => { /* ... */ },
///     AssetModelState::Creating => { /* ... */ },
///     AssetModelState::Deleting => { /* ... */ },
///     AssetModelState::Failed => { /* ... */ },
///     AssetModelState::Propagating => { /* ... */ },
///     AssetModelState::Updating => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `assetmodelstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AssetModelState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AssetModelState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AssetModelState::NewFeature` is defined.
/// Specifically, when `assetmodelstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AssetModelState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AssetModelState {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Propagating,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AssetModelState {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => AssetModelState::Active,
            "CREATING" => AssetModelState::Creating,
            "DELETING" => AssetModelState::Deleting,
            "FAILED" => AssetModelState::Failed,
            "PROPAGATING" => AssetModelState::Propagating,
            "UPDATING" => AssetModelState::Updating,
            other => AssetModelState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AssetModelState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AssetModelState::from(s))
    }
}
impl AssetModelState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AssetModelState::Active => "ACTIVE",
            AssetModelState::Creating => "CREATING",
            AssetModelState::Deleting => "DELETING",
            AssetModelState::Failed => "FAILED",
            AssetModelState::Propagating => "PROPAGATING",
            AssetModelState::Updating => "UPDATING",
            AssetModelState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACTIVE",
            "CREATING",
            "DELETING",
            "FAILED",
            "PROPAGATING",
            "UPDATING",
        ]
    }
}
impl AsRef<str> for AssetModelState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about a composite model in an asset model. This object contains the asset property definitions that you define in the composite model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssetModelCompositeModel {
    /// <p>The name of the composite model.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the composite model.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The type of the composite model. For alarm composite models, this type is <code>AWS/ALARM</code>.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The asset property definitions for this composite model.</p>
    #[doc(hidden)]
    pub properties: std::option::Option<std::vec::Vec<crate::model::AssetModelProperty>>,
    /// <p> The ID of the asset model composite model. </p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl AssetModelCompositeModel {
    /// <p>The name of the composite model.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the composite model.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The type of the composite model. For alarm composite models, this type is <code>AWS/ALARM</code>.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The asset property definitions for this composite model.</p>
    pub fn properties(&self) -> std::option::Option<&[crate::model::AssetModelProperty]> {
        self.properties.as_deref()
    }
    /// <p> The ID of the asset model composite model. </p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
}
/// See [`AssetModelCompositeModel`](crate::model::AssetModelCompositeModel).
pub mod asset_model_composite_model {

    /// A builder for [`AssetModelCompositeModel`](crate::model::AssetModelCompositeModel).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) properties: std::option::Option<std::vec::Vec<crate::model::AssetModelProperty>>,
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the composite model.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the composite model.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the composite model.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the composite model.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The type of the composite model. For alarm composite models, this type is <code>AWS/ALARM</code>.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of the composite model. For alarm composite models, this type is <code>AWS/ALARM</code>.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Appends an item to `properties`.
        ///
        /// To override the contents of this collection use [`set_properties`](Self::set_properties).
        ///
        /// <p>The asset property definitions for this composite model.</p>
        pub fn properties(mut self, input: crate::model::AssetModelProperty) -> Self {
            let mut v = self.properties.unwrap_or_default();
            v.push(input);
            self.properties = Some(v);
            self
        }
        /// <p>The asset property definitions for this composite model.</p>
        pub fn set_properties(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AssetModelProperty>>,
        ) -> Self {
            self.properties = input;
            self
        }
        /// <p> The ID of the asset model composite model. </p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p> The ID of the asset model composite model. </p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`AssetModelCompositeModel`](crate::model::AssetModelCompositeModel).
        pub fn build(self) -> crate::model::AssetModelCompositeModel {
            crate::model::AssetModelCompositeModel {
                name: self.name,
                description: self.description,
                r#type: self.r#type,
                properties: self.properties,
                id: self.id,
            }
        }
    }
}
impl AssetModelCompositeModel {
    /// Creates a new builder-style object to manufacture [`AssetModelCompositeModel`](crate::model::AssetModelCompositeModel).
    pub fn builder() -> crate::model::asset_model_composite_model::Builder {
        crate::model::asset_model_composite_model::Builder::default()
    }
}

/// <p>Contains information about an asset model property.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssetModelProperty {
    /// <p>The ID of the asset model property.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the asset model property.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The data type of the asset model property.</p>
    #[doc(hidden)]
    pub data_type: std::option::Option<crate::model::PropertyDataType>,
    /// <p>The data type of the structure for this property. This parameter exists on properties that have the <code>STRUCT</code> data type.</p>
    #[doc(hidden)]
    pub data_type_spec: std::option::Option<std::string::String>,
    /// <p>The unit of the asset model property, such as <code>Newtons</code> or <code>RPM</code>.</p>
    #[doc(hidden)]
    pub unit: std::option::Option<std::string::String>,
    /// <p>The property type (see <code>PropertyType</code>).</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::PropertyType>,
}
impl AssetModelProperty {
    /// <p>The ID of the asset model property.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the asset model property.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The data type of the asset model property.</p>
    pub fn data_type(&self) -> std::option::Option<&crate::model::PropertyDataType> {
        self.data_type.as_ref()
    }
    /// <p>The data type of the structure for this property. This parameter exists on properties that have the <code>STRUCT</code> data type.</p>
    pub fn data_type_spec(&self) -> std::option::Option<&str> {
        self.data_type_spec.as_deref()
    }
    /// <p>The unit of the asset model property, such as <code>Newtons</code> or <code>RPM</code>.</p>
    pub fn unit(&self) -> std::option::Option<&str> {
        self.unit.as_deref()
    }
    /// <p>The property type (see <code>PropertyType</code>).</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::PropertyType> {
        self.r#type.as_ref()
    }
}
/// See [`AssetModelProperty`](crate::model::AssetModelProperty).
pub mod asset_model_property {

    /// A builder for [`AssetModelProperty`](crate::model::AssetModelProperty).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) data_type: std::option::Option<crate::model::PropertyDataType>,
        pub(crate) data_type_spec: std::option::Option<std::string::String>,
        pub(crate) unit: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::PropertyType>,
    }
    impl Builder {
        /// <p>The ID of the asset model property.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the asset model property.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the asset model property.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the asset model property.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The data type of the asset model property.</p>
        pub fn data_type(mut self, input: crate::model::PropertyDataType) -> Self {
            self.data_type = Some(input);
            self
        }
        /// <p>The data type of the asset model property.</p>
        pub fn set_data_type(
            mut self,
            input: std::option::Option<crate::model::PropertyDataType>,
        ) -> Self {
            self.data_type = input;
            self
        }
        /// <p>The data type of the structure for this property. This parameter exists on properties that have the <code>STRUCT</code> data type.</p>
        pub fn data_type_spec(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_type_spec = Some(input.into());
            self
        }
        /// <p>The data type of the structure for this property. This parameter exists on properties that have the <code>STRUCT</code> data type.</p>
        pub fn set_data_type_spec(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_type_spec = input;
            self
        }
        /// <p>The unit of the asset model property, such as <code>Newtons</code> or <code>RPM</code>.</p>
        pub fn unit(mut self, input: impl Into<std::string::String>) -> Self {
            self.unit = Some(input.into());
            self
        }
        /// <p>The unit of the asset model property, such as <code>Newtons</code> or <code>RPM</code>.</p>
        pub fn set_unit(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.unit = input;
            self
        }
        /// <p>The property type (see <code>PropertyType</code>).</p>
        pub fn r#type(mut self, input: crate::model::PropertyType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The property type (see <code>PropertyType</code>).</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::PropertyType>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`AssetModelProperty`](crate::model::AssetModelProperty).
        pub fn build(self) -> crate::model::AssetModelProperty {
            crate::model::AssetModelProperty {
                id: self.id,
                name: self.name,
                data_type: self.data_type,
                data_type_spec: self.data_type_spec,
                unit: self.unit,
                r#type: self.r#type,
            }
        }
    }
}
impl AssetModelProperty {
    /// Creates a new builder-style object to manufacture [`AssetModelProperty`](crate::model::AssetModelProperty).
    pub fn builder() -> crate::model::asset_model_property::Builder {
        crate::model::asset_model_property::Builder::default()
    }
}

/// <p>Contains a property type, which can be one of <code>attribute</code>, <code>measurement</code>, <code>metric</code>, or <code>transform</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PropertyType {
    /// <p>Specifies an asset attribute property. An attribute generally contains static information, such as the serial number of an <a href="https://en.wikipedia.org/wiki/Internet_of_things#Industrial_applications">IIoT</a> wind turbine.</p>
    #[doc(hidden)]
    pub attribute: std::option::Option<crate::model::Attribute>,
    /// <p>Specifies an asset measurement property. A measurement represents a device's raw sensor data stream, such as timestamped temperature values or timestamped power values.</p>
    #[doc(hidden)]
    pub measurement: std::option::Option<crate::model::Measurement>,
    /// <p>Specifies an asset transform property. A transform contains a mathematical expression that maps a property's data points from one form to another, such as a unit conversion from Celsius to Fahrenheit.</p>
    #[doc(hidden)]
    pub transform: std::option::Option<crate::model::Transform>,
    /// <p>Specifies an asset metric property. A metric contains a mathematical expression that uses aggregate functions to process all input data points over a time interval and output a single data point, such as to calculate the average hourly temperature.</p>
    #[doc(hidden)]
    pub metric: std::option::Option<crate::model::Metric>,
}
impl PropertyType {
    /// <p>Specifies an asset attribute property. An attribute generally contains static information, such as the serial number of an <a href="https://en.wikipedia.org/wiki/Internet_of_things#Industrial_applications">IIoT</a> wind turbine.</p>
    pub fn attribute(&self) -> std::option::Option<&crate::model::Attribute> {
        self.attribute.as_ref()
    }
    /// <p>Specifies an asset measurement property. A measurement represents a device's raw sensor data stream, such as timestamped temperature values or timestamped power values.</p>
    pub fn measurement(&self) -> std::option::Option<&crate::model::Measurement> {
        self.measurement.as_ref()
    }
    /// <p>Specifies an asset transform property. A transform contains a mathematical expression that maps a property's data points from one form to another, such as a unit conversion from Celsius to Fahrenheit.</p>
    pub fn transform(&self) -> std::option::Option<&crate::model::Transform> {
        self.transform.as_ref()
    }
    /// <p>Specifies an asset metric property. A metric contains a mathematical expression that uses aggregate functions to process all input data points over a time interval and output a single data point, such as to calculate the average hourly temperature.</p>
    pub fn metric(&self) -> std::option::Option<&crate::model::Metric> {
        self.metric.as_ref()
    }
}
/// See [`PropertyType`](crate::model::PropertyType).
pub mod property_type {

    /// A builder for [`PropertyType`](crate::model::PropertyType).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attribute: std::option::Option<crate::model::Attribute>,
        pub(crate) measurement: std::option::Option<crate::model::Measurement>,
        pub(crate) transform: std::option::Option<crate::model::Transform>,
        pub(crate) metric: std::option::Option<crate::model::Metric>,
    }
    impl Builder {
        /// <p>Specifies an asset attribute property. An attribute generally contains static information, such as the serial number of an <a href="https://en.wikipedia.org/wiki/Internet_of_things#Industrial_applications">IIoT</a> wind turbine.</p>
        pub fn attribute(mut self, input: crate::model::Attribute) -> Self {
            self.attribute = Some(input);
            self
        }
        /// <p>Specifies an asset attribute property. An attribute generally contains static information, such as the serial number of an <a href="https://en.wikipedia.org/wiki/Internet_of_things#Industrial_applications">IIoT</a> wind turbine.</p>
        pub fn set_attribute(
            mut self,
            input: std::option::Option<crate::model::Attribute>,
        ) -> Self {
            self.attribute = input;
            self
        }
        /// <p>Specifies an asset measurement property. A measurement represents a device's raw sensor data stream, such as timestamped temperature values or timestamped power values.</p>
        pub fn measurement(mut self, input: crate::model::Measurement) -> Self {
            self.measurement = Some(input);
            self
        }
        /// <p>Specifies an asset measurement property. A measurement represents a device's raw sensor data stream, such as timestamped temperature values or timestamped power values.</p>
        pub fn set_measurement(
            mut self,
            input: std::option::Option<crate::model::Measurement>,
        ) -> Self {
            self.measurement = input;
            self
        }
        /// <p>Specifies an asset transform property. A transform contains a mathematical expression that maps a property's data points from one form to another, such as a unit conversion from Celsius to Fahrenheit.</p>
        pub fn transform(mut self, input: crate::model::Transform) -> Self {
            self.transform = Some(input);
            self
        }
        /// <p>Specifies an asset transform property. A transform contains a mathematical expression that maps a property's data points from one form to another, such as a unit conversion from Celsius to Fahrenheit.</p>
        pub fn set_transform(
            mut self,
            input: std::option::Option<crate::model::Transform>,
        ) -> Self {
            self.transform = input;
            self
        }
        /// <p>Specifies an asset metric property. A metric contains a mathematical expression that uses aggregate functions to process all input data points over a time interval and output a single data point, such as to calculate the average hourly temperature.</p>
        pub fn metric(mut self, input: crate::model::Metric) -> Self {
            self.metric = Some(input);
            self
        }
        /// <p>Specifies an asset metric property. A metric contains a mathematical expression that uses aggregate functions to process all input data points over a time interval and output a single data point, such as to calculate the average hourly temperature.</p>
        pub fn set_metric(mut self, input: std::option::Option<crate::model::Metric>) -> Self {
            self.metric = input;
            self
        }
        /// Consumes the builder and constructs a [`PropertyType`](crate::model::PropertyType).
        pub fn build(self) -> crate::model::PropertyType {
            crate::model::PropertyType {
                attribute: self.attribute,
                measurement: self.measurement,
                transform: self.transform,
                metric: self.metric,
            }
        }
    }
}
impl PropertyType {
    /// Creates a new builder-style object to manufacture [`PropertyType`](crate::model::PropertyType).
    pub fn builder() -> crate::model::property_type::Builder {
        crate::model::property_type::Builder::default()
    }
}

/// <p>Contains an asset metric property. With metrics, you can calculate aggregate functions, such as an average, maximum, or minimum, as specified through an expression. A metric maps several values to a single value (such as a sum).</p>
/// <p>The maximum number of dependent/cascading variables used in any one metric calculation is 10. Therefore, a <i>root</i> metric can have up to 10 cascading metrics in its computational dependency tree. Additionally, a metric can only have a data type of <code>DOUBLE</code> and consume properties with data types of <code>INTEGER</code> or <code>DOUBLE</code>.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html#metrics">Metrics</a> in the <i>IoT SiteWise User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Metric {
    /// <p>The mathematical expression that defines the metric aggregation function. You can specify up to 10 variables per expression. You can specify up to 10 functions per expression. </p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub expression: std::option::Option<std::string::String>,
    /// <p>The list of variables used in the expression.</p>
    #[doc(hidden)]
    pub variables: std::option::Option<std::vec::Vec<crate::model::ExpressionVariable>>,
    /// <p>The window (time interval) over which IoT SiteWise computes the metric's aggregation expression. IoT SiteWise computes one data point per <code>window</code>.</p>
    #[doc(hidden)]
    pub window: std::option::Option<crate::model::MetricWindow>,
    /// <p>The processing configuration for the given metric property. You can configure metrics to be computed at the edge or in the Amazon Web Services Cloud. By default, metrics are forwarded to the cloud.</p>
    #[doc(hidden)]
    pub processing_config: std::option::Option<crate::model::MetricProcessingConfig>,
}
impl Metric {
    /// <p>The mathematical expression that defines the metric aggregation function. You can specify up to 10 variables per expression. You can specify up to 10 functions per expression. </p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn expression(&self) -> std::option::Option<&str> {
        self.expression.as_deref()
    }
    /// <p>The list of variables used in the expression.</p>
    pub fn variables(&self) -> std::option::Option<&[crate::model::ExpressionVariable]> {
        self.variables.as_deref()
    }
    /// <p>The window (time interval) over which IoT SiteWise computes the metric's aggregation expression. IoT SiteWise computes one data point per <code>window</code>.</p>
    pub fn window(&self) -> std::option::Option<&crate::model::MetricWindow> {
        self.window.as_ref()
    }
    /// <p>The processing configuration for the given metric property. You can configure metrics to be computed at the edge or in the Amazon Web Services Cloud. By default, metrics are forwarded to the cloud.</p>
    pub fn processing_config(&self) -> std::option::Option<&crate::model::MetricProcessingConfig> {
        self.processing_config.as_ref()
    }
}
/// See [`Metric`](crate::model::Metric).
pub mod metric {

    /// A builder for [`Metric`](crate::model::Metric).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) expression: std::option::Option<std::string::String>,
        pub(crate) variables: std::option::Option<std::vec::Vec<crate::model::ExpressionVariable>>,
        pub(crate) window: std::option::Option<crate::model::MetricWindow>,
        pub(crate) processing_config: std::option::Option<crate::model::MetricProcessingConfig>,
    }
    impl Builder {
        /// <p>The mathematical expression that defines the metric aggregation function. You can specify up to 10 variables per expression. You can specify up to 10 functions per expression. </p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.expression = Some(input.into());
            self
        }
        /// <p>The mathematical expression that defines the metric aggregation function. You can specify up to 10 variables per expression. You can specify up to 10 functions per expression. </p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_expression(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.expression = input;
            self
        }
        /// Appends an item to `variables`.
        ///
        /// To override the contents of this collection use [`set_variables`](Self::set_variables).
        ///
        /// <p>The list of variables used in the expression.</p>
        pub fn variables(mut self, input: crate::model::ExpressionVariable) -> Self {
            let mut v = self.variables.unwrap_or_default();
            v.push(input);
            self.variables = Some(v);
            self
        }
        /// <p>The list of variables used in the expression.</p>
        pub fn set_variables(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ExpressionVariable>>,
        ) -> Self {
            self.variables = input;
            self
        }
        /// <p>The window (time interval) over which IoT SiteWise computes the metric's aggregation expression. IoT SiteWise computes one data point per <code>window</code>.</p>
        pub fn window(mut self, input: crate::model::MetricWindow) -> Self {
            self.window = Some(input);
            self
        }
        /// <p>The window (time interval) over which IoT SiteWise computes the metric's aggregation expression. IoT SiteWise computes one data point per <code>window</code>.</p>
        pub fn set_window(
            mut self,
            input: std::option::Option<crate::model::MetricWindow>,
        ) -> Self {
            self.window = input;
            self
        }
        /// <p>The processing configuration for the given metric property. You can configure metrics to be computed at the edge or in the Amazon Web Services Cloud. By default, metrics are forwarded to the cloud.</p>
        pub fn processing_config(mut self, input: crate::model::MetricProcessingConfig) -> Self {
            self.processing_config = Some(input);
            self
        }
        /// <p>The processing configuration for the given metric property. You can configure metrics to be computed at the edge or in the Amazon Web Services Cloud. By default, metrics are forwarded to the cloud.</p>
        pub fn set_processing_config(
            mut self,
            input: std::option::Option<crate::model::MetricProcessingConfig>,
        ) -> Self {
            self.processing_config = input;
            self
        }
        /// Consumes the builder and constructs a [`Metric`](crate::model::Metric).
        pub fn build(self) -> crate::model::Metric {
            crate::model::Metric {
                expression: self.expression,
                variables: self.variables,
                window: self.window,
                processing_config: self.processing_config,
            }
        }
    }
}
impl Metric {
    /// Creates a new builder-style object to manufacture [`Metric`](crate::model::Metric).
    pub fn builder() -> crate::model::metric::Builder {
        crate::model::metric::Builder::default()
    }
}

/// <p>The processing configuration for the given metric property. You can configure metrics to be computed at the edge or in the Amazon Web Services Cloud. By default, metrics are forwarded to the cloud.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MetricProcessingConfig {
    /// <p>The compute location for the given metric property. </p>
    #[doc(hidden)]
    pub compute_location: std::option::Option<crate::model::ComputeLocation>,
}
impl MetricProcessingConfig {
    /// <p>The compute location for the given metric property. </p>
    pub fn compute_location(&self) -> std::option::Option<&crate::model::ComputeLocation> {
        self.compute_location.as_ref()
    }
}
/// See [`MetricProcessingConfig`](crate::model::MetricProcessingConfig).
pub mod metric_processing_config {

    /// A builder for [`MetricProcessingConfig`](crate::model::MetricProcessingConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) compute_location: std::option::Option<crate::model::ComputeLocation>,
    }
    impl Builder {
        /// <p>The compute location for the given metric property. </p>
        pub fn compute_location(mut self, input: crate::model::ComputeLocation) -> Self {
            self.compute_location = Some(input);
            self
        }
        /// <p>The compute location for the given metric property. </p>
        pub fn set_compute_location(
            mut self,
            input: std::option::Option<crate::model::ComputeLocation>,
        ) -> Self {
            self.compute_location = input;
            self
        }
        /// Consumes the builder and constructs a [`MetricProcessingConfig`](crate::model::MetricProcessingConfig).
        pub fn build(self) -> crate::model::MetricProcessingConfig {
            crate::model::MetricProcessingConfig {
                compute_location: self.compute_location,
            }
        }
    }
}
impl MetricProcessingConfig {
    /// Creates a new builder-style object to manufacture [`MetricProcessingConfig`](crate::model::MetricProcessingConfig).
    pub fn builder() -> crate::model::metric_processing_config::Builder {
        crate::model::metric_processing_config::Builder::default()
    }
}

/// When writing a match expression against `ComputeLocation`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let computelocation = unimplemented!();
/// match computelocation {
///     ComputeLocation::Cloud => { /* ... */ },
///     ComputeLocation::Edge => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `computelocation` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ComputeLocation::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ComputeLocation::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ComputeLocation::NewFeature` is defined.
/// Specifically, when `computelocation` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ComputeLocation::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ComputeLocation {
    #[allow(missing_docs)] // documentation missing in model
    Cloud,
    #[allow(missing_docs)] // documentation missing in model
    Edge,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ComputeLocation {
    fn from(s: &str) -> Self {
        match s {
            "CLOUD" => ComputeLocation::Cloud,
            "EDGE" => ComputeLocation::Edge,
            other => ComputeLocation::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ComputeLocation {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ComputeLocation::from(s))
    }
}
impl ComputeLocation {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ComputeLocation::Cloud => "CLOUD",
            ComputeLocation::Edge => "EDGE",
            ComputeLocation::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CLOUD", "EDGE"]
    }
}
impl AsRef<str> for ComputeLocation {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains a time interval window used for data aggregate computations (for example, average, sum, count, and so on).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MetricWindow {
    /// <p>The tumbling time interval window.</p>
    #[doc(hidden)]
    pub tumbling: std::option::Option<crate::model::TumblingWindow>,
}
impl MetricWindow {
    /// <p>The tumbling time interval window.</p>
    pub fn tumbling(&self) -> std::option::Option<&crate::model::TumblingWindow> {
        self.tumbling.as_ref()
    }
}
/// See [`MetricWindow`](crate::model::MetricWindow).
pub mod metric_window {

    /// A builder for [`MetricWindow`](crate::model::MetricWindow).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) tumbling: std::option::Option<crate::model::TumblingWindow>,
    }
    impl Builder {
        /// <p>The tumbling time interval window.</p>
        pub fn tumbling(mut self, input: crate::model::TumblingWindow) -> Self {
            self.tumbling = Some(input);
            self
        }
        /// <p>The tumbling time interval window.</p>
        pub fn set_tumbling(
            mut self,
            input: std::option::Option<crate::model::TumblingWindow>,
        ) -> Self {
            self.tumbling = input;
            self
        }
        /// Consumes the builder and constructs a [`MetricWindow`](crate::model::MetricWindow).
        pub fn build(self) -> crate::model::MetricWindow {
            crate::model::MetricWindow {
                tumbling: self.tumbling,
            }
        }
    }
}
impl MetricWindow {
    /// Creates a new builder-style object to manufacture [`MetricWindow`](crate::model::MetricWindow).
    pub fn builder() -> crate::model::metric_window::Builder {
        crate::model::metric_window::Builder::default()
    }
}

/// <p>Contains a tumbling window, which is a repeating fixed-sized, non-overlapping, and contiguous time window. You can use this window in metrics to aggregate data from properties and other assets.</p>
/// <p>You can use <code>m</code>, <code>h</code>, <code>d</code>, and <code>w</code> when you specify an interval or offset. Note that <code>m</code> represents minutes, <code>h</code> represents hours, <code>d</code> represents days, and <code>w</code> represents weeks. You can also use <code>s</code> to represent seconds in <code>offset</code>.</p>
/// <p>The <code>interval</code> and <code>offset</code> parameters support the <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601 format</a>. For example, <code>PT5S</code> represents 5 seconds, <code>PT5M</code> represents 5 minutes, and <code>PT5H</code> represents 5 hours.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TumblingWindow {
    /// <p>The time interval for the tumbling window. The interval time must be between 1 minute and 1 week.</p>
    /// <p>IoT SiteWise computes the <code>1w</code> interval the end of Sunday at midnight each week (UTC), the <code>1d</code> interval at the end of each day at midnight (UTC), the <code>1h</code> interval at the end of each hour, and so on. </p>
    /// <p>When IoT SiteWise aggregates data points for metric computations, the start of each interval is exclusive and the end of each interval is inclusive. IoT SiteWise places the computed data point at the end of the interval.</p>
    #[doc(hidden)]
    pub interval: std::option::Option<std::string::String>,
    /// <p>The offset for the tumbling window. The <code>offset</code> parameter accepts the following:</p>
    /// <ul>
    /// <li> <p>The offset time.</p> <p>For example, if you specify <code>18h</code> for <code>offset</code> and <code>1d</code> for <code>interval</code>, IoT SiteWise aggregates data in one of the following ways:</p>
    /// <ul>
    /// <li> <p>If you create the metric before or at 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) on the day when you create the metric.</p> </li>
    /// <li> <p>If you create the metric after 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) the next day.</p> </li>
    /// </ul> </li>
    /// <li> <p>The ISO 8601 format.</p> <p>For example, if you specify <code>PT18H</code> for <code>offset</code> and <code>1d</code> for <code>interval</code>, IoT SiteWise aggregates data in one of the following ways:</p>
    /// <ul>
    /// <li> <p>If you create the metric before or at 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) on the day when you create the metric.</p> </li>
    /// <li> <p>If you create the metric after 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) the next day.</p> </li>
    /// </ul> </li>
    /// <li> <p>The 24-hour clock.</p> <p>For example, if you specify <code>00:03:00</code> for <code>offset</code>, <code>5m</code> for <code>interval</code>, and you create the metric at 2 PM (UTC), you get the first aggregation result at 2:03 PM (UTC). You get the second aggregation result at 2:08 PM (UTC). </p> </li>
    /// <li> <p>The offset time zone.</p> <p>For example, if you specify <code>2021-07-23T18:00-08</code> for <code>offset</code> and <code>1d</code> for <code>interval</code>, IoT SiteWise aggregates data in one of the following ways:</p>
    /// <ul>
    /// <li> <p>If you create the metric before or at 6 PM (PST), you get the first aggregation result at 6 PM (PST) on the day when you create the metric.</p> </li>
    /// <li> <p>If you create the metric after 6 PM (PST), you get the first aggregation result at 6 PM (PST) the next day.</p> </li>
    /// </ul> </li>
    /// </ul>
    #[doc(hidden)]
    pub offset: std::option::Option<std::string::String>,
}
impl TumblingWindow {
    /// <p>The time interval for the tumbling window. The interval time must be between 1 minute and 1 week.</p>
    /// <p>IoT SiteWise computes the <code>1w</code> interval the end of Sunday at midnight each week (UTC), the <code>1d</code> interval at the end of each day at midnight (UTC), the <code>1h</code> interval at the end of each hour, and so on. </p>
    /// <p>When IoT SiteWise aggregates data points for metric computations, the start of each interval is exclusive and the end of each interval is inclusive. IoT SiteWise places the computed data point at the end of the interval.</p>
    pub fn interval(&self) -> std::option::Option<&str> {
        self.interval.as_deref()
    }
    /// <p>The offset for the tumbling window. The <code>offset</code> parameter accepts the following:</p>
    /// <ul>
    /// <li> <p>The offset time.</p> <p>For example, if you specify <code>18h</code> for <code>offset</code> and <code>1d</code> for <code>interval</code>, IoT SiteWise aggregates data in one of the following ways:</p>
    /// <ul>
    /// <li> <p>If you create the metric before or at 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) on the day when you create the metric.</p> </li>
    /// <li> <p>If you create the metric after 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) the next day.</p> </li>
    /// </ul> </li>
    /// <li> <p>The ISO 8601 format.</p> <p>For example, if you specify <code>PT18H</code> for <code>offset</code> and <code>1d</code> for <code>interval</code>, IoT SiteWise aggregates data in one of the following ways:</p>
    /// <ul>
    /// <li> <p>If you create the metric before or at 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) on the day when you create the metric.</p> </li>
    /// <li> <p>If you create the metric after 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) the next day.</p> </li>
    /// </ul> </li>
    /// <li> <p>The 24-hour clock.</p> <p>For example, if you specify <code>00:03:00</code> for <code>offset</code>, <code>5m</code> for <code>interval</code>, and you create the metric at 2 PM (UTC), you get the first aggregation result at 2:03 PM (UTC). You get the second aggregation result at 2:08 PM (UTC). </p> </li>
    /// <li> <p>The offset time zone.</p> <p>For example, if you specify <code>2021-07-23T18:00-08</code> for <code>offset</code> and <code>1d</code> for <code>interval</code>, IoT SiteWise aggregates data in one of the following ways:</p>
    /// <ul>
    /// <li> <p>If you create the metric before or at 6 PM (PST), you get the first aggregation result at 6 PM (PST) on the day when you create the metric.</p> </li>
    /// <li> <p>If you create the metric after 6 PM (PST), you get the first aggregation result at 6 PM (PST) the next day.</p> </li>
    /// </ul> </li>
    /// </ul>
    pub fn offset(&self) -> std::option::Option<&str> {
        self.offset.as_deref()
    }
}
/// See [`TumblingWindow`](crate::model::TumblingWindow).
pub mod tumbling_window {

    /// A builder for [`TumblingWindow`](crate::model::TumblingWindow).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) interval: std::option::Option<std::string::String>,
        pub(crate) offset: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The time interval for the tumbling window. The interval time must be between 1 minute and 1 week.</p>
        /// <p>IoT SiteWise computes the <code>1w</code> interval the end of Sunday at midnight each week (UTC), the <code>1d</code> interval at the end of each day at midnight (UTC), the <code>1h</code> interval at the end of each hour, and so on. </p>
        /// <p>When IoT SiteWise aggregates data points for metric computations, the start of each interval is exclusive and the end of each interval is inclusive. IoT SiteWise places the computed data point at the end of the interval.</p>
        pub fn interval(mut self, input: impl Into<std::string::String>) -> Self {
            self.interval = Some(input.into());
            self
        }
        /// <p>The time interval for the tumbling window. The interval time must be between 1 minute and 1 week.</p>
        /// <p>IoT SiteWise computes the <code>1w</code> interval the end of Sunday at midnight each week (UTC), the <code>1d</code> interval at the end of each day at midnight (UTC), the <code>1h</code> interval at the end of each hour, and so on. </p>
        /// <p>When IoT SiteWise aggregates data points for metric computations, the start of each interval is exclusive and the end of each interval is inclusive. IoT SiteWise places the computed data point at the end of the interval.</p>
        pub fn set_interval(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.interval = input;
            self
        }
        /// <p>The offset for the tumbling window. The <code>offset</code> parameter accepts the following:</p>
        /// <ul>
        /// <li> <p>The offset time.</p> <p>For example, if you specify <code>18h</code> for <code>offset</code> and <code>1d</code> for <code>interval</code>, IoT SiteWise aggregates data in one of the following ways:</p>
        /// <ul>
        /// <li> <p>If you create the metric before or at 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) on the day when you create the metric.</p> </li>
        /// <li> <p>If you create the metric after 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) the next day.</p> </li>
        /// </ul> </li>
        /// <li> <p>The ISO 8601 format.</p> <p>For example, if you specify <code>PT18H</code> for <code>offset</code> and <code>1d</code> for <code>interval</code>, IoT SiteWise aggregates data in one of the following ways:</p>
        /// <ul>
        /// <li> <p>If you create the metric before or at 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) on the day when you create the metric.</p> </li>
        /// <li> <p>If you create the metric after 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) the next day.</p> </li>
        /// </ul> </li>
        /// <li> <p>The 24-hour clock.</p> <p>For example, if you specify <code>00:03:00</code> for <code>offset</code>, <code>5m</code> for <code>interval</code>, and you create the metric at 2 PM (UTC), you get the first aggregation result at 2:03 PM (UTC). You get the second aggregation result at 2:08 PM (UTC). </p> </li>
        /// <li> <p>The offset time zone.</p> <p>For example, if you specify <code>2021-07-23T18:00-08</code> for <code>offset</code> and <code>1d</code> for <code>interval</code>, IoT SiteWise aggregates data in one of the following ways:</p>
        /// <ul>
        /// <li> <p>If you create the metric before or at 6 PM (PST), you get the first aggregation result at 6 PM (PST) on the day when you create the metric.</p> </li>
        /// <li> <p>If you create the metric after 6 PM (PST), you get the first aggregation result at 6 PM (PST) the next day.</p> </li>
        /// </ul> </li>
        /// </ul>
        pub fn offset(mut self, input: impl Into<std::string::String>) -> Self {
            self.offset = Some(input.into());
            self
        }
        /// <p>The offset for the tumbling window. The <code>offset</code> parameter accepts the following:</p>
        /// <ul>
        /// <li> <p>The offset time.</p> <p>For example, if you specify <code>18h</code> for <code>offset</code> and <code>1d</code> for <code>interval</code>, IoT SiteWise aggregates data in one of the following ways:</p>
        /// <ul>
        /// <li> <p>If you create the metric before or at 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) on the day when you create the metric.</p> </li>
        /// <li> <p>If you create the metric after 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) the next day.</p> </li>
        /// </ul> </li>
        /// <li> <p>The ISO 8601 format.</p> <p>For example, if you specify <code>PT18H</code> for <code>offset</code> and <code>1d</code> for <code>interval</code>, IoT SiteWise aggregates data in one of the following ways:</p>
        /// <ul>
        /// <li> <p>If you create the metric before or at 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) on the day when you create the metric.</p> </li>
        /// <li> <p>If you create the metric after 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) the next day.</p> </li>
        /// </ul> </li>
        /// <li> <p>The 24-hour clock.</p> <p>For example, if you specify <code>00:03:00</code> for <code>offset</code>, <code>5m</code> for <code>interval</code>, and you create the metric at 2 PM (UTC), you get the first aggregation result at 2:03 PM (UTC). You get the second aggregation result at 2:08 PM (UTC). </p> </li>
        /// <li> <p>The offset time zone.</p> <p>For example, if you specify <code>2021-07-23T18:00-08</code> for <code>offset</code> and <code>1d</code> for <code>interval</code>, IoT SiteWise aggregates data in one of the following ways:</p>
        /// <ul>
        /// <li> <p>If you create the metric before or at 6 PM (PST), you get the first aggregation result at 6 PM (PST) on the day when you create the metric.</p> </li>
        /// <li> <p>If you create the metric after 6 PM (PST), you get the first aggregation result at 6 PM (PST) the next day.</p> </li>
        /// </ul> </li>
        /// </ul>
        pub fn set_offset(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.offset = input;
            self
        }
        /// Consumes the builder and constructs a [`TumblingWindow`](crate::model::TumblingWindow).
        pub fn build(self) -> crate::model::TumblingWindow {
            crate::model::TumblingWindow {
                interval: self.interval,
                offset: self.offset,
            }
        }
    }
}
impl TumblingWindow {
    /// Creates a new builder-style object to manufacture [`TumblingWindow`](crate::model::TumblingWindow).
    pub fn builder() -> crate::model::tumbling_window::Builder {
        crate::model::tumbling_window::Builder::default()
    }
}

/// <p>Contains expression variable information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExpressionVariable {
    /// <p>The friendly name of the variable to be used in the expression.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The variable that identifies an asset property from which to use values.</p>
    #[doc(hidden)]
    pub value: std::option::Option<crate::model::VariableValue>,
}
impl ExpressionVariable {
    /// <p>The friendly name of the variable to be used in the expression.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The variable that identifies an asset property from which to use values.</p>
    pub fn value(&self) -> std::option::Option<&crate::model::VariableValue> {
        self.value.as_ref()
    }
}
/// See [`ExpressionVariable`](crate::model::ExpressionVariable).
pub mod expression_variable {

    /// A builder for [`ExpressionVariable`](crate::model::ExpressionVariable).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<crate::model::VariableValue>,
    }
    impl Builder {
        /// <p>The friendly name of the variable to be used in the expression.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The friendly name of the variable to be used in the expression.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The variable that identifies an asset property from which to use values.</p>
        pub fn value(mut self, input: crate::model::VariableValue) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The variable that identifies an asset property from which to use values.</p>
        pub fn set_value(
            mut self,
            input: std::option::Option<crate::model::VariableValue>,
        ) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`ExpressionVariable`](crate::model::ExpressionVariable).
        pub fn build(self) -> crate::model::ExpressionVariable {
            crate::model::ExpressionVariable {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl ExpressionVariable {
    /// Creates a new builder-style object to manufacture [`ExpressionVariable`](crate::model::ExpressionVariable).
    pub fn builder() -> crate::model::expression_variable::Builder {
        crate::model::expression_variable::Builder::default()
    }
}

/// <p>Identifies a property value used in an expression.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VariableValue {
    /// <p>The ID of the property to use as the variable. You can use the property <code>name</code> if it's from the same asset model.</p>
    #[doc(hidden)]
    pub property_id: std::option::Option<std::string::String>,
    /// <p>The ID of the hierarchy to query for the property ID. You can use the hierarchy's name instead of the hierarchy's ID.</p>
    /// <p>You use a hierarchy ID instead of a model ID because you can have several hierarchies using the same model and therefore the same <code>propertyId</code>. For example, you might have separately grouped assets that come from the same asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html">Asset hierarchies</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub hierarchy_id: std::option::Option<std::string::String>,
}
impl VariableValue {
    /// <p>The ID of the property to use as the variable. You can use the property <code>name</code> if it's from the same asset model.</p>
    pub fn property_id(&self) -> std::option::Option<&str> {
        self.property_id.as_deref()
    }
    /// <p>The ID of the hierarchy to query for the property ID. You can use the hierarchy's name instead of the hierarchy's ID.</p>
    /// <p>You use a hierarchy ID instead of a model ID because you can have several hierarchies using the same model and therefore the same <code>propertyId</code>. For example, you might have separately grouped assets that come from the same asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html">Asset hierarchies</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn hierarchy_id(&self) -> std::option::Option<&str> {
        self.hierarchy_id.as_deref()
    }
}
/// See [`VariableValue`](crate::model::VariableValue).
pub mod variable_value {

    /// A builder for [`VariableValue`](crate::model::VariableValue).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) property_id: std::option::Option<std::string::String>,
        pub(crate) hierarchy_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the property to use as the variable. You can use the property <code>name</code> if it's from the same asset model.</p>
        pub fn property_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_id = Some(input.into());
            self
        }
        /// <p>The ID of the property to use as the variable. You can use the property <code>name</code> if it's from the same asset model.</p>
        pub fn set_property_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.property_id = input;
            self
        }
        /// <p>The ID of the hierarchy to query for the property ID. You can use the hierarchy's name instead of the hierarchy's ID.</p>
        /// <p>You use a hierarchy ID instead of a model ID because you can have several hierarchies using the same model and therefore the same <code>propertyId</code>. For example, you might have separately grouped assets that come from the same asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html">Asset hierarchies</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn hierarchy_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hierarchy_id = Some(input.into());
            self
        }
        /// <p>The ID of the hierarchy to query for the property ID. You can use the hierarchy's name instead of the hierarchy's ID.</p>
        /// <p>You use a hierarchy ID instead of a model ID because you can have several hierarchies using the same model and therefore the same <code>propertyId</code>. For example, you might have separately grouped assets that come from the same asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html">Asset hierarchies</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_hierarchy_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hierarchy_id = input;
            self
        }
        /// Consumes the builder and constructs a [`VariableValue`](crate::model::VariableValue).
        pub fn build(self) -> crate::model::VariableValue {
            crate::model::VariableValue {
                property_id: self.property_id,
                hierarchy_id: self.hierarchy_id,
            }
        }
    }
}
impl VariableValue {
    /// Creates a new builder-style object to manufacture [`VariableValue`](crate::model::VariableValue).
    pub fn builder() -> crate::model::variable_value::Builder {
        crate::model::variable_value::Builder::default()
    }
}

/// <p>Contains an asset transform property. A transform is a one-to-one mapping of a property's data points from one form to another. For example, you can use a transform to convert a Celsius data stream to Fahrenheit by applying the transformation expression to each data point of the Celsius stream. A transform can only have a data type of <code>DOUBLE</code> and consume properties with data types of <code>INTEGER</code> or <code>DOUBLE</code>.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html#transforms">Transforms</a> in the <i>IoT SiteWise User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Transform {
    /// <p>The mathematical expression that defines the transformation function. You can specify up to 10 variables per expression. You can specify up to 10 functions per expression. </p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub expression: std::option::Option<std::string::String>,
    /// <p>The list of variables used in the expression.</p>
    #[doc(hidden)]
    pub variables: std::option::Option<std::vec::Vec<crate::model::ExpressionVariable>>,
    /// <p>The processing configuration for the given transform property. You can configure transforms to be kept at the edge or forwarded to the Amazon Web Services Cloud. You can also configure transforms to be computed at the edge or in the cloud.</p>
    #[doc(hidden)]
    pub processing_config: std::option::Option<crate::model::TransformProcessingConfig>,
}
impl Transform {
    /// <p>The mathematical expression that defines the transformation function. You can specify up to 10 variables per expression. You can specify up to 10 functions per expression. </p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn expression(&self) -> std::option::Option<&str> {
        self.expression.as_deref()
    }
    /// <p>The list of variables used in the expression.</p>
    pub fn variables(&self) -> std::option::Option<&[crate::model::ExpressionVariable]> {
        self.variables.as_deref()
    }
    /// <p>The processing configuration for the given transform property. You can configure transforms to be kept at the edge or forwarded to the Amazon Web Services Cloud. You can also configure transforms to be computed at the edge or in the cloud.</p>
    pub fn processing_config(
        &self,
    ) -> std::option::Option<&crate::model::TransformProcessingConfig> {
        self.processing_config.as_ref()
    }
}
/// See [`Transform`](crate::model::Transform).
pub mod transform {

    /// A builder for [`Transform`](crate::model::Transform).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) expression: std::option::Option<std::string::String>,
        pub(crate) variables: std::option::Option<std::vec::Vec<crate::model::ExpressionVariable>>,
        pub(crate) processing_config: std::option::Option<crate::model::TransformProcessingConfig>,
    }
    impl Builder {
        /// <p>The mathematical expression that defines the transformation function. You can specify up to 10 variables per expression. You can specify up to 10 functions per expression. </p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.expression = Some(input.into());
            self
        }
        /// <p>The mathematical expression that defines the transformation function. You can specify up to 10 variables per expression. You can specify up to 10 functions per expression. </p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_expression(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.expression = input;
            self
        }
        /// Appends an item to `variables`.
        ///
        /// To override the contents of this collection use [`set_variables`](Self::set_variables).
        ///
        /// <p>The list of variables used in the expression.</p>
        pub fn variables(mut self, input: crate::model::ExpressionVariable) -> Self {
            let mut v = self.variables.unwrap_or_default();
            v.push(input);
            self.variables = Some(v);
            self
        }
        /// <p>The list of variables used in the expression.</p>
        pub fn set_variables(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ExpressionVariable>>,
        ) -> Self {
            self.variables = input;
            self
        }
        /// <p>The processing configuration for the given transform property. You can configure transforms to be kept at the edge or forwarded to the Amazon Web Services Cloud. You can also configure transforms to be computed at the edge or in the cloud.</p>
        pub fn processing_config(mut self, input: crate::model::TransformProcessingConfig) -> Self {
            self.processing_config = Some(input);
            self
        }
        /// <p>The processing configuration for the given transform property. You can configure transforms to be kept at the edge or forwarded to the Amazon Web Services Cloud. You can also configure transforms to be computed at the edge or in the cloud.</p>
        pub fn set_processing_config(
            mut self,
            input: std::option::Option<crate::model::TransformProcessingConfig>,
        ) -> Self {
            self.processing_config = input;
            self
        }
        /// Consumes the builder and constructs a [`Transform`](crate::model::Transform).
        pub fn build(self) -> crate::model::Transform {
            crate::model::Transform {
                expression: self.expression,
                variables: self.variables,
                processing_config: self.processing_config,
            }
        }
    }
}
impl Transform {
    /// Creates a new builder-style object to manufacture [`Transform`](crate::model::Transform).
    pub fn builder() -> crate::model::transform::Builder {
        crate::model::transform::Builder::default()
    }
}

/// <p>The processing configuration for the given transform property. You can configure transforms to be kept at the edge or forwarded to the Amazon Web Services Cloud. You can also configure transforms to be computed at the edge or in the cloud.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TransformProcessingConfig {
    /// <p>The compute location for the given transform property. </p>
    #[doc(hidden)]
    pub compute_location: std::option::Option<crate::model::ComputeLocation>,
    /// <p>The forwarding configuration for a given property.</p>
    #[doc(hidden)]
    pub forwarding_config: std::option::Option<crate::model::ForwardingConfig>,
}
impl TransformProcessingConfig {
    /// <p>The compute location for the given transform property. </p>
    pub fn compute_location(&self) -> std::option::Option<&crate::model::ComputeLocation> {
        self.compute_location.as_ref()
    }
    /// <p>The forwarding configuration for a given property.</p>
    pub fn forwarding_config(&self) -> std::option::Option<&crate::model::ForwardingConfig> {
        self.forwarding_config.as_ref()
    }
}
/// See [`TransformProcessingConfig`](crate::model::TransformProcessingConfig).
pub mod transform_processing_config {

    /// A builder for [`TransformProcessingConfig`](crate::model::TransformProcessingConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) compute_location: std::option::Option<crate::model::ComputeLocation>,
        pub(crate) forwarding_config: std::option::Option<crate::model::ForwardingConfig>,
    }
    impl Builder {
        /// <p>The compute location for the given transform property. </p>
        pub fn compute_location(mut self, input: crate::model::ComputeLocation) -> Self {
            self.compute_location = Some(input);
            self
        }
        /// <p>The compute location for the given transform property. </p>
        pub fn set_compute_location(
            mut self,
            input: std::option::Option<crate::model::ComputeLocation>,
        ) -> Self {
            self.compute_location = input;
            self
        }
        /// <p>The forwarding configuration for a given property.</p>
        pub fn forwarding_config(mut self, input: crate::model::ForwardingConfig) -> Self {
            self.forwarding_config = Some(input);
            self
        }
        /// <p>The forwarding configuration for a given property.</p>
        pub fn set_forwarding_config(
            mut self,
            input: std::option::Option<crate::model::ForwardingConfig>,
        ) -> Self {
            self.forwarding_config = input;
            self
        }
        /// Consumes the builder and constructs a [`TransformProcessingConfig`](crate::model::TransformProcessingConfig).
        pub fn build(self) -> crate::model::TransformProcessingConfig {
            crate::model::TransformProcessingConfig {
                compute_location: self.compute_location,
                forwarding_config: self.forwarding_config,
            }
        }
    }
}
impl TransformProcessingConfig {
    /// Creates a new builder-style object to manufacture [`TransformProcessingConfig`](crate::model::TransformProcessingConfig).
    pub fn builder() -> crate::model::transform_processing_config::Builder {
        crate::model::transform_processing_config::Builder::default()
    }
}

/// <p>The forwarding configuration for a given property.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ForwardingConfig {
    /// <p>The forwarding state for the given property. </p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::ForwardingConfigState>,
}
impl ForwardingConfig {
    /// <p>The forwarding state for the given property. </p>
    pub fn state(&self) -> std::option::Option<&crate::model::ForwardingConfigState> {
        self.state.as_ref()
    }
}
/// See [`ForwardingConfig`](crate::model::ForwardingConfig).
pub mod forwarding_config {

    /// A builder for [`ForwardingConfig`](crate::model::ForwardingConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) state: std::option::Option<crate::model::ForwardingConfigState>,
    }
    impl Builder {
        /// <p>The forwarding state for the given property. </p>
        pub fn state(mut self, input: crate::model::ForwardingConfigState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The forwarding state for the given property. </p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::ForwardingConfigState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`ForwardingConfig`](crate::model::ForwardingConfig).
        pub fn build(self) -> crate::model::ForwardingConfig {
            crate::model::ForwardingConfig { state: self.state }
        }
    }
}
impl ForwardingConfig {
    /// Creates a new builder-style object to manufacture [`ForwardingConfig`](crate::model::ForwardingConfig).
    pub fn builder() -> crate::model::forwarding_config::Builder {
        crate::model::forwarding_config::Builder::default()
    }
}

/// When writing a match expression against `ForwardingConfigState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let forwardingconfigstate = unimplemented!();
/// match forwardingconfigstate {
///     ForwardingConfigState::Disabled => { /* ... */ },
///     ForwardingConfigState::Enabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `forwardingconfigstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ForwardingConfigState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ForwardingConfigState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ForwardingConfigState::NewFeature` is defined.
/// Specifically, when `forwardingconfigstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ForwardingConfigState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ForwardingConfigState {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ForwardingConfigState {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => ForwardingConfigState::Disabled,
            "ENABLED" => ForwardingConfigState::Enabled,
            other => {
                ForwardingConfigState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ForwardingConfigState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ForwardingConfigState::from(s))
    }
}
impl ForwardingConfigState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ForwardingConfigState::Disabled => "DISABLED",
            ForwardingConfigState::Enabled => "ENABLED",
            ForwardingConfigState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for ForwardingConfigState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains an asset measurement property. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html#measurements">Measurements</a> in the <i>IoT SiteWise User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Measurement {
    /// <p>The processing configuration for the given measurement property. You can configure measurements to be kept at the edge or forwarded to the Amazon Web Services Cloud. By default, measurements are forwarded to the cloud.</p>
    #[doc(hidden)]
    pub processing_config: std::option::Option<crate::model::MeasurementProcessingConfig>,
}
impl Measurement {
    /// <p>The processing configuration for the given measurement property. You can configure measurements to be kept at the edge or forwarded to the Amazon Web Services Cloud. By default, measurements are forwarded to the cloud.</p>
    pub fn processing_config(
        &self,
    ) -> std::option::Option<&crate::model::MeasurementProcessingConfig> {
        self.processing_config.as_ref()
    }
}
/// See [`Measurement`](crate::model::Measurement).
pub mod measurement {

    /// A builder for [`Measurement`](crate::model::Measurement).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) processing_config:
            std::option::Option<crate::model::MeasurementProcessingConfig>,
    }
    impl Builder {
        /// <p>The processing configuration for the given measurement property. You can configure measurements to be kept at the edge or forwarded to the Amazon Web Services Cloud. By default, measurements are forwarded to the cloud.</p>
        pub fn processing_config(
            mut self,
            input: crate::model::MeasurementProcessingConfig,
        ) -> Self {
            self.processing_config = Some(input);
            self
        }
        /// <p>The processing configuration for the given measurement property. You can configure measurements to be kept at the edge or forwarded to the Amazon Web Services Cloud. By default, measurements are forwarded to the cloud.</p>
        pub fn set_processing_config(
            mut self,
            input: std::option::Option<crate::model::MeasurementProcessingConfig>,
        ) -> Self {
            self.processing_config = input;
            self
        }
        /// Consumes the builder and constructs a [`Measurement`](crate::model::Measurement).
        pub fn build(self) -> crate::model::Measurement {
            crate::model::Measurement {
                processing_config: self.processing_config,
            }
        }
    }
}
impl Measurement {
    /// Creates a new builder-style object to manufacture [`Measurement`](crate::model::Measurement).
    pub fn builder() -> crate::model::measurement::Builder {
        crate::model::measurement::Builder::default()
    }
}

/// <p>The processing configuration for the given measurement property. You can configure measurements to be kept at the edge or forwarded to the Amazon Web Services Cloud. By default, measurements are forwarded to the cloud.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MeasurementProcessingConfig {
    /// <p>The forwarding configuration for the given measurement property. </p>
    #[doc(hidden)]
    pub forwarding_config: std::option::Option<crate::model::ForwardingConfig>,
}
impl MeasurementProcessingConfig {
    /// <p>The forwarding configuration for the given measurement property. </p>
    pub fn forwarding_config(&self) -> std::option::Option<&crate::model::ForwardingConfig> {
        self.forwarding_config.as_ref()
    }
}
/// See [`MeasurementProcessingConfig`](crate::model::MeasurementProcessingConfig).
pub mod measurement_processing_config {

    /// A builder for [`MeasurementProcessingConfig`](crate::model::MeasurementProcessingConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) forwarding_config: std::option::Option<crate::model::ForwardingConfig>,
    }
    impl Builder {
        /// <p>The forwarding configuration for the given measurement property. </p>
        pub fn forwarding_config(mut self, input: crate::model::ForwardingConfig) -> Self {
            self.forwarding_config = Some(input);
            self
        }
        /// <p>The forwarding configuration for the given measurement property. </p>
        pub fn set_forwarding_config(
            mut self,
            input: std::option::Option<crate::model::ForwardingConfig>,
        ) -> Self {
            self.forwarding_config = input;
            self
        }
        /// Consumes the builder and constructs a [`MeasurementProcessingConfig`](crate::model::MeasurementProcessingConfig).
        pub fn build(self) -> crate::model::MeasurementProcessingConfig {
            crate::model::MeasurementProcessingConfig {
                forwarding_config: self.forwarding_config,
            }
        }
    }
}
impl MeasurementProcessingConfig {
    /// Creates a new builder-style object to manufacture [`MeasurementProcessingConfig`](crate::model::MeasurementProcessingConfig).
    pub fn builder() -> crate::model::measurement_processing_config::Builder {
        crate::model::measurement_processing_config::Builder::default()
    }
}

/// <p>Contains an asset attribute property. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html#attributes">Attributes</a> in the <i>IoT SiteWise User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Attribute {
    /// <p>The default value of the asset model property attribute. All assets that you create from the asset model contain this attribute value. You can update an attribute's value after you create an asset. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/update-attribute-values.html">Updating attribute values</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub default_value: std::option::Option<std::string::String>,
}
impl Attribute {
    /// <p>The default value of the asset model property attribute. All assets that you create from the asset model contain this attribute value. You can update an attribute's value after you create an asset. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/update-attribute-values.html">Updating attribute values</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn default_value(&self) -> std::option::Option<&str> {
        self.default_value.as_deref()
    }
}
/// See [`Attribute`](crate::model::Attribute).
pub mod attribute {

    /// A builder for [`Attribute`](crate::model::Attribute).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) default_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The default value of the asset model property attribute. All assets that you create from the asset model contain this attribute value. You can update an attribute's value after you create an asset. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/update-attribute-values.html">Updating attribute values</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn default_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_value = Some(input.into());
            self
        }
        /// <p>The default value of the asset model property attribute. All assets that you create from the asset model contain this attribute value. You can update an attribute's value after you create an asset. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/update-attribute-values.html">Updating attribute values</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_default_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_value = input;
            self
        }
        /// Consumes the builder and constructs a [`Attribute`](crate::model::Attribute).
        pub fn build(self) -> crate::model::Attribute {
            crate::model::Attribute {
                default_value: self.default_value,
            }
        }
    }
}
impl Attribute {
    /// Creates a new builder-style object to manufacture [`Attribute`](crate::model::Attribute).
    pub fn builder() -> crate::model::attribute::Builder {
        crate::model::attribute::Builder::default()
    }
}

/// When writing a match expression against `PropertyDataType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let propertydatatype = unimplemented!();
/// match propertydatatype {
///     PropertyDataType::Boolean => { /* ... */ },
///     PropertyDataType::Double => { /* ... */ },
///     PropertyDataType::Integer => { /* ... */ },
///     PropertyDataType::String => { /* ... */ },
///     PropertyDataType::Struct => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `propertydatatype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PropertyDataType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PropertyDataType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PropertyDataType::NewFeature` is defined.
/// Specifically, when `propertydatatype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PropertyDataType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PropertyDataType {
    #[allow(missing_docs)] // documentation missing in model
    Boolean,
    #[allow(missing_docs)] // documentation missing in model
    Double,
    #[allow(missing_docs)] // documentation missing in model
    Integer,
    #[allow(missing_docs)] // documentation missing in model
    String,
    #[allow(missing_docs)] // documentation missing in model
    Struct,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PropertyDataType {
    fn from(s: &str) -> Self {
        match s {
            "BOOLEAN" => PropertyDataType::Boolean,
            "DOUBLE" => PropertyDataType::Double,
            "INTEGER" => PropertyDataType::Integer,
            "STRING" => PropertyDataType::String,
            "STRUCT" => PropertyDataType::Struct,
            other => PropertyDataType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PropertyDataType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PropertyDataType::from(s))
    }
}
impl PropertyDataType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PropertyDataType::Boolean => "BOOLEAN",
            PropertyDataType::Double => "DOUBLE",
            PropertyDataType::Integer => "INTEGER",
            PropertyDataType::String => "STRING",
            PropertyDataType::Struct => "STRUCT",
            PropertyDataType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["BOOLEAN", "DOUBLE", "INTEGER", "STRING", "STRUCT"]
    }
}
impl AsRef<str> for PropertyDataType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes an asset hierarchy that contains a hierarchy's name, ID, and child asset model ID that specifies the type of asset that can be in this hierarchy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssetModelHierarchy {
    /// <p>The ID of the asset model hierarchy. This ID is a <code>hierarchyId</code>.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the asset model hierarchy that you specify by using the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_CreateAssetModel.html">CreateAssetModel</a> or <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetModel.html">UpdateAssetModel</a> API operation.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The ID of the asset model. All assets in this hierarchy must be instances of the <code>childAssetModelId</code> asset model.</p>
    #[doc(hidden)]
    pub child_asset_model_id: std::option::Option<std::string::String>,
}
impl AssetModelHierarchy {
    /// <p>The ID of the asset model hierarchy. This ID is a <code>hierarchyId</code>.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the asset model hierarchy that you specify by using the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_CreateAssetModel.html">CreateAssetModel</a> or <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetModel.html">UpdateAssetModel</a> API operation.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The ID of the asset model. All assets in this hierarchy must be instances of the <code>childAssetModelId</code> asset model.</p>
    pub fn child_asset_model_id(&self) -> std::option::Option<&str> {
        self.child_asset_model_id.as_deref()
    }
}
/// See [`AssetModelHierarchy`](crate::model::AssetModelHierarchy).
pub mod asset_model_hierarchy {

    /// A builder for [`AssetModelHierarchy`](crate::model::AssetModelHierarchy).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) child_asset_model_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the asset model hierarchy. This ID is a <code>hierarchyId</code>.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the asset model hierarchy. This ID is a <code>hierarchyId</code>.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the asset model hierarchy that you specify by using the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_CreateAssetModel.html">CreateAssetModel</a> or <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetModel.html">UpdateAssetModel</a> API operation.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the asset model hierarchy that you specify by using the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_CreateAssetModel.html">CreateAssetModel</a> or <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetModel.html">UpdateAssetModel</a> API operation.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The ID of the asset model. All assets in this hierarchy must be instances of the <code>childAssetModelId</code> asset model.</p>
        pub fn child_asset_model_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.child_asset_model_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset model. All assets in this hierarchy must be instances of the <code>childAssetModelId</code> asset model.</p>
        pub fn set_child_asset_model_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.child_asset_model_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AssetModelHierarchy`](crate::model::AssetModelHierarchy).
        pub fn build(self) -> crate::model::AssetModelHierarchy {
            crate::model::AssetModelHierarchy {
                id: self.id,
                name: self.name,
                child_asset_model_id: self.child_asset_model_id,
            }
        }
    }
}
impl AssetModelHierarchy {
    /// Creates a new builder-style object to manufacture [`AssetModelHierarchy`](crate::model::AssetModelHierarchy).
    pub fn builder() -> crate::model::asset_model_hierarchy::Builder {
        crate::model::asset_model_hierarchy::Builder::default()
    }
}

/// <p>Contains information about the current status of an asset. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-and-model-states.html">Asset and model states</a> in the <i>IoT SiteWise User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssetStatus {
    /// <p>The current status of the asset.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::AssetState>,
    /// <p>Contains associated error information, if any.</p>
    #[doc(hidden)]
    pub error: std::option::Option<crate::model::ErrorDetails>,
}
impl AssetStatus {
    /// <p>The current status of the asset.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::AssetState> {
        self.state.as_ref()
    }
    /// <p>Contains associated error information, if any.</p>
    pub fn error(&self) -> std::option::Option<&crate::model::ErrorDetails> {
        self.error.as_ref()
    }
}
/// See [`AssetStatus`](crate::model::AssetStatus).
pub mod asset_status {

    /// A builder for [`AssetStatus`](crate::model::AssetStatus).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) state: std::option::Option<crate::model::AssetState>,
        pub(crate) error: std::option::Option<crate::model::ErrorDetails>,
    }
    impl Builder {
        /// <p>The current status of the asset.</p>
        pub fn state(mut self, input: crate::model::AssetState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current status of the asset.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::AssetState>) -> Self {
            self.state = input;
            self
        }
        /// <p>Contains associated error information, if any.</p>
        pub fn error(mut self, input: crate::model::ErrorDetails) -> Self {
            self.error = Some(input);
            self
        }
        /// <p>Contains associated error information, if any.</p>
        pub fn set_error(mut self, input: std::option::Option<crate::model::ErrorDetails>) -> Self {
            self.error = input;
            self
        }
        /// Consumes the builder and constructs a [`AssetStatus`](crate::model::AssetStatus).
        pub fn build(self) -> crate::model::AssetStatus {
            crate::model::AssetStatus {
                state: self.state,
                error: self.error,
            }
        }
    }
}
impl AssetStatus {
    /// Creates a new builder-style object to manufacture [`AssetStatus`](crate::model::AssetStatus).
    pub fn builder() -> crate::model::asset_status::Builder {
        crate::model::asset_status::Builder::default()
    }
}

/// When writing a match expression against `AssetState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let assetstate = unimplemented!();
/// match assetstate {
///     AssetState::Active => { /* ... */ },
///     AssetState::Creating => { /* ... */ },
///     AssetState::Deleting => { /* ... */ },
///     AssetState::Failed => { /* ... */ },
///     AssetState::Updating => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `assetstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AssetState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AssetState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AssetState::NewFeature` is defined.
/// Specifically, when `assetstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AssetState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AssetState {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AssetState {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => AssetState::Active,
            "CREATING" => AssetState::Creating,
            "DELETING" => AssetState::Deleting,
            "FAILED" => AssetState::Failed,
            "UPDATING" => AssetState::Updating,
            other => AssetState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AssetState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AssetState::from(s))
    }
}
impl AssetState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AssetState::Active => "ACTIVE",
            AssetState::Creating => "CREATING",
            AssetState::Deleting => "DELETING",
            AssetState::Failed => "FAILED",
            AssetState::Updating => "UPDATING",
            AssetState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "CREATING", "DELETING", "FAILED", "UPDATING"]
    }
}
impl AsRef<str> for AssetState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `Permission`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let permission = unimplemented!();
/// match permission {
///     Permission::Administrator => { /* ... */ },
///     Permission::Viewer => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `permission` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Permission::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Permission::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Permission::NewFeature` is defined.
/// Specifically, when `permission` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Permission::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Permission {
    #[allow(missing_docs)] // documentation missing in model
    Administrator,
    #[allow(missing_docs)] // documentation missing in model
    Viewer,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Permission {
    fn from(s: &str) -> Self {
        match s {
            "ADMINISTRATOR" => Permission::Administrator,
            "VIEWER" => Permission::Viewer,
            other => Permission::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Permission {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Permission::from(s))
    }
}
impl Permission {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Permission::Administrator => "ADMINISTRATOR",
            Permission::Viewer => "VIEWER",
            Permission::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ADMINISTRATOR", "VIEWER"]
    }
}
impl AsRef<str> for Permission {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains an IoT SiteWise Monitor resource ID for a portal or project.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Resource {
    /// <p>A portal resource.</p>
    #[doc(hidden)]
    pub portal: std::option::Option<crate::model::PortalResource>,
    /// <p>A project resource.</p>
    #[doc(hidden)]
    pub project: std::option::Option<crate::model::ProjectResource>,
}
impl Resource {
    /// <p>A portal resource.</p>
    pub fn portal(&self) -> std::option::Option<&crate::model::PortalResource> {
        self.portal.as_ref()
    }
    /// <p>A project resource.</p>
    pub fn project(&self) -> std::option::Option<&crate::model::ProjectResource> {
        self.project.as_ref()
    }
}
/// See [`Resource`](crate::model::Resource).
pub mod resource {

    /// A builder for [`Resource`](crate::model::Resource).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) portal: std::option::Option<crate::model::PortalResource>,
        pub(crate) project: std::option::Option<crate::model::ProjectResource>,
    }
    impl Builder {
        /// <p>A portal resource.</p>
        pub fn portal(mut self, input: crate::model::PortalResource) -> Self {
            self.portal = Some(input);
            self
        }
        /// <p>A portal resource.</p>
        pub fn set_portal(
            mut self,
            input: std::option::Option<crate::model::PortalResource>,
        ) -> Self {
            self.portal = input;
            self
        }
        /// <p>A project resource.</p>
        pub fn project(mut self, input: crate::model::ProjectResource) -> Self {
            self.project = Some(input);
            self
        }
        /// <p>A project resource.</p>
        pub fn set_project(
            mut self,
            input: std::option::Option<crate::model::ProjectResource>,
        ) -> Self {
            self.project = input;
            self
        }
        /// Consumes the builder and constructs a [`Resource`](crate::model::Resource).
        pub fn build(self) -> crate::model::Resource {
            crate::model::Resource {
                portal: self.portal,
                project: self.project,
            }
        }
    }
}
impl Resource {
    /// Creates a new builder-style object to manufacture [`Resource`](crate::model::Resource).
    pub fn builder() -> crate::model::resource::Builder {
        crate::model::resource::Builder::default()
    }
}

/// <p>Identifies a specific IoT SiteWise Monitor project.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProjectResource {
    /// <p>The ID of the project.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl ProjectResource {
    /// <p>The ID of the project.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
}
/// See [`ProjectResource`](crate::model::ProjectResource).
pub mod project_resource {

    /// A builder for [`ProjectResource`](crate::model::ProjectResource).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the project.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the project.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`ProjectResource`](crate::model::ProjectResource).
        pub fn build(self) -> crate::model::ProjectResource {
            crate::model::ProjectResource { id: self.id }
        }
    }
}
impl ProjectResource {
    /// Creates a new builder-style object to manufacture [`ProjectResource`](crate::model::ProjectResource).
    pub fn builder() -> crate::model::project_resource::Builder {
        crate::model::project_resource::Builder::default()
    }
}

/// <p>Identifies an IoT SiteWise Monitor portal.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PortalResource {
    /// <p>The ID of the portal.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl PortalResource {
    /// <p>The ID of the portal.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
}
/// See [`PortalResource`](crate::model::PortalResource).
pub mod portal_resource {

    /// A builder for [`PortalResource`](crate::model::PortalResource).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the portal.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the portal.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`PortalResource`](crate::model::PortalResource).
        pub fn build(self) -> crate::model::PortalResource {
            crate::model::PortalResource { id: self.id }
        }
    }
}
impl PortalResource {
    /// Creates a new builder-style object to manufacture [`PortalResource`](crate::model::PortalResource).
    pub fn builder() -> crate::model::portal_resource::Builder {
        crate::model::portal_resource::Builder::default()
    }
}

/// <p>Contains an identity that can access an IoT SiteWise Monitor resource.</p> <note>
/// <p>Currently, you can't use Amazon Web Services APIs to retrieve IAM Identity Center identity IDs. You can find the IAM Identity Center identity IDs in the URL of user and group pages in the <a href="https://console.aws.amazon.com/singlesignon">IAM Identity Center console</a>.</p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Identity {
    /// <p>An IAM Identity Center user identity.</p>
    #[doc(hidden)]
    pub user: std::option::Option<crate::model::UserIdentity>,
    /// <p>An IAM Identity Center group identity.</p>
    #[doc(hidden)]
    pub group: std::option::Option<crate::model::GroupIdentity>,
    /// <p>An IAM user identity.</p>
    #[doc(hidden)]
    pub iam_user: std::option::Option<crate::model::IamUserIdentity>,
    /// <p>An IAM role identity.</p>
    #[doc(hidden)]
    pub iam_role: std::option::Option<crate::model::IamRoleIdentity>,
}
impl Identity {
    /// <p>An IAM Identity Center user identity.</p>
    pub fn user(&self) -> std::option::Option<&crate::model::UserIdentity> {
        self.user.as_ref()
    }
    /// <p>An IAM Identity Center group identity.</p>
    pub fn group(&self) -> std::option::Option<&crate::model::GroupIdentity> {
        self.group.as_ref()
    }
    /// <p>An IAM user identity.</p>
    pub fn iam_user(&self) -> std::option::Option<&crate::model::IamUserIdentity> {
        self.iam_user.as_ref()
    }
    /// <p>An IAM role identity.</p>
    pub fn iam_role(&self) -> std::option::Option<&crate::model::IamRoleIdentity> {
        self.iam_role.as_ref()
    }
}
/// See [`Identity`](crate::model::Identity).
pub mod identity {

    /// A builder for [`Identity`](crate::model::Identity).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user: std::option::Option<crate::model::UserIdentity>,
        pub(crate) group: std::option::Option<crate::model::GroupIdentity>,
        pub(crate) iam_user: std::option::Option<crate::model::IamUserIdentity>,
        pub(crate) iam_role: std::option::Option<crate::model::IamRoleIdentity>,
    }
    impl Builder {
        /// <p>An IAM Identity Center user identity.</p>
        pub fn user(mut self, input: crate::model::UserIdentity) -> Self {
            self.user = Some(input);
            self
        }
        /// <p>An IAM Identity Center user identity.</p>
        pub fn set_user(mut self, input: std::option::Option<crate::model::UserIdentity>) -> Self {
            self.user = input;
            self
        }
        /// <p>An IAM Identity Center group identity.</p>
        pub fn group(mut self, input: crate::model::GroupIdentity) -> Self {
            self.group = Some(input);
            self
        }
        /// <p>An IAM Identity Center group identity.</p>
        pub fn set_group(
            mut self,
            input: std::option::Option<crate::model::GroupIdentity>,
        ) -> Self {
            self.group = input;
            self
        }
        /// <p>An IAM user identity.</p>
        pub fn iam_user(mut self, input: crate::model::IamUserIdentity) -> Self {
            self.iam_user = Some(input);
            self
        }
        /// <p>An IAM user identity.</p>
        pub fn set_iam_user(
            mut self,
            input: std::option::Option<crate::model::IamUserIdentity>,
        ) -> Self {
            self.iam_user = input;
            self
        }
        /// <p>An IAM role identity.</p>
        pub fn iam_role(mut self, input: crate::model::IamRoleIdentity) -> Self {
            self.iam_role = Some(input);
            self
        }
        /// <p>An IAM role identity.</p>
        pub fn set_iam_role(
            mut self,
            input: std::option::Option<crate::model::IamRoleIdentity>,
        ) -> Self {
            self.iam_role = input;
            self
        }
        /// Consumes the builder and constructs a [`Identity`](crate::model::Identity).
        pub fn build(self) -> crate::model::Identity {
            crate::model::Identity {
                user: self.user,
                group: self.group,
                iam_user: self.iam_user,
                iam_role: self.iam_role,
            }
        }
    }
}
impl Identity {
    /// Creates a new builder-style object to manufacture [`Identity`](crate::model::Identity).
    pub fn builder() -> crate::model::identity::Builder {
        crate::model::identity::Builder::default()
    }
}

/// <p>Contains information about an Identity and Access Management role. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html">IAM roles</a> in the <i>IAM User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IamRoleIdentity {
    /// <p>The ARN of the IAM role. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM ARNs</a> in the <i>IAM User Guide</i>.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
}
impl IamRoleIdentity {
    /// <p>The ARN of the IAM role. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM ARNs</a> in the <i>IAM User Guide</i>.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
/// See [`IamRoleIdentity`](crate::model::IamRoleIdentity).
pub mod iam_role_identity {

    /// A builder for [`IamRoleIdentity`](crate::model::IamRoleIdentity).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the IAM role. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM ARNs</a> in the <i>IAM User Guide</i>.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the IAM role. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM ARNs</a> in the <i>IAM User Guide</i>.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`IamRoleIdentity`](crate::model::IamRoleIdentity).
        pub fn build(self) -> crate::model::IamRoleIdentity {
            crate::model::IamRoleIdentity { arn: self.arn }
        }
    }
}
impl IamRoleIdentity {
    /// Creates a new builder-style object to manufacture [`IamRoleIdentity`](crate::model::IamRoleIdentity).
    pub fn builder() -> crate::model::iam_role_identity::Builder {
        crate::model::iam_role_identity::Builder::default()
    }
}

/// <p>Contains information about an Identity and Access Management user.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IamUserIdentity {
    /// <p>The ARN of the IAM user. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM ARNs</a> in the <i>IAM User Guide</i>.</p> <note>
    /// <p>If you delete the IAM user, access policies that contain this identity include an empty <code>arn</code>. You can delete the access policy for the IAM user that no longer exists.</p>
    /// </note>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
}
impl IamUserIdentity {
    /// <p>The ARN of the IAM user. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM ARNs</a> in the <i>IAM User Guide</i>.</p> <note>
    /// <p>If you delete the IAM user, access policies that contain this identity include an empty <code>arn</code>. You can delete the access policy for the IAM user that no longer exists.</p>
    /// </note>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
/// See [`IamUserIdentity`](crate::model::IamUserIdentity).
pub mod iam_user_identity {

    /// A builder for [`IamUserIdentity`](crate::model::IamUserIdentity).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the IAM user. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM ARNs</a> in the <i>IAM User Guide</i>.</p> <note>
        /// <p>If you delete the IAM user, access policies that contain this identity include an empty <code>arn</code>. You can delete the access policy for the IAM user that no longer exists.</p>
        /// </note>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the IAM user. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM ARNs</a> in the <i>IAM User Guide</i>.</p> <note>
        /// <p>If you delete the IAM user, access policies that contain this identity include an empty <code>arn</code>. You can delete the access policy for the IAM user that no longer exists.</p>
        /// </note>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`IamUserIdentity`](crate::model::IamUserIdentity).
        pub fn build(self) -> crate::model::IamUserIdentity {
            crate::model::IamUserIdentity { arn: self.arn }
        }
    }
}
impl IamUserIdentity {
    /// Creates a new builder-style object to manufacture [`IamUserIdentity`](crate::model::IamUserIdentity).
    pub fn builder() -> crate::model::iam_user_identity::Builder {
        crate::model::iam_user_identity::Builder::default()
    }
}

/// <p>Contains information for a group identity in an access policy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GroupIdentity {
    /// <p>The IAM Identity Center ID of the group.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl GroupIdentity {
    /// <p>The IAM Identity Center ID of the group.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
}
/// See [`GroupIdentity`](crate::model::GroupIdentity).
pub mod group_identity {

    /// A builder for [`GroupIdentity`](crate::model::GroupIdentity).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IAM Identity Center ID of the group.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The IAM Identity Center ID of the group.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`GroupIdentity`](crate::model::GroupIdentity).
        pub fn build(self) -> crate::model::GroupIdentity {
            crate::model::GroupIdentity { id: self.id }
        }
    }
}
impl GroupIdentity {
    /// Creates a new builder-style object to manufacture [`GroupIdentity`](crate::model::GroupIdentity).
    pub fn builder() -> crate::model::group_identity::Builder {
        crate::model::group_identity::Builder::default()
    }
}

/// <p>Contains information for a user identity in an access policy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UserIdentity {
    /// <p>The IAM Identity Center ID of the user.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl UserIdentity {
    /// <p>The IAM Identity Center ID of the user.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
}
/// See [`UserIdentity`](crate::model::UserIdentity).
pub mod user_identity {

    /// A builder for [`UserIdentity`](crate::model::UserIdentity).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IAM Identity Center ID of the user.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The IAM Identity Center ID of the user.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`UserIdentity`](crate::model::UserIdentity).
        pub fn build(self) -> crate::model::UserIdentity {
            crate::model::UserIdentity { id: self.id }
        }
    }
}
impl UserIdentity {
    /// Creates a new builder-style object to manufacture [`UserIdentity`](crate::model::UserIdentity).
    pub fn builder() -> crate::model::user_identity::Builder {
        crate::model::user_identity::Builder::default()
    }
}

/// <p>Contains current status information for the configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfigurationStatus {
    /// <p>The current state of the configuration.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::ConfigurationState>,
    /// <p>Contains associated error information, if any.</p>
    #[doc(hidden)]
    pub error: std::option::Option<crate::model::ConfigurationErrorDetails>,
}
impl ConfigurationStatus {
    /// <p>The current state of the configuration.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::ConfigurationState> {
        self.state.as_ref()
    }
    /// <p>Contains associated error information, if any.</p>
    pub fn error(&self) -> std::option::Option<&crate::model::ConfigurationErrorDetails> {
        self.error.as_ref()
    }
}
/// See [`ConfigurationStatus`](crate::model::ConfigurationStatus).
pub mod configuration_status {

    /// A builder for [`ConfigurationStatus`](crate::model::ConfigurationStatus).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) state: std::option::Option<crate::model::ConfigurationState>,
        pub(crate) error: std::option::Option<crate::model::ConfigurationErrorDetails>,
    }
    impl Builder {
        /// <p>The current state of the configuration.</p>
        pub fn state(mut self, input: crate::model::ConfigurationState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current state of the configuration.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::ConfigurationState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>Contains associated error information, if any.</p>
        pub fn error(mut self, input: crate::model::ConfigurationErrorDetails) -> Self {
            self.error = Some(input);
            self
        }
        /// <p>Contains associated error information, if any.</p>
        pub fn set_error(
            mut self,
            input: std::option::Option<crate::model::ConfigurationErrorDetails>,
        ) -> Self {
            self.error = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfigurationStatus`](crate::model::ConfigurationStatus).
        pub fn build(self) -> crate::model::ConfigurationStatus {
            crate::model::ConfigurationStatus {
                state: self.state,
                error: self.error,
            }
        }
    }
}
impl ConfigurationStatus {
    /// Creates a new builder-style object to manufacture [`ConfigurationStatus`](crate::model::ConfigurationStatus).
    pub fn builder() -> crate::model::configuration_status::Builder {
        crate::model::configuration_status::Builder::default()
    }
}

/// <p>Contains the details of an IoT SiteWise configuration error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfigurationErrorDetails {
    /// <p>The error code.</p>
    #[doc(hidden)]
    pub code: std::option::Option<crate::model::ErrorCode>,
    /// <p>The error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ConfigurationErrorDetails {
    /// <p>The error code.</p>
    pub fn code(&self) -> std::option::Option<&crate::model::ErrorCode> {
        self.code.as_ref()
    }
    /// <p>The error message.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
/// See [`ConfigurationErrorDetails`](crate::model::ConfigurationErrorDetails).
pub mod configuration_error_details {

    /// A builder for [`ConfigurationErrorDetails`](crate::model::ConfigurationErrorDetails).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The error code.</p>
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        /// <p>The error code.</p>
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        /// <p>The error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfigurationErrorDetails`](crate::model::ConfigurationErrorDetails).
        pub fn build(self) -> crate::model::ConfigurationErrorDetails {
            crate::model::ConfigurationErrorDetails {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl ConfigurationErrorDetails {
    /// Creates a new builder-style object to manufacture [`ConfigurationErrorDetails`](crate::model::ConfigurationErrorDetails).
    pub fn builder() -> crate::model::configuration_error_details::Builder {
        crate::model::configuration_error_details::Builder::default()
    }
}

/// When writing a match expression against `ConfigurationState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let configurationstate = unimplemented!();
/// match configurationstate {
///     ConfigurationState::Active => { /* ... */ },
///     ConfigurationState::UpdateFailed => { /* ... */ },
///     ConfigurationState::UpdateInProgress => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `configurationstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConfigurationState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConfigurationState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConfigurationState::NewFeature` is defined.
/// Specifically, when `configurationstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConfigurationState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConfigurationState {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    UpdateFailed,
    #[allow(missing_docs)] // documentation missing in model
    UpdateInProgress,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ConfigurationState {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => ConfigurationState::Active,
            "UPDATE_FAILED" => ConfigurationState::UpdateFailed,
            "UPDATE_IN_PROGRESS" => ConfigurationState::UpdateInProgress,
            other => {
                ConfigurationState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ConfigurationState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConfigurationState::from(s))
    }
}
impl ConfigurationState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConfigurationState::Active => "ACTIVE",
            ConfigurationState::UpdateFailed => "UPDATE_FAILED",
            ConfigurationState::UpdateInProgress => "UPDATE_IN_PROGRESS",
            ConfigurationState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "UPDATE_FAILED", "UPDATE_IN_PROGRESS"]
    }
}
impl AsRef<str> for ConfigurationState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>How many days your data is kept in the hot tier. By default, your data is kept indefinitely in the hot tier.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RetentionPeriod {
    /// <p>The number of days that your data is kept.</p> <note>
    /// <p>If you specified a value for this parameter, the <code>unlimited</code> parameter must be <code>false</code>.</p>
    /// </note>
    #[doc(hidden)]
    pub number_of_days: std::option::Option<i32>,
    /// <p>If true, your data is kept indefinitely.</p> <note>
    /// <p>If configured to <code>true</code>, you must not specify a value for the <code>numberOfDays</code> parameter.</p>
    /// </note>
    #[doc(hidden)]
    pub unlimited: std::option::Option<bool>,
}
impl RetentionPeriod {
    /// <p>The number of days that your data is kept.</p> <note>
    /// <p>If you specified a value for this parameter, the <code>unlimited</code> parameter must be <code>false</code>.</p>
    /// </note>
    pub fn number_of_days(&self) -> std::option::Option<i32> {
        self.number_of_days
    }
    /// <p>If true, your data is kept indefinitely.</p> <note>
    /// <p>If configured to <code>true</code>, you must not specify a value for the <code>numberOfDays</code> parameter.</p>
    /// </note>
    pub fn unlimited(&self) -> std::option::Option<bool> {
        self.unlimited
    }
}
/// See [`RetentionPeriod`](crate::model::RetentionPeriod).
pub mod retention_period {

    /// A builder for [`RetentionPeriod`](crate::model::RetentionPeriod).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) number_of_days: std::option::Option<i32>,
        pub(crate) unlimited: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The number of days that your data is kept.</p> <note>
        /// <p>If you specified a value for this parameter, the <code>unlimited</code> parameter must be <code>false</code>.</p>
        /// </note>
        pub fn number_of_days(mut self, input: i32) -> Self {
            self.number_of_days = Some(input);
            self
        }
        /// <p>The number of days that your data is kept.</p> <note>
        /// <p>If you specified a value for this parameter, the <code>unlimited</code> parameter must be <code>false</code>.</p>
        /// </note>
        pub fn set_number_of_days(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_days = input;
            self
        }
        /// <p>If true, your data is kept indefinitely.</p> <note>
        /// <p>If configured to <code>true</code>, you must not specify a value for the <code>numberOfDays</code> parameter.</p>
        /// </note>
        pub fn unlimited(mut self, input: bool) -> Self {
            self.unlimited = Some(input);
            self
        }
        /// <p>If true, your data is kept indefinitely.</p> <note>
        /// <p>If configured to <code>true</code>, you must not specify a value for the <code>numberOfDays</code> parameter.</p>
        /// </note>
        pub fn set_unlimited(mut self, input: std::option::Option<bool>) -> Self {
            self.unlimited = input;
            self
        }
        /// Consumes the builder and constructs a [`RetentionPeriod`](crate::model::RetentionPeriod).
        pub fn build(self) -> crate::model::RetentionPeriod {
            crate::model::RetentionPeriod {
                number_of_days: self.number_of_days,
                unlimited: self.unlimited,
            }
        }
    }
}
impl RetentionPeriod {
    /// Creates a new builder-style object to manufacture [`RetentionPeriod`](crate::model::RetentionPeriod).
    pub fn builder() -> crate::model::retention_period::Builder {
        crate::model::retention_period::Builder::default()
    }
}

/// When writing a match expression against `DisassociatedDataStorageState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let disassociateddatastoragestate = unimplemented!();
/// match disassociateddatastoragestate {
///     DisassociatedDataStorageState::Disabled => { /* ... */ },
///     DisassociatedDataStorageState::Enabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `disassociateddatastoragestate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DisassociatedDataStorageState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DisassociatedDataStorageState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DisassociatedDataStorageState::NewFeature` is defined.
/// Specifically, when `disassociateddatastoragestate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DisassociatedDataStorageState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DisassociatedDataStorageState {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DisassociatedDataStorageState {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => DisassociatedDataStorageState::Disabled,
            "ENABLED" => DisassociatedDataStorageState::Enabled,
            other => DisassociatedDataStorageState::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for DisassociatedDataStorageState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DisassociatedDataStorageState::from(s))
    }
}
impl DisassociatedDataStorageState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DisassociatedDataStorageState::Disabled => "DISABLED",
            DisassociatedDataStorageState::Enabled => "ENABLED",
            DisassociatedDataStorageState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for DisassociatedDataStorageState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about the storage destination.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MultiLayerStorage {
    /// <p>Contains information about a customer managed Amazon S3 bucket.</p>
    #[doc(hidden)]
    pub customer_managed_s3_storage: std::option::Option<crate::model::CustomerManagedS3Storage>,
}
impl MultiLayerStorage {
    /// <p>Contains information about a customer managed Amazon S3 bucket.</p>
    pub fn customer_managed_s3_storage(
        &self,
    ) -> std::option::Option<&crate::model::CustomerManagedS3Storage> {
        self.customer_managed_s3_storage.as_ref()
    }
}
/// See [`MultiLayerStorage`](crate::model::MultiLayerStorage).
pub mod multi_layer_storage {

    /// A builder for [`MultiLayerStorage`](crate::model::MultiLayerStorage).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) customer_managed_s3_storage:
            std::option::Option<crate::model::CustomerManagedS3Storage>,
    }
    impl Builder {
        /// <p>Contains information about a customer managed Amazon S3 bucket.</p>
        pub fn customer_managed_s3_storage(
            mut self,
            input: crate::model::CustomerManagedS3Storage,
        ) -> Self {
            self.customer_managed_s3_storage = Some(input);
            self
        }
        /// <p>Contains information about a customer managed Amazon S3 bucket.</p>
        pub fn set_customer_managed_s3_storage(
            mut self,
            input: std::option::Option<crate::model::CustomerManagedS3Storage>,
        ) -> Self {
            self.customer_managed_s3_storage = input;
            self
        }
        /// Consumes the builder and constructs a [`MultiLayerStorage`](crate::model::MultiLayerStorage).
        pub fn build(self) -> crate::model::MultiLayerStorage {
            crate::model::MultiLayerStorage {
                customer_managed_s3_storage: self.customer_managed_s3_storage,
            }
        }
    }
}
impl MultiLayerStorage {
    /// Creates a new builder-style object to manufacture [`MultiLayerStorage`](crate::model::MultiLayerStorage).
    pub fn builder() -> crate::model::multi_layer_storage::Builder {
        crate::model::multi_layer_storage::Builder::default()
    }
}

/// <p>Contains information about a customer managed Amazon S3 bucket.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CustomerManagedS3Storage {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the Amazon S3 object. For more information about how to find the ARN for an Amazon S3 object, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-arn-format.html">Amazon S3 resources</a> in the <i>Amazon Simple Storage Service User Guide</i>.</p>
    #[doc(hidden)]
    pub s3_resource_arn: std::option::Option<std::string::String>,
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the Identity and Access Management role that allows IoT SiteWise to send data to Amazon S3.</p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
}
impl CustomerManagedS3Storage {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the Amazon S3 object. For more information about how to find the ARN for an Amazon S3 object, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-arn-format.html">Amazon S3 resources</a> in the <i>Amazon Simple Storage Service User Guide</i>.</p>
    pub fn s3_resource_arn(&self) -> std::option::Option<&str> {
        self.s3_resource_arn.as_deref()
    }
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the Identity and Access Management role that allows IoT SiteWise to send data to Amazon S3.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
}
/// See [`CustomerManagedS3Storage`](crate::model::CustomerManagedS3Storage).
pub mod customer_managed_s3_storage {

    /// A builder for [`CustomerManagedS3Storage`](crate::model::CustomerManagedS3Storage).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_resource_arn: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the Amazon S3 object. For more information about how to find the ARN for an Amazon S3 object, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-arn-format.html">Amazon S3 resources</a> in the <i>Amazon Simple Storage Service User Guide</i>.</p>
        pub fn s3_resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_resource_arn = Some(input.into());
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the Amazon S3 object. For more information about how to find the ARN for an Amazon S3 object, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-arn-format.html">Amazon S3 resources</a> in the <i>Amazon Simple Storage Service User Guide</i>.</p>
        pub fn set_s3_resource_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_resource_arn = input;
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the Identity and Access Management role that allows IoT SiteWise to send data to Amazon S3.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the Identity and Access Management role that allows IoT SiteWise to send data to Amazon S3.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomerManagedS3Storage`](crate::model::CustomerManagedS3Storage).
        pub fn build(self) -> crate::model::CustomerManagedS3Storage {
            crate::model::CustomerManagedS3Storage {
                s3_resource_arn: self.s3_resource_arn,
                role_arn: self.role_arn,
            }
        }
    }
}
impl CustomerManagedS3Storage {
    /// Creates a new builder-style object to manufacture [`CustomerManagedS3Storage`](crate::model::CustomerManagedS3Storage).
    pub fn builder() -> crate::model::customer_managed_s3_storage::Builder {
        crate::model::customer_managed_s3_storage::Builder::default()
    }
}

/// When writing a match expression against `StorageType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let storagetype = unimplemented!();
/// match storagetype {
///     StorageType::MultiLayerStorage => { /* ... */ },
///     StorageType::SitewiseDefaultStorage => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `storagetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StorageType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StorageType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StorageType::NewFeature` is defined.
/// Specifically, when `storagetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StorageType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StorageType {
    #[allow(missing_docs)] // documentation missing in model
    MultiLayerStorage,
    #[allow(missing_docs)] // documentation missing in model
    SitewiseDefaultStorage,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StorageType {
    fn from(s: &str) -> Self {
        match s {
            "MULTI_LAYER_STORAGE" => StorageType::MultiLayerStorage,
            "SITEWISE_DEFAULT_STORAGE" => StorageType::SitewiseDefaultStorage,
            other => StorageType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for StorageType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StorageType::from(s))
    }
}
impl StorageType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StorageType::MultiLayerStorage => "MULTI_LAYER_STORAGE",
            StorageType::SitewiseDefaultStorage => "SITEWISE_DEFAULT_STORAGE",
            StorageType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["MULTI_LAYER_STORAGE", "SITEWISE_DEFAULT_STORAGE"]
    }
}
impl AsRef<str> for StorageType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains logging options.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LoggingOptions {
    /// <p>The IoT SiteWise logging verbosity level.</p>
    #[doc(hidden)]
    pub level: std::option::Option<crate::model::LoggingLevel>,
}
impl LoggingOptions {
    /// <p>The IoT SiteWise logging verbosity level.</p>
    pub fn level(&self) -> std::option::Option<&crate::model::LoggingLevel> {
        self.level.as_ref()
    }
}
/// See [`LoggingOptions`](crate::model::LoggingOptions).
pub mod logging_options {

    /// A builder for [`LoggingOptions`](crate::model::LoggingOptions).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) level: std::option::Option<crate::model::LoggingLevel>,
    }
    impl Builder {
        /// <p>The IoT SiteWise logging verbosity level.</p>
        pub fn level(mut self, input: crate::model::LoggingLevel) -> Self {
            self.level = Some(input);
            self
        }
        /// <p>The IoT SiteWise logging verbosity level.</p>
        pub fn set_level(mut self, input: std::option::Option<crate::model::LoggingLevel>) -> Self {
            self.level = input;
            self
        }
        /// Consumes the builder and constructs a [`LoggingOptions`](crate::model::LoggingOptions).
        pub fn build(self) -> crate::model::LoggingOptions {
            crate::model::LoggingOptions { level: self.level }
        }
    }
}
impl LoggingOptions {
    /// Creates a new builder-style object to manufacture [`LoggingOptions`](crate::model::LoggingOptions).
    pub fn builder() -> crate::model::logging_options::Builder {
        crate::model::logging_options::Builder::default()
    }
}

/// When writing a match expression against `LoggingLevel`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let logginglevel = unimplemented!();
/// match logginglevel {
///     LoggingLevel::Error => { /* ... */ },
///     LoggingLevel::Info => { /* ... */ },
///     LoggingLevel::Off => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `logginglevel` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LoggingLevel::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LoggingLevel::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LoggingLevel::NewFeature` is defined.
/// Specifically, when `logginglevel` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LoggingLevel::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LoggingLevel {
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    Info,
    #[allow(missing_docs)] // documentation missing in model
    Off,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LoggingLevel {
    fn from(s: &str) -> Self {
        match s {
            "ERROR" => LoggingLevel::Error,
            "INFO" => LoggingLevel::Info,
            "OFF" => LoggingLevel::Off,
            other => LoggingLevel::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for LoggingLevel {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LoggingLevel::from(s))
    }
}
impl LoggingLevel {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LoggingLevel::Error => "ERROR",
            LoggingLevel::Info => "INFO",
            LoggingLevel::Off => "OFF",
            LoggingLevel::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ERROR", "INFO", "OFF"]
    }
}
impl AsRef<str> for LoggingLevel {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `EncryptionType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let encryptiontype = unimplemented!();
/// match encryptiontype {
///     EncryptionType::KmsBasedEncryption => { /* ... */ },
///     EncryptionType::SitewiseDefaultEncryption => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `encryptiontype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EncryptionType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EncryptionType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EncryptionType::NewFeature` is defined.
/// Specifically, when `encryptiontype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EncryptionType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EncryptionType {
    #[allow(missing_docs)] // documentation missing in model
    KmsBasedEncryption,
    #[allow(missing_docs)] // documentation missing in model
    SitewiseDefaultEncryption,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EncryptionType {
    fn from(s: &str) -> Self {
        match s {
            "KMS_BASED_ENCRYPTION" => EncryptionType::KmsBasedEncryption,
            "SITEWISE_DEFAULT_ENCRYPTION" => EncryptionType::SitewiseDefaultEncryption,
            other => EncryptionType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for EncryptionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EncryptionType::from(s))
    }
}
impl EncryptionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EncryptionType::KmsBasedEncryption => "KMS_BASED_ENCRYPTION",
            EncryptionType::SitewiseDefaultEncryption => "SITEWISE_DEFAULT_ENCRYPTION",
            EncryptionType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["KMS_BASED_ENCRYPTION", "SITEWISE_DEFAULT_ENCRYPTION"]
    }
}
impl AsRef<str> for EncryptionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains a summary of a time series (data stream).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TimeSeriesSummary {
    /// <p>The ID of the asset in which the asset property was created.</p>
    #[doc(hidden)]
    pub asset_id: std::option::Option<std::string::String>,
    /// <p>The ID of the asset property.</p>
    #[doc(hidden)]
    pub property_id: std::option::Option<std::string::String>,
    /// <p>The alias that identifies the time series.</p>
    #[doc(hidden)]
    pub alias: std::option::Option<std::string::String>,
    /// <p>The ID of the time series.</p>
    #[doc(hidden)]
    pub time_series_id: std::option::Option<std::string::String>,
    /// <p>The data type of the time series.</p>
    /// <p>If you specify <code>STRUCT</code>, you must also specify <code>dataTypeSpec</code> to identify the type of the structure for this time series.</p>
    #[doc(hidden)]
    pub data_type: std::option::Option<crate::model::PropertyDataType>,
    /// <p>The data type of the structure for this time series. This parameter is required for time series that have the <code>STRUCT</code> data type.</p>
    /// <p>The options for this parameter depend on the type of the composite model in which you created the asset property that is associated with your time series. Use <code>AWS/ALARM_STATE</code> for alarm state in alarm composite models.</p>
    #[doc(hidden)]
    pub data_type_spec: std::option::Option<std::string::String>,
    /// <p>The date that the time series was created, in Unix epoch time.</p>
    #[doc(hidden)]
    pub time_series_creation_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date that the time series was last updated, in Unix epoch time.</p>
    #[doc(hidden)]
    pub time_series_last_update_date: std::option::Option<aws_smithy_types::DateTime>,
}
impl TimeSeriesSummary {
    /// <p>The ID of the asset in which the asset property was created.</p>
    pub fn asset_id(&self) -> std::option::Option<&str> {
        self.asset_id.as_deref()
    }
    /// <p>The ID of the asset property.</p>
    pub fn property_id(&self) -> std::option::Option<&str> {
        self.property_id.as_deref()
    }
    /// <p>The alias that identifies the time series.</p>
    pub fn alias(&self) -> std::option::Option<&str> {
        self.alias.as_deref()
    }
    /// <p>The ID of the time series.</p>
    pub fn time_series_id(&self) -> std::option::Option<&str> {
        self.time_series_id.as_deref()
    }
    /// <p>The data type of the time series.</p>
    /// <p>If you specify <code>STRUCT</code>, you must also specify <code>dataTypeSpec</code> to identify the type of the structure for this time series.</p>
    pub fn data_type(&self) -> std::option::Option<&crate::model::PropertyDataType> {
        self.data_type.as_ref()
    }
    /// <p>The data type of the structure for this time series. This parameter is required for time series that have the <code>STRUCT</code> data type.</p>
    /// <p>The options for this parameter depend on the type of the composite model in which you created the asset property that is associated with your time series. Use <code>AWS/ALARM_STATE</code> for alarm state in alarm composite models.</p>
    pub fn data_type_spec(&self) -> std::option::Option<&str> {
        self.data_type_spec.as_deref()
    }
    /// <p>The date that the time series was created, in Unix epoch time.</p>
    pub fn time_series_creation_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.time_series_creation_date.as_ref()
    }
    /// <p>The date that the time series was last updated, in Unix epoch time.</p>
    pub fn time_series_last_update_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.time_series_last_update_date.as_ref()
    }
}
/// See [`TimeSeriesSummary`](crate::model::TimeSeriesSummary).
pub mod time_series_summary {

    /// A builder for [`TimeSeriesSummary`](crate::model::TimeSeriesSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) asset_id: std::option::Option<std::string::String>,
        pub(crate) property_id: std::option::Option<std::string::String>,
        pub(crate) alias: std::option::Option<std::string::String>,
        pub(crate) time_series_id: std::option::Option<std::string::String>,
        pub(crate) data_type: std::option::Option<crate::model::PropertyDataType>,
        pub(crate) data_type_spec: std::option::Option<std::string::String>,
        pub(crate) time_series_creation_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) time_series_last_update_date: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The ID of the asset in which the asset property was created.</p>
        pub fn asset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset in which the asset property was created.</p>
        pub fn set_asset_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_id = input;
            self
        }
        /// <p>The ID of the asset property.</p>
        pub fn property_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset property.</p>
        pub fn set_property_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.property_id = input;
            self
        }
        /// <p>The alias that identifies the time series.</p>
        pub fn alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.alias = Some(input.into());
            self
        }
        /// <p>The alias that identifies the time series.</p>
        pub fn set_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alias = input;
            self
        }
        /// <p>The ID of the time series.</p>
        pub fn time_series_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.time_series_id = Some(input.into());
            self
        }
        /// <p>The ID of the time series.</p>
        pub fn set_time_series_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.time_series_id = input;
            self
        }
        /// <p>The data type of the time series.</p>
        /// <p>If you specify <code>STRUCT</code>, you must also specify <code>dataTypeSpec</code> to identify the type of the structure for this time series.</p>
        pub fn data_type(mut self, input: crate::model::PropertyDataType) -> Self {
            self.data_type = Some(input);
            self
        }
        /// <p>The data type of the time series.</p>
        /// <p>If you specify <code>STRUCT</code>, you must also specify <code>dataTypeSpec</code> to identify the type of the structure for this time series.</p>
        pub fn set_data_type(
            mut self,
            input: std::option::Option<crate::model::PropertyDataType>,
        ) -> Self {
            self.data_type = input;
            self
        }
        /// <p>The data type of the structure for this time series. This parameter is required for time series that have the <code>STRUCT</code> data type.</p>
        /// <p>The options for this parameter depend on the type of the composite model in which you created the asset property that is associated with your time series. Use <code>AWS/ALARM_STATE</code> for alarm state in alarm composite models.</p>
        pub fn data_type_spec(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_type_spec = Some(input.into());
            self
        }
        /// <p>The data type of the structure for this time series. This parameter is required for time series that have the <code>STRUCT</code> data type.</p>
        /// <p>The options for this parameter depend on the type of the composite model in which you created the asset property that is associated with your time series. Use <code>AWS/ALARM_STATE</code> for alarm state in alarm composite models.</p>
        pub fn set_data_type_spec(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_type_spec = input;
            self
        }
        /// <p>The date that the time series was created, in Unix epoch time.</p>
        pub fn time_series_creation_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.time_series_creation_date = Some(input);
            self
        }
        /// <p>The date that the time series was created, in Unix epoch time.</p>
        pub fn set_time_series_creation_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.time_series_creation_date = input;
            self
        }
        /// <p>The date that the time series was last updated, in Unix epoch time.</p>
        pub fn time_series_last_update_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.time_series_last_update_date = Some(input);
            self
        }
        /// <p>The date that the time series was last updated, in Unix epoch time.</p>
        pub fn set_time_series_last_update_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.time_series_last_update_date = input;
            self
        }
        /// Consumes the builder and constructs a [`TimeSeriesSummary`](crate::model::TimeSeriesSummary).
        pub fn build(self) -> crate::model::TimeSeriesSummary {
            crate::model::TimeSeriesSummary {
                asset_id: self.asset_id,
                property_id: self.property_id,
                alias: self.alias,
                time_series_id: self.time_series_id,
                data_type: self.data_type,
                data_type_spec: self.data_type_spec,
                time_series_creation_date: self.time_series_creation_date,
                time_series_last_update_date: self.time_series_last_update_date,
            }
        }
    }
}
impl TimeSeriesSummary {
    /// Creates a new builder-style object to manufacture [`TimeSeriesSummary`](crate::model::TimeSeriesSummary).
    pub fn builder() -> crate::model::time_series_summary::Builder {
        crate::model::time_series_summary::Builder::default()
    }
}

/// When writing a match expression against `ListTimeSeriesType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let listtimeseriestype = unimplemented!();
/// match listtimeseriestype {
///     ListTimeSeriesType::Associated => { /* ... */ },
///     ListTimeSeriesType::Disassociated => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `listtimeseriestype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ListTimeSeriesType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ListTimeSeriesType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ListTimeSeriesType::NewFeature` is defined.
/// Specifically, when `listtimeseriestype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ListTimeSeriesType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ListTimeSeriesType {
    #[allow(missing_docs)] // documentation missing in model
    Associated,
    #[allow(missing_docs)] // documentation missing in model
    Disassociated,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ListTimeSeriesType {
    fn from(s: &str) -> Self {
        match s {
            "ASSOCIATED" => ListTimeSeriesType::Associated,
            "DISASSOCIATED" => ListTimeSeriesType::Disassociated,
            other => {
                ListTimeSeriesType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ListTimeSeriesType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ListTimeSeriesType::from(s))
    }
}
impl ListTimeSeriesType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ListTimeSeriesType::Associated => "ASSOCIATED",
            ListTimeSeriesType::Disassociated => "DISASSOCIATED",
            ListTimeSeriesType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ASSOCIATED", "DISASSOCIATED"]
    }
}
impl AsRef<str> for ListTimeSeriesType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains project summary information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProjectSummary {
    /// <p>The ID of the project.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the project.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The project's description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The date the project was created, in Unix epoch time.</p>
    #[doc(hidden)]
    pub creation_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date the project was last updated, in Unix epoch time.</p>
    #[doc(hidden)]
    pub last_update_date: std::option::Option<aws_smithy_types::DateTime>,
}
impl ProjectSummary {
    /// <p>The ID of the project.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the project.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The project's description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The date the project was created, in Unix epoch time.</p>
    pub fn creation_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_date.as_ref()
    }
    /// <p>The date the project was last updated, in Unix epoch time.</p>
    pub fn last_update_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_update_date.as_ref()
    }
}
/// See [`ProjectSummary`](crate::model::ProjectSummary).
pub mod project_summary {

    /// A builder for [`ProjectSummary`](crate::model::ProjectSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) creation_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_update_date: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The ID of the project.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the project.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the project.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the project.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The project's description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The project's description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The date the project was created, in Unix epoch time.</p>
        pub fn creation_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_date = Some(input);
            self
        }
        /// <p>The date the project was created, in Unix epoch time.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>The date the project was last updated, in Unix epoch time.</p>
        pub fn last_update_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_update_date = Some(input);
            self
        }
        /// <p>The date the project was last updated, in Unix epoch time.</p>
        pub fn set_last_update_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_update_date = input;
            self
        }
        /// Consumes the builder and constructs a [`ProjectSummary`](crate::model::ProjectSummary).
        pub fn build(self) -> crate::model::ProjectSummary {
            crate::model::ProjectSummary {
                id: self.id,
                name: self.name,
                description: self.description,
                creation_date: self.creation_date,
                last_update_date: self.last_update_date,
            }
        }
    }
}
impl ProjectSummary {
    /// Creates a new builder-style object to manufacture [`ProjectSummary`](crate::model::ProjectSummary).
    pub fn builder() -> crate::model::project_summary::Builder {
        crate::model::project_summary::Builder::default()
    }
}

/// <p>Contains a portal summary.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PortalSummary {
    /// <p>The ID of the portal.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the portal.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The portal's description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The URL for the IoT SiteWise Monitor portal. You can use this URL to access portals that use IAM Identity Center for authentication. For portals that use IAM for authentication, you must use the IoT SiteWise console to get a URL that you can use to access the portal.</p>
    #[doc(hidden)]
    pub start_url: std::option::Option<std::string::String>,
    /// <p>The date the portal was created, in Unix epoch time.</p>
    #[doc(hidden)]
    pub creation_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date the portal was last updated, in Unix epoch time.</p>
    #[doc(hidden)]
    pub last_update_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-service-role.html">Using service roles for IoT SiteWise Monitor</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>Contains information about the current status of a portal.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::PortalStatus>,
}
impl PortalSummary {
    /// <p>The ID of the portal.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the portal.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The portal's description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The URL for the IoT SiteWise Monitor portal. You can use this URL to access portals that use IAM Identity Center for authentication. For portals that use IAM for authentication, you must use the IoT SiteWise console to get a URL that you can use to access the portal.</p>
    pub fn start_url(&self) -> std::option::Option<&str> {
        self.start_url.as_deref()
    }
    /// <p>The date the portal was created, in Unix epoch time.</p>
    pub fn creation_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_date.as_ref()
    }
    /// <p>The date the portal was last updated, in Unix epoch time.</p>
    pub fn last_update_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_update_date.as_ref()
    }
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-service-role.html">Using service roles for IoT SiteWise Monitor</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>Contains information about the current status of a portal.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::PortalStatus> {
        self.status.as_ref()
    }
}
/// See [`PortalSummary`](crate::model::PortalSummary).
pub mod portal_summary {

    /// A builder for [`PortalSummary`](crate::model::PortalSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) start_url: std::option::Option<std::string::String>,
        pub(crate) creation_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_update_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::PortalStatus>,
    }
    impl Builder {
        /// <p>The ID of the portal.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the portal.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the portal.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the portal.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The portal's description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The portal's description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The URL for the IoT SiteWise Monitor portal. You can use this URL to access portals that use IAM Identity Center for authentication. For portals that use IAM for authentication, you must use the IoT SiteWise console to get a URL that you can use to access the portal.</p>
        pub fn start_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.start_url = Some(input.into());
            self
        }
        /// <p>The URL for the IoT SiteWise Monitor portal. You can use this URL to access portals that use IAM Identity Center for authentication. For portals that use IAM for authentication, you must use the IoT SiteWise console to get a URL that you can use to access the portal.</p>
        pub fn set_start_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.start_url = input;
            self
        }
        /// <p>The date the portal was created, in Unix epoch time.</p>
        pub fn creation_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_date = Some(input);
            self
        }
        /// <p>The date the portal was created, in Unix epoch time.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>The date the portal was last updated, in Unix epoch time.</p>
        pub fn last_update_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_update_date = Some(input);
            self
        }
        /// <p>The date the portal was last updated, in Unix epoch time.</p>
        pub fn set_last_update_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_update_date = input;
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-service-role.html">Using service roles for IoT SiteWise Monitor</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-service-role.html">Using service roles for IoT SiteWise Monitor</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>Contains information about the current status of a portal.</p>
        pub fn status(mut self, input: crate::model::PortalStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Contains information about the current status of a portal.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::PortalStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`PortalSummary`](crate::model::PortalSummary).
        pub fn build(self) -> crate::model::PortalSummary {
            crate::model::PortalSummary {
                id: self.id,
                name: self.name,
                description: self.description,
                start_url: self.start_url,
                creation_date: self.creation_date,
                last_update_date: self.last_update_date,
                role_arn: self.role_arn,
                status: self.status,
            }
        }
    }
}
impl PortalSummary {
    /// Creates a new builder-style object to manufacture [`PortalSummary`](crate::model::PortalSummary).
    pub fn builder() -> crate::model::portal_summary::Builder {
        crate::model::portal_summary::Builder::default()
    }
}

/// <p>Contains a summary of a gateway.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GatewaySummary {
    /// <p>The ID of the gateway device.</p>
    #[doc(hidden)]
    pub gateway_id: std::option::Option<std::string::String>,
    /// <p>The name of the asset.</p>
    #[doc(hidden)]
    pub gateway_name: std::option::Option<std::string::String>,
    /// <p>Contains a gateway's platform information.</p>
    #[doc(hidden)]
    pub gateway_platform: std::option::Option<crate::model::GatewayPlatform>,
    /// <p>A list of gateway capability summaries that each contain a namespace and status. Each gateway capability defines data sources for the gateway. To retrieve a capability configuration's definition, use <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_DescribeGatewayCapabilityConfiguration.html">DescribeGatewayCapabilityConfiguration</a>.</p>
    #[doc(hidden)]
    pub gateway_capability_summaries:
        std::option::Option<std::vec::Vec<crate::model::GatewayCapabilitySummary>>,
    /// <p>The date the gateway was created, in Unix epoch time.</p>
    #[doc(hidden)]
    pub creation_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date the gateway was last updated, in Unix epoch time.</p>
    #[doc(hidden)]
    pub last_update_date: std::option::Option<aws_smithy_types::DateTime>,
}
impl GatewaySummary {
    /// <p>The ID of the gateway device.</p>
    pub fn gateway_id(&self) -> std::option::Option<&str> {
        self.gateway_id.as_deref()
    }
    /// <p>The name of the asset.</p>
    pub fn gateway_name(&self) -> std::option::Option<&str> {
        self.gateway_name.as_deref()
    }
    /// <p>Contains a gateway's platform information.</p>
    pub fn gateway_platform(&self) -> std::option::Option<&crate::model::GatewayPlatform> {
        self.gateway_platform.as_ref()
    }
    /// <p>A list of gateway capability summaries that each contain a namespace and status. Each gateway capability defines data sources for the gateway. To retrieve a capability configuration's definition, use <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_DescribeGatewayCapabilityConfiguration.html">DescribeGatewayCapabilityConfiguration</a>.</p>
    pub fn gateway_capability_summaries(
        &self,
    ) -> std::option::Option<&[crate::model::GatewayCapabilitySummary]> {
        self.gateway_capability_summaries.as_deref()
    }
    /// <p>The date the gateway was created, in Unix epoch time.</p>
    pub fn creation_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_date.as_ref()
    }
    /// <p>The date the gateway was last updated, in Unix epoch time.</p>
    pub fn last_update_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_update_date.as_ref()
    }
}
/// See [`GatewaySummary`](crate::model::GatewaySummary).
pub mod gateway_summary {

    /// A builder for [`GatewaySummary`](crate::model::GatewaySummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) gateway_id: std::option::Option<std::string::String>,
        pub(crate) gateway_name: std::option::Option<std::string::String>,
        pub(crate) gateway_platform: std::option::Option<crate::model::GatewayPlatform>,
        pub(crate) gateway_capability_summaries:
            std::option::Option<std::vec::Vec<crate::model::GatewayCapabilitySummary>>,
        pub(crate) creation_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_update_date: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The ID of the gateway device.</p>
        pub fn gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.gateway_id = Some(input.into());
            self
        }
        /// <p>The ID of the gateway device.</p>
        pub fn set_gateway_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.gateway_id = input;
            self
        }
        /// <p>The name of the asset.</p>
        pub fn gateway_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.gateway_name = Some(input.into());
            self
        }
        /// <p>The name of the asset.</p>
        pub fn set_gateway_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.gateway_name = input;
            self
        }
        /// <p>Contains a gateway's platform information.</p>
        pub fn gateway_platform(mut self, input: crate::model::GatewayPlatform) -> Self {
            self.gateway_platform = Some(input);
            self
        }
        /// <p>Contains a gateway's platform information.</p>
        pub fn set_gateway_platform(
            mut self,
            input: std::option::Option<crate::model::GatewayPlatform>,
        ) -> Self {
            self.gateway_platform = input;
            self
        }
        /// Appends an item to `gateway_capability_summaries`.
        ///
        /// To override the contents of this collection use [`set_gateway_capability_summaries`](Self::set_gateway_capability_summaries).
        ///
        /// <p>A list of gateway capability summaries that each contain a namespace and status. Each gateway capability defines data sources for the gateway. To retrieve a capability configuration's definition, use <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_DescribeGatewayCapabilityConfiguration.html">DescribeGatewayCapabilityConfiguration</a>.</p>
        pub fn gateway_capability_summaries(
            mut self,
            input: crate::model::GatewayCapabilitySummary,
        ) -> Self {
            let mut v = self.gateway_capability_summaries.unwrap_or_default();
            v.push(input);
            self.gateway_capability_summaries = Some(v);
            self
        }
        /// <p>A list of gateway capability summaries that each contain a namespace and status. Each gateway capability defines data sources for the gateway. To retrieve a capability configuration's definition, use <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_DescribeGatewayCapabilityConfiguration.html">DescribeGatewayCapabilityConfiguration</a>.</p>
        pub fn set_gateway_capability_summaries(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GatewayCapabilitySummary>>,
        ) -> Self {
            self.gateway_capability_summaries = input;
            self
        }
        /// <p>The date the gateway was created, in Unix epoch time.</p>
        pub fn creation_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_date = Some(input);
            self
        }
        /// <p>The date the gateway was created, in Unix epoch time.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>The date the gateway was last updated, in Unix epoch time.</p>
        pub fn last_update_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_update_date = Some(input);
            self
        }
        /// <p>The date the gateway was last updated, in Unix epoch time.</p>
        pub fn set_last_update_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_update_date = input;
            self
        }
        /// Consumes the builder and constructs a [`GatewaySummary`](crate::model::GatewaySummary).
        pub fn build(self) -> crate::model::GatewaySummary {
            crate::model::GatewaySummary {
                gateway_id: self.gateway_id,
                gateway_name: self.gateway_name,
                gateway_platform: self.gateway_platform,
                gateway_capability_summaries: self.gateway_capability_summaries,
                creation_date: self.creation_date,
                last_update_date: self.last_update_date,
            }
        }
    }
}
impl GatewaySummary {
    /// Creates a new builder-style object to manufacture [`GatewaySummary`](crate::model::GatewaySummary).
    pub fn builder() -> crate::model::gateway_summary::Builder {
        crate::model::gateway_summary::Builder::default()
    }
}

/// <p>Contains a summary of a gateway capability configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GatewayCapabilitySummary {
    /// <p>The namespace of the capability configuration. For example, if you configure OPC-UA sources from the IoT SiteWise console, your OPC-UA capability configuration has the namespace <code>iotsitewise:opcuacollector:version</code>, where <code>version</code> is a number such as <code>1</code>.</p>
    #[doc(hidden)]
    pub capability_namespace: std::option::Option<std::string::String>,
    /// <p>The synchronization status of the capability configuration. The sync status can be one of the following:</p>
    /// <ul>
    /// <li> <p> <code>IN_SYNC</code> – The gateway is running the capability configuration.</p> </li>
    /// <li> <p> <code>OUT_OF_SYNC</code> – The gateway hasn't received the capability configuration.</p> </li>
    /// <li> <p> <code>SYNC_FAILED</code> – The gateway rejected the capability configuration.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub capability_sync_status: std::option::Option<crate::model::CapabilitySyncStatus>,
}
impl GatewayCapabilitySummary {
    /// <p>The namespace of the capability configuration. For example, if you configure OPC-UA sources from the IoT SiteWise console, your OPC-UA capability configuration has the namespace <code>iotsitewise:opcuacollector:version</code>, where <code>version</code> is a number such as <code>1</code>.</p>
    pub fn capability_namespace(&self) -> std::option::Option<&str> {
        self.capability_namespace.as_deref()
    }
    /// <p>The synchronization status of the capability configuration. The sync status can be one of the following:</p>
    /// <ul>
    /// <li> <p> <code>IN_SYNC</code> – The gateway is running the capability configuration.</p> </li>
    /// <li> <p> <code>OUT_OF_SYNC</code> – The gateway hasn't received the capability configuration.</p> </li>
    /// <li> <p> <code>SYNC_FAILED</code> – The gateway rejected the capability configuration.</p> </li>
    /// </ul>
    pub fn capability_sync_status(
        &self,
    ) -> std::option::Option<&crate::model::CapabilitySyncStatus> {
        self.capability_sync_status.as_ref()
    }
}
/// See [`GatewayCapabilitySummary`](crate::model::GatewayCapabilitySummary).
pub mod gateway_capability_summary {

    /// A builder for [`GatewayCapabilitySummary`](crate::model::GatewayCapabilitySummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) capability_namespace: std::option::Option<std::string::String>,
        pub(crate) capability_sync_status: std::option::Option<crate::model::CapabilitySyncStatus>,
    }
    impl Builder {
        /// <p>The namespace of the capability configuration. For example, if you configure OPC-UA sources from the IoT SiteWise console, your OPC-UA capability configuration has the namespace <code>iotsitewise:opcuacollector:version</code>, where <code>version</code> is a number such as <code>1</code>.</p>
        pub fn capability_namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.capability_namespace = Some(input.into());
            self
        }
        /// <p>The namespace of the capability configuration. For example, if you configure OPC-UA sources from the IoT SiteWise console, your OPC-UA capability configuration has the namespace <code>iotsitewise:opcuacollector:version</code>, where <code>version</code> is a number such as <code>1</code>.</p>
        pub fn set_capability_namespace(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.capability_namespace = input;
            self
        }
        /// <p>The synchronization status of the capability configuration. The sync status can be one of the following:</p>
        /// <ul>
        /// <li> <p> <code>IN_SYNC</code> – The gateway is running the capability configuration.</p> </li>
        /// <li> <p> <code>OUT_OF_SYNC</code> – The gateway hasn't received the capability configuration.</p> </li>
        /// <li> <p> <code>SYNC_FAILED</code> – The gateway rejected the capability configuration.</p> </li>
        /// </ul>
        pub fn capability_sync_status(mut self, input: crate::model::CapabilitySyncStatus) -> Self {
            self.capability_sync_status = Some(input);
            self
        }
        /// <p>The synchronization status of the capability configuration. The sync status can be one of the following:</p>
        /// <ul>
        /// <li> <p> <code>IN_SYNC</code> – The gateway is running the capability configuration.</p> </li>
        /// <li> <p> <code>OUT_OF_SYNC</code> – The gateway hasn't received the capability configuration.</p> </li>
        /// <li> <p> <code>SYNC_FAILED</code> – The gateway rejected the capability configuration.</p> </li>
        /// </ul>
        pub fn set_capability_sync_status(
            mut self,
            input: std::option::Option<crate::model::CapabilitySyncStatus>,
        ) -> Self {
            self.capability_sync_status = input;
            self
        }
        /// Consumes the builder and constructs a [`GatewayCapabilitySummary`](crate::model::GatewayCapabilitySummary).
        pub fn build(self) -> crate::model::GatewayCapabilitySummary {
            crate::model::GatewayCapabilitySummary {
                capability_namespace: self.capability_namespace,
                capability_sync_status: self.capability_sync_status,
            }
        }
    }
}
impl GatewayCapabilitySummary {
    /// Creates a new builder-style object to manufacture [`GatewayCapabilitySummary`](crate::model::GatewayCapabilitySummary).
    pub fn builder() -> crate::model::gateway_capability_summary::Builder {
        crate::model::gateway_capability_summary::Builder::default()
    }
}

/// <p>Contains a gateway's platform information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GatewayPlatform {
    /// <p>A gateway that runs on IoT Greengrass.</p>
    #[doc(hidden)]
    pub greengrass: std::option::Option<crate::model::Greengrass>,
    /// <p>A gateway that runs on IoT Greengrass V2.</p>
    #[doc(hidden)]
    pub greengrass_v2: std::option::Option<crate::model::GreengrassV2>,
}
impl GatewayPlatform {
    /// <p>A gateway that runs on IoT Greengrass.</p>
    pub fn greengrass(&self) -> std::option::Option<&crate::model::Greengrass> {
        self.greengrass.as_ref()
    }
    /// <p>A gateway that runs on IoT Greengrass V2.</p>
    pub fn greengrass_v2(&self) -> std::option::Option<&crate::model::GreengrassV2> {
        self.greengrass_v2.as_ref()
    }
}
/// See [`GatewayPlatform`](crate::model::GatewayPlatform).
pub mod gateway_platform {

    /// A builder for [`GatewayPlatform`](crate::model::GatewayPlatform).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) greengrass: std::option::Option<crate::model::Greengrass>,
        pub(crate) greengrass_v2: std::option::Option<crate::model::GreengrassV2>,
    }
    impl Builder {
        /// <p>A gateway that runs on IoT Greengrass.</p>
        pub fn greengrass(mut self, input: crate::model::Greengrass) -> Self {
            self.greengrass = Some(input);
            self
        }
        /// <p>A gateway that runs on IoT Greengrass.</p>
        pub fn set_greengrass(
            mut self,
            input: std::option::Option<crate::model::Greengrass>,
        ) -> Self {
            self.greengrass = input;
            self
        }
        /// <p>A gateway that runs on IoT Greengrass V2.</p>
        pub fn greengrass_v2(mut self, input: crate::model::GreengrassV2) -> Self {
            self.greengrass_v2 = Some(input);
            self
        }
        /// <p>A gateway that runs on IoT Greengrass V2.</p>
        pub fn set_greengrass_v2(
            mut self,
            input: std::option::Option<crate::model::GreengrassV2>,
        ) -> Self {
            self.greengrass_v2 = input;
            self
        }
        /// Consumes the builder and constructs a [`GatewayPlatform`](crate::model::GatewayPlatform).
        pub fn build(self) -> crate::model::GatewayPlatform {
            crate::model::GatewayPlatform {
                greengrass: self.greengrass,
                greengrass_v2: self.greengrass_v2,
            }
        }
    }
}
impl GatewayPlatform {
    /// Creates a new builder-style object to manufacture [`GatewayPlatform`](crate::model::GatewayPlatform).
    pub fn builder() -> crate::model::gateway_platform::Builder {
        crate::model::gateway_platform::Builder::default()
    }
}

/// <p>Contains details for a gateway that runs on IoT Greengrass V2. To create a gateway that runs on IoT Greengrass V2, you must deploy the IoT SiteWise Edge component to your gateway device. Your <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/device-service-role.html">Greengrass device role</a> must use the <code>AWSIoTSiteWiseEdgeAccess</code> policy. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/sw-gateways.html">Using IoT SiteWise at the edge</a> in the <i>IoT SiteWise User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GreengrassV2 {
    /// <p>The name of the IoT thing for your IoT Greengrass V2 core device.</p>
    #[doc(hidden)]
    pub core_device_thing_name: std::option::Option<std::string::String>,
}
impl GreengrassV2 {
    /// <p>The name of the IoT thing for your IoT Greengrass V2 core device.</p>
    pub fn core_device_thing_name(&self) -> std::option::Option<&str> {
        self.core_device_thing_name.as_deref()
    }
}
/// See [`GreengrassV2`](crate::model::GreengrassV2).
pub mod greengrass_v2 {

    /// A builder for [`GreengrassV2`](crate::model::GreengrassV2).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_device_thing_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the IoT thing for your IoT Greengrass V2 core device.</p>
        pub fn core_device_thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_device_thing_name = Some(input.into());
            self
        }
        /// <p>The name of the IoT thing for your IoT Greengrass V2 core device.</p>
        pub fn set_core_device_thing_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_device_thing_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GreengrassV2`](crate::model::GreengrassV2).
        pub fn build(self) -> crate::model::GreengrassV2 {
            crate::model::GreengrassV2 {
                core_device_thing_name: self.core_device_thing_name,
            }
        }
    }
}
impl GreengrassV2 {
    /// Creates a new builder-style object to manufacture [`GreengrassV2`](crate::model::GreengrassV2).
    pub fn builder() -> crate::model::greengrass_v2::Builder {
        crate::model::greengrass_v2::Builder::default()
    }
}

/// <p>Contains details for a gateway that runs on IoT Greengrass. To create a gateway that runs on IoT Greengrass, you must add the IoT SiteWise connector to a Greengrass group and deploy it. Your Greengrass group must also have permissions to upload data to IoT SiteWise. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/gateway-connector.html">Ingesting data using a gateway</a> in the <i>IoT SiteWise User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Greengrass {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the Greengrass group. For more information about how to find a group's ARN, see <a href="https://docs.aws.amazon.com/greengrass/latest/apireference/listgroups-get.html">ListGroups</a> and <a href="https://docs.aws.amazon.com/greengrass/latest/apireference/getgroup-get.html">GetGroup</a> in the <i>IoT Greengrass API Reference</i>.</p>
    #[doc(hidden)]
    pub group_arn: std::option::Option<std::string::String>,
}
impl Greengrass {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the Greengrass group. For more information about how to find a group's ARN, see <a href="https://docs.aws.amazon.com/greengrass/latest/apireference/listgroups-get.html">ListGroups</a> and <a href="https://docs.aws.amazon.com/greengrass/latest/apireference/getgroup-get.html">GetGroup</a> in the <i>IoT Greengrass API Reference</i>.</p>
    pub fn group_arn(&self) -> std::option::Option<&str> {
        self.group_arn.as_deref()
    }
}
/// See [`Greengrass`](crate::model::Greengrass).
pub mod greengrass {

    /// A builder for [`Greengrass`](crate::model::Greengrass).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the Greengrass group. For more information about how to find a group's ARN, see <a href="https://docs.aws.amazon.com/greengrass/latest/apireference/listgroups-get.html">ListGroups</a> and <a href="https://docs.aws.amazon.com/greengrass/latest/apireference/getgroup-get.html">GetGroup</a> in the <i>IoT Greengrass API Reference</i>.</p>
        pub fn group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_arn = Some(input.into());
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the Greengrass group. For more information about how to find a group's ARN, see <a href="https://docs.aws.amazon.com/greengrass/latest/apireference/listgroups-get.html">ListGroups</a> and <a href="https://docs.aws.amazon.com/greengrass/latest/apireference/getgroup-get.html">GetGroup</a> in the <i>IoT Greengrass API Reference</i>.</p>
        pub fn set_group_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`Greengrass`](crate::model::Greengrass).
        pub fn build(self) -> crate::model::Greengrass {
            crate::model::Greengrass {
                group_arn: self.group_arn,
            }
        }
    }
}
impl Greengrass {
    /// Creates a new builder-style object to manufacture [`Greengrass`](crate::model::Greengrass).
    pub fn builder() -> crate::model::greengrass::Builder {
        crate::model::greengrass::Builder::default()
    }
}

/// <p>Contains a dashboard summary.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DashboardSummary {
    /// <p>The ID of the dashboard.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the dashboard</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The dashboard's description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The date the dashboard was created, in Unix epoch time.</p>
    #[doc(hidden)]
    pub creation_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date the dashboard was last updated, in Unix epoch time.</p>
    #[doc(hidden)]
    pub last_update_date: std::option::Option<aws_smithy_types::DateTime>,
}
impl DashboardSummary {
    /// <p>The ID of the dashboard.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the dashboard</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The dashboard's description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The date the dashboard was created, in Unix epoch time.</p>
    pub fn creation_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_date.as_ref()
    }
    /// <p>The date the dashboard was last updated, in Unix epoch time.</p>
    pub fn last_update_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_update_date.as_ref()
    }
}
/// See [`DashboardSummary`](crate::model::DashboardSummary).
pub mod dashboard_summary {

    /// A builder for [`DashboardSummary`](crate::model::DashboardSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) creation_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_update_date: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The ID of the dashboard.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the dashboard.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the dashboard</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the dashboard</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The dashboard's description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The dashboard's description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The date the dashboard was created, in Unix epoch time.</p>
        pub fn creation_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_date = Some(input);
            self
        }
        /// <p>The date the dashboard was created, in Unix epoch time.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>The date the dashboard was last updated, in Unix epoch time.</p>
        pub fn last_update_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_update_date = Some(input);
            self
        }
        /// <p>The date the dashboard was last updated, in Unix epoch time.</p>
        pub fn set_last_update_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_update_date = input;
            self
        }
        /// Consumes the builder and constructs a [`DashboardSummary`](crate::model::DashboardSummary).
        pub fn build(self) -> crate::model::DashboardSummary {
            crate::model::DashboardSummary {
                id: self.id,
                name: self.name,
                description: self.description,
                creation_date: self.creation_date,
                last_update_date: self.last_update_date,
            }
        }
    }
}
impl DashboardSummary {
    /// Creates a new builder-style object to manufacture [`DashboardSummary`](crate::model::DashboardSummary).
    pub fn builder() -> crate::model::dashboard_summary::Builder {
        crate::model::dashboard_summary::Builder::default()
    }
}

/// <p>Contains a job summary information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct JobSummary {
    /// <p>The ID of the job.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The unique name that helps identify the job request.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The status of the bulk import job can be one of following values.</p>
    /// <ul>
    /// <li> <p> <code>PENDING</code> – IoT SiteWise is waiting for the current bulk import job to finish.</p> </li>
    /// <li> <p> <code>CANCELLED</code> – The bulk import job has been canceled.</p> </li>
    /// <li> <p> <code>RUNNING</code> – IoT SiteWise is processing your request to import your data from Amazon S3.</p> </li>
    /// <li> <p> <code>COMPLETED</code> – IoT SiteWise successfully completed your request to import data from Amazon S3.</p> </li>
    /// <li> <p> <code>FAILED</code> – IoT SiteWise couldn't process your request to import data from Amazon S3. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.</p> </li>
    /// <li> <p> <code>COMPLETED_WITH_FAILURES</code> – IoT SiteWise completed your request to import data from Amazon S3 with errors. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::JobStatus>,
}
impl JobSummary {
    /// <p>The ID of the job.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The unique name that helps identify the job request.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The status of the bulk import job can be one of following values.</p>
    /// <ul>
    /// <li> <p> <code>PENDING</code> – IoT SiteWise is waiting for the current bulk import job to finish.</p> </li>
    /// <li> <p> <code>CANCELLED</code> – The bulk import job has been canceled.</p> </li>
    /// <li> <p> <code>RUNNING</code> – IoT SiteWise is processing your request to import your data from Amazon S3.</p> </li>
    /// <li> <p> <code>COMPLETED</code> – IoT SiteWise successfully completed your request to import data from Amazon S3.</p> </li>
    /// <li> <p> <code>FAILED</code> – IoT SiteWise couldn't process your request to import data from Amazon S3. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.</p> </li>
    /// <li> <p> <code>COMPLETED_WITH_FAILURES</code> – IoT SiteWise completed your request to import data from Amazon S3 with errors. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.</p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.status.as_ref()
    }
}
/// See [`JobSummary`](crate::model::JobSummary).
pub mod job_summary {

    /// A builder for [`JobSummary`](crate::model::JobSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::JobStatus>,
    }
    impl Builder {
        /// <p>The ID of the job.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the job.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The unique name that helps identify the job request.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The unique name that helps identify the job request.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The status of the bulk import job can be one of following values.</p>
        /// <ul>
        /// <li> <p> <code>PENDING</code> – IoT SiteWise is waiting for the current bulk import job to finish.</p> </li>
        /// <li> <p> <code>CANCELLED</code> – The bulk import job has been canceled.</p> </li>
        /// <li> <p> <code>RUNNING</code> – IoT SiteWise is processing your request to import your data from Amazon S3.</p> </li>
        /// <li> <p> <code>COMPLETED</code> – IoT SiteWise successfully completed your request to import data from Amazon S3.</p> </li>
        /// <li> <p> <code>FAILED</code> – IoT SiteWise couldn't process your request to import data from Amazon S3. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.</p> </li>
        /// <li> <p> <code>COMPLETED_WITH_FAILURES</code> – IoT SiteWise completed your request to import data from Amazon S3 with errors. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.</p> </li>
        /// </ul>
        pub fn status(mut self, input: crate::model::JobStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the bulk import job can be one of following values.</p>
        /// <ul>
        /// <li> <p> <code>PENDING</code> – IoT SiteWise is waiting for the current bulk import job to finish.</p> </li>
        /// <li> <p> <code>CANCELLED</code> – The bulk import job has been canceled.</p> </li>
        /// <li> <p> <code>RUNNING</code> – IoT SiteWise is processing your request to import your data from Amazon S3.</p> </li>
        /// <li> <p> <code>COMPLETED</code> – IoT SiteWise successfully completed your request to import data from Amazon S3.</p> </li>
        /// <li> <p> <code>FAILED</code> – IoT SiteWise couldn't process your request to import data from Amazon S3. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.</p> </li>
        /// <li> <p> <code>COMPLETED_WITH_FAILURES</code> – IoT SiteWise completed your request to import data from Amazon S3 with errors. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.</p> </li>
        /// </ul>
        pub fn set_status(mut self, input: std::option::Option<crate::model::JobStatus>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`JobSummary`](crate::model::JobSummary).
        pub fn build(self) -> crate::model::JobSummary {
            crate::model::JobSummary {
                id: self.id,
                name: self.name,
                status: self.status,
            }
        }
    }
}
impl JobSummary {
    /// Creates a new builder-style object to manufacture [`JobSummary`](crate::model::JobSummary).
    pub fn builder() -> crate::model::job_summary::Builder {
        crate::model::job_summary::Builder::default()
    }
}

/// When writing a match expression against `JobStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let jobstatus = unimplemented!();
/// match jobstatus {
///     JobStatus::Cancelled => { /* ... */ },
///     JobStatus::Completed => { /* ... */ },
///     JobStatus::CompletedWithFailures => { /* ... */ },
///     JobStatus::Failed => { /* ... */ },
///     JobStatus::Pending => { /* ... */ },
///     JobStatus::Running => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `jobstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `JobStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `JobStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `JobStatus::NewFeature` is defined.
/// Specifically, when `jobstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `JobStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum JobStatus {
    #[allow(missing_docs)] // documentation missing in model
    Cancelled,
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    CompletedWithFailures,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for JobStatus {
    fn from(s: &str) -> Self {
        match s {
            "CANCELLED" => JobStatus::Cancelled,
            "COMPLETED" => JobStatus::Completed,
            "COMPLETED_WITH_FAILURES" => JobStatus::CompletedWithFailures,
            "FAILED" => JobStatus::Failed,
            "PENDING" => JobStatus::Pending,
            "RUNNING" => JobStatus::Running,
            other => JobStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for JobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(JobStatus::from(s))
    }
}
impl JobStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            JobStatus::Cancelled => "CANCELLED",
            JobStatus::Completed => "COMPLETED",
            JobStatus::CompletedWithFailures => "COMPLETED_WITH_FAILURES",
            JobStatus::Failed => "FAILED",
            JobStatus::Pending => "PENDING",
            JobStatus::Running => "RUNNING",
            JobStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CANCELLED",
            "COMPLETED",
            "COMPLETED_WITH_FAILURES",
            "FAILED",
            "PENDING",
            "RUNNING",
        ]
    }
}
impl AsRef<str> for JobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ListBulkImportJobsFilter`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let listbulkimportjobsfilter = unimplemented!();
/// match listbulkimportjobsfilter {
///     ListBulkImportJobsFilter::All => { /* ... */ },
///     ListBulkImportJobsFilter::Cancelled => { /* ... */ },
///     ListBulkImportJobsFilter::Completed => { /* ... */ },
///     ListBulkImportJobsFilter::CompletedWithFailures => { /* ... */ },
///     ListBulkImportJobsFilter::Failed => { /* ... */ },
///     ListBulkImportJobsFilter::Pending => { /* ... */ },
///     ListBulkImportJobsFilter::Running => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `listbulkimportjobsfilter` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ListBulkImportJobsFilter::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ListBulkImportJobsFilter::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ListBulkImportJobsFilter::NewFeature` is defined.
/// Specifically, when `listbulkimportjobsfilter` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ListBulkImportJobsFilter::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ListBulkImportJobsFilter {
    #[allow(missing_docs)] // documentation missing in model
    All,
    #[allow(missing_docs)] // documentation missing in model
    Cancelled,
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    CompletedWithFailures,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ListBulkImportJobsFilter {
    fn from(s: &str) -> Self {
        match s {
            "ALL" => ListBulkImportJobsFilter::All,
            "CANCELLED" => ListBulkImportJobsFilter::Cancelled,
            "COMPLETED" => ListBulkImportJobsFilter::Completed,
            "COMPLETED_WITH_FAILURES" => ListBulkImportJobsFilter::CompletedWithFailures,
            "FAILED" => ListBulkImportJobsFilter::Failed,
            "PENDING" => ListBulkImportJobsFilter::Pending,
            "RUNNING" => ListBulkImportJobsFilter::Running,
            other => ListBulkImportJobsFilter::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ListBulkImportJobsFilter {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ListBulkImportJobsFilter::from(s))
    }
}
impl ListBulkImportJobsFilter {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ListBulkImportJobsFilter::All => "ALL",
            ListBulkImportJobsFilter::Cancelled => "CANCELLED",
            ListBulkImportJobsFilter::Completed => "COMPLETED",
            ListBulkImportJobsFilter::CompletedWithFailures => "COMPLETED_WITH_FAILURES",
            ListBulkImportJobsFilter::Failed => "FAILED",
            ListBulkImportJobsFilter::Pending => "PENDING",
            ListBulkImportJobsFilter::Running => "RUNNING",
            ListBulkImportJobsFilter::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ALL",
            "CANCELLED",
            "COMPLETED",
            "COMPLETED_WITH_FAILURES",
            "FAILED",
            "PENDING",
            "RUNNING",
        ]
    }
}
impl AsRef<str> for ListBulkImportJobsFilter {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains a summary of an associated asset.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssociatedAssetsSummary {
    /// <p>The ID of the asset.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the asset, which has the following format.</p>
    /// <p> <code>arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}</code> </p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the asset.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The ID of the asset model used to create the asset.</p>
    #[doc(hidden)]
    pub asset_model_id: std::option::Option<std::string::String>,
    /// <p>The date the asset was created, in Unix epoch time.</p>
    #[doc(hidden)]
    pub creation_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date the asset was last updated, in Unix epoch time.</p>
    #[doc(hidden)]
    pub last_update_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The current status of the asset.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::AssetStatus>,
    /// <p>A list of asset hierarchies that each contain a <code>hierarchyId</code>. A hierarchy specifies allowed parent/child asset relationships.</p>
    #[doc(hidden)]
    pub hierarchies: std::option::Option<std::vec::Vec<crate::model::AssetHierarchy>>,
    /// <p>A description for the asset.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
}
impl AssociatedAssetsSummary {
    /// <p>The ID of the asset.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the asset, which has the following format.</p>
    /// <p> <code>arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}</code> </p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the asset.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The ID of the asset model used to create the asset.</p>
    pub fn asset_model_id(&self) -> std::option::Option<&str> {
        self.asset_model_id.as_deref()
    }
    /// <p>The date the asset was created, in Unix epoch time.</p>
    pub fn creation_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_date.as_ref()
    }
    /// <p>The date the asset was last updated, in Unix epoch time.</p>
    pub fn last_update_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_update_date.as_ref()
    }
    /// <p>The current status of the asset.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::AssetStatus> {
        self.status.as_ref()
    }
    /// <p>A list of asset hierarchies that each contain a <code>hierarchyId</code>. A hierarchy specifies allowed parent/child asset relationships.</p>
    pub fn hierarchies(&self) -> std::option::Option<&[crate::model::AssetHierarchy]> {
        self.hierarchies.as_deref()
    }
    /// <p>A description for the asset.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}
/// See [`AssociatedAssetsSummary`](crate::model::AssociatedAssetsSummary).
pub mod associated_assets_summary {

    /// A builder for [`AssociatedAssetsSummary`](crate::model::AssociatedAssetsSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) asset_model_id: std::option::Option<std::string::String>,
        pub(crate) creation_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_update_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) status: std::option::Option<crate::model::AssetStatus>,
        pub(crate) hierarchies: std::option::Option<std::vec::Vec<crate::model::AssetHierarchy>>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the asset.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the asset.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the asset, which has the following format.</p>
        /// <p> <code>arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}</code> </p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the asset, which has the following format.</p>
        /// <p> <code>arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}</code> </p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the asset.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the asset.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The ID of the asset model used to create the asset.</p>
        pub fn asset_model_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_model_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset model used to create the asset.</p>
        pub fn set_asset_model_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.asset_model_id = input;
            self
        }
        /// <p>The date the asset was created, in Unix epoch time.</p>
        pub fn creation_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_date = Some(input);
            self
        }
        /// <p>The date the asset was created, in Unix epoch time.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>The date the asset was last updated, in Unix epoch time.</p>
        pub fn last_update_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_update_date = Some(input);
            self
        }
        /// <p>The date the asset was last updated, in Unix epoch time.</p>
        pub fn set_last_update_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_update_date = input;
            self
        }
        /// <p>The current status of the asset.</p>
        pub fn status(mut self, input: crate::model::AssetStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The current status of the asset.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::AssetStatus>) -> Self {
            self.status = input;
            self
        }
        /// Appends an item to `hierarchies`.
        ///
        /// To override the contents of this collection use [`set_hierarchies`](Self::set_hierarchies).
        ///
        /// <p>A list of asset hierarchies that each contain a <code>hierarchyId</code>. A hierarchy specifies allowed parent/child asset relationships.</p>
        pub fn hierarchies(mut self, input: crate::model::AssetHierarchy) -> Self {
            let mut v = self.hierarchies.unwrap_or_default();
            v.push(input);
            self.hierarchies = Some(v);
            self
        }
        /// <p>A list of asset hierarchies that each contain a <code>hierarchyId</code>. A hierarchy specifies allowed parent/child asset relationships.</p>
        pub fn set_hierarchies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AssetHierarchy>>,
        ) -> Self {
            self.hierarchies = input;
            self
        }
        /// <p>A description for the asset.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description for the asset.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociatedAssetsSummary`](crate::model::AssociatedAssetsSummary).
        pub fn build(self) -> crate::model::AssociatedAssetsSummary {
            crate::model::AssociatedAssetsSummary {
                id: self.id,
                arn: self.arn,
                name: self.name,
                asset_model_id: self.asset_model_id,
                creation_date: self.creation_date,
                last_update_date: self.last_update_date,
                status: self.status,
                hierarchies: self.hierarchies,
                description: self.description,
            }
        }
    }
}
impl AssociatedAssetsSummary {
    /// Creates a new builder-style object to manufacture [`AssociatedAssetsSummary`](crate::model::AssociatedAssetsSummary).
    pub fn builder() -> crate::model::associated_assets_summary::Builder {
        crate::model::associated_assets_summary::Builder::default()
    }
}

/// <p>Describes an asset hierarchy that contains a hierarchy's name and ID.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssetHierarchy {
    /// <p>The ID of the hierarchy. This ID is a <code>hierarchyId</code>.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The hierarchy name provided in the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_CreateAssetModel.html">CreateAssetModel</a> or <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetModel.html">UpdateAssetModel</a> API operation.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl AssetHierarchy {
    /// <p>The ID of the hierarchy. This ID is a <code>hierarchyId</code>.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The hierarchy name provided in the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_CreateAssetModel.html">CreateAssetModel</a> or <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetModel.html">UpdateAssetModel</a> API operation.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
/// See [`AssetHierarchy`](crate::model::AssetHierarchy).
pub mod asset_hierarchy {

    /// A builder for [`AssetHierarchy`](crate::model::AssetHierarchy).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the hierarchy. This ID is a <code>hierarchyId</code>.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the hierarchy. This ID is a <code>hierarchyId</code>.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The hierarchy name provided in the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_CreateAssetModel.html">CreateAssetModel</a> or <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetModel.html">UpdateAssetModel</a> API operation.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The hierarchy name provided in the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_CreateAssetModel.html">CreateAssetModel</a> or <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetModel.html">UpdateAssetModel</a> API operation.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`AssetHierarchy`](crate::model::AssetHierarchy).
        pub fn build(self) -> crate::model::AssetHierarchy {
            crate::model::AssetHierarchy {
                id: self.id,
                name: self.name,
            }
        }
    }
}
impl AssetHierarchy {
    /// Creates a new builder-style object to manufacture [`AssetHierarchy`](crate::model::AssetHierarchy).
    pub fn builder() -> crate::model::asset_hierarchy::Builder {
        crate::model::asset_hierarchy::Builder::default()
    }
}

/// When writing a match expression against `TraversalDirection`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let traversaldirection = unimplemented!();
/// match traversaldirection {
///     TraversalDirection::Child => { /* ... */ },
///     TraversalDirection::Parent => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `traversaldirection` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TraversalDirection::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TraversalDirection::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TraversalDirection::NewFeature` is defined.
/// Specifically, when `traversaldirection` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TraversalDirection::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TraversalDirection {
    #[allow(missing_docs)] // documentation missing in model
    Child,
    #[allow(missing_docs)] // documentation missing in model
    Parent,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TraversalDirection {
    fn from(s: &str) -> Self {
        match s {
            "CHILD" => TraversalDirection::Child,
            "PARENT" => TraversalDirection::Parent,
            other => {
                TraversalDirection::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for TraversalDirection {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TraversalDirection::from(s))
    }
}
impl TraversalDirection {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TraversalDirection::Child => "CHILD",
            TraversalDirection::Parent => "PARENT",
            TraversalDirection::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CHILD", "PARENT"]
    }
}
impl AsRef<str> for TraversalDirection {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains a summary of an asset.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssetSummary {
    /// <p>The ID of the asset.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the asset, which has the following format.</p>
    /// <p> <code>arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}</code> </p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the asset.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The ID of the asset model used to create this asset.</p>
    #[doc(hidden)]
    pub asset_model_id: std::option::Option<std::string::String>,
    /// <p>The date the asset was created, in Unix epoch time.</p>
    #[doc(hidden)]
    pub creation_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date the asset was last updated, in Unix epoch time.</p>
    #[doc(hidden)]
    pub last_update_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The current status of the asset.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::AssetStatus>,
    /// <p>A list of asset hierarchies that each contain a <code>hierarchyId</code>. A hierarchy specifies allowed parent/child asset relationships.</p>
    #[doc(hidden)]
    pub hierarchies: std::option::Option<std::vec::Vec<crate::model::AssetHierarchy>>,
    /// <p>A description for the asset.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
}
impl AssetSummary {
    /// <p>The ID of the asset.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the asset, which has the following format.</p>
    /// <p> <code>arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}</code> </p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the asset.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The ID of the asset model used to create this asset.</p>
    pub fn asset_model_id(&self) -> std::option::Option<&str> {
        self.asset_model_id.as_deref()
    }
    /// <p>The date the asset was created, in Unix epoch time.</p>
    pub fn creation_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_date.as_ref()
    }
    /// <p>The date the asset was last updated, in Unix epoch time.</p>
    pub fn last_update_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_update_date.as_ref()
    }
    /// <p>The current status of the asset.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::AssetStatus> {
        self.status.as_ref()
    }
    /// <p>A list of asset hierarchies that each contain a <code>hierarchyId</code>. A hierarchy specifies allowed parent/child asset relationships.</p>
    pub fn hierarchies(&self) -> std::option::Option<&[crate::model::AssetHierarchy]> {
        self.hierarchies.as_deref()
    }
    /// <p>A description for the asset.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}
/// See [`AssetSummary`](crate::model::AssetSummary).
pub mod asset_summary {

    /// A builder for [`AssetSummary`](crate::model::AssetSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) asset_model_id: std::option::Option<std::string::String>,
        pub(crate) creation_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_update_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) status: std::option::Option<crate::model::AssetStatus>,
        pub(crate) hierarchies: std::option::Option<std::vec::Vec<crate::model::AssetHierarchy>>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the asset.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the asset.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the asset, which has the following format.</p>
        /// <p> <code>arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}</code> </p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the asset, which has the following format.</p>
        /// <p> <code>arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}</code> </p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the asset.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the asset.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The ID of the asset model used to create this asset.</p>
        pub fn asset_model_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_model_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset model used to create this asset.</p>
        pub fn set_asset_model_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.asset_model_id = input;
            self
        }
        /// <p>The date the asset was created, in Unix epoch time.</p>
        pub fn creation_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_date = Some(input);
            self
        }
        /// <p>The date the asset was created, in Unix epoch time.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>The date the asset was last updated, in Unix epoch time.</p>
        pub fn last_update_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_update_date = Some(input);
            self
        }
        /// <p>The date the asset was last updated, in Unix epoch time.</p>
        pub fn set_last_update_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_update_date = input;
            self
        }
        /// <p>The current status of the asset.</p>
        pub fn status(mut self, input: crate::model::AssetStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The current status of the asset.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::AssetStatus>) -> Self {
            self.status = input;
            self
        }
        /// Appends an item to `hierarchies`.
        ///
        /// To override the contents of this collection use [`set_hierarchies`](Self::set_hierarchies).
        ///
        /// <p>A list of asset hierarchies that each contain a <code>hierarchyId</code>. A hierarchy specifies allowed parent/child asset relationships.</p>
        pub fn hierarchies(mut self, input: crate::model::AssetHierarchy) -> Self {
            let mut v = self.hierarchies.unwrap_or_default();
            v.push(input);
            self.hierarchies = Some(v);
            self
        }
        /// <p>A list of asset hierarchies that each contain a <code>hierarchyId</code>. A hierarchy specifies allowed parent/child asset relationships.</p>
        pub fn set_hierarchies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AssetHierarchy>>,
        ) -> Self {
            self.hierarchies = input;
            self
        }
        /// <p>A description for the asset.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description for the asset.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`AssetSummary`](crate::model::AssetSummary).
        pub fn build(self) -> crate::model::AssetSummary {
            crate::model::AssetSummary {
                id: self.id,
                arn: self.arn,
                name: self.name,
                asset_model_id: self.asset_model_id,
                creation_date: self.creation_date,
                last_update_date: self.last_update_date,
                status: self.status,
                hierarchies: self.hierarchies,
                description: self.description,
            }
        }
    }
}
impl AssetSummary {
    /// Creates a new builder-style object to manufacture [`AssetSummary`](crate::model::AssetSummary).
    pub fn builder() -> crate::model::asset_summary::Builder {
        crate::model::asset_summary::Builder::default()
    }
}

/// When writing a match expression against `ListAssetsFilter`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let listassetsfilter = unimplemented!();
/// match listassetsfilter {
///     ListAssetsFilter::All => { /* ... */ },
///     ListAssetsFilter::TopLevel => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `listassetsfilter` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ListAssetsFilter::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ListAssetsFilter::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ListAssetsFilter::NewFeature` is defined.
/// Specifically, when `listassetsfilter` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ListAssetsFilter::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ListAssetsFilter {
    #[allow(missing_docs)] // documentation missing in model
    All,
    #[allow(missing_docs)] // documentation missing in model
    TopLevel,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ListAssetsFilter {
    fn from(s: &str) -> Self {
        match s {
            "ALL" => ListAssetsFilter::All,
            "TOP_LEVEL" => ListAssetsFilter::TopLevel,
            other => ListAssetsFilter::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ListAssetsFilter {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ListAssetsFilter::from(s))
    }
}
impl ListAssetsFilter {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ListAssetsFilter::All => "ALL",
            ListAssetsFilter::TopLevel => "TOP_LEVEL",
            ListAssetsFilter::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALL", "TOP_LEVEL"]
    }
}
impl AsRef<str> for ListAssetsFilter {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about assets that are related to one another.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssetRelationshipSummary {
    /// <p>The assets that are related through an asset hierarchy.</p>
    /// <p>This object is present if the <code>relationshipType</code> is <code>HIERARCHY</code>.</p>
    #[doc(hidden)]
    pub hierarchy_info: std::option::Option<crate::model::AssetHierarchyInfo>,
    /// <p>The relationship type of the assets in this relationship. This value is one of the following:</p>
    /// <ul>
    /// <li> <p> <code>HIERARCHY</code> – The assets are related through an asset hierarchy. If you specify this relationship type, this asset relationship includes the <code>hierarchyInfo</code> object.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub relationship_type: std::option::Option<crate::model::AssetRelationshipType>,
}
impl AssetRelationshipSummary {
    /// <p>The assets that are related through an asset hierarchy.</p>
    /// <p>This object is present if the <code>relationshipType</code> is <code>HIERARCHY</code>.</p>
    pub fn hierarchy_info(&self) -> std::option::Option<&crate::model::AssetHierarchyInfo> {
        self.hierarchy_info.as_ref()
    }
    /// <p>The relationship type of the assets in this relationship. This value is one of the following:</p>
    /// <ul>
    /// <li> <p> <code>HIERARCHY</code> – The assets are related through an asset hierarchy. If you specify this relationship type, this asset relationship includes the <code>hierarchyInfo</code> object.</p> </li>
    /// </ul>
    pub fn relationship_type(&self) -> std::option::Option<&crate::model::AssetRelationshipType> {
        self.relationship_type.as_ref()
    }
}
/// See [`AssetRelationshipSummary`](crate::model::AssetRelationshipSummary).
pub mod asset_relationship_summary {

    /// A builder for [`AssetRelationshipSummary`](crate::model::AssetRelationshipSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) hierarchy_info: std::option::Option<crate::model::AssetHierarchyInfo>,
        pub(crate) relationship_type: std::option::Option<crate::model::AssetRelationshipType>,
    }
    impl Builder {
        /// <p>The assets that are related through an asset hierarchy.</p>
        /// <p>This object is present if the <code>relationshipType</code> is <code>HIERARCHY</code>.</p>
        pub fn hierarchy_info(mut self, input: crate::model::AssetHierarchyInfo) -> Self {
            self.hierarchy_info = Some(input);
            self
        }
        /// <p>The assets that are related through an asset hierarchy.</p>
        /// <p>This object is present if the <code>relationshipType</code> is <code>HIERARCHY</code>.</p>
        pub fn set_hierarchy_info(
            mut self,
            input: std::option::Option<crate::model::AssetHierarchyInfo>,
        ) -> Self {
            self.hierarchy_info = input;
            self
        }
        /// <p>The relationship type of the assets in this relationship. This value is one of the following:</p>
        /// <ul>
        /// <li> <p> <code>HIERARCHY</code> – The assets are related through an asset hierarchy. If you specify this relationship type, this asset relationship includes the <code>hierarchyInfo</code> object.</p> </li>
        /// </ul>
        pub fn relationship_type(mut self, input: crate::model::AssetRelationshipType) -> Self {
            self.relationship_type = Some(input);
            self
        }
        /// <p>The relationship type of the assets in this relationship. This value is one of the following:</p>
        /// <ul>
        /// <li> <p> <code>HIERARCHY</code> – The assets are related through an asset hierarchy. If you specify this relationship type, this asset relationship includes the <code>hierarchyInfo</code> object.</p> </li>
        /// </ul>
        pub fn set_relationship_type(
            mut self,
            input: std::option::Option<crate::model::AssetRelationshipType>,
        ) -> Self {
            self.relationship_type = input;
            self
        }
        /// Consumes the builder and constructs a [`AssetRelationshipSummary`](crate::model::AssetRelationshipSummary).
        pub fn build(self) -> crate::model::AssetRelationshipSummary {
            crate::model::AssetRelationshipSummary {
                hierarchy_info: self.hierarchy_info,
                relationship_type: self.relationship_type,
            }
        }
    }
}
impl AssetRelationshipSummary {
    /// Creates a new builder-style object to manufacture [`AssetRelationshipSummary`](crate::model::AssetRelationshipSummary).
    pub fn builder() -> crate::model::asset_relationship_summary::Builder {
        crate::model::asset_relationship_summary::Builder::default()
    }
}

/// When writing a match expression against `AssetRelationshipType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let assetrelationshiptype = unimplemented!();
/// match assetrelationshiptype {
///     AssetRelationshipType::Hierarchy => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `assetrelationshiptype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AssetRelationshipType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AssetRelationshipType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AssetRelationshipType::NewFeature` is defined.
/// Specifically, when `assetrelationshiptype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AssetRelationshipType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AssetRelationshipType {
    #[allow(missing_docs)] // documentation missing in model
    Hierarchy,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AssetRelationshipType {
    fn from(s: &str) -> Self {
        match s {
            "HIERARCHY" => AssetRelationshipType::Hierarchy,
            other => {
                AssetRelationshipType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for AssetRelationshipType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AssetRelationshipType::from(s))
    }
}
impl AssetRelationshipType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AssetRelationshipType::Hierarchy => "HIERARCHY",
            AssetRelationshipType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["HIERARCHY"]
    }
}
impl AsRef<str> for AssetRelationshipType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about a parent asset and a child asset that are related through an asset hierarchy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssetHierarchyInfo {
    /// <p>The ID of the parent asset in this asset relationship.</p>
    #[doc(hidden)]
    pub parent_asset_id: std::option::Option<std::string::String>,
    /// <p>The ID of the child asset in this asset relationship.</p>
    #[doc(hidden)]
    pub child_asset_id: std::option::Option<std::string::String>,
}
impl AssetHierarchyInfo {
    /// <p>The ID of the parent asset in this asset relationship.</p>
    pub fn parent_asset_id(&self) -> std::option::Option<&str> {
        self.parent_asset_id.as_deref()
    }
    /// <p>The ID of the child asset in this asset relationship.</p>
    pub fn child_asset_id(&self) -> std::option::Option<&str> {
        self.child_asset_id.as_deref()
    }
}
/// See [`AssetHierarchyInfo`](crate::model::AssetHierarchyInfo).
pub mod asset_hierarchy_info {

    /// A builder for [`AssetHierarchyInfo`](crate::model::AssetHierarchyInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) parent_asset_id: std::option::Option<std::string::String>,
        pub(crate) child_asset_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the parent asset in this asset relationship.</p>
        pub fn parent_asset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.parent_asset_id = Some(input.into());
            self
        }
        /// <p>The ID of the parent asset in this asset relationship.</p>
        pub fn set_parent_asset_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parent_asset_id = input;
            self
        }
        /// <p>The ID of the child asset in this asset relationship.</p>
        pub fn child_asset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.child_asset_id = Some(input.into());
            self
        }
        /// <p>The ID of the child asset in this asset relationship.</p>
        pub fn set_child_asset_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.child_asset_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AssetHierarchyInfo`](crate::model::AssetHierarchyInfo).
        pub fn build(self) -> crate::model::AssetHierarchyInfo {
            crate::model::AssetHierarchyInfo {
                parent_asset_id: self.parent_asset_id,
                child_asset_id: self.child_asset_id,
            }
        }
    }
}
impl AssetHierarchyInfo {
    /// Creates a new builder-style object to manufacture [`AssetHierarchyInfo`](crate::model::AssetHierarchyInfo).
    pub fn builder() -> crate::model::asset_hierarchy_info::Builder {
        crate::model::asset_hierarchy_info::Builder::default()
    }
}

/// When writing a match expression against `TraversalType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let traversaltype = unimplemented!();
/// match traversaltype {
///     TraversalType::PathToRoot => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `traversaltype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TraversalType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TraversalType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TraversalType::NewFeature` is defined.
/// Specifically, when `traversaltype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TraversalType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TraversalType {
    #[allow(missing_docs)] // documentation missing in model
    PathToRoot,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TraversalType {
    fn from(s: &str) -> Self {
        match s {
            "PATH_TO_ROOT" => TraversalType::PathToRoot,
            other => TraversalType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for TraversalType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TraversalType::from(s))
    }
}
impl TraversalType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TraversalType::PathToRoot => "PATH_TO_ROOT",
            TraversalType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["PATH_TO_ROOT"]
    }
}
impl AsRef<str> for TraversalType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains a summary of a property associated with an asset.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssetPropertySummary {
    /// <p>The ID of the property.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub alias: std::option::Option<std::string::String>,
    /// <p> The unit of measure (such as Newtons or RPM) of the asset property. </p>
    #[doc(hidden)]
    pub unit: std::option::Option<std::string::String>,
    /// <p>Contains asset property value notification information. When the notification state is enabled, IoT SiteWise publishes property value updates to a unique MQTT topic. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/interact-with-other-services.html">Interacting with other services</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub notification: std::option::Option<crate::model::PropertyNotification>,
    /// <p> The ID of the composite model that contains the asset property. </p>
    #[doc(hidden)]
    pub asset_composite_model_id: std::option::Option<std::string::String>,
}
impl AssetPropertySummary {
    /// <p>The ID of the property.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn alias(&self) -> std::option::Option<&str> {
        self.alias.as_deref()
    }
    /// <p> The unit of measure (such as Newtons or RPM) of the asset property. </p>
    pub fn unit(&self) -> std::option::Option<&str> {
        self.unit.as_deref()
    }
    /// <p>Contains asset property value notification information. When the notification state is enabled, IoT SiteWise publishes property value updates to a unique MQTT topic. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/interact-with-other-services.html">Interacting with other services</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn notification(&self) -> std::option::Option<&crate::model::PropertyNotification> {
        self.notification.as_ref()
    }
    /// <p> The ID of the composite model that contains the asset property. </p>
    pub fn asset_composite_model_id(&self) -> std::option::Option<&str> {
        self.asset_composite_model_id.as_deref()
    }
}
/// See [`AssetPropertySummary`](crate::model::AssetPropertySummary).
pub mod asset_property_summary {

    /// A builder for [`AssetPropertySummary`](crate::model::AssetPropertySummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) alias: std::option::Option<std::string::String>,
        pub(crate) unit: std::option::Option<std::string::String>,
        pub(crate) notification: std::option::Option<crate::model::PropertyNotification>,
        pub(crate) asset_composite_model_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the property.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the property.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.alias = Some(input.into());
            self
        }
        /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alias = input;
            self
        }
        /// <p> The unit of measure (such as Newtons or RPM) of the asset property. </p>
        pub fn unit(mut self, input: impl Into<std::string::String>) -> Self {
            self.unit = Some(input.into());
            self
        }
        /// <p> The unit of measure (such as Newtons or RPM) of the asset property. </p>
        pub fn set_unit(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.unit = input;
            self
        }
        /// <p>Contains asset property value notification information. When the notification state is enabled, IoT SiteWise publishes property value updates to a unique MQTT topic. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/interact-with-other-services.html">Interacting with other services</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn notification(mut self, input: crate::model::PropertyNotification) -> Self {
            self.notification = Some(input);
            self
        }
        /// <p>Contains asset property value notification information. When the notification state is enabled, IoT SiteWise publishes property value updates to a unique MQTT topic. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/interact-with-other-services.html">Interacting with other services</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_notification(
            mut self,
            input: std::option::Option<crate::model::PropertyNotification>,
        ) -> Self {
            self.notification = input;
            self
        }
        /// <p> The ID of the composite model that contains the asset property. </p>
        pub fn asset_composite_model_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_composite_model_id = Some(input.into());
            self
        }
        /// <p> The ID of the composite model that contains the asset property. </p>
        pub fn set_asset_composite_model_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.asset_composite_model_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AssetPropertySummary`](crate::model::AssetPropertySummary).
        pub fn build(self) -> crate::model::AssetPropertySummary {
            crate::model::AssetPropertySummary {
                id: self.id,
                alias: self.alias,
                unit: self.unit,
                notification: self.notification,
                asset_composite_model_id: self.asset_composite_model_id,
            }
        }
    }
}
impl AssetPropertySummary {
    /// Creates a new builder-style object to manufacture [`AssetPropertySummary`](crate::model::AssetPropertySummary).
    pub fn builder() -> crate::model::asset_property_summary::Builder {
        crate::model::asset_property_summary::Builder::default()
    }
}

/// <p>Contains asset property value notification information. When the notification state is enabled, IoT SiteWise publishes property value updates to a unique MQTT topic. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/interact-with-other-services.html">Interacting with other services</a> in the <i>IoT SiteWise User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PropertyNotification {
    /// <p>The MQTT topic to which IoT SiteWise publishes property value update notifications.</p>
    #[doc(hidden)]
    pub topic: std::option::Option<std::string::String>,
    /// <p>The current notification state.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::PropertyNotificationState>,
}
impl PropertyNotification {
    /// <p>The MQTT topic to which IoT SiteWise publishes property value update notifications.</p>
    pub fn topic(&self) -> std::option::Option<&str> {
        self.topic.as_deref()
    }
    /// <p>The current notification state.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::PropertyNotificationState> {
        self.state.as_ref()
    }
}
/// See [`PropertyNotification`](crate::model::PropertyNotification).
pub mod property_notification {

    /// A builder for [`PropertyNotification`](crate::model::PropertyNotification).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) topic: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::PropertyNotificationState>,
    }
    impl Builder {
        /// <p>The MQTT topic to which IoT SiteWise publishes property value update notifications.</p>
        pub fn topic(mut self, input: impl Into<std::string::String>) -> Self {
            self.topic = Some(input.into());
            self
        }
        /// <p>The MQTT topic to which IoT SiteWise publishes property value update notifications.</p>
        pub fn set_topic(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.topic = input;
            self
        }
        /// <p>The current notification state.</p>
        pub fn state(mut self, input: crate::model::PropertyNotificationState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current notification state.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::PropertyNotificationState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`PropertyNotification`](crate::model::PropertyNotification).
        pub fn build(self) -> crate::model::PropertyNotification {
            crate::model::PropertyNotification {
                topic: self.topic,
                state: self.state,
            }
        }
    }
}
impl PropertyNotification {
    /// Creates a new builder-style object to manufacture [`PropertyNotification`](crate::model::PropertyNotification).
    pub fn builder() -> crate::model::property_notification::Builder {
        crate::model::property_notification::Builder::default()
    }
}

/// When writing a match expression against `ListAssetPropertiesFilter`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let listassetpropertiesfilter = unimplemented!();
/// match listassetpropertiesfilter {
///     ListAssetPropertiesFilter::All => { /* ... */ },
///     ListAssetPropertiesFilter::Base => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `listassetpropertiesfilter` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ListAssetPropertiesFilter::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ListAssetPropertiesFilter::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ListAssetPropertiesFilter::NewFeature` is defined.
/// Specifically, when `listassetpropertiesfilter` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ListAssetPropertiesFilter::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ListAssetPropertiesFilter {
    #[allow(missing_docs)] // documentation missing in model
    All,
    #[allow(missing_docs)] // documentation missing in model
    Base,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ListAssetPropertiesFilter {
    fn from(s: &str) -> Self {
        match s {
            "ALL" => ListAssetPropertiesFilter::All,
            "BASE" => ListAssetPropertiesFilter::Base,
            other => ListAssetPropertiesFilter::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ListAssetPropertiesFilter {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ListAssetPropertiesFilter::from(s))
    }
}
impl ListAssetPropertiesFilter {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ListAssetPropertiesFilter::All => "ALL",
            ListAssetPropertiesFilter::Base => "BASE",
            ListAssetPropertiesFilter::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALL", "BASE"]
    }
}
impl AsRef<str> for ListAssetPropertiesFilter {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains a summary of an asset model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssetModelSummary {
    /// <p>The ID of the asset model (used with IoT SiteWise APIs).</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the asset model, which has the following format.</p>
    /// <p> <code>arn:${Partition}:iotsitewise:${Region}:${Account}:asset-model/${AssetModelId}</code> </p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the asset model.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The asset model description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The date the asset model was created, in Unix epoch time.</p>
    #[doc(hidden)]
    pub creation_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date the asset model was last updated, in Unix epoch time.</p>
    #[doc(hidden)]
    pub last_update_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The current status of the asset model.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::AssetModelStatus>,
}
impl AssetModelSummary {
    /// <p>The ID of the asset model (used with IoT SiteWise APIs).</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the asset model, which has the following format.</p>
    /// <p> <code>arn:${Partition}:iotsitewise:${Region}:${Account}:asset-model/${AssetModelId}</code> </p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the asset model.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The asset model description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The date the asset model was created, in Unix epoch time.</p>
    pub fn creation_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_date.as_ref()
    }
    /// <p>The date the asset model was last updated, in Unix epoch time.</p>
    pub fn last_update_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_update_date.as_ref()
    }
    /// <p>The current status of the asset model.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::AssetModelStatus> {
        self.status.as_ref()
    }
}
/// See [`AssetModelSummary`](crate::model::AssetModelSummary).
pub mod asset_model_summary {

    /// A builder for [`AssetModelSummary`](crate::model::AssetModelSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) creation_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_update_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) status: std::option::Option<crate::model::AssetModelStatus>,
    }
    impl Builder {
        /// <p>The ID of the asset model (used with IoT SiteWise APIs).</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the asset model (used with IoT SiteWise APIs).</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the asset model, which has the following format.</p>
        /// <p> <code>arn:${Partition}:iotsitewise:${Region}:${Account}:asset-model/${AssetModelId}</code> </p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the asset model, which has the following format.</p>
        /// <p> <code>arn:${Partition}:iotsitewise:${Region}:${Account}:asset-model/${AssetModelId}</code> </p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the asset model.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the asset model.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The asset model description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The asset model description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The date the asset model was created, in Unix epoch time.</p>
        pub fn creation_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_date = Some(input);
            self
        }
        /// <p>The date the asset model was created, in Unix epoch time.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>The date the asset model was last updated, in Unix epoch time.</p>
        pub fn last_update_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_update_date = Some(input);
            self
        }
        /// <p>The date the asset model was last updated, in Unix epoch time.</p>
        pub fn set_last_update_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_update_date = input;
            self
        }
        /// <p>The current status of the asset model.</p>
        pub fn status(mut self, input: crate::model::AssetModelStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The current status of the asset model.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::AssetModelStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`AssetModelSummary`](crate::model::AssetModelSummary).
        pub fn build(self) -> crate::model::AssetModelSummary {
            crate::model::AssetModelSummary {
                id: self.id,
                arn: self.arn,
                name: self.name,
                description: self.description,
                creation_date: self.creation_date,
                last_update_date: self.last_update_date,
                status: self.status,
            }
        }
    }
}
impl AssetModelSummary {
    /// Creates a new builder-style object to manufacture [`AssetModelSummary`](crate::model::AssetModelSummary).
    pub fn builder() -> crate::model::asset_model_summary::Builder {
        crate::model::asset_model_summary::Builder::default()
    }
}

/// <p>Contains a summary of a property associated with a model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssetModelPropertySummary {
    /// <p>The ID of the property.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the property.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The data type of the property.</p>
    #[doc(hidden)]
    pub data_type: std::option::Option<crate::model::PropertyDataType>,
    /// <p>The data type of the structure for this property. This parameter exists on properties that have the <code>STRUCT</code> data type.</p>
    #[doc(hidden)]
    pub data_type_spec: std::option::Option<std::string::String>,
    /// <p>The unit (such as <code>Newtons</code> or <code>RPM</code>) of the property.</p>
    #[doc(hidden)]
    pub unit: std::option::Option<std::string::String>,
    /// <p>Contains a property type, which can be one of <code>attribute</code>, <code>measurement</code>, <code>metric</code>, or <code>transform</code>.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::PropertyType>,
    /// <p> The ID of the composite model that contains the asset model property. </p>
    #[doc(hidden)]
    pub asset_model_composite_model_id: std::option::Option<std::string::String>,
}
impl AssetModelPropertySummary {
    /// <p>The ID of the property.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the property.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The data type of the property.</p>
    pub fn data_type(&self) -> std::option::Option<&crate::model::PropertyDataType> {
        self.data_type.as_ref()
    }
    /// <p>The data type of the structure for this property. This parameter exists on properties that have the <code>STRUCT</code> data type.</p>
    pub fn data_type_spec(&self) -> std::option::Option<&str> {
        self.data_type_spec.as_deref()
    }
    /// <p>The unit (such as <code>Newtons</code> or <code>RPM</code>) of the property.</p>
    pub fn unit(&self) -> std::option::Option<&str> {
        self.unit.as_deref()
    }
    /// <p>Contains a property type, which can be one of <code>attribute</code>, <code>measurement</code>, <code>metric</code>, or <code>transform</code>.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::PropertyType> {
        self.r#type.as_ref()
    }
    /// <p> The ID of the composite model that contains the asset model property. </p>
    pub fn asset_model_composite_model_id(&self) -> std::option::Option<&str> {
        self.asset_model_composite_model_id.as_deref()
    }
}
/// See [`AssetModelPropertySummary`](crate::model::AssetModelPropertySummary).
pub mod asset_model_property_summary {

    /// A builder for [`AssetModelPropertySummary`](crate::model::AssetModelPropertySummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) data_type: std::option::Option<crate::model::PropertyDataType>,
        pub(crate) data_type_spec: std::option::Option<std::string::String>,
        pub(crate) unit: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::PropertyType>,
        pub(crate) asset_model_composite_model_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the property.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the property.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the property.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the property.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The data type of the property.</p>
        pub fn data_type(mut self, input: crate::model::PropertyDataType) -> Self {
            self.data_type = Some(input);
            self
        }
        /// <p>The data type of the property.</p>
        pub fn set_data_type(
            mut self,
            input: std::option::Option<crate::model::PropertyDataType>,
        ) -> Self {
            self.data_type = input;
            self
        }
        /// <p>The data type of the structure for this property. This parameter exists on properties that have the <code>STRUCT</code> data type.</p>
        pub fn data_type_spec(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_type_spec = Some(input.into());
            self
        }
        /// <p>The data type of the structure for this property. This parameter exists on properties that have the <code>STRUCT</code> data type.</p>
        pub fn set_data_type_spec(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_type_spec = input;
            self
        }
        /// <p>The unit (such as <code>Newtons</code> or <code>RPM</code>) of the property.</p>
        pub fn unit(mut self, input: impl Into<std::string::String>) -> Self {
            self.unit = Some(input.into());
            self
        }
        /// <p>The unit (such as <code>Newtons</code> or <code>RPM</code>) of the property.</p>
        pub fn set_unit(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.unit = input;
            self
        }
        /// <p>Contains a property type, which can be one of <code>attribute</code>, <code>measurement</code>, <code>metric</code>, or <code>transform</code>.</p>
        pub fn r#type(mut self, input: crate::model::PropertyType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>Contains a property type, which can be one of <code>attribute</code>, <code>measurement</code>, <code>metric</code>, or <code>transform</code>.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::PropertyType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p> The ID of the composite model that contains the asset model property. </p>
        pub fn asset_model_composite_model_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.asset_model_composite_model_id = Some(input.into());
            self
        }
        /// <p> The ID of the composite model that contains the asset model property. </p>
        pub fn set_asset_model_composite_model_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.asset_model_composite_model_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AssetModelPropertySummary`](crate::model::AssetModelPropertySummary).
        pub fn build(self) -> crate::model::AssetModelPropertySummary {
            crate::model::AssetModelPropertySummary {
                id: self.id,
                name: self.name,
                data_type: self.data_type,
                data_type_spec: self.data_type_spec,
                unit: self.unit,
                r#type: self.r#type,
                asset_model_composite_model_id: self.asset_model_composite_model_id,
            }
        }
    }
}
impl AssetModelPropertySummary {
    /// Creates a new builder-style object to manufacture [`AssetModelPropertySummary`](crate::model::AssetModelPropertySummary).
    pub fn builder() -> crate::model::asset_model_property_summary::Builder {
        crate::model::asset_model_property_summary::Builder::default()
    }
}

/// When writing a match expression against `ListAssetModelPropertiesFilter`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let listassetmodelpropertiesfilter = unimplemented!();
/// match listassetmodelpropertiesfilter {
///     ListAssetModelPropertiesFilter::All => { /* ... */ },
///     ListAssetModelPropertiesFilter::Base => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `listassetmodelpropertiesfilter` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ListAssetModelPropertiesFilter::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ListAssetModelPropertiesFilter::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ListAssetModelPropertiesFilter::NewFeature` is defined.
/// Specifically, when `listassetmodelpropertiesfilter` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ListAssetModelPropertiesFilter::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ListAssetModelPropertiesFilter {
    #[allow(missing_docs)] // documentation missing in model
    All,
    #[allow(missing_docs)] // documentation missing in model
    Base,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ListAssetModelPropertiesFilter {
    fn from(s: &str) -> Self {
        match s {
            "ALL" => ListAssetModelPropertiesFilter::All,
            "BASE" => ListAssetModelPropertiesFilter::Base,
            other => ListAssetModelPropertiesFilter::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ListAssetModelPropertiesFilter {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ListAssetModelPropertiesFilter::from(s))
    }
}
impl ListAssetModelPropertiesFilter {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ListAssetModelPropertiesFilter::All => "ALL",
            ListAssetModelPropertiesFilter::Base => "BASE",
            ListAssetModelPropertiesFilter::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALL", "BASE"]
    }
}
impl AsRef<str> for ListAssetModelPropertiesFilter {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains an access policy that defines an identity's access to an IoT SiteWise Monitor resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AccessPolicySummary {
    /// <p>The ID of the access policy.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The identity (an IAM Identity Center user, an IAM Identity Center group, or an IAM user).</p>
    #[doc(hidden)]
    pub identity: std::option::Option<crate::model::Identity>,
    /// <p>The IoT SiteWise Monitor resource (a portal or project).</p>
    #[doc(hidden)]
    pub resource: std::option::Option<crate::model::Resource>,
    /// <p>The permissions for the access policy. Note that a project <code>ADMINISTRATOR</code> is also known as a project owner.</p>
    #[doc(hidden)]
    pub permission: std::option::Option<crate::model::Permission>,
    /// <p>The date the access policy was created, in Unix epoch time.</p>
    #[doc(hidden)]
    pub creation_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date the access policy was last updated, in Unix epoch time.</p>
    #[doc(hidden)]
    pub last_update_date: std::option::Option<aws_smithy_types::DateTime>,
}
impl AccessPolicySummary {
    /// <p>The ID of the access policy.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The identity (an IAM Identity Center user, an IAM Identity Center group, or an IAM user).</p>
    pub fn identity(&self) -> std::option::Option<&crate::model::Identity> {
        self.identity.as_ref()
    }
    /// <p>The IoT SiteWise Monitor resource (a portal or project).</p>
    pub fn resource(&self) -> std::option::Option<&crate::model::Resource> {
        self.resource.as_ref()
    }
    /// <p>The permissions for the access policy. Note that a project <code>ADMINISTRATOR</code> is also known as a project owner.</p>
    pub fn permission(&self) -> std::option::Option<&crate::model::Permission> {
        self.permission.as_ref()
    }
    /// <p>The date the access policy was created, in Unix epoch time.</p>
    pub fn creation_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_date.as_ref()
    }
    /// <p>The date the access policy was last updated, in Unix epoch time.</p>
    pub fn last_update_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_update_date.as_ref()
    }
}
/// See [`AccessPolicySummary`](crate::model::AccessPolicySummary).
pub mod access_policy_summary {

    /// A builder for [`AccessPolicySummary`](crate::model::AccessPolicySummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) identity: std::option::Option<crate::model::Identity>,
        pub(crate) resource: std::option::Option<crate::model::Resource>,
        pub(crate) permission: std::option::Option<crate::model::Permission>,
        pub(crate) creation_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_update_date: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The ID of the access policy.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the access policy.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The identity (an IAM Identity Center user, an IAM Identity Center group, or an IAM user).</p>
        pub fn identity(mut self, input: crate::model::Identity) -> Self {
            self.identity = Some(input);
            self
        }
        /// <p>The identity (an IAM Identity Center user, an IAM Identity Center group, or an IAM user).</p>
        pub fn set_identity(mut self, input: std::option::Option<crate::model::Identity>) -> Self {
            self.identity = input;
            self
        }
        /// <p>The IoT SiteWise Monitor resource (a portal or project).</p>
        pub fn resource(mut self, input: crate::model::Resource) -> Self {
            self.resource = Some(input);
            self
        }
        /// <p>The IoT SiteWise Monitor resource (a portal or project).</p>
        pub fn set_resource(mut self, input: std::option::Option<crate::model::Resource>) -> Self {
            self.resource = input;
            self
        }
        /// <p>The permissions for the access policy. Note that a project <code>ADMINISTRATOR</code> is also known as a project owner.</p>
        pub fn permission(mut self, input: crate::model::Permission) -> Self {
            self.permission = Some(input);
            self
        }
        /// <p>The permissions for the access policy. Note that a project <code>ADMINISTRATOR</code> is also known as a project owner.</p>
        pub fn set_permission(
            mut self,
            input: std::option::Option<crate::model::Permission>,
        ) -> Self {
            self.permission = input;
            self
        }
        /// <p>The date the access policy was created, in Unix epoch time.</p>
        pub fn creation_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_date = Some(input);
            self
        }
        /// <p>The date the access policy was created, in Unix epoch time.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>The date the access policy was last updated, in Unix epoch time.</p>
        pub fn last_update_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_update_date = Some(input);
            self
        }
        /// <p>The date the access policy was last updated, in Unix epoch time.</p>
        pub fn set_last_update_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_update_date = input;
            self
        }
        /// Consumes the builder and constructs a [`AccessPolicySummary`](crate::model::AccessPolicySummary).
        pub fn build(self) -> crate::model::AccessPolicySummary {
            crate::model::AccessPolicySummary {
                id: self.id,
                identity: self.identity,
                resource: self.resource,
                permission: self.permission,
                creation_date: self.creation_date,
                last_update_date: self.last_update_date,
            }
        }
    }
}
impl AccessPolicySummary {
    /// Creates a new builder-style object to manufacture [`AccessPolicySummary`](crate::model::AccessPolicySummary).
    pub fn builder() -> crate::model::access_policy_summary::Builder {
        crate::model::access_policy_summary::Builder::default()
    }
}

/// When writing a match expression against `ResourceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let resourcetype = unimplemented!();
/// match resourcetype {
///     ResourceType::Portal => { /* ... */ },
///     ResourceType::Project => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `resourcetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ResourceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ResourceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ResourceType::NewFeature` is defined.
/// Specifically, when `resourcetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ResourceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceType {
    #[allow(missing_docs)] // documentation missing in model
    Portal,
    #[allow(missing_docs)] // documentation missing in model
    Project,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ResourceType {
    fn from(s: &str) -> Self {
        match s {
            "PORTAL" => ResourceType::Portal,
            "PROJECT" => ResourceType::Project,
            other => ResourceType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ResourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResourceType::from(s))
    }
}
impl ResourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ResourceType::Portal => "PORTAL",
            ResourceType::Project => "PROJECT",
            ResourceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["PORTAL", "PROJECT"]
    }
}
impl AsRef<str> for ResourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `IdentityType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let identitytype = unimplemented!();
/// match identitytype {
///     IdentityType::Group => { /* ... */ },
///     IdentityType::Iam => { /* ... */ },
///     IdentityType::User => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `identitytype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `IdentityType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `IdentityType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `IdentityType::NewFeature` is defined.
/// Specifically, when `identitytype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `IdentityType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum IdentityType {
    #[allow(missing_docs)] // documentation missing in model
    Group,
    #[allow(missing_docs)] // documentation missing in model
    Iam,
    #[allow(missing_docs)] // documentation missing in model
    User,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for IdentityType {
    fn from(s: &str) -> Self {
        match s {
            "GROUP" => IdentityType::Group,
            "IAM" => IdentityType::Iam,
            "USER" => IdentityType::User,
            other => IdentityType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for IdentityType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(IdentityType::from(s))
    }
}
impl IdentityType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            IdentityType::Group => "GROUP",
            IdentityType::Iam => "IAM",
            IdentityType::User => "USER",
            IdentityType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["GROUP", "IAM", "USER"]
    }
}
impl AsRef<str> for IdentityType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about an interpolated asset property value.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InterpolatedAssetPropertyValue {
    /// <p>Contains a timestamp with optional nanosecond granularity.</p>
    #[doc(hidden)]
    pub timestamp: std::option::Option<crate::model::TimeInNanos>,
    /// <p>Contains an asset property value (of a single type only).</p>
    #[doc(hidden)]
    pub value: std::option::Option<crate::model::Variant>,
}
impl InterpolatedAssetPropertyValue {
    /// <p>Contains a timestamp with optional nanosecond granularity.</p>
    pub fn timestamp(&self) -> std::option::Option<&crate::model::TimeInNanos> {
        self.timestamp.as_ref()
    }
    /// <p>Contains an asset property value (of a single type only).</p>
    pub fn value(&self) -> std::option::Option<&crate::model::Variant> {
        self.value.as_ref()
    }
}
/// See [`InterpolatedAssetPropertyValue`](crate::model::InterpolatedAssetPropertyValue).
pub mod interpolated_asset_property_value {

    /// A builder for [`InterpolatedAssetPropertyValue`](crate::model::InterpolatedAssetPropertyValue).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) timestamp: std::option::Option<crate::model::TimeInNanos>,
        pub(crate) value: std::option::Option<crate::model::Variant>,
    }
    impl Builder {
        /// <p>Contains a timestamp with optional nanosecond granularity.</p>
        pub fn timestamp(mut self, input: crate::model::TimeInNanos) -> Self {
            self.timestamp = Some(input);
            self
        }
        /// <p>Contains a timestamp with optional nanosecond granularity.</p>
        pub fn set_timestamp(
            mut self,
            input: std::option::Option<crate::model::TimeInNanos>,
        ) -> Self {
            self.timestamp = input;
            self
        }
        /// <p>Contains an asset property value (of a single type only).</p>
        pub fn value(mut self, input: crate::model::Variant) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>Contains an asset property value (of a single type only).</p>
        pub fn set_value(mut self, input: std::option::Option<crate::model::Variant>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`InterpolatedAssetPropertyValue`](crate::model::InterpolatedAssetPropertyValue).
        pub fn build(self) -> crate::model::InterpolatedAssetPropertyValue {
            crate::model::InterpolatedAssetPropertyValue {
                timestamp: self.timestamp,
                value: self.value,
            }
        }
    }
}
impl InterpolatedAssetPropertyValue {
    /// Creates a new builder-style object to manufacture [`InterpolatedAssetPropertyValue`](crate::model::InterpolatedAssetPropertyValue).
    pub fn builder() -> crate::model::interpolated_asset_property_value::Builder {
        crate::model::interpolated_asset_property_value::Builder::default()
    }
}

/// <p>Contains an asset property value (of a single type only).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Variant {
    /// <p>Asset property data of type string (sequence of characters).</p>
    #[doc(hidden)]
    pub string_value: std::option::Option<std::string::String>,
    /// <p>Asset property data of type integer (whole number).</p>
    #[doc(hidden)]
    pub integer_value: std::option::Option<i32>,
    /// <p>Asset property data of type double (floating point number).</p>
    #[doc(hidden)]
    pub double_value: std::option::Option<f64>,
    /// <p>Asset property data of type Boolean (true or false).</p>
    #[doc(hidden)]
    pub boolean_value: std::option::Option<bool>,
}
impl Variant {
    /// <p>Asset property data of type string (sequence of characters).</p>
    pub fn string_value(&self) -> std::option::Option<&str> {
        self.string_value.as_deref()
    }
    /// <p>Asset property data of type integer (whole number).</p>
    pub fn integer_value(&self) -> std::option::Option<i32> {
        self.integer_value
    }
    /// <p>Asset property data of type double (floating point number).</p>
    pub fn double_value(&self) -> std::option::Option<f64> {
        self.double_value
    }
    /// <p>Asset property data of type Boolean (true or false).</p>
    pub fn boolean_value(&self) -> std::option::Option<bool> {
        self.boolean_value
    }
}
/// See [`Variant`](crate::model::Variant).
pub mod variant {

    /// A builder for [`Variant`](crate::model::Variant).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) string_value: std::option::Option<std::string::String>,
        pub(crate) integer_value: std::option::Option<i32>,
        pub(crate) double_value: std::option::Option<f64>,
        pub(crate) boolean_value: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Asset property data of type string (sequence of characters).</p>
        pub fn string_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.string_value = Some(input.into());
            self
        }
        /// <p>Asset property data of type string (sequence of characters).</p>
        pub fn set_string_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.string_value = input;
            self
        }
        /// <p>Asset property data of type integer (whole number).</p>
        pub fn integer_value(mut self, input: i32) -> Self {
            self.integer_value = Some(input);
            self
        }
        /// <p>Asset property data of type integer (whole number).</p>
        pub fn set_integer_value(mut self, input: std::option::Option<i32>) -> Self {
            self.integer_value = input;
            self
        }
        /// <p>Asset property data of type double (floating point number).</p>
        pub fn double_value(mut self, input: f64) -> Self {
            self.double_value = Some(input);
            self
        }
        /// <p>Asset property data of type double (floating point number).</p>
        pub fn set_double_value(mut self, input: std::option::Option<f64>) -> Self {
            self.double_value = input;
            self
        }
        /// <p>Asset property data of type Boolean (true or false).</p>
        pub fn boolean_value(mut self, input: bool) -> Self {
            self.boolean_value = Some(input);
            self
        }
        /// <p>Asset property data of type Boolean (true or false).</p>
        pub fn set_boolean_value(mut self, input: std::option::Option<bool>) -> Self {
            self.boolean_value = input;
            self
        }
        /// Consumes the builder and constructs a [`Variant`](crate::model::Variant).
        pub fn build(self) -> crate::model::Variant {
            crate::model::Variant {
                string_value: self.string_value,
                integer_value: self.integer_value,
                double_value: self.double_value,
                boolean_value: self.boolean_value,
            }
        }
    }
}
impl Variant {
    /// Creates a new builder-style object to manufacture [`Variant`](crate::model::Variant).
    pub fn builder() -> crate::model::variant::Builder {
        crate::model::variant::Builder::default()
    }
}

/// <p>Contains a timestamp with optional nanosecond granularity.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TimeInNanos {
    /// <p>The timestamp date, in seconds, in the Unix epoch format. Fractional nanosecond data is provided by <code>offsetInNanos</code>.</p>
    #[doc(hidden)]
    pub time_in_seconds: std::option::Option<i64>,
    /// <p>The nanosecond offset from <code>timeInSeconds</code>.</p>
    #[doc(hidden)]
    pub offset_in_nanos: std::option::Option<i32>,
}
impl TimeInNanos {
    /// <p>The timestamp date, in seconds, in the Unix epoch format. Fractional nanosecond data is provided by <code>offsetInNanos</code>.</p>
    pub fn time_in_seconds(&self) -> std::option::Option<i64> {
        self.time_in_seconds
    }
    /// <p>The nanosecond offset from <code>timeInSeconds</code>.</p>
    pub fn offset_in_nanos(&self) -> std::option::Option<i32> {
        self.offset_in_nanos
    }
}
/// See [`TimeInNanos`](crate::model::TimeInNanos).
pub mod time_in_nanos {

    /// A builder for [`TimeInNanos`](crate::model::TimeInNanos).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) time_in_seconds: std::option::Option<i64>,
        pub(crate) offset_in_nanos: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The timestamp date, in seconds, in the Unix epoch format. Fractional nanosecond data is provided by <code>offsetInNanos</code>.</p>
        pub fn time_in_seconds(mut self, input: i64) -> Self {
            self.time_in_seconds = Some(input);
            self
        }
        /// <p>The timestamp date, in seconds, in the Unix epoch format. Fractional nanosecond data is provided by <code>offsetInNanos</code>.</p>
        pub fn set_time_in_seconds(mut self, input: std::option::Option<i64>) -> Self {
            self.time_in_seconds = input;
            self
        }
        /// <p>The nanosecond offset from <code>timeInSeconds</code>.</p>
        pub fn offset_in_nanos(mut self, input: i32) -> Self {
            self.offset_in_nanos = Some(input);
            self
        }
        /// <p>The nanosecond offset from <code>timeInSeconds</code>.</p>
        pub fn set_offset_in_nanos(mut self, input: std::option::Option<i32>) -> Self {
            self.offset_in_nanos = input;
            self
        }
        /// Consumes the builder and constructs a [`TimeInNanos`](crate::model::TimeInNanos).
        pub fn build(self) -> crate::model::TimeInNanos {
            crate::model::TimeInNanos {
                time_in_seconds: self.time_in_seconds,
                offset_in_nanos: self.offset_in_nanos,
            }
        }
    }
}
impl TimeInNanos {
    /// Creates a new builder-style object to manufacture [`TimeInNanos`](crate::model::TimeInNanos).
    pub fn builder() -> crate::model::time_in_nanos::Builder {
        crate::model::time_in_nanos::Builder::default()
    }
}

/// When writing a match expression against `Quality`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let quality = unimplemented!();
/// match quality {
///     Quality::Bad => { /* ... */ },
///     Quality::Good => { /* ... */ },
///     Quality::Uncertain => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `quality` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Quality::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Quality::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Quality::NewFeature` is defined.
/// Specifically, when `quality` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Quality::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Quality {
    #[allow(missing_docs)] // documentation missing in model
    Bad,
    #[allow(missing_docs)] // documentation missing in model
    Good,
    #[allow(missing_docs)] // documentation missing in model
    Uncertain,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Quality {
    fn from(s: &str) -> Self {
        match s {
            "BAD" => Quality::Bad,
            "GOOD" => Quality::Good,
            "UNCERTAIN" => Quality::Uncertain,
            other => Quality::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Quality {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Quality::from(s))
    }
}
impl Quality {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Quality::Bad => "BAD",
            Quality::Good => "GOOD",
            Quality::Uncertain => "UNCERTAIN",
            Quality::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["BAD", "GOOD", "UNCERTAIN"]
    }
}
impl AsRef<str> for Quality {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains asset property value information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssetPropertyValue {
    /// <p>The value of the asset property (see <code>Variant</code>).</p>
    #[doc(hidden)]
    pub value: std::option::Option<crate::model::Variant>,
    /// <p>The timestamp of the asset property value.</p>
    #[doc(hidden)]
    pub timestamp: std::option::Option<crate::model::TimeInNanos>,
    /// <p>The quality of the asset property value.</p>
    #[doc(hidden)]
    pub quality: std::option::Option<crate::model::Quality>,
}
impl AssetPropertyValue {
    /// <p>The value of the asset property (see <code>Variant</code>).</p>
    pub fn value(&self) -> std::option::Option<&crate::model::Variant> {
        self.value.as_ref()
    }
    /// <p>The timestamp of the asset property value.</p>
    pub fn timestamp(&self) -> std::option::Option<&crate::model::TimeInNanos> {
        self.timestamp.as_ref()
    }
    /// <p>The quality of the asset property value.</p>
    pub fn quality(&self) -> std::option::Option<&crate::model::Quality> {
        self.quality.as_ref()
    }
}
/// See [`AssetPropertyValue`](crate::model::AssetPropertyValue).
pub mod asset_property_value {

    /// A builder for [`AssetPropertyValue`](crate::model::AssetPropertyValue).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<crate::model::Variant>,
        pub(crate) timestamp: std::option::Option<crate::model::TimeInNanos>,
        pub(crate) quality: std::option::Option<crate::model::Quality>,
    }
    impl Builder {
        /// <p>The value of the asset property (see <code>Variant</code>).</p>
        pub fn value(mut self, input: crate::model::Variant) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value of the asset property (see <code>Variant</code>).</p>
        pub fn set_value(mut self, input: std::option::Option<crate::model::Variant>) -> Self {
            self.value = input;
            self
        }
        /// <p>The timestamp of the asset property value.</p>
        pub fn timestamp(mut self, input: crate::model::TimeInNanos) -> Self {
            self.timestamp = Some(input);
            self
        }
        /// <p>The timestamp of the asset property value.</p>
        pub fn set_timestamp(
            mut self,
            input: std::option::Option<crate::model::TimeInNanos>,
        ) -> Self {
            self.timestamp = input;
            self
        }
        /// <p>The quality of the asset property value.</p>
        pub fn quality(mut self, input: crate::model::Quality) -> Self {
            self.quality = Some(input);
            self
        }
        /// <p>The quality of the asset property value.</p>
        pub fn set_quality(mut self, input: std::option::Option<crate::model::Quality>) -> Self {
            self.quality = input;
            self
        }
        /// Consumes the builder and constructs a [`AssetPropertyValue`](crate::model::AssetPropertyValue).
        pub fn build(self) -> crate::model::AssetPropertyValue {
            crate::model::AssetPropertyValue {
                value: self.value,
                timestamp: self.timestamp,
                quality: self.quality,
            }
        }
    }
}
impl AssetPropertyValue {
    /// Creates a new builder-style object to manufacture [`AssetPropertyValue`](crate::model::AssetPropertyValue).
    pub fn builder() -> crate::model::asset_property_value::Builder {
        crate::model::asset_property_value::Builder::default()
    }
}

/// When writing a match expression against `TimeOrdering`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let timeordering = unimplemented!();
/// match timeordering {
///     TimeOrdering::Ascending => { /* ... */ },
///     TimeOrdering::Descending => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `timeordering` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TimeOrdering::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TimeOrdering::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TimeOrdering::NewFeature` is defined.
/// Specifically, when `timeordering` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TimeOrdering::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TimeOrdering {
    #[allow(missing_docs)] // documentation missing in model
    Ascending,
    #[allow(missing_docs)] // documentation missing in model
    Descending,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TimeOrdering {
    fn from(s: &str) -> Self {
        match s {
            "ASCENDING" => TimeOrdering::Ascending,
            "DESCENDING" => TimeOrdering::Descending,
            other => TimeOrdering::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for TimeOrdering {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TimeOrdering::from(s))
    }
}
impl TimeOrdering {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TimeOrdering::Ascending => "ASCENDING",
            TimeOrdering::Descending => "DESCENDING",
            TimeOrdering::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ASCENDING", "DESCENDING"]
    }
}
impl AsRef<str> for TimeOrdering {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains aggregated asset property values (for example, average, minimum, and maximum).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AggregatedValue {
    /// <p>The date the aggregating computations occurred, in Unix epoch time.</p>
    #[doc(hidden)]
    pub timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The quality of the aggregated data.</p>
    #[doc(hidden)]
    pub quality: std::option::Option<crate::model::Quality>,
    /// <p>The value of the aggregates.</p>
    #[doc(hidden)]
    pub value: std::option::Option<crate::model::Aggregates>,
}
impl AggregatedValue {
    /// <p>The date the aggregating computations occurred, in Unix epoch time.</p>
    pub fn timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.timestamp.as_ref()
    }
    /// <p>The quality of the aggregated data.</p>
    pub fn quality(&self) -> std::option::Option<&crate::model::Quality> {
        self.quality.as_ref()
    }
    /// <p>The value of the aggregates.</p>
    pub fn value(&self) -> std::option::Option<&crate::model::Aggregates> {
        self.value.as_ref()
    }
}
/// See [`AggregatedValue`](crate::model::AggregatedValue).
pub mod aggregated_value {

    /// A builder for [`AggregatedValue`](crate::model::AggregatedValue).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) quality: std::option::Option<crate::model::Quality>,
        pub(crate) value: std::option::Option<crate::model::Aggregates>,
    }
    impl Builder {
        /// <p>The date the aggregating computations occurred, in Unix epoch time.</p>
        pub fn timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.timestamp = Some(input);
            self
        }
        /// <p>The date the aggregating computations occurred, in Unix epoch time.</p>
        pub fn set_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.timestamp = input;
            self
        }
        /// <p>The quality of the aggregated data.</p>
        pub fn quality(mut self, input: crate::model::Quality) -> Self {
            self.quality = Some(input);
            self
        }
        /// <p>The quality of the aggregated data.</p>
        pub fn set_quality(mut self, input: std::option::Option<crate::model::Quality>) -> Self {
            self.quality = input;
            self
        }
        /// <p>The value of the aggregates.</p>
        pub fn value(mut self, input: crate::model::Aggregates) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value of the aggregates.</p>
        pub fn set_value(mut self, input: std::option::Option<crate::model::Aggregates>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`AggregatedValue`](crate::model::AggregatedValue).
        pub fn build(self) -> crate::model::AggregatedValue {
            crate::model::AggregatedValue {
                timestamp: self.timestamp,
                quality: self.quality,
                value: self.value,
            }
        }
    }
}
impl AggregatedValue {
    /// Creates a new builder-style object to manufacture [`AggregatedValue`](crate::model::AggregatedValue).
    pub fn builder() -> crate::model::aggregated_value::Builder {
        crate::model::aggregated_value::Builder::default()
    }
}

/// <p>Contains the (pre-calculated) aggregate values for an asset property.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Aggregates {
    /// <p>The average (mean) value of the time series over a time interval window.</p>
    #[doc(hidden)]
    pub average: std::option::Option<f64>,
    /// <p>The count of data points in the time series over a time interval window.</p>
    #[doc(hidden)]
    pub count: std::option::Option<f64>,
    /// <p>The maximum value of the time series over a time interval window.</p>
    #[doc(hidden)]
    pub maximum: std::option::Option<f64>,
    /// <p>The minimum value of the time series over a time interval window.</p>
    #[doc(hidden)]
    pub minimum: std::option::Option<f64>,
    /// <p>The sum of the time series over a time interval window.</p>
    #[doc(hidden)]
    pub sum: std::option::Option<f64>,
    /// <p>The standard deviation of the time series over a time interval window.</p>
    #[doc(hidden)]
    pub standard_deviation: std::option::Option<f64>,
}
impl Aggregates {
    /// <p>The average (mean) value of the time series over a time interval window.</p>
    pub fn average(&self) -> std::option::Option<f64> {
        self.average
    }
    /// <p>The count of data points in the time series over a time interval window.</p>
    pub fn count(&self) -> std::option::Option<f64> {
        self.count
    }
    /// <p>The maximum value of the time series over a time interval window.</p>
    pub fn maximum(&self) -> std::option::Option<f64> {
        self.maximum
    }
    /// <p>The minimum value of the time series over a time interval window.</p>
    pub fn minimum(&self) -> std::option::Option<f64> {
        self.minimum
    }
    /// <p>The sum of the time series over a time interval window.</p>
    pub fn sum(&self) -> std::option::Option<f64> {
        self.sum
    }
    /// <p>The standard deviation of the time series over a time interval window.</p>
    pub fn standard_deviation(&self) -> std::option::Option<f64> {
        self.standard_deviation
    }
}
/// See [`Aggregates`](crate::model::Aggregates).
pub mod aggregates {

    /// A builder for [`Aggregates`](crate::model::Aggregates).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) average: std::option::Option<f64>,
        pub(crate) count: std::option::Option<f64>,
        pub(crate) maximum: std::option::Option<f64>,
        pub(crate) minimum: std::option::Option<f64>,
        pub(crate) sum: std::option::Option<f64>,
        pub(crate) standard_deviation: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The average (mean) value of the time series over a time interval window.</p>
        pub fn average(mut self, input: f64) -> Self {
            self.average = Some(input);
            self
        }
        /// <p>The average (mean) value of the time series over a time interval window.</p>
        pub fn set_average(mut self, input: std::option::Option<f64>) -> Self {
            self.average = input;
            self
        }
        /// <p>The count of data points in the time series over a time interval window.</p>
        pub fn count(mut self, input: f64) -> Self {
            self.count = Some(input);
            self
        }
        /// <p>The count of data points in the time series over a time interval window.</p>
        pub fn set_count(mut self, input: std::option::Option<f64>) -> Self {
            self.count = input;
            self
        }
        /// <p>The maximum value of the time series over a time interval window.</p>
        pub fn maximum(mut self, input: f64) -> Self {
            self.maximum = Some(input);
            self
        }
        /// <p>The maximum value of the time series over a time interval window.</p>
        pub fn set_maximum(mut self, input: std::option::Option<f64>) -> Self {
            self.maximum = input;
            self
        }
        /// <p>The minimum value of the time series over a time interval window.</p>
        pub fn minimum(mut self, input: f64) -> Self {
            self.minimum = Some(input);
            self
        }
        /// <p>The minimum value of the time series over a time interval window.</p>
        pub fn set_minimum(mut self, input: std::option::Option<f64>) -> Self {
            self.minimum = input;
            self
        }
        /// <p>The sum of the time series over a time interval window.</p>
        pub fn sum(mut self, input: f64) -> Self {
            self.sum = Some(input);
            self
        }
        /// <p>The sum of the time series over a time interval window.</p>
        pub fn set_sum(mut self, input: std::option::Option<f64>) -> Self {
            self.sum = input;
            self
        }
        /// <p>The standard deviation of the time series over a time interval window.</p>
        pub fn standard_deviation(mut self, input: f64) -> Self {
            self.standard_deviation = Some(input);
            self
        }
        /// <p>The standard deviation of the time series over a time interval window.</p>
        pub fn set_standard_deviation(mut self, input: std::option::Option<f64>) -> Self {
            self.standard_deviation = input;
            self
        }
        /// Consumes the builder and constructs a [`Aggregates`](crate::model::Aggregates).
        pub fn build(self) -> crate::model::Aggregates {
            crate::model::Aggregates {
                average: self.average,
                count: self.count,
                maximum: self.maximum,
                minimum: self.minimum,
                sum: self.sum,
                standard_deviation: self.standard_deviation,
            }
        }
    }
}
impl Aggregates {
    /// Creates a new builder-style object to manufacture [`Aggregates`](crate::model::Aggregates).
    pub fn builder() -> crate::model::aggregates::Builder {
        crate::model::aggregates::Builder::default()
    }
}

/// When writing a match expression against `AggregateType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let aggregatetype = unimplemented!();
/// match aggregatetype {
///     AggregateType::Average => { /* ... */ },
///     AggregateType::Count => { /* ... */ },
///     AggregateType::Maximum => { /* ... */ },
///     AggregateType::Minimum => { /* ... */ },
///     AggregateType::StandardDeviation => { /* ... */ },
///     AggregateType::Sum => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `aggregatetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AggregateType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AggregateType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AggregateType::NewFeature` is defined.
/// Specifically, when `aggregatetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AggregateType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AggregateType {
    #[allow(missing_docs)] // documentation missing in model
    Average,
    #[allow(missing_docs)] // documentation missing in model
    Count,
    #[allow(missing_docs)] // documentation missing in model
    Maximum,
    #[allow(missing_docs)] // documentation missing in model
    Minimum,
    #[allow(missing_docs)] // documentation missing in model
    StandardDeviation,
    #[allow(missing_docs)] // documentation missing in model
    Sum,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AggregateType {
    fn from(s: &str) -> Self {
        match s {
            "AVERAGE" => AggregateType::Average,
            "COUNT" => AggregateType::Count,
            "MAXIMUM" => AggregateType::Maximum,
            "MINIMUM" => AggregateType::Minimum,
            "STANDARD_DEVIATION" => AggregateType::StandardDeviation,
            "SUM" => AggregateType::Sum,
            other => AggregateType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AggregateType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AggregateType::from(s))
    }
}
impl AggregateType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AggregateType::Average => "AVERAGE",
            AggregateType::Count => "COUNT",
            AggregateType::Maximum => "MAXIMUM",
            AggregateType::Minimum => "MINIMUM",
            AggregateType::StandardDeviation => "STANDARD_DEVIATION",
            AggregateType::Sum => "SUM",
            AggregateType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AVERAGE",
            "COUNT",
            "MAXIMUM",
            "MINIMUM",
            "STANDARD_DEVIATION",
            "SUM",
        ]
    }
}
impl AsRef<str> for AggregateType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `AuthMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let authmode = unimplemented!();
/// match authmode {
///     AuthMode::Iam => { /* ... */ },
///     AuthMode::Sso => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `authmode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AuthMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AuthMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AuthMode::NewFeature` is defined.
/// Specifically, when `authmode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AuthMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AuthMode {
    #[allow(missing_docs)] // documentation missing in model
    Iam,
    #[allow(missing_docs)] // documentation missing in model
    Sso,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AuthMode {
    fn from(s: &str) -> Self {
        match s {
            "IAM" => AuthMode::Iam,
            "SSO" => AuthMode::Sso,
            other => AuthMode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AuthMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AuthMode::from(s))
    }
}
impl AuthMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AuthMode::Iam => "IAM",
            AuthMode::Sso => "SSO",
            AuthMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["IAM", "SSO"]
    }
}
impl AsRef<str> for AuthMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains an image that is uploaded to IoT SiteWise and available at a URL.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ImageLocation {
    /// <p>The ID of the image.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The URL where the image is available. The URL is valid for 15 minutes so that you can view and download the image</p>
    #[doc(hidden)]
    pub url: std::option::Option<std::string::String>,
}
impl ImageLocation {
    /// <p>The ID of the image.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The URL where the image is available. The URL is valid for 15 minutes so that you can view and download the image</p>
    pub fn url(&self) -> std::option::Option<&str> {
        self.url.as_deref()
    }
}
/// See [`ImageLocation`](crate::model::ImageLocation).
pub mod image_location {

    /// A builder for [`ImageLocation`](crate::model::ImageLocation).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the image.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the image.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The URL where the image is available. The URL is valid for 15 minutes so that you can view and download the image</p>
        pub fn url(mut self, input: impl Into<std::string::String>) -> Self {
            self.url = Some(input.into());
            self
        }
        /// <p>The URL where the image is available. The URL is valid for 15 minutes so that you can view and download the image</p>
        pub fn set_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.url = input;
            self
        }
        /// Consumes the builder and constructs a [`ImageLocation`](crate::model::ImageLocation).
        pub fn build(self) -> crate::model::ImageLocation {
            crate::model::ImageLocation {
                id: self.id,
                url: self.url,
            }
        }
    }
}
impl ImageLocation {
    /// Creates a new builder-style object to manufacture [`ImageLocation`](crate::model::ImageLocation).
    pub fn builder() -> crate::model::image_location::Builder {
        crate::model::image_location::Builder::default()
    }
}

/// <p>Contains the configuration information of a job, such as the file format used to save data in Amazon S3.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct JobConfiguration {
    /// <p>The file format of the data in Amazon S3.</p>
    #[doc(hidden)]
    pub file_format: std::option::Option<crate::model::FileFormat>,
}
impl JobConfiguration {
    /// <p>The file format of the data in Amazon S3.</p>
    pub fn file_format(&self) -> std::option::Option<&crate::model::FileFormat> {
        self.file_format.as_ref()
    }
}
/// See [`JobConfiguration`](crate::model::JobConfiguration).
pub mod job_configuration {

    /// A builder for [`JobConfiguration`](crate::model::JobConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) file_format: std::option::Option<crate::model::FileFormat>,
    }
    impl Builder {
        /// <p>The file format of the data in Amazon S3.</p>
        pub fn file_format(mut self, input: crate::model::FileFormat) -> Self {
            self.file_format = Some(input);
            self
        }
        /// <p>The file format of the data in Amazon S3.</p>
        pub fn set_file_format(
            mut self,
            input: std::option::Option<crate::model::FileFormat>,
        ) -> Self {
            self.file_format = input;
            self
        }
        /// Consumes the builder and constructs a [`JobConfiguration`](crate::model::JobConfiguration).
        pub fn build(self) -> crate::model::JobConfiguration {
            crate::model::JobConfiguration {
                file_format: self.file_format,
            }
        }
    }
}
impl JobConfiguration {
    /// Creates a new builder-style object to manufacture [`JobConfiguration`](crate::model::JobConfiguration).
    pub fn builder() -> crate::model::job_configuration::Builder {
        crate::model::job_configuration::Builder::default()
    }
}

/// <p>The file format of the data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FileFormat {
    /// <p>The .csv file format.</p>
    #[doc(hidden)]
    pub csv: std::option::Option<crate::model::Csv>,
}
impl FileFormat {
    /// <p>The .csv file format.</p>
    pub fn csv(&self) -> std::option::Option<&crate::model::Csv> {
        self.csv.as_ref()
    }
}
/// See [`FileFormat`](crate::model::FileFormat).
pub mod file_format {

    /// A builder for [`FileFormat`](crate::model::FileFormat).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) csv: std::option::Option<crate::model::Csv>,
    }
    impl Builder {
        /// <p>The .csv file format.</p>
        pub fn csv(mut self, input: crate::model::Csv) -> Self {
            self.csv = Some(input);
            self
        }
        /// <p>The .csv file format.</p>
        pub fn set_csv(mut self, input: std::option::Option<crate::model::Csv>) -> Self {
            self.csv = input;
            self
        }
        /// Consumes the builder and constructs a [`FileFormat`](crate::model::FileFormat).
        pub fn build(self) -> crate::model::FileFormat {
            crate::model::FileFormat { csv: self.csv }
        }
    }
}
impl FileFormat {
    /// Creates a new builder-style object to manufacture [`FileFormat`](crate::model::FileFormat).
    pub fn builder() -> crate::model::file_format::Builder {
        crate::model::file_format::Builder::default()
    }
}

/// <p>A .csv file.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Csv {
    /// <p>The column names specified in the .csv file.</p>
    #[doc(hidden)]
    pub column_names: std::option::Option<std::vec::Vec<crate::model::ColumnName>>,
}
impl Csv {
    /// <p>The column names specified in the .csv file.</p>
    pub fn column_names(&self) -> std::option::Option<&[crate::model::ColumnName]> {
        self.column_names.as_deref()
    }
}
/// See [`Csv`](crate::model::Csv).
pub mod csv {

    /// A builder for [`Csv`](crate::model::Csv).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) column_names: std::option::Option<std::vec::Vec<crate::model::ColumnName>>,
    }
    impl Builder {
        /// Appends an item to `column_names`.
        ///
        /// To override the contents of this collection use [`set_column_names`](Self::set_column_names).
        ///
        /// <p>The column names specified in the .csv file.</p>
        pub fn column_names(mut self, input: crate::model::ColumnName) -> Self {
            let mut v = self.column_names.unwrap_or_default();
            v.push(input);
            self.column_names = Some(v);
            self
        }
        /// <p>The column names specified in the .csv file.</p>
        pub fn set_column_names(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ColumnName>>,
        ) -> Self {
            self.column_names = input;
            self
        }
        /// Consumes the builder and constructs a [`Csv`](crate::model::Csv).
        pub fn build(self) -> crate::model::Csv {
            crate::model::Csv {
                column_names: self.column_names,
            }
        }
    }
}
impl Csv {
    /// Creates a new builder-style object to manufacture [`Csv`](crate::model::Csv).
    pub fn builder() -> crate::model::csv::Builder {
        crate::model::csv::Builder::default()
    }
}

/// When writing a match expression against `ColumnName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let columnname = unimplemented!();
/// match columnname {
///     ColumnName::Alias => { /* ... */ },
///     ColumnName::AssetId => { /* ... */ },
///     ColumnName::DataType => { /* ... */ },
///     ColumnName::PropertyId => { /* ... */ },
///     ColumnName::Quality => { /* ... */ },
///     ColumnName::TimestampNanoOffset => { /* ... */ },
///     ColumnName::TimestampSeconds => { /* ... */ },
///     ColumnName::Value => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `columnname` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ColumnName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ColumnName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ColumnName::NewFeature` is defined.
/// Specifically, when `columnname` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ColumnName::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ColumnName {
    #[allow(missing_docs)] // documentation missing in model
    Alias,
    #[allow(missing_docs)] // documentation missing in model
    AssetId,
    #[allow(missing_docs)] // documentation missing in model
    DataType,
    #[allow(missing_docs)] // documentation missing in model
    PropertyId,
    #[allow(missing_docs)] // documentation missing in model
    Quality,
    #[allow(missing_docs)] // documentation missing in model
    TimestampNanoOffset,
    #[allow(missing_docs)] // documentation missing in model
    TimestampSeconds,
    #[allow(missing_docs)] // documentation missing in model
    Value,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ColumnName {
    fn from(s: &str) -> Self {
        match s {
            "ALIAS" => ColumnName::Alias,
            "ASSET_ID" => ColumnName::AssetId,
            "DATA_TYPE" => ColumnName::DataType,
            "PROPERTY_ID" => ColumnName::PropertyId,
            "QUALITY" => ColumnName::Quality,
            "TIMESTAMP_NANO_OFFSET" => ColumnName::TimestampNanoOffset,
            "TIMESTAMP_SECONDS" => ColumnName::TimestampSeconds,
            "VALUE" => ColumnName::Value,
            other => ColumnName::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ColumnName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ColumnName::from(s))
    }
}
impl ColumnName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ColumnName::Alias => "ALIAS",
            ColumnName::AssetId => "ASSET_ID",
            ColumnName::DataType => "DATA_TYPE",
            ColumnName::PropertyId => "PROPERTY_ID",
            ColumnName::Quality => "QUALITY",
            ColumnName::TimestampNanoOffset => "TIMESTAMP_NANO_OFFSET",
            ColumnName::TimestampSeconds => "TIMESTAMP_SECONDS",
            ColumnName::Value => "VALUE",
            ColumnName::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ALIAS",
            "ASSET_ID",
            "DATA_TYPE",
            "PROPERTY_ID",
            "QUALITY",
            "TIMESTAMP_NANO_OFFSET",
            "TIMESTAMP_SECONDS",
            "VALUE",
        ]
    }
}
impl AsRef<str> for ColumnName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The Amazon S3 destination where errors associated with the job creation request are saved.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ErrorReportLocation {
    /// <p>The name of the Amazon S3 bucket to which errors associated with the bulk import job are sent.</p>
    #[doc(hidden)]
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Amazon S3 uses the prefix as a folder name to organize data in the bucket. Each Amazon S3 object has a key that is its unique identifier in the bucket. Each object in a bucket has exactly one key. The prefix must end with a forward slash (/). For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-prefixes.html">Organizing objects using prefixes</a> in the <i>Amazon Simple Storage Service User Guide</i>.</p>
    #[doc(hidden)]
    pub prefix: std::option::Option<std::string::String>,
}
impl ErrorReportLocation {
    /// <p>The name of the Amazon S3 bucket to which errors associated with the bulk import job are sent.</p>
    pub fn bucket(&self) -> std::option::Option<&str> {
        self.bucket.as_deref()
    }
    /// <p>Amazon S3 uses the prefix as a folder name to organize data in the bucket. Each Amazon S3 object has a key that is its unique identifier in the bucket. Each object in a bucket has exactly one key. The prefix must end with a forward slash (/). For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-prefixes.html">Organizing objects using prefixes</a> in the <i>Amazon Simple Storage Service User Guide</i>.</p>
    pub fn prefix(&self) -> std::option::Option<&str> {
        self.prefix.as_deref()
    }
}
/// See [`ErrorReportLocation`](crate::model::ErrorReportLocation).
pub mod error_report_location {

    /// A builder for [`ErrorReportLocation`](crate::model::ErrorReportLocation).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) prefix: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Amazon S3 bucket to which errors associated with the bulk import job are sent.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        /// <p>The name of the Amazon S3 bucket to which errors associated with the bulk import job are sent.</p>
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Amazon S3 uses the prefix as a folder name to organize data in the bucket. Each Amazon S3 object has a key that is its unique identifier in the bucket. Each object in a bucket has exactly one key. The prefix must end with a forward slash (/). For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-prefixes.html">Organizing objects using prefixes</a> in the <i>Amazon Simple Storage Service User Guide</i>.</p>
        pub fn prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix = Some(input.into());
            self
        }
        /// <p>Amazon S3 uses the prefix as a folder name to organize data in the bucket. Each Amazon S3 object has a key that is its unique identifier in the bucket. Each object in a bucket has exactly one key. The prefix must end with a forward slash (/). For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-prefixes.html">Organizing objects using prefixes</a> in the <i>Amazon Simple Storage Service User Guide</i>.</p>
        pub fn set_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.prefix = input;
            self
        }
        /// Consumes the builder and constructs a [`ErrorReportLocation`](crate::model::ErrorReportLocation).
        pub fn build(self) -> crate::model::ErrorReportLocation {
            crate::model::ErrorReportLocation {
                bucket: self.bucket,
                prefix: self.prefix,
            }
        }
    }
}
impl ErrorReportLocation {
    /// Creates a new builder-style object to manufacture [`ErrorReportLocation`](crate::model::ErrorReportLocation).
    pub fn builder() -> crate::model::error_report_location::Builder {
        crate::model::error_report_location::Builder::default()
    }
}

/// <p>The file in Amazon S3 where your data is saved. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct File {
    /// <p>The name of the Amazon S3 bucket from which data is imported.</p>
    #[doc(hidden)]
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The key of the Amazon S3 object that contains your data. Each object has a key that is a unique identifier. Each object has exactly one key.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The version ID to identify a specific version of the Amazon S3 object that contains your data.</p>
    #[doc(hidden)]
    pub version_id: std::option::Option<std::string::String>,
}
impl File {
    /// <p>The name of the Amazon S3 bucket from which data is imported.</p>
    pub fn bucket(&self) -> std::option::Option<&str> {
        self.bucket.as_deref()
    }
    /// <p>The key of the Amazon S3 object that contains your data. Each object has a key that is a unique identifier. Each object has exactly one key.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The version ID to identify a specific version of the Amazon S3 object that contains your data.</p>
    pub fn version_id(&self) -> std::option::Option<&str> {
        self.version_id.as_deref()
    }
}
/// See [`File`](crate::model::File).
pub mod file {

    /// A builder for [`File`](crate::model::File).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) version_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Amazon S3 bucket from which data is imported.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        /// <p>The name of the Amazon S3 bucket from which data is imported.</p>
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The key of the Amazon S3 object that contains your data. Each object has a key that is a unique identifier. Each object has exactly one key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The key of the Amazon S3 object that contains your data. Each object has a key that is a unique identifier. Each object has exactly one key.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The version ID to identify a specific version of the Amazon S3 object that contains your data.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        /// <p>The version ID to identify a specific version of the Amazon S3 object that contains your data.</p>
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// Consumes the builder and constructs a [`File`](crate::model::File).
        pub fn build(self) -> crate::model::File {
            crate::model::File {
                bucket: self.bucket,
                key: self.key,
                version_id: self.version_id,
            }
        }
    }
}
impl File {
    /// Creates a new builder-style object to manufacture [`File`](crate::model::File).
    pub fn builder() -> crate::model::file::Builder {
        crate::model::file::Builder::default()
    }
}

/// <p>Contains information about a composite model property on an asset.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CompositeModelProperty {
    /// <p>The name of the property.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of the composite model that defines this property.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>Contains asset property information.</p>
    #[doc(hidden)]
    pub asset_property: std::option::Option<crate::model::Property>,
    /// <p> The ID of the composite model that contains the property. </p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl CompositeModelProperty {
    /// <p>The name of the property.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of the composite model that defines this property.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>Contains asset property information.</p>
    pub fn asset_property(&self) -> std::option::Option<&crate::model::Property> {
        self.asset_property.as_ref()
    }
    /// <p> The ID of the composite model that contains the property. </p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
}
/// See [`CompositeModelProperty`](crate::model::CompositeModelProperty).
pub mod composite_model_property {

    /// A builder for [`CompositeModelProperty`](crate::model::CompositeModelProperty).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) asset_property: std::option::Option<crate::model::Property>,
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the property.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the property.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of the composite model that defines this property.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of the composite model that defines this property.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Contains asset property information.</p>
        pub fn asset_property(mut self, input: crate::model::Property) -> Self {
            self.asset_property = Some(input);
            self
        }
        /// <p>Contains asset property information.</p>
        pub fn set_asset_property(
            mut self,
            input: std::option::Option<crate::model::Property>,
        ) -> Self {
            self.asset_property = input;
            self
        }
        /// <p> The ID of the composite model that contains the property. </p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p> The ID of the composite model that contains the property. </p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`CompositeModelProperty`](crate::model::CompositeModelProperty).
        pub fn build(self) -> crate::model::CompositeModelProperty {
            crate::model::CompositeModelProperty {
                name: self.name,
                r#type: self.r#type,
                asset_property: self.asset_property,
                id: self.id,
            }
        }
    }
}
impl CompositeModelProperty {
    /// Creates a new builder-style object to manufacture [`CompositeModelProperty`](crate::model::CompositeModelProperty).
    pub fn builder() -> crate::model::composite_model_property::Builder {
        crate::model::composite_model_property::Builder::default()
    }
}

/// <p>Contains asset property information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Property {
    /// <p>The ID of the asset property.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the property.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub alias: std::option::Option<std::string::String>,
    /// <p>The asset property's notification topic and state. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetProperty.html">UpdateAssetProperty</a>.</p>
    #[doc(hidden)]
    pub notification: std::option::Option<crate::model::PropertyNotification>,
    /// <p>The property data type.</p>
    #[doc(hidden)]
    pub data_type: std::option::Option<crate::model::PropertyDataType>,
    /// <p>The unit (such as <code>Newtons</code> or <code>RPM</code>) of the asset property.</p>
    #[doc(hidden)]
    pub unit: std::option::Option<std::string::String>,
    /// <p>The property type (see <code>PropertyType</code>). A property contains one type.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::PropertyType>,
}
impl Property {
    /// <p>The ID of the asset property.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the property.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn alias(&self) -> std::option::Option<&str> {
        self.alias.as_deref()
    }
    /// <p>The asset property's notification topic and state. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetProperty.html">UpdateAssetProperty</a>.</p>
    pub fn notification(&self) -> std::option::Option<&crate::model::PropertyNotification> {
        self.notification.as_ref()
    }
    /// <p>The property data type.</p>
    pub fn data_type(&self) -> std::option::Option<&crate::model::PropertyDataType> {
        self.data_type.as_ref()
    }
    /// <p>The unit (such as <code>Newtons</code> or <code>RPM</code>) of the asset property.</p>
    pub fn unit(&self) -> std::option::Option<&str> {
        self.unit.as_deref()
    }
    /// <p>The property type (see <code>PropertyType</code>). A property contains one type.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::PropertyType> {
        self.r#type.as_ref()
    }
}
/// See [`Property`](crate::model::Property).
pub mod property {

    /// A builder for [`Property`](crate::model::Property).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) alias: std::option::Option<std::string::String>,
        pub(crate) notification: std::option::Option<crate::model::PropertyNotification>,
        pub(crate) data_type: std::option::Option<crate::model::PropertyDataType>,
        pub(crate) unit: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::PropertyType>,
    }
    impl Builder {
        /// <p>The ID of the asset property.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the asset property.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the property.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the property.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.alias = Some(input.into());
            self
        }
        /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alias = input;
            self
        }
        /// <p>The asset property's notification topic and state. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetProperty.html">UpdateAssetProperty</a>.</p>
        pub fn notification(mut self, input: crate::model::PropertyNotification) -> Self {
            self.notification = Some(input);
            self
        }
        /// <p>The asset property's notification topic and state. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetProperty.html">UpdateAssetProperty</a>.</p>
        pub fn set_notification(
            mut self,
            input: std::option::Option<crate::model::PropertyNotification>,
        ) -> Self {
            self.notification = input;
            self
        }
        /// <p>The property data type.</p>
        pub fn data_type(mut self, input: crate::model::PropertyDataType) -> Self {
            self.data_type = Some(input);
            self
        }
        /// <p>The property data type.</p>
        pub fn set_data_type(
            mut self,
            input: std::option::Option<crate::model::PropertyDataType>,
        ) -> Self {
            self.data_type = input;
            self
        }
        /// <p>The unit (such as <code>Newtons</code> or <code>RPM</code>) of the asset property.</p>
        pub fn unit(mut self, input: impl Into<std::string::String>) -> Self {
            self.unit = Some(input.into());
            self
        }
        /// <p>The unit (such as <code>Newtons</code> or <code>RPM</code>) of the asset property.</p>
        pub fn set_unit(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.unit = input;
            self
        }
        /// <p>The property type (see <code>PropertyType</code>). A property contains one type.</p>
        pub fn r#type(mut self, input: crate::model::PropertyType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The property type (see <code>PropertyType</code>). A property contains one type.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::PropertyType>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`Property`](crate::model::Property).
        pub fn build(self) -> crate::model::Property {
            crate::model::Property {
                id: self.id,
                name: self.name,
                alias: self.alias,
                notification: self.notification,
                data_type: self.data_type,
                unit: self.unit,
                r#type: self.r#type,
            }
        }
    }
}
impl Property {
    /// Creates a new builder-style object to manufacture [`Property`](crate::model::Property).
    pub fn builder() -> crate::model::property::Builder {
        crate::model::property::Builder::default()
    }
}

/// <p>Contains information about a composite model in an asset. This object contains the asset's properties that you define in the composite model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssetCompositeModel {
    /// <p>The name of the composite model.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the composite model.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The type of the composite model. For alarm composite models, this type is <code>AWS/ALARM</code>.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The asset properties that this composite model defines.</p>
    #[doc(hidden)]
    pub properties: std::option::Option<std::vec::Vec<crate::model::AssetProperty>>,
    /// <p> The ID of the asset composite model. </p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl AssetCompositeModel {
    /// <p>The name of the composite model.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the composite model.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The type of the composite model. For alarm composite models, this type is <code>AWS/ALARM</code>.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The asset properties that this composite model defines.</p>
    pub fn properties(&self) -> std::option::Option<&[crate::model::AssetProperty]> {
        self.properties.as_deref()
    }
    /// <p> The ID of the asset composite model. </p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
}
/// See [`AssetCompositeModel`](crate::model::AssetCompositeModel).
pub mod asset_composite_model {

    /// A builder for [`AssetCompositeModel`](crate::model::AssetCompositeModel).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) properties: std::option::Option<std::vec::Vec<crate::model::AssetProperty>>,
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the composite model.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the composite model.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the composite model.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the composite model.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The type of the composite model. For alarm composite models, this type is <code>AWS/ALARM</code>.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of the composite model. For alarm composite models, this type is <code>AWS/ALARM</code>.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Appends an item to `properties`.
        ///
        /// To override the contents of this collection use [`set_properties`](Self::set_properties).
        ///
        /// <p>The asset properties that this composite model defines.</p>
        pub fn properties(mut self, input: crate::model::AssetProperty) -> Self {
            let mut v = self.properties.unwrap_or_default();
            v.push(input);
            self.properties = Some(v);
            self
        }
        /// <p>The asset properties that this composite model defines.</p>
        pub fn set_properties(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AssetProperty>>,
        ) -> Self {
            self.properties = input;
            self
        }
        /// <p> The ID of the asset composite model. </p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p> The ID of the asset composite model. </p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`AssetCompositeModel`](crate::model::AssetCompositeModel).
        pub fn build(self) -> crate::model::AssetCompositeModel {
            crate::model::AssetCompositeModel {
                name: self.name,
                description: self.description,
                r#type: self.r#type,
                properties: self.properties,
                id: self.id,
            }
        }
    }
}
impl AssetCompositeModel {
    /// Creates a new builder-style object to manufacture [`AssetCompositeModel`](crate::model::AssetCompositeModel).
    pub fn builder() -> crate::model::asset_composite_model::Builder {
        crate::model::asset_composite_model::Builder::default()
    }
}

/// <p>Contains asset property information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssetProperty {
    /// <p>The ID of the asset property.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the property.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub alias: std::option::Option<std::string::String>,
    /// <p>The asset property's notification topic and state. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetProperty.html">UpdateAssetProperty</a>.</p>
    #[doc(hidden)]
    pub notification: std::option::Option<crate::model::PropertyNotification>,
    /// <p>The data type of the asset property.</p>
    #[doc(hidden)]
    pub data_type: std::option::Option<crate::model::PropertyDataType>,
    /// <p>The data type of the structure for this property. This parameter exists on properties that have the <code>STRUCT</code> data type.</p>
    #[doc(hidden)]
    pub data_type_spec: std::option::Option<std::string::String>,
    /// <p>The unit (such as <code>Newtons</code> or <code>RPM</code>) of the asset property.</p>
    #[doc(hidden)]
    pub unit: std::option::Option<std::string::String>,
}
impl AssetProperty {
    /// <p>The ID of the asset property.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the property.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn alias(&self) -> std::option::Option<&str> {
        self.alias.as_deref()
    }
    /// <p>The asset property's notification topic and state. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetProperty.html">UpdateAssetProperty</a>.</p>
    pub fn notification(&self) -> std::option::Option<&crate::model::PropertyNotification> {
        self.notification.as_ref()
    }
    /// <p>The data type of the asset property.</p>
    pub fn data_type(&self) -> std::option::Option<&crate::model::PropertyDataType> {
        self.data_type.as_ref()
    }
    /// <p>The data type of the structure for this property. This parameter exists on properties that have the <code>STRUCT</code> data type.</p>
    pub fn data_type_spec(&self) -> std::option::Option<&str> {
        self.data_type_spec.as_deref()
    }
    /// <p>The unit (such as <code>Newtons</code> or <code>RPM</code>) of the asset property.</p>
    pub fn unit(&self) -> std::option::Option<&str> {
        self.unit.as_deref()
    }
}
/// See [`AssetProperty`](crate::model::AssetProperty).
pub mod asset_property {

    /// A builder for [`AssetProperty`](crate::model::AssetProperty).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) alias: std::option::Option<std::string::String>,
        pub(crate) notification: std::option::Option<crate::model::PropertyNotification>,
        pub(crate) data_type: std::option::Option<crate::model::PropertyDataType>,
        pub(crate) data_type_spec: std::option::Option<std::string::String>,
        pub(crate) unit: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the asset property.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the asset property.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the property.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the property.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.alias = Some(input.into());
            self
        }
        /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alias = input;
            self
        }
        /// <p>The asset property's notification topic and state. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetProperty.html">UpdateAssetProperty</a>.</p>
        pub fn notification(mut self, input: crate::model::PropertyNotification) -> Self {
            self.notification = Some(input);
            self
        }
        /// <p>The asset property's notification topic and state. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetProperty.html">UpdateAssetProperty</a>.</p>
        pub fn set_notification(
            mut self,
            input: std::option::Option<crate::model::PropertyNotification>,
        ) -> Self {
            self.notification = input;
            self
        }
        /// <p>The data type of the asset property.</p>
        pub fn data_type(mut self, input: crate::model::PropertyDataType) -> Self {
            self.data_type = Some(input);
            self
        }
        /// <p>The data type of the asset property.</p>
        pub fn set_data_type(
            mut self,
            input: std::option::Option<crate::model::PropertyDataType>,
        ) -> Self {
            self.data_type = input;
            self
        }
        /// <p>The data type of the structure for this property. This parameter exists on properties that have the <code>STRUCT</code> data type.</p>
        pub fn data_type_spec(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_type_spec = Some(input.into());
            self
        }
        /// <p>The data type of the structure for this property. This parameter exists on properties that have the <code>STRUCT</code> data type.</p>
        pub fn set_data_type_spec(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_type_spec = input;
            self
        }
        /// <p>The unit (such as <code>Newtons</code> or <code>RPM</code>) of the asset property.</p>
        pub fn unit(mut self, input: impl Into<std::string::String>) -> Self {
            self.unit = Some(input.into());
            self
        }
        /// <p>The unit (such as <code>Newtons</code> or <code>RPM</code>) of the asset property.</p>
        pub fn set_unit(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.unit = input;
            self
        }
        /// Consumes the builder and constructs a [`AssetProperty`](crate::model::AssetProperty).
        pub fn build(self) -> crate::model::AssetProperty {
            crate::model::AssetProperty {
                id: self.id,
                name: self.name,
                alias: self.alias,
                notification: self.notification,
                data_type: self.data_type,
                data_type_spec: self.data_type_spec,
                unit: self.unit,
            }
        }
    }
}
impl AssetProperty {
    /// Creates a new builder-style object to manufacture [`AssetProperty`](crate::model::AssetProperty).
    pub fn builder() -> crate::model::asset_property::Builder {
        crate::model::asset_property::Builder::default()
    }
}

/// <p>Contains a composite model definition in an asset model. This composite model definition is applied to all assets created from the asset model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssetModelCompositeModelDefinition {
    /// <p>The name of the composite model.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the composite model.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The type of the composite model. For alarm composite models, this type is <code>AWS/ALARM</code>.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The asset property definitions for this composite model.</p>
    #[doc(hidden)]
    pub properties: std::option::Option<std::vec::Vec<crate::model::AssetModelPropertyDefinition>>,
}
impl AssetModelCompositeModelDefinition {
    /// <p>The name of the composite model.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the composite model.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The type of the composite model. For alarm composite models, this type is <code>AWS/ALARM</code>.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The asset property definitions for this composite model.</p>
    pub fn properties(&self) -> std::option::Option<&[crate::model::AssetModelPropertyDefinition]> {
        self.properties.as_deref()
    }
}
/// See [`AssetModelCompositeModelDefinition`](crate::model::AssetModelCompositeModelDefinition).
pub mod asset_model_composite_model_definition {

    /// A builder for [`AssetModelCompositeModelDefinition`](crate::model::AssetModelCompositeModelDefinition).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) properties:
            std::option::Option<std::vec::Vec<crate::model::AssetModelPropertyDefinition>>,
    }
    impl Builder {
        /// <p>The name of the composite model.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the composite model.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the composite model.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the composite model.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The type of the composite model. For alarm composite models, this type is <code>AWS/ALARM</code>.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of the composite model. For alarm composite models, this type is <code>AWS/ALARM</code>.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Appends an item to `properties`.
        ///
        /// To override the contents of this collection use [`set_properties`](Self::set_properties).
        ///
        /// <p>The asset property definitions for this composite model.</p>
        pub fn properties(mut self, input: crate::model::AssetModelPropertyDefinition) -> Self {
            let mut v = self.properties.unwrap_or_default();
            v.push(input);
            self.properties = Some(v);
            self
        }
        /// <p>The asset property definitions for this composite model.</p>
        pub fn set_properties(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AssetModelPropertyDefinition>>,
        ) -> Self {
            self.properties = input;
            self
        }
        /// Consumes the builder and constructs a [`AssetModelCompositeModelDefinition`](crate::model::AssetModelCompositeModelDefinition).
        pub fn build(self) -> crate::model::AssetModelCompositeModelDefinition {
            crate::model::AssetModelCompositeModelDefinition {
                name: self.name,
                description: self.description,
                r#type: self.r#type,
                properties: self.properties,
            }
        }
    }
}
impl AssetModelCompositeModelDefinition {
    /// Creates a new builder-style object to manufacture [`AssetModelCompositeModelDefinition`](crate::model::AssetModelCompositeModelDefinition).
    pub fn builder() -> crate::model::asset_model_composite_model_definition::Builder {
        crate::model::asset_model_composite_model_definition::Builder::default()
    }
}

/// <p>Contains an asset model property definition. This property definition is applied to all assets created from the asset model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssetModelPropertyDefinition {
    /// <p>The name of the property definition.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The data type of the property definition.</p>
    /// <p>If you specify <code>STRUCT</code>, you must also specify <code>dataTypeSpec</code> to identify the type of the structure for this property.</p>
    #[doc(hidden)]
    pub data_type: std::option::Option<crate::model::PropertyDataType>,
    /// <p>The data type of the structure for this property. This parameter is required on properties that have the <code>STRUCT</code> data type.</p>
    /// <p>The options for this parameter depend on the type of the composite model in which you define this property. Use <code>AWS/ALARM_STATE</code> for alarm state in alarm composite models.</p>
    #[doc(hidden)]
    pub data_type_spec: std::option::Option<std::string::String>,
    /// <p>The unit of the property definition, such as <code>Newtons</code> or <code>RPM</code>.</p>
    #[doc(hidden)]
    pub unit: std::option::Option<std::string::String>,
    /// <p>The property definition type (see <code>PropertyType</code>). You can only specify one type in a property definition.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::PropertyType>,
}
impl AssetModelPropertyDefinition {
    /// <p>The name of the property definition.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The data type of the property definition.</p>
    /// <p>If you specify <code>STRUCT</code>, you must also specify <code>dataTypeSpec</code> to identify the type of the structure for this property.</p>
    pub fn data_type(&self) -> std::option::Option<&crate::model::PropertyDataType> {
        self.data_type.as_ref()
    }
    /// <p>The data type of the structure for this property. This parameter is required on properties that have the <code>STRUCT</code> data type.</p>
    /// <p>The options for this parameter depend on the type of the composite model in which you define this property. Use <code>AWS/ALARM_STATE</code> for alarm state in alarm composite models.</p>
    pub fn data_type_spec(&self) -> std::option::Option<&str> {
        self.data_type_spec.as_deref()
    }
    /// <p>The unit of the property definition, such as <code>Newtons</code> or <code>RPM</code>.</p>
    pub fn unit(&self) -> std::option::Option<&str> {
        self.unit.as_deref()
    }
    /// <p>The property definition type (see <code>PropertyType</code>). You can only specify one type in a property definition.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::PropertyType> {
        self.r#type.as_ref()
    }
}
/// See [`AssetModelPropertyDefinition`](crate::model::AssetModelPropertyDefinition).
pub mod asset_model_property_definition {

    /// A builder for [`AssetModelPropertyDefinition`](crate::model::AssetModelPropertyDefinition).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) data_type: std::option::Option<crate::model::PropertyDataType>,
        pub(crate) data_type_spec: std::option::Option<std::string::String>,
        pub(crate) unit: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::PropertyType>,
    }
    impl Builder {
        /// <p>The name of the property definition.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the property definition.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The data type of the property definition.</p>
        /// <p>If you specify <code>STRUCT</code>, you must also specify <code>dataTypeSpec</code> to identify the type of the structure for this property.</p>
        pub fn data_type(mut self, input: crate::model::PropertyDataType) -> Self {
            self.data_type = Some(input);
            self
        }
        /// <p>The data type of the property definition.</p>
        /// <p>If you specify <code>STRUCT</code>, you must also specify <code>dataTypeSpec</code> to identify the type of the structure for this property.</p>
        pub fn set_data_type(
            mut self,
            input: std::option::Option<crate::model::PropertyDataType>,
        ) -> Self {
            self.data_type = input;
            self
        }
        /// <p>The data type of the structure for this property. This parameter is required on properties that have the <code>STRUCT</code> data type.</p>
        /// <p>The options for this parameter depend on the type of the composite model in which you define this property. Use <code>AWS/ALARM_STATE</code> for alarm state in alarm composite models.</p>
        pub fn data_type_spec(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_type_spec = Some(input.into());
            self
        }
        /// <p>The data type of the structure for this property. This parameter is required on properties that have the <code>STRUCT</code> data type.</p>
        /// <p>The options for this parameter depend on the type of the composite model in which you define this property. Use <code>AWS/ALARM_STATE</code> for alarm state in alarm composite models.</p>
        pub fn set_data_type_spec(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_type_spec = input;
            self
        }
        /// <p>The unit of the property definition, such as <code>Newtons</code> or <code>RPM</code>.</p>
        pub fn unit(mut self, input: impl Into<std::string::String>) -> Self {
            self.unit = Some(input.into());
            self
        }
        /// <p>The unit of the property definition, such as <code>Newtons</code> or <code>RPM</code>.</p>
        pub fn set_unit(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.unit = input;
            self
        }
        /// <p>The property definition type (see <code>PropertyType</code>). You can only specify one type in a property definition.</p>
        pub fn r#type(mut self, input: crate::model::PropertyType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The property definition type (see <code>PropertyType</code>). You can only specify one type in a property definition.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::PropertyType>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`AssetModelPropertyDefinition`](crate::model::AssetModelPropertyDefinition).
        pub fn build(self) -> crate::model::AssetModelPropertyDefinition {
            crate::model::AssetModelPropertyDefinition {
                name: self.name,
                data_type: self.data_type,
                data_type_spec: self.data_type_spec,
                unit: self.unit,
                r#type: self.r#type,
            }
        }
    }
}
impl AssetModelPropertyDefinition {
    /// Creates a new builder-style object to manufacture [`AssetModelPropertyDefinition`](crate::model::AssetModelPropertyDefinition).
    pub fn builder() -> crate::model::asset_model_property_definition::Builder {
        crate::model::asset_model_property_definition::Builder::default()
    }
}

/// <p>Contains an asset model hierarchy used in asset model creation. An asset model hierarchy determines the kind (or type) of asset that can belong to a hierarchy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssetModelHierarchyDefinition {
    /// <p>The name of the asset model hierarchy definition (as specified in the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_CreateAssetModel.html">CreateAssetModel</a> or <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetModel.html">UpdateAssetModel</a> API operation).</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The ID of an asset model for this hierarchy.</p>
    #[doc(hidden)]
    pub child_asset_model_id: std::option::Option<std::string::String>,
}
impl AssetModelHierarchyDefinition {
    /// <p>The name of the asset model hierarchy definition (as specified in the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_CreateAssetModel.html">CreateAssetModel</a> or <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetModel.html">UpdateAssetModel</a> API operation).</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The ID of an asset model for this hierarchy.</p>
    pub fn child_asset_model_id(&self) -> std::option::Option<&str> {
        self.child_asset_model_id.as_deref()
    }
}
/// See [`AssetModelHierarchyDefinition`](crate::model::AssetModelHierarchyDefinition).
pub mod asset_model_hierarchy_definition {

    /// A builder for [`AssetModelHierarchyDefinition`](crate::model::AssetModelHierarchyDefinition).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) child_asset_model_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the asset model hierarchy definition (as specified in the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_CreateAssetModel.html">CreateAssetModel</a> or <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetModel.html">UpdateAssetModel</a> API operation).</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the asset model hierarchy definition (as specified in the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_CreateAssetModel.html">CreateAssetModel</a> or <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetModel.html">UpdateAssetModel</a> API operation).</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The ID of an asset model for this hierarchy.</p>
        pub fn child_asset_model_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.child_asset_model_id = Some(input.into());
            self
        }
        /// <p>The ID of an asset model for this hierarchy.</p>
        pub fn set_child_asset_model_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.child_asset_model_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AssetModelHierarchyDefinition`](crate::model::AssetModelHierarchyDefinition).
        pub fn build(self) -> crate::model::AssetModelHierarchyDefinition {
            crate::model::AssetModelHierarchyDefinition {
                name: self.name,
                child_asset_model_id: self.child_asset_model_id,
            }
        }
    }
}
impl AssetModelHierarchyDefinition {
    /// Creates a new builder-style object to manufacture [`AssetModelHierarchyDefinition`](crate::model::AssetModelHierarchyDefinition).
    pub fn builder() -> crate::model::asset_model_hierarchy_definition::Builder {
        crate::model::asset_model_hierarchy_definition::Builder::default()
    }
}

/// <p>Contains error information for asset property value entries that are associated with the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchPutAssetPropertyValue.html">BatchPutAssetPropertyValue</a> API.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchPutAssetPropertyErrorEntry {
    /// <p>The ID of the failed entry.</p>
    #[doc(hidden)]
    pub entry_id: std::option::Option<std::string::String>,
    /// <p>The list of update property value errors.</p>
    #[doc(hidden)]
    pub errors: std::option::Option<std::vec::Vec<crate::model::BatchPutAssetPropertyError>>,
}
impl BatchPutAssetPropertyErrorEntry {
    /// <p>The ID of the failed entry.</p>
    pub fn entry_id(&self) -> std::option::Option<&str> {
        self.entry_id.as_deref()
    }
    /// <p>The list of update property value errors.</p>
    pub fn errors(&self) -> std::option::Option<&[crate::model::BatchPutAssetPropertyError]> {
        self.errors.as_deref()
    }
}
/// See [`BatchPutAssetPropertyErrorEntry`](crate::model::BatchPutAssetPropertyErrorEntry).
pub mod batch_put_asset_property_error_entry {

    /// A builder for [`BatchPutAssetPropertyErrorEntry`](crate::model::BatchPutAssetPropertyErrorEntry).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entry_id: std::option::Option<std::string::String>,
        pub(crate) errors:
            std::option::Option<std::vec::Vec<crate::model::BatchPutAssetPropertyError>>,
    }
    impl Builder {
        /// <p>The ID of the failed entry.</p>
        pub fn entry_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.entry_id = Some(input.into());
            self
        }
        /// <p>The ID of the failed entry.</p>
        pub fn set_entry_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.entry_id = input;
            self
        }
        /// Appends an item to `errors`.
        ///
        /// To override the contents of this collection use [`set_errors`](Self::set_errors).
        ///
        /// <p>The list of update property value errors.</p>
        pub fn errors(mut self, input: crate::model::BatchPutAssetPropertyError) -> Self {
            let mut v = self.errors.unwrap_or_default();
            v.push(input);
            self.errors = Some(v);
            self
        }
        /// <p>The list of update property value errors.</p>
        pub fn set_errors(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BatchPutAssetPropertyError>>,
        ) -> Self {
            self.errors = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchPutAssetPropertyErrorEntry`](crate::model::BatchPutAssetPropertyErrorEntry).
        pub fn build(self) -> crate::model::BatchPutAssetPropertyErrorEntry {
            crate::model::BatchPutAssetPropertyErrorEntry {
                entry_id: self.entry_id,
                errors: self.errors,
            }
        }
    }
}
impl BatchPutAssetPropertyErrorEntry {
    /// Creates a new builder-style object to manufacture [`BatchPutAssetPropertyErrorEntry`](crate::model::BatchPutAssetPropertyErrorEntry).
    pub fn builder() -> crate::model::batch_put_asset_property_error_entry::Builder {
        crate::model::batch_put_asset_property_error_entry::Builder::default()
    }
}

/// <p>Contains error information from updating a batch of asset property values.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchPutAssetPropertyError {
    /// <p>The error code.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<crate::model::BatchPutAssetPropertyValueErrorCode>,
    /// <p>The associated error message.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
    /// <p>A list of timestamps for each error, if any.</p>
    #[doc(hidden)]
    pub timestamps: std::option::Option<std::vec::Vec<crate::model::TimeInNanos>>,
}
impl BatchPutAssetPropertyError {
    /// <p>The error code.</p>
    pub fn error_code(
        &self,
    ) -> std::option::Option<&crate::model::BatchPutAssetPropertyValueErrorCode> {
        self.error_code.as_ref()
    }
    /// <p>The associated error message.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
    /// <p>A list of timestamps for each error, if any.</p>
    pub fn timestamps(&self) -> std::option::Option<&[crate::model::TimeInNanos]> {
        self.timestamps.as_deref()
    }
}
/// See [`BatchPutAssetPropertyError`](crate::model::BatchPutAssetPropertyError).
pub mod batch_put_asset_property_error {

    /// A builder for [`BatchPutAssetPropertyError`](crate::model::BatchPutAssetPropertyError).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error_code:
            std::option::Option<crate::model::BatchPutAssetPropertyValueErrorCode>,
        pub(crate) error_message: std::option::Option<std::string::String>,
        pub(crate) timestamps: std::option::Option<std::vec::Vec<crate::model::TimeInNanos>>,
    }
    impl Builder {
        /// <p>The error code.</p>
        pub fn error_code(
            mut self,
            input: crate::model::BatchPutAssetPropertyValueErrorCode,
        ) -> Self {
            self.error_code = Some(input);
            self
        }
        /// <p>The error code.</p>
        pub fn set_error_code(
            mut self,
            input: std::option::Option<crate::model::BatchPutAssetPropertyValueErrorCode>,
        ) -> Self {
            self.error_code = input;
            self
        }
        /// <p>The associated error message.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>The associated error message.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Appends an item to `timestamps`.
        ///
        /// To override the contents of this collection use [`set_timestamps`](Self::set_timestamps).
        ///
        /// <p>A list of timestamps for each error, if any.</p>
        pub fn timestamps(mut self, input: crate::model::TimeInNanos) -> Self {
            let mut v = self.timestamps.unwrap_or_default();
            v.push(input);
            self.timestamps = Some(v);
            self
        }
        /// <p>A list of timestamps for each error, if any.</p>
        pub fn set_timestamps(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TimeInNanos>>,
        ) -> Self {
            self.timestamps = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchPutAssetPropertyError`](crate::model::BatchPutAssetPropertyError).
        pub fn build(self) -> crate::model::BatchPutAssetPropertyError {
            crate::model::BatchPutAssetPropertyError {
                error_code: self.error_code,
                error_message: self.error_message,
                timestamps: self.timestamps,
            }
        }
    }
}
impl BatchPutAssetPropertyError {
    /// Creates a new builder-style object to manufacture [`BatchPutAssetPropertyError`](crate::model::BatchPutAssetPropertyError).
    pub fn builder() -> crate::model::batch_put_asset_property_error::Builder {
        crate::model::batch_put_asset_property_error::Builder::default()
    }
}

/// When writing a match expression against `BatchPutAssetPropertyValueErrorCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let batchputassetpropertyvalueerrorcode = unimplemented!();
/// match batchputassetpropertyvalueerrorcode {
///     BatchPutAssetPropertyValueErrorCode::AccessDeniedException => { /* ... */ },
///     BatchPutAssetPropertyValueErrorCode::ConflictingOperationException => { /* ... */ },
///     BatchPutAssetPropertyValueErrorCode::InternalFailureException => { /* ... */ },
///     BatchPutAssetPropertyValueErrorCode::InvalidRequestException => { /* ... */ },
///     BatchPutAssetPropertyValueErrorCode::LimitExceededException => { /* ... */ },
///     BatchPutAssetPropertyValueErrorCode::ResourceNotFoundException => { /* ... */ },
///     BatchPutAssetPropertyValueErrorCode::ServiceUnavailableException => { /* ... */ },
///     BatchPutAssetPropertyValueErrorCode::ThrottlingException => { /* ... */ },
///     BatchPutAssetPropertyValueErrorCode::TimestampOutOfRangeException => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `batchputassetpropertyvalueerrorcode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `BatchPutAssetPropertyValueErrorCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `BatchPutAssetPropertyValueErrorCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `BatchPutAssetPropertyValueErrorCode::NewFeature` is defined.
/// Specifically, when `batchputassetpropertyvalueerrorcode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `BatchPutAssetPropertyValueErrorCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BatchPutAssetPropertyValueErrorCode {
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedException,
    #[allow(missing_docs)] // documentation missing in model
    ConflictingOperationException,
    #[allow(missing_docs)] // documentation missing in model
    InternalFailureException,
    #[allow(missing_docs)] // documentation missing in model
    InvalidRequestException,
    #[allow(missing_docs)] // documentation missing in model
    LimitExceededException,
    #[allow(missing_docs)] // documentation missing in model
    ResourceNotFoundException,
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException,
    #[allow(missing_docs)] // documentation missing in model
    ThrottlingException,
    #[allow(missing_docs)] // documentation missing in model
    TimestampOutOfRangeException,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for BatchPutAssetPropertyValueErrorCode {
    fn from(s: &str) -> Self {
        match s {
            "AccessDeniedException" => BatchPutAssetPropertyValueErrorCode::AccessDeniedException,
            "ConflictingOperationException" => {
                BatchPutAssetPropertyValueErrorCode::ConflictingOperationException
            }
            "InternalFailureException" => {
                BatchPutAssetPropertyValueErrorCode::InternalFailureException
            }
            "InvalidRequestException" => {
                BatchPutAssetPropertyValueErrorCode::InvalidRequestException
            }
            "LimitExceededException" => BatchPutAssetPropertyValueErrorCode::LimitExceededException,
            "ResourceNotFoundException" => {
                BatchPutAssetPropertyValueErrorCode::ResourceNotFoundException
            }
            "ServiceUnavailableException" => {
                BatchPutAssetPropertyValueErrorCode::ServiceUnavailableException
            }
            "ThrottlingException" => BatchPutAssetPropertyValueErrorCode::ThrottlingException,
            "TimestampOutOfRangeException" => {
                BatchPutAssetPropertyValueErrorCode::TimestampOutOfRangeException
            }
            other => BatchPutAssetPropertyValueErrorCode::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for BatchPutAssetPropertyValueErrorCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BatchPutAssetPropertyValueErrorCode::from(s))
    }
}
impl BatchPutAssetPropertyValueErrorCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            BatchPutAssetPropertyValueErrorCode::AccessDeniedException => "AccessDeniedException",
            BatchPutAssetPropertyValueErrorCode::ConflictingOperationException => {
                "ConflictingOperationException"
            }
            BatchPutAssetPropertyValueErrorCode::InternalFailureException => {
                "InternalFailureException"
            }
            BatchPutAssetPropertyValueErrorCode::InvalidRequestException => {
                "InvalidRequestException"
            }
            BatchPutAssetPropertyValueErrorCode::LimitExceededException => "LimitExceededException",
            BatchPutAssetPropertyValueErrorCode::ResourceNotFoundException => {
                "ResourceNotFoundException"
            }
            BatchPutAssetPropertyValueErrorCode::ServiceUnavailableException => {
                "ServiceUnavailableException"
            }
            BatchPutAssetPropertyValueErrorCode::ThrottlingException => "ThrottlingException",
            BatchPutAssetPropertyValueErrorCode::TimestampOutOfRangeException => {
                "TimestampOutOfRangeException"
            }
            BatchPutAssetPropertyValueErrorCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AccessDeniedException",
            "ConflictingOperationException",
            "InternalFailureException",
            "InvalidRequestException",
            "LimitExceededException",
            "ResourceNotFoundException",
            "ServiceUnavailableException",
            "ThrottlingException",
            "TimestampOutOfRangeException",
        ]
    }
}
impl AsRef<str> for BatchPutAssetPropertyValueErrorCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains a list of value updates for an asset property in the list of asset entries consumed by the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchPutAssetPropertyValue.html">BatchPutAssetPropertyValue</a> API operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PutAssetPropertyValueEntry {
    /// <p>The user specified ID for the entry. You can use this ID to identify which entries failed.</p>
    #[doc(hidden)]
    pub entry_id: std::option::Option<std::string::String>,
    /// <p>The ID of the asset to update.</p>
    #[doc(hidden)]
    pub asset_id: std::option::Option<std::string::String>,
    /// <p>The ID of the asset property for this entry.</p>
    #[doc(hidden)]
    pub property_id: std::option::Option<std::string::String>,
    /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub property_alias: std::option::Option<std::string::String>,
    /// <p>The list of property values to upload. You can specify up to 10 <code>propertyValues</code> array elements. </p>
    #[doc(hidden)]
    pub property_values: std::option::Option<std::vec::Vec<crate::model::AssetPropertyValue>>,
}
impl PutAssetPropertyValueEntry {
    /// <p>The user specified ID for the entry. You can use this ID to identify which entries failed.</p>
    pub fn entry_id(&self) -> std::option::Option<&str> {
        self.entry_id.as_deref()
    }
    /// <p>The ID of the asset to update.</p>
    pub fn asset_id(&self) -> std::option::Option<&str> {
        self.asset_id.as_deref()
    }
    /// <p>The ID of the asset property for this entry.</p>
    pub fn property_id(&self) -> std::option::Option<&str> {
        self.property_id.as_deref()
    }
    /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn property_alias(&self) -> std::option::Option<&str> {
        self.property_alias.as_deref()
    }
    /// <p>The list of property values to upload. You can specify up to 10 <code>propertyValues</code> array elements. </p>
    pub fn property_values(&self) -> std::option::Option<&[crate::model::AssetPropertyValue]> {
        self.property_values.as_deref()
    }
}
/// See [`PutAssetPropertyValueEntry`](crate::model::PutAssetPropertyValueEntry).
pub mod put_asset_property_value_entry {

    /// A builder for [`PutAssetPropertyValueEntry`](crate::model::PutAssetPropertyValueEntry).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entry_id: std::option::Option<std::string::String>,
        pub(crate) asset_id: std::option::Option<std::string::String>,
        pub(crate) property_id: std::option::Option<std::string::String>,
        pub(crate) property_alias: std::option::Option<std::string::String>,
        pub(crate) property_values:
            std::option::Option<std::vec::Vec<crate::model::AssetPropertyValue>>,
    }
    impl Builder {
        /// <p>The user specified ID for the entry. You can use this ID to identify which entries failed.</p>
        pub fn entry_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.entry_id = Some(input.into());
            self
        }
        /// <p>The user specified ID for the entry. You can use this ID to identify which entries failed.</p>
        pub fn set_entry_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.entry_id = input;
            self
        }
        /// <p>The ID of the asset to update.</p>
        pub fn asset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset to update.</p>
        pub fn set_asset_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_id = input;
            self
        }
        /// <p>The ID of the asset property for this entry.</p>
        pub fn property_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset property for this entry.</p>
        pub fn set_property_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.property_id = input;
            self
        }
        /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn property_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_alias = Some(input.into());
            self
        }
        /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_property_alias(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.property_alias = input;
            self
        }
        /// Appends an item to `property_values`.
        ///
        /// To override the contents of this collection use [`set_property_values`](Self::set_property_values).
        ///
        /// <p>The list of property values to upload. You can specify up to 10 <code>propertyValues</code> array elements. </p>
        pub fn property_values(mut self, input: crate::model::AssetPropertyValue) -> Self {
            let mut v = self.property_values.unwrap_or_default();
            v.push(input);
            self.property_values = Some(v);
            self
        }
        /// <p>The list of property values to upload. You can specify up to 10 <code>propertyValues</code> array elements. </p>
        pub fn set_property_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AssetPropertyValue>>,
        ) -> Self {
            self.property_values = input;
            self
        }
        /// Consumes the builder and constructs a [`PutAssetPropertyValueEntry`](crate::model::PutAssetPropertyValueEntry).
        pub fn build(self) -> crate::model::PutAssetPropertyValueEntry {
            crate::model::PutAssetPropertyValueEntry {
                entry_id: self.entry_id,
                asset_id: self.asset_id,
                property_id: self.property_id,
                property_alias: self.property_alias,
                property_values: self.property_values,
            }
        }
    }
}
impl PutAssetPropertyValueEntry {
    /// Creates a new builder-style object to manufacture [`PutAssetPropertyValueEntry`](crate::model::PutAssetPropertyValueEntry).
    pub fn builder() -> crate::model::put_asset_property_value_entry::Builder {
        crate::model::put_asset_property_value_entry::Builder::default()
    }
}

/// <p>Contains information for an entry that has been processed by the previous <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValue.html">BatchGetAssetPropertyValueHistory</a> request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchGetAssetPropertyValueHistorySkippedEntry {
    /// <p>The ID of the entry.</p>
    #[doc(hidden)]
    pub entry_id: std::option::Option<std::string::String>,
    /// <p>The completion status of each entry that is associated with the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValueHistory.html">BatchGetAssetPropertyValueHistory</a> API.</p>
    #[doc(hidden)]
    pub completion_status: std::option::Option<crate::model::BatchEntryCompletionStatus>,
    /// <p>The error information, such as the error code and the timestamp.</p>
    #[doc(hidden)]
    pub error_info: std::option::Option<crate::model::BatchGetAssetPropertyValueHistoryErrorInfo>,
}
impl BatchGetAssetPropertyValueHistorySkippedEntry {
    /// <p>The ID of the entry.</p>
    pub fn entry_id(&self) -> std::option::Option<&str> {
        self.entry_id.as_deref()
    }
    /// <p>The completion status of each entry that is associated with the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValueHistory.html">BatchGetAssetPropertyValueHistory</a> API.</p>
    pub fn completion_status(
        &self,
    ) -> std::option::Option<&crate::model::BatchEntryCompletionStatus> {
        self.completion_status.as_ref()
    }
    /// <p>The error information, such as the error code and the timestamp.</p>
    pub fn error_info(
        &self,
    ) -> std::option::Option<&crate::model::BatchGetAssetPropertyValueHistoryErrorInfo> {
        self.error_info.as_ref()
    }
}
/// See [`BatchGetAssetPropertyValueHistorySkippedEntry`](crate::model::BatchGetAssetPropertyValueHistorySkippedEntry).
pub mod batch_get_asset_property_value_history_skipped_entry {

    /// A builder for [`BatchGetAssetPropertyValueHistorySkippedEntry`](crate::model::BatchGetAssetPropertyValueHistorySkippedEntry).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entry_id: std::option::Option<std::string::String>,
        pub(crate) completion_status: std::option::Option<crate::model::BatchEntryCompletionStatus>,
        pub(crate) error_info:
            std::option::Option<crate::model::BatchGetAssetPropertyValueHistoryErrorInfo>,
    }
    impl Builder {
        /// <p>The ID of the entry.</p>
        pub fn entry_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.entry_id = Some(input.into());
            self
        }
        /// <p>The ID of the entry.</p>
        pub fn set_entry_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.entry_id = input;
            self
        }
        /// <p>The completion status of each entry that is associated with the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValueHistory.html">BatchGetAssetPropertyValueHistory</a> API.</p>
        pub fn completion_status(
            mut self,
            input: crate::model::BatchEntryCompletionStatus,
        ) -> Self {
            self.completion_status = Some(input);
            self
        }
        /// <p>The completion status of each entry that is associated with the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValueHistory.html">BatchGetAssetPropertyValueHistory</a> API.</p>
        pub fn set_completion_status(
            mut self,
            input: std::option::Option<crate::model::BatchEntryCompletionStatus>,
        ) -> Self {
            self.completion_status = input;
            self
        }
        /// <p>The error information, such as the error code and the timestamp.</p>
        pub fn error_info(
            mut self,
            input: crate::model::BatchGetAssetPropertyValueHistoryErrorInfo,
        ) -> Self {
            self.error_info = Some(input);
            self
        }
        /// <p>The error information, such as the error code and the timestamp.</p>
        pub fn set_error_info(
            mut self,
            input: std::option::Option<crate::model::BatchGetAssetPropertyValueHistoryErrorInfo>,
        ) -> Self {
            self.error_info = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchGetAssetPropertyValueHistorySkippedEntry`](crate::model::BatchGetAssetPropertyValueHistorySkippedEntry).
        pub fn build(self) -> crate::model::BatchGetAssetPropertyValueHistorySkippedEntry {
            crate::model::BatchGetAssetPropertyValueHistorySkippedEntry {
                entry_id: self.entry_id,
                completion_status: self.completion_status,
                error_info: self.error_info,
            }
        }
    }
}
impl BatchGetAssetPropertyValueHistorySkippedEntry {
    /// Creates a new builder-style object to manufacture [`BatchGetAssetPropertyValueHistorySkippedEntry`](crate::model::BatchGetAssetPropertyValueHistorySkippedEntry).
    pub fn builder() -> crate::model::batch_get_asset_property_value_history_skipped_entry::Builder
    {
        crate::model::batch_get_asset_property_value_history_skipped_entry::Builder::default()
    }
}

/// <p>The error information, such as the error code and the timestamp.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchGetAssetPropertyValueHistoryErrorInfo {
    /// <p>The error code.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<crate::model::BatchGetAssetPropertyValueHistoryErrorCode>,
    /// <p>The date the error occurred, in Unix epoch time.</p>
    #[doc(hidden)]
    pub error_timestamp: std::option::Option<aws_smithy_types::DateTime>,
}
impl BatchGetAssetPropertyValueHistoryErrorInfo {
    /// <p>The error code.</p>
    pub fn error_code(
        &self,
    ) -> std::option::Option<&crate::model::BatchGetAssetPropertyValueHistoryErrorCode> {
        self.error_code.as_ref()
    }
    /// <p>The date the error occurred, in Unix epoch time.</p>
    pub fn error_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.error_timestamp.as_ref()
    }
}
/// See [`BatchGetAssetPropertyValueHistoryErrorInfo`](crate::model::BatchGetAssetPropertyValueHistoryErrorInfo).
pub mod batch_get_asset_property_value_history_error_info {

    /// A builder for [`BatchGetAssetPropertyValueHistoryErrorInfo`](crate::model::BatchGetAssetPropertyValueHistoryErrorInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error_code:
            std::option::Option<crate::model::BatchGetAssetPropertyValueHistoryErrorCode>,
        pub(crate) error_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The error code.</p>
        pub fn error_code(
            mut self,
            input: crate::model::BatchGetAssetPropertyValueHistoryErrorCode,
        ) -> Self {
            self.error_code = Some(input);
            self
        }
        /// <p>The error code.</p>
        pub fn set_error_code(
            mut self,
            input: std::option::Option<crate::model::BatchGetAssetPropertyValueHistoryErrorCode>,
        ) -> Self {
            self.error_code = input;
            self
        }
        /// <p>The date the error occurred, in Unix epoch time.</p>
        pub fn error_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.error_timestamp = Some(input);
            self
        }
        /// <p>The date the error occurred, in Unix epoch time.</p>
        pub fn set_error_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.error_timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchGetAssetPropertyValueHistoryErrorInfo`](crate::model::BatchGetAssetPropertyValueHistoryErrorInfo).
        pub fn build(self) -> crate::model::BatchGetAssetPropertyValueHistoryErrorInfo {
            crate::model::BatchGetAssetPropertyValueHistoryErrorInfo {
                error_code: self.error_code,
                error_timestamp: self.error_timestamp,
            }
        }
    }
}
impl BatchGetAssetPropertyValueHistoryErrorInfo {
    /// Creates a new builder-style object to manufacture [`BatchGetAssetPropertyValueHistoryErrorInfo`](crate::model::BatchGetAssetPropertyValueHistoryErrorInfo).
    pub fn builder() -> crate::model::batch_get_asset_property_value_history_error_info::Builder {
        crate::model::batch_get_asset_property_value_history_error_info::Builder::default()
    }
}

/// When writing a match expression against `BatchGetAssetPropertyValueHistoryErrorCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let batchgetassetpropertyvaluehistoryerrorcode = unimplemented!();
/// match batchgetassetpropertyvaluehistoryerrorcode {
///     BatchGetAssetPropertyValueHistoryErrorCode::AccessDeniedException => { /* ... */ },
///     BatchGetAssetPropertyValueHistoryErrorCode::InvalidRequestException => { /* ... */ },
///     BatchGetAssetPropertyValueHistoryErrorCode::ResourceNotFoundException => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `batchgetassetpropertyvaluehistoryerrorcode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `BatchGetAssetPropertyValueHistoryErrorCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `BatchGetAssetPropertyValueHistoryErrorCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `BatchGetAssetPropertyValueHistoryErrorCode::NewFeature` is defined.
/// Specifically, when `batchgetassetpropertyvaluehistoryerrorcode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `BatchGetAssetPropertyValueHistoryErrorCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BatchGetAssetPropertyValueHistoryErrorCode {
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedException,
    #[allow(missing_docs)] // documentation missing in model
    InvalidRequestException,
    #[allow(missing_docs)] // documentation missing in model
    ResourceNotFoundException,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for BatchGetAssetPropertyValueHistoryErrorCode {
    fn from(s: &str) -> Self {
        match s {
            "AccessDeniedException" => {
                BatchGetAssetPropertyValueHistoryErrorCode::AccessDeniedException
            }
            "InvalidRequestException" => {
                BatchGetAssetPropertyValueHistoryErrorCode::InvalidRequestException
            }
            "ResourceNotFoundException" => {
                BatchGetAssetPropertyValueHistoryErrorCode::ResourceNotFoundException
            }
            other => BatchGetAssetPropertyValueHistoryErrorCode::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for BatchGetAssetPropertyValueHistoryErrorCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BatchGetAssetPropertyValueHistoryErrorCode::from(s))
    }
}
impl BatchGetAssetPropertyValueHistoryErrorCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            BatchGetAssetPropertyValueHistoryErrorCode::AccessDeniedException => {
                "AccessDeniedException"
            }
            BatchGetAssetPropertyValueHistoryErrorCode::InvalidRequestException => {
                "InvalidRequestException"
            }
            BatchGetAssetPropertyValueHistoryErrorCode::ResourceNotFoundException => {
                "ResourceNotFoundException"
            }
            BatchGetAssetPropertyValueHistoryErrorCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AccessDeniedException",
            "InvalidRequestException",
            "ResourceNotFoundException",
        ]
    }
}
impl AsRef<str> for BatchGetAssetPropertyValueHistoryErrorCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `BatchEntryCompletionStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let batchentrycompletionstatus = unimplemented!();
/// match batchentrycompletionstatus {
///     BatchEntryCompletionStatus::Error => { /* ... */ },
///     BatchEntryCompletionStatus::Success => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `batchentrycompletionstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `BatchEntryCompletionStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `BatchEntryCompletionStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `BatchEntryCompletionStatus::NewFeature` is defined.
/// Specifically, when `batchentrycompletionstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `BatchEntryCompletionStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BatchEntryCompletionStatus {
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    Success,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for BatchEntryCompletionStatus {
    fn from(s: &str) -> Self {
        match s {
            "ERROR" => BatchEntryCompletionStatus::Error,
            "SUCCESS" => BatchEntryCompletionStatus::Success,
            other => BatchEntryCompletionStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for BatchEntryCompletionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BatchEntryCompletionStatus::from(s))
    }
}
impl BatchEntryCompletionStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            BatchEntryCompletionStatus::Error => "ERROR",
            BatchEntryCompletionStatus::Success => "SUCCESS",
            BatchEntryCompletionStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ERROR", "SUCCESS"]
    }
}
impl AsRef<str> for BatchEntryCompletionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains success information for an entry that is associated with the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValue.html">BatchGetAssetPropertyValueHistory</a> API.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchGetAssetPropertyValueHistorySuccessEntry {
    /// <p>The ID of the entry.</p>
    #[doc(hidden)]
    pub entry_id: std::option::Option<std::string::String>,
    /// <p>The requested historical values for the specified asset property.</p>
    #[doc(hidden)]
    pub asset_property_value_history:
        std::option::Option<std::vec::Vec<crate::model::AssetPropertyValue>>,
}
impl BatchGetAssetPropertyValueHistorySuccessEntry {
    /// <p>The ID of the entry.</p>
    pub fn entry_id(&self) -> std::option::Option<&str> {
        self.entry_id.as_deref()
    }
    /// <p>The requested historical values for the specified asset property.</p>
    pub fn asset_property_value_history(
        &self,
    ) -> std::option::Option<&[crate::model::AssetPropertyValue]> {
        self.asset_property_value_history.as_deref()
    }
}
/// See [`BatchGetAssetPropertyValueHistorySuccessEntry`](crate::model::BatchGetAssetPropertyValueHistorySuccessEntry).
pub mod batch_get_asset_property_value_history_success_entry {

    /// A builder for [`BatchGetAssetPropertyValueHistorySuccessEntry`](crate::model::BatchGetAssetPropertyValueHistorySuccessEntry).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entry_id: std::option::Option<std::string::String>,
        pub(crate) asset_property_value_history:
            std::option::Option<std::vec::Vec<crate::model::AssetPropertyValue>>,
    }
    impl Builder {
        /// <p>The ID of the entry.</p>
        pub fn entry_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.entry_id = Some(input.into());
            self
        }
        /// <p>The ID of the entry.</p>
        pub fn set_entry_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.entry_id = input;
            self
        }
        /// Appends an item to `asset_property_value_history`.
        ///
        /// To override the contents of this collection use [`set_asset_property_value_history`](Self::set_asset_property_value_history).
        ///
        /// <p>The requested historical values for the specified asset property.</p>
        pub fn asset_property_value_history(
            mut self,
            input: crate::model::AssetPropertyValue,
        ) -> Self {
            let mut v = self.asset_property_value_history.unwrap_or_default();
            v.push(input);
            self.asset_property_value_history = Some(v);
            self
        }
        /// <p>The requested historical values for the specified asset property.</p>
        pub fn set_asset_property_value_history(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AssetPropertyValue>>,
        ) -> Self {
            self.asset_property_value_history = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchGetAssetPropertyValueHistorySuccessEntry`](crate::model::BatchGetAssetPropertyValueHistorySuccessEntry).
        pub fn build(self) -> crate::model::BatchGetAssetPropertyValueHistorySuccessEntry {
            crate::model::BatchGetAssetPropertyValueHistorySuccessEntry {
                entry_id: self.entry_id,
                asset_property_value_history: self.asset_property_value_history,
            }
        }
    }
}
impl BatchGetAssetPropertyValueHistorySuccessEntry {
    /// Creates a new builder-style object to manufacture [`BatchGetAssetPropertyValueHistorySuccessEntry`](crate::model::BatchGetAssetPropertyValueHistorySuccessEntry).
    pub fn builder() -> crate::model::batch_get_asset_property_value_history_success_entry::Builder
    {
        crate::model::batch_get_asset_property_value_history_success_entry::Builder::default()
    }
}

/// <p>A list of the errors (if any) associated with the batch request. Each error entry contains the <code>entryId</code> of the entry that failed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchGetAssetPropertyValueHistoryErrorEntry {
    /// <p>The error code.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<crate::model::BatchGetAssetPropertyValueHistoryErrorCode>,
    /// <p>The associated error message.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
    /// <p>The ID of the entry.</p>
    #[doc(hidden)]
    pub entry_id: std::option::Option<std::string::String>,
}
impl BatchGetAssetPropertyValueHistoryErrorEntry {
    /// <p>The error code.</p>
    pub fn error_code(
        &self,
    ) -> std::option::Option<&crate::model::BatchGetAssetPropertyValueHistoryErrorCode> {
        self.error_code.as_ref()
    }
    /// <p>The associated error message.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
    /// <p>The ID of the entry.</p>
    pub fn entry_id(&self) -> std::option::Option<&str> {
        self.entry_id.as_deref()
    }
}
/// See [`BatchGetAssetPropertyValueHistoryErrorEntry`](crate::model::BatchGetAssetPropertyValueHistoryErrorEntry).
pub mod batch_get_asset_property_value_history_error_entry {

    /// A builder for [`BatchGetAssetPropertyValueHistoryErrorEntry`](crate::model::BatchGetAssetPropertyValueHistoryErrorEntry).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error_code:
            std::option::Option<crate::model::BatchGetAssetPropertyValueHistoryErrorCode>,
        pub(crate) error_message: std::option::Option<std::string::String>,
        pub(crate) entry_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The error code.</p>
        pub fn error_code(
            mut self,
            input: crate::model::BatchGetAssetPropertyValueHistoryErrorCode,
        ) -> Self {
            self.error_code = Some(input);
            self
        }
        /// <p>The error code.</p>
        pub fn set_error_code(
            mut self,
            input: std::option::Option<crate::model::BatchGetAssetPropertyValueHistoryErrorCode>,
        ) -> Self {
            self.error_code = input;
            self
        }
        /// <p>The associated error message.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>The associated error message.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// <p>The ID of the entry.</p>
        pub fn entry_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.entry_id = Some(input.into());
            self
        }
        /// <p>The ID of the entry.</p>
        pub fn set_entry_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.entry_id = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchGetAssetPropertyValueHistoryErrorEntry`](crate::model::BatchGetAssetPropertyValueHistoryErrorEntry).
        pub fn build(self) -> crate::model::BatchGetAssetPropertyValueHistoryErrorEntry {
            crate::model::BatchGetAssetPropertyValueHistoryErrorEntry {
                error_code: self.error_code,
                error_message: self.error_message,
                entry_id: self.entry_id,
            }
        }
    }
}
impl BatchGetAssetPropertyValueHistoryErrorEntry {
    /// Creates a new builder-style object to manufacture [`BatchGetAssetPropertyValueHistoryErrorEntry`](crate::model::BatchGetAssetPropertyValueHistoryErrorEntry).
    pub fn builder() -> crate::model::batch_get_asset_property_value_history_error_entry::Builder {
        crate::model::batch_get_asset_property_value_history_error_entry::Builder::default()
    }
}

/// <p>Contains information for an asset property historical value entry that is associated with the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValue.html">BatchGetAssetPropertyValueHistory</a> API.</p>
/// <p>To identify an asset property, you must specify one of the following:</p>
/// <ul>
/// <li> <p>The <code>assetId</code> and <code>propertyId</code> of an asset property.</p> </li>
/// <li> <p>A <code>propertyAlias</code>, which is a data stream alias (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). To define an asset property's alias, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetProperty.html">UpdateAssetProperty</a>.</p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchGetAssetPropertyValueHistoryEntry {
    /// <p>The ID of the entry.</p>
    #[doc(hidden)]
    pub entry_id: std::option::Option<std::string::String>,
    /// <p>The ID of the asset in which the asset property was created.</p>
    #[doc(hidden)]
    pub asset_id: std::option::Option<std::string::String>,
    /// <p>The ID of the asset property.</p>
    #[doc(hidden)]
    pub property_id: std::option::Option<std::string::String>,
    /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub property_alias: std::option::Option<std::string::String>,
    /// <p>The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.</p>
    #[doc(hidden)]
    pub start_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.</p>
    #[doc(hidden)]
    pub end_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The quality by which to filter asset data.</p>
    #[doc(hidden)]
    pub qualities: std::option::Option<std::vec::Vec<crate::model::Quality>>,
    /// <p>The chronological sorting order of the requested information.</p>
    /// <p>Default: <code>ASCENDING</code> </p>
    #[doc(hidden)]
    pub time_ordering: std::option::Option<crate::model::TimeOrdering>,
}
impl BatchGetAssetPropertyValueHistoryEntry {
    /// <p>The ID of the entry.</p>
    pub fn entry_id(&self) -> std::option::Option<&str> {
        self.entry_id.as_deref()
    }
    /// <p>The ID of the asset in which the asset property was created.</p>
    pub fn asset_id(&self) -> std::option::Option<&str> {
        self.asset_id.as_deref()
    }
    /// <p>The ID of the asset property.</p>
    pub fn property_id(&self) -> std::option::Option<&str> {
        self.property_id.as_deref()
    }
    /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn property_alias(&self) -> std::option::Option<&str> {
        self.property_alias.as_deref()
    }
    /// <p>The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.</p>
    pub fn start_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_date.as_ref()
    }
    /// <p>The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.</p>
    pub fn end_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_date.as_ref()
    }
    /// <p>The quality by which to filter asset data.</p>
    pub fn qualities(&self) -> std::option::Option<&[crate::model::Quality]> {
        self.qualities.as_deref()
    }
    /// <p>The chronological sorting order of the requested information.</p>
    /// <p>Default: <code>ASCENDING</code> </p>
    pub fn time_ordering(&self) -> std::option::Option<&crate::model::TimeOrdering> {
        self.time_ordering.as_ref()
    }
}
/// See [`BatchGetAssetPropertyValueHistoryEntry`](crate::model::BatchGetAssetPropertyValueHistoryEntry).
pub mod batch_get_asset_property_value_history_entry {

    /// A builder for [`BatchGetAssetPropertyValueHistoryEntry`](crate::model::BatchGetAssetPropertyValueHistoryEntry).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entry_id: std::option::Option<std::string::String>,
        pub(crate) asset_id: std::option::Option<std::string::String>,
        pub(crate) property_id: std::option::Option<std::string::String>,
        pub(crate) property_alias: std::option::Option<std::string::String>,
        pub(crate) start_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) qualities: std::option::Option<std::vec::Vec<crate::model::Quality>>,
        pub(crate) time_ordering: std::option::Option<crate::model::TimeOrdering>,
    }
    impl Builder {
        /// <p>The ID of the entry.</p>
        pub fn entry_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.entry_id = Some(input.into());
            self
        }
        /// <p>The ID of the entry.</p>
        pub fn set_entry_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.entry_id = input;
            self
        }
        /// <p>The ID of the asset in which the asset property was created.</p>
        pub fn asset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset in which the asset property was created.</p>
        pub fn set_asset_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_id = input;
            self
        }
        /// <p>The ID of the asset property.</p>
        pub fn property_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset property.</p>
        pub fn set_property_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.property_id = input;
            self
        }
        /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn property_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_alias = Some(input.into());
            self
        }
        /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_property_alias(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.property_alias = input;
            self
        }
        /// <p>The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.</p>
        pub fn start_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_date = Some(input);
            self
        }
        /// <p>The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.</p>
        pub fn set_start_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_date = input;
            self
        }
        /// <p>The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.</p>
        pub fn end_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_date = Some(input);
            self
        }
        /// <p>The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.</p>
        pub fn set_end_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_date = input;
            self
        }
        /// Appends an item to `qualities`.
        ///
        /// To override the contents of this collection use [`set_qualities`](Self::set_qualities).
        ///
        /// <p>The quality by which to filter asset data.</p>
        pub fn qualities(mut self, input: crate::model::Quality) -> Self {
            let mut v = self.qualities.unwrap_or_default();
            v.push(input);
            self.qualities = Some(v);
            self
        }
        /// <p>The quality by which to filter asset data.</p>
        pub fn set_qualities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Quality>>,
        ) -> Self {
            self.qualities = input;
            self
        }
        /// <p>The chronological sorting order of the requested information.</p>
        /// <p>Default: <code>ASCENDING</code> </p>
        pub fn time_ordering(mut self, input: crate::model::TimeOrdering) -> Self {
            self.time_ordering = Some(input);
            self
        }
        /// <p>The chronological sorting order of the requested information.</p>
        /// <p>Default: <code>ASCENDING</code> </p>
        pub fn set_time_ordering(
            mut self,
            input: std::option::Option<crate::model::TimeOrdering>,
        ) -> Self {
            self.time_ordering = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchGetAssetPropertyValueHistoryEntry`](crate::model::BatchGetAssetPropertyValueHistoryEntry).
        pub fn build(self) -> crate::model::BatchGetAssetPropertyValueHistoryEntry {
            crate::model::BatchGetAssetPropertyValueHistoryEntry {
                entry_id: self.entry_id,
                asset_id: self.asset_id,
                property_id: self.property_id,
                property_alias: self.property_alias,
                start_date: self.start_date,
                end_date: self.end_date,
                qualities: self.qualities,
                time_ordering: self.time_ordering,
            }
        }
    }
}
impl BatchGetAssetPropertyValueHistoryEntry {
    /// Creates a new builder-style object to manufacture [`BatchGetAssetPropertyValueHistoryEntry`](crate::model::BatchGetAssetPropertyValueHistoryEntry).
    pub fn builder() -> crate::model::batch_get_asset_property_value_history_entry::Builder {
        crate::model::batch_get_asset_property_value_history_entry::Builder::default()
    }
}

/// <p>Contains information for an entry that has been processed by the previous <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValue.html">BatchGetAssetPropertyValue</a> request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchGetAssetPropertyValueSkippedEntry {
    /// <p>The ID of the entry.</p>
    #[doc(hidden)]
    pub entry_id: std::option::Option<std::string::String>,
    /// <p>The completion status of each entry that is associated with the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValue.html">BatchGetAssetPropertyValue</a> request.</p>
    #[doc(hidden)]
    pub completion_status: std::option::Option<crate::model::BatchEntryCompletionStatus>,
    /// <p>The error information, such as the error code and the timestamp.</p>
    #[doc(hidden)]
    pub error_info: std::option::Option<crate::model::BatchGetAssetPropertyValueErrorInfo>,
}
impl BatchGetAssetPropertyValueSkippedEntry {
    /// <p>The ID of the entry.</p>
    pub fn entry_id(&self) -> std::option::Option<&str> {
        self.entry_id.as_deref()
    }
    /// <p>The completion status of each entry that is associated with the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValue.html">BatchGetAssetPropertyValue</a> request.</p>
    pub fn completion_status(
        &self,
    ) -> std::option::Option<&crate::model::BatchEntryCompletionStatus> {
        self.completion_status.as_ref()
    }
    /// <p>The error information, such as the error code and the timestamp.</p>
    pub fn error_info(
        &self,
    ) -> std::option::Option<&crate::model::BatchGetAssetPropertyValueErrorInfo> {
        self.error_info.as_ref()
    }
}
/// See [`BatchGetAssetPropertyValueSkippedEntry`](crate::model::BatchGetAssetPropertyValueSkippedEntry).
pub mod batch_get_asset_property_value_skipped_entry {

    /// A builder for [`BatchGetAssetPropertyValueSkippedEntry`](crate::model::BatchGetAssetPropertyValueSkippedEntry).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entry_id: std::option::Option<std::string::String>,
        pub(crate) completion_status: std::option::Option<crate::model::BatchEntryCompletionStatus>,
        pub(crate) error_info:
            std::option::Option<crate::model::BatchGetAssetPropertyValueErrorInfo>,
    }
    impl Builder {
        /// <p>The ID of the entry.</p>
        pub fn entry_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.entry_id = Some(input.into());
            self
        }
        /// <p>The ID of the entry.</p>
        pub fn set_entry_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.entry_id = input;
            self
        }
        /// <p>The completion status of each entry that is associated with the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValue.html">BatchGetAssetPropertyValue</a> request.</p>
        pub fn completion_status(
            mut self,
            input: crate::model::BatchEntryCompletionStatus,
        ) -> Self {
            self.completion_status = Some(input);
            self
        }
        /// <p>The completion status of each entry that is associated with the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValue.html">BatchGetAssetPropertyValue</a> request.</p>
        pub fn set_completion_status(
            mut self,
            input: std::option::Option<crate::model::BatchEntryCompletionStatus>,
        ) -> Self {
            self.completion_status = input;
            self
        }
        /// <p>The error information, such as the error code and the timestamp.</p>
        pub fn error_info(
            mut self,
            input: crate::model::BatchGetAssetPropertyValueErrorInfo,
        ) -> Self {
            self.error_info = Some(input);
            self
        }
        /// <p>The error information, such as the error code and the timestamp.</p>
        pub fn set_error_info(
            mut self,
            input: std::option::Option<crate::model::BatchGetAssetPropertyValueErrorInfo>,
        ) -> Self {
            self.error_info = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchGetAssetPropertyValueSkippedEntry`](crate::model::BatchGetAssetPropertyValueSkippedEntry).
        pub fn build(self) -> crate::model::BatchGetAssetPropertyValueSkippedEntry {
            crate::model::BatchGetAssetPropertyValueSkippedEntry {
                entry_id: self.entry_id,
                completion_status: self.completion_status,
                error_info: self.error_info,
            }
        }
    }
}
impl BatchGetAssetPropertyValueSkippedEntry {
    /// Creates a new builder-style object to manufacture [`BatchGetAssetPropertyValueSkippedEntry`](crate::model::BatchGetAssetPropertyValueSkippedEntry).
    pub fn builder() -> crate::model::batch_get_asset_property_value_skipped_entry::Builder {
        crate::model::batch_get_asset_property_value_skipped_entry::Builder::default()
    }
}

/// <p>The error information, such as the error code and the timestamp.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchGetAssetPropertyValueErrorInfo {
    /// <p>The error code.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<crate::model::BatchGetAssetPropertyValueErrorCode>,
    /// <p>The date the error occurred, in Unix epoch time.</p>
    #[doc(hidden)]
    pub error_timestamp: std::option::Option<aws_smithy_types::DateTime>,
}
impl BatchGetAssetPropertyValueErrorInfo {
    /// <p>The error code.</p>
    pub fn error_code(
        &self,
    ) -> std::option::Option<&crate::model::BatchGetAssetPropertyValueErrorCode> {
        self.error_code.as_ref()
    }
    /// <p>The date the error occurred, in Unix epoch time.</p>
    pub fn error_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.error_timestamp.as_ref()
    }
}
/// See [`BatchGetAssetPropertyValueErrorInfo`](crate::model::BatchGetAssetPropertyValueErrorInfo).
pub mod batch_get_asset_property_value_error_info {

    /// A builder for [`BatchGetAssetPropertyValueErrorInfo`](crate::model::BatchGetAssetPropertyValueErrorInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error_code:
            std::option::Option<crate::model::BatchGetAssetPropertyValueErrorCode>,
        pub(crate) error_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The error code.</p>
        pub fn error_code(
            mut self,
            input: crate::model::BatchGetAssetPropertyValueErrorCode,
        ) -> Self {
            self.error_code = Some(input);
            self
        }
        /// <p>The error code.</p>
        pub fn set_error_code(
            mut self,
            input: std::option::Option<crate::model::BatchGetAssetPropertyValueErrorCode>,
        ) -> Self {
            self.error_code = input;
            self
        }
        /// <p>The date the error occurred, in Unix epoch time.</p>
        pub fn error_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.error_timestamp = Some(input);
            self
        }
        /// <p>The date the error occurred, in Unix epoch time.</p>
        pub fn set_error_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.error_timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchGetAssetPropertyValueErrorInfo`](crate::model::BatchGetAssetPropertyValueErrorInfo).
        pub fn build(self) -> crate::model::BatchGetAssetPropertyValueErrorInfo {
            crate::model::BatchGetAssetPropertyValueErrorInfo {
                error_code: self.error_code,
                error_timestamp: self.error_timestamp,
            }
        }
    }
}
impl BatchGetAssetPropertyValueErrorInfo {
    /// Creates a new builder-style object to manufacture [`BatchGetAssetPropertyValueErrorInfo`](crate::model::BatchGetAssetPropertyValueErrorInfo).
    pub fn builder() -> crate::model::batch_get_asset_property_value_error_info::Builder {
        crate::model::batch_get_asset_property_value_error_info::Builder::default()
    }
}

/// When writing a match expression against `BatchGetAssetPropertyValueErrorCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let batchgetassetpropertyvalueerrorcode = unimplemented!();
/// match batchgetassetpropertyvalueerrorcode {
///     BatchGetAssetPropertyValueErrorCode::AccessDeniedException => { /* ... */ },
///     BatchGetAssetPropertyValueErrorCode::InvalidRequestException => { /* ... */ },
///     BatchGetAssetPropertyValueErrorCode::ResourceNotFoundException => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `batchgetassetpropertyvalueerrorcode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `BatchGetAssetPropertyValueErrorCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `BatchGetAssetPropertyValueErrorCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `BatchGetAssetPropertyValueErrorCode::NewFeature` is defined.
/// Specifically, when `batchgetassetpropertyvalueerrorcode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `BatchGetAssetPropertyValueErrorCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BatchGetAssetPropertyValueErrorCode {
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedException,
    #[allow(missing_docs)] // documentation missing in model
    InvalidRequestException,
    #[allow(missing_docs)] // documentation missing in model
    ResourceNotFoundException,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for BatchGetAssetPropertyValueErrorCode {
    fn from(s: &str) -> Self {
        match s {
            "AccessDeniedException" => BatchGetAssetPropertyValueErrorCode::AccessDeniedException,
            "InvalidRequestException" => {
                BatchGetAssetPropertyValueErrorCode::InvalidRequestException
            }
            "ResourceNotFoundException" => {
                BatchGetAssetPropertyValueErrorCode::ResourceNotFoundException
            }
            other => BatchGetAssetPropertyValueErrorCode::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for BatchGetAssetPropertyValueErrorCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BatchGetAssetPropertyValueErrorCode::from(s))
    }
}
impl BatchGetAssetPropertyValueErrorCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            BatchGetAssetPropertyValueErrorCode::AccessDeniedException => "AccessDeniedException",
            BatchGetAssetPropertyValueErrorCode::InvalidRequestException => {
                "InvalidRequestException"
            }
            BatchGetAssetPropertyValueErrorCode::ResourceNotFoundException => {
                "ResourceNotFoundException"
            }
            BatchGetAssetPropertyValueErrorCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AccessDeniedException",
            "InvalidRequestException",
            "ResourceNotFoundException",
        ]
    }
}
impl AsRef<str> for BatchGetAssetPropertyValueErrorCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains success information for an entry that is associated with the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValue.html">BatchGetAssetPropertyValue</a> API.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchGetAssetPropertyValueSuccessEntry {
    /// <p>The ID of the entry.</p>
    #[doc(hidden)]
    pub entry_id: std::option::Option<std::string::String>,
    /// <p>Contains asset property value information.</p>
    #[doc(hidden)]
    pub asset_property_value: std::option::Option<crate::model::AssetPropertyValue>,
}
impl BatchGetAssetPropertyValueSuccessEntry {
    /// <p>The ID of the entry.</p>
    pub fn entry_id(&self) -> std::option::Option<&str> {
        self.entry_id.as_deref()
    }
    /// <p>Contains asset property value information.</p>
    pub fn asset_property_value(&self) -> std::option::Option<&crate::model::AssetPropertyValue> {
        self.asset_property_value.as_ref()
    }
}
/// See [`BatchGetAssetPropertyValueSuccessEntry`](crate::model::BatchGetAssetPropertyValueSuccessEntry).
pub mod batch_get_asset_property_value_success_entry {

    /// A builder for [`BatchGetAssetPropertyValueSuccessEntry`](crate::model::BatchGetAssetPropertyValueSuccessEntry).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entry_id: std::option::Option<std::string::String>,
        pub(crate) asset_property_value: std::option::Option<crate::model::AssetPropertyValue>,
    }
    impl Builder {
        /// <p>The ID of the entry.</p>
        pub fn entry_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.entry_id = Some(input.into());
            self
        }
        /// <p>The ID of the entry.</p>
        pub fn set_entry_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.entry_id = input;
            self
        }
        /// <p>Contains asset property value information.</p>
        pub fn asset_property_value(mut self, input: crate::model::AssetPropertyValue) -> Self {
            self.asset_property_value = Some(input);
            self
        }
        /// <p>Contains asset property value information.</p>
        pub fn set_asset_property_value(
            mut self,
            input: std::option::Option<crate::model::AssetPropertyValue>,
        ) -> Self {
            self.asset_property_value = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchGetAssetPropertyValueSuccessEntry`](crate::model::BatchGetAssetPropertyValueSuccessEntry).
        pub fn build(self) -> crate::model::BatchGetAssetPropertyValueSuccessEntry {
            crate::model::BatchGetAssetPropertyValueSuccessEntry {
                entry_id: self.entry_id,
                asset_property_value: self.asset_property_value,
            }
        }
    }
}
impl BatchGetAssetPropertyValueSuccessEntry {
    /// Creates a new builder-style object to manufacture [`BatchGetAssetPropertyValueSuccessEntry`](crate::model::BatchGetAssetPropertyValueSuccessEntry).
    pub fn builder() -> crate::model::batch_get_asset_property_value_success_entry::Builder {
        crate::model::batch_get_asset_property_value_success_entry::Builder::default()
    }
}

/// <p>Contains error information for an asset property value entry that is associated with the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValue.html">BatchGetAssetPropertyValue</a> API.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchGetAssetPropertyValueErrorEntry {
    /// <p>The error code.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<crate::model::BatchGetAssetPropertyValueErrorCode>,
    /// <p>The associated error message.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
    /// <p>The ID of the entry.</p>
    #[doc(hidden)]
    pub entry_id: std::option::Option<std::string::String>,
}
impl BatchGetAssetPropertyValueErrorEntry {
    /// <p>The error code.</p>
    pub fn error_code(
        &self,
    ) -> std::option::Option<&crate::model::BatchGetAssetPropertyValueErrorCode> {
        self.error_code.as_ref()
    }
    /// <p>The associated error message.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
    /// <p>The ID of the entry.</p>
    pub fn entry_id(&self) -> std::option::Option<&str> {
        self.entry_id.as_deref()
    }
}
/// See [`BatchGetAssetPropertyValueErrorEntry`](crate::model::BatchGetAssetPropertyValueErrorEntry).
pub mod batch_get_asset_property_value_error_entry {

    /// A builder for [`BatchGetAssetPropertyValueErrorEntry`](crate::model::BatchGetAssetPropertyValueErrorEntry).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error_code:
            std::option::Option<crate::model::BatchGetAssetPropertyValueErrorCode>,
        pub(crate) error_message: std::option::Option<std::string::String>,
        pub(crate) entry_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The error code.</p>
        pub fn error_code(
            mut self,
            input: crate::model::BatchGetAssetPropertyValueErrorCode,
        ) -> Self {
            self.error_code = Some(input);
            self
        }
        /// <p>The error code.</p>
        pub fn set_error_code(
            mut self,
            input: std::option::Option<crate::model::BatchGetAssetPropertyValueErrorCode>,
        ) -> Self {
            self.error_code = input;
            self
        }
        /// <p>The associated error message.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>The associated error message.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// <p>The ID of the entry.</p>
        pub fn entry_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.entry_id = Some(input.into());
            self
        }
        /// <p>The ID of the entry.</p>
        pub fn set_entry_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.entry_id = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchGetAssetPropertyValueErrorEntry`](crate::model::BatchGetAssetPropertyValueErrorEntry).
        pub fn build(self) -> crate::model::BatchGetAssetPropertyValueErrorEntry {
            crate::model::BatchGetAssetPropertyValueErrorEntry {
                error_code: self.error_code,
                error_message: self.error_message,
                entry_id: self.entry_id,
            }
        }
    }
}
impl BatchGetAssetPropertyValueErrorEntry {
    /// Creates a new builder-style object to manufacture [`BatchGetAssetPropertyValueErrorEntry`](crate::model::BatchGetAssetPropertyValueErrorEntry).
    pub fn builder() -> crate::model::batch_get_asset_property_value_error_entry::Builder {
        crate::model::batch_get_asset_property_value_error_entry::Builder::default()
    }
}

/// <p>Contains information for an asset property value entry that is associated with the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValue.html">BatchGetAssetPropertyValue</a> API.</p>
/// <p>To identify an asset property, you must specify one of the following:</p>
/// <ul>
/// <li> <p>The <code>assetId</code> and <code>propertyId</code> of an asset property.</p> </li>
/// <li> <p>A <code>propertyAlias</code>, which is a data stream alias (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). To define an asset property's alias, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetProperty.html">UpdateAssetProperty</a>.</p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchGetAssetPropertyValueEntry {
    /// <p>The ID of the entry.</p>
    #[doc(hidden)]
    pub entry_id: std::option::Option<std::string::String>,
    /// <p>The ID of the asset in which the asset property was created.</p>
    #[doc(hidden)]
    pub asset_id: std::option::Option<std::string::String>,
    /// <p>The ID of the asset property.</p>
    #[doc(hidden)]
    pub property_id: std::option::Option<std::string::String>,
    /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub property_alias: std::option::Option<std::string::String>,
}
impl BatchGetAssetPropertyValueEntry {
    /// <p>The ID of the entry.</p>
    pub fn entry_id(&self) -> std::option::Option<&str> {
        self.entry_id.as_deref()
    }
    /// <p>The ID of the asset in which the asset property was created.</p>
    pub fn asset_id(&self) -> std::option::Option<&str> {
        self.asset_id.as_deref()
    }
    /// <p>The ID of the asset property.</p>
    pub fn property_id(&self) -> std::option::Option<&str> {
        self.property_id.as_deref()
    }
    /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn property_alias(&self) -> std::option::Option<&str> {
        self.property_alias.as_deref()
    }
}
/// See [`BatchGetAssetPropertyValueEntry`](crate::model::BatchGetAssetPropertyValueEntry).
pub mod batch_get_asset_property_value_entry {

    /// A builder for [`BatchGetAssetPropertyValueEntry`](crate::model::BatchGetAssetPropertyValueEntry).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entry_id: std::option::Option<std::string::String>,
        pub(crate) asset_id: std::option::Option<std::string::String>,
        pub(crate) property_id: std::option::Option<std::string::String>,
        pub(crate) property_alias: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the entry.</p>
        pub fn entry_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.entry_id = Some(input.into());
            self
        }
        /// <p>The ID of the entry.</p>
        pub fn set_entry_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.entry_id = input;
            self
        }
        /// <p>The ID of the asset in which the asset property was created.</p>
        pub fn asset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset in which the asset property was created.</p>
        pub fn set_asset_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_id = input;
            self
        }
        /// <p>The ID of the asset property.</p>
        pub fn property_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset property.</p>
        pub fn set_property_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.property_id = input;
            self
        }
        /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn property_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_alias = Some(input.into());
            self
        }
        /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_property_alias(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.property_alias = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchGetAssetPropertyValueEntry`](crate::model::BatchGetAssetPropertyValueEntry).
        pub fn build(self) -> crate::model::BatchGetAssetPropertyValueEntry {
            crate::model::BatchGetAssetPropertyValueEntry {
                entry_id: self.entry_id,
                asset_id: self.asset_id,
                property_id: self.property_id,
                property_alias: self.property_alias,
            }
        }
    }
}
impl BatchGetAssetPropertyValueEntry {
    /// Creates a new builder-style object to manufacture [`BatchGetAssetPropertyValueEntry`](crate::model::BatchGetAssetPropertyValueEntry).
    pub fn builder() -> crate::model::batch_get_asset_property_value_entry::Builder {
        crate::model::batch_get_asset_property_value_entry::Builder::default()
    }
}

/// <p>Contains information for an entry that has been processed by the previous <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyAggregates.html">BatchGetAssetPropertyAggregates</a> request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchGetAssetPropertyAggregatesSkippedEntry {
    /// <p>The ID of the entry.</p>
    #[doc(hidden)]
    pub entry_id: std::option::Option<std::string::String>,
    /// <p>The completion status of each entry that is associated with the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyAggregates.html">BatchGetAssetPropertyAggregates</a> API.</p>
    #[doc(hidden)]
    pub completion_status: std::option::Option<crate::model::BatchEntryCompletionStatus>,
    /// <p>The error information, such as the error code and the timestamp.</p>
    #[doc(hidden)]
    pub error_info: std::option::Option<crate::model::BatchGetAssetPropertyAggregatesErrorInfo>,
}
impl BatchGetAssetPropertyAggregatesSkippedEntry {
    /// <p>The ID of the entry.</p>
    pub fn entry_id(&self) -> std::option::Option<&str> {
        self.entry_id.as_deref()
    }
    /// <p>The completion status of each entry that is associated with the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyAggregates.html">BatchGetAssetPropertyAggregates</a> API.</p>
    pub fn completion_status(
        &self,
    ) -> std::option::Option<&crate::model::BatchEntryCompletionStatus> {
        self.completion_status.as_ref()
    }
    /// <p>The error information, such as the error code and the timestamp.</p>
    pub fn error_info(
        &self,
    ) -> std::option::Option<&crate::model::BatchGetAssetPropertyAggregatesErrorInfo> {
        self.error_info.as_ref()
    }
}
/// See [`BatchGetAssetPropertyAggregatesSkippedEntry`](crate::model::BatchGetAssetPropertyAggregatesSkippedEntry).
pub mod batch_get_asset_property_aggregates_skipped_entry {

    /// A builder for [`BatchGetAssetPropertyAggregatesSkippedEntry`](crate::model::BatchGetAssetPropertyAggregatesSkippedEntry).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entry_id: std::option::Option<std::string::String>,
        pub(crate) completion_status: std::option::Option<crate::model::BatchEntryCompletionStatus>,
        pub(crate) error_info:
            std::option::Option<crate::model::BatchGetAssetPropertyAggregatesErrorInfo>,
    }
    impl Builder {
        /// <p>The ID of the entry.</p>
        pub fn entry_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.entry_id = Some(input.into());
            self
        }
        /// <p>The ID of the entry.</p>
        pub fn set_entry_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.entry_id = input;
            self
        }
        /// <p>The completion status of each entry that is associated with the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyAggregates.html">BatchGetAssetPropertyAggregates</a> API.</p>
        pub fn completion_status(
            mut self,
            input: crate::model::BatchEntryCompletionStatus,
        ) -> Self {
            self.completion_status = Some(input);
            self
        }
        /// <p>The completion status of each entry that is associated with the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyAggregates.html">BatchGetAssetPropertyAggregates</a> API.</p>
        pub fn set_completion_status(
            mut self,
            input: std::option::Option<crate::model::BatchEntryCompletionStatus>,
        ) -> Self {
            self.completion_status = input;
            self
        }
        /// <p>The error information, such as the error code and the timestamp.</p>
        pub fn error_info(
            mut self,
            input: crate::model::BatchGetAssetPropertyAggregatesErrorInfo,
        ) -> Self {
            self.error_info = Some(input);
            self
        }
        /// <p>The error information, such as the error code and the timestamp.</p>
        pub fn set_error_info(
            mut self,
            input: std::option::Option<crate::model::BatchGetAssetPropertyAggregatesErrorInfo>,
        ) -> Self {
            self.error_info = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchGetAssetPropertyAggregatesSkippedEntry`](crate::model::BatchGetAssetPropertyAggregatesSkippedEntry).
        pub fn build(self) -> crate::model::BatchGetAssetPropertyAggregatesSkippedEntry {
            crate::model::BatchGetAssetPropertyAggregatesSkippedEntry {
                entry_id: self.entry_id,
                completion_status: self.completion_status,
                error_info: self.error_info,
            }
        }
    }
}
impl BatchGetAssetPropertyAggregatesSkippedEntry {
    /// Creates a new builder-style object to manufacture [`BatchGetAssetPropertyAggregatesSkippedEntry`](crate::model::BatchGetAssetPropertyAggregatesSkippedEntry).
    pub fn builder() -> crate::model::batch_get_asset_property_aggregates_skipped_entry::Builder {
        crate::model::batch_get_asset_property_aggregates_skipped_entry::Builder::default()
    }
}

/// <p>Contains the error code and the timestamp for an asset property aggregate entry that is associated with the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyAggregates.html">BatchGetAssetPropertyAggregates</a> API.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchGetAssetPropertyAggregatesErrorInfo {
    /// <p>The error code.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<crate::model::BatchGetAssetPropertyAggregatesErrorCode>,
    /// <p>The date the error occurred, in Unix epoch time.</p>
    #[doc(hidden)]
    pub error_timestamp: std::option::Option<aws_smithy_types::DateTime>,
}
impl BatchGetAssetPropertyAggregatesErrorInfo {
    /// <p>The error code.</p>
    pub fn error_code(
        &self,
    ) -> std::option::Option<&crate::model::BatchGetAssetPropertyAggregatesErrorCode> {
        self.error_code.as_ref()
    }
    /// <p>The date the error occurred, in Unix epoch time.</p>
    pub fn error_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.error_timestamp.as_ref()
    }
}
/// See [`BatchGetAssetPropertyAggregatesErrorInfo`](crate::model::BatchGetAssetPropertyAggregatesErrorInfo).
pub mod batch_get_asset_property_aggregates_error_info {

    /// A builder for [`BatchGetAssetPropertyAggregatesErrorInfo`](crate::model::BatchGetAssetPropertyAggregatesErrorInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error_code:
            std::option::Option<crate::model::BatchGetAssetPropertyAggregatesErrorCode>,
        pub(crate) error_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The error code.</p>
        pub fn error_code(
            mut self,
            input: crate::model::BatchGetAssetPropertyAggregatesErrorCode,
        ) -> Self {
            self.error_code = Some(input);
            self
        }
        /// <p>The error code.</p>
        pub fn set_error_code(
            mut self,
            input: std::option::Option<crate::model::BatchGetAssetPropertyAggregatesErrorCode>,
        ) -> Self {
            self.error_code = input;
            self
        }
        /// <p>The date the error occurred, in Unix epoch time.</p>
        pub fn error_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.error_timestamp = Some(input);
            self
        }
        /// <p>The date the error occurred, in Unix epoch time.</p>
        pub fn set_error_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.error_timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchGetAssetPropertyAggregatesErrorInfo`](crate::model::BatchGetAssetPropertyAggregatesErrorInfo).
        pub fn build(self) -> crate::model::BatchGetAssetPropertyAggregatesErrorInfo {
            crate::model::BatchGetAssetPropertyAggregatesErrorInfo {
                error_code: self.error_code,
                error_timestamp: self.error_timestamp,
            }
        }
    }
}
impl BatchGetAssetPropertyAggregatesErrorInfo {
    /// Creates a new builder-style object to manufacture [`BatchGetAssetPropertyAggregatesErrorInfo`](crate::model::BatchGetAssetPropertyAggregatesErrorInfo).
    pub fn builder() -> crate::model::batch_get_asset_property_aggregates_error_info::Builder {
        crate::model::batch_get_asset_property_aggregates_error_info::Builder::default()
    }
}

/// When writing a match expression against `BatchGetAssetPropertyAggregatesErrorCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let batchgetassetpropertyaggregateserrorcode = unimplemented!();
/// match batchgetassetpropertyaggregateserrorcode {
///     BatchGetAssetPropertyAggregatesErrorCode::AccessDeniedException => { /* ... */ },
///     BatchGetAssetPropertyAggregatesErrorCode::InvalidRequestException => { /* ... */ },
///     BatchGetAssetPropertyAggregatesErrorCode::ResourceNotFoundException => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `batchgetassetpropertyaggregateserrorcode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `BatchGetAssetPropertyAggregatesErrorCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `BatchGetAssetPropertyAggregatesErrorCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `BatchGetAssetPropertyAggregatesErrorCode::NewFeature` is defined.
/// Specifically, when `batchgetassetpropertyaggregateserrorcode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `BatchGetAssetPropertyAggregatesErrorCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BatchGetAssetPropertyAggregatesErrorCode {
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedException,
    #[allow(missing_docs)] // documentation missing in model
    InvalidRequestException,
    #[allow(missing_docs)] // documentation missing in model
    ResourceNotFoundException,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for BatchGetAssetPropertyAggregatesErrorCode {
    fn from(s: &str) -> Self {
        match s {
            "AccessDeniedException" => {
                BatchGetAssetPropertyAggregatesErrorCode::AccessDeniedException
            }
            "InvalidRequestException" => {
                BatchGetAssetPropertyAggregatesErrorCode::InvalidRequestException
            }
            "ResourceNotFoundException" => {
                BatchGetAssetPropertyAggregatesErrorCode::ResourceNotFoundException
            }
            other => BatchGetAssetPropertyAggregatesErrorCode::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for BatchGetAssetPropertyAggregatesErrorCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BatchGetAssetPropertyAggregatesErrorCode::from(s))
    }
}
impl BatchGetAssetPropertyAggregatesErrorCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            BatchGetAssetPropertyAggregatesErrorCode::AccessDeniedException => {
                "AccessDeniedException"
            }
            BatchGetAssetPropertyAggregatesErrorCode::InvalidRequestException => {
                "InvalidRequestException"
            }
            BatchGetAssetPropertyAggregatesErrorCode::ResourceNotFoundException => {
                "ResourceNotFoundException"
            }
            BatchGetAssetPropertyAggregatesErrorCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AccessDeniedException",
            "InvalidRequestException",
            "ResourceNotFoundException",
        ]
    }
}
impl AsRef<str> for BatchGetAssetPropertyAggregatesErrorCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains success information for an entry that is associated with the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyAggregates.html">BatchGetAssetPropertyAggregates</a> API.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchGetAssetPropertyAggregatesSuccessEntry {
    /// <p>The ID of the entry.</p>
    #[doc(hidden)]
    pub entry_id: std::option::Option<std::string::String>,
    /// <p>The requested aggregated asset property values (for example, average, minimum, and maximum).</p>
    #[doc(hidden)]
    pub aggregated_values: std::option::Option<std::vec::Vec<crate::model::AggregatedValue>>,
}
impl BatchGetAssetPropertyAggregatesSuccessEntry {
    /// <p>The ID of the entry.</p>
    pub fn entry_id(&self) -> std::option::Option<&str> {
        self.entry_id.as_deref()
    }
    /// <p>The requested aggregated asset property values (for example, average, minimum, and maximum).</p>
    pub fn aggregated_values(&self) -> std::option::Option<&[crate::model::AggregatedValue]> {
        self.aggregated_values.as_deref()
    }
}
/// See [`BatchGetAssetPropertyAggregatesSuccessEntry`](crate::model::BatchGetAssetPropertyAggregatesSuccessEntry).
pub mod batch_get_asset_property_aggregates_success_entry {

    /// A builder for [`BatchGetAssetPropertyAggregatesSuccessEntry`](crate::model::BatchGetAssetPropertyAggregatesSuccessEntry).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entry_id: std::option::Option<std::string::String>,
        pub(crate) aggregated_values:
            std::option::Option<std::vec::Vec<crate::model::AggregatedValue>>,
    }
    impl Builder {
        /// <p>The ID of the entry.</p>
        pub fn entry_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.entry_id = Some(input.into());
            self
        }
        /// <p>The ID of the entry.</p>
        pub fn set_entry_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.entry_id = input;
            self
        }
        /// Appends an item to `aggregated_values`.
        ///
        /// To override the contents of this collection use [`set_aggregated_values`](Self::set_aggregated_values).
        ///
        /// <p>The requested aggregated asset property values (for example, average, minimum, and maximum).</p>
        pub fn aggregated_values(mut self, input: crate::model::AggregatedValue) -> Self {
            let mut v = self.aggregated_values.unwrap_or_default();
            v.push(input);
            self.aggregated_values = Some(v);
            self
        }
        /// <p>The requested aggregated asset property values (for example, average, minimum, and maximum).</p>
        pub fn set_aggregated_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AggregatedValue>>,
        ) -> Self {
            self.aggregated_values = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchGetAssetPropertyAggregatesSuccessEntry`](crate::model::BatchGetAssetPropertyAggregatesSuccessEntry).
        pub fn build(self) -> crate::model::BatchGetAssetPropertyAggregatesSuccessEntry {
            crate::model::BatchGetAssetPropertyAggregatesSuccessEntry {
                entry_id: self.entry_id,
                aggregated_values: self.aggregated_values,
            }
        }
    }
}
impl BatchGetAssetPropertyAggregatesSuccessEntry {
    /// Creates a new builder-style object to manufacture [`BatchGetAssetPropertyAggregatesSuccessEntry`](crate::model::BatchGetAssetPropertyAggregatesSuccessEntry).
    pub fn builder() -> crate::model::batch_get_asset_property_aggregates_success_entry::Builder {
        crate::model::batch_get_asset_property_aggregates_success_entry::Builder::default()
    }
}

/// <p>Contains error information for an asset property aggregate entry that is associated with the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyAggregates.html">BatchGetAssetPropertyAggregates</a> API.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchGetAssetPropertyAggregatesErrorEntry {
    /// <p>The error code.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<crate::model::BatchGetAssetPropertyAggregatesErrorCode>,
    /// <p>The associated error message.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
    /// <p>The ID of the entry.</p>
    #[doc(hidden)]
    pub entry_id: std::option::Option<std::string::String>,
}
impl BatchGetAssetPropertyAggregatesErrorEntry {
    /// <p>The error code.</p>
    pub fn error_code(
        &self,
    ) -> std::option::Option<&crate::model::BatchGetAssetPropertyAggregatesErrorCode> {
        self.error_code.as_ref()
    }
    /// <p>The associated error message.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
    /// <p>The ID of the entry.</p>
    pub fn entry_id(&self) -> std::option::Option<&str> {
        self.entry_id.as_deref()
    }
}
/// See [`BatchGetAssetPropertyAggregatesErrorEntry`](crate::model::BatchGetAssetPropertyAggregatesErrorEntry).
pub mod batch_get_asset_property_aggregates_error_entry {

    /// A builder for [`BatchGetAssetPropertyAggregatesErrorEntry`](crate::model::BatchGetAssetPropertyAggregatesErrorEntry).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error_code:
            std::option::Option<crate::model::BatchGetAssetPropertyAggregatesErrorCode>,
        pub(crate) error_message: std::option::Option<std::string::String>,
        pub(crate) entry_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The error code.</p>
        pub fn error_code(
            mut self,
            input: crate::model::BatchGetAssetPropertyAggregatesErrorCode,
        ) -> Self {
            self.error_code = Some(input);
            self
        }
        /// <p>The error code.</p>
        pub fn set_error_code(
            mut self,
            input: std::option::Option<crate::model::BatchGetAssetPropertyAggregatesErrorCode>,
        ) -> Self {
            self.error_code = input;
            self
        }
        /// <p>The associated error message.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>The associated error message.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// <p>The ID of the entry.</p>
        pub fn entry_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.entry_id = Some(input.into());
            self
        }
        /// <p>The ID of the entry.</p>
        pub fn set_entry_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.entry_id = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchGetAssetPropertyAggregatesErrorEntry`](crate::model::BatchGetAssetPropertyAggregatesErrorEntry).
        pub fn build(self) -> crate::model::BatchGetAssetPropertyAggregatesErrorEntry {
            crate::model::BatchGetAssetPropertyAggregatesErrorEntry {
                error_code: self.error_code,
                error_message: self.error_message,
                entry_id: self.entry_id,
            }
        }
    }
}
impl BatchGetAssetPropertyAggregatesErrorEntry {
    /// Creates a new builder-style object to manufacture [`BatchGetAssetPropertyAggregatesErrorEntry`](crate::model::BatchGetAssetPropertyAggregatesErrorEntry).
    pub fn builder() -> crate::model::batch_get_asset_property_aggregates_error_entry::Builder {
        crate::model::batch_get_asset_property_aggregates_error_entry::Builder::default()
    }
}

/// <p>Contains information for an asset property aggregate entry that is associated with the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyAggregates.html">BatchGetAssetPropertyAggregates</a> API.</p>
/// <p>To identify an asset property, you must specify one of the following:</p>
/// <ul>
/// <li> <p>The <code>assetId</code> and <code>propertyId</code> of an asset property.</p> </li>
/// <li> <p>A <code>propertyAlias</code>, which is a data stream alias (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). To define an asset property's alias, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetProperty.html">UpdateAssetProperty</a>.</p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchGetAssetPropertyAggregatesEntry {
    /// <p>The ID of the entry.</p>
    #[doc(hidden)]
    pub entry_id: std::option::Option<std::string::String>,
    /// <p>The ID of the asset in which the asset property was created.</p>
    #[doc(hidden)]
    pub asset_id: std::option::Option<std::string::String>,
    /// <p>The ID of the asset property.</p>
    #[doc(hidden)]
    pub property_id: std::option::Option<std::string::String>,
    /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
    #[doc(hidden)]
    pub property_alias: std::option::Option<std::string::String>,
    /// <p>The data aggregating function.</p>
    #[doc(hidden)]
    pub aggregate_types: std::option::Option<std::vec::Vec<crate::model::AggregateType>>,
    /// <p>The time interval over which to aggregate data.</p>
    #[doc(hidden)]
    pub resolution: std::option::Option<std::string::String>,
    /// <p>The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.</p>
    #[doc(hidden)]
    pub start_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.</p>
    #[doc(hidden)]
    pub end_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The quality by which to filter asset data.</p>
    #[doc(hidden)]
    pub qualities: std::option::Option<std::vec::Vec<crate::model::Quality>>,
    /// <p>The chronological sorting order of the requested information.</p>
    /// <p>Default: <code>ASCENDING</code> </p>
    #[doc(hidden)]
    pub time_ordering: std::option::Option<crate::model::TimeOrdering>,
}
impl BatchGetAssetPropertyAggregatesEntry {
    /// <p>The ID of the entry.</p>
    pub fn entry_id(&self) -> std::option::Option<&str> {
        self.entry_id.as_deref()
    }
    /// <p>The ID of the asset in which the asset property was created.</p>
    pub fn asset_id(&self) -> std::option::Option<&str> {
        self.asset_id.as_deref()
    }
    /// <p>The ID of the asset property.</p>
    pub fn property_id(&self) -> std::option::Option<&str> {
        self.property_id.as_deref()
    }
    /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
    pub fn property_alias(&self) -> std::option::Option<&str> {
        self.property_alias.as_deref()
    }
    /// <p>The data aggregating function.</p>
    pub fn aggregate_types(&self) -> std::option::Option<&[crate::model::AggregateType]> {
        self.aggregate_types.as_deref()
    }
    /// <p>The time interval over which to aggregate data.</p>
    pub fn resolution(&self) -> std::option::Option<&str> {
        self.resolution.as_deref()
    }
    /// <p>The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.</p>
    pub fn start_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_date.as_ref()
    }
    /// <p>The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.</p>
    pub fn end_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_date.as_ref()
    }
    /// <p>The quality by which to filter asset data.</p>
    pub fn qualities(&self) -> std::option::Option<&[crate::model::Quality]> {
        self.qualities.as_deref()
    }
    /// <p>The chronological sorting order of the requested information.</p>
    /// <p>Default: <code>ASCENDING</code> </p>
    pub fn time_ordering(&self) -> std::option::Option<&crate::model::TimeOrdering> {
        self.time_ordering.as_ref()
    }
}
/// See [`BatchGetAssetPropertyAggregatesEntry`](crate::model::BatchGetAssetPropertyAggregatesEntry).
pub mod batch_get_asset_property_aggregates_entry {

    /// A builder for [`BatchGetAssetPropertyAggregatesEntry`](crate::model::BatchGetAssetPropertyAggregatesEntry).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entry_id: std::option::Option<std::string::String>,
        pub(crate) asset_id: std::option::Option<std::string::String>,
        pub(crate) property_id: std::option::Option<std::string::String>,
        pub(crate) property_alias: std::option::Option<std::string::String>,
        pub(crate) aggregate_types: std::option::Option<std::vec::Vec<crate::model::AggregateType>>,
        pub(crate) resolution: std::option::Option<std::string::String>,
        pub(crate) start_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) qualities: std::option::Option<std::vec::Vec<crate::model::Quality>>,
        pub(crate) time_ordering: std::option::Option<crate::model::TimeOrdering>,
    }
    impl Builder {
        /// <p>The ID of the entry.</p>
        pub fn entry_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.entry_id = Some(input.into());
            self
        }
        /// <p>The ID of the entry.</p>
        pub fn set_entry_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.entry_id = input;
            self
        }
        /// <p>The ID of the asset in which the asset property was created.</p>
        pub fn asset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset in which the asset property was created.</p>
        pub fn set_asset_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_id = input;
            self
        }
        /// <p>The ID of the asset property.</p>
        pub fn property_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset property.</p>
        pub fn set_property_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.property_id = input;
            self
        }
        /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn property_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_alias = Some(input.into());
            self
        }
        /// <p>The alias that identifies the property, such as an OPC-UA server data stream path (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the <i>IoT SiteWise User Guide</i>.</p>
        pub fn set_property_alias(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.property_alias = input;
            self
        }
        /// Appends an item to `aggregate_types`.
        ///
        /// To override the contents of this collection use [`set_aggregate_types`](Self::set_aggregate_types).
        ///
        /// <p>The data aggregating function.</p>
        pub fn aggregate_types(mut self, input: crate::model::AggregateType) -> Self {
            let mut v = self.aggregate_types.unwrap_or_default();
            v.push(input);
            self.aggregate_types = Some(v);
            self
        }
        /// <p>The data aggregating function.</p>
        pub fn set_aggregate_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AggregateType>>,
        ) -> Self {
            self.aggregate_types = input;
            self
        }
        /// <p>The time interval over which to aggregate data.</p>
        pub fn resolution(mut self, input: impl Into<std::string::String>) -> Self {
            self.resolution = Some(input.into());
            self
        }
        /// <p>The time interval over which to aggregate data.</p>
        pub fn set_resolution(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resolution = input;
            self
        }
        /// <p>The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.</p>
        pub fn start_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_date = Some(input);
            self
        }
        /// <p>The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.</p>
        pub fn set_start_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_date = input;
            self
        }
        /// <p>The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.</p>
        pub fn end_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_date = Some(input);
            self
        }
        /// <p>The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.</p>
        pub fn set_end_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_date = input;
            self
        }
        /// Appends an item to `qualities`.
        ///
        /// To override the contents of this collection use [`set_qualities`](Self::set_qualities).
        ///
        /// <p>The quality by which to filter asset data.</p>
        pub fn qualities(mut self, input: crate::model::Quality) -> Self {
            let mut v = self.qualities.unwrap_or_default();
            v.push(input);
            self.qualities = Some(v);
            self
        }
        /// <p>The quality by which to filter asset data.</p>
        pub fn set_qualities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Quality>>,
        ) -> Self {
            self.qualities = input;
            self
        }
        /// <p>The chronological sorting order of the requested information.</p>
        /// <p>Default: <code>ASCENDING</code> </p>
        pub fn time_ordering(mut self, input: crate::model::TimeOrdering) -> Self {
            self.time_ordering = Some(input);
            self
        }
        /// <p>The chronological sorting order of the requested information.</p>
        /// <p>Default: <code>ASCENDING</code> </p>
        pub fn set_time_ordering(
            mut self,
            input: std::option::Option<crate::model::TimeOrdering>,
        ) -> Self {
            self.time_ordering = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchGetAssetPropertyAggregatesEntry`](crate::model::BatchGetAssetPropertyAggregatesEntry).
        pub fn build(self) -> crate::model::BatchGetAssetPropertyAggregatesEntry {
            crate::model::BatchGetAssetPropertyAggregatesEntry {
                entry_id: self.entry_id,
                asset_id: self.asset_id,
                property_id: self.property_id,
                property_alias: self.property_alias,
                aggregate_types: self.aggregate_types,
                resolution: self.resolution,
                start_date: self.start_date,
                end_date: self.end_date,
                qualities: self.qualities,
                time_ordering: self.time_ordering,
            }
        }
    }
}
impl BatchGetAssetPropertyAggregatesEntry {
    /// Creates a new builder-style object to manufacture [`BatchGetAssetPropertyAggregatesEntry`](crate::model::BatchGetAssetPropertyAggregatesEntry).
    pub fn builder() -> crate::model::batch_get_asset_property_aggregates_entry::Builder {
        crate::model::batch_get_asset_property_aggregates_entry::Builder::default()
    }
}

/// <p>Contains error details for the requested associate project asset action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssetErrorDetails {
    /// <p>The ID of the asset.</p>
    #[doc(hidden)]
    pub asset_id: std::option::Option<std::string::String>,
    /// <p>The error code.</p>
    #[doc(hidden)]
    pub code: std::option::Option<crate::model::AssetErrorCode>,
    /// <p>The error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl AssetErrorDetails {
    /// <p>The ID of the asset.</p>
    pub fn asset_id(&self) -> std::option::Option<&str> {
        self.asset_id.as_deref()
    }
    /// <p>The error code.</p>
    pub fn code(&self) -> std::option::Option<&crate::model::AssetErrorCode> {
        self.code.as_ref()
    }
    /// <p>The error message.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
/// See [`AssetErrorDetails`](crate::model::AssetErrorDetails).
pub mod asset_error_details {

    /// A builder for [`AssetErrorDetails`](crate::model::AssetErrorDetails).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) asset_id: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<crate::model::AssetErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the asset.</p>
        pub fn asset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.asset_id = Some(input.into());
            self
        }
        /// <p>The ID of the asset.</p>
        pub fn set_asset_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.asset_id = input;
            self
        }
        /// <p>The error code.</p>
        pub fn code(mut self, input: crate::model::AssetErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        /// <p>The error code.</p>
        pub fn set_code(
            mut self,
            input: std::option::Option<crate::model::AssetErrorCode>,
        ) -> Self {
            self.code = input;
            self
        }
        /// <p>The error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AssetErrorDetails`](crate::model::AssetErrorDetails).
        pub fn build(self) -> crate::model::AssetErrorDetails {
            crate::model::AssetErrorDetails {
                asset_id: self.asset_id,
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl AssetErrorDetails {
    /// Creates a new builder-style object to manufacture [`AssetErrorDetails`](crate::model::AssetErrorDetails).
    pub fn builder() -> crate::model::asset_error_details::Builder {
        crate::model::asset_error_details::Builder::default()
    }
}

/// When writing a match expression against `AssetErrorCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let asseterrorcode = unimplemented!();
/// match asseterrorcode {
///     AssetErrorCode::InternalFailure => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `asseterrorcode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AssetErrorCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AssetErrorCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AssetErrorCode::NewFeature` is defined.
/// Specifically, when `asseterrorcode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AssetErrorCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AssetErrorCode {
    #[allow(missing_docs)] // documentation missing in model
    InternalFailure,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AssetErrorCode {
    fn from(s: &str) -> Self {
        match s {
            "INTERNAL_FAILURE" => AssetErrorCode::InternalFailure,
            other => AssetErrorCode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AssetErrorCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AssetErrorCode::from(s))
    }
}
impl AssetErrorCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AssetErrorCode::InternalFailure => "INTERNAL_FAILURE",
            AssetErrorCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["INTERNAL_FAILURE"]
    }
}
impl AsRef<str> for AssetErrorCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
