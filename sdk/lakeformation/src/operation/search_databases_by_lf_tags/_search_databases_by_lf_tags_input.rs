// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct SearchDatabasesByLfTagsInput {
    /// <p>A continuation token, if this is not the first call to retrieve this list.</p>
    pub next_token: ::std::option::Option<::std::string::String>,
    /// <p>The maximum number of results to return.</p>
    pub max_results: ::std::option::Option<i32>,
    /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.</p>
    pub catalog_id: ::std::option::Option<::std::string::String>,
    /// <p>A list of conditions (<code>LFTag</code> structures) to search for in database resources.</p>
    pub expression: ::std::option::Option<::std::vec::Vec<crate::types::LfTag>>,
}
impl SearchDatabasesByLfTagsInput {
    /// <p>A continuation token, if this is not the first call to retrieve this list.</p>
    pub fn next_token(&self) -> ::std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> ::std::option::Option<i32> {
        self.max_results
    }
    /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.</p>
    pub fn catalog_id(&self) -> ::std::option::Option<&str> {
        self.catalog_id.as_deref()
    }
    /// <p>A list of conditions (<code>LFTag</code> structures) to search for in database resources.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.expression.is_none()`.
    pub fn expression(&self) -> &[crate::types::LfTag] {
        self.expression.as_deref().unwrap_or_default()
    }
}
impl SearchDatabasesByLfTagsInput {
    /// Creates a new builder-style object to manufacture [`SearchDatabasesByLfTagsInput`](crate::operation::search_databases_by_lf_tags::SearchDatabasesByLfTagsInput).
    pub fn builder() -> crate::operation::search_databases_by_lf_tags::builders::SearchDatabasesByLfTagsInputBuilder {
        crate::operation::search_databases_by_lf_tags::builders::SearchDatabasesByLfTagsInputBuilder::default()
    }
}

/// A builder for [`SearchDatabasesByLfTagsInput`](crate::operation::search_databases_by_lf_tags::SearchDatabasesByLfTagsInput).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct SearchDatabasesByLfTagsInputBuilder {
    pub(crate) next_token: ::std::option::Option<::std::string::String>,
    pub(crate) max_results: ::std::option::Option<i32>,
    pub(crate) catalog_id: ::std::option::Option<::std::string::String>,
    pub(crate) expression: ::std::option::Option<::std::vec::Vec<crate::types::LfTag>>,
}
impl SearchDatabasesByLfTagsInputBuilder {
    /// <p>A continuation token, if this is not the first call to retrieve this list.</p>
    pub fn next_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.next_token = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A continuation token, if this is not the first call to retrieve this list.</p>
    pub fn set_next_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.next_token = input;
        self
    }
    /// <p>A continuation token, if this is not the first call to retrieve this list.</p>
    pub fn get_next_token(&self) -> &::std::option::Option<::std::string::String> {
        &self.next_token
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(mut self, input: i32) -> Self {
        self.max_results = ::std::option::Option::Some(input);
        self
    }
    /// <p>The maximum number of results to return.</p>
    pub fn set_max_results(mut self, input: ::std::option::Option<i32>) -> Self {
        self.max_results = input;
        self
    }
    /// <p>The maximum number of results to return.</p>
    pub fn get_max_results(&self) -> &::std::option::Option<i32> {
        &self.max_results
    }
    /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.</p>
    pub fn catalog_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.catalog_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.</p>
    pub fn set_catalog_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.catalog_id = input;
        self
    }
    /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.</p>
    pub fn get_catalog_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.catalog_id
    }
    /// Appends an item to `expression`.
    ///
    /// To override the contents of this collection use [`set_expression`](Self::set_expression).
    ///
    /// <p>A list of conditions (<code>LFTag</code> structures) to search for in database resources.</p>
    pub fn expression(mut self, input: crate::types::LfTag) -> Self {
        let mut v = self.expression.unwrap_or_default();
        v.push(input);
        self.expression = ::std::option::Option::Some(v);
        self
    }
    /// <p>A list of conditions (<code>LFTag</code> structures) to search for in database resources.</p>
    pub fn set_expression(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::LfTag>>) -> Self {
        self.expression = input;
        self
    }
    /// <p>A list of conditions (<code>LFTag</code> structures) to search for in database resources.</p>
    pub fn get_expression(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::LfTag>> {
        &self.expression
    }
    /// Consumes the builder and constructs a [`SearchDatabasesByLfTagsInput`](crate::operation::search_databases_by_lf_tags::SearchDatabasesByLfTagsInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<
        crate::operation::search_databases_by_lf_tags::SearchDatabasesByLfTagsInput,
        ::aws_smithy_types::error::operation::BuildError,
    > {
        ::std::result::Result::Ok(crate::operation::search_databases_by_lf_tags::SearchDatabasesByLfTagsInput {
            next_token: self.next_token,
            max_results: self.max_results,
            catalog_id: self.catalog_id,
            expression: self.expression,
        })
    }
}
