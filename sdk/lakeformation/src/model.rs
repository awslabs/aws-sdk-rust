// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// When writing a match expression against `OptimizerType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let optimizertype = unimplemented!();
/// match optimizertype {
///     OptimizerType::Generic => { /* ... */ },
///     OptimizerType::Compaction => { /* ... */ },
///     OptimizerType::GarbageCollection => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `optimizertype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `OptimizerType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `OptimizerType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `OptimizerType::NewFeature` is defined.
/// Specifically, when `optimizertype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `OptimizerType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OptimizerType {
    #[allow(missing_docs)] // documentation missing in model
    Generic,
    #[allow(missing_docs)] // documentation missing in model
    Compaction,
    #[allow(missing_docs)] // documentation missing in model
    GarbageCollection,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for OptimizerType {
    fn from(s: &str) -> Self {
        match s {
            "ALL" => OptimizerType::Generic,
            "COMPACTION" => OptimizerType::Compaction,
            "GARBAGE_COLLECTION" => OptimizerType::GarbageCollection,
            other => OptimizerType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for OptimizerType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OptimizerType::from(s))
    }
}
impl OptimizerType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OptimizerType::Generic => "ALL",
            OptimizerType::Compaction => "COMPACTION",
            OptimizerType::GarbageCollection => "GARBAGE_COLLECTION",
            OptimizerType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALL", "COMPACTION", "GARBAGE_COLLECTION"]
    }
}
impl AsRef<str> for OptimizerType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Defines an object to add to or delete from a governed table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WriteOperation {
    /// <p>A new object to add to the governed table.</p>
    #[doc(hidden)]
    pub add_object: std::option::Option<crate::model::AddObjectInput>,
    /// <p>An object to delete from the governed table.</p>
    #[doc(hidden)]
    pub delete_object: std::option::Option<crate::model::DeleteObjectInput>,
}
impl WriteOperation {
    /// <p>A new object to add to the governed table.</p>
    pub fn add_object(&self) -> std::option::Option<&crate::model::AddObjectInput> {
        self.add_object.as_ref()
    }
    /// <p>An object to delete from the governed table.</p>
    pub fn delete_object(&self) -> std::option::Option<&crate::model::DeleteObjectInput> {
        self.delete_object.as_ref()
    }
}
impl WriteOperation {
    /// Creates a new builder-style object to manufacture [`WriteOperation`](crate::model::WriteOperation).
    pub fn builder() -> crate::model::write_operation::Builder {
        crate::model::write_operation::Builder::default()
    }
}

/// See [`WriteOperation`](crate::model::WriteOperation).
pub mod write_operation {

    /// A builder for [`WriteOperation`](crate::model::WriteOperation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) add_object: std::option::Option<crate::model::AddObjectInput>,
        pub(crate) delete_object: std::option::Option<crate::model::DeleteObjectInput>,
    }
    impl Builder {
        /// <p>A new object to add to the governed table.</p>
        pub fn add_object(mut self, input: crate::model::AddObjectInput) -> Self {
            self.add_object = Some(input);
            self
        }
        /// <p>A new object to add to the governed table.</p>
        pub fn set_add_object(
            mut self,
            input: std::option::Option<crate::model::AddObjectInput>,
        ) -> Self {
            self.add_object = input;
            self
        }
        /// <p>An object to delete from the governed table.</p>
        pub fn delete_object(mut self, input: crate::model::DeleteObjectInput) -> Self {
            self.delete_object = Some(input);
            self
        }
        /// <p>An object to delete from the governed table.</p>
        pub fn set_delete_object(
            mut self,
            input: std::option::Option<crate::model::DeleteObjectInput>,
        ) -> Self {
            self.delete_object = input;
            self
        }
        /// Consumes the builder and constructs a [`WriteOperation`](crate::model::WriteOperation).
        pub fn build(self) -> crate::model::WriteOperation {
            crate::model::WriteOperation {
                add_object: self.add_object,
                delete_object: self.delete_object,
            }
        }
    }
}

/// <p>An object to delete from the governed table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteObjectInput {
    /// <p>The Amazon S3 location of the object to delete.</p>
    #[doc(hidden)]
    pub uri: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 ETag of the object. Returned by <code>GetTableObjects</code> for validation and used to identify changes to the underlying data.</p>
    #[doc(hidden)]
    pub e_tag: std::option::Option<std::string::String>,
    /// <p>A list of partition values for the object. A value must be specified for each partition key associated with the governed table.</p>
    #[doc(hidden)]
    pub partition_values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl DeleteObjectInput {
    /// <p>The Amazon S3 location of the object to delete.</p>
    pub fn uri(&self) -> std::option::Option<&str> {
        self.uri.as_deref()
    }
    /// <p>The Amazon S3 ETag of the object. Returned by <code>GetTableObjects</code> for validation and used to identify changes to the underlying data.</p>
    pub fn e_tag(&self) -> std::option::Option<&str> {
        self.e_tag.as_deref()
    }
    /// <p>A list of partition values for the object. A value must be specified for each partition key associated with the governed table.</p>
    pub fn partition_values(&self) -> std::option::Option<&[std::string::String]> {
        self.partition_values.as_deref()
    }
}
impl DeleteObjectInput {
    /// Creates a new builder-style object to manufacture [`DeleteObjectInput`](crate::model::DeleteObjectInput).
    pub fn builder() -> crate::model::delete_object_input::Builder {
        crate::model::delete_object_input::Builder::default()
    }
}

/// See [`DeleteObjectInput`](crate::model::DeleteObjectInput).
pub mod delete_object_input {

    /// A builder for [`DeleteObjectInput`](crate::model::DeleteObjectInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) uri: std::option::Option<std::string::String>,
        pub(crate) e_tag: std::option::Option<std::string::String>,
        pub(crate) partition_values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The Amazon S3 location of the object to delete.</p>
        pub fn uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.uri = Some(input.into());
            self
        }
        /// <p>The Amazon S3 location of the object to delete.</p>
        pub fn set_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.uri = input;
            self
        }
        /// <p>The Amazon S3 ETag of the object. Returned by <code>GetTableObjects</code> for validation and used to identify changes to the underlying data.</p>
        pub fn e_tag(mut self, input: impl Into<std::string::String>) -> Self {
            self.e_tag = Some(input.into());
            self
        }
        /// <p>The Amazon S3 ETag of the object. Returned by <code>GetTableObjects</code> for validation and used to identify changes to the underlying data.</p>
        pub fn set_e_tag(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.e_tag = input;
            self
        }
        /// Appends an item to `partition_values`.
        ///
        /// To override the contents of this collection use [`set_partition_values`](Self::set_partition_values).
        ///
        /// <p>A list of partition values for the object. A value must be specified for each partition key associated with the governed table.</p>
        pub fn partition_values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.partition_values.unwrap_or_default();
            v.push(input.into());
            self.partition_values = Some(v);
            self
        }
        /// <p>A list of partition values for the object. A value must be specified for each partition key associated with the governed table.</p>
        pub fn set_partition_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.partition_values = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteObjectInput`](crate::model::DeleteObjectInput).
        pub fn build(self) -> crate::model::DeleteObjectInput {
            crate::model::DeleteObjectInput {
                uri: self.uri,
                e_tag: self.e_tag,
                partition_values: self.partition_values,
            }
        }
    }
}

/// <p>A new object to add to the governed table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AddObjectInput {
    /// <p>The Amazon S3 location of the object.</p>
    #[doc(hidden)]
    pub uri: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 ETag of the object. Returned by <code>GetTableObjects</code> for validation and used to identify changes to the underlying data.</p>
    #[doc(hidden)]
    pub e_tag: std::option::Option<std::string::String>,
    /// <p>The size of the Amazon S3 object in bytes.</p>
    #[doc(hidden)]
    pub size: i64,
    /// <p>A list of partition values for the object. A value must be specified for each partition key associated with the table.</p>
    /// <p>The supported data types are integer, long, date(yyyy-MM-dd), timestamp(yyyy-MM-dd HH:mm:ssXXX or yyyy-MM-dd HH:mm:ss"), string and decimal.</p>
    #[doc(hidden)]
    pub partition_values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl AddObjectInput {
    /// <p>The Amazon S3 location of the object.</p>
    pub fn uri(&self) -> std::option::Option<&str> {
        self.uri.as_deref()
    }
    /// <p>The Amazon S3 ETag of the object. Returned by <code>GetTableObjects</code> for validation and used to identify changes to the underlying data.</p>
    pub fn e_tag(&self) -> std::option::Option<&str> {
        self.e_tag.as_deref()
    }
    /// <p>The size of the Amazon S3 object in bytes.</p>
    pub fn size(&self) -> i64 {
        self.size
    }
    /// <p>A list of partition values for the object. A value must be specified for each partition key associated with the table.</p>
    /// <p>The supported data types are integer, long, date(yyyy-MM-dd), timestamp(yyyy-MM-dd HH:mm:ssXXX or yyyy-MM-dd HH:mm:ss"), string and decimal.</p>
    pub fn partition_values(&self) -> std::option::Option<&[std::string::String]> {
        self.partition_values.as_deref()
    }
}
impl AddObjectInput {
    /// Creates a new builder-style object to manufacture [`AddObjectInput`](crate::model::AddObjectInput).
    pub fn builder() -> crate::model::add_object_input::Builder {
        crate::model::add_object_input::Builder::default()
    }
}

/// See [`AddObjectInput`](crate::model::AddObjectInput).
pub mod add_object_input {

    /// A builder for [`AddObjectInput`](crate::model::AddObjectInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) uri: std::option::Option<std::string::String>,
        pub(crate) e_tag: std::option::Option<std::string::String>,
        pub(crate) size: std::option::Option<i64>,
        pub(crate) partition_values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The Amazon S3 location of the object.</p>
        pub fn uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.uri = Some(input.into());
            self
        }
        /// <p>The Amazon S3 location of the object.</p>
        pub fn set_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.uri = input;
            self
        }
        /// <p>The Amazon S3 ETag of the object. Returned by <code>GetTableObjects</code> for validation and used to identify changes to the underlying data.</p>
        pub fn e_tag(mut self, input: impl Into<std::string::String>) -> Self {
            self.e_tag = Some(input.into());
            self
        }
        /// <p>The Amazon S3 ETag of the object. Returned by <code>GetTableObjects</code> for validation and used to identify changes to the underlying data.</p>
        pub fn set_e_tag(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.e_tag = input;
            self
        }
        /// <p>The size of the Amazon S3 object in bytes.</p>
        pub fn size(mut self, input: i64) -> Self {
            self.size = Some(input);
            self
        }
        /// <p>The size of the Amazon S3 object in bytes.</p>
        pub fn set_size(mut self, input: std::option::Option<i64>) -> Self {
            self.size = input;
            self
        }
        /// Appends an item to `partition_values`.
        ///
        /// To override the contents of this collection use [`set_partition_values`](Self::set_partition_values).
        ///
        /// <p>A list of partition values for the object. A value must be specified for each partition key associated with the table.</p>
        /// <p>The supported data types are integer, long, date(yyyy-MM-dd), timestamp(yyyy-MM-dd HH:mm:ssXXX or yyyy-MM-dd HH:mm:ss"), string and decimal.</p>
        pub fn partition_values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.partition_values.unwrap_or_default();
            v.push(input.into());
            self.partition_values = Some(v);
            self
        }
        /// <p>A list of partition values for the object. A value must be specified for each partition key associated with the table.</p>
        /// <p>The supported data types are integer, long, date(yyyy-MM-dd), timestamp(yyyy-MM-dd HH:mm:ssXXX or yyyy-MM-dd HH:mm:ss"), string and decimal.</p>
        pub fn set_partition_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.partition_values = input;
            self
        }
        /// Consumes the builder and constructs a [`AddObjectInput`](crate::model::AddObjectInput).
        pub fn build(self) -> crate::model::AddObjectInput {
            crate::model::AddObjectInput {
                uri: self.uri,
                e_tag: self.e_tag,
                size: self.size.unwrap_or_default(),
                partition_values: self.partition_values,
            }
        }
    }
}

/// When writing a match expression against `TransactionType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let transactiontype = unimplemented!();
/// match transactiontype {
///     TransactionType::ReadAndWrite => { /* ... */ },
///     TransactionType::ReadOnly => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `transactiontype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TransactionType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TransactionType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TransactionType::NewFeature` is defined.
/// Specifically, when `transactiontype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TransactionType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TransactionType {
    #[allow(missing_docs)] // documentation missing in model
    ReadAndWrite,
    #[allow(missing_docs)] // documentation missing in model
    ReadOnly,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TransactionType {
    fn from(s: &str) -> Self {
        match s {
            "READ_AND_WRITE" => TransactionType::ReadAndWrite,
            "READ_ONLY" => TransactionType::ReadOnly,
            other => TransactionType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for TransactionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TransactionType::from(s))
    }
}
impl TransactionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TransactionType::ReadAndWrite => "READ_AND_WRITE",
            TransactionType::ReadOnly => "READ_ONLY",
            TransactionType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["READ_AND_WRITE", "READ_ONLY"]
    }
}
impl AsRef<str> for TransactionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A structure containing information about the query plan.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct QueryPlanningContext {
    /// <p>The ID of the Data Catalog where the partition in question resides. If none is provided, the Amazon Web Services account ID is used by default.</p>
    #[doc(hidden)]
    pub catalog_id: std::option::Option<std::string::String>,
    /// <p>The database containing the table.</p>
    #[doc(hidden)]
    pub database_name: std::option::Option<std::string::String>,
    /// <p>The time as of when to read the table contents. If not set, the most recent transaction commit time will be used. Cannot be specified along with <code>TransactionId</code>.</p>
    #[doc(hidden)]
    pub query_as_of_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A map consisting of key-value pairs.</p>
    #[doc(hidden)]
    pub query_parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The transaction ID at which to read the table contents. If this transaction is not committed, the read will be treated as part of that transaction and will see its writes. If this transaction has aborted, an error will be returned. If not set, defaults to the most recent committed transaction. Cannot be specified along with <code>QueryAsOfTime</code>.</p>
    #[doc(hidden)]
    pub transaction_id: std::option::Option<std::string::String>,
}
impl QueryPlanningContext {
    /// <p>The ID of the Data Catalog where the partition in question resides. If none is provided, the Amazon Web Services account ID is used by default.</p>
    pub fn catalog_id(&self) -> std::option::Option<&str> {
        self.catalog_id.as_deref()
    }
    /// <p>The database containing the table.</p>
    pub fn database_name(&self) -> std::option::Option<&str> {
        self.database_name.as_deref()
    }
    /// <p>The time as of when to read the table contents. If not set, the most recent transaction commit time will be used. Cannot be specified along with <code>TransactionId</code>.</p>
    pub fn query_as_of_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.query_as_of_time.as_ref()
    }
    /// <p>A map consisting of key-value pairs.</p>
    pub fn query_parameters(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.query_parameters.as_ref()
    }
    /// <p>The transaction ID at which to read the table contents. If this transaction is not committed, the read will be treated as part of that transaction and will see its writes. If this transaction has aborted, an error will be returned. If not set, defaults to the most recent committed transaction. Cannot be specified along with <code>QueryAsOfTime</code>.</p>
    pub fn transaction_id(&self) -> std::option::Option<&str> {
        self.transaction_id.as_deref()
    }
}
impl QueryPlanningContext {
    /// Creates a new builder-style object to manufacture [`QueryPlanningContext`](crate::model::QueryPlanningContext).
    pub fn builder() -> crate::model::query_planning_context::Builder {
        crate::model::query_planning_context::Builder::default()
    }
}

/// See [`QueryPlanningContext`](crate::model::QueryPlanningContext).
pub mod query_planning_context {

    /// A builder for [`QueryPlanningContext`](crate::model::QueryPlanningContext).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) catalog_id: std::option::Option<std::string::String>,
        pub(crate) database_name: std::option::Option<std::string::String>,
        pub(crate) query_as_of_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) query_parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) transaction_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the Data Catalog where the partition in question resides. If none is provided, the Amazon Web Services account ID is used by default.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.catalog_id = Some(input.into());
            self
        }
        /// <p>The ID of the Data Catalog where the partition in question resides. If none is provided, the Amazon Web Services account ID is used by default.</p>
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.catalog_id = input;
            self
        }
        /// <p>The database containing the table.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.database_name = Some(input.into());
            self
        }
        /// <p>The database containing the table.</p>
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.database_name = input;
            self
        }
        /// <p>The time as of when to read the table contents. If not set, the most recent transaction commit time will be used. Cannot be specified along with <code>TransactionId</code>.</p>
        pub fn query_as_of_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.query_as_of_time = Some(input);
            self
        }
        /// <p>The time as of when to read the table contents. If not set, the most recent transaction commit time will be used. Cannot be specified along with <code>TransactionId</code>.</p>
        pub fn set_query_as_of_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.query_as_of_time = input;
            self
        }
        /// Adds a key-value pair to `query_parameters`.
        ///
        /// To override the contents of this collection use [`set_query_parameters`](Self::set_query_parameters).
        ///
        /// <p>A map consisting of key-value pairs.</p>
        pub fn query_parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.query_parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.query_parameters = Some(hash_map);
            self
        }
        /// <p>A map consisting of key-value pairs.</p>
        pub fn set_query_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.query_parameters = input;
            self
        }
        /// <p>The transaction ID at which to read the table contents. If this transaction is not committed, the read will be treated as part of that transaction and will see its writes. If this transaction has aborted, an error will be returned. If not set, defaults to the most recent committed transaction. Cannot be specified along with <code>QueryAsOfTime</code>.</p>
        pub fn transaction_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.transaction_id = Some(input.into());
            self
        }
        /// <p>The transaction ID at which to read the table contents. If this transaction is not committed, the read will be treated as part of that transaction and will see its writes. If this transaction has aborted, an error will be returned. If not set, defaults to the most recent committed transaction. Cannot be specified along with <code>QueryAsOfTime</code>.</p>
        pub fn set_transaction_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transaction_id = input;
            self
        }
        /// Consumes the builder and constructs a [`QueryPlanningContext`](crate::model::QueryPlanningContext).
        pub fn build(self) -> crate::model::QueryPlanningContext {
            crate::model::QueryPlanningContext {
                catalog_id: self.catalog_id,
                database_name: self.database_name,
                query_as_of_time: self.query_as_of_time,
                query_parameters: self.query_parameters,
                transaction_id: self.transaction_id,
            }
        }
    }
}

/// <p>A structure describing a table resource with LF-tags.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TaggedTable {
    /// <p>A table that has LF-tags attached to it.</p>
    #[doc(hidden)]
    pub table: std::option::Option<crate::model::TableResource>,
    /// <p>A list of LF-tags attached to the database where the table resides.</p>
    #[doc(hidden)]
    pub lf_tag_on_database: std::option::Option<std::vec::Vec<crate::model::LfTagPair>>,
    /// <p>A list of LF-tags attached to the table.</p>
    #[doc(hidden)]
    pub lf_tags_on_table: std::option::Option<std::vec::Vec<crate::model::LfTagPair>>,
    /// <p>A list of LF-tags attached to columns in the table.</p>
    #[doc(hidden)]
    pub lf_tags_on_columns: std::option::Option<std::vec::Vec<crate::model::ColumnLfTag>>,
}
impl TaggedTable {
    /// <p>A table that has LF-tags attached to it.</p>
    pub fn table(&self) -> std::option::Option<&crate::model::TableResource> {
        self.table.as_ref()
    }
    /// <p>A list of LF-tags attached to the database where the table resides.</p>
    pub fn lf_tag_on_database(&self) -> std::option::Option<&[crate::model::LfTagPair]> {
        self.lf_tag_on_database.as_deref()
    }
    /// <p>A list of LF-tags attached to the table.</p>
    pub fn lf_tags_on_table(&self) -> std::option::Option<&[crate::model::LfTagPair]> {
        self.lf_tags_on_table.as_deref()
    }
    /// <p>A list of LF-tags attached to columns in the table.</p>
    pub fn lf_tags_on_columns(&self) -> std::option::Option<&[crate::model::ColumnLfTag]> {
        self.lf_tags_on_columns.as_deref()
    }
}
impl TaggedTable {
    /// Creates a new builder-style object to manufacture [`TaggedTable`](crate::model::TaggedTable).
    pub fn builder() -> crate::model::tagged_table::Builder {
        crate::model::tagged_table::Builder::default()
    }
}

/// See [`TaggedTable`](crate::model::TaggedTable).
pub mod tagged_table {

    /// A builder for [`TaggedTable`](crate::model::TaggedTable).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) table: std::option::Option<crate::model::TableResource>,
        pub(crate) lf_tag_on_database: std::option::Option<std::vec::Vec<crate::model::LfTagPair>>,
        pub(crate) lf_tags_on_table: std::option::Option<std::vec::Vec<crate::model::LfTagPair>>,
        pub(crate) lf_tags_on_columns:
            std::option::Option<std::vec::Vec<crate::model::ColumnLfTag>>,
    }
    impl Builder {
        /// <p>A table that has LF-tags attached to it.</p>
        pub fn table(mut self, input: crate::model::TableResource) -> Self {
            self.table = Some(input);
            self
        }
        /// <p>A table that has LF-tags attached to it.</p>
        pub fn set_table(
            mut self,
            input: std::option::Option<crate::model::TableResource>,
        ) -> Self {
            self.table = input;
            self
        }
        /// Appends an item to `lf_tag_on_database`.
        ///
        /// To override the contents of this collection use [`set_lf_tag_on_database`](Self::set_lf_tag_on_database).
        ///
        /// <p>A list of LF-tags attached to the database where the table resides.</p>
        pub fn lf_tag_on_database(mut self, input: crate::model::LfTagPair) -> Self {
            let mut v = self.lf_tag_on_database.unwrap_or_default();
            v.push(input);
            self.lf_tag_on_database = Some(v);
            self
        }
        /// <p>A list of LF-tags attached to the database where the table resides.</p>
        pub fn set_lf_tag_on_database(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LfTagPair>>,
        ) -> Self {
            self.lf_tag_on_database = input;
            self
        }
        /// Appends an item to `lf_tags_on_table`.
        ///
        /// To override the contents of this collection use [`set_lf_tags_on_table`](Self::set_lf_tags_on_table).
        ///
        /// <p>A list of LF-tags attached to the table.</p>
        pub fn lf_tags_on_table(mut self, input: crate::model::LfTagPair) -> Self {
            let mut v = self.lf_tags_on_table.unwrap_or_default();
            v.push(input);
            self.lf_tags_on_table = Some(v);
            self
        }
        /// <p>A list of LF-tags attached to the table.</p>
        pub fn set_lf_tags_on_table(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LfTagPair>>,
        ) -> Self {
            self.lf_tags_on_table = input;
            self
        }
        /// Appends an item to `lf_tags_on_columns`.
        ///
        /// To override the contents of this collection use [`set_lf_tags_on_columns`](Self::set_lf_tags_on_columns).
        ///
        /// <p>A list of LF-tags attached to columns in the table.</p>
        pub fn lf_tags_on_columns(mut self, input: crate::model::ColumnLfTag) -> Self {
            let mut v = self.lf_tags_on_columns.unwrap_or_default();
            v.push(input);
            self.lf_tags_on_columns = Some(v);
            self
        }
        /// <p>A list of LF-tags attached to columns in the table.</p>
        pub fn set_lf_tags_on_columns(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ColumnLfTag>>,
        ) -> Self {
            self.lf_tags_on_columns = input;
            self
        }
        /// Consumes the builder and constructs a [`TaggedTable`](crate::model::TaggedTable).
        pub fn build(self) -> crate::model::TaggedTable {
            crate::model::TaggedTable {
                table: self.table,
                lf_tag_on_database: self.lf_tag_on_database,
                lf_tags_on_table: self.lf_tags_on_table,
                lf_tags_on_columns: self.lf_tags_on_columns,
            }
        }
    }
}

/// <p>A structure containing the name of a column resource and the LF-tags attached to it.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ColumnLfTag {
    /// <p>The name of a column resource.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The LF-tags attached to a column resource.</p>
    #[doc(hidden)]
    pub lf_tags: std::option::Option<std::vec::Vec<crate::model::LfTagPair>>,
}
impl ColumnLfTag {
    /// <p>The name of a column resource.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The LF-tags attached to a column resource.</p>
    pub fn lf_tags(&self) -> std::option::Option<&[crate::model::LfTagPair]> {
        self.lf_tags.as_deref()
    }
}
impl ColumnLfTag {
    /// Creates a new builder-style object to manufacture [`ColumnLfTag`](crate::model::ColumnLfTag).
    pub fn builder() -> crate::model::column_lf_tag::Builder {
        crate::model::column_lf_tag::Builder::default()
    }
}

/// See [`ColumnLfTag`](crate::model::ColumnLfTag).
pub mod column_lf_tag {

    /// A builder for [`ColumnLfTag`](crate::model::ColumnLfTag).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) lf_tags: std::option::Option<std::vec::Vec<crate::model::LfTagPair>>,
    }
    impl Builder {
        /// <p>The name of a column resource.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of a column resource.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `lf_tags`.
        ///
        /// To override the contents of this collection use [`set_lf_tags`](Self::set_lf_tags).
        ///
        /// <p>The LF-tags attached to a column resource.</p>
        pub fn lf_tags(mut self, input: crate::model::LfTagPair) -> Self {
            let mut v = self.lf_tags.unwrap_or_default();
            v.push(input);
            self.lf_tags = Some(v);
            self
        }
        /// <p>The LF-tags attached to a column resource.</p>
        pub fn set_lf_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LfTagPair>>,
        ) -> Self {
            self.lf_tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ColumnLfTag`](crate::model::ColumnLfTag).
        pub fn build(self) -> crate::model::ColumnLfTag {
            crate::model::ColumnLfTag {
                name: self.name,
                lf_tags: self.lf_tags,
            }
        }
    }
}

/// <p>A structure containing an LF-tag key-value pair.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LfTagPair {
    /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. </p>
    #[doc(hidden)]
    pub catalog_id: std::option::Option<std::string::String>,
    /// <p>The key-name for the LF-tag.</p>
    #[doc(hidden)]
    pub tag_key: std::option::Option<std::string::String>,
    /// <p>A list of possible values an attribute can take.</p>
    #[doc(hidden)]
    pub tag_values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl LfTagPair {
    /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. </p>
    pub fn catalog_id(&self) -> std::option::Option<&str> {
        self.catalog_id.as_deref()
    }
    /// <p>The key-name for the LF-tag.</p>
    pub fn tag_key(&self) -> std::option::Option<&str> {
        self.tag_key.as_deref()
    }
    /// <p>A list of possible values an attribute can take.</p>
    pub fn tag_values(&self) -> std::option::Option<&[std::string::String]> {
        self.tag_values.as_deref()
    }
}
impl LfTagPair {
    /// Creates a new builder-style object to manufacture [`LfTagPair`](crate::model::LfTagPair).
    pub fn builder() -> crate::model::lf_tag_pair::Builder {
        crate::model::lf_tag_pair::Builder::default()
    }
}

/// See [`LfTagPair`](crate::model::LfTagPair).
pub mod lf_tag_pair {

    /// A builder for [`LfTagPair`](crate::model::LfTagPair).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) catalog_id: std::option::Option<std::string::String>,
        pub(crate) tag_key: std::option::Option<std::string::String>,
        pub(crate) tag_values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. </p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.catalog_id = Some(input.into());
            self
        }
        /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. </p>
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.catalog_id = input;
            self
        }
        /// <p>The key-name for the LF-tag.</p>
        pub fn tag_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.tag_key = Some(input.into());
            self
        }
        /// <p>The key-name for the LF-tag.</p>
        pub fn set_tag_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.tag_key = input;
            self
        }
        /// Appends an item to `tag_values`.
        ///
        /// To override the contents of this collection use [`set_tag_values`](Self::set_tag_values).
        ///
        /// <p>A list of possible values an attribute can take.</p>
        pub fn tag_values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_values.unwrap_or_default();
            v.push(input.into());
            self.tag_values = Some(v);
            self
        }
        /// <p>A list of possible values an attribute can take.</p>
        pub fn set_tag_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_values = input;
            self
        }
        /// Consumes the builder and constructs a [`LfTagPair`](crate::model::LfTagPair).
        pub fn build(self) -> crate::model::LfTagPair {
            crate::model::LfTagPair {
                catalog_id: self.catalog_id,
                tag_key: self.tag_key,
                tag_values: self.tag_values,
            }
        }
    }
}

/// <p>A structure for the table object. A table is a metadata definition that represents your data. You can Grant and Revoke table privileges to a principal. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableResource {
    /// <p>The identifier for the Data Catalog. By default, it is the account ID of the caller.</p>
    #[doc(hidden)]
    pub catalog_id: std::option::Option<std::string::String>,
    /// <p>The name of the database for the table. Unique to a Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database privileges to a principal. </p>
    #[doc(hidden)]
    pub database_name: std::option::Option<std::string::String>,
    /// <p>The name of the table.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A wildcard object representing every table under a database.</p>
    /// <p>At least one of <code>TableResource$Name</code> or <code>TableResource$TableWildcard</code> is required.</p>
    #[doc(hidden)]
    pub table_wildcard: std::option::Option<crate::model::TableWildcard>,
}
impl TableResource {
    /// <p>The identifier for the Data Catalog. By default, it is the account ID of the caller.</p>
    pub fn catalog_id(&self) -> std::option::Option<&str> {
        self.catalog_id.as_deref()
    }
    /// <p>The name of the database for the table. Unique to a Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database privileges to a principal. </p>
    pub fn database_name(&self) -> std::option::Option<&str> {
        self.database_name.as_deref()
    }
    /// <p>The name of the table.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A wildcard object representing every table under a database.</p>
    /// <p>At least one of <code>TableResource$Name</code> or <code>TableResource$TableWildcard</code> is required.</p>
    pub fn table_wildcard(&self) -> std::option::Option<&crate::model::TableWildcard> {
        self.table_wildcard.as_ref()
    }
}
impl TableResource {
    /// Creates a new builder-style object to manufacture [`TableResource`](crate::model::TableResource).
    pub fn builder() -> crate::model::table_resource::Builder {
        crate::model::table_resource::Builder::default()
    }
}

/// See [`TableResource`](crate::model::TableResource).
pub mod table_resource {

    /// A builder for [`TableResource`](crate::model::TableResource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) catalog_id: std::option::Option<std::string::String>,
        pub(crate) database_name: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) table_wildcard: std::option::Option<crate::model::TableWildcard>,
    }
    impl Builder {
        /// <p>The identifier for the Data Catalog. By default, it is the account ID of the caller.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.catalog_id = Some(input.into());
            self
        }
        /// <p>The identifier for the Data Catalog. By default, it is the account ID of the caller.</p>
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.catalog_id = input;
            self
        }
        /// <p>The name of the database for the table. Unique to a Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database privileges to a principal. </p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.database_name = Some(input.into());
            self
        }
        /// <p>The name of the database for the table. Unique to a Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database privileges to a principal. </p>
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.database_name = input;
            self
        }
        /// <p>The name of the table.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the table.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A wildcard object representing every table under a database.</p>
        /// <p>At least one of <code>TableResource$Name</code> or <code>TableResource$TableWildcard</code> is required.</p>
        pub fn table_wildcard(mut self, input: crate::model::TableWildcard) -> Self {
            self.table_wildcard = Some(input);
            self
        }
        /// <p>A wildcard object representing every table under a database.</p>
        /// <p>At least one of <code>TableResource$Name</code> or <code>TableResource$TableWildcard</code> is required.</p>
        pub fn set_table_wildcard(
            mut self,
            input: std::option::Option<crate::model::TableWildcard>,
        ) -> Self {
            self.table_wildcard = input;
            self
        }
        /// Consumes the builder and constructs a [`TableResource`](crate::model::TableResource).
        pub fn build(self) -> crate::model::TableResource {
            crate::model::TableResource {
                catalog_id: self.catalog_id,
                database_name: self.database_name,
                name: self.name,
                table_wildcard: self.table_wildcard,
            }
        }
    }
}

/// <p>A wildcard object representing every table under a database.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableWildcard {}
impl TableWildcard {
    /// Creates a new builder-style object to manufacture [`TableWildcard`](crate::model::TableWildcard).
    pub fn builder() -> crate::model::table_wildcard::Builder {
        crate::model::table_wildcard::Builder::default()
    }
}

/// See [`TableWildcard`](crate::model::TableWildcard).
pub mod table_wildcard {

    /// A builder for [`TableWildcard`](crate::model::TableWildcard).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`TableWildcard`](crate::model::TableWildcard).
        pub fn build(self) -> crate::model::TableWildcard {
            crate::model::TableWildcard {}
        }
    }
}

/// <p>A structure that allows an admin to grant user permissions on certain conditions. For example, granting a role access to all columns that do not have the LF-tag 'PII' in tables that have the LF-tag 'Prod'.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LfTag {
    /// <p>The key-name for the LF-tag.</p>
    #[doc(hidden)]
    pub tag_key: std::option::Option<std::string::String>,
    /// <p>A list of possible values an attribute can take.</p>
    #[doc(hidden)]
    pub tag_values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl LfTag {
    /// <p>The key-name for the LF-tag.</p>
    pub fn tag_key(&self) -> std::option::Option<&str> {
        self.tag_key.as_deref()
    }
    /// <p>A list of possible values an attribute can take.</p>
    pub fn tag_values(&self) -> std::option::Option<&[std::string::String]> {
        self.tag_values.as_deref()
    }
}
impl LfTag {
    /// Creates a new builder-style object to manufacture [`LfTag`](crate::model::LfTag).
    pub fn builder() -> crate::model::lf_tag::Builder {
        crate::model::lf_tag::Builder::default()
    }
}

/// See [`LfTag`](crate::model::LfTag).
pub mod lf_tag {

    /// A builder for [`LfTag`](crate::model::LfTag).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) tag_key: std::option::Option<std::string::String>,
        pub(crate) tag_values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The key-name for the LF-tag.</p>
        pub fn tag_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.tag_key = Some(input.into());
            self
        }
        /// <p>The key-name for the LF-tag.</p>
        pub fn set_tag_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.tag_key = input;
            self
        }
        /// Appends an item to `tag_values`.
        ///
        /// To override the contents of this collection use [`set_tag_values`](Self::set_tag_values).
        ///
        /// <p>A list of possible values an attribute can take.</p>
        pub fn tag_values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_values.unwrap_or_default();
            v.push(input.into());
            self.tag_values = Some(v);
            self
        }
        /// <p>A list of possible values an attribute can take.</p>
        pub fn set_tag_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_values = input;
            self
        }
        /// Consumes the builder and constructs a [`LfTag`](crate::model::LfTag).
        pub fn build(self) -> crate::model::LfTag {
            crate::model::LfTag {
                tag_key: self.tag_key,
                tag_values: self.tag_values,
            }
        }
    }
}

/// <p>A structure describing a database resource with LF-tags.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TaggedDatabase {
    /// <p>A database that has LF-tags attached to it.</p>
    #[doc(hidden)]
    pub database: std::option::Option<crate::model::DatabaseResource>,
    /// <p>A list of LF-tags attached to the database.</p>
    #[doc(hidden)]
    pub lf_tags: std::option::Option<std::vec::Vec<crate::model::LfTagPair>>,
}
impl TaggedDatabase {
    /// <p>A database that has LF-tags attached to it.</p>
    pub fn database(&self) -> std::option::Option<&crate::model::DatabaseResource> {
        self.database.as_ref()
    }
    /// <p>A list of LF-tags attached to the database.</p>
    pub fn lf_tags(&self) -> std::option::Option<&[crate::model::LfTagPair]> {
        self.lf_tags.as_deref()
    }
}
impl TaggedDatabase {
    /// Creates a new builder-style object to manufacture [`TaggedDatabase`](crate::model::TaggedDatabase).
    pub fn builder() -> crate::model::tagged_database::Builder {
        crate::model::tagged_database::Builder::default()
    }
}

/// See [`TaggedDatabase`](crate::model::TaggedDatabase).
pub mod tagged_database {

    /// A builder for [`TaggedDatabase`](crate::model::TaggedDatabase).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) database: std::option::Option<crate::model::DatabaseResource>,
        pub(crate) lf_tags: std::option::Option<std::vec::Vec<crate::model::LfTagPair>>,
    }
    impl Builder {
        /// <p>A database that has LF-tags attached to it.</p>
        pub fn database(mut self, input: crate::model::DatabaseResource) -> Self {
            self.database = Some(input);
            self
        }
        /// <p>A database that has LF-tags attached to it.</p>
        pub fn set_database(
            mut self,
            input: std::option::Option<crate::model::DatabaseResource>,
        ) -> Self {
            self.database = input;
            self
        }
        /// Appends an item to `lf_tags`.
        ///
        /// To override the contents of this collection use [`set_lf_tags`](Self::set_lf_tags).
        ///
        /// <p>A list of LF-tags attached to the database.</p>
        pub fn lf_tags(mut self, input: crate::model::LfTagPair) -> Self {
            let mut v = self.lf_tags.unwrap_or_default();
            v.push(input);
            self.lf_tags = Some(v);
            self
        }
        /// <p>A list of LF-tags attached to the database.</p>
        pub fn set_lf_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LfTagPair>>,
        ) -> Self {
            self.lf_tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TaggedDatabase`](crate::model::TaggedDatabase).
        pub fn build(self) -> crate::model::TaggedDatabase {
            crate::model::TaggedDatabase {
                database: self.database,
                lf_tags: self.lf_tags,
            }
        }
    }
}

/// <p>A structure for the database object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DatabaseResource {
    /// <p>The identifier for the Data Catalog. By default, it is the account ID of the caller.</p>
    #[doc(hidden)]
    pub catalog_id: std::option::Option<std::string::String>,
    /// <p>The name of the database resource. Unique to the Data Catalog.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl DatabaseResource {
    /// <p>The identifier for the Data Catalog. By default, it is the account ID of the caller.</p>
    pub fn catalog_id(&self) -> std::option::Option<&str> {
        self.catalog_id.as_deref()
    }
    /// <p>The name of the database resource. Unique to the Data Catalog.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl DatabaseResource {
    /// Creates a new builder-style object to manufacture [`DatabaseResource`](crate::model::DatabaseResource).
    pub fn builder() -> crate::model::database_resource::Builder {
        crate::model::database_resource::Builder::default()
    }
}

/// See [`DatabaseResource`](crate::model::DatabaseResource).
pub mod database_resource {

    /// A builder for [`DatabaseResource`](crate::model::DatabaseResource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) catalog_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the Data Catalog. By default, it is the account ID of the caller.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.catalog_id = Some(input.into());
            self
        }
        /// <p>The identifier for the Data Catalog. By default, it is the account ID of the caller.</p>
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.catalog_id = input;
            self
        }
        /// <p>The name of the database resource. Unique to the Data Catalog.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the database resource. Unique to the Data Catalog.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`DatabaseResource`](crate::model::DatabaseResource).
        pub fn build(self) -> crate::model::DatabaseResource {
            crate::model::DatabaseResource {
                catalog_id: self.catalog_id,
                name: self.name,
            }
        }
    }
}

/// When writing a match expression against `Permission`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let permission = unimplemented!();
/// match permission {
///     Permission::All => { /* ... */ },
///     Permission::Alter => { /* ... */ },
///     Permission::Associate => { /* ... */ },
///     Permission::CreateDatabase => { /* ... */ },
///     Permission::CreateTable => { /* ... */ },
///     Permission::CreateTag => { /* ... */ },
///     Permission::DataLocationAccess => { /* ... */ },
///     Permission::Delete => { /* ... */ },
///     Permission::Describe => { /* ... */ },
///     Permission::Drop => { /* ... */ },
///     Permission::Insert => { /* ... */ },
///     Permission::Select => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `permission` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Permission::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Permission::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Permission::NewFeature` is defined.
/// Specifically, when `permission` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Permission::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Permission {
    #[allow(missing_docs)] // documentation missing in model
    All,
    #[allow(missing_docs)] // documentation missing in model
    Alter,
    #[allow(missing_docs)] // documentation missing in model
    Associate,
    #[allow(missing_docs)] // documentation missing in model
    CreateDatabase,
    #[allow(missing_docs)] // documentation missing in model
    CreateTable,
    #[allow(missing_docs)] // documentation missing in model
    CreateTag,
    #[allow(missing_docs)] // documentation missing in model
    DataLocationAccess,
    #[allow(missing_docs)] // documentation missing in model
    Delete,
    #[allow(missing_docs)] // documentation missing in model
    Describe,
    #[allow(missing_docs)] // documentation missing in model
    Drop,
    #[allow(missing_docs)] // documentation missing in model
    Insert,
    #[allow(missing_docs)] // documentation missing in model
    Select,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Permission {
    fn from(s: &str) -> Self {
        match s {
            "ALL" => Permission::All,
            "ALTER" => Permission::Alter,
            "ASSOCIATE" => Permission::Associate,
            "CREATE_DATABASE" => Permission::CreateDatabase,
            "CREATE_TABLE" => Permission::CreateTable,
            "CREATE_TAG" => Permission::CreateTag,
            "DATA_LOCATION_ACCESS" => Permission::DataLocationAccess,
            "DELETE" => Permission::Delete,
            "DESCRIBE" => Permission::Describe,
            "DROP" => Permission::Drop,
            "INSERT" => Permission::Insert,
            "SELECT" => Permission::Select,
            other => Permission::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Permission {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Permission::from(s))
    }
}
impl Permission {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Permission::All => "ALL",
            Permission::Alter => "ALTER",
            Permission::Associate => "ASSOCIATE",
            Permission::CreateDatabase => "CREATE_DATABASE",
            Permission::CreateTable => "CREATE_TABLE",
            Permission::CreateTag => "CREATE_TAG",
            Permission::DataLocationAccess => "DATA_LOCATION_ACCESS",
            Permission::Delete => "DELETE",
            Permission::Describe => "DESCRIBE",
            Permission::Drop => "DROP",
            Permission::Insert => "INSERT",
            Permission::Select => "SELECT",
            Permission::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ALL",
            "ALTER",
            "ASSOCIATE",
            "CREATE_DATABASE",
            "CREATE_TABLE",
            "CREATE_TAG",
            "DATA_LOCATION_ACCESS",
            "DELETE",
            "DESCRIBE",
            "DROP",
            "INSERT",
            "SELECT",
        ]
    }
}
impl AsRef<str> for Permission {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A structure for the resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Resource {
    /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. </p>
    #[doc(hidden)]
    pub catalog: std::option::Option<crate::model::CatalogResource>,
    /// <p>The database for the resource. Unique to the Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database permissions to a principal. </p>
    #[doc(hidden)]
    pub database: std::option::Option<crate::model::DatabaseResource>,
    /// <p>The table for the resource. A table is a metadata definition that represents your data. You can Grant and Revoke table privileges to a principal. </p>
    #[doc(hidden)]
    pub table: std::option::Option<crate::model::TableResource>,
    /// <p>The table with columns for the resource. A principal with permissions to this resource can select metadata from the columns of a table in the Data Catalog and the underlying data in Amazon S3.</p>
    #[doc(hidden)]
    pub table_with_columns: std::option::Option<crate::model::TableWithColumnsResource>,
    /// <p>The location of an Amazon S3 path where permissions are granted or revoked. </p>
    #[doc(hidden)]
    pub data_location: std::option::Option<crate::model::DataLocationResource>,
    /// <p>A data cell filter.</p>
    #[doc(hidden)]
    pub data_cells_filter: std::option::Option<crate::model::DataCellsFilterResource>,
    /// <p>The LF-tag key and values attached to a resource.</p>
    #[doc(hidden)]
    pub lf_tag: std::option::Option<crate::model::LfTagKeyResource>,
    /// <p>A list of LF-tag conditions that define a resource's LF-tag policy.</p>
    #[doc(hidden)]
    pub lf_tag_policy: std::option::Option<crate::model::LfTagPolicyResource>,
}
impl Resource {
    /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. </p>
    pub fn catalog(&self) -> std::option::Option<&crate::model::CatalogResource> {
        self.catalog.as_ref()
    }
    /// <p>The database for the resource. Unique to the Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database permissions to a principal. </p>
    pub fn database(&self) -> std::option::Option<&crate::model::DatabaseResource> {
        self.database.as_ref()
    }
    /// <p>The table for the resource. A table is a metadata definition that represents your data. You can Grant and Revoke table privileges to a principal. </p>
    pub fn table(&self) -> std::option::Option<&crate::model::TableResource> {
        self.table.as_ref()
    }
    /// <p>The table with columns for the resource. A principal with permissions to this resource can select metadata from the columns of a table in the Data Catalog and the underlying data in Amazon S3.</p>
    pub fn table_with_columns(
        &self,
    ) -> std::option::Option<&crate::model::TableWithColumnsResource> {
        self.table_with_columns.as_ref()
    }
    /// <p>The location of an Amazon S3 path where permissions are granted or revoked. </p>
    pub fn data_location(&self) -> std::option::Option<&crate::model::DataLocationResource> {
        self.data_location.as_ref()
    }
    /// <p>A data cell filter.</p>
    pub fn data_cells_filter(&self) -> std::option::Option<&crate::model::DataCellsFilterResource> {
        self.data_cells_filter.as_ref()
    }
    /// <p>The LF-tag key and values attached to a resource.</p>
    pub fn lf_tag(&self) -> std::option::Option<&crate::model::LfTagKeyResource> {
        self.lf_tag.as_ref()
    }
    /// <p>A list of LF-tag conditions that define a resource's LF-tag policy.</p>
    pub fn lf_tag_policy(&self) -> std::option::Option<&crate::model::LfTagPolicyResource> {
        self.lf_tag_policy.as_ref()
    }
}
impl Resource {
    /// Creates a new builder-style object to manufacture [`Resource`](crate::model::Resource).
    pub fn builder() -> crate::model::resource::Builder {
        crate::model::resource::Builder::default()
    }
}

/// See [`Resource`](crate::model::Resource).
pub mod resource {

    /// A builder for [`Resource`](crate::model::Resource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) catalog: std::option::Option<crate::model::CatalogResource>,
        pub(crate) database: std::option::Option<crate::model::DatabaseResource>,
        pub(crate) table: std::option::Option<crate::model::TableResource>,
        pub(crate) table_with_columns: std::option::Option<crate::model::TableWithColumnsResource>,
        pub(crate) data_location: std::option::Option<crate::model::DataLocationResource>,
        pub(crate) data_cells_filter: std::option::Option<crate::model::DataCellsFilterResource>,
        pub(crate) lf_tag: std::option::Option<crate::model::LfTagKeyResource>,
        pub(crate) lf_tag_policy: std::option::Option<crate::model::LfTagPolicyResource>,
    }
    impl Builder {
        /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. </p>
        pub fn catalog(mut self, input: crate::model::CatalogResource) -> Self {
            self.catalog = Some(input);
            self
        }
        /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. </p>
        pub fn set_catalog(
            mut self,
            input: std::option::Option<crate::model::CatalogResource>,
        ) -> Self {
            self.catalog = input;
            self
        }
        /// <p>The database for the resource. Unique to the Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database permissions to a principal. </p>
        pub fn database(mut self, input: crate::model::DatabaseResource) -> Self {
            self.database = Some(input);
            self
        }
        /// <p>The database for the resource. Unique to the Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database permissions to a principal. </p>
        pub fn set_database(
            mut self,
            input: std::option::Option<crate::model::DatabaseResource>,
        ) -> Self {
            self.database = input;
            self
        }
        /// <p>The table for the resource. A table is a metadata definition that represents your data. You can Grant and Revoke table privileges to a principal. </p>
        pub fn table(mut self, input: crate::model::TableResource) -> Self {
            self.table = Some(input);
            self
        }
        /// <p>The table for the resource. A table is a metadata definition that represents your data. You can Grant and Revoke table privileges to a principal. </p>
        pub fn set_table(
            mut self,
            input: std::option::Option<crate::model::TableResource>,
        ) -> Self {
            self.table = input;
            self
        }
        /// <p>The table with columns for the resource. A principal with permissions to this resource can select metadata from the columns of a table in the Data Catalog and the underlying data in Amazon S3.</p>
        pub fn table_with_columns(mut self, input: crate::model::TableWithColumnsResource) -> Self {
            self.table_with_columns = Some(input);
            self
        }
        /// <p>The table with columns for the resource. A principal with permissions to this resource can select metadata from the columns of a table in the Data Catalog and the underlying data in Amazon S3.</p>
        pub fn set_table_with_columns(
            mut self,
            input: std::option::Option<crate::model::TableWithColumnsResource>,
        ) -> Self {
            self.table_with_columns = input;
            self
        }
        /// <p>The location of an Amazon S3 path where permissions are granted or revoked. </p>
        pub fn data_location(mut self, input: crate::model::DataLocationResource) -> Self {
            self.data_location = Some(input);
            self
        }
        /// <p>The location of an Amazon S3 path where permissions are granted or revoked. </p>
        pub fn set_data_location(
            mut self,
            input: std::option::Option<crate::model::DataLocationResource>,
        ) -> Self {
            self.data_location = input;
            self
        }
        /// <p>A data cell filter.</p>
        pub fn data_cells_filter(mut self, input: crate::model::DataCellsFilterResource) -> Self {
            self.data_cells_filter = Some(input);
            self
        }
        /// <p>A data cell filter.</p>
        pub fn set_data_cells_filter(
            mut self,
            input: std::option::Option<crate::model::DataCellsFilterResource>,
        ) -> Self {
            self.data_cells_filter = input;
            self
        }
        /// <p>The LF-tag key and values attached to a resource.</p>
        pub fn lf_tag(mut self, input: crate::model::LfTagKeyResource) -> Self {
            self.lf_tag = Some(input);
            self
        }
        /// <p>The LF-tag key and values attached to a resource.</p>
        pub fn set_lf_tag(
            mut self,
            input: std::option::Option<crate::model::LfTagKeyResource>,
        ) -> Self {
            self.lf_tag = input;
            self
        }
        /// <p>A list of LF-tag conditions that define a resource's LF-tag policy.</p>
        pub fn lf_tag_policy(mut self, input: crate::model::LfTagPolicyResource) -> Self {
            self.lf_tag_policy = Some(input);
            self
        }
        /// <p>A list of LF-tag conditions that define a resource's LF-tag policy.</p>
        pub fn set_lf_tag_policy(
            mut self,
            input: std::option::Option<crate::model::LfTagPolicyResource>,
        ) -> Self {
            self.lf_tag_policy = input;
            self
        }
        /// Consumes the builder and constructs a [`Resource`](crate::model::Resource).
        pub fn build(self) -> crate::model::Resource {
            crate::model::Resource {
                catalog: self.catalog,
                database: self.database,
                table: self.table,
                table_with_columns: self.table_with_columns,
                data_location: self.data_location,
                data_cells_filter: self.data_cells_filter,
                lf_tag: self.lf_tag,
                lf_tag_policy: self.lf_tag_policy,
            }
        }
    }
}

/// <p>A structure containing a list of LF-tag conditions that apply to a resource's LF-tag policy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LfTagPolicyResource {
    /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. </p>
    #[doc(hidden)]
    pub catalog_id: std::option::Option<std::string::String>,
    /// <p>The resource type for which the LF-tag policy applies.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<crate::model::ResourceType>,
    /// <p>A list of LF-tag conditions that apply to the resource's LF-tag policy.</p>
    #[doc(hidden)]
    pub expression: std::option::Option<std::vec::Vec<crate::model::LfTag>>,
}
impl LfTagPolicyResource {
    /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. </p>
    pub fn catalog_id(&self) -> std::option::Option<&str> {
        self.catalog_id.as_deref()
    }
    /// <p>The resource type for which the LF-tag policy applies.</p>
    pub fn resource_type(&self) -> std::option::Option<&crate::model::ResourceType> {
        self.resource_type.as_ref()
    }
    /// <p>A list of LF-tag conditions that apply to the resource's LF-tag policy.</p>
    pub fn expression(&self) -> std::option::Option<&[crate::model::LfTag]> {
        self.expression.as_deref()
    }
}
impl LfTagPolicyResource {
    /// Creates a new builder-style object to manufacture [`LfTagPolicyResource`](crate::model::LfTagPolicyResource).
    pub fn builder() -> crate::model::lf_tag_policy_resource::Builder {
        crate::model::lf_tag_policy_resource::Builder::default()
    }
}

/// See [`LfTagPolicyResource`](crate::model::LfTagPolicyResource).
pub mod lf_tag_policy_resource {

    /// A builder for [`LfTagPolicyResource`](crate::model::LfTagPolicyResource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) catalog_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<crate::model::ResourceType>,
        pub(crate) expression: std::option::Option<std::vec::Vec<crate::model::LfTag>>,
    }
    impl Builder {
        /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. </p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.catalog_id = Some(input.into());
            self
        }
        /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. </p>
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.catalog_id = input;
            self
        }
        /// <p>The resource type for which the LF-tag policy applies.</p>
        pub fn resource_type(mut self, input: crate::model::ResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        /// <p>The resource type for which the LF-tag policy applies.</p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::ResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// Appends an item to `expression`.
        ///
        /// To override the contents of this collection use [`set_expression`](Self::set_expression).
        ///
        /// <p>A list of LF-tag conditions that apply to the resource's LF-tag policy.</p>
        pub fn expression(mut self, input: crate::model::LfTag) -> Self {
            let mut v = self.expression.unwrap_or_default();
            v.push(input);
            self.expression = Some(v);
            self
        }
        /// <p>A list of LF-tag conditions that apply to the resource's LF-tag policy.</p>
        pub fn set_expression(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LfTag>>,
        ) -> Self {
            self.expression = input;
            self
        }
        /// Consumes the builder and constructs a [`LfTagPolicyResource`](crate::model::LfTagPolicyResource).
        pub fn build(self) -> crate::model::LfTagPolicyResource {
            crate::model::LfTagPolicyResource {
                catalog_id: self.catalog_id,
                resource_type: self.resource_type,
                expression: self.expression,
            }
        }
    }
}

/// When writing a match expression against `ResourceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let resourcetype = unimplemented!();
/// match resourcetype {
///     ResourceType::Database => { /* ... */ },
///     ResourceType::Table => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `resourcetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ResourceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ResourceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ResourceType::NewFeature` is defined.
/// Specifically, when `resourcetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ResourceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceType {
    #[allow(missing_docs)] // documentation missing in model
    Database,
    #[allow(missing_docs)] // documentation missing in model
    Table,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ResourceType {
    fn from(s: &str) -> Self {
        match s {
            "DATABASE" => ResourceType::Database,
            "TABLE" => ResourceType::Table,
            other => ResourceType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ResourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResourceType::from(s))
    }
}
impl ResourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ResourceType::Database => "DATABASE",
            ResourceType::Table => "TABLE",
            ResourceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DATABASE", "TABLE"]
    }
}
impl AsRef<str> for ResourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A structure containing an LF-tag key and values for a resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LfTagKeyResource {
    /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. </p>
    #[doc(hidden)]
    pub catalog_id: std::option::Option<std::string::String>,
    /// <p>The key-name for the LF-tag.</p>
    #[doc(hidden)]
    pub tag_key: std::option::Option<std::string::String>,
    /// <p>A list of possible values an attribute can take.</p>
    #[doc(hidden)]
    pub tag_values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl LfTagKeyResource {
    /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. </p>
    pub fn catalog_id(&self) -> std::option::Option<&str> {
        self.catalog_id.as_deref()
    }
    /// <p>The key-name for the LF-tag.</p>
    pub fn tag_key(&self) -> std::option::Option<&str> {
        self.tag_key.as_deref()
    }
    /// <p>A list of possible values an attribute can take.</p>
    pub fn tag_values(&self) -> std::option::Option<&[std::string::String]> {
        self.tag_values.as_deref()
    }
}
impl LfTagKeyResource {
    /// Creates a new builder-style object to manufacture [`LfTagKeyResource`](crate::model::LfTagKeyResource).
    pub fn builder() -> crate::model::lf_tag_key_resource::Builder {
        crate::model::lf_tag_key_resource::Builder::default()
    }
}

/// See [`LfTagKeyResource`](crate::model::LfTagKeyResource).
pub mod lf_tag_key_resource {

    /// A builder for [`LfTagKeyResource`](crate::model::LfTagKeyResource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) catalog_id: std::option::Option<std::string::String>,
        pub(crate) tag_key: std::option::Option<std::string::String>,
        pub(crate) tag_values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. </p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.catalog_id = Some(input.into());
            self
        }
        /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. </p>
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.catalog_id = input;
            self
        }
        /// <p>The key-name for the LF-tag.</p>
        pub fn tag_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.tag_key = Some(input.into());
            self
        }
        /// <p>The key-name for the LF-tag.</p>
        pub fn set_tag_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.tag_key = input;
            self
        }
        /// Appends an item to `tag_values`.
        ///
        /// To override the contents of this collection use [`set_tag_values`](Self::set_tag_values).
        ///
        /// <p>A list of possible values an attribute can take.</p>
        pub fn tag_values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_values.unwrap_or_default();
            v.push(input.into());
            self.tag_values = Some(v);
            self
        }
        /// <p>A list of possible values an attribute can take.</p>
        pub fn set_tag_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_values = input;
            self
        }
        /// Consumes the builder and constructs a [`LfTagKeyResource`](crate::model::LfTagKeyResource).
        pub fn build(self) -> crate::model::LfTagKeyResource {
            crate::model::LfTagKeyResource {
                catalog_id: self.catalog_id,
                tag_key: self.tag_key,
                tag_values: self.tag_values,
            }
        }
    }
}

/// <p>A structure for a data cells filter resource. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataCellsFilterResource {
    /// <p>The ID of the catalog to which the table belongs.</p>
    #[doc(hidden)]
    pub table_catalog_id: std::option::Option<std::string::String>,
    /// <p>A database in the Glue Data Catalog.</p>
    #[doc(hidden)]
    pub database_name: std::option::Option<std::string::String>,
    /// <p>The name of the table.</p>
    #[doc(hidden)]
    pub table_name: std::option::Option<std::string::String>,
    /// <p>The name of the data cells filter. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl DataCellsFilterResource {
    /// <p>The ID of the catalog to which the table belongs.</p>
    pub fn table_catalog_id(&self) -> std::option::Option<&str> {
        self.table_catalog_id.as_deref()
    }
    /// <p>A database in the Glue Data Catalog.</p>
    pub fn database_name(&self) -> std::option::Option<&str> {
        self.database_name.as_deref()
    }
    /// <p>The name of the table.</p>
    pub fn table_name(&self) -> std::option::Option<&str> {
        self.table_name.as_deref()
    }
    /// <p>The name of the data cells filter. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl DataCellsFilterResource {
    /// Creates a new builder-style object to manufacture [`DataCellsFilterResource`](crate::model::DataCellsFilterResource).
    pub fn builder() -> crate::model::data_cells_filter_resource::Builder {
        crate::model::data_cells_filter_resource::Builder::default()
    }
}

/// See [`DataCellsFilterResource`](crate::model::DataCellsFilterResource).
pub mod data_cells_filter_resource {

    /// A builder for [`DataCellsFilterResource`](crate::model::DataCellsFilterResource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) table_catalog_id: std::option::Option<std::string::String>,
        pub(crate) database_name: std::option::Option<std::string::String>,
        pub(crate) table_name: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the catalog to which the table belongs.</p>
        pub fn table_catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.table_catalog_id = Some(input.into());
            self
        }
        /// <p>The ID of the catalog to which the table belongs.</p>
        pub fn set_table_catalog_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.table_catalog_id = input;
            self
        }
        /// <p>A database in the Glue Data Catalog.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.database_name = Some(input.into());
            self
        }
        /// <p>A database in the Glue Data Catalog.</p>
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.database_name = input;
            self
        }
        /// <p>The name of the table.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.table_name = Some(input.into());
            self
        }
        /// <p>The name of the table.</p>
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table_name = input;
            self
        }
        /// <p>The name of the data cells filter. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data cells filter. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`DataCellsFilterResource`](crate::model::DataCellsFilterResource).
        pub fn build(self) -> crate::model::DataCellsFilterResource {
            crate::model::DataCellsFilterResource {
                table_catalog_id: self.table_catalog_id,
                database_name: self.database_name,
                table_name: self.table_name,
                name: self.name,
            }
        }
    }
}

/// <p>A structure for a data location object where permissions are granted or revoked. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataLocationResource {
    /// <p>The identifier for the Data Catalog where the location is registered with Lake Formation. By default, it is the account ID of the caller.</p>
    #[doc(hidden)]
    pub catalog_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies the data location resource.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
}
impl DataLocationResource {
    /// <p>The identifier for the Data Catalog where the location is registered with Lake Formation. By default, it is the account ID of the caller.</p>
    pub fn catalog_id(&self) -> std::option::Option<&str> {
        self.catalog_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies the data location resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
}
impl DataLocationResource {
    /// Creates a new builder-style object to manufacture [`DataLocationResource`](crate::model::DataLocationResource).
    pub fn builder() -> crate::model::data_location_resource::Builder {
        crate::model::data_location_resource::Builder::default()
    }
}

/// See [`DataLocationResource`](crate::model::DataLocationResource).
pub mod data_location_resource {

    /// A builder for [`DataLocationResource`](crate::model::DataLocationResource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) catalog_id: std::option::Option<std::string::String>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the Data Catalog where the location is registered with Lake Formation. By default, it is the account ID of the caller.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.catalog_id = Some(input.into());
            self
        }
        /// <p>The identifier for the Data Catalog where the location is registered with Lake Formation. By default, it is the account ID of the caller.</p>
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.catalog_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies the data location resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies the data location resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DataLocationResource`](crate::model::DataLocationResource).
        pub fn build(self) -> crate::model::DataLocationResource {
            crate::model::DataLocationResource {
                catalog_id: self.catalog_id,
                resource_arn: self.resource_arn,
            }
        }
    }
}

/// <p>A structure for a table with columns object. This object is only used when granting a SELECT permission.</p>
/// <p>This object must take a value for at least one of <code>ColumnsNames</code>, <code>ColumnsIndexes</code>, or <code>ColumnsWildcard</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableWithColumnsResource {
    /// <p>The identifier for the Data Catalog. By default, it is the account ID of the caller.</p>
    #[doc(hidden)]
    pub catalog_id: std::option::Option<std::string::String>,
    /// <p>The name of the database for the table with columns resource. Unique to the Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database privileges to a principal. </p>
    #[doc(hidden)]
    pub database_name: std::option::Option<std::string::String>,
    /// <p>The name of the table resource. A table is a metadata definition that represents your data. You can Grant and Revoke table privileges to a principal. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The list of column names for the table. At least one of <code>ColumnNames</code> or <code>ColumnWildcard</code> is required.</p>
    #[doc(hidden)]
    pub column_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A wildcard specified by a <code>ColumnWildcard</code> object. At least one of <code>ColumnNames</code> or <code>ColumnWildcard</code> is required.</p>
    #[doc(hidden)]
    pub column_wildcard: std::option::Option<crate::model::ColumnWildcard>,
}
impl TableWithColumnsResource {
    /// <p>The identifier for the Data Catalog. By default, it is the account ID of the caller.</p>
    pub fn catalog_id(&self) -> std::option::Option<&str> {
        self.catalog_id.as_deref()
    }
    /// <p>The name of the database for the table with columns resource. Unique to the Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database privileges to a principal. </p>
    pub fn database_name(&self) -> std::option::Option<&str> {
        self.database_name.as_deref()
    }
    /// <p>The name of the table resource. A table is a metadata definition that represents your data. You can Grant and Revoke table privileges to a principal. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The list of column names for the table. At least one of <code>ColumnNames</code> or <code>ColumnWildcard</code> is required.</p>
    pub fn column_names(&self) -> std::option::Option<&[std::string::String]> {
        self.column_names.as_deref()
    }
    /// <p>A wildcard specified by a <code>ColumnWildcard</code> object. At least one of <code>ColumnNames</code> or <code>ColumnWildcard</code> is required.</p>
    pub fn column_wildcard(&self) -> std::option::Option<&crate::model::ColumnWildcard> {
        self.column_wildcard.as_ref()
    }
}
impl TableWithColumnsResource {
    /// Creates a new builder-style object to manufacture [`TableWithColumnsResource`](crate::model::TableWithColumnsResource).
    pub fn builder() -> crate::model::table_with_columns_resource::Builder {
        crate::model::table_with_columns_resource::Builder::default()
    }
}

/// See [`TableWithColumnsResource`](crate::model::TableWithColumnsResource).
pub mod table_with_columns_resource {

    /// A builder for [`TableWithColumnsResource`](crate::model::TableWithColumnsResource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) catalog_id: std::option::Option<std::string::String>,
        pub(crate) database_name: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) column_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) column_wildcard: std::option::Option<crate::model::ColumnWildcard>,
    }
    impl Builder {
        /// <p>The identifier for the Data Catalog. By default, it is the account ID of the caller.</p>
        pub fn catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.catalog_id = Some(input.into());
            self
        }
        /// <p>The identifier for the Data Catalog. By default, it is the account ID of the caller.</p>
        pub fn set_catalog_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.catalog_id = input;
            self
        }
        /// <p>The name of the database for the table with columns resource. Unique to the Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database privileges to a principal. </p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.database_name = Some(input.into());
            self
        }
        /// <p>The name of the database for the table with columns resource. Unique to the Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database privileges to a principal. </p>
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.database_name = input;
            self
        }
        /// <p>The name of the table resource. A table is a metadata definition that represents your data. You can Grant and Revoke table privileges to a principal. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the table resource. A table is a metadata definition that represents your data. You can Grant and Revoke table privileges to a principal. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `column_names`.
        ///
        /// To override the contents of this collection use [`set_column_names`](Self::set_column_names).
        ///
        /// <p>The list of column names for the table. At least one of <code>ColumnNames</code> or <code>ColumnWildcard</code> is required.</p>
        pub fn column_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.column_names.unwrap_or_default();
            v.push(input.into());
            self.column_names = Some(v);
            self
        }
        /// <p>The list of column names for the table. At least one of <code>ColumnNames</code> or <code>ColumnWildcard</code> is required.</p>
        pub fn set_column_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.column_names = input;
            self
        }
        /// <p>A wildcard specified by a <code>ColumnWildcard</code> object. At least one of <code>ColumnNames</code> or <code>ColumnWildcard</code> is required.</p>
        pub fn column_wildcard(mut self, input: crate::model::ColumnWildcard) -> Self {
            self.column_wildcard = Some(input);
            self
        }
        /// <p>A wildcard specified by a <code>ColumnWildcard</code> object. At least one of <code>ColumnNames</code> or <code>ColumnWildcard</code> is required.</p>
        pub fn set_column_wildcard(
            mut self,
            input: std::option::Option<crate::model::ColumnWildcard>,
        ) -> Self {
            self.column_wildcard = input;
            self
        }
        /// Consumes the builder and constructs a [`TableWithColumnsResource`](crate::model::TableWithColumnsResource).
        pub fn build(self) -> crate::model::TableWithColumnsResource {
            crate::model::TableWithColumnsResource {
                catalog_id: self.catalog_id,
                database_name: self.database_name,
                name: self.name,
                column_names: self.column_names,
                column_wildcard: self.column_wildcard,
            }
        }
    }
}

/// <p>A wildcard object, consisting of an optional list of excluded column names or indexes.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ColumnWildcard {
    /// <p>Excludes column names. Any column with this name will be excluded.</p>
    #[doc(hidden)]
    pub excluded_column_names: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl ColumnWildcard {
    /// <p>Excludes column names. Any column with this name will be excluded.</p>
    pub fn excluded_column_names(&self) -> std::option::Option<&[std::string::String]> {
        self.excluded_column_names.as_deref()
    }
}
impl ColumnWildcard {
    /// Creates a new builder-style object to manufacture [`ColumnWildcard`](crate::model::ColumnWildcard).
    pub fn builder() -> crate::model::column_wildcard::Builder {
        crate::model::column_wildcard::Builder::default()
    }
}

/// See [`ColumnWildcard`](crate::model::ColumnWildcard).
pub mod column_wildcard {

    /// A builder for [`ColumnWildcard`](crate::model::ColumnWildcard).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) excluded_column_names: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `excluded_column_names`.
        ///
        /// To override the contents of this collection use [`set_excluded_column_names`](Self::set_excluded_column_names).
        ///
        /// <p>Excludes column names. Any column with this name will be excluded.</p>
        pub fn excluded_column_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.excluded_column_names.unwrap_or_default();
            v.push(input.into());
            self.excluded_column_names = Some(v);
            self
        }
        /// <p>Excludes column names. Any column with this name will be excluded.</p>
        pub fn set_excluded_column_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.excluded_column_names = input;
            self
        }
        /// Consumes the builder and constructs a [`ColumnWildcard`](crate::model::ColumnWildcard).
        pub fn build(self) -> crate::model::ColumnWildcard {
            crate::model::ColumnWildcard {
                excluded_column_names: self.excluded_column_names,
            }
        }
    }
}

/// <p>A structure for the catalog object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CatalogResource {}
impl CatalogResource {
    /// Creates a new builder-style object to manufacture [`CatalogResource`](crate::model::CatalogResource).
    pub fn builder() -> crate::model::catalog_resource::Builder {
        crate::model::catalog_resource::Builder::default()
    }
}

/// See [`CatalogResource`](crate::model::CatalogResource).
pub mod catalog_resource {

    /// A builder for [`CatalogResource`](crate::model::CatalogResource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`CatalogResource`](crate::model::CatalogResource).
        pub fn build(self) -> crate::model::CatalogResource {
            crate::model::CatalogResource {}
        }
    }
}

/// <p>The Lake Formation principal. Supported principals are IAM users or IAM roles.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataLakePrincipal {
    /// <p>An identifier for the Lake Formation principal.</p>
    #[doc(hidden)]
    pub data_lake_principal_identifier: std::option::Option<std::string::String>,
}
impl DataLakePrincipal {
    /// <p>An identifier for the Lake Formation principal.</p>
    pub fn data_lake_principal_identifier(&self) -> std::option::Option<&str> {
        self.data_lake_principal_identifier.as_deref()
    }
}
impl DataLakePrincipal {
    /// Creates a new builder-style object to manufacture [`DataLakePrincipal`](crate::model::DataLakePrincipal).
    pub fn builder() -> crate::model::data_lake_principal::Builder {
        crate::model::data_lake_principal::Builder::default()
    }
}

/// See [`DataLakePrincipal`](crate::model::DataLakePrincipal).
pub mod data_lake_principal {

    /// A builder for [`DataLakePrincipal`](crate::model::DataLakePrincipal).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_lake_principal_identifier: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An identifier for the Lake Formation principal.</p>
        pub fn data_lake_principal_identifier(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.data_lake_principal_identifier = Some(input.into());
            self
        }
        /// <p>An identifier for the Lake Formation principal.</p>
        pub fn set_data_lake_principal_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_lake_principal_identifier = input;
            self
        }
        /// Consumes the builder and constructs a [`DataLakePrincipal`](crate::model::DataLakePrincipal).
        pub fn build(self) -> crate::model::DataLakePrincipal {
            crate::model::DataLakePrincipal {
                data_lake_principal_identifier: self.data_lake_principal_identifier,
            }
        }
    }
}

/// <p>A structure containing an error related to a <code>TagResource</code> or <code>UnTagResource</code> operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LfTagError {
    /// <p>The key-name of the LF-tag.</p>
    #[doc(hidden)]
    pub lf_tag: std::option::Option<crate::model::LfTagPair>,
    /// <p>An error that occurred with the attachment or detachment of the LF-tag.</p>
    #[doc(hidden)]
    pub error: std::option::Option<crate::model::ErrorDetail>,
}
impl LfTagError {
    /// <p>The key-name of the LF-tag.</p>
    pub fn lf_tag(&self) -> std::option::Option<&crate::model::LfTagPair> {
        self.lf_tag.as_ref()
    }
    /// <p>An error that occurred with the attachment or detachment of the LF-tag.</p>
    pub fn error(&self) -> std::option::Option<&crate::model::ErrorDetail> {
        self.error.as_ref()
    }
}
impl LfTagError {
    /// Creates a new builder-style object to manufacture [`LfTagError`](crate::model::LfTagError).
    pub fn builder() -> crate::model::lf_tag_error::Builder {
        crate::model::lf_tag_error::Builder::default()
    }
}

/// See [`LfTagError`](crate::model::LfTagError).
pub mod lf_tag_error {

    /// A builder for [`LfTagError`](crate::model::LfTagError).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lf_tag: std::option::Option<crate::model::LfTagPair>,
        pub(crate) error: std::option::Option<crate::model::ErrorDetail>,
    }
    impl Builder {
        /// <p>The key-name of the LF-tag.</p>
        pub fn lf_tag(mut self, input: crate::model::LfTagPair) -> Self {
            self.lf_tag = Some(input);
            self
        }
        /// <p>The key-name of the LF-tag.</p>
        pub fn set_lf_tag(mut self, input: std::option::Option<crate::model::LfTagPair>) -> Self {
            self.lf_tag = input;
            self
        }
        /// <p>An error that occurred with the attachment or detachment of the LF-tag.</p>
        pub fn error(mut self, input: crate::model::ErrorDetail) -> Self {
            self.error = Some(input);
            self
        }
        /// <p>An error that occurred with the attachment or detachment of the LF-tag.</p>
        pub fn set_error(mut self, input: std::option::Option<crate::model::ErrorDetail>) -> Self {
            self.error = input;
            self
        }
        /// Consumes the builder and constructs a [`LfTagError`](crate::model::LfTagError).
        pub fn build(self) -> crate::model::LfTagError {
            crate::model::LfTagError {
                lf_tag: self.lf_tag,
                error: self.error,
            }
        }
    }
}

/// <p>Contains details about an error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ErrorDetail {
    /// <p>The code associated with this error.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<std::string::String>,
    /// <p>A message describing the error.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
}
impl ErrorDetail {
    /// <p>The code associated with this error.</p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p>A message describing the error.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
impl ErrorDetail {
    /// Creates a new builder-style object to manufacture [`ErrorDetail`](crate::model::ErrorDetail).
    pub fn builder() -> crate::model::error_detail::Builder {
        crate::model::error_detail::Builder::default()
    }
}

/// See [`ErrorDetail`](crate::model::ErrorDetail).
pub mod error_detail {

    /// A builder for [`ErrorDetail`](crate::model::ErrorDetail).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The code associated with this error.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>The code associated with this error.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>A message describing the error.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>A message describing the error.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`ErrorDetail`](crate::model::ErrorDetail).
        pub fn build(self) -> crate::model::ErrorDetail {
            crate::model::ErrorDetail {
                error_code: self.error_code,
                error_message: self.error_message,
            }
        }
    }
}

/// <p>A structure representing a list of Lake Formation principals designated as data lake administrators and lists of principal permission entries for default create database and default create table permissions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataLakeSettings {
    /// <p>A list of Lake Formation principals. Supported principals are IAM users or IAM roles.</p>
    #[doc(hidden)]
    pub data_lake_admins: std::option::Option<std::vec::Vec<crate::model::DataLakePrincipal>>,
    /// <p>Specifies whether access control on newly created database is managed by Lake Formation permissions or exclusively by IAM permissions.</p>
    /// <p>A null value indicates access control by Lake Formation permissions. A value that assigns ALL to IAM_ALLOWED_PRINCIPALS indicates access control by IAM permissions. This is referred to as the setting "Use only IAM access control," and is for backward compatibility with the Glue permission model implemented by IAM permissions.</p>
    /// <p>The only permitted values are an empty array or an array that contains a single JSON object that grants ALL to IAM_ALLOWED_PRINCIPALS.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/lake-formation/latest/dg/change-settings.html">Changing the Default Security Settings for Your Data Lake</a>.</p>
    #[doc(hidden)]
    pub create_database_default_permissions:
        std::option::Option<std::vec::Vec<crate::model::PrincipalPermissions>>,
    /// <p>Specifies whether access control on newly created table is managed by Lake Formation permissions or exclusively by IAM permissions.</p>
    /// <p>A null value indicates access control by Lake Formation permissions. A value that assigns ALL to IAM_ALLOWED_PRINCIPALS indicates access control by IAM permissions. This is referred to as the setting "Use only IAM access control," and is for backward compatibility with the Glue permission model implemented by IAM permissions.</p>
    /// <p>The only permitted values are an empty array or an array that contains a single JSON object that grants ALL to IAM_ALLOWED_PRINCIPALS.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/lake-formation/latest/dg/change-settings.html">Changing the Default Security Settings for Your Data Lake</a>.</p>
    #[doc(hidden)]
    pub create_table_default_permissions:
        std::option::Option<std::vec::Vec<crate::model::PrincipalPermissions>>,
    /// <p>A key-value map that provides an additional configuration on your data lake. CrossAccountVersion is the key you can configure in the Parameters field. Accepted values for the CrossAccountVersion key are 1, 2, and 3.</p>
    #[doc(hidden)]
    pub parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A list of the resource-owning account IDs that the caller's account can use to share their user access details (user ARNs). The user ARNs can be logged in the resource owner's CloudTrail log.</p>
    /// <p>You may want to specify this property when you are in a high-trust boundary, such as the same team or company. </p>
    #[doc(hidden)]
    pub trusted_resource_owners: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Whether to allow Amazon EMR clusters to access data managed by Lake Formation. </p>
    /// <p>If true, you allow Amazon EMR clusters to access data in Amazon S3 locations that are registered with Lake Formation.</p>
    /// <p>If false or null, no Amazon EMR clusters will be able to access data in Amazon S3 locations that are registered with Lake Formation.</p>
    /// <p>For more information, see <a href="https://docs-aws.amazon.com/lake-formation/latest/dg/getting-started-setup.html#emr-switch">(Optional) Allow Data Filtering on Amazon EMR</a>.</p>
    #[doc(hidden)]
    pub allow_external_data_filtering: std::option::Option<bool>,
    /// <p>A list of the account IDs of Amazon Web Services accounts with Amazon EMR clusters that are to perform data filtering.&gt;</p>
    #[doc(hidden)]
    pub external_data_filtering_allow_list:
        std::option::Option<std::vec::Vec<crate::model::DataLakePrincipal>>,
    /// <p>Lake Formation relies on a privileged process secured by Amazon EMR or the third party integrator to tag the user's role while assuming it. Lake Formation will publish the acceptable key-value pair, for example key = "LakeFormationTrustedCaller" and value = "TRUE" and the third party integrator must properly tag the temporary security credentials that will be used to call Lake Formation's administrative APIs.</p>
    #[doc(hidden)]
    pub authorized_session_tag_value_list: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl DataLakeSettings {
    /// <p>A list of Lake Formation principals. Supported principals are IAM users or IAM roles.</p>
    pub fn data_lake_admins(&self) -> std::option::Option<&[crate::model::DataLakePrincipal]> {
        self.data_lake_admins.as_deref()
    }
    /// <p>Specifies whether access control on newly created database is managed by Lake Formation permissions or exclusively by IAM permissions.</p>
    /// <p>A null value indicates access control by Lake Formation permissions. A value that assigns ALL to IAM_ALLOWED_PRINCIPALS indicates access control by IAM permissions. This is referred to as the setting "Use only IAM access control," and is for backward compatibility with the Glue permission model implemented by IAM permissions.</p>
    /// <p>The only permitted values are an empty array or an array that contains a single JSON object that grants ALL to IAM_ALLOWED_PRINCIPALS.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/lake-formation/latest/dg/change-settings.html">Changing the Default Security Settings for Your Data Lake</a>.</p>
    pub fn create_database_default_permissions(
        &self,
    ) -> std::option::Option<&[crate::model::PrincipalPermissions]> {
        self.create_database_default_permissions.as_deref()
    }
    /// <p>Specifies whether access control on newly created table is managed by Lake Formation permissions or exclusively by IAM permissions.</p>
    /// <p>A null value indicates access control by Lake Formation permissions. A value that assigns ALL to IAM_ALLOWED_PRINCIPALS indicates access control by IAM permissions. This is referred to as the setting "Use only IAM access control," and is for backward compatibility with the Glue permission model implemented by IAM permissions.</p>
    /// <p>The only permitted values are an empty array or an array that contains a single JSON object that grants ALL to IAM_ALLOWED_PRINCIPALS.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/lake-formation/latest/dg/change-settings.html">Changing the Default Security Settings for Your Data Lake</a>.</p>
    pub fn create_table_default_permissions(
        &self,
    ) -> std::option::Option<&[crate::model::PrincipalPermissions]> {
        self.create_table_default_permissions.as_deref()
    }
    /// <p>A key-value map that provides an additional configuration on your data lake. CrossAccountVersion is the key you can configure in the Parameters field. Accepted values for the CrossAccountVersion key are 1, 2, and 3.</p>
    pub fn parameters(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.parameters.as_ref()
    }
    /// <p>A list of the resource-owning account IDs that the caller's account can use to share their user access details (user ARNs). The user ARNs can be logged in the resource owner's CloudTrail log.</p>
    /// <p>You may want to specify this property when you are in a high-trust boundary, such as the same team or company. </p>
    pub fn trusted_resource_owners(&self) -> std::option::Option<&[std::string::String]> {
        self.trusted_resource_owners.as_deref()
    }
    /// <p>Whether to allow Amazon EMR clusters to access data managed by Lake Formation. </p>
    /// <p>If true, you allow Amazon EMR clusters to access data in Amazon S3 locations that are registered with Lake Formation.</p>
    /// <p>If false or null, no Amazon EMR clusters will be able to access data in Amazon S3 locations that are registered with Lake Formation.</p>
    /// <p>For more information, see <a href="https://docs-aws.amazon.com/lake-formation/latest/dg/getting-started-setup.html#emr-switch">(Optional) Allow Data Filtering on Amazon EMR</a>.</p>
    pub fn allow_external_data_filtering(&self) -> std::option::Option<bool> {
        self.allow_external_data_filtering
    }
    /// <p>A list of the account IDs of Amazon Web Services accounts with Amazon EMR clusters that are to perform data filtering.&gt;</p>
    pub fn external_data_filtering_allow_list(
        &self,
    ) -> std::option::Option<&[crate::model::DataLakePrincipal]> {
        self.external_data_filtering_allow_list.as_deref()
    }
    /// <p>Lake Formation relies on a privileged process secured by Amazon EMR or the third party integrator to tag the user's role while assuming it. Lake Formation will publish the acceptable key-value pair, for example key = "LakeFormationTrustedCaller" and value = "TRUE" and the third party integrator must properly tag the temporary security credentials that will be used to call Lake Formation's administrative APIs.</p>
    pub fn authorized_session_tag_value_list(&self) -> std::option::Option<&[std::string::String]> {
        self.authorized_session_tag_value_list.as_deref()
    }
}
impl DataLakeSettings {
    /// Creates a new builder-style object to manufacture [`DataLakeSettings`](crate::model::DataLakeSettings).
    pub fn builder() -> crate::model::data_lake_settings::Builder {
        crate::model::data_lake_settings::Builder::default()
    }
}

/// See [`DataLakeSettings`](crate::model::DataLakeSettings).
pub mod data_lake_settings {

    /// A builder for [`DataLakeSettings`](crate::model::DataLakeSettings).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_lake_admins:
            std::option::Option<std::vec::Vec<crate::model::DataLakePrincipal>>,
        pub(crate) create_database_default_permissions:
            std::option::Option<std::vec::Vec<crate::model::PrincipalPermissions>>,
        pub(crate) create_table_default_permissions:
            std::option::Option<std::vec::Vec<crate::model::PrincipalPermissions>>,
        pub(crate) parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) trusted_resource_owners: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) allow_external_data_filtering: std::option::Option<bool>,
        pub(crate) external_data_filtering_allow_list:
            std::option::Option<std::vec::Vec<crate::model::DataLakePrincipal>>,
        pub(crate) authorized_session_tag_value_list:
            std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `data_lake_admins`.
        ///
        /// To override the contents of this collection use [`set_data_lake_admins`](Self::set_data_lake_admins).
        ///
        /// <p>A list of Lake Formation principals. Supported principals are IAM users or IAM roles.</p>
        pub fn data_lake_admins(mut self, input: crate::model::DataLakePrincipal) -> Self {
            let mut v = self.data_lake_admins.unwrap_or_default();
            v.push(input);
            self.data_lake_admins = Some(v);
            self
        }
        /// <p>A list of Lake Formation principals. Supported principals are IAM users or IAM roles.</p>
        pub fn set_data_lake_admins(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataLakePrincipal>>,
        ) -> Self {
            self.data_lake_admins = input;
            self
        }
        /// Appends an item to `create_database_default_permissions`.
        ///
        /// To override the contents of this collection use [`set_create_database_default_permissions`](Self::set_create_database_default_permissions).
        ///
        /// <p>Specifies whether access control on newly created database is managed by Lake Formation permissions or exclusively by IAM permissions.</p>
        /// <p>A null value indicates access control by Lake Formation permissions. A value that assigns ALL to IAM_ALLOWED_PRINCIPALS indicates access control by IAM permissions. This is referred to as the setting "Use only IAM access control," and is for backward compatibility with the Glue permission model implemented by IAM permissions.</p>
        /// <p>The only permitted values are an empty array or an array that contains a single JSON object that grants ALL to IAM_ALLOWED_PRINCIPALS.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/lake-formation/latest/dg/change-settings.html">Changing the Default Security Settings for Your Data Lake</a>.</p>
        pub fn create_database_default_permissions(
            mut self,
            input: crate::model::PrincipalPermissions,
        ) -> Self {
            let mut v = self.create_database_default_permissions.unwrap_or_default();
            v.push(input);
            self.create_database_default_permissions = Some(v);
            self
        }
        /// <p>Specifies whether access control on newly created database is managed by Lake Formation permissions or exclusively by IAM permissions.</p>
        /// <p>A null value indicates access control by Lake Formation permissions. A value that assigns ALL to IAM_ALLOWED_PRINCIPALS indicates access control by IAM permissions. This is referred to as the setting "Use only IAM access control," and is for backward compatibility with the Glue permission model implemented by IAM permissions.</p>
        /// <p>The only permitted values are an empty array or an array that contains a single JSON object that grants ALL to IAM_ALLOWED_PRINCIPALS.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/lake-formation/latest/dg/change-settings.html">Changing the Default Security Settings for Your Data Lake</a>.</p>
        pub fn set_create_database_default_permissions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PrincipalPermissions>>,
        ) -> Self {
            self.create_database_default_permissions = input;
            self
        }
        /// Appends an item to `create_table_default_permissions`.
        ///
        /// To override the contents of this collection use [`set_create_table_default_permissions`](Self::set_create_table_default_permissions).
        ///
        /// <p>Specifies whether access control on newly created table is managed by Lake Formation permissions or exclusively by IAM permissions.</p>
        /// <p>A null value indicates access control by Lake Formation permissions. A value that assigns ALL to IAM_ALLOWED_PRINCIPALS indicates access control by IAM permissions. This is referred to as the setting "Use only IAM access control," and is for backward compatibility with the Glue permission model implemented by IAM permissions.</p>
        /// <p>The only permitted values are an empty array or an array that contains a single JSON object that grants ALL to IAM_ALLOWED_PRINCIPALS.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/lake-formation/latest/dg/change-settings.html">Changing the Default Security Settings for Your Data Lake</a>.</p>
        pub fn create_table_default_permissions(
            mut self,
            input: crate::model::PrincipalPermissions,
        ) -> Self {
            let mut v = self.create_table_default_permissions.unwrap_or_default();
            v.push(input);
            self.create_table_default_permissions = Some(v);
            self
        }
        /// <p>Specifies whether access control on newly created table is managed by Lake Formation permissions or exclusively by IAM permissions.</p>
        /// <p>A null value indicates access control by Lake Formation permissions. A value that assigns ALL to IAM_ALLOWED_PRINCIPALS indicates access control by IAM permissions. This is referred to as the setting "Use only IAM access control," and is for backward compatibility with the Glue permission model implemented by IAM permissions.</p>
        /// <p>The only permitted values are an empty array or an array that contains a single JSON object that grants ALL to IAM_ALLOWED_PRINCIPALS.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/lake-formation/latest/dg/change-settings.html">Changing the Default Security Settings for Your Data Lake</a>.</p>
        pub fn set_create_table_default_permissions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PrincipalPermissions>>,
        ) -> Self {
            self.create_table_default_permissions = input;
            self
        }
        /// Adds a key-value pair to `parameters`.
        ///
        /// To override the contents of this collection use [`set_parameters`](Self::set_parameters).
        ///
        /// <p>A key-value map that provides an additional configuration on your data lake. CrossAccountVersion is the key you can configure in the Parameters field. Accepted values for the CrossAccountVersion key are 1, 2, and 3.</p>
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.parameters = Some(hash_map);
            self
        }
        /// <p>A key-value map that provides an additional configuration on your data lake. CrossAccountVersion is the key you can configure in the Parameters field. Accepted values for the CrossAccountVersion key are 1, 2, and 3.</p>
        pub fn set_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.parameters = input;
            self
        }
        /// Appends an item to `trusted_resource_owners`.
        ///
        /// To override the contents of this collection use [`set_trusted_resource_owners`](Self::set_trusted_resource_owners).
        ///
        /// <p>A list of the resource-owning account IDs that the caller's account can use to share their user access details (user ARNs). The user ARNs can be logged in the resource owner's CloudTrail log.</p>
        /// <p>You may want to specify this property when you are in a high-trust boundary, such as the same team or company. </p>
        pub fn trusted_resource_owners(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.trusted_resource_owners.unwrap_or_default();
            v.push(input.into());
            self.trusted_resource_owners = Some(v);
            self
        }
        /// <p>A list of the resource-owning account IDs that the caller's account can use to share their user access details (user ARNs). The user ARNs can be logged in the resource owner's CloudTrail log.</p>
        /// <p>You may want to specify this property when you are in a high-trust boundary, such as the same team or company. </p>
        pub fn set_trusted_resource_owners(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.trusted_resource_owners = input;
            self
        }
        /// <p>Whether to allow Amazon EMR clusters to access data managed by Lake Formation. </p>
        /// <p>If true, you allow Amazon EMR clusters to access data in Amazon S3 locations that are registered with Lake Formation.</p>
        /// <p>If false or null, no Amazon EMR clusters will be able to access data in Amazon S3 locations that are registered with Lake Formation.</p>
        /// <p>For more information, see <a href="https://docs-aws.amazon.com/lake-formation/latest/dg/getting-started-setup.html#emr-switch">(Optional) Allow Data Filtering on Amazon EMR</a>.</p>
        pub fn allow_external_data_filtering(mut self, input: bool) -> Self {
            self.allow_external_data_filtering = Some(input);
            self
        }
        /// <p>Whether to allow Amazon EMR clusters to access data managed by Lake Formation. </p>
        /// <p>If true, you allow Amazon EMR clusters to access data in Amazon S3 locations that are registered with Lake Formation.</p>
        /// <p>If false or null, no Amazon EMR clusters will be able to access data in Amazon S3 locations that are registered with Lake Formation.</p>
        /// <p>For more information, see <a href="https://docs-aws.amazon.com/lake-formation/latest/dg/getting-started-setup.html#emr-switch">(Optional) Allow Data Filtering on Amazon EMR</a>.</p>
        pub fn set_allow_external_data_filtering(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.allow_external_data_filtering = input;
            self
        }
        /// Appends an item to `external_data_filtering_allow_list`.
        ///
        /// To override the contents of this collection use [`set_external_data_filtering_allow_list`](Self::set_external_data_filtering_allow_list).
        ///
        /// <p>A list of the account IDs of Amazon Web Services accounts with Amazon EMR clusters that are to perform data filtering.&gt;</p>
        pub fn external_data_filtering_allow_list(
            mut self,
            input: crate::model::DataLakePrincipal,
        ) -> Self {
            let mut v = self.external_data_filtering_allow_list.unwrap_or_default();
            v.push(input);
            self.external_data_filtering_allow_list = Some(v);
            self
        }
        /// <p>A list of the account IDs of Amazon Web Services accounts with Amazon EMR clusters that are to perform data filtering.&gt;</p>
        pub fn set_external_data_filtering_allow_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataLakePrincipal>>,
        ) -> Self {
            self.external_data_filtering_allow_list = input;
            self
        }
        /// Appends an item to `authorized_session_tag_value_list`.
        ///
        /// To override the contents of this collection use [`set_authorized_session_tag_value_list`](Self::set_authorized_session_tag_value_list).
        ///
        /// <p>Lake Formation relies on a privileged process secured by Amazon EMR or the third party integrator to tag the user's role while assuming it. Lake Formation will publish the acceptable key-value pair, for example key = "LakeFormationTrustedCaller" and value = "TRUE" and the third party integrator must properly tag the temporary security credentials that will be used to call Lake Formation's administrative APIs.</p>
        pub fn authorized_session_tag_value_list(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.authorized_session_tag_value_list.unwrap_or_default();
            v.push(input.into());
            self.authorized_session_tag_value_list = Some(v);
            self
        }
        /// <p>Lake Formation relies on a privileged process secured by Amazon EMR or the third party integrator to tag the user's role while assuming it. Lake Formation will publish the acceptable key-value pair, for example key = "LakeFormationTrustedCaller" and value = "TRUE" and the third party integrator must properly tag the temporary security credentials that will be used to call Lake Formation's administrative APIs.</p>
        pub fn set_authorized_session_tag_value_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.authorized_session_tag_value_list = input;
            self
        }
        /// Consumes the builder and constructs a [`DataLakeSettings`](crate::model::DataLakeSettings).
        pub fn build(self) -> crate::model::DataLakeSettings {
            crate::model::DataLakeSettings {
                data_lake_admins: self.data_lake_admins,
                create_database_default_permissions: self.create_database_default_permissions,
                create_table_default_permissions: self.create_table_default_permissions,
                parameters: self.parameters,
                trusted_resource_owners: self.trusted_resource_owners,
                allow_external_data_filtering: self.allow_external_data_filtering,
                external_data_filtering_allow_list: self.external_data_filtering_allow_list,
                authorized_session_tag_value_list: self.authorized_session_tag_value_list,
            }
        }
    }
}

/// <p>Permissions granted to a principal.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PrincipalPermissions {
    /// <p>The principal who is granted permissions.</p>
    #[doc(hidden)]
    pub principal: std::option::Option<crate::model::DataLakePrincipal>,
    /// <p>The permissions that are granted to the principal.</p>
    #[doc(hidden)]
    pub permissions: std::option::Option<std::vec::Vec<crate::model::Permission>>,
}
impl PrincipalPermissions {
    /// <p>The principal who is granted permissions.</p>
    pub fn principal(&self) -> std::option::Option<&crate::model::DataLakePrincipal> {
        self.principal.as_ref()
    }
    /// <p>The permissions that are granted to the principal.</p>
    pub fn permissions(&self) -> std::option::Option<&[crate::model::Permission]> {
        self.permissions.as_deref()
    }
}
impl PrincipalPermissions {
    /// Creates a new builder-style object to manufacture [`PrincipalPermissions`](crate::model::PrincipalPermissions).
    pub fn builder() -> crate::model::principal_permissions::Builder {
        crate::model::principal_permissions::Builder::default()
    }
}

/// See [`PrincipalPermissions`](crate::model::PrincipalPermissions).
pub mod principal_permissions {

    /// A builder for [`PrincipalPermissions`](crate::model::PrincipalPermissions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) principal: std::option::Option<crate::model::DataLakePrincipal>,
        pub(crate) permissions: std::option::Option<std::vec::Vec<crate::model::Permission>>,
    }
    impl Builder {
        /// <p>The principal who is granted permissions.</p>
        pub fn principal(mut self, input: crate::model::DataLakePrincipal) -> Self {
            self.principal = Some(input);
            self
        }
        /// <p>The principal who is granted permissions.</p>
        pub fn set_principal(
            mut self,
            input: std::option::Option<crate::model::DataLakePrincipal>,
        ) -> Self {
            self.principal = input;
            self
        }
        /// Appends an item to `permissions`.
        ///
        /// To override the contents of this collection use [`set_permissions`](Self::set_permissions).
        ///
        /// <p>The permissions that are granted to the principal.</p>
        pub fn permissions(mut self, input: crate::model::Permission) -> Self {
            let mut v = self.permissions.unwrap_or_default();
            v.push(input);
            self.permissions = Some(v);
            self
        }
        /// <p>The permissions that are granted to the principal.</p>
        pub fn set_permissions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Permission>>,
        ) -> Self {
            self.permissions = input;
            self
        }
        /// Consumes the builder and constructs a [`PrincipalPermissions`](crate::model::PrincipalPermissions).
        pub fn build(self) -> crate::model::PrincipalPermissions {
            crate::model::PrincipalPermissions {
                principal: self.principal,
                permissions: self.permissions,
            }
        }
    }
}

/// <p>A structure that contains information about a transaction.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TransactionDescription {
    /// <p>The ID of the transaction.</p>
    #[doc(hidden)]
    pub transaction_id: std::option::Option<std::string::String>,
    /// <p>A status of ACTIVE, COMMITTED, or ABORTED.</p>
    #[doc(hidden)]
    pub transaction_status: std::option::Option<crate::model::TransactionStatus>,
    /// <p>The time when the transaction started.</p>
    #[doc(hidden)]
    pub transaction_start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time when the transaction committed or aborted, if it is not currently active.</p>
    #[doc(hidden)]
    pub transaction_end_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl TransactionDescription {
    /// <p>The ID of the transaction.</p>
    pub fn transaction_id(&self) -> std::option::Option<&str> {
        self.transaction_id.as_deref()
    }
    /// <p>A status of ACTIVE, COMMITTED, or ABORTED.</p>
    pub fn transaction_status(&self) -> std::option::Option<&crate::model::TransactionStatus> {
        self.transaction_status.as_ref()
    }
    /// <p>The time when the transaction started.</p>
    pub fn transaction_start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.transaction_start_time.as_ref()
    }
    /// <p>The time when the transaction committed or aborted, if it is not currently active.</p>
    pub fn transaction_end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.transaction_end_time.as_ref()
    }
}
impl TransactionDescription {
    /// Creates a new builder-style object to manufacture [`TransactionDescription`](crate::model::TransactionDescription).
    pub fn builder() -> crate::model::transaction_description::Builder {
        crate::model::transaction_description::Builder::default()
    }
}

/// See [`TransactionDescription`](crate::model::TransactionDescription).
pub mod transaction_description {

    /// A builder for [`TransactionDescription`](crate::model::TransactionDescription).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transaction_id: std::option::Option<std::string::String>,
        pub(crate) transaction_status: std::option::Option<crate::model::TransactionStatus>,
        pub(crate) transaction_start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) transaction_end_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The ID of the transaction.</p>
        pub fn transaction_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.transaction_id = Some(input.into());
            self
        }
        /// <p>The ID of the transaction.</p>
        pub fn set_transaction_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transaction_id = input;
            self
        }
        /// <p>A status of ACTIVE, COMMITTED, or ABORTED.</p>
        pub fn transaction_status(mut self, input: crate::model::TransactionStatus) -> Self {
            self.transaction_status = Some(input);
            self
        }
        /// <p>A status of ACTIVE, COMMITTED, or ABORTED.</p>
        pub fn set_transaction_status(
            mut self,
            input: std::option::Option<crate::model::TransactionStatus>,
        ) -> Self {
            self.transaction_status = input;
            self
        }
        /// <p>The time when the transaction started.</p>
        pub fn transaction_start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.transaction_start_time = Some(input);
            self
        }
        /// <p>The time when the transaction started.</p>
        pub fn set_transaction_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.transaction_start_time = input;
            self
        }
        /// <p>The time when the transaction committed or aborted, if it is not currently active.</p>
        pub fn transaction_end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.transaction_end_time = Some(input);
            self
        }
        /// <p>The time when the transaction committed or aborted, if it is not currently active.</p>
        pub fn set_transaction_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.transaction_end_time = input;
            self
        }
        /// Consumes the builder and constructs a [`TransactionDescription`](crate::model::TransactionDescription).
        pub fn build(self) -> crate::model::TransactionDescription {
            crate::model::TransactionDescription {
                transaction_id: self.transaction_id,
                transaction_status: self.transaction_status,
                transaction_start_time: self.transaction_start_time,
                transaction_end_time: self.transaction_end_time,
            }
        }
    }
}

/// When writing a match expression against `TransactionStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let transactionstatus = unimplemented!();
/// match transactionstatus {
///     TransactionStatus::Aborted => { /* ... */ },
///     TransactionStatus::Active => { /* ... */ },
///     TransactionStatus::Committed => { /* ... */ },
///     TransactionStatus::CommitInProgress => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `transactionstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TransactionStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TransactionStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TransactionStatus::NewFeature` is defined.
/// Specifically, when `transactionstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TransactionStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TransactionStatus {
    #[allow(missing_docs)] // documentation missing in model
    Aborted,
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Committed,
    #[allow(missing_docs)] // documentation missing in model
    CommitInProgress,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TransactionStatus {
    fn from(s: &str) -> Self {
        match s {
            "ABORTED" => TransactionStatus::Aborted,
            "ACTIVE" => TransactionStatus::Active,
            "COMMITTED" => TransactionStatus::Committed,
            "COMMIT_IN_PROGRESS" => TransactionStatus::CommitInProgress,
            other => {
                TransactionStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for TransactionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TransactionStatus::from(s))
    }
}
impl TransactionStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TransactionStatus::Aborted => "ABORTED",
            TransactionStatus::Active => "ACTIVE",
            TransactionStatus::Committed => "COMMITTED",
            TransactionStatus::CommitInProgress => "COMMIT_IN_PROGRESS",
            TransactionStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ABORTED", "ACTIVE", "COMMITTED", "COMMIT_IN_PROGRESS"]
    }
}
impl AsRef<str> for TransactionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `TransactionStatusFilter`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let transactionstatusfilter = unimplemented!();
/// match transactionstatusfilter {
///     TransactionStatusFilter::Aborted => { /* ... */ },
///     TransactionStatusFilter::Active => { /* ... */ },
///     TransactionStatusFilter::All => { /* ... */ },
///     TransactionStatusFilter::Committed => { /* ... */ },
///     TransactionStatusFilter::Completed => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `transactionstatusfilter` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TransactionStatusFilter::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TransactionStatusFilter::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TransactionStatusFilter::NewFeature` is defined.
/// Specifically, when `transactionstatusfilter` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TransactionStatusFilter::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TransactionStatusFilter {
    #[allow(missing_docs)] // documentation missing in model
    Aborted,
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    All,
    #[allow(missing_docs)] // documentation missing in model
    Committed,
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TransactionStatusFilter {
    fn from(s: &str) -> Self {
        match s {
            "ABORTED" => TransactionStatusFilter::Aborted,
            "ACTIVE" => TransactionStatusFilter::Active,
            "ALL" => TransactionStatusFilter::All,
            "COMMITTED" => TransactionStatusFilter::Committed,
            "COMPLETED" => TransactionStatusFilter::Completed,
            other => TransactionStatusFilter::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for TransactionStatusFilter {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TransactionStatusFilter::from(s))
    }
}
impl TransactionStatusFilter {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TransactionStatusFilter::Aborted => "ABORTED",
            TransactionStatusFilter::Active => "ACTIVE",
            TransactionStatusFilter::All => "ALL",
            TransactionStatusFilter::Committed => "COMMITTED",
            TransactionStatusFilter::Completed => "COMPLETED",
            TransactionStatusFilter::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ABORTED", "ACTIVE", "ALL", "COMMITTED", "COMPLETED"]
    }
}
impl AsRef<str> for TransactionStatusFilter {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A structure describing the configuration and details of a storage optimizer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StorageOptimizer {
    /// <p>The specific type of storage optimizer. The supported value is <code>compaction</code>.</p>
    #[doc(hidden)]
    pub storage_optimizer_type: std::option::Option<crate::model::OptimizerType>,
    /// <p>A map of the storage optimizer configuration. Currently contains only one key-value pair: <code>is_enabled</code> indicates true or false for acceleration.</p>
    #[doc(hidden)]
    pub config:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A message that contains information about any error (if present).</p>
    /// <p>When an acceleration result has an enabled status, the error message is empty.</p>
    /// <p>When an acceleration result has a disabled status, the message describes an error or simply indicates "disabled by the user".</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
    /// <p>A message that contains information about any warnings (if present).</p>
    #[doc(hidden)]
    pub warnings: std::option::Option<std::string::String>,
    /// <p>When an acceleration result has an enabled status, contains the details of the last job run.</p>
    #[doc(hidden)]
    pub last_run_details: std::option::Option<std::string::String>,
}
impl StorageOptimizer {
    /// <p>The specific type of storage optimizer. The supported value is <code>compaction</code>.</p>
    pub fn storage_optimizer_type(&self) -> std::option::Option<&crate::model::OptimizerType> {
        self.storage_optimizer_type.as_ref()
    }
    /// <p>A map of the storage optimizer configuration. Currently contains only one key-value pair: <code>is_enabled</code> indicates true or false for acceleration.</p>
    pub fn config(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.config.as_ref()
    }
    /// <p>A message that contains information about any error (if present).</p>
    /// <p>When an acceleration result has an enabled status, the error message is empty.</p>
    /// <p>When an acceleration result has a disabled status, the message describes an error or simply indicates "disabled by the user".</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
    /// <p>A message that contains information about any warnings (if present).</p>
    pub fn warnings(&self) -> std::option::Option<&str> {
        self.warnings.as_deref()
    }
    /// <p>When an acceleration result has an enabled status, contains the details of the last job run.</p>
    pub fn last_run_details(&self) -> std::option::Option<&str> {
        self.last_run_details.as_deref()
    }
}
impl StorageOptimizer {
    /// Creates a new builder-style object to manufacture [`StorageOptimizer`](crate::model::StorageOptimizer).
    pub fn builder() -> crate::model::storage_optimizer::Builder {
        crate::model::storage_optimizer::Builder::default()
    }
}

/// See [`StorageOptimizer`](crate::model::StorageOptimizer).
pub mod storage_optimizer {

    /// A builder for [`StorageOptimizer`](crate::model::StorageOptimizer).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) storage_optimizer_type: std::option::Option<crate::model::OptimizerType>,
        pub(crate) config: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) error_message: std::option::Option<std::string::String>,
        pub(crate) warnings: std::option::Option<std::string::String>,
        pub(crate) last_run_details: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The specific type of storage optimizer. The supported value is <code>compaction</code>.</p>
        pub fn storage_optimizer_type(mut self, input: crate::model::OptimizerType) -> Self {
            self.storage_optimizer_type = Some(input);
            self
        }
        /// <p>The specific type of storage optimizer. The supported value is <code>compaction</code>.</p>
        pub fn set_storage_optimizer_type(
            mut self,
            input: std::option::Option<crate::model::OptimizerType>,
        ) -> Self {
            self.storage_optimizer_type = input;
            self
        }
        /// Adds a key-value pair to `config`.
        ///
        /// To override the contents of this collection use [`set_config`](Self::set_config).
        ///
        /// <p>A map of the storage optimizer configuration. Currently contains only one key-value pair: <code>is_enabled</code> indicates true or false for acceleration.</p>
        pub fn config(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.config.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.config = Some(hash_map);
            self
        }
        /// <p>A map of the storage optimizer configuration. Currently contains only one key-value pair: <code>is_enabled</code> indicates true or false for acceleration.</p>
        pub fn set_config(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.config = input;
            self
        }
        /// <p>A message that contains information about any error (if present).</p>
        /// <p>When an acceleration result has an enabled status, the error message is empty.</p>
        /// <p>When an acceleration result has a disabled status, the message describes an error or simply indicates "disabled by the user".</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>A message that contains information about any error (if present).</p>
        /// <p>When an acceleration result has an enabled status, the error message is empty.</p>
        /// <p>When an acceleration result has a disabled status, the message describes an error or simply indicates "disabled by the user".</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// <p>A message that contains information about any warnings (if present).</p>
        pub fn warnings(mut self, input: impl Into<std::string::String>) -> Self {
            self.warnings = Some(input.into());
            self
        }
        /// <p>A message that contains information about any warnings (if present).</p>
        pub fn set_warnings(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.warnings = input;
            self
        }
        /// <p>When an acceleration result has an enabled status, contains the details of the last job run.</p>
        pub fn last_run_details(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_run_details = Some(input.into());
            self
        }
        /// <p>When an acceleration result has an enabled status, contains the details of the last job run.</p>
        pub fn set_last_run_details(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_run_details = input;
            self
        }
        /// Consumes the builder and constructs a [`StorageOptimizer`](crate::model::StorageOptimizer).
        pub fn build(self) -> crate::model::StorageOptimizer {
            crate::model::StorageOptimizer {
                storage_optimizer_type: self.storage_optimizer_type,
                config: self.config,
                error_message: self.error_message,
                warnings: self.warnings,
                last_run_details: self.last_run_details,
            }
        }
    }
}

/// <p>A structure containing information about an Lake Formation resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceInfo {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The IAM role that registered a resource.</p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The date and time the resource was last modified.</p>
    #[doc(hidden)]
    pub last_modified: std::option::Option<aws_smithy_types::DateTime>,
}
impl ResourceInfo {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The IAM role that registered a resource.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>The date and time the resource was last modified.</p>
    pub fn last_modified(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified.as_ref()
    }
}
impl ResourceInfo {
    /// Creates a new builder-style object to manufacture [`ResourceInfo`](crate::model::ResourceInfo).
    pub fn builder() -> crate::model::resource_info::Builder {
        crate::model::resource_info::Builder::default()
    }
}

/// See [`ResourceInfo`](crate::model::ResourceInfo).
pub mod resource_info {

    /// A builder for [`ResourceInfo`](crate::model::ResourceInfo).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) last_modified: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// <p>The IAM role that registered a resource.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The IAM role that registered a resource.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>The date and time the resource was last modified.</p>
        pub fn last_modified(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified = Some(input);
            self
        }
        /// <p>The date and time the resource was last modified.</p>
        pub fn set_last_modified(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceInfo`](crate::model::ResourceInfo).
        pub fn build(self) -> crate::model::ResourceInfo {
            crate::model::ResourceInfo {
                resource_arn: self.resource_arn,
                role_arn: self.role_arn,
                last_modified: self.last_modified,
            }
        }
    }
}

/// <p>This structure describes the filtering of columns in a table based on a filter condition.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FilterCondition {
    /// <p>The field to filter in the filter condition.</p>
    #[doc(hidden)]
    pub field: std::option::Option<crate::model::FieldNameString>,
    /// <p>The comparison operator used in the filter condition.</p>
    #[doc(hidden)]
    pub comparison_operator: std::option::Option<crate::model::ComparisonOperator>,
    /// <p>A string with values used in evaluating the filter condition.</p>
    #[doc(hidden)]
    pub string_value_list: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl FilterCondition {
    /// <p>The field to filter in the filter condition.</p>
    pub fn field(&self) -> std::option::Option<&crate::model::FieldNameString> {
        self.field.as_ref()
    }
    /// <p>The comparison operator used in the filter condition.</p>
    pub fn comparison_operator(&self) -> std::option::Option<&crate::model::ComparisonOperator> {
        self.comparison_operator.as_ref()
    }
    /// <p>A string with values used in evaluating the filter condition.</p>
    pub fn string_value_list(&self) -> std::option::Option<&[std::string::String]> {
        self.string_value_list.as_deref()
    }
}
impl FilterCondition {
    /// Creates a new builder-style object to manufacture [`FilterCondition`](crate::model::FilterCondition).
    pub fn builder() -> crate::model::filter_condition::Builder {
        crate::model::filter_condition::Builder::default()
    }
}

/// See [`FilterCondition`](crate::model::FilterCondition).
pub mod filter_condition {

    /// A builder for [`FilterCondition`](crate::model::FilterCondition).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field: std::option::Option<crate::model::FieldNameString>,
        pub(crate) comparison_operator: std::option::Option<crate::model::ComparisonOperator>,
        pub(crate) string_value_list: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The field to filter in the filter condition.</p>
        pub fn field(mut self, input: crate::model::FieldNameString) -> Self {
            self.field = Some(input);
            self
        }
        /// <p>The field to filter in the filter condition.</p>
        pub fn set_field(
            mut self,
            input: std::option::Option<crate::model::FieldNameString>,
        ) -> Self {
            self.field = input;
            self
        }
        /// <p>The comparison operator used in the filter condition.</p>
        pub fn comparison_operator(mut self, input: crate::model::ComparisonOperator) -> Self {
            self.comparison_operator = Some(input);
            self
        }
        /// <p>The comparison operator used in the filter condition.</p>
        pub fn set_comparison_operator(
            mut self,
            input: std::option::Option<crate::model::ComparisonOperator>,
        ) -> Self {
            self.comparison_operator = input;
            self
        }
        /// Appends an item to `string_value_list`.
        ///
        /// To override the contents of this collection use [`set_string_value_list`](Self::set_string_value_list).
        ///
        /// <p>A string with values used in evaluating the filter condition.</p>
        pub fn string_value_list(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.string_value_list.unwrap_or_default();
            v.push(input.into());
            self.string_value_list = Some(v);
            self
        }
        /// <p>A string with values used in evaluating the filter condition.</p>
        pub fn set_string_value_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.string_value_list = input;
            self
        }
        /// Consumes the builder and constructs a [`FilterCondition`](crate::model::FilterCondition).
        pub fn build(self) -> crate::model::FilterCondition {
            crate::model::FilterCondition {
                field: self.field,
                comparison_operator: self.comparison_operator,
                string_value_list: self.string_value_list,
            }
        }
    }
}

/// When writing a match expression against `ComparisonOperator`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let comparisonoperator = unimplemented!();
/// match comparisonoperator {
///     ComparisonOperator::BeginsWith => { /* ... */ },
///     ComparisonOperator::Between => { /* ... */ },
///     ComparisonOperator::Contains => { /* ... */ },
///     ComparisonOperator::Eq => { /* ... */ },
///     ComparisonOperator::Ge => { /* ... */ },
///     ComparisonOperator::Gt => { /* ... */ },
///     ComparisonOperator::In => { /* ... */ },
///     ComparisonOperator::Le => { /* ... */ },
///     ComparisonOperator::Lt => { /* ... */ },
///     ComparisonOperator::Ne => { /* ... */ },
///     ComparisonOperator::NotContains => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `comparisonoperator` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ComparisonOperator::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ComparisonOperator::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ComparisonOperator::NewFeature` is defined.
/// Specifically, when `comparisonoperator` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ComparisonOperator::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ComparisonOperator {
    #[allow(missing_docs)] // documentation missing in model
    BeginsWith,
    #[allow(missing_docs)] // documentation missing in model
    Between,
    #[allow(missing_docs)] // documentation missing in model
    Contains,
    #[allow(missing_docs)] // documentation missing in model
    Eq,
    #[allow(missing_docs)] // documentation missing in model
    Ge,
    #[allow(missing_docs)] // documentation missing in model
    Gt,
    #[allow(missing_docs)] // documentation missing in model
    In,
    #[allow(missing_docs)] // documentation missing in model
    Le,
    #[allow(missing_docs)] // documentation missing in model
    Lt,
    #[allow(missing_docs)] // documentation missing in model
    Ne,
    #[allow(missing_docs)] // documentation missing in model
    NotContains,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ComparisonOperator {
    fn from(s: &str) -> Self {
        match s {
            "BEGINS_WITH" => ComparisonOperator::BeginsWith,
            "BETWEEN" => ComparisonOperator::Between,
            "CONTAINS" => ComparisonOperator::Contains,
            "EQ" => ComparisonOperator::Eq,
            "GE" => ComparisonOperator::Ge,
            "GT" => ComparisonOperator::Gt,
            "IN" => ComparisonOperator::In,
            "LE" => ComparisonOperator::Le,
            "LT" => ComparisonOperator::Lt,
            "NE" => ComparisonOperator::Ne,
            "NOT_CONTAINS" => ComparisonOperator::NotContains,
            other => {
                ComparisonOperator::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ComparisonOperator {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ComparisonOperator::from(s))
    }
}
impl ComparisonOperator {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ComparisonOperator::BeginsWith => "BEGINS_WITH",
            ComparisonOperator::Between => "BETWEEN",
            ComparisonOperator::Contains => "CONTAINS",
            ComparisonOperator::Eq => "EQ",
            ComparisonOperator::Ge => "GE",
            ComparisonOperator::Gt => "GT",
            ComparisonOperator::In => "IN",
            ComparisonOperator::Le => "LE",
            ComparisonOperator::Lt => "LT",
            ComparisonOperator::Ne => "NE",
            ComparisonOperator::NotContains => "NOT_CONTAINS",
            ComparisonOperator::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "BEGINS_WITH",
            "BETWEEN",
            "CONTAINS",
            "EQ",
            "GE",
            "GT",
            "IN",
            "LE",
            "LT",
            "NE",
            "NOT_CONTAINS",
        ]
    }
}
impl AsRef<str> for ComparisonOperator {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `FieldNameString`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let fieldnamestring = unimplemented!();
/// match fieldnamestring {
///     FieldNameString::LastModified => { /* ... */ },
///     FieldNameString::ResourceArn => { /* ... */ },
///     FieldNameString::RoleArn => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `fieldnamestring` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FieldNameString::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FieldNameString::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FieldNameString::NewFeature` is defined.
/// Specifically, when `fieldnamestring` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FieldNameString::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FieldNameString {
    #[allow(missing_docs)] // documentation missing in model
    LastModified,
    #[allow(missing_docs)] // documentation missing in model
    ResourceArn,
    #[allow(missing_docs)] // documentation missing in model
    RoleArn,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FieldNameString {
    fn from(s: &str) -> Self {
        match s {
            "LAST_MODIFIED" => FieldNameString::LastModified,
            "RESOURCE_ARN" => FieldNameString::ResourceArn,
            "ROLE_ARN" => FieldNameString::RoleArn,
            other => FieldNameString::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for FieldNameString {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FieldNameString::from(s))
    }
}
impl FieldNameString {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FieldNameString::LastModified => "LAST_MODIFIED",
            FieldNameString::ResourceArn => "RESOURCE_ARN",
            FieldNameString::RoleArn => "ROLE_ARN",
            FieldNameString::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["LAST_MODIFIED", "RESOURCE_ARN", "ROLE_ARN"]
    }
}
impl AsRef<str> for FieldNameString {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The permissions granted or revoked on a resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PrincipalResourcePermissions {
    /// <p>The Data Lake principal to be granted or revoked permissions.</p>
    #[doc(hidden)]
    pub principal: std::option::Option<crate::model::DataLakePrincipal>,
    /// <p>The resource where permissions are to be granted or revoked.</p>
    #[doc(hidden)]
    pub resource: std::option::Option<crate::model::Resource>,
    /// <p>The permissions to be granted or revoked on the resource.</p>
    #[doc(hidden)]
    pub permissions: std::option::Option<std::vec::Vec<crate::model::Permission>>,
    /// <p>Indicates whether to grant the ability to grant permissions (as a subset of permissions granted).</p>
    #[doc(hidden)]
    pub permissions_with_grant_option: std::option::Option<std::vec::Vec<crate::model::Permission>>,
    /// <p>This attribute can be used to return any additional details of <code>PrincipalResourcePermissions</code>. Currently returns only as a RAM resource share ARN.</p>
    #[doc(hidden)]
    pub additional_details: std::option::Option<crate::model::DetailsMap>,
}
impl PrincipalResourcePermissions {
    /// <p>The Data Lake principal to be granted or revoked permissions.</p>
    pub fn principal(&self) -> std::option::Option<&crate::model::DataLakePrincipal> {
        self.principal.as_ref()
    }
    /// <p>The resource where permissions are to be granted or revoked.</p>
    pub fn resource(&self) -> std::option::Option<&crate::model::Resource> {
        self.resource.as_ref()
    }
    /// <p>The permissions to be granted or revoked on the resource.</p>
    pub fn permissions(&self) -> std::option::Option<&[crate::model::Permission]> {
        self.permissions.as_deref()
    }
    /// <p>Indicates whether to grant the ability to grant permissions (as a subset of permissions granted).</p>
    pub fn permissions_with_grant_option(
        &self,
    ) -> std::option::Option<&[crate::model::Permission]> {
        self.permissions_with_grant_option.as_deref()
    }
    /// <p>This attribute can be used to return any additional details of <code>PrincipalResourcePermissions</code>. Currently returns only as a RAM resource share ARN.</p>
    pub fn additional_details(&self) -> std::option::Option<&crate::model::DetailsMap> {
        self.additional_details.as_ref()
    }
}
impl PrincipalResourcePermissions {
    /// Creates a new builder-style object to manufacture [`PrincipalResourcePermissions`](crate::model::PrincipalResourcePermissions).
    pub fn builder() -> crate::model::principal_resource_permissions::Builder {
        crate::model::principal_resource_permissions::Builder::default()
    }
}

/// See [`PrincipalResourcePermissions`](crate::model::PrincipalResourcePermissions).
pub mod principal_resource_permissions {

    /// A builder for [`PrincipalResourcePermissions`](crate::model::PrincipalResourcePermissions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) principal: std::option::Option<crate::model::DataLakePrincipal>,
        pub(crate) resource: std::option::Option<crate::model::Resource>,
        pub(crate) permissions: std::option::Option<std::vec::Vec<crate::model::Permission>>,
        pub(crate) permissions_with_grant_option:
            std::option::Option<std::vec::Vec<crate::model::Permission>>,
        pub(crate) additional_details: std::option::Option<crate::model::DetailsMap>,
    }
    impl Builder {
        /// <p>The Data Lake principal to be granted or revoked permissions.</p>
        pub fn principal(mut self, input: crate::model::DataLakePrincipal) -> Self {
            self.principal = Some(input);
            self
        }
        /// <p>The Data Lake principal to be granted or revoked permissions.</p>
        pub fn set_principal(
            mut self,
            input: std::option::Option<crate::model::DataLakePrincipal>,
        ) -> Self {
            self.principal = input;
            self
        }
        /// <p>The resource where permissions are to be granted or revoked.</p>
        pub fn resource(mut self, input: crate::model::Resource) -> Self {
            self.resource = Some(input);
            self
        }
        /// <p>The resource where permissions are to be granted or revoked.</p>
        pub fn set_resource(mut self, input: std::option::Option<crate::model::Resource>) -> Self {
            self.resource = input;
            self
        }
        /// Appends an item to `permissions`.
        ///
        /// To override the contents of this collection use [`set_permissions`](Self::set_permissions).
        ///
        /// <p>The permissions to be granted or revoked on the resource.</p>
        pub fn permissions(mut self, input: crate::model::Permission) -> Self {
            let mut v = self.permissions.unwrap_or_default();
            v.push(input);
            self.permissions = Some(v);
            self
        }
        /// <p>The permissions to be granted or revoked on the resource.</p>
        pub fn set_permissions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Permission>>,
        ) -> Self {
            self.permissions = input;
            self
        }
        /// Appends an item to `permissions_with_grant_option`.
        ///
        /// To override the contents of this collection use [`set_permissions_with_grant_option`](Self::set_permissions_with_grant_option).
        ///
        /// <p>Indicates whether to grant the ability to grant permissions (as a subset of permissions granted).</p>
        pub fn permissions_with_grant_option(mut self, input: crate::model::Permission) -> Self {
            let mut v = self.permissions_with_grant_option.unwrap_or_default();
            v.push(input);
            self.permissions_with_grant_option = Some(v);
            self
        }
        /// <p>Indicates whether to grant the ability to grant permissions (as a subset of permissions granted).</p>
        pub fn set_permissions_with_grant_option(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Permission>>,
        ) -> Self {
            self.permissions_with_grant_option = input;
            self
        }
        /// <p>This attribute can be used to return any additional details of <code>PrincipalResourcePermissions</code>. Currently returns only as a RAM resource share ARN.</p>
        pub fn additional_details(mut self, input: crate::model::DetailsMap) -> Self {
            self.additional_details = Some(input);
            self
        }
        /// <p>This attribute can be used to return any additional details of <code>PrincipalResourcePermissions</code>. Currently returns only as a RAM resource share ARN.</p>
        pub fn set_additional_details(
            mut self,
            input: std::option::Option<crate::model::DetailsMap>,
        ) -> Self {
            self.additional_details = input;
            self
        }
        /// Consumes the builder and constructs a [`PrincipalResourcePermissions`](crate::model::PrincipalResourcePermissions).
        pub fn build(self) -> crate::model::PrincipalResourcePermissions {
            crate::model::PrincipalResourcePermissions {
                principal: self.principal,
                resource: self.resource,
                permissions: self.permissions,
                permissions_with_grant_option: self.permissions_with_grant_option,
                additional_details: self.additional_details,
            }
        }
    }
}

/// <p>A structure containing the additional details to be returned in the <code>AdditionalDetails</code> attribute of <code>PrincipalResourcePermissions</code>.</p>
/// <p>If a catalog resource is shared through Resource Access Manager (RAM), then there will exist a corresponding RAM resource share ARN.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DetailsMap {
    /// <p>A resource share ARN for a catalog resource shared through RAM.</p>
    #[doc(hidden)]
    pub resource_share: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl DetailsMap {
    /// <p>A resource share ARN for a catalog resource shared through RAM.</p>
    pub fn resource_share(&self) -> std::option::Option<&[std::string::String]> {
        self.resource_share.as_deref()
    }
}
impl DetailsMap {
    /// Creates a new builder-style object to manufacture [`DetailsMap`](crate::model::DetailsMap).
    pub fn builder() -> crate::model::details_map::Builder {
        crate::model::details_map::Builder::default()
    }
}

/// See [`DetailsMap`](crate::model::DetailsMap).
pub mod details_map {

    /// A builder for [`DetailsMap`](crate::model::DetailsMap).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_share: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `resource_share`.
        ///
        /// To override the contents of this collection use [`set_resource_share`](Self::set_resource_share).
        ///
        /// <p>A resource share ARN for a catalog resource shared through RAM.</p>
        pub fn resource_share(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.resource_share.unwrap_or_default();
            v.push(input.into());
            self.resource_share = Some(v);
            self
        }
        /// <p>A resource share ARN for a catalog resource shared through RAM.</p>
        pub fn set_resource_share(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.resource_share = input;
            self
        }
        /// Consumes the builder and constructs a [`DetailsMap`](crate::model::DetailsMap).
        pub fn build(self) -> crate::model::DetailsMap {
            crate::model::DetailsMap {
                resource_share: self.resource_share,
            }
        }
    }
}

/// When writing a match expression against `DataLakeResourceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let datalakeresourcetype = unimplemented!();
/// match datalakeresourcetype {
///     DataLakeResourceType::Catalog => { /* ... */ },
///     DataLakeResourceType::Database => { /* ... */ },
///     DataLakeResourceType::DataLocation => { /* ... */ },
///     DataLakeResourceType::LfTag => { /* ... */ },
///     DataLakeResourceType::LfTagPolicy => { /* ... */ },
///     DataLakeResourceType::LfTagPolicyDatabase => { /* ... */ },
///     DataLakeResourceType::LfTagPolicyTable => { /* ... */ },
///     DataLakeResourceType::Table => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `datalakeresourcetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DataLakeResourceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DataLakeResourceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DataLakeResourceType::NewFeature` is defined.
/// Specifically, when `datalakeresourcetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DataLakeResourceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataLakeResourceType {
    #[allow(missing_docs)] // documentation missing in model
    Catalog,
    #[allow(missing_docs)] // documentation missing in model
    Database,
    #[allow(missing_docs)] // documentation missing in model
    DataLocation,
    #[allow(missing_docs)] // documentation missing in model
    LfTag,
    #[allow(missing_docs)] // documentation missing in model
    LfTagPolicy,
    #[allow(missing_docs)] // documentation missing in model
    LfTagPolicyDatabase,
    #[allow(missing_docs)] // documentation missing in model
    LfTagPolicyTable,
    #[allow(missing_docs)] // documentation missing in model
    Table,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DataLakeResourceType {
    fn from(s: &str) -> Self {
        match s {
            "CATALOG" => DataLakeResourceType::Catalog,
            "DATABASE" => DataLakeResourceType::Database,
            "DATA_LOCATION" => DataLakeResourceType::DataLocation,
            "LF_TAG" => DataLakeResourceType::LfTag,
            "LF_TAG_POLICY" => DataLakeResourceType::LfTagPolicy,
            "LF_TAG_POLICY_DATABASE" => DataLakeResourceType::LfTagPolicyDatabase,
            "LF_TAG_POLICY_TABLE" => DataLakeResourceType::LfTagPolicyTable,
            "TABLE" => DataLakeResourceType::Table,
            other => {
                DataLakeResourceType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for DataLakeResourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataLakeResourceType::from(s))
    }
}
impl DataLakeResourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DataLakeResourceType::Catalog => "CATALOG",
            DataLakeResourceType::Database => "DATABASE",
            DataLakeResourceType::DataLocation => "DATA_LOCATION",
            DataLakeResourceType::LfTag => "LF_TAG",
            DataLakeResourceType::LfTagPolicy => "LF_TAG_POLICY",
            DataLakeResourceType::LfTagPolicyDatabase => "LF_TAG_POLICY_DATABASE",
            DataLakeResourceType::LfTagPolicyTable => "LF_TAG_POLICY_TABLE",
            DataLakeResourceType::Table => "TABLE",
            DataLakeResourceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CATALOG",
            "DATABASE",
            "DATA_LOCATION",
            "LF_TAG",
            "LF_TAG_POLICY",
            "LF_TAG_POLICY_DATABASE",
            "LF_TAG_POLICY_TABLE",
            "TABLE",
        ]
    }
}
impl AsRef<str> for DataLakeResourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ResourceShareType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let resourcesharetype = unimplemented!();
/// match resourcesharetype {
///     ResourceShareType::All => { /* ... */ },
///     ResourceShareType::Foreign => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `resourcesharetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ResourceShareType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ResourceShareType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ResourceShareType::NewFeature` is defined.
/// Specifically, when `resourcesharetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ResourceShareType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceShareType {
    #[allow(missing_docs)] // documentation missing in model
    All,
    #[allow(missing_docs)] // documentation missing in model
    Foreign,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ResourceShareType {
    fn from(s: &str) -> Self {
        match s {
            "ALL" => ResourceShareType::All,
            "FOREIGN" => ResourceShareType::Foreign,
            other => {
                ResourceShareType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ResourceShareType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResourceShareType::from(s))
    }
}
impl ResourceShareType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ResourceShareType::All => "ALL",
            ResourceShareType::Foreign => "FOREIGN",
            ResourceShareType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALL", "FOREIGN"]
    }
}
impl AsRef<str> for ResourceShareType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A structure that describes certain columns on certain rows.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataCellsFilter {
    /// <p>The ID of the catalog to which the table belongs.</p>
    #[doc(hidden)]
    pub table_catalog_id: std::option::Option<std::string::String>,
    /// <p>A database in the Glue Data Catalog.</p>
    #[doc(hidden)]
    pub database_name: std::option::Option<std::string::String>,
    /// <p>A table in the database.</p>
    #[doc(hidden)]
    pub table_name: std::option::Option<std::string::String>,
    /// <p>The name given by the user to the data filter cell.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A PartiQL predicate.</p>
    #[doc(hidden)]
    pub row_filter: std::option::Option<crate::model::RowFilter>,
    /// <p>A list of column names.</p>
    #[doc(hidden)]
    pub column_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A wildcard with exclusions.</p>
    /// <p>You must specify either a <code>ColumnNames</code> list or the <code>ColumnWildCard</code>. </p>
    #[doc(hidden)]
    pub column_wildcard: std::option::Option<crate::model::ColumnWildcard>,
}
impl DataCellsFilter {
    /// <p>The ID of the catalog to which the table belongs.</p>
    pub fn table_catalog_id(&self) -> std::option::Option<&str> {
        self.table_catalog_id.as_deref()
    }
    /// <p>A database in the Glue Data Catalog.</p>
    pub fn database_name(&self) -> std::option::Option<&str> {
        self.database_name.as_deref()
    }
    /// <p>A table in the database.</p>
    pub fn table_name(&self) -> std::option::Option<&str> {
        self.table_name.as_deref()
    }
    /// <p>The name given by the user to the data filter cell.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A PartiQL predicate.</p>
    pub fn row_filter(&self) -> std::option::Option<&crate::model::RowFilter> {
        self.row_filter.as_ref()
    }
    /// <p>A list of column names.</p>
    pub fn column_names(&self) -> std::option::Option<&[std::string::String]> {
        self.column_names.as_deref()
    }
    /// <p>A wildcard with exclusions.</p>
    /// <p>You must specify either a <code>ColumnNames</code> list or the <code>ColumnWildCard</code>. </p>
    pub fn column_wildcard(&self) -> std::option::Option<&crate::model::ColumnWildcard> {
        self.column_wildcard.as_ref()
    }
}
impl DataCellsFilter {
    /// Creates a new builder-style object to manufacture [`DataCellsFilter`](crate::model::DataCellsFilter).
    pub fn builder() -> crate::model::data_cells_filter::Builder {
        crate::model::data_cells_filter::Builder::default()
    }
}

/// See [`DataCellsFilter`](crate::model::DataCellsFilter).
pub mod data_cells_filter {

    /// A builder for [`DataCellsFilter`](crate::model::DataCellsFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) table_catalog_id: std::option::Option<std::string::String>,
        pub(crate) database_name: std::option::Option<std::string::String>,
        pub(crate) table_name: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) row_filter: std::option::Option<crate::model::RowFilter>,
        pub(crate) column_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) column_wildcard: std::option::Option<crate::model::ColumnWildcard>,
    }
    impl Builder {
        /// <p>The ID of the catalog to which the table belongs.</p>
        pub fn table_catalog_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.table_catalog_id = Some(input.into());
            self
        }
        /// <p>The ID of the catalog to which the table belongs.</p>
        pub fn set_table_catalog_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.table_catalog_id = input;
            self
        }
        /// <p>A database in the Glue Data Catalog.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.database_name = Some(input.into());
            self
        }
        /// <p>A database in the Glue Data Catalog.</p>
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.database_name = input;
            self
        }
        /// <p>A table in the database.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.table_name = Some(input.into());
            self
        }
        /// <p>A table in the database.</p>
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table_name = input;
            self
        }
        /// <p>The name given by the user to the data filter cell.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name given by the user to the data filter cell.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A PartiQL predicate.</p>
        pub fn row_filter(mut self, input: crate::model::RowFilter) -> Self {
            self.row_filter = Some(input);
            self
        }
        /// <p>A PartiQL predicate.</p>
        pub fn set_row_filter(
            mut self,
            input: std::option::Option<crate::model::RowFilter>,
        ) -> Self {
            self.row_filter = input;
            self
        }
        /// Appends an item to `column_names`.
        ///
        /// To override the contents of this collection use [`set_column_names`](Self::set_column_names).
        ///
        /// <p>A list of column names.</p>
        pub fn column_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.column_names.unwrap_or_default();
            v.push(input.into());
            self.column_names = Some(v);
            self
        }
        /// <p>A list of column names.</p>
        pub fn set_column_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.column_names = input;
            self
        }
        /// <p>A wildcard with exclusions.</p>
        /// <p>You must specify either a <code>ColumnNames</code> list or the <code>ColumnWildCard</code>. </p>
        pub fn column_wildcard(mut self, input: crate::model::ColumnWildcard) -> Self {
            self.column_wildcard = Some(input);
            self
        }
        /// <p>A wildcard with exclusions.</p>
        /// <p>You must specify either a <code>ColumnNames</code> list or the <code>ColumnWildCard</code>. </p>
        pub fn set_column_wildcard(
            mut self,
            input: std::option::Option<crate::model::ColumnWildcard>,
        ) -> Self {
            self.column_wildcard = input;
            self
        }
        /// Consumes the builder and constructs a [`DataCellsFilter`](crate::model::DataCellsFilter).
        pub fn build(self) -> crate::model::DataCellsFilter {
            crate::model::DataCellsFilter {
                table_catalog_id: self.table_catalog_id,
                database_name: self.database_name,
                table_name: self.table_name,
                name: self.name,
                row_filter: self.row_filter,
                column_names: self.column_names,
                column_wildcard: self.column_wildcard,
            }
        }
    }
}

/// <p>A PartiQL predicate.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RowFilter {
    /// <p>A filter expression.</p>
    #[doc(hidden)]
    pub filter_expression: std::option::Option<std::string::String>,
    /// <p>A wildcard for all rows.</p>
    #[doc(hidden)]
    pub all_rows_wildcard: std::option::Option<crate::model::AllRowsWildcard>,
}
impl RowFilter {
    /// <p>A filter expression.</p>
    pub fn filter_expression(&self) -> std::option::Option<&str> {
        self.filter_expression.as_deref()
    }
    /// <p>A wildcard for all rows.</p>
    pub fn all_rows_wildcard(&self) -> std::option::Option<&crate::model::AllRowsWildcard> {
        self.all_rows_wildcard.as_ref()
    }
}
impl RowFilter {
    /// Creates a new builder-style object to manufacture [`RowFilter`](crate::model::RowFilter).
    pub fn builder() -> crate::model::row_filter::Builder {
        crate::model::row_filter::Builder::default()
    }
}

/// See [`RowFilter`](crate::model::RowFilter).
pub mod row_filter {

    /// A builder for [`RowFilter`](crate::model::RowFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) filter_expression: std::option::Option<std::string::String>,
        pub(crate) all_rows_wildcard: std::option::Option<crate::model::AllRowsWildcard>,
    }
    impl Builder {
        /// <p>A filter expression.</p>
        pub fn filter_expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.filter_expression = Some(input.into());
            self
        }
        /// <p>A filter expression.</p>
        pub fn set_filter_expression(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.filter_expression = input;
            self
        }
        /// <p>A wildcard for all rows.</p>
        pub fn all_rows_wildcard(mut self, input: crate::model::AllRowsWildcard) -> Self {
            self.all_rows_wildcard = Some(input);
            self
        }
        /// <p>A wildcard for all rows.</p>
        pub fn set_all_rows_wildcard(
            mut self,
            input: std::option::Option<crate::model::AllRowsWildcard>,
        ) -> Self {
            self.all_rows_wildcard = input;
            self
        }
        /// Consumes the builder and constructs a [`RowFilter`](crate::model::RowFilter).
        pub fn build(self) -> crate::model::RowFilter {
            crate::model::RowFilter {
                filter_expression: self.filter_expression,
                all_rows_wildcard: self.all_rows_wildcard,
            }
        }
    }
}

/// <p>A structure that you pass to indicate you want all rows in a filter. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AllRowsWildcard {}
impl AllRowsWildcard {
    /// Creates a new builder-style object to manufacture [`AllRowsWildcard`](crate::model::AllRowsWildcard).
    pub fn builder() -> crate::model::all_rows_wildcard::Builder {
        crate::model::all_rows_wildcard::Builder::default()
    }
}

/// See [`AllRowsWildcard`](crate::model::AllRowsWildcard).
pub mod all_rows_wildcard {

    /// A builder for [`AllRowsWildcard`](crate::model::AllRowsWildcard).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`AllRowsWildcard`](crate::model::AllRowsWildcard).
        pub fn build(self) -> crate::model::AllRowsWildcard {
            crate::model::AllRowsWildcard {}
        }
    }
}

/// <p>Defines the valid range of work unit IDs for querying the execution service.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WorkUnitRange {
    /// <p>Defines the maximum work unit ID in the range. The maximum value is inclusive.</p>
    #[doc(hidden)]
    pub work_unit_id_max: i64,
    /// <p>Defines the minimum work unit ID in the range.</p>
    #[doc(hidden)]
    pub work_unit_id_min: i64,
    /// <p>A work token used to query the execution service.</p>
    #[doc(hidden)]
    pub work_unit_token: std::option::Option<std::string::String>,
}
impl WorkUnitRange {
    /// <p>Defines the maximum work unit ID in the range. The maximum value is inclusive.</p>
    pub fn work_unit_id_max(&self) -> i64 {
        self.work_unit_id_max
    }
    /// <p>Defines the minimum work unit ID in the range.</p>
    pub fn work_unit_id_min(&self) -> i64 {
        self.work_unit_id_min
    }
    /// <p>A work token used to query the execution service.</p>
    pub fn work_unit_token(&self) -> std::option::Option<&str> {
        self.work_unit_token.as_deref()
    }
}
impl WorkUnitRange {
    /// Creates a new builder-style object to manufacture [`WorkUnitRange`](crate::model::WorkUnitRange).
    pub fn builder() -> crate::model::work_unit_range::Builder {
        crate::model::work_unit_range::Builder::default()
    }
}

/// See [`WorkUnitRange`](crate::model::WorkUnitRange).
pub mod work_unit_range {

    /// A builder for [`WorkUnitRange`](crate::model::WorkUnitRange).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) work_unit_id_max: std::option::Option<i64>,
        pub(crate) work_unit_id_min: std::option::Option<i64>,
        pub(crate) work_unit_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Defines the maximum work unit ID in the range. The maximum value is inclusive.</p>
        pub fn work_unit_id_max(mut self, input: i64) -> Self {
            self.work_unit_id_max = Some(input);
            self
        }
        /// <p>Defines the maximum work unit ID in the range. The maximum value is inclusive.</p>
        pub fn set_work_unit_id_max(mut self, input: std::option::Option<i64>) -> Self {
            self.work_unit_id_max = input;
            self
        }
        /// <p>Defines the minimum work unit ID in the range.</p>
        pub fn work_unit_id_min(mut self, input: i64) -> Self {
            self.work_unit_id_min = Some(input);
            self
        }
        /// <p>Defines the minimum work unit ID in the range.</p>
        pub fn set_work_unit_id_min(mut self, input: std::option::Option<i64>) -> Self {
            self.work_unit_id_min = input;
            self
        }
        /// <p>A work token used to query the execution service.</p>
        pub fn work_unit_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.work_unit_token = Some(input.into());
            self
        }
        /// <p>A work token used to query the execution service.</p>
        pub fn set_work_unit_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.work_unit_token = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkUnitRange`](crate::model::WorkUnitRange).
        pub fn build(self) -> crate::model::WorkUnitRange {
            crate::model::WorkUnitRange {
                work_unit_id_max: self.work_unit_id_max.unwrap_or_default(),
                work_unit_id_min: self.work_unit_id_min.unwrap_or_default(),
                work_unit_token: self.work_unit_token,
            }
        }
    }
}

/// When writing a match expression against `PermissionType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let permissiontype = unimplemented!();
/// match permissiontype {
///     PermissionType::CellFilterPermission => { /* ... */ },
///     PermissionType::ColumnPermission => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `permissiontype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PermissionType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PermissionType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PermissionType::NewFeature` is defined.
/// Specifically, when `permissiontype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PermissionType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PermissionType {
    #[allow(missing_docs)] // documentation missing in model
    CellFilterPermission,
    #[allow(missing_docs)] // documentation missing in model
    ColumnPermission,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PermissionType {
    fn from(s: &str) -> Self {
        match s {
            "CELL_FILTER_PERMISSION" => PermissionType::CellFilterPermission,
            "COLUMN_PERMISSION" => PermissionType::ColumnPermission,
            other => PermissionType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PermissionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PermissionType::from(s))
    }
}
impl PermissionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PermissionType::CellFilterPermission => "CELL_FILTER_PERMISSION",
            PermissionType::ColumnPermission => "COLUMN_PERMISSION",
            PermissionType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CELL_FILTER_PERMISSION", "COLUMN_PERMISSION"]
    }
}
impl AsRef<str> for PermissionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A structure used to include auditing information on the privileged API. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AuditContext {
    /// <p>The filter engine can populate the 'AdditionalAuditContext' information with the request ID for you to track. This information will be displayed in CloudTrail log in your account.</p>
    #[doc(hidden)]
    pub additional_audit_context: std::option::Option<std::string::String>,
}
impl AuditContext {
    /// <p>The filter engine can populate the 'AdditionalAuditContext' information with the request ID for you to track. This information will be displayed in CloudTrail log in your account.</p>
    pub fn additional_audit_context(&self) -> std::option::Option<&str> {
        self.additional_audit_context.as_deref()
    }
}
impl AuditContext {
    /// Creates a new builder-style object to manufacture [`AuditContext`](crate::model::AuditContext).
    pub fn builder() -> crate::model::audit_context::Builder {
        crate::model::audit_context::Builder::default()
    }
}

/// See [`AuditContext`](crate::model::AuditContext).
pub mod audit_context {

    /// A builder for [`AuditContext`](crate::model::AuditContext).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) additional_audit_context: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The filter engine can populate the 'AdditionalAuditContext' information with the request ID for you to track. This information will be displayed in CloudTrail log in your account.</p>
        pub fn additional_audit_context(mut self, input: impl Into<std::string::String>) -> Self {
            self.additional_audit_context = Some(input.into());
            self
        }
        /// <p>The filter engine can populate the 'AdditionalAuditContext' information with the request ID for you to track. This information will be displayed in CloudTrail log in your account.</p>
        pub fn set_additional_audit_context(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.additional_audit_context = input;
            self
        }
        /// Consumes the builder and constructs a [`AuditContext`](crate::model::AuditContext).
        pub fn build(self) -> crate::model::AuditContext {
            crate::model::AuditContext {
                additional_audit_context: self.additional_audit_context,
            }
        }
    }
}

/// <p>Contains a list of values defining partitions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PartitionValueList {
    /// <p>The list of partition values.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl PartitionValueList {
    /// <p>The list of partition values.</p>
    pub fn values(&self) -> std::option::Option<&[std::string::String]> {
        self.values.as_deref()
    }
}
impl PartitionValueList {
    /// Creates a new builder-style object to manufacture [`PartitionValueList`](crate::model::PartitionValueList).
    pub fn builder() -> crate::model::partition_value_list::Builder {
        crate::model::partition_value_list::Builder::default()
    }
}

/// See [`PartitionValueList`](crate::model::PartitionValueList).
pub mod partition_value_list {

    /// A builder for [`PartitionValueList`](crate::model::PartitionValueList).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The list of partition values.</p>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        /// <p>The list of partition values.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`PartitionValueList`](crate::model::PartitionValueList).
        pub fn build(self) -> crate::model::PartitionValueList {
            crate::model::PartitionValueList {
                values: self.values,
            }
        }
    }
}

/// <p>A structure containing a list of partition values and table objects.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PartitionObjects {
    /// <p>A list of partition values.</p>
    #[doc(hidden)]
    pub partition_values: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of table objects</p>
    #[doc(hidden)]
    pub objects: std::option::Option<std::vec::Vec<crate::model::TableObject>>,
}
impl PartitionObjects {
    /// <p>A list of partition values.</p>
    pub fn partition_values(&self) -> std::option::Option<&[std::string::String]> {
        self.partition_values.as_deref()
    }
    /// <p>A list of table objects</p>
    pub fn objects(&self) -> std::option::Option<&[crate::model::TableObject]> {
        self.objects.as_deref()
    }
}
impl PartitionObjects {
    /// Creates a new builder-style object to manufacture [`PartitionObjects`](crate::model::PartitionObjects).
    pub fn builder() -> crate::model::partition_objects::Builder {
        crate::model::partition_objects::Builder::default()
    }
}

/// See [`PartitionObjects`](crate::model::PartitionObjects).
pub mod partition_objects {

    /// A builder for [`PartitionObjects`](crate::model::PartitionObjects).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) partition_values: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) objects: std::option::Option<std::vec::Vec<crate::model::TableObject>>,
    }
    impl Builder {
        /// Appends an item to `partition_values`.
        ///
        /// To override the contents of this collection use [`set_partition_values`](Self::set_partition_values).
        ///
        /// <p>A list of partition values.</p>
        pub fn partition_values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.partition_values.unwrap_or_default();
            v.push(input.into());
            self.partition_values = Some(v);
            self
        }
        /// <p>A list of partition values.</p>
        pub fn set_partition_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.partition_values = input;
            self
        }
        /// Appends an item to `objects`.
        ///
        /// To override the contents of this collection use [`set_objects`](Self::set_objects).
        ///
        /// <p>A list of table objects</p>
        pub fn objects(mut self, input: crate::model::TableObject) -> Self {
            let mut v = self.objects.unwrap_or_default();
            v.push(input);
            self.objects = Some(v);
            self
        }
        /// <p>A list of table objects</p>
        pub fn set_objects(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TableObject>>,
        ) -> Self {
            self.objects = input;
            self
        }
        /// Consumes the builder and constructs a [`PartitionObjects`](crate::model::PartitionObjects).
        pub fn build(self) -> crate::model::PartitionObjects {
            crate::model::PartitionObjects {
                partition_values: self.partition_values,
                objects: self.objects,
            }
        }
    }
}

/// <p>Specifies the details of a governed table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableObject {
    /// <p>The Amazon S3 location of the object.</p>
    #[doc(hidden)]
    pub uri: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 ETag of the object. Returned by <code>GetTableObjects</code> for validation and used to identify changes to the underlying data.</p>
    #[doc(hidden)]
    pub e_tag: std::option::Option<std::string::String>,
    /// <p>The size of the Amazon S3 object in bytes.</p>
    #[doc(hidden)]
    pub size: i64,
}
impl TableObject {
    /// <p>The Amazon S3 location of the object.</p>
    pub fn uri(&self) -> std::option::Option<&str> {
        self.uri.as_deref()
    }
    /// <p>The Amazon S3 ETag of the object. Returned by <code>GetTableObjects</code> for validation and used to identify changes to the underlying data.</p>
    pub fn e_tag(&self) -> std::option::Option<&str> {
        self.e_tag.as_deref()
    }
    /// <p>The size of the Amazon S3 object in bytes.</p>
    pub fn size(&self) -> i64 {
        self.size
    }
}
impl TableObject {
    /// Creates a new builder-style object to manufacture [`TableObject`](crate::model::TableObject).
    pub fn builder() -> crate::model::table_object::Builder {
        crate::model::table_object::Builder::default()
    }
}

/// See [`TableObject`](crate::model::TableObject).
pub mod table_object {

    /// A builder for [`TableObject`](crate::model::TableObject).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) uri: std::option::Option<std::string::String>,
        pub(crate) e_tag: std::option::Option<std::string::String>,
        pub(crate) size: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The Amazon S3 location of the object.</p>
        pub fn uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.uri = Some(input.into());
            self
        }
        /// <p>The Amazon S3 location of the object.</p>
        pub fn set_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.uri = input;
            self
        }
        /// <p>The Amazon S3 ETag of the object. Returned by <code>GetTableObjects</code> for validation and used to identify changes to the underlying data.</p>
        pub fn e_tag(mut self, input: impl Into<std::string::String>) -> Self {
            self.e_tag = Some(input.into());
            self
        }
        /// <p>The Amazon S3 ETag of the object. Returned by <code>GetTableObjects</code> for validation and used to identify changes to the underlying data.</p>
        pub fn set_e_tag(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.e_tag = input;
            self
        }
        /// <p>The size of the Amazon S3 object in bytes.</p>
        pub fn size(mut self, input: i64) -> Self {
            self.size = Some(input);
            self
        }
        /// <p>The size of the Amazon S3 object in bytes.</p>
        pub fn set_size(mut self, input: std::option::Option<i64>) -> Self {
            self.size = input;
            self
        }
        /// Consumes the builder and constructs a [`TableObject`](crate::model::TableObject).
        pub fn build(self) -> crate::model::TableObject {
            crate::model::TableObject {
                uri: self.uri,
                e_tag: self.e_tag,
                size: self.size.unwrap_or_default(),
            }
        }
    }
}

/// <p>Statistics related to the processing of a query statement.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PlanningStatistics {
    /// <p>An estimate of the data that was scanned in bytes.</p>
    #[doc(hidden)]
    pub estimated_data_to_scan_bytes: i64,
    /// <p>The time that it took to process the request.</p>
    #[doc(hidden)]
    pub planning_time_millis: i64,
    /// <p>The time the request was in queue to be processed.</p>
    #[doc(hidden)]
    pub queue_time_millis: i64,
    /// <p>The number of work units generated.</p>
    #[doc(hidden)]
    pub work_units_generated_count: i64,
}
impl PlanningStatistics {
    /// <p>An estimate of the data that was scanned in bytes.</p>
    pub fn estimated_data_to_scan_bytes(&self) -> i64 {
        self.estimated_data_to_scan_bytes
    }
    /// <p>The time that it took to process the request.</p>
    pub fn planning_time_millis(&self) -> i64 {
        self.planning_time_millis
    }
    /// <p>The time the request was in queue to be processed.</p>
    pub fn queue_time_millis(&self) -> i64 {
        self.queue_time_millis
    }
    /// <p>The number of work units generated.</p>
    pub fn work_units_generated_count(&self) -> i64 {
        self.work_units_generated_count
    }
}
impl PlanningStatistics {
    /// Creates a new builder-style object to manufacture [`PlanningStatistics`](crate::model::PlanningStatistics).
    pub fn builder() -> crate::model::planning_statistics::Builder {
        crate::model::planning_statistics::Builder::default()
    }
}

/// See [`PlanningStatistics`](crate::model::PlanningStatistics).
pub mod planning_statistics {

    /// A builder for [`PlanningStatistics`](crate::model::PlanningStatistics).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) estimated_data_to_scan_bytes: std::option::Option<i64>,
        pub(crate) planning_time_millis: std::option::Option<i64>,
        pub(crate) queue_time_millis: std::option::Option<i64>,
        pub(crate) work_units_generated_count: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>An estimate of the data that was scanned in bytes.</p>
        pub fn estimated_data_to_scan_bytes(mut self, input: i64) -> Self {
            self.estimated_data_to_scan_bytes = Some(input);
            self
        }
        /// <p>An estimate of the data that was scanned in bytes.</p>
        pub fn set_estimated_data_to_scan_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.estimated_data_to_scan_bytes = input;
            self
        }
        /// <p>The time that it took to process the request.</p>
        pub fn planning_time_millis(mut self, input: i64) -> Self {
            self.planning_time_millis = Some(input);
            self
        }
        /// <p>The time that it took to process the request.</p>
        pub fn set_planning_time_millis(mut self, input: std::option::Option<i64>) -> Self {
            self.planning_time_millis = input;
            self
        }
        /// <p>The time the request was in queue to be processed.</p>
        pub fn queue_time_millis(mut self, input: i64) -> Self {
            self.queue_time_millis = Some(input);
            self
        }
        /// <p>The time the request was in queue to be processed.</p>
        pub fn set_queue_time_millis(mut self, input: std::option::Option<i64>) -> Self {
            self.queue_time_millis = input;
            self
        }
        /// <p>The number of work units generated.</p>
        pub fn work_units_generated_count(mut self, input: i64) -> Self {
            self.work_units_generated_count = Some(input);
            self
        }
        /// <p>The number of work units generated.</p>
        pub fn set_work_units_generated_count(mut self, input: std::option::Option<i64>) -> Self {
            self.work_units_generated_count = input;
            self
        }
        /// Consumes the builder and constructs a [`PlanningStatistics`](crate::model::PlanningStatistics).
        pub fn build(self) -> crate::model::PlanningStatistics {
            crate::model::PlanningStatistics {
                estimated_data_to_scan_bytes: self.estimated_data_to_scan_bytes.unwrap_or_default(),
                planning_time_millis: self.planning_time_millis.unwrap_or_default(),
                queue_time_millis: self.queue_time_millis.unwrap_or_default(),
                work_units_generated_count: self.work_units_generated_count.unwrap_or_default(),
            }
        }
    }
}

/// <p>Statistics related to the processing of a query statement.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExecutionStatistics {
    /// <p>The average time the request took to be executed.</p>
    #[doc(hidden)]
    pub average_execution_time_millis: i64,
    /// <p>The amount of data that was scanned in bytes.</p>
    #[doc(hidden)]
    pub data_scanned_bytes: i64,
    /// <p>The number of work units executed.</p>
    #[doc(hidden)]
    pub work_units_executed_count: i64,
}
impl ExecutionStatistics {
    /// <p>The average time the request took to be executed.</p>
    pub fn average_execution_time_millis(&self) -> i64 {
        self.average_execution_time_millis
    }
    /// <p>The amount of data that was scanned in bytes.</p>
    pub fn data_scanned_bytes(&self) -> i64 {
        self.data_scanned_bytes
    }
    /// <p>The number of work units executed.</p>
    pub fn work_units_executed_count(&self) -> i64 {
        self.work_units_executed_count
    }
}
impl ExecutionStatistics {
    /// Creates a new builder-style object to manufacture [`ExecutionStatistics`](crate::model::ExecutionStatistics).
    pub fn builder() -> crate::model::execution_statistics::Builder {
        crate::model::execution_statistics::Builder::default()
    }
}

/// See [`ExecutionStatistics`](crate::model::ExecutionStatistics).
pub mod execution_statistics {

    /// A builder for [`ExecutionStatistics`](crate::model::ExecutionStatistics).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) average_execution_time_millis: std::option::Option<i64>,
        pub(crate) data_scanned_bytes: std::option::Option<i64>,
        pub(crate) work_units_executed_count: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The average time the request took to be executed.</p>
        pub fn average_execution_time_millis(mut self, input: i64) -> Self {
            self.average_execution_time_millis = Some(input);
            self
        }
        /// <p>The average time the request took to be executed.</p>
        pub fn set_average_execution_time_millis(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.average_execution_time_millis = input;
            self
        }
        /// <p>The amount of data that was scanned in bytes.</p>
        pub fn data_scanned_bytes(mut self, input: i64) -> Self {
            self.data_scanned_bytes = Some(input);
            self
        }
        /// <p>The amount of data that was scanned in bytes.</p>
        pub fn set_data_scanned_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.data_scanned_bytes = input;
            self
        }
        /// <p>The number of work units executed.</p>
        pub fn work_units_executed_count(mut self, input: i64) -> Self {
            self.work_units_executed_count = Some(input);
            self
        }
        /// <p>The number of work units executed.</p>
        pub fn set_work_units_executed_count(mut self, input: std::option::Option<i64>) -> Self {
            self.work_units_executed_count = input;
            self
        }
        /// Consumes the builder and constructs a [`ExecutionStatistics`](crate::model::ExecutionStatistics).
        pub fn build(self) -> crate::model::ExecutionStatistics {
            crate::model::ExecutionStatistics {
                average_execution_time_millis: self
                    .average_execution_time_millis
                    .unwrap_or_default(),
                data_scanned_bytes: self.data_scanned_bytes.unwrap_or_default(),
                work_units_executed_count: self.work_units_executed_count.unwrap_or_default(),
            }
        }
    }
}

/// When writing a match expression against `QueryStateString`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let querystatestring = unimplemented!();
/// match querystatestring {
///     QueryStateString::Error => { /* ... */ },
///     QueryStateString::Expired => { /* ... */ },
///     QueryStateString::Finished => { /* ... */ },
///     QueryStateString::Pending => { /* ... */ },
///     QueryStateString::WorkunitsAvailable => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `querystatestring` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `QueryStateString::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `QueryStateString::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `QueryStateString::NewFeature` is defined.
/// Specifically, when `querystatestring` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `QueryStateString::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum QueryStateString {
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    Expired,
    #[allow(missing_docs)] // documentation missing in model
    Finished,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    WorkunitsAvailable,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for QueryStateString {
    fn from(s: &str) -> Self {
        match s {
            "ERROR" => QueryStateString::Error,
            "EXPIRED" => QueryStateString::Expired,
            "FINISHED" => QueryStateString::Finished,
            "PENDING" => QueryStateString::Pending,
            "WORKUNITS_AVAILABLE" => QueryStateString::WorkunitsAvailable,
            other => QueryStateString::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for QueryStateString {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(QueryStateString::from(s))
    }
}
impl QueryStateString {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            QueryStateString::Error => "ERROR",
            QueryStateString::Expired => "EXPIRED",
            QueryStateString::Finished => "FINISHED",
            QueryStateString::Pending => "PENDING",
            QueryStateString::WorkunitsAvailable => "WORKUNITS_AVAILABLE",
            QueryStateString::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ERROR",
            "EXPIRED",
            "FINISHED",
            "PENDING",
            "WORKUNITS_AVAILABLE",
        ]
    }
}
impl AsRef<str> for QueryStateString {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object that defines an Amazon S3 object to be deleted if a transaction cancels, provided that <code>VirtualPut</code> was called before writing the object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VirtualObject {
    /// <p>The path to the Amazon S3 object. Must start with s3://</p>
    #[doc(hidden)]
    pub uri: std::option::Option<std::string::String>,
    /// <p>The ETag of the Amazon S3 object.</p>
    #[doc(hidden)]
    pub e_tag: std::option::Option<std::string::String>,
}
impl VirtualObject {
    /// <p>The path to the Amazon S3 object. Must start with s3://</p>
    pub fn uri(&self) -> std::option::Option<&str> {
        self.uri.as_deref()
    }
    /// <p>The ETag of the Amazon S3 object.</p>
    pub fn e_tag(&self) -> std::option::Option<&str> {
        self.e_tag.as_deref()
    }
}
impl VirtualObject {
    /// Creates a new builder-style object to manufacture [`VirtualObject`](crate::model::VirtualObject).
    pub fn builder() -> crate::model::virtual_object::Builder {
        crate::model::virtual_object::Builder::default()
    }
}

/// See [`VirtualObject`](crate::model::VirtualObject).
pub mod virtual_object {

    /// A builder for [`VirtualObject`](crate::model::VirtualObject).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) uri: std::option::Option<std::string::String>,
        pub(crate) e_tag: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The path to the Amazon S3 object. Must start with s3://</p>
        pub fn uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.uri = Some(input.into());
            self
        }
        /// <p>The path to the Amazon S3 object. Must start with s3://</p>
        pub fn set_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.uri = input;
            self
        }
        /// <p>The ETag of the Amazon S3 object.</p>
        pub fn e_tag(mut self, input: impl Into<std::string::String>) -> Self {
            self.e_tag = Some(input.into());
            self
        }
        /// <p>The ETag of the Amazon S3 object.</p>
        pub fn set_e_tag(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.e_tag = input;
            self
        }
        /// Consumes the builder and constructs a [`VirtualObject`](crate::model::VirtualObject).
        pub fn build(self) -> crate::model::VirtualObject {
            crate::model::VirtualObject {
                uri: self.uri,
                e_tag: self.e_tag,
            }
        }
    }
}

/// <p>A list of failures when performing a batch grant or batch revoke operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchPermissionsFailureEntry {
    /// <p>An identifier for an entry of the batch request.</p>
    #[doc(hidden)]
    pub request_entry: std::option::Option<crate::model::BatchPermissionsRequestEntry>,
    /// <p>An error message that applies to the failure of the entry.</p>
    #[doc(hidden)]
    pub error: std::option::Option<crate::model::ErrorDetail>,
}
impl BatchPermissionsFailureEntry {
    /// <p>An identifier for an entry of the batch request.</p>
    pub fn request_entry(
        &self,
    ) -> std::option::Option<&crate::model::BatchPermissionsRequestEntry> {
        self.request_entry.as_ref()
    }
    /// <p>An error message that applies to the failure of the entry.</p>
    pub fn error(&self) -> std::option::Option<&crate::model::ErrorDetail> {
        self.error.as_ref()
    }
}
impl BatchPermissionsFailureEntry {
    /// Creates a new builder-style object to manufacture [`BatchPermissionsFailureEntry`](crate::model::BatchPermissionsFailureEntry).
    pub fn builder() -> crate::model::batch_permissions_failure_entry::Builder {
        crate::model::batch_permissions_failure_entry::Builder::default()
    }
}

/// See [`BatchPermissionsFailureEntry`](crate::model::BatchPermissionsFailureEntry).
pub mod batch_permissions_failure_entry {

    /// A builder for [`BatchPermissionsFailureEntry`](crate::model::BatchPermissionsFailureEntry).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) request_entry: std::option::Option<crate::model::BatchPermissionsRequestEntry>,
        pub(crate) error: std::option::Option<crate::model::ErrorDetail>,
    }
    impl Builder {
        /// <p>An identifier for an entry of the batch request.</p>
        pub fn request_entry(mut self, input: crate::model::BatchPermissionsRequestEntry) -> Self {
            self.request_entry = Some(input);
            self
        }
        /// <p>An identifier for an entry of the batch request.</p>
        pub fn set_request_entry(
            mut self,
            input: std::option::Option<crate::model::BatchPermissionsRequestEntry>,
        ) -> Self {
            self.request_entry = input;
            self
        }
        /// <p>An error message that applies to the failure of the entry.</p>
        pub fn error(mut self, input: crate::model::ErrorDetail) -> Self {
            self.error = Some(input);
            self
        }
        /// <p>An error message that applies to the failure of the entry.</p>
        pub fn set_error(mut self, input: std::option::Option<crate::model::ErrorDetail>) -> Self {
            self.error = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchPermissionsFailureEntry`](crate::model::BatchPermissionsFailureEntry).
        pub fn build(self) -> crate::model::BatchPermissionsFailureEntry {
            crate::model::BatchPermissionsFailureEntry {
                request_entry: self.request_entry,
                error: self.error,
            }
        }
    }
}

/// <p>A permission to a resource granted by batch operation to the principal.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchPermissionsRequestEntry {
    /// <p>A unique identifier for the batch permissions request entry.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The principal to be granted a permission.</p>
    #[doc(hidden)]
    pub principal: std::option::Option<crate::model::DataLakePrincipal>,
    /// <p>The resource to which the principal is to be granted a permission.</p>
    #[doc(hidden)]
    pub resource: std::option::Option<crate::model::Resource>,
    /// <p>The permissions to be granted.</p>
    #[doc(hidden)]
    pub permissions: std::option::Option<std::vec::Vec<crate::model::Permission>>,
    /// <p>Indicates if the option to pass permissions is granted.</p>
    #[doc(hidden)]
    pub permissions_with_grant_option: std::option::Option<std::vec::Vec<crate::model::Permission>>,
}
impl BatchPermissionsRequestEntry {
    /// <p>A unique identifier for the batch permissions request entry.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The principal to be granted a permission.</p>
    pub fn principal(&self) -> std::option::Option<&crate::model::DataLakePrincipal> {
        self.principal.as_ref()
    }
    /// <p>The resource to which the principal is to be granted a permission.</p>
    pub fn resource(&self) -> std::option::Option<&crate::model::Resource> {
        self.resource.as_ref()
    }
    /// <p>The permissions to be granted.</p>
    pub fn permissions(&self) -> std::option::Option<&[crate::model::Permission]> {
        self.permissions.as_deref()
    }
    /// <p>Indicates if the option to pass permissions is granted.</p>
    pub fn permissions_with_grant_option(
        &self,
    ) -> std::option::Option<&[crate::model::Permission]> {
        self.permissions_with_grant_option.as_deref()
    }
}
impl BatchPermissionsRequestEntry {
    /// Creates a new builder-style object to manufacture [`BatchPermissionsRequestEntry`](crate::model::BatchPermissionsRequestEntry).
    pub fn builder() -> crate::model::batch_permissions_request_entry::Builder {
        crate::model::batch_permissions_request_entry::Builder::default()
    }
}

/// See [`BatchPermissionsRequestEntry`](crate::model::BatchPermissionsRequestEntry).
pub mod batch_permissions_request_entry {

    /// A builder for [`BatchPermissionsRequestEntry`](crate::model::BatchPermissionsRequestEntry).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) principal: std::option::Option<crate::model::DataLakePrincipal>,
        pub(crate) resource: std::option::Option<crate::model::Resource>,
        pub(crate) permissions: std::option::Option<std::vec::Vec<crate::model::Permission>>,
        pub(crate) permissions_with_grant_option:
            std::option::Option<std::vec::Vec<crate::model::Permission>>,
    }
    impl Builder {
        /// <p>A unique identifier for the batch permissions request entry.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the batch permissions request entry.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The principal to be granted a permission.</p>
        pub fn principal(mut self, input: crate::model::DataLakePrincipal) -> Self {
            self.principal = Some(input);
            self
        }
        /// <p>The principal to be granted a permission.</p>
        pub fn set_principal(
            mut self,
            input: std::option::Option<crate::model::DataLakePrincipal>,
        ) -> Self {
            self.principal = input;
            self
        }
        /// <p>The resource to which the principal is to be granted a permission.</p>
        pub fn resource(mut self, input: crate::model::Resource) -> Self {
            self.resource = Some(input);
            self
        }
        /// <p>The resource to which the principal is to be granted a permission.</p>
        pub fn set_resource(mut self, input: std::option::Option<crate::model::Resource>) -> Self {
            self.resource = input;
            self
        }
        /// Appends an item to `permissions`.
        ///
        /// To override the contents of this collection use [`set_permissions`](Self::set_permissions).
        ///
        /// <p>The permissions to be granted.</p>
        pub fn permissions(mut self, input: crate::model::Permission) -> Self {
            let mut v = self.permissions.unwrap_or_default();
            v.push(input);
            self.permissions = Some(v);
            self
        }
        /// <p>The permissions to be granted.</p>
        pub fn set_permissions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Permission>>,
        ) -> Self {
            self.permissions = input;
            self
        }
        /// Appends an item to `permissions_with_grant_option`.
        ///
        /// To override the contents of this collection use [`set_permissions_with_grant_option`](Self::set_permissions_with_grant_option).
        ///
        /// <p>Indicates if the option to pass permissions is granted.</p>
        pub fn permissions_with_grant_option(mut self, input: crate::model::Permission) -> Self {
            let mut v = self.permissions_with_grant_option.unwrap_or_default();
            v.push(input);
            self.permissions_with_grant_option = Some(v);
            self
        }
        /// <p>Indicates if the option to pass permissions is granted.</p>
        pub fn set_permissions_with_grant_option(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Permission>>,
        ) -> Self {
            self.permissions_with_grant_option = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchPermissionsRequestEntry`](crate::model::BatchPermissionsRequestEntry).
        pub fn build(self) -> crate::model::BatchPermissionsRequestEntry {
            crate::model::BatchPermissionsRequestEntry {
                id: self.id,
                principal: self.principal,
                resource: self.resource,
                permissions: self.permissions,
                permissions_with_grant_option: self.permissions_with_grant_option,
            }
        }
    }
}
