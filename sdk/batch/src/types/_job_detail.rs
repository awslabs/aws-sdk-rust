// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>An object that represents an Batch job.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct JobDetail {
    /// <p>The Amazon Resource Name (ARN) of the job.</p>
    pub job_arn: ::std::option::Option<::std::string::String>,
    /// <p>The job name.</p>
    pub job_name: ::std::option::Option<::std::string::String>,
    /// <p>The job ID.</p>
    pub job_id: ::std::option::Option<::std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the job queue that the job is associated with.</p>
    pub job_queue: ::std::option::Option<::std::string::String>,
    /// <p>The current status for the job.</p> <note>
    /// <p>If your jobs don't progress to <code>STARTING</code>, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/troubleshooting.html#job_stuck_in_runnable">Jobs stuck in RUNNABLE status</a> in the troubleshooting section of the <i>Batch User Guide</i>.</p>
    /// </note>
    pub status: ::std::option::Option<crate::types::JobStatus>,
    /// <p>The share identifier for the job.</p>
    pub share_identifier: ::std::option::Option<::std::string::String>,
    /// <p>The scheduling policy of the job definition. This only affects jobs in job queues with a fair share policy. Jobs with a higher scheduling priority are scheduled before jobs with a lower scheduling priority.</p>
    pub scheduling_priority: ::std::option::Option<i32>,
    /// <p>A list of job attempts that are associated with this job.</p>
    pub attempts: ::std::option::Option<::std::vec::Vec<crate::types::AttemptDetail>>,
    /// <p>A short, human-readable string to provide more details for the current status of the job.</p>
    pub status_reason: ::std::option::Option<::std::string::String>,
    /// <p>The Unix timestamp (in milliseconds) for when the job was created. For non-array jobs and parent array jobs, this is when the job entered the <code>SUBMITTED</code> state. This is specifically at the time <code>SubmitJob</code> was called. For array child jobs, this is when the child job was spawned by its parent and entered the <code>PENDING</code> state.</p>
    pub created_at: ::std::option::Option<i64>,
    /// <p>The retry strategy to use for this job if an attempt fails.</p>
    pub retry_strategy: ::std::option::Option<crate::types::RetryStrategy>,
    /// <p>The Unix timestamp (in milliseconds) for when the job was started. More specifically, it's when the job transitioned from the <code>STARTING</code> state to the <code>RUNNING</code> state. This parameter isn't provided for child jobs of array jobs or multi-node parallel jobs.</p>
    pub started_at: ::std::option::Option<i64>,
    /// <p>The Unix timestamp (in milliseconds) for when the job was stopped. More specifically, it's when the job transitioned from the <code>RUNNING</code> state to a terminal state, such as <code>SUCCEEDED</code> or <code>FAILED</code>.</p>
    pub stopped_at: ::std::option::Option<i64>,
    /// <p>A list of job IDs that this job depends on.</p>
    pub depends_on: ::std::option::Option<::std::vec::Vec<crate::types::JobDependency>>,
    /// <p>The Amazon Resource Name (ARN) of the job definition that this job uses.</p>
    pub job_definition: ::std::option::Option<::std::string::String>,
    /// <p>Additional parameters that are passed to the job that replace parameter substitution placeholders or override any corresponding parameter defaults from the job definition.</p>
    pub parameters: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    /// <p>An object that represents the details for the container that's associated with the job.</p>
    pub container: ::std::option::Option<crate::types::ContainerDetail>,
    /// <p>An object that represents the details of a node that's associated with a multi-node parallel job.</p>
    pub node_details: ::std::option::Option<crate::types::NodeDetails>,
    /// <p>An object that represents the node properties of a multi-node parallel job.</p> <note>
    /// <p>This isn't applicable to jobs that are running on Fargate resources.</p>
    /// </note>
    pub node_properties: ::std::option::Option<crate::types::NodeProperties>,
    /// <p>The array properties of the job, if it's an array job.</p>
    pub array_properties: ::std::option::Option<crate::types::ArrayPropertiesDetail>,
    /// <p>The timeout configuration for the job.</p>
    pub timeout: ::std::option::Option<crate::types::JobTimeout>,
    /// <p>The tags that are applied to the job.</p>
    pub tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    /// <p>Specifies whether to propagate the tags from the job or job definition to the corresponding Amazon ECS task. If no value is specified, the tags aren't propagated. Tags can only be propagated to the tasks when the tasks are created. For tags with the same name, job tags are given priority over job definitions tags. If the total number of combined tags from the job and job definition is over 50, the job is moved to the <code>FAILED</code> state.</p>
    pub propagate_tags: ::std::option::Option<bool>,
    /// <p>The platform capabilities required by the job definition. If no value is specified, it defaults to <code>EC2</code>. Jobs run on Fargate resources specify <code>FARGATE</code>.</p>
    pub platform_capabilities: ::std::option::Option<::std::vec::Vec<crate::types::PlatformCapability>>,
    /// <p>An object with various properties that are specific to Amazon EKS based jobs. Only one of <code>container</code>, <code>eksProperties</code>, or <code>nodeDetails</code> is specified.</p>
    pub eks_properties: ::std::option::Option<crate::types::EksPropertiesDetail>,
    /// <p>A list of job attempts that are associated with this job.</p>
    pub eks_attempts: ::std::option::Option<::std::vec::Vec<crate::types::EksAttemptDetail>>,
    /// <p>Indicates whether the job is canceled.</p>
    pub is_cancelled: ::std::option::Option<bool>,
    /// <p>Indicates whether the job is terminated.</p>
    pub is_terminated: ::std::option::Option<bool>,
}
impl JobDetail {
    /// <p>The Amazon Resource Name (ARN) of the job.</p>
    pub fn job_arn(&self) -> ::std::option::Option<&str> {
        self.job_arn.as_deref()
    }
    /// <p>The job name.</p>
    pub fn job_name(&self) -> ::std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>The job ID.</p>
    pub fn job_id(&self) -> ::std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the job queue that the job is associated with.</p>
    pub fn job_queue(&self) -> ::std::option::Option<&str> {
        self.job_queue.as_deref()
    }
    /// <p>The current status for the job.</p> <note>
    /// <p>If your jobs don't progress to <code>STARTING</code>, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/troubleshooting.html#job_stuck_in_runnable">Jobs stuck in RUNNABLE status</a> in the troubleshooting section of the <i>Batch User Guide</i>.</p>
    /// </note>
    pub fn status(&self) -> ::std::option::Option<&crate::types::JobStatus> {
        self.status.as_ref()
    }
    /// <p>The share identifier for the job.</p>
    pub fn share_identifier(&self) -> ::std::option::Option<&str> {
        self.share_identifier.as_deref()
    }
    /// <p>The scheduling policy of the job definition. This only affects jobs in job queues with a fair share policy. Jobs with a higher scheduling priority are scheduled before jobs with a lower scheduling priority.</p>
    pub fn scheduling_priority(&self) -> ::std::option::Option<i32> {
        self.scheduling_priority
    }
    /// <p>A list of job attempts that are associated with this job.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.attempts.is_none()`.
    pub fn attempts(&self) -> &[crate::types::AttemptDetail] {
        self.attempts.as_deref().unwrap_or_default()
    }
    /// <p>A short, human-readable string to provide more details for the current status of the job.</p>
    pub fn status_reason(&self) -> ::std::option::Option<&str> {
        self.status_reason.as_deref()
    }
    /// <p>The Unix timestamp (in milliseconds) for when the job was created. For non-array jobs and parent array jobs, this is when the job entered the <code>SUBMITTED</code> state. This is specifically at the time <code>SubmitJob</code> was called. For array child jobs, this is when the child job was spawned by its parent and entered the <code>PENDING</code> state.</p>
    pub fn created_at(&self) -> ::std::option::Option<i64> {
        self.created_at
    }
    /// <p>The retry strategy to use for this job if an attempt fails.</p>
    pub fn retry_strategy(&self) -> ::std::option::Option<&crate::types::RetryStrategy> {
        self.retry_strategy.as_ref()
    }
    /// <p>The Unix timestamp (in milliseconds) for when the job was started. More specifically, it's when the job transitioned from the <code>STARTING</code> state to the <code>RUNNING</code> state. This parameter isn't provided for child jobs of array jobs or multi-node parallel jobs.</p>
    pub fn started_at(&self) -> ::std::option::Option<i64> {
        self.started_at
    }
    /// <p>The Unix timestamp (in milliseconds) for when the job was stopped. More specifically, it's when the job transitioned from the <code>RUNNING</code> state to a terminal state, such as <code>SUCCEEDED</code> or <code>FAILED</code>.</p>
    pub fn stopped_at(&self) -> ::std::option::Option<i64> {
        self.stopped_at
    }
    /// <p>A list of job IDs that this job depends on.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.depends_on.is_none()`.
    pub fn depends_on(&self) -> &[crate::types::JobDependency] {
        self.depends_on.as_deref().unwrap_or_default()
    }
    /// <p>The Amazon Resource Name (ARN) of the job definition that this job uses.</p>
    pub fn job_definition(&self) -> ::std::option::Option<&str> {
        self.job_definition.as_deref()
    }
    /// <p>Additional parameters that are passed to the job that replace parameter substitution placeholders or override any corresponding parameter defaults from the job definition.</p>
    pub fn parameters(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.parameters.as_ref()
    }
    /// <p>An object that represents the details for the container that's associated with the job.</p>
    pub fn container(&self) -> ::std::option::Option<&crate::types::ContainerDetail> {
        self.container.as_ref()
    }
    /// <p>An object that represents the details of a node that's associated with a multi-node parallel job.</p>
    pub fn node_details(&self) -> ::std::option::Option<&crate::types::NodeDetails> {
        self.node_details.as_ref()
    }
    /// <p>An object that represents the node properties of a multi-node parallel job.</p> <note>
    /// <p>This isn't applicable to jobs that are running on Fargate resources.</p>
    /// </note>
    pub fn node_properties(&self) -> ::std::option::Option<&crate::types::NodeProperties> {
        self.node_properties.as_ref()
    }
    /// <p>The array properties of the job, if it's an array job.</p>
    pub fn array_properties(&self) -> ::std::option::Option<&crate::types::ArrayPropertiesDetail> {
        self.array_properties.as_ref()
    }
    /// <p>The timeout configuration for the job.</p>
    pub fn timeout(&self) -> ::std::option::Option<&crate::types::JobTimeout> {
        self.timeout.as_ref()
    }
    /// <p>The tags that are applied to the job.</p>
    pub fn tags(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.tags.as_ref()
    }
    /// <p>Specifies whether to propagate the tags from the job or job definition to the corresponding Amazon ECS task. If no value is specified, the tags aren't propagated. Tags can only be propagated to the tasks when the tasks are created. For tags with the same name, job tags are given priority over job definitions tags. If the total number of combined tags from the job and job definition is over 50, the job is moved to the <code>FAILED</code> state.</p>
    pub fn propagate_tags(&self) -> ::std::option::Option<bool> {
        self.propagate_tags
    }
    /// <p>The platform capabilities required by the job definition. If no value is specified, it defaults to <code>EC2</code>. Jobs run on Fargate resources specify <code>FARGATE</code>.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.platform_capabilities.is_none()`.
    pub fn platform_capabilities(&self) -> &[crate::types::PlatformCapability] {
        self.platform_capabilities.as_deref().unwrap_or_default()
    }
    /// <p>An object with various properties that are specific to Amazon EKS based jobs. Only one of <code>container</code>, <code>eksProperties</code>, or <code>nodeDetails</code> is specified.</p>
    pub fn eks_properties(&self) -> ::std::option::Option<&crate::types::EksPropertiesDetail> {
        self.eks_properties.as_ref()
    }
    /// <p>A list of job attempts that are associated with this job.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.eks_attempts.is_none()`.
    pub fn eks_attempts(&self) -> &[crate::types::EksAttemptDetail] {
        self.eks_attempts.as_deref().unwrap_or_default()
    }
    /// <p>Indicates whether the job is canceled.</p>
    pub fn is_cancelled(&self) -> ::std::option::Option<bool> {
        self.is_cancelled
    }
    /// <p>Indicates whether the job is terminated.</p>
    pub fn is_terminated(&self) -> ::std::option::Option<bool> {
        self.is_terminated
    }
}
impl JobDetail {
    /// Creates a new builder-style object to manufacture [`JobDetail`](crate::types::JobDetail).
    pub fn builder() -> crate::types::builders::JobDetailBuilder {
        crate::types::builders::JobDetailBuilder::default()
    }
}

/// A builder for [`JobDetail`](crate::types::JobDetail).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct JobDetailBuilder {
    pub(crate) job_arn: ::std::option::Option<::std::string::String>,
    pub(crate) job_name: ::std::option::Option<::std::string::String>,
    pub(crate) job_id: ::std::option::Option<::std::string::String>,
    pub(crate) job_queue: ::std::option::Option<::std::string::String>,
    pub(crate) status: ::std::option::Option<crate::types::JobStatus>,
    pub(crate) share_identifier: ::std::option::Option<::std::string::String>,
    pub(crate) scheduling_priority: ::std::option::Option<i32>,
    pub(crate) attempts: ::std::option::Option<::std::vec::Vec<crate::types::AttemptDetail>>,
    pub(crate) status_reason: ::std::option::Option<::std::string::String>,
    pub(crate) created_at: ::std::option::Option<i64>,
    pub(crate) retry_strategy: ::std::option::Option<crate::types::RetryStrategy>,
    pub(crate) started_at: ::std::option::Option<i64>,
    pub(crate) stopped_at: ::std::option::Option<i64>,
    pub(crate) depends_on: ::std::option::Option<::std::vec::Vec<crate::types::JobDependency>>,
    pub(crate) job_definition: ::std::option::Option<::std::string::String>,
    pub(crate) parameters: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    pub(crate) container: ::std::option::Option<crate::types::ContainerDetail>,
    pub(crate) node_details: ::std::option::Option<crate::types::NodeDetails>,
    pub(crate) node_properties: ::std::option::Option<crate::types::NodeProperties>,
    pub(crate) array_properties: ::std::option::Option<crate::types::ArrayPropertiesDetail>,
    pub(crate) timeout: ::std::option::Option<crate::types::JobTimeout>,
    pub(crate) tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    pub(crate) propagate_tags: ::std::option::Option<bool>,
    pub(crate) platform_capabilities: ::std::option::Option<::std::vec::Vec<crate::types::PlatformCapability>>,
    pub(crate) eks_properties: ::std::option::Option<crate::types::EksPropertiesDetail>,
    pub(crate) eks_attempts: ::std::option::Option<::std::vec::Vec<crate::types::EksAttemptDetail>>,
    pub(crate) is_cancelled: ::std::option::Option<bool>,
    pub(crate) is_terminated: ::std::option::Option<bool>,
}
impl JobDetailBuilder {
    /// <p>The Amazon Resource Name (ARN) of the job.</p>
    pub fn job_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.job_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the job.</p>
    pub fn set_job_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.job_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the job.</p>
    pub fn get_job_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.job_arn
    }
    /// <p>The job name.</p>
    /// This field is required.
    pub fn job_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.job_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The job name.</p>
    pub fn set_job_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.job_name = input;
        self
    }
    /// <p>The job name.</p>
    pub fn get_job_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.job_name
    }
    /// <p>The job ID.</p>
    /// This field is required.
    pub fn job_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.job_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The job ID.</p>
    pub fn set_job_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.job_id = input;
        self
    }
    /// <p>The job ID.</p>
    pub fn get_job_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.job_id
    }
    /// <p>The Amazon Resource Name (ARN) of the job queue that the job is associated with.</p>
    /// This field is required.
    pub fn job_queue(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.job_queue = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the job queue that the job is associated with.</p>
    pub fn set_job_queue(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.job_queue = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the job queue that the job is associated with.</p>
    pub fn get_job_queue(&self) -> &::std::option::Option<::std::string::String> {
        &self.job_queue
    }
    /// <p>The current status for the job.</p> <note>
    /// <p>If your jobs don't progress to <code>STARTING</code>, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/troubleshooting.html#job_stuck_in_runnable">Jobs stuck in RUNNABLE status</a> in the troubleshooting section of the <i>Batch User Guide</i>.</p>
    /// </note>
    /// This field is required.
    pub fn status(mut self, input: crate::types::JobStatus) -> Self {
        self.status = ::std::option::Option::Some(input);
        self
    }
    /// <p>The current status for the job.</p> <note>
    /// <p>If your jobs don't progress to <code>STARTING</code>, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/troubleshooting.html#job_stuck_in_runnable">Jobs stuck in RUNNABLE status</a> in the troubleshooting section of the <i>Batch User Guide</i>.</p>
    /// </note>
    pub fn set_status(mut self, input: ::std::option::Option<crate::types::JobStatus>) -> Self {
        self.status = input;
        self
    }
    /// <p>The current status for the job.</p> <note>
    /// <p>If your jobs don't progress to <code>STARTING</code>, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/troubleshooting.html#job_stuck_in_runnable">Jobs stuck in RUNNABLE status</a> in the troubleshooting section of the <i>Batch User Guide</i>.</p>
    /// </note>
    pub fn get_status(&self) -> &::std::option::Option<crate::types::JobStatus> {
        &self.status
    }
    /// <p>The share identifier for the job.</p>
    pub fn share_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.share_identifier = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The share identifier for the job.</p>
    pub fn set_share_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.share_identifier = input;
        self
    }
    /// <p>The share identifier for the job.</p>
    pub fn get_share_identifier(&self) -> &::std::option::Option<::std::string::String> {
        &self.share_identifier
    }
    /// <p>The scheduling policy of the job definition. This only affects jobs in job queues with a fair share policy. Jobs with a higher scheduling priority are scheduled before jobs with a lower scheduling priority.</p>
    pub fn scheduling_priority(mut self, input: i32) -> Self {
        self.scheduling_priority = ::std::option::Option::Some(input);
        self
    }
    /// <p>The scheduling policy of the job definition. This only affects jobs in job queues with a fair share policy. Jobs with a higher scheduling priority are scheduled before jobs with a lower scheduling priority.</p>
    pub fn set_scheduling_priority(mut self, input: ::std::option::Option<i32>) -> Self {
        self.scheduling_priority = input;
        self
    }
    /// <p>The scheduling policy of the job definition. This only affects jobs in job queues with a fair share policy. Jobs with a higher scheduling priority are scheduled before jobs with a lower scheduling priority.</p>
    pub fn get_scheduling_priority(&self) -> &::std::option::Option<i32> {
        &self.scheduling_priority
    }
    /// Appends an item to `attempts`.
    ///
    /// To override the contents of this collection use [`set_attempts`](Self::set_attempts).
    ///
    /// <p>A list of job attempts that are associated with this job.</p>
    pub fn attempts(mut self, input: crate::types::AttemptDetail) -> Self {
        let mut v = self.attempts.unwrap_or_default();
        v.push(input);
        self.attempts = ::std::option::Option::Some(v);
        self
    }
    /// <p>A list of job attempts that are associated with this job.</p>
    pub fn set_attempts(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::AttemptDetail>>) -> Self {
        self.attempts = input;
        self
    }
    /// <p>A list of job attempts that are associated with this job.</p>
    pub fn get_attempts(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::AttemptDetail>> {
        &self.attempts
    }
    /// <p>A short, human-readable string to provide more details for the current status of the job.</p>
    pub fn status_reason(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.status_reason = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A short, human-readable string to provide more details for the current status of the job.</p>
    pub fn set_status_reason(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.status_reason = input;
        self
    }
    /// <p>A short, human-readable string to provide more details for the current status of the job.</p>
    pub fn get_status_reason(&self) -> &::std::option::Option<::std::string::String> {
        &self.status_reason
    }
    /// <p>The Unix timestamp (in milliseconds) for when the job was created. For non-array jobs and parent array jobs, this is when the job entered the <code>SUBMITTED</code> state. This is specifically at the time <code>SubmitJob</code> was called. For array child jobs, this is when the child job was spawned by its parent and entered the <code>PENDING</code> state.</p>
    pub fn created_at(mut self, input: i64) -> Self {
        self.created_at = ::std::option::Option::Some(input);
        self
    }
    /// <p>The Unix timestamp (in milliseconds) for when the job was created. For non-array jobs and parent array jobs, this is when the job entered the <code>SUBMITTED</code> state. This is specifically at the time <code>SubmitJob</code> was called. For array child jobs, this is when the child job was spawned by its parent and entered the <code>PENDING</code> state.</p>
    pub fn set_created_at(mut self, input: ::std::option::Option<i64>) -> Self {
        self.created_at = input;
        self
    }
    /// <p>The Unix timestamp (in milliseconds) for when the job was created. For non-array jobs and parent array jobs, this is when the job entered the <code>SUBMITTED</code> state. This is specifically at the time <code>SubmitJob</code> was called. For array child jobs, this is when the child job was spawned by its parent and entered the <code>PENDING</code> state.</p>
    pub fn get_created_at(&self) -> &::std::option::Option<i64> {
        &self.created_at
    }
    /// <p>The retry strategy to use for this job if an attempt fails.</p>
    pub fn retry_strategy(mut self, input: crate::types::RetryStrategy) -> Self {
        self.retry_strategy = ::std::option::Option::Some(input);
        self
    }
    /// <p>The retry strategy to use for this job if an attempt fails.</p>
    pub fn set_retry_strategy(mut self, input: ::std::option::Option<crate::types::RetryStrategy>) -> Self {
        self.retry_strategy = input;
        self
    }
    /// <p>The retry strategy to use for this job if an attempt fails.</p>
    pub fn get_retry_strategy(&self) -> &::std::option::Option<crate::types::RetryStrategy> {
        &self.retry_strategy
    }
    /// <p>The Unix timestamp (in milliseconds) for when the job was started. More specifically, it's when the job transitioned from the <code>STARTING</code> state to the <code>RUNNING</code> state. This parameter isn't provided for child jobs of array jobs or multi-node parallel jobs.</p>
    /// This field is required.
    pub fn started_at(mut self, input: i64) -> Self {
        self.started_at = ::std::option::Option::Some(input);
        self
    }
    /// <p>The Unix timestamp (in milliseconds) for when the job was started. More specifically, it's when the job transitioned from the <code>STARTING</code> state to the <code>RUNNING</code> state. This parameter isn't provided for child jobs of array jobs or multi-node parallel jobs.</p>
    pub fn set_started_at(mut self, input: ::std::option::Option<i64>) -> Self {
        self.started_at = input;
        self
    }
    /// <p>The Unix timestamp (in milliseconds) for when the job was started. More specifically, it's when the job transitioned from the <code>STARTING</code> state to the <code>RUNNING</code> state. This parameter isn't provided for child jobs of array jobs or multi-node parallel jobs.</p>
    pub fn get_started_at(&self) -> &::std::option::Option<i64> {
        &self.started_at
    }
    /// <p>The Unix timestamp (in milliseconds) for when the job was stopped. More specifically, it's when the job transitioned from the <code>RUNNING</code> state to a terminal state, such as <code>SUCCEEDED</code> or <code>FAILED</code>.</p>
    pub fn stopped_at(mut self, input: i64) -> Self {
        self.stopped_at = ::std::option::Option::Some(input);
        self
    }
    /// <p>The Unix timestamp (in milliseconds) for when the job was stopped. More specifically, it's when the job transitioned from the <code>RUNNING</code> state to a terminal state, such as <code>SUCCEEDED</code> or <code>FAILED</code>.</p>
    pub fn set_stopped_at(mut self, input: ::std::option::Option<i64>) -> Self {
        self.stopped_at = input;
        self
    }
    /// <p>The Unix timestamp (in milliseconds) for when the job was stopped. More specifically, it's when the job transitioned from the <code>RUNNING</code> state to a terminal state, such as <code>SUCCEEDED</code> or <code>FAILED</code>.</p>
    pub fn get_stopped_at(&self) -> &::std::option::Option<i64> {
        &self.stopped_at
    }
    /// Appends an item to `depends_on`.
    ///
    /// To override the contents of this collection use [`set_depends_on`](Self::set_depends_on).
    ///
    /// <p>A list of job IDs that this job depends on.</p>
    pub fn depends_on(mut self, input: crate::types::JobDependency) -> Self {
        let mut v = self.depends_on.unwrap_or_default();
        v.push(input);
        self.depends_on = ::std::option::Option::Some(v);
        self
    }
    /// <p>A list of job IDs that this job depends on.</p>
    pub fn set_depends_on(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::JobDependency>>) -> Self {
        self.depends_on = input;
        self
    }
    /// <p>A list of job IDs that this job depends on.</p>
    pub fn get_depends_on(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::JobDependency>> {
        &self.depends_on
    }
    /// <p>The Amazon Resource Name (ARN) of the job definition that this job uses.</p>
    /// This field is required.
    pub fn job_definition(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.job_definition = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the job definition that this job uses.</p>
    pub fn set_job_definition(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.job_definition = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the job definition that this job uses.</p>
    pub fn get_job_definition(&self) -> &::std::option::Option<::std::string::String> {
        &self.job_definition
    }
    /// Adds a key-value pair to `parameters`.
    ///
    /// To override the contents of this collection use [`set_parameters`](Self::set_parameters).
    ///
    /// <p>Additional parameters that are passed to the job that replace parameter substitution placeholders or override any corresponding parameter defaults from the job definition.</p>
    pub fn parameters(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut hash_map = self.parameters.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.parameters = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>Additional parameters that are passed to the job that replace parameter substitution placeholders or override any corresponding parameter defaults from the job definition.</p>
    pub fn set_parameters(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.parameters = input;
        self
    }
    /// <p>Additional parameters that are passed to the job that replace parameter substitution placeholders or override any corresponding parameter defaults from the job definition.</p>
    pub fn get_parameters(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.parameters
    }
    /// <p>An object that represents the details for the container that's associated with the job.</p>
    pub fn container(mut self, input: crate::types::ContainerDetail) -> Self {
        self.container = ::std::option::Option::Some(input);
        self
    }
    /// <p>An object that represents the details for the container that's associated with the job.</p>
    pub fn set_container(mut self, input: ::std::option::Option<crate::types::ContainerDetail>) -> Self {
        self.container = input;
        self
    }
    /// <p>An object that represents the details for the container that's associated with the job.</p>
    pub fn get_container(&self) -> &::std::option::Option<crate::types::ContainerDetail> {
        &self.container
    }
    /// <p>An object that represents the details of a node that's associated with a multi-node parallel job.</p>
    pub fn node_details(mut self, input: crate::types::NodeDetails) -> Self {
        self.node_details = ::std::option::Option::Some(input);
        self
    }
    /// <p>An object that represents the details of a node that's associated with a multi-node parallel job.</p>
    pub fn set_node_details(mut self, input: ::std::option::Option<crate::types::NodeDetails>) -> Self {
        self.node_details = input;
        self
    }
    /// <p>An object that represents the details of a node that's associated with a multi-node parallel job.</p>
    pub fn get_node_details(&self) -> &::std::option::Option<crate::types::NodeDetails> {
        &self.node_details
    }
    /// <p>An object that represents the node properties of a multi-node parallel job.</p> <note>
    /// <p>This isn't applicable to jobs that are running on Fargate resources.</p>
    /// </note>
    pub fn node_properties(mut self, input: crate::types::NodeProperties) -> Self {
        self.node_properties = ::std::option::Option::Some(input);
        self
    }
    /// <p>An object that represents the node properties of a multi-node parallel job.</p> <note>
    /// <p>This isn't applicable to jobs that are running on Fargate resources.</p>
    /// </note>
    pub fn set_node_properties(mut self, input: ::std::option::Option<crate::types::NodeProperties>) -> Self {
        self.node_properties = input;
        self
    }
    /// <p>An object that represents the node properties of a multi-node parallel job.</p> <note>
    /// <p>This isn't applicable to jobs that are running on Fargate resources.</p>
    /// </note>
    pub fn get_node_properties(&self) -> &::std::option::Option<crate::types::NodeProperties> {
        &self.node_properties
    }
    /// <p>The array properties of the job, if it's an array job.</p>
    pub fn array_properties(mut self, input: crate::types::ArrayPropertiesDetail) -> Self {
        self.array_properties = ::std::option::Option::Some(input);
        self
    }
    /// <p>The array properties of the job, if it's an array job.</p>
    pub fn set_array_properties(mut self, input: ::std::option::Option<crate::types::ArrayPropertiesDetail>) -> Self {
        self.array_properties = input;
        self
    }
    /// <p>The array properties of the job, if it's an array job.</p>
    pub fn get_array_properties(&self) -> &::std::option::Option<crate::types::ArrayPropertiesDetail> {
        &self.array_properties
    }
    /// <p>The timeout configuration for the job.</p>
    pub fn timeout(mut self, input: crate::types::JobTimeout) -> Self {
        self.timeout = ::std::option::Option::Some(input);
        self
    }
    /// <p>The timeout configuration for the job.</p>
    pub fn set_timeout(mut self, input: ::std::option::Option<crate::types::JobTimeout>) -> Self {
        self.timeout = input;
        self
    }
    /// <p>The timeout configuration for the job.</p>
    pub fn get_timeout(&self) -> &::std::option::Option<crate::types::JobTimeout> {
        &self.timeout
    }
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>The tags that are applied to the job.</p>
    pub fn tags(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut hash_map = self.tags.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.tags = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>The tags that are applied to the job.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>The tags that are applied to the job.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.tags
    }
    /// <p>Specifies whether to propagate the tags from the job or job definition to the corresponding Amazon ECS task. If no value is specified, the tags aren't propagated. Tags can only be propagated to the tasks when the tasks are created. For tags with the same name, job tags are given priority over job definitions tags. If the total number of combined tags from the job and job definition is over 50, the job is moved to the <code>FAILED</code> state.</p>
    pub fn propagate_tags(mut self, input: bool) -> Self {
        self.propagate_tags = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies whether to propagate the tags from the job or job definition to the corresponding Amazon ECS task. If no value is specified, the tags aren't propagated. Tags can only be propagated to the tasks when the tasks are created. For tags with the same name, job tags are given priority over job definitions tags. If the total number of combined tags from the job and job definition is over 50, the job is moved to the <code>FAILED</code> state.</p>
    pub fn set_propagate_tags(mut self, input: ::std::option::Option<bool>) -> Self {
        self.propagate_tags = input;
        self
    }
    /// <p>Specifies whether to propagate the tags from the job or job definition to the corresponding Amazon ECS task. If no value is specified, the tags aren't propagated. Tags can only be propagated to the tasks when the tasks are created. For tags with the same name, job tags are given priority over job definitions tags. If the total number of combined tags from the job and job definition is over 50, the job is moved to the <code>FAILED</code> state.</p>
    pub fn get_propagate_tags(&self) -> &::std::option::Option<bool> {
        &self.propagate_tags
    }
    /// Appends an item to `platform_capabilities`.
    ///
    /// To override the contents of this collection use [`set_platform_capabilities`](Self::set_platform_capabilities).
    ///
    /// <p>The platform capabilities required by the job definition. If no value is specified, it defaults to <code>EC2</code>. Jobs run on Fargate resources specify <code>FARGATE</code>.</p>
    pub fn platform_capabilities(mut self, input: crate::types::PlatformCapability) -> Self {
        let mut v = self.platform_capabilities.unwrap_or_default();
        v.push(input);
        self.platform_capabilities = ::std::option::Option::Some(v);
        self
    }
    /// <p>The platform capabilities required by the job definition. If no value is specified, it defaults to <code>EC2</code>. Jobs run on Fargate resources specify <code>FARGATE</code>.</p>
    pub fn set_platform_capabilities(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::PlatformCapability>>) -> Self {
        self.platform_capabilities = input;
        self
    }
    /// <p>The platform capabilities required by the job definition. If no value is specified, it defaults to <code>EC2</code>. Jobs run on Fargate resources specify <code>FARGATE</code>.</p>
    pub fn get_platform_capabilities(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::PlatformCapability>> {
        &self.platform_capabilities
    }
    /// <p>An object with various properties that are specific to Amazon EKS based jobs. Only one of <code>container</code>, <code>eksProperties</code>, or <code>nodeDetails</code> is specified.</p>
    pub fn eks_properties(mut self, input: crate::types::EksPropertiesDetail) -> Self {
        self.eks_properties = ::std::option::Option::Some(input);
        self
    }
    /// <p>An object with various properties that are specific to Amazon EKS based jobs. Only one of <code>container</code>, <code>eksProperties</code>, or <code>nodeDetails</code> is specified.</p>
    pub fn set_eks_properties(mut self, input: ::std::option::Option<crate::types::EksPropertiesDetail>) -> Self {
        self.eks_properties = input;
        self
    }
    /// <p>An object with various properties that are specific to Amazon EKS based jobs. Only one of <code>container</code>, <code>eksProperties</code>, or <code>nodeDetails</code> is specified.</p>
    pub fn get_eks_properties(&self) -> &::std::option::Option<crate::types::EksPropertiesDetail> {
        &self.eks_properties
    }
    /// Appends an item to `eks_attempts`.
    ///
    /// To override the contents of this collection use [`set_eks_attempts`](Self::set_eks_attempts).
    ///
    /// <p>A list of job attempts that are associated with this job.</p>
    pub fn eks_attempts(mut self, input: crate::types::EksAttemptDetail) -> Self {
        let mut v = self.eks_attempts.unwrap_or_default();
        v.push(input);
        self.eks_attempts = ::std::option::Option::Some(v);
        self
    }
    /// <p>A list of job attempts that are associated with this job.</p>
    pub fn set_eks_attempts(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::EksAttemptDetail>>) -> Self {
        self.eks_attempts = input;
        self
    }
    /// <p>A list of job attempts that are associated with this job.</p>
    pub fn get_eks_attempts(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::EksAttemptDetail>> {
        &self.eks_attempts
    }
    /// <p>Indicates whether the job is canceled.</p>
    pub fn is_cancelled(mut self, input: bool) -> Self {
        self.is_cancelled = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates whether the job is canceled.</p>
    pub fn set_is_cancelled(mut self, input: ::std::option::Option<bool>) -> Self {
        self.is_cancelled = input;
        self
    }
    /// <p>Indicates whether the job is canceled.</p>
    pub fn get_is_cancelled(&self) -> &::std::option::Option<bool> {
        &self.is_cancelled
    }
    /// <p>Indicates whether the job is terminated.</p>
    pub fn is_terminated(mut self, input: bool) -> Self {
        self.is_terminated = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates whether the job is terminated.</p>
    pub fn set_is_terminated(mut self, input: ::std::option::Option<bool>) -> Self {
        self.is_terminated = input;
        self
    }
    /// <p>Indicates whether the job is terminated.</p>
    pub fn get_is_terminated(&self) -> &::std::option::Option<bool> {
        &self.is_terminated
    }
    /// Consumes the builder and constructs a [`JobDetail`](crate::types::JobDetail).
    pub fn build(self) -> crate::types::JobDetail {
        crate::types::JobDetail {
            job_arn: self.job_arn,
            job_name: self.job_name,
            job_id: self.job_id,
            job_queue: self.job_queue,
            status: self.status,
            share_identifier: self.share_identifier,
            scheduling_priority: self.scheduling_priority,
            attempts: self.attempts,
            status_reason: self.status_reason,
            created_at: self.created_at,
            retry_strategy: self.retry_strategy,
            started_at: self.started_at,
            stopped_at: self.stopped_at,
            depends_on: self.depends_on,
            job_definition: self.job_definition,
            parameters: self.parameters,
            container: self.container,
            node_details: self.node_details,
            node_properties: self.node_properties,
            array_properties: self.array_properties,
            timeout: self.timeout,
            tags: self.tags,
            propagate_tags: self.propagate_tags,
            platform_capabilities: self.platform_capabilities,
            eks_properties: self.eks_properties,
            eks_attempts: self.eks_attempts,
            is_cancelled: self.is_cancelled,
            is_terminated: self.is_terminated,
        }
    }
}
