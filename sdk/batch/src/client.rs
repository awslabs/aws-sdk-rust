// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn cancel_job(&self) -> fluent_builders::CancelJob<C> {
        fluent_builders::CancelJob::new(self.handle.clone())
    }
    pub fn create_compute_environment(&self) -> fluent_builders::CreateComputeEnvironment<C> {
        fluent_builders::CreateComputeEnvironment::new(self.handle.clone())
    }
    pub fn create_job_queue(&self) -> fluent_builders::CreateJobQueue<C> {
        fluent_builders::CreateJobQueue::new(self.handle.clone())
    }
    pub fn delete_compute_environment(&self) -> fluent_builders::DeleteComputeEnvironment<C> {
        fluent_builders::DeleteComputeEnvironment::new(self.handle.clone())
    }
    pub fn delete_job_queue(&self) -> fluent_builders::DeleteJobQueue<C> {
        fluent_builders::DeleteJobQueue::new(self.handle.clone())
    }
    pub fn deregister_job_definition(&self) -> fluent_builders::DeregisterJobDefinition<C> {
        fluent_builders::DeregisterJobDefinition::new(self.handle.clone())
    }
    pub fn describe_compute_environments(&self) -> fluent_builders::DescribeComputeEnvironments<C> {
        fluent_builders::DescribeComputeEnvironments::new(self.handle.clone())
    }
    pub fn describe_job_definitions(&self) -> fluent_builders::DescribeJobDefinitions<C> {
        fluent_builders::DescribeJobDefinitions::new(self.handle.clone())
    }
    pub fn describe_job_queues(&self) -> fluent_builders::DescribeJobQueues<C> {
        fluent_builders::DescribeJobQueues::new(self.handle.clone())
    }
    pub fn describe_jobs(&self) -> fluent_builders::DescribeJobs<C> {
        fluent_builders::DescribeJobs::new(self.handle.clone())
    }
    pub fn list_jobs(&self) -> fluent_builders::ListJobs<C> {
        fluent_builders::ListJobs::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn register_job_definition(&self) -> fluent_builders::RegisterJobDefinition<C> {
        fluent_builders::RegisterJobDefinition::new(self.handle.clone())
    }
    pub fn submit_job(&self) -> fluent_builders::SubmitJob<C> {
        fluent_builders::SubmitJob::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn terminate_job(&self) -> fluent_builders::TerminateJob<C> {
        fluent_builders::TerminateJob::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_compute_environment(&self) -> fluent_builders::UpdateComputeEnvironment<C> {
        fluent_builders::UpdateComputeEnvironment::new(self.handle.clone())
    }
    pub fn update_job_queue(&self) -> fluent_builders::UpdateJobQueue<C> {
        fluent_builders::UpdateJobQueue::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct CancelJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::cancel_job_input::Builder,
    }
    impl<C> CancelJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CancelJobOutput,
            smithy_http::result::SdkError<crate::error::CancelJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The AWS Batch job ID of the job to cancel.</p>
        pub fn job_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(inp);
            self
        }
        pub fn set_job_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(inp);
            self
        }
        /// <p>A message to attach to the job that explains the reason for canceling it. This message is returned by future
        /// <a>DescribeJobs</a> operations on the job. This message is also recorded in the AWS Batch activity
        /// logs.</p>
        pub fn reason(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reason(inp);
            self
        }
        pub fn set_reason(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_reason(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateComputeEnvironment<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_compute_environment_input::Builder,
    }
    impl<C> CreateComputeEnvironment<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateComputeEnvironmentOutput,
            smithy_http::result::SdkError<crate::error::CreateComputeEnvironmentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name for your compute environment. Up to 128 letters (uppercase and lowercase), numbers, hyphens, and
        /// underscores are allowed.</p>
        pub fn compute_environment_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.compute_environment_name(inp);
            self
        }
        pub fn set_compute_environment_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_compute_environment_name(inp);
            self
        }
        /// <p>The type of the compute environment: <code>MANAGED</code> or <code>UNMANAGED</code>. For more information, see
        /// <a href="https://docs.aws.amazon.com/batch/latest/userguide/compute_environments.html">Compute Environments</a> in the
        /// <i>AWS Batch User Guide</i>.</p>
        pub fn r#type(mut self, inp: crate::model::CeType) -> Self {
            self.inner = self.inner.r#type(inp);
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<crate::model::CeType>) -> Self {
            self.inner = self.inner.set_type(inp);
            self
        }
        /// <p>The state of the compute environment. If the state is <code>ENABLED</code>, then the compute environment accepts
        /// jobs from a queue and can scale out automatically based on queues.</p>
        /// <p>If the state is <code>ENABLED</code>, then the AWS Batch scheduler can attempt to place jobs from an associated
        /// job queue on the compute resources within the environment. If the compute environment is managed, then it can scale
        /// its instances out or in automatically, based on the job queue demand.</p>
        /// <p>If the state is <code>DISABLED</code>, then the AWS Batch scheduler doesn't attempt to place jobs within the
        /// environment. Jobs in a <code>STARTING</code> or <code>RUNNING</code> state continue to progress normally. Managed
        /// compute environments in the <code>DISABLED</code> state don't scale out. However, they scale in to
        /// <code>minvCpus</code> value after instances become idle.</p>
        pub fn state(mut self, inp: crate::model::CeState) -> Self {
            self.inner = self.inner.state(inp);
            self
        }
        pub fn set_state(mut self, inp: std::option::Option<crate::model::CeState>) -> Self {
            self.inner = self.inner.set_state(inp);
            self
        }
        /// <p>Details about the compute resources managed by the compute environment. This parameter is required for managed
        /// compute environments. For more information, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/compute_environments.html">Compute Environments</a> in the <i>AWS Batch User Guide</i>.</p>
        pub fn compute_resources(mut self, inp: crate::model::ComputeResource) -> Self {
            self.inner = self.inner.compute_resources(inp);
            self
        }
        pub fn set_compute_resources(
            mut self,
            inp: std::option::Option<crate::model::ComputeResource>,
        ) -> Self {
            self.inner = self.inner.set_compute_resources(inp);
            self
        }
        /// <p>The full Amazon Resource Name (ARN) of the IAM role that allows AWS Batch to make calls to other AWS services on your behalf. For
        /// more information, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/service_IAM_role.html">AWS Batch service IAM
        /// role</a> in the <i>AWS Batch User Guide</i>.</p>
        /// <important>
        /// <p>If your account has already created the AWS Batch service-linked role, that role is used by default for your
        /// compute environment unless you specify a role here. If the AWS Batch service-linked role does not exist in your
        /// account, and no role is specified here, the service will try to create the AWS Batch service-linked role in your
        /// account.</p>
        /// </important>
        /// <p>If your specified role has a path other than <code>/</code>, then you must specify either the full role ARN
        /// (recommended) or prefix the role name with the path. For example, if a role with the name <code>bar</code> has a path
        /// of <code>/foo/</code> then you would specify <code>/foo/bar</code> as the role name. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-friendly-names">Friendly names
        /// and paths</a> in the <i>IAM User Guide</i>.</p>
        /// <note>
        /// <p>Depending on how you created your AWS Batch service role, its ARN might contain the <code>service-role</code>
        /// path prefix. When you only specify the name of the service role, AWS Batch assumes that your ARN doesn't use the
        /// <code>service-role</code> path prefix. Because of this, we recommend that you specify the full ARN of your service
        /// role when you create compute environments.</p>
        /// </note>
        pub fn service_role(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_role(inp);
            self
        }
        pub fn set_service_role(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_role(inp);
            self
        }
        /// <p>The tags that you apply to the compute environment to help you categorize and organize your resources. Each tag
        /// consists of a key and an optional value. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging AWS Resources</a> in <i>AWS General
        /// Reference</i>.</p>
        /// <p>These tags can be updated or removed using the <a href="https://docs.aws.amazon.com/batch/latest/APIReference/API_TagResource.html">TagResource</a> and <a href="https://docs.aws.amazon.com/batch/latest/APIReference/API_UntagResource.html">UntagResource</a> API operations. These tags don't
        /// propagate to the underlying compute resources.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateJobQueue<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_job_queue_input::Builder,
    }
    impl<C> CreateJobQueue<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateJobQueueOutput,
            smithy_http::result::SdkError<crate::error::CreateJobQueueError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the job queue. Up to 128 letters (uppercase and lowercase), numbers, and underscores are
        /// allowed.</p>
        pub fn job_queue_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_queue_name(inp);
            self
        }
        pub fn set_job_queue_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_queue_name(inp);
            self
        }
        /// <p>The state of the job queue. If the job queue state is <code>ENABLED</code>, it is able to accept jobs. If the
        /// job queue state is <code>DISABLED</code>, new jobs can't be added to the queue, but jobs already in the queue can
        /// finish.</p>
        pub fn state(mut self, inp: crate::model::JqState) -> Self {
            self.inner = self.inner.state(inp);
            self
        }
        pub fn set_state(mut self, inp: std::option::Option<crate::model::JqState>) -> Self {
            self.inner = self.inner.set_state(inp);
            self
        }
        /// <p>The priority of the job queue. Job queues with a higher priority (or a higher integer value for the
        /// <code>priority</code> parameter) are evaluated first when associated with the same compute environment. Priority is
        /// determined in descending order. For example, a job queue with a priority value of <code>10</code> is given scheduling
        /// preference over a job queue with a priority value of <code>1</code>. All of the compute environments must be either
        /// EC2 (<code>EC2</code> or <code>SPOT</code>) or Fargate (<code>FARGATE</code> or <code>FARGATE_SPOT</code>); EC2 and
        /// Fargate compute environments cannot be mixed.</p>
        pub fn priority(mut self, inp: i32) -> Self {
            self.inner = self.inner.priority(inp);
            self
        }
        pub fn set_priority(mut self, inp: i32) -> Self {
            self.inner = self.inner.set_priority(inp);
            self
        }
        /// <p>The set of compute environments mapped to a job queue and their order relative to each other. The job scheduler
        /// uses this parameter to determine which compute environment should run a specific job. Compute environments must be in
        /// the <code>VALID</code> state before you can associate them with a job queue. You can associate up to three compute
        /// environments with a job queue. All of the compute environments must be either EC2 (<code>EC2</code> or
        /// <code>SPOT</code>) or Fargate (<code>FARGATE</code> or <code>FARGATE_SPOT</code>); EC2 and Fargate compute
        /// environments can't be mixed.</p>
        /// <note>
        /// <p>All compute environments that are associated with a job queue must share the same architecture. AWS Batch doesn't
        /// support mixing compute environment architecture types in a single job queue.</p>
        /// </note>
        pub fn compute_environment_order(
            mut self,
            inp: impl Into<crate::model::ComputeEnvironmentOrder>,
        ) -> Self {
            self.inner = self.inner.compute_environment_order(inp);
            self
        }
        pub fn set_compute_environment_order(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::ComputeEnvironmentOrder>>,
        ) -> Self {
            self.inner = self.inner.set_compute_environment_order(inp);
            self
        }
        /// <p>The tags that you apply to the job queue to help you categorize and organize your resources. Each tag consists
        /// of a key and an optional value. For more information, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/using-tags.html">Tagging your AWS Batch resources</a> in <i>AWS Batch User Guide</i>.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteComputeEnvironment<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_compute_environment_input::Builder,
    }
    impl<C> DeleteComputeEnvironment<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteComputeEnvironmentOutput,
            smithy_http::result::SdkError<crate::error::DeleteComputeEnvironmentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name or Amazon Resource Name (ARN) of the compute environment to delete.</p>
        pub fn compute_environment(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.compute_environment(inp);
            self
        }
        pub fn set_compute_environment(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_compute_environment(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteJobQueue<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_job_queue_input::Builder,
    }
    impl<C> DeleteJobQueue<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteJobQueueOutput,
            smithy_http::result::SdkError<crate::error::DeleteJobQueueError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The short name or full Amazon Resource Name (ARN) of the queue to delete.</p>
        pub fn job_queue(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_queue(inp);
            self
        }
        pub fn set_job_queue(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_queue(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeregisterJobDefinition<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::deregister_job_definition_input::Builder,
    }
    impl<C> DeregisterJobDefinition<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeregisterJobDefinitionOutput,
            smithy_http::result::SdkError<crate::error::DeregisterJobDefinitionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name and revision (<code>name:revision</code>) or full Amazon Resource Name (ARN) of the job definition to deregister.</p>
        pub fn job_definition(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_definition(inp);
            self
        }
        pub fn set_job_definition(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_definition(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeComputeEnvironments<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_compute_environments_input::Builder,
    }
    impl<C> DescribeComputeEnvironments<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeComputeEnvironmentsOutput,
            smithy_http::result::SdkError<crate::error::DescribeComputeEnvironmentsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A list of up to 100 compute environment names or full Amazon Resource Name (ARN) entries.</p>
        pub fn compute_environments(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.compute_environments(inp);
            self
        }
        pub fn set_compute_environments(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_compute_environments(inp);
            self
        }
        /// <p>The maximum number of cluster results returned by <code>DescribeComputeEnvironments</code> in paginated output.
        /// When this parameter is used, <code>DescribeComputeEnvironments</code> only returns <code>maxResults</code> results in
        /// a single page along with a <code>nextToken</code> response element. The remaining results of the initial request can
        /// be seen by sending another <code>DescribeComputeEnvironments</code> request with the returned <code>nextToken</code>
        /// value. This value can be between 1 and 100. If this parameter isn't used, then
        /// <code>DescribeComputeEnvironments</code> returns up to 100 results and a <code>nextToken</code>
        /// value if applicable.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>The <code>nextToken</code> value returned from a previous paginated <code>DescribeComputeEnvironments</code>
        /// request where <code>maxResults</code> was used and the results exceeded the value of that parameter. Pagination
        /// continues from the end of the previous results that returned the <code>nextToken</code> value. This value is
        /// <code>null</code> when there are no more results to return.</p>
        /// <note>
        /// <p>This token should be treated as an opaque identifier that's only used to
        /// retrieve the next items in a list and not for other programmatic purposes.</p>
        /// </note>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeJobDefinitions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_job_definitions_input::Builder,
    }
    impl<C> DescribeJobDefinitions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeJobDefinitionsOutput,
            smithy_http::result::SdkError<crate::error::DescribeJobDefinitionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A list of up to 100 job definition names or full Amazon Resource Name (ARN) entries.</p>
        pub fn job_definitions(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_definitions(inp);
            self
        }
        pub fn set_job_definitions(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_job_definitions(inp);
            self
        }
        /// <p>The maximum number of results returned by <code>DescribeJobDefinitions</code> in paginated output. When this
        /// parameter is used, <code>DescribeJobDefinitions</code> only returns <code>maxResults</code> results in a single page
        /// and a <code>nextToken</code> response element. The remaining results of the initial request can be seen by sending
        /// another <code>DescribeJobDefinitions</code> request with the returned <code>nextToken</code> value. This value can be
        /// between 1 and 100. If this parameter isn't used, then
        /// <code>DescribeJobDefinitions</code> returns up to 100 results and a <code>nextToken</code> value
        /// if applicable.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>The name of the job definition to describe.</p>
        pub fn job_definition_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_definition_name(inp);
            self
        }
        pub fn set_job_definition_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_job_definition_name(inp);
            self
        }
        /// <p>The status used to filter job definitions.</p>
        pub fn status(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.status(inp);
            self
        }
        pub fn set_status(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_status(inp);
            self
        }
        /// <p>The <code>nextToken</code> value returned from a previous paginated <code>DescribeJobDefinitions</code> request
        /// where <code>maxResults</code> was used and the results exceeded the value of that parameter. Pagination continues
        /// from the end of the previous results that returned the <code>nextToken</code> value. This value is <code>null</code>
        /// when there are no more results to return.</p>
        /// <note>
        /// <p>This token should be treated as an opaque identifier that's only used to
        /// retrieve the next items in a list and not for other programmatic purposes.</p>
        /// </note>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeJobQueues<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_job_queues_input::Builder,
    }
    impl<C> DescribeJobQueues<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeJobQueuesOutput,
            smithy_http::result::SdkError<crate::error::DescribeJobQueuesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A list of up to 100 queue names or full queue Amazon Resource Name (ARN) entries.</p>
        pub fn job_queues(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_queues(inp);
            self
        }
        pub fn set_job_queues(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_job_queues(inp);
            self
        }
        /// <p>The maximum number of results returned by <code>DescribeJobQueues</code> in paginated output. When this
        /// parameter is used, <code>DescribeJobQueues</code> only returns <code>maxResults</code> results in a single page and a
        /// <code>nextToken</code> response element. The remaining results of the initial request can be seen by sending another
        /// <code>DescribeJobQueues</code> request with the returned <code>nextToken</code> value. This value can be between
        /// 1 and 100. If this parameter isn't used, then <code>DescribeJobQueues</code> returns up
        /// to 100 results and a <code>nextToken</code> value if applicable.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>The <code>nextToken</code> value returned from a previous paginated <code>DescribeJobQueues</code> request where
        /// <code>maxResults</code> was used and the results exceeded the value of that parameter. Pagination continues from the
        /// end of the previous results that returned the <code>nextToken</code> value. This value is <code>null</code> when
        /// there are no more results to return.</p>
        /// <note>
        /// <p>This token should be treated as an opaque identifier that's only used to
        /// retrieve the next items in a list and not for other programmatic purposes.</p>
        /// </note>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeJobs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_jobs_input::Builder,
    }
    impl<C> DescribeJobs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeJobsOutput,
            smithy_http::result::SdkError<crate::error::DescribeJobsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A list of up to 100 job IDs.</p>
        pub fn jobs(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.jobs(inp);
            self
        }
        pub fn set_jobs(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_jobs(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListJobs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_jobs_input::Builder,
    }
    impl<C> ListJobs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListJobsOutput,
            smithy_http::result::SdkError<crate::error::ListJobsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name or full Amazon Resource Name (ARN) of the job queue used to list jobs.</p>
        pub fn job_queue(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_queue(inp);
            self
        }
        pub fn set_job_queue(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_queue(inp);
            self
        }
        /// <p>The job ID for an array job. Specifying an array job ID with this parameter lists all child jobs from within the
        /// specified array.</p>
        pub fn array_job_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.array_job_id(inp);
            self
        }
        pub fn set_array_job_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_array_job_id(inp);
            self
        }
        /// <p>The job ID for a multi-node parallel job. Specifying a multi-node parallel job ID with this parameter lists all
        /// nodes that are associated with the specified job.</p>
        pub fn multi_node_job_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.multi_node_job_id(inp);
            self
        }
        pub fn set_multi_node_job_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_multi_node_job_id(inp);
            self
        }
        /// <p>The job status used to filter jobs in the specified queue. If you don't specify a status, only
        /// <code>RUNNING</code> jobs are returned.</p>
        pub fn job_status(mut self, inp: crate::model::JobStatus) -> Self {
            self.inner = self.inner.job_status(inp);
            self
        }
        pub fn set_job_status(mut self, inp: std::option::Option<crate::model::JobStatus>) -> Self {
            self.inner = self.inner.set_job_status(inp);
            self
        }
        /// <p>The maximum number of results returned by <code>ListJobs</code> in paginated output. When this parameter is
        /// used, <code>ListJobs</code> only returns <code>maxResults</code> results in a single page and a
        /// <code>nextToken</code> response element. The remaining results of the initial request can be seen by sending another
        /// <code>ListJobs</code> request with the returned <code>nextToken</code> value. This value can be between
        /// 1 and 100. If this parameter isn't used, then <code>ListJobs</code> returns up to
        /// 100 results and a <code>nextToken</code> value if applicable.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>The <code>nextToken</code> value returned from a previous paginated <code>ListJobs</code> request where
        /// <code>maxResults</code> was used and the results exceeded the value of that parameter. Pagination continues from the
        /// end of the previous results that returned the <code>nextToken</code> value. This value is <code>null</code> when
        /// there are no more results to return.</p>
        /// <note>
        /// <p>This token should be treated as an opaque identifier that's only used to
        /// retrieve the next items in a list and not for other programmatic purposes.</p>
        /// </note>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) that identifies the resource that tags are listed for. AWS Batch resources that support tags are compute environments, jobs, job definitions, and job
        /// queues. ARNs for child jobs of array and multi-node parallel (MNP) jobs are not supported.</p>
        pub fn resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(inp);
            self
        }
        pub fn set_resource_arn(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_resource_arn(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RegisterJobDefinition<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::register_job_definition_input::Builder,
    }
    impl<C> RegisterJobDefinition<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::RegisterJobDefinitionOutput,
            smithy_http::result::SdkError<crate::error::RegisterJobDefinitionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the job definition to register. Up to 128 letters (uppercase and lowercase), numbers, hyphens, and
        /// underscores are allowed.</p>
        pub fn job_definition_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_definition_name(inp);
            self
        }
        pub fn set_job_definition_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_job_definition_name(inp);
            self
        }
        /// <p>The type of job definition. For more information about multi-node parallel jobs, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/multi-node-job-def.html">Creating a multi-node parallel job definition</a> in the
        /// <i>AWS Batch User Guide</i>.</p>
        /// <note>
        /// <p>If the job is run on Fargate resources, then <code>multinode</code> isn't supported.</p>
        /// </note>
        pub fn r#type(mut self, inp: crate::model::JobDefinitionType) -> Self {
            self.inner = self.inner.r#type(inp);
            self
        }
        pub fn set_type(
            mut self,
            inp: std::option::Option<crate::model::JobDefinitionType>,
        ) -> Self {
            self.inner = self.inner.set_type(inp);
            self
        }
        /// <p>Default parameter substitution placeholders to set in the job definition. Parameters are specified as a
        /// key-value pair mapping. Parameters in a <code>SubmitJob</code> request override any corresponding parameter defaults
        /// from the job definition.</p>
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.parameters(k, v);
            self
        }
        pub fn set_parameters(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_parameters(inp);
            self
        }
        /// <p>An object with various properties specific to single-node container-based jobs. If the job definition's
        /// <code>type</code> parameter is <code>container</code>, then you must specify either <code>containerProperties</code>
        /// or <code>nodeProperties</code>.</p>
        /// <note>
        /// <p>If the job runs on Fargate resources, then you must not specify <code>nodeProperties</code>; use only
        /// <code>containerProperties</code>.</p>
        /// </note>
        pub fn container_properties(mut self, inp: crate::model::ContainerProperties) -> Self {
            self.inner = self.inner.container_properties(inp);
            self
        }
        pub fn set_container_properties(
            mut self,
            inp: std::option::Option<crate::model::ContainerProperties>,
        ) -> Self {
            self.inner = self.inner.set_container_properties(inp);
            self
        }
        /// <p>An object with various properties specific to multi-node parallel jobs. If you specify node properties for a
        /// job, it becomes a multi-node parallel job. For more information, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/multi-node-parallel-jobs.html">Multi-node Parallel Jobs</a> in the
        /// <i>AWS Batch User Guide</i>. If the job definition's <code>type</code> parameter is
        /// <code>container</code>, then you must specify either <code>containerProperties</code> or
        /// <code>nodeProperties</code>.</p>
        /// <note>
        /// <p>If the job runs on Fargate resources, then you must not specify <code>nodeProperties</code>; use
        /// <code>containerProperties</code> instead.</p>
        /// </note>
        pub fn node_properties(mut self, inp: crate::model::NodeProperties) -> Self {
            self.inner = self.inner.node_properties(inp);
            self
        }
        pub fn set_node_properties(
            mut self,
            inp: std::option::Option<crate::model::NodeProperties>,
        ) -> Self {
            self.inner = self.inner.set_node_properties(inp);
            self
        }
        /// <p>The retry strategy to use for failed jobs that are submitted with this job definition. Any retry strategy that's
        /// specified during a <a>SubmitJob</a> operation overrides the retry strategy defined here. If a job is
        /// terminated due to a timeout, it isn't retried.</p>
        pub fn retry_strategy(mut self, inp: crate::model::RetryStrategy) -> Self {
            self.inner = self.inner.retry_strategy(inp);
            self
        }
        pub fn set_retry_strategy(
            mut self,
            inp: std::option::Option<crate::model::RetryStrategy>,
        ) -> Self {
            self.inner = self.inner.set_retry_strategy(inp);
            self
        }
        /// <p>Specifies whether to propagate the tags from the job or job definition to the corresponding Amazon ECS task. If no
        /// value is specified, the tags are not propagated. Tags can only be propagated to the tasks during task creation. For
        /// tags with the same name, job tags are given priority over job definitions tags. If the total number of combined tags
        /// from the job and job definition is over 50, the job is moved to the <code>FAILED</code> state.</p>
        pub fn propagate_tags(mut self, inp: bool) -> Self {
            self.inner = self.inner.propagate_tags(inp);
            self
        }
        pub fn set_propagate_tags(mut self, inp: bool) -> Self {
            self.inner = self.inner.set_propagate_tags(inp);
            self
        }
        /// <p>The timeout configuration for jobs that are submitted with this job definition, after which AWS Batch terminates
        /// your jobs if they have not finished. If a job is terminated due to a timeout, it isn't retried. The minimum value for
        /// the timeout is 60 seconds. Any timeout configuration that's specified during a <a>SubmitJob</a> operation
        /// overrides the timeout configuration defined here. For more information, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/job_timeouts.html">Job Timeouts</a> in the <i>AWS Batch User Guide</i>.</p>
        pub fn timeout(mut self, inp: crate::model::JobTimeout) -> Self {
            self.inner = self.inner.timeout(inp);
            self
        }
        pub fn set_timeout(mut self, inp: std::option::Option<crate::model::JobTimeout>) -> Self {
            self.inner = self.inner.set_timeout(inp);
            self
        }
        /// <p>The tags that you apply to the job definition to help you categorize and organize your resources. Each tag
        /// consists of a key and an optional value. For more information, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/using-tags.html">Tagging AWS Resources</a> in <i>AWS Batch User Guide</i>.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
        /// <p>The platform capabilities required by the job definition. If no value is specified, it defaults to
        /// <code>EC2</code>. To run the job on Fargate resources, specify <code>FARGATE</code>.</p>
        pub fn platform_capabilities(
            mut self,
            inp: impl Into<crate::model::PlatformCapability>,
        ) -> Self {
            self.inner = self.inner.platform_capabilities(inp);
            self
        }
        pub fn set_platform_capabilities(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::PlatformCapability>>,
        ) -> Self {
            self.inner = self.inner.set_platform_capabilities(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SubmitJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::submit_job_input::Builder,
    }
    impl<C> SubmitJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::SubmitJobOutput,
            smithy_http::result::SdkError<crate::error::SubmitJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the job. The first character must be alphanumeric, and up to 128 letters (uppercase and lowercase),
        /// numbers, hyphens, and underscores are allowed.</p>
        pub fn job_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_name(inp);
            self
        }
        pub fn set_job_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_name(inp);
            self
        }
        /// <p>The job queue where the job is submitted. You can specify either the name or the Amazon Resource Name (ARN) of the queue.</p>
        pub fn job_queue(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_queue(inp);
            self
        }
        pub fn set_job_queue(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_queue(inp);
            self
        }
        /// <p>The array properties for the submitted job, such as the size of the array. The array size can be between 2 and
        /// 10,000. If you specify array properties for a job, it becomes an array job. For more information, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/array_jobs.html">Array Jobs</a> in the
        /// <i>AWS Batch User Guide</i>.</p>
        pub fn array_properties(mut self, inp: crate::model::ArrayProperties) -> Self {
            self.inner = self.inner.array_properties(inp);
            self
        }
        pub fn set_array_properties(
            mut self,
            inp: std::option::Option<crate::model::ArrayProperties>,
        ) -> Self {
            self.inner = self.inner.set_array_properties(inp);
            self
        }
        /// <p>A list of dependencies for the job. A job can depend upon a maximum of 20 jobs. You can specify a
        /// <code>SEQUENTIAL</code> type dependency without specifying a job ID for array jobs so that each child array job
        /// completes sequentially, starting at index 0. You can also specify an <code>N_TO_N</code> type dependency with a job
        /// ID for array jobs. In that case, each index child of this job must wait for the corresponding index child of each
        /// dependency to complete before it can begin.</p>
        pub fn depends_on(mut self, inp: impl Into<crate::model::JobDependency>) -> Self {
            self.inner = self.inner.depends_on(inp);
            self
        }
        pub fn set_depends_on(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::JobDependency>>,
        ) -> Self {
            self.inner = self.inner.set_depends_on(inp);
            self
        }
        /// <p>The job definition used by this job. This value can be one of <code>name</code>, <code>name:revision</code>, or
        /// the Amazon Resource Name (ARN) for the job definition. If <code>name</code> is specified without a revision then the latest active
        /// revision is used.</p>
        pub fn job_definition(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_definition(inp);
            self
        }
        pub fn set_job_definition(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_definition(inp);
            self
        }
        /// <p>Additional parameters passed to the job that replace parameter substitution placeholders that are set in the job
        /// definition. Parameters are specified as a key and value pair mapping. Parameters in a <code>SubmitJob</code> request
        /// override any corresponding parameter defaults from the job definition.</p>
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.parameters(k, v);
            self
        }
        pub fn set_parameters(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_parameters(inp);
            self
        }
        /// <p>A list of container overrides in the JSON format that specify the name of a container in the specified job
        /// definition and the overrides it should receive. You can override the default command for a container, which is
        /// specified in the job definition or the Docker image, with a <code>command</code> override. You can also override
        /// existing environment variables on a container or add new environment variables to it with an <code>environment</code>
        /// override.</p>
        pub fn container_overrides(mut self, inp: crate::model::ContainerOverrides) -> Self {
            self.inner = self.inner.container_overrides(inp);
            self
        }
        pub fn set_container_overrides(
            mut self,
            inp: std::option::Option<crate::model::ContainerOverrides>,
        ) -> Self {
            self.inner = self.inner.set_container_overrides(inp);
            self
        }
        /// <p>A list of node overrides in JSON format that specify the node range to target and the container overrides for
        /// that node range.</p>
        /// <note>
        /// <p>This parameter isn't applicable to jobs running on Fargate resources; use <code>containerOverrides</code>
        /// instead.</p>
        /// </note>
        pub fn node_overrides(mut self, inp: crate::model::NodeOverrides) -> Self {
            self.inner = self.inner.node_overrides(inp);
            self
        }
        pub fn set_node_overrides(
            mut self,
            inp: std::option::Option<crate::model::NodeOverrides>,
        ) -> Self {
            self.inner = self.inner.set_node_overrides(inp);
            self
        }
        /// <p>The retry strategy to use for failed jobs from this <a>SubmitJob</a> operation. When a retry strategy
        /// is specified here, it overrides the retry strategy defined in the job definition.</p>
        pub fn retry_strategy(mut self, inp: crate::model::RetryStrategy) -> Self {
            self.inner = self.inner.retry_strategy(inp);
            self
        }
        pub fn set_retry_strategy(
            mut self,
            inp: std::option::Option<crate::model::RetryStrategy>,
        ) -> Self {
            self.inner = self.inner.set_retry_strategy(inp);
            self
        }
        /// <p>Specifies whether to propagate the tags from the job or job definition to the corresponding Amazon ECS task. If no
        /// value is specified, the tags aren't propagated. Tags can only be propagated to the tasks during task creation. For
        /// tags with the same name, job tags are given priority over job definitions tags. If the total number of combined tags
        /// from the job and job definition is over 50, the job is moved to the <code>FAILED</code> state. When specified, this
        /// overrides the tag propagation setting in the job definition.</p>
        pub fn propagate_tags(mut self, inp: bool) -> Self {
            self.inner = self.inner.propagate_tags(inp);
            self
        }
        pub fn set_propagate_tags(mut self, inp: bool) -> Self {
            self.inner = self.inner.set_propagate_tags(inp);
            self
        }
        /// <p>The timeout configuration for this <a>SubmitJob</a> operation. You can specify a timeout duration
        /// after which AWS Batch terminates your jobs if they haven't finished. If a job is terminated due to a timeout, it isn't
        /// retried. The minimum value for the timeout is 60 seconds. This configuration overrides any timeout configuration
        /// specified in the job definition. For array jobs, child jobs have the same timeout configuration as the parent job.
        /// For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/job_timeouts.html">Job
        /// Timeouts</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
        pub fn timeout(mut self, inp: crate::model::JobTimeout) -> Self {
            self.inner = self.inner.timeout(inp);
            self
        }
        pub fn set_timeout(mut self, inp: std::option::Option<crate::model::JobTimeout>) -> Self {
            self.inner = self.inner.set_timeout(inp);
            self
        }
        /// <p>The tags that you apply to the job request to help you categorize and organize your resources. Each tag consists
        /// of a key and an optional value. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging AWS Resources</a> in <i>AWS General
        /// Reference</i>.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource that tags are added to. AWS Batch resources that support tags are compute environments, jobs, job definitions, and job
        /// queues. ARNs for child jobs of array and multi-node parallel (MNP) jobs are not supported.</p>
        pub fn resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(inp);
            self
        }
        pub fn set_resource_arn(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_resource_arn(inp);
            self
        }
        /// <p>The tags that you apply to the resource to help you categorize and organize your resources. Each tag consists of
        /// a key and an optional value. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging AWS Resources</a> in <i>AWS General
        /// Reference</i>.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TerminateJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::terminate_job_input::Builder,
    }
    impl<C> TerminateJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::TerminateJobOutput,
            smithy_http::result::SdkError<crate::error::TerminateJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The AWS Batch job ID of the job to terminate.</p>
        pub fn job_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(inp);
            self
        }
        pub fn set_job_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(inp);
            self
        }
        /// <p>A message to attach to the job that explains the reason for canceling it. This message is returned by future
        /// <a>DescribeJobs</a> operations on the job. This message is also recorded in the AWS Batch activity
        /// logs.</p>
        pub fn reason(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reason(inp);
            self
        }
        pub fn set_reason(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_reason(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource from which to delete tags. AWS Batch resources that support tags are compute environments, jobs, job definitions, and job
        /// queues. ARNs for child jobs of array and multi-node parallel (MNP) jobs are not supported.</p>
        pub fn resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(inp);
            self
        }
        pub fn set_resource_arn(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_resource_arn(inp);
            self
        }
        /// <p>The keys of the tags to be removed.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateComputeEnvironment<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_compute_environment_input::Builder,
    }
    impl<C> UpdateComputeEnvironment<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateComputeEnvironmentOutput,
            smithy_http::result::SdkError<crate::error::UpdateComputeEnvironmentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name or full Amazon Resource Name (ARN) of the compute environment to update.</p>
        pub fn compute_environment(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.compute_environment(inp);
            self
        }
        pub fn set_compute_environment(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_compute_environment(inp);
            self
        }
        /// <p>The state of the compute environment. Compute environments in the <code>ENABLED</code> state can accept jobs
        /// from a queue and scale in or out automatically based on the workload demand of its associated queues.</p>
        /// <p>If the state is <code>ENABLED</code>, then the AWS Batch scheduler can attempt to place jobs from an associated
        /// job queue on the compute resources within the environment. If the compute environment is managed, then it can scale
        /// its instances out or in automatically, based on the job queue demand.</p>
        /// <p>If the state is <code>DISABLED</code>, then the AWS Batch scheduler doesn't attempt to place jobs within the
        /// environment. Jobs in a <code>STARTING</code> or <code>RUNNING</code> state continue to progress normally. Managed
        /// compute environments in the <code>DISABLED</code> state don't scale out. However, they scale in to
        /// <code>minvCpus</code> value after instances become idle.</p>
        pub fn state(mut self, inp: crate::model::CeState) -> Self {
            self.inner = self.inner.state(inp);
            self
        }
        pub fn set_state(mut self, inp: std::option::Option<crate::model::CeState>) -> Self {
            self.inner = self.inner.set_state(inp);
            self
        }
        /// <p>Details of the compute resources managed by the compute environment. Required for a managed compute environment.
        /// For more information, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/compute_environments.html">Compute
        /// Environments</a> in the <i>AWS Batch User Guide</i>.</p>
        pub fn compute_resources(mut self, inp: crate::model::ComputeResourceUpdate) -> Self {
            self.inner = self.inner.compute_resources(inp);
            self
        }
        pub fn set_compute_resources(
            mut self,
            inp: std::option::Option<crate::model::ComputeResourceUpdate>,
        ) -> Self {
            self.inner = self.inner.set_compute_resources(inp);
            self
        }
        /// <p>The full Amazon Resource Name (ARN) of the IAM role that allows AWS Batch to make calls to other AWS services on your behalf. For
        /// more information, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/service_IAM_role.html">AWS Batch service IAM
        /// role</a> in the <i>AWS Batch User Guide</i>.</p>
        /// <important>
        /// <p>If the compute environment has a service-linked role, it cannot be changed to use a regular IAM role. If the
        /// compute environment has a regular IAM role, it cannot be changed to use a service-linked role.</p>
        /// </important>
        /// <p>If your specified role has a path other than <code>/</code>, then you must either specify the full role ARN
        /// (this is recommended) or prefix the role name with the path.</p>
        /// <note>
        /// <p>Depending on how you created your AWS Batch service role, its ARN might contain the <code>service-role</code>
        /// path prefix. When you only specify the name of the service role, AWS Batch assumes that your ARN doesn't use the
        /// <code>service-role</code> path prefix. Because of this, we recommend that you specify the full ARN of your service
        /// role when you create compute environments.</p>
        /// </note>
        pub fn service_role(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_role(inp);
            self
        }
        pub fn set_service_role(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_role(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateJobQueue<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_job_queue_input::Builder,
    }
    impl<C> UpdateJobQueue<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateJobQueueOutput,
            smithy_http::result::SdkError<crate::error::UpdateJobQueueError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name or the Amazon Resource Name (ARN) of the job queue.</p>
        pub fn job_queue(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_queue(inp);
            self
        }
        pub fn set_job_queue(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_queue(inp);
            self
        }
        /// <p>Describes the queue's ability to accept new jobs. If the job queue state is <code>ENABLED</code>, it can accept
        /// jobs. If the job queue state is <code>DISABLED</code>, new jobs can't be added to the queue, but jobs already in the
        /// queue can finish.</p>
        pub fn state(mut self, inp: crate::model::JqState) -> Self {
            self.inner = self.inner.state(inp);
            self
        }
        pub fn set_state(mut self, inp: std::option::Option<crate::model::JqState>) -> Self {
            self.inner = self.inner.set_state(inp);
            self
        }
        /// <p>The priority of the job queue. Job queues with a higher priority (or a higher integer value for the
        /// <code>priority</code> parameter) are evaluated first when associated with the same compute environment. Priority is
        /// determined in descending order, for example, a job queue with a priority value of <code>10</code> is given scheduling
        /// preference over a job queue with a priority value of <code>1</code>. All of the compute environments must be either
        /// EC2 (<code>EC2</code> or <code>SPOT</code>) or Fargate (<code>FARGATE</code> or <code>FARGATE_SPOT</code>). EC2 and
        /// Fargate compute environments can't be mixed.</p>
        pub fn priority(mut self, inp: i32) -> Self {
            self.inner = self.inner.priority(inp);
            self
        }
        pub fn set_priority(mut self, inp: i32) -> Self {
            self.inner = self.inner.set_priority(inp);
            self
        }
        /// <p>Details the set of compute environments mapped to a job queue and their order relative to each other. This is
        /// one of the parameters used by the job scheduler to determine which compute environment should run a given job.
        /// Compute environments must be in the <code>VALID</code> state before you can associate them with a job queue. All of
        /// the compute environments must be either EC2 (<code>EC2</code> or <code>SPOT</code>) or Fargate
        /// (<code>FARGATE</code> or <code>FARGATE_SPOT</code>). EC2 and Fargate compute environments can't be mixed.</p>
        /// <note>
        /// <p>All compute environments that are associated with a job queue must share the same architecture. AWS Batch doesn't
        /// support mixing compute environment architecture types in a single job queue.</p>
        /// </note>
        pub fn compute_environment_order(
            mut self,
            inp: impl Into<crate::model::ComputeEnvironmentOrder>,
        ) -> Self {
            self.inner = self.inner.compute_environment_order(inp);
            self
        }
        pub fn set_compute_environment_order(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::ComputeEnvironmentOrder>>,
        ) -> Self {
            self.inner = self.inner.set_compute_environment_order(inp);
            self
        }
    }
}
