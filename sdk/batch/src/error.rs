// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelJobError {
    pub kind: CancelJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelJobErrorKind {
    ClientError(crate::error::ClientError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelJobErrorKind::ClientError(_inner) => _inner.fmt(f),
            CancelJobErrorKind::ServerError(_inner) => _inner.fmt(f),
            CancelJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelJobError {
    fn code(&self) -> Option<&str> {
        CancelJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelJobError {
    pub fn new(kind: CancelJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, CancelJobErrorKind::ClientError(_))
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, CancelJobErrorKind::ServerError(_))
    }
}
impl std::error::Error for CancelJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelJobErrorKind::ClientError(_inner) => Some(_inner),
            CancelJobErrorKind::ServerError(_inner) => Some(_inner),
            CancelJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateComputeEnvironmentError {
    pub kind: CreateComputeEnvironmentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateComputeEnvironmentErrorKind {
    ClientError(crate::error::ClientError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateComputeEnvironmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateComputeEnvironmentErrorKind::ClientError(_inner) => _inner.fmt(f),
            CreateComputeEnvironmentErrorKind::ServerError(_inner) => _inner.fmt(f),
            CreateComputeEnvironmentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateComputeEnvironmentError {
    fn code(&self) -> Option<&str> {
        CreateComputeEnvironmentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateComputeEnvironmentError {
    pub fn new(kind: CreateComputeEnvironmentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateComputeEnvironmentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateComputeEnvironmentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateComputeEnvironmentErrorKind::ClientError(_)
        )
    }
    pub fn is_server_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateComputeEnvironmentErrorKind::ServerError(_)
        )
    }
}
impl std::error::Error for CreateComputeEnvironmentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateComputeEnvironmentErrorKind::ClientError(_inner) => Some(_inner),
            CreateComputeEnvironmentErrorKind::ServerError(_inner) => Some(_inner),
            CreateComputeEnvironmentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateJobQueueError {
    pub kind: CreateJobQueueErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateJobQueueErrorKind {
    ClientError(crate::error::ClientError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateJobQueueError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateJobQueueErrorKind::ClientError(_inner) => _inner.fmt(f),
            CreateJobQueueErrorKind::ServerError(_inner) => _inner.fmt(f),
            CreateJobQueueErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateJobQueueError {
    fn code(&self) -> Option<&str> {
        CreateJobQueueError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateJobQueueError {
    pub fn new(kind: CreateJobQueueErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateJobQueueErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateJobQueueErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, CreateJobQueueErrorKind::ClientError(_))
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, CreateJobQueueErrorKind::ServerError(_))
    }
}
impl std::error::Error for CreateJobQueueError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateJobQueueErrorKind::ClientError(_inner) => Some(_inner),
            CreateJobQueueErrorKind::ServerError(_inner) => Some(_inner),
            CreateJobQueueErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteComputeEnvironmentError {
    pub kind: DeleteComputeEnvironmentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteComputeEnvironmentErrorKind {
    ClientError(crate::error::ClientError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteComputeEnvironmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteComputeEnvironmentErrorKind::ClientError(_inner) => _inner.fmt(f),
            DeleteComputeEnvironmentErrorKind::ServerError(_inner) => _inner.fmt(f),
            DeleteComputeEnvironmentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteComputeEnvironmentError {
    fn code(&self) -> Option<&str> {
        DeleteComputeEnvironmentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteComputeEnvironmentError {
    pub fn new(kind: DeleteComputeEnvironmentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteComputeEnvironmentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteComputeEnvironmentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteComputeEnvironmentErrorKind::ClientError(_)
        )
    }
    pub fn is_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteComputeEnvironmentErrorKind::ServerError(_)
        )
    }
}
impl std::error::Error for DeleteComputeEnvironmentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteComputeEnvironmentErrorKind::ClientError(_inner) => Some(_inner),
            DeleteComputeEnvironmentErrorKind::ServerError(_inner) => Some(_inner),
            DeleteComputeEnvironmentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteJobQueueError {
    pub kind: DeleteJobQueueErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteJobQueueErrorKind {
    ClientError(crate::error::ClientError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteJobQueueError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteJobQueueErrorKind::ClientError(_inner) => _inner.fmt(f),
            DeleteJobQueueErrorKind::ServerError(_inner) => _inner.fmt(f),
            DeleteJobQueueErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteJobQueueError {
    fn code(&self) -> Option<&str> {
        DeleteJobQueueError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteJobQueueError {
    pub fn new(kind: DeleteJobQueueErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteJobQueueErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteJobQueueErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, DeleteJobQueueErrorKind::ClientError(_))
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, DeleteJobQueueErrorKind::ServerError(_))
    }
}
impl std::error::Error for DeleteJobQueueError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteJobQueueErrorKind::ClientError(_inner) => Some(_inner),
            DeleteJobQueueErrorKind::ServerError(_inner) => Some(_inner),
            DeleteJobQueueErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeregisterJobDefinitionError {
    pub kind: DeregisterJobDefinitionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeregisterJobDefinitionErrorKind {
    ClientError(crate::error::ClientError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeregisterJobDefinitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeregisterJobDefinitionErrorKind::ClientError(_inner) => _inner.fmt(f),
            DeregisterJobDefinitionErrorKind::ServerError(_inner) => _inner.fmt(f),
            DeregisterJobDefinitionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeregisterJobDefinitionError {
    fn code(&self) -> Option<&str> {
        DeregisterJobDefinitionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeregisterJobDefinitionError {
    pub fn new(kind: DeregisterJobDefinitionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeregisterJobDefinitionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeregisterJobDefinitionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, DeregisterJobDefinitionErrorKind::ClientError(_))
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, DeregisterJobDefinitionErrorKind::ServerError(_))
    }
}
impl std::error::Error for DeregisterJobDefinitionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeregisterJobDefinitionErrorKind::ClientError(_inner) => Some(_inner),
            DeregisterJobDefinitionErrorKind::ServerError(_inner) => Some(_inner),
            DeregisterJobDefinitionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeComputeEnvironmentsError {
    pub kind: DescribeComputeEnvironmentsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeComputeEnvironmentsErrorKind {
    ClientError(crate::error::ClientError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeComputeEnvironmentsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeComputeEnvironmentsErrorKind::ClientError(_inner) => _inner.fmt(f),
            DescribeComputeEnvironmentsErrorKind::ServerError(_inner) => _inner.fmt(f),
            DescribeComputeEnvironmentsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeComputeEnvironmentsError {
    fn code(&self) -> Option<&str> {
        DescribeComputeEnvironmentsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeComputeEnvironmentsError {
    pub fn new(kind: DescribeComputeEnvironmentsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeComputeEnvironmentsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeComputeEnvironmentsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeComputeEnvironmentsErrorKind::ClientError(_)
        )
    }
    pub fn is_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeComputeEnvironmentsErrorKind::ServerError(_)
        )
    }
}
impl std::error::Error for DescribeComputeEnvironmentsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeComputeEnvironmentsErrorKind::ClientError(_inner) => Some(_inner),
            DescribeComputeEnvironmentsErrorKind::ServerError(_inner) => Some(_inner),
            DescribeComputeEnvironmentsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeJobDefinitionsError {
    pub kind: DescribeJobDefinitionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeJobDefinitionsErrorKind {
    ClientError(crate::error::ClientError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeJobDefinitionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeJobDefinitionsErrorKind::ClientError(_inner) => _inner.fmt(f),
            DescribeJobDefinitionsErrorKind::ServerError(_inner) => _inner.fmt(f),
            DescribeJobDefinitionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeJobDefinitionsError {
    fn code(&self) -> Option<&str> {
        DescribeJobDefinitionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeJobDefinitionsError {
    pub fn new(kind: DescribeJobDefinitionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeJobDefinitionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeJobDefinitionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, DescribeJobDefinitionsErrorKind::ClientError(_))
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, DescribeJobDefinitionsErrorKind::ServerError(_))
    }
}
impl std::error::Error for DescribeJobDefinitionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeJobDefinitionsErrorKind::ClientError(_inner) => Some(_inner),
            DescribeJobDefinitionsErrorKind::ServerError(_inner) => Some(_inner),
            DescribeJobDefinitionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeJobQueuesError {
    pub kind: DescribeJobQueuesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeJobQueuesErrorKind {
    ClientError(crate::error::ClientError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeJobQueuesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeJobQueuesErrorKind::ClientError(_inner) => _inner.fmt(f),
            DescribeJobQueuesErrorKind::ServerError(_inner) => _inner.fmt(f),
            DescribeJobQueuesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeJobQueuesError {
    fn code(&self) -> Option<&str> {
        DescribeJobQueuesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeJobQueuesError {
    pub fn new(kind: DescribeJobQueuesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeJobQueuesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeJobQueuesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, DescribeJobQueuesErrorKind::ClientError(_))
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, DescribeJobQueuesErrorKind::ServerError(_))
    }
}
impl std::error::Error for DescribeJobQueuesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeJobQueuesErrorKind::ClientError(_inner) => Some(_inner),
            DescribeJobQueuesErrorKind::ServerError(_inner) => Some(_inner),
            DescribeJobQueuesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeJobsError {
    pub kind: DescribeJobsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeJobsErrorKind {
    ClientError(crate::error::ClientError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeJobsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeJobsErrorKind::ClientError(_inner) => _inner.fmt(f),
            DescribeJobsErrorKind::ServerError(_inner) => _inner.fmt(f),
            DescribeJobsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeJobsError {
    fn code(&self) -> Option<&str> {
        DescribeJobsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeJobsError {
    pub fn new(kind: DescribeJobsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeJobsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeJobsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, DescribeJobsErrorKind::ClientError(_))
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, DescribeJobsErrorKind::ServerError(_))
    }
}
impl std::error::Error for DescribeJobsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeJobsErrorKind::ClientError(_inner) => Some(_inner),
            DescribeJobsErrorKind::ServerError(_inner) => Some(_inner),
            DescribeJobsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListJobsError {
    pub kind: ListJobsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListJobsErrorKind {
    ClientError(crate::error::ClientError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListJobsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListJobsErrorKind::ClientError(_inner) => _inner.fmt(f),
            ListJobsErrorKind::ServerError(_inner) => _inner.fmt(f),
            ListJobsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListJobsError {
    fn code(&self) -> Option<&str> {
        ListJobsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListJobsError {
    pub fn new(kind: ListJobsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListJobsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListJobsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, ListJobsErrorKind::ClientError(_))
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, ListJobsErrorKind::ServerError(_))
    }
}
impl std::error::Error for ListJobsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListJobsErrorKind::ClientError(_inner) => Some(_inner),
            ListJobsErrorKind::ServerError(_inner) => Some(_inner),
            ListJobsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    ClientError(crate::error::ClientError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::ClientError(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ServerError(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, ListTagsForResourceErrorKind::ClientError(_))
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, ListTagsForResourceErrorKind::ServerError(_))
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::ClientError(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ServerError(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RegisterJobDefinitionError {
    pub kind: RegisterJobDefinitionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterJobDefinitionErrorKind {
    ClientError(crate::error::ClientError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RegisterJobDefinitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RegisterJobDefinitionErrorKind::ClientError(_inner) => _inner.fmt(f),
            RegisterJobDefinitionErrorKind::ServerError(_inner) => _inner.fmt(f),
            RegisterJobDefinitionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RegisterJobDefinitionError {
    fn code(&self) -> Option<&str> {
        RegisterJobDefinitionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterJobDefinitionError {
    pub fn new(kind: RegisterJobDefinitionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RegisterJobDefinitionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RegisterJobDefinitionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, RegisterJobDefinitionErrorKind::ClientError(_))
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, RegisterJobDefinitionErrorKind::ServerError(_))
    }
}
impl std::error::Error for RegisterJobDefinitionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RegisterJobDefinitionErrorKind::ClientError(_inner) => Some(_inner),
            RegisterJobDefinitionErrorKind::ServerError(_inner) => Some(_inner),
            RegisterJobDefinitionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SubmitJobError {
    pub kind: SubmitJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SubmitJobErrorKind {
    ClientError(crate::error::ClientError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SubmitJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SubmitJobErrorKind::ClientError(_inner) => _inner.fmt(f),
            SubmitJobErrorKind::ServerError(_inner) => _inner.fmt(f),
            SubmitJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SubmitJobError {
    fn code(&self) -> Option<&str> {
        SubmitJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SubmitJobError {
    pub fn new(kind: SubmitJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SubmitJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SubmitJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, SubmitJobErrorKind::ClientError(_))
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, SubmitJobErrorKind::ServerError(_))
    }
}
impl std::error::Error for SubmitJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SubmitJobErrorKind::ClientError(_inner) => Some(_inner),
            SubmitJobErrorKind::ServerError(_inner) => Some(_inner),
            SubmitJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    ClientError(crate::error::ClientError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::ClientError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ServerError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ClientError(_))
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ServerError(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::ClientError(_inner) => Some(_inner),
            TagResourceErrorKind::ServerError(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TerminateJobError {
    pub kind: TerminateJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TerminateJobErrorKind {
    ClientError(crate::error::ClientError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TerminateJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TerminateJobErrorKind::ClientError(_inner) => _inner.fmt(f),
            TerminateJobErrorKind::ServerError(_inner) => _inner.fmt(f),
            TerminateJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TerminateJobError {
    fn code(&self) -> Option<&str> {
        TerminateJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TerminateJobError {
    pub fn new(kind: TerminateJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TerminateJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TerminateJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, TerminateJobErrorKind::ClientError(_))
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, TerminateJobErrorKind::ServerError(_))
    }
}
impl std::error::Error for TerminateJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TerminateJobErrorKind::ClientError(_inner) => Some(_inner),
            TerminateJobErrorKind::ServerError(_inner) => Some(_inner),
            TerminateJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    ClientError(crate::error::ClientError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::ClientError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ServerError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ClientError(_))
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ServerError(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::ClientError(_inner) => Some(_inner),
            UntagResourceErrorKind::ServerError(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateComputeEnvironmentError {
    pub kind: UpdateComputeEnvironmentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateComputeEnvironmentErrorKind {
    ClientError(crate::error::ClientError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateComputeEnvironmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateComputeEnvironmentErrorKind::ClientError(_inner) => _inner.fmt(f),
            UpdateComputeEnvironmentErrorKind::ServerError(_inner) => _inner.fmt(f),
            UpdateComputeEnvironmentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateComputeEnvironmentError {
    fn code(&self) -> Option<&str> {
        UpdateComputeEnvironmentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateComputeEnvironmentError {
    pub fn new(kind: UpdateComputeEnvironmentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateComputeEnvironmentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateComputeEnvironmentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateComputeEnvironmentErrorKind::ClientError(_)
        )
    }
    pub fn is_server_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateComputeEnvironmentErrorKind::ServerError(_)
        )
    }
}
impl std::error::Error for UpdateComputeEnvironmentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateComputeEnvironmentErrorKind::ClientError(_inner) => Some(_inner),
            UpdateComputeEnvironmentErrorKind::ServerError(_inner) => Some(_inner),
            UpdateComputeEnvironmentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateJobQueueError {
    pub kind: UpdateJobQueueErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateJobQueueErrorKind {
    ClientError(crate::error::ClientError),
    ServerError(crate::error::ServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateJobQueueError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateJobQueueErrorKind::ClientError(_inner) => _inner.fmt(f),
            UpdateJobQueueErrorKind::ServerError(_inner) => _inner.fmt(f),
            UpdateJobQueueErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateJobQueueError {
    fn code(&self) -> Option<&str> {
        UpdateJobQueueError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateJobQueueError {
    pub fn new(kind: UpdateJobQueueErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateJobQueueErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateJobQueueErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_error(&self) -> bool {
        matches!(&self.kind, UpdateJobQueueErrorKind::ClientError(_))
    }
    pub fn is_server_error(&self) -> bool {
        matches!(&self.kind, UpdateJobQueueErrorKind::ServerError(_))
    }
}
impl std::error::Error for UpdateJobQueueError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateJobQueueErrorKind::ClientError(_inner) => Some(_inner),
            UpdateJobQueueErrorKind::ServerError(_inner) => Some(_inner),
            UpdateJobQueueErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>These errors are usually caused by a server issue.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ServerError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServerError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServerError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServerError [ServerException]")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServerError {}
/// See [`ServerError`](crate::error::ServerError)
pub mod server_error {
    /// A builder for [`ServerError`](crate::error::ServerError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServerError`](crate::error::ServerError)
        pub fn build(self) -> crate::error::ServerError {
            crate::error::ServerError {
                message: self.message,
            }
        }
    }
}
impl ServerError {
    /// Creates a new builder-style object to manufacture [`ServerError`](crate::error::ServerError)
    pub fn builder() -> crate::error::server_error::Builder {
        crate::error::server_error::Builder::default()
    }
}

/// <p>These errors are usually caused by a client action, such as using an action or resource on behalf of a user that
/// doesn't have permissions to use the action or resource, or specifying an identifier that's not valid.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ClientError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ClientError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClientError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ClientError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClientError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ClientError [ClientException]")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for ClientError {}
/// See [`ClientError`](crate::error::ClientError)
pub mod client_error {
    /// A builder for [`ClientError`](crate::error::ClientError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ClientError`](crate::error::ClientError)
        pub fn build(self) -> crate::error::ClientError {
            crate::error::ClientError {
                message: self.message,
            }
        }
    }
}
impl ClientError {
    /// Creates a new builder-style object to manufacture [`ClientError`](crate::error::ClientError)
    pub fn builder() -> crate::error::client_error::Builder {
        crate::error::client_error::Builder::default()
    }
}
