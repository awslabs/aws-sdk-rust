// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Cancels a job in an Batch job queue. Jobs that are in the <code>SUBMITTED</code>, <code>PENDING</code>, or
/// <code>RUNNABLE</code> state are canceled. Jobs that have progressed to <code>STARTING</code> or <code>RUNNING</code>
/// aren't canceled, but the API operation still succeeds, even if no job is canceled. These jobs must be terminated with
/// the <a>TerminateJob</a> operation.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CancelJob {
    _private: (),
}
impl CancelJob {
    /// Creates a new builder-style object to manufacture [`CancelJobInput`](crate::input::CancelJobInput)
    pub fn builder() -> crate::input::cancel_job_input::Builder {
        crate::input::cancel_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CancelJob {
    type Output = std::result::Result<crate::output::CancelJobOutput, crate::error::CancelJobError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_cancel_job_error(response)
        } else {
            crate::operation_deser::parse_cancel_job_response(response)
        }
    }
}

/// <p>Creates an Batch compute environment. You can create <code>MANAGED</code> or <code>UNMANAGED</code> compute
/// environments. <code>MANAGED</code> compute environments can use Amazon EC2 or Fargate resources.
/// <code>UNMANAGED</code> compute environments can only use EC2 resources.</p>
/// <p>In a managed compute environment, Batch manages the capacity and instance types of the compute resources
/// within the environment. This is based on the compute resource specification that you define or the <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html">launch template</a> that you
/// specify when you create the compute environment. Either, you can choose to use EC2 On-Demand Instances and EC2 Spot
/// Instances. Or, you can use Fargate and Fargate Spot capacity in your managed compute environment. You can
/// optionally set a maximum price so that Spot Instances only launch when the Spot Instance price is less than a
/// specified percentage of the On-Demand price.</p>
/// <note>
/// <p>Multi-node parallel jobs aren't supported on Spot Instances.</p>
/// </note>
/// <p>In an unmanaged compute environment, you can manage your own EC2 compute resources and have a lot of flexibility
/// with how you configure your compute resources. For example, you can use custom AMIs. However, you must verify that
/// each of your AMIs meet the Amazon ECS container instance AMI specification. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/container_instance_AMIs.html">container instance
/// AMIs</a> in the <i>Amazon Elastic Container Service Developer Guide</i>. After you created your unmanaged compute environment, you
/// can use the <a>DescribeComputeEnvironments</a> operation to find the Amazon ECS cluster that's associated with
/// it. Then, launch your container instances into that Amazon ECS cluster. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_container_instance.html">Launching an Amazon ECS
/// container instance</a> in the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
/// <note>
/// <p>Batch doesn't upgrade the AMIs in a compute environment after the environment is created. For example, it
/// doesn't update the AMIs when a newer version of the Amazon ECS optimized AMI is available. Therefore, you're responsible
/// for managing the guest operating system (including its updates and security patches) and any additional application
/// software or utilities that you install on the compute resources. To use a new AMI for your Batch jobs, complete
/// these steps:</p>
/// <ol>
/// <li>
/// <p>Create a new compute environment with the new AMI.</p>
/// </li>
/// <li>
/// <p>Add the compute environment to an existing job queue.</p>
/// </li>
/// <li>
/// <p>Remove the earlier compute environment from your job queue.</p>
/// </li>
/// <li>
/// <p>Delete the earlier compute environment.</p>
/// </li>
/// </ol>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateComputeEnvironment {
    _private: (),
}
impl CreateComputeEnvironment {
    /// Creates a new builder-style object to manufacture [`CreateComputeEnvironmentInput`](crate::input::CreateComputeEnvironmentInput)
    pub fn builder() -> crate::input::create_compute_environment_input::Builder {
        crate::input::create_compute_environment_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateComputeEnvironment {
    type Output = std::result::Result<
        crate::output::CreateComputeEnvironmentOutput,
        crate::error::CreateComputeEnvironmentError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_compute_environment_error(response)
        } else {
            crate::operation_deser::parse_create_compute_environment_response(response)
        }
    }
}

/// <p>Creates an Batch job queue. When you create a job queue, you associate one or more compute environments to the
/// queue and assign an order of preference for the compute environments.</p>
/// <p>You also set a priority to the job queue that determines the order that the Batch scheduler places jobs onto
/// its associated compute environments. For example, if a compute environment is associated with more than one job
/// queue, the job queue with a higher priority is given preference for scheduling jobs to that compute
/// environment.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateJobQueue {
    _private: (),
}
impl CreateJobQueue {
    /// Creates a new builder-style object to manufacture [`CreateJobQueueInput`](crate::input::CreateJobQueueInput)
    pub fn builder() -> crate::input::create_job_queue_input::Builder {
        crate::input::create_job_queue_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateJobQueue {
    type Output =
        std::result::Result<crate::output::CreateJobQueueOutput, crate::error::CreateJobQueueError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_job_queue_error(response)
        } else {
            crate::operation_deser::parse_create_job_queue_response(response)
        }
    }
}

/// <p>Deletes an Batch compute environment.</p>
/// <p>Before you can delete a compute environment, you must set its state to <code>DISABLED</code> with the <a>UpdateComputeEnvironment</a> API operation and disassociate it from any job queues with the <a>UpdateJobQueue</a> API operation. Compute environments that use Fargate resources must terminate all
/// active jobs on that compute environment before deleting the compute environment. If this isn't done, the compute
/// environment enters an invalid state.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteComputeEnvironment {
    _private: (),
}
impl DeleteComputeEnvironment {
    /// Creates a new builder-style object to manufacture [`DeleteComputeEnvironmentInput`](crate::input::DeleteComputeEnvironmentInput)
    pub fn builder() -> crate::input::delete_compute_environment_input::Builder {
        crate::input::delete_compute_environment_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteComputeEnvironment {
    type Output = std::result::Result<
        crate::output::DeleteComputeEnvironmentOutput,
        crate::error::DeleteComputeEnvironmentError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_compute_environment_error(response)
        } else {
            crate::operation_deser::parse_delete_compute_environment_response(response)
        }
    }
}

/// <p>Deletes the specified job queue. You must first disable submissions for a queue with the <a>UpdateJobQueue</a> operation. All jobs in the queue are eventually terminated when you delete a job queue.
/// The jobs are terminated at a rate of about 16 jobs each second.</p>
/// <p>It's not necessary to disassociate compute environments from a queue before submitting a
/// <code>DeleteJobQueue</code> request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteJobQueue {
    _private: (),
}
impl DeleteJobQueue {
    /// Creates a new builder-style object to manufacture [`DeleteJobQueueInput`](crate::input::DeleteJobQueueInput)
    pub fn builder() -> crate::input::delete_job_queue_input::Builder {
        crate::input::delete_job_queue_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteJobQueue {
    type Output =
        std::result::Result<crate::output::DeleteJobQueueOutput, crate::error::DeleteJobQueueError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_job_queue_error(response)
        } else {
            crate::operation_deser::parse_delete_job_queue_response(response)
        }
    }
}

/// <p>Deregisters an Batch job definition. Job definitions are permanently deleted after 180 days.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeregisterJobDefinition {
    _private: (),
}
impl DeregisterJobDefinition {
    /// Creates a new builder-style object to manufacture [`DeregisterJobDefinitionInput`](crate::input::DeregisterJobDefinitionInput)
    pub fn builder() -> crate::input::deregister_job_definition_input::Builder {
        crate::input::deregister_job_definition_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeregisterJobDefinition {
    type Output = std::result::Result<
        crate::output::DeregisterJobDefinitionOutput,
        crate::error::DeregisterJobDefinitionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_deregister_job_definition_error(response)
        } else {
            crate::operation_deser::parse_deregister_job_definition_response(response)
        }
    }
}

/// <p>Describes one or more of your compute environments.</p>
/// <p>If you're using an unmanaged compute environment, you can use the <code>DescribeComputeEnvironment</code>
/// operation to determine the <code>ecsClusterArn</code> that you should launch your Amazon ECS container instances
/// into.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeComputeEnvironments {
    _private: (),
}
impl DescribeComputeEnvironments {
    /// Creates a new builder-style object to manufacture [`DescribeComputeEnvironmentsInput`](crate::input::DescribeComputeEnvironmentsInput)
    pub fn builder() -> crate::input::describe_compute_environments_input::Builder {
        crate::input::describe_compute_environments_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeComputeEnvironments {
    type Output = std::result::Result<
        crate::output::DescribeComputeEnvironmentsOutput,
        crate::error::DescribeComputeEnvironmentsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_compute_environments_error(response)
        } else {
            crate::operation_deser::parse_describe_compute_environments_response(response)
        }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod describe_compute_environments_request_test {
    /// This test case validates a bug where unboxed primitives were incorrectly marked as required
    /// Test ID: DeserializeDescribeCompute
    #[tokio::test]
    async fn deserialize_describe_compute_response() {
        let expected_output = crate::output::DescribeComputeEnvironmentsOutput::builder()
            .set_compute_environments(Some(vec![crate::model::ComputeEnvironmentDetail::builder(
            )
            .set_compute_environment_name(Some("test-batch-compute".to_string()))
            .set_compute_environment_arn(Some("arn".to_string()))
            .set_ecs_cluster_arn(Some("clusteran".to_string()))
            .set_tags(Some({
                let mut ret = std::collections::HashMap::new();
                ret.insert("foo".to_string(), "bar".to_string());
                ret
            }))
            .set_type(Some(crate::model::CeType::from("MANAGED")))
            .set_state(Some(crate::model::CeState::from("ENABLED")))
            .set_status(Some(crate::model::CeStatus::from("VALID")))
            .set_status_reason(Some("ComputeEnvironment Healthy".to_string()))
            .set_compute_resources(Some(
                crate::model::ComputeResource::builder()
                    .set_type(Some(crate::model::CrType::from("EC2")))
                    .set_minv_cpus(Some(0))
                    .set_maxv_cpus(Some(256))
                    .set_desiredv_cpus(Some(0))
                    .set_instance_types(Some(vec!["optimal".to_string()]))
                    .set_subnets(Some(vec![
                        "subnet-c745b79c".to_string(),
                        "subnet-d4e24fe8".to_string(),
                    ]))
                    .set_security_group_ids(Some(vec!["sg-06a55e7b".to_string()]))
                    .set_instance_role(Some("instancerole".to_string()))
                    .set_tags(Some({
                        let mut ret = std::collections::HashMap::new();
                        ret.insert("Name".to_string(), "batch-compute".to_string());
                        ret
                    }))
                    .set_ec2_configuration(Some(vec![crate::model::Ec2Configuration::builder()
                        .set_image_type(Some("ECS_AL1".to_string()))
                        .build()]))
                    .build(),
            ))
            .set_service_role(Some(
                "arn:aws:iam::432762038596:role/service-role/AWSBatchServiceRole".to_string(),
            ))
            .build()]))
            .build();
        let http_response = http::response::Builder::new()
        .status(200)
                        .body(smithy_http::body::SdkBody::from("    {\n        \"computeEnvironments\":[{\n            \"computeEnvironmentName\":\"test-batch-compute\",\n            \"computeEnvironmentArn\":\"arn\",\n            \"ecsClusterArn\":\"clusteran\",\n            \"tags\":{\"foo\": \"bar\"},\n            \"type\":\"MANAGED\",\n            \"state\":\"ENABLED\",\n            \"status\":\"VALID\",\n            \"statusReason\":\"ComputeEnvironment Healthy\",\n            \"computeResources\":{\n                \"type\":\"EC2\",\n                \"minvCpus\":0,\n                \"maxvCpus\":256,\n                \"desiredvCpus\":0,\n                \"instanceTypes\":[\"optimal\"],\n                \"subnets\":[\"subnet-c745b79c\",\"subnet-d4e24fe8\"],\n                \"securityGroupIds\":[\"sg-06a55e7b\"],\n                \"instanceRole\":\"instancerole\",\n                \"tags\":{\"Name\":\"batch-compute\"},\n                \"ec2Configuration\":[{\"imageType\":\"ECS_AL1\"}]\n            },\n            \"serviceRole\":\"arn:aws:iam::432762038596:role/service-role/AWSBatchServiceRole\"\n        }]\n    }\n"))
                        .unwrap();
        let mut op_response = smithy_http::operation::Response::new(http_response);
        use smithy_http::response::ParseHttpResponse;
        let parser = crate::operation::DescribeComputeEnvironments::new();
        let parsed = parser.parse_unloaded(&mut op_response);
        let parsed = parsed.unwrap_or_else(|| {
                        let (http_response, _) = op_response.into_parts();
                        let http_response = http_response.map(|body|bytes::Bytes::copy_from_slice(body.bytes().unwrap()));
                        <crate::operation::DescribeComputeEnvironments as smithy_http::response::ParseHttpResponse>::parse_loaded(&parser, &http_response)
                    });
        let parsed = parsed.unwrap();
        assert_eq!(
            parsed.compute_environments, expected_output.compute_environments,
            "Unexpected value for `compute_environments`"
        );
        assert_eq!(
            parsed.next_token, expected_output.next_token,
            "Unexpected value for `next_token`"
        );
    }
}

/// <p>Describes a list of job definitions. You can specify a <code>status</code> (such as <code>ACTIVE</code>) to only
/// return job definitions that match that status.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeJobDefinitions {
    _private: (),
}
impl DescribeJobDefinitions {
    /// Creates a new builder-style object to manufacture [`DescribeJobDefinitionsInput`](crate::input::DescribeJobDefinitionsInput)
    pub fn builder() -> crate::input::describe_job_definitions_input::Builder {
        crate::input::describe_job_definitions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeJobDefinitions {
    type Output = std::result::Result<
        crate::output::DescribeJobDefinitionsOutput,
        crate::error::DescribeJobDefinitionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_job_definitions_error(response)
        } else {
            crate::operation_deser::parse_describe_job_definitions_response(response)
        }
    }
}

/// <p>Describes one or more of your job queues.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeJobQueues {
    _private: (),
}
impl DescribeJobQueues {
    /// Creates a new builder-style object to manufacture [`DescribeJobQueuesInput`](crate::input::DescribeJobQueuesInput)
    pub fn builder() -> crate::input::describe_job_queues_input::Builder {
        crate::input::describe_job_queues_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeJobQueues {
    type Output = std::result::Result<
        crate::output::DescribeJobQueuesOutput,
        crate::error::DescribeJobQueuesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_job_queues_error(response)
        } else {
            crate::operation_deser::parse_describe_job_queues_response(response)
        }
    }
}

/// <p>Describes a list of Batch jobs.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeJobs {
    _private: (),
}
impl DescribeJobs {
    /// Creates a new builder-style object to manufacture [`DescribeJobsInput`](crate::input::DescribeJobsInput)
    pub fn builder() -> crate::input::describe_jobs_input::Builder {
        crate::input::describe_jobs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeJobs {
    type Output =
        std::result::Result<crate::output::DescribeJobsOutput, crate::error::DescribeJobsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_jobs_error(response)
        } else {
            crate::operation_deser::parse_describe_jobs_response(response)
        }
    }
}

/// <p>Returns a list of Batch jobs.</p>
/// <p>You must specify only one of the following items:</p>
/// <ul>
/// <li>
/// <p>A job queue ID to return a list of jobs in that job queue</p>
/// </li>
/// <li>
/// <p>A multi-node parallel job ID to return a list of nodes for that job</p>
/// </li>
/// <li>
/// <p>An array job ID to return a list of the children for that job</p>
/// </li>
/// </ul>
/// <p>You can filter the results by job status with the <code>jobStatus</code> parameter. If you don't specify a
/// status, only <code>RUNNING</code> jobs are returned.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListJobs {
    _private: (),
}
impl ListJobs {
    /// Creates a new builder-style object to manufacture [`ListJobsInput`](crate::input::ListJobsInput)
    pub fn builder() -> crate::input::list_jobs_input::Builder {
        crate::input::list_jobs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListJobs {
    type Output = std::result::Result<crate::output::ListJobsOutput, crate::error::ListJobsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_jobs_error(response)
        } else {
            crate::operation_deser::parse_list_jobs_response(response)
        }
    }
}

/// <p>Lists the tags for an Batch resource. Batch resources that support tags are compute environments, jobs, job definitions, and job
/// queues. ARNs for child jobs of array and multi-node parallel (MNP) jobs are not supported.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p>Registers an Batch job definition.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RegisterJobDefinition {
    _private: (),
}
impl RegisterJobDefinition {
    /// Creates a new builder-style object to manufacture [`RegisterJobDefinitionInput`](crate::input::RegisterJobDefinitionInput)
    pub fn builder() -> crate::input::register_job_definition_input::Builder {
        crate::input::register_job_definition_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RegisterJobDefinition {
    type Output = std::result::Result<
        crate::output::RegisterJobDefinitionOutput,
        crate::error::RegisterJobDefinitionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_register_job_definition_error(response)
        } else {
            crate::operation_deser::parse_register_job_definition_response(response)
        }
    }
}

/// <p>Submits an Batch job from a job definition. Parameters that are specified during <a>SubmitJob</a>
/// override parameters defined in the job definition. vCPU and memory requirements that are specified in the
/// <code>ResourceRequirements</code> objects in the job definition are the exception. They can't be overridden this way
/// using the <code>memory</code> and <code>vcpus</code> parameters. Rather, you must specify updates to job definition
/// parameters in a <code>ResourceRequirements</code> object that's included in the <code>containerOverrides</code>
/// parameter.</p>
/// <important>
/// <p>Jobs that run on Fargate resources can't be guaranteed to run for more than 14 days. This is because, after 14
/// days, Fargate resources might become unavailable and job might be terminated.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SubmitJob {
    _private: (),
}
impl SubmitJob {
    /// Creates a new builder-style object to manufacture [`SubmitJobInput`](crate::input::SubmitJobInput)
    pub fn builder() -> crate::input::submit_job_input::Builder {
        crate::input::submit_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SubmitJob {
    type Output = std::result::Result<crate::output::SubmitJobOutput, crate::error::SubmitJobError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_submit_job_error(response)
        } else {
            crate::operation_deser::parse_submit_job_response(response)
        }
    }
}

/// <p>Associates the specified tags to a resource with the specified <code>resourceArn</code>. If existing tags on a
/// resource aren't specified in the request parameters, they aren't changed. When a resource is deleted, the tags that
/// are associated with that resource are deleted as well. Batch resources that support tags are compute environments, jobs, job definitions, and job
/// queues. ARNs for child jobs of array and multi-node parallel (MNP) jobs are not supported.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p>Terminates a job in a job queue. Jobs that are in the <code>STARTING</code> or <code>RUNNING</code> state are
/// terminated, which causes them to transition to <code>FAILED</code>. Jobs that have not progressed to the
/// <code>STARTING</code> state are cancelled.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TerminateJob {
    _private: (),
}
impl TerminateJob {
    /// Creates a new builder-style object to manufacture [`TerminateJobInput`](crate::input::TerminateJobInput)
    pub fn builder() -> crate::input::terminate_job_input::Builder {
        crate::input::terminate_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TerminateJob {
    type Output =
        std::result::Result<crate::output::TerminateJobOutput, crate::error::TerminateJobError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_terminate_job_error(response)
        } else {
            crate::operation_deser::parse_terminate_job_response(response)
        }
    }
}

/// <p>Deletes specified tags from an Batch resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}

/// <p>Updates an Batch compute environment.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateComputeEnvironment {
    _private: (),
}
impl UpdateComputeEnvironment {
    /// Creates a new builder-style object to manufacture [`UpdateComputeEnvironmentInput`](crate::input::UpdateComputeEnvironmentInput)
    pub fn builder() -> crate::input::update_compute_environment_input::Builder {
        crate::input::update_compute_environment_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateComputeEnvironment {
    type Output = std::result::Result<
        crate::output::UpdateComputeEnvironmentOutput,
        crate::error::UpdateComputeEnvironmentError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_compute_environment_error(response)
        } else {
            crate::operation_deser::parse_update_compute_environment_response(response)
        }
    }
}

/// <p>Updates a job queue.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateJobQueue {
    _private: (),
}
impl UpdateJobQueue {
    /// Creates a new builder-style object to manufacture [`UpdateJobQueueInput`](crate::input::UpdateJobQueueInput)
    pub fn builder() -> crate::input::update_job_queue_input::Builder {
        crate::input::update_job_queue_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateJobQueue {
    type Output =
        std::result::Result<crate::output::UpdateJobQueueOutput, crate::error::UpdateJobQueueError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_job_queue_error(response)
        } else {
            crate::operation_deser::parse_update_job_queue_response(response)
        }
    }
}
