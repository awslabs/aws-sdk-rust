// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::create_privacy_budget_template::_create_privacy_budget_template_output::CreatePrivacyBudgetTemplateOutputBuilder;

pub use crate::operation::create_privacy_budget_template::_create_privacy_budget_template_input::CreatePrivacyBudgetTemplateInputBuilder;

impl crate::operation::create_privacy_budget_template::builders::CreatePrivacyBudgetTemplateInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::create_privacy_budget_template::CreatePrivacyBudgetTemplateOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_privacy_budget_template::CreatePrivacyBudgetTemplateError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.create_privacy_budget_template();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `CreatePrivacyBudgetTemplate`.
///
/// <p>Creates a privacy budget template for a specified membership. Each membership can have only one privacy budget template, but it can be deleted and recreated. If you need to change the privacy budget template for a membership, use the <code>UpdatePrivacyBudgetTemplate</code> operation.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct CreatePrivacyBudgetTemplateFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::create_privacy_budget_template::builders::CreatePrivacyBudgetTemplateInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::create_privacy_budget_template::CreatePrivacyBudgetTemplateOutput,
        crate::operation::create_privacy_budget_template::CreatePrivacyBudgetTemplateError,
    > for CreatePrivacyBudgetTemplateFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::create_privacy_budget_template::CreatePrivacyBudgetTemplateOutput,
            crate::operation::create_privacy_budget_template::CreatePrivacyBudgetTemplateError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl CreatePrivacyBudgetTemplateFluentBuilder {
    /// Creates a new `CreatePrivacyBudgetTemplate`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the CreatePrivacyBudgetTemplate as a reference.
    pub fn as_input(&self) -> &crate::operation::create_privacy_budget_template::builders::CreatePrivacyBudgetTemplateInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::create_privacy_budget_template::CreatePrivacyBudgetTemplateOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_privacy_budget_template::CreatePrivacyBudgetTemplateError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::create_privacy_budget_template::CreatePrivacyBudgetTemplate::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::create_privacy_budget_template::CreatePrivacyBudgetTemplate::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::create_privacy_budget_template::CreatePrivacyBudgetTemplateOutput,
        crate::operation::create_privacy_budget_template::CreatePrivacyBudgetTemplateError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl ::std::convert::Into<crate::config::Builder>) -> Self {
        self.set_config_override(::std::option::Option::Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: ::std::option::Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>A unique identifier for one of your memberships for a collaboration. The privacy budget template is created in the collaboration that this membership belongs to. Accepts a membership ID.</p>
    pub fn membership_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.membership_identifier(input.into());
        self
    }
    /// <p>A unique identifier for one of your memberships for a collaboration. The privacy budget template is created in the collaboration that this membership belongs to. Accepts a membership ID.</p>
    pub fn set_membership_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_membership_identifier(input);
        self
    }
    /// <p>A unique identifier for one of your memberships for a collaboration. The privacy budget template is created in the collaboration that this membership belongs to. Accepts a membership ID.</p>
    pub fn get_membership_identifier(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_membership_identifier()
    }
    /// <p>How often the privacy budget refreshes.</p><important>
    /// <p>If you plan to regularly bring new data into the collaboration, you can use <code>CALENDAR_MONTH</code> to automatically get a new privacy budget for the collaboration every calendar month. Choosing this option allows arbitrary amounts of information to be revealed about rows of the data when repeatedly queries across refreshes. Avoid choosing this if the same rows will be repeatedly queried between privacy budget refreshes.</p>
    /// </important>
    pub fn auto_refresh(mut self, input: crate::types::PrivacyBudgetTemplateAutoRefresh) -> Self {
        self.inner = self.inner.auto_refresh(input);
        self
    }
    /// <p>How often the privacy budget refreshes.</p><important>
    /// <p>If you plan to regularly bring new data into the collaboration, you can use <code>CALENDAR_MONTH</code> to automatically get a new privacy budget for the collaboration every calendar month. Choosing this option allows arbitrary amounts of information to be revealed about rows of the data when repeatedly queries across refreshes. Avoid choosing this if the same rows will be repeatedly queried between privacy budget refreshes.</p>
    /// </important>
    pub fn set_auto_refresh(mut self, input: ::std::option::Option<crate::types::PrivacyBudgetTemplateAutoRefresh>) -> Self {
        self.inner = self.inner.set_auto_refresh(input);
        self
    }
    /// <p>How often the privacy budget refreshes.</p><important>
    /// <p>If you plan to regularly bring new data into the collaboration, you can use <code>CALENDAR_MONTH</code> to automatically get a new privacy budget for the collaboration every calendar month. Choosing this option allows arbitrary amounts of information to be revealed about rows of the data when repeatedly queries across refreshes. Avoid choosing this if the same rows will be repeatedly queried between privacy budget refreshes.</p>
    /// </important>
    pub fn get_auto_refresh(&self) -> &::std::option::Option<crate::types::PrivacyBudgetTemplateAutoRefresh> {
        self.inner.get_auto_refresh()
    }
    /// <p>Specifies the type of the privacy budget template.</p>
    pub fn privacy_budget_type(mut self, input: crate::types::PrivacyBudgetType) -> Self {
        self.inner = self.inner.privacy_budget_type(input);
        self
    }
    /// <p>Specifies the type of the privacy budget template.</p>
    pub fn set_privacy_budget_type(mut self, input: ::std::option::Option<crate::types::PrivacyBudgetType>) -> Self {
        self.inner = self.inner.set_privacy_budget_type(input);
        self
    }
    /// <p>Specifies the type of the privacy budget template.</p>
    pub fn get_privacy_budget_type(&self) -> &::std::option::Option<crate::types::PrivacyBudgetType> {
        self.inner.get_privacy_budget_type()
    }
    /// <p>Specifies your parameters for the privacy budget template.</p>
    pub fn parameters(mut self, input: crate::types::PrivacyBudgetTemplateParametersInput) -> Self {
        self.inner = self.inner.parameters(input);
        self
    }
    /// <p>Specifies your parameters for the privacy budget template.</p>
    pub fn set_parameters(mut self, input: ::std::option::Option<crate::types::PrivacyBudgetTemplateParametersInput>) -> Self {
        self.inner = self.inner.set_parameters(input);
        self
    }
    /// <p>Specifies your parameters for the privacy budget template.</p>
    pub fn get_parameters(&self) -> &::std::option::Option<crate::types::PrivacyBudgetTemplateParametersInput> {
        self.inner.get_parameters()
    }
    ///
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.</p>
    pub fn tags(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.tags(k.into(), v.into());
        self
    }
    /// <p>An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.inner = self.inner.set_tags(input);
        self
    }
    /// <p>An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.inner.get_tags()
    }
}
