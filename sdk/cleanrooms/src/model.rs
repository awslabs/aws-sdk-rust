// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Describes validation errors for specific input parameters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ValidationExceptionField {
    /// <p>The name of the input parameter.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A message for the input validation error.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ValidationExceptionField {
    /// <p>The name of the input parameter.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A message for the input validation error.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
/// See [`ValidationExceptionField`](crate::model::ValidationExceptionField).
pub mod validation_exception_field {

    /// A builder for [`ValidationExceptionField`](crate::model::ValidationExceptionField).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the input parameter.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the input parameter.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A message for the input validation error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message for the input validation error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ValidationExceptionField`](crate::model::ValidationExceptionField).
        pub fn build(self) -> crate::model::ValidationExceptionField {
            crate::model::ValidationExceptionField {
                name: self.name,
                message: self.message,
            }
        }
    }
}
impl ValidationExceptionField {
    /// Creates a new builder-style object to manufacture [`ValidationExceptionField`](crate::model::ValidationExceptionField).
    pub fn builder() -> crate::model::validation_exception_field::Builder {
        crate::model::validation_exception_field::Builder::default()
    }
}

/// When writing a match expression against `ValidationExceptionReason`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let validationexceptionreason = unimplemented!();
/// match validationexceptionreason {
///     ValidationExceptionReason::FieldValidationFailed => { /* ... */ },
///     ValidationExceptionReason::InvalidConfiguration => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `validationexceptionreason` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ValidationExceptionReason::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ValidationExceptionReason::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ValidationExceptionReason::NewFeature` is defined.
/// Specifically, when `validationexceptionreason` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ValidationExceptionReason::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ValidationExceptionReason {
    #[allow(missing_docs)] // documentation missing in model
    FieldValidationFailed,
    #[allow(missing_docs)] // documentation missing in model
    InvalidConfiguration,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ValidationExceptionReason {
    fn from(s: &str) -> Self {
        match s {
            "FIELD_VALIDATION_FAILED" => ValidationExceptionReason::FieldValidationFailed,
            "INVALID_CONFIGURATION" => ValidationExceptionReason::InvalidConfiguration,
            other => ValidationExceptionReason::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ValidationExceptionReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ValidationExceptionReason::from(s))
    }
}
impl ValidationExceptionReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ValidationExceptionReason::FieldValidationFailed => "FIELD_VALIDATION_FAILED",
            ValidationExceptionReason::InvalidConfiguration => "INVALID_CONFIGURATION",
            ValidationExceptionReason::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FIELD_VALIDATION_FAILED", "INVALID_CONFIGURATION"]
    }
}
impl AsRef<str> for ValidationExceptionReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ResourceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let resourcetype = unimplemented!();
/// match resourcetype {
///     ResourceType::Collaboration => { /* ... */ },
///     ResourceType::ConfiguredTable => { /* ... */ },
///     ResourceType::ConfiguredTableAssociation => { /* ... */ },
///     ResourceType::Membership => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `resourcetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ResourceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ResourceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ResourceType::NewFeature` is defined.
/// Specifically, when `resourcetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ResourceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceType {
    #[allow(missing_docs)] // documentation missing in model
    Collaboration,
    #[allow(missing_docs)] // documentation missing in model
    ConfiguredTable,
    #[allow(missing_docs)] // documentation missing in model
    ConfiguredTableAssociation,
    #[allow(missing_docs)] // documentation missing in model
    Membership,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ResourceType {
    fn from(s: &str) -> Self {
        match s {
            "COLLABORATION" => ResourceType::Collaboration,
            "CONFIGURED_TABLE" => ResourceType::ConfiguredTable,
            "CONFIGURED_TABLE_ASSOCIATION" => ResourceType::ConfiguredTableAssociation,
            "MEMBERSHIP" => ResourceType::Membership,
            other => ResourceType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ResourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResourceType::from(s))
    }
}
impl ResourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ResourceType::Collaboration => "COLLABORATION",
            ResourceType::ConfiguredTable => "CONFIGURED_TABLE",
            ResourceType::ConfiguredTableAssociation => "CONFIGURED_TABLE_ASSOCIATION",
            ResourceType::Membership => "MEMBERSHIP",
            ResourceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "COLLABORATION",
            "CONFIGURED_TABLE",
            "CONFIGURED_TABLE_ASSOCIATION",
            "MEMBERSHIP",
        ]
    }
}
impl AsRef<str> for ResourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ConflictExceptionReason`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let conflictexceptionreason = unimplemented!();
/// match conflictexceptionreason {
///     ConflictExceptionReason::AlreadyExists => { /* ... */ },
///     ConflictExceptionReason::InvalidState => { /* ... */ },
///     ConflictExceptionReason::SubresourcesExist => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `conflictexceptionreason` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConflictExceptionReason::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConflictExceptionReason::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConflictExceptionReason::NewFeature` is defined.
/// Specifically, when `conflictexceptionreason` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConflictExceptionReason::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConflictExceptionReason {
    #[allow(missing_docs)] // documentation missing in model
    AlreadyExists,
    #[allow(missing_docs)] // documentation missing in model
    InvalidState,
    #[allow(missing_docs)] // documentation missing in model
    SubresourcesExist,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ConflictExceptionReason {
    fn from(s: &str) -> Self {
        match s {
            "ALREADY_EXISTS" => ConflictExceptionReason::AlreadyExists,
            "INVALID_STATE" => ConflictExceptionReason::InvalidState,
            "SUBRESOURCES_EXIST" => ConflictExceptionReason::SubresourcesExist,
            other => ConflictExceptionReason::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ConflictExceptionReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConflictExceptionReason::from(s))
    }
}
impl ConflictExceptionReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConflictExceptionReason::AlreadyExists => "ALREADY_EXISTS",
            ConflictExceptionReason::InvalidState => "INVALID_STATE",
            ConflictExceptionReason::SubresourcesExist => "SUBRESOURCES_EXIST",
            ConflictExceptionReason::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALREADY_EXISTS", "INVALID_STATE", "SUBRESOURCES_EXIST"]
    }
}
impl AsRef<str> for ConflictExceptionReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `AccessDeniedExceptionReason`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let accessdeniedexceptionreason = unimplemented!();
/// match accessdeniedexceptionreason {
///     AccessDeniedExceptionReason::InsufficientPermissions => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `accessdeniedexceptionreason` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AccessDeniedExceptionReason::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AccessDeniedExceptionReason::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AccessDeniedExceptionReason::NewFeature` is defined.
/// Specifically, when `accessdeniedexceptionreason` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AccessDeniedExceptionReason::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AccessDeniedExceptionReason {
    #[allow(missing_docs)] // documentation missing in model
    InsufficientPermissions,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AccessDeniedExceptionReason {
    fn from(s: &str) -> Self {
        match s {
            "INSUFFICIENT_PERMISSIONS" => AccessDeniedExceptionReason::InsufficientPermissions,
            other => AccessDeniedExceptionReason::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for AccessDeniedExceptionReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AccessDeniedExceptionReason::from(s))
    }
}
impl AccessDeniedExceptionReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AccessDeniedExceptionReason::InsufficientPermissions => "INSUFFICIENT_PERMISSIONS",
            AccessDeniedExceptionReason::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["INSUFFICIENT_PERMISSIONS"]
    }
}
impl AsRef<str> for AccessDeniedExceptionReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The parameters for an AWS Clean Rooms protected query.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProtectedQuery {
    /// <p>The identifier for a protected query instance.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The identifier for the membership.</p>
    #[doc(hidden)]
    pub membership_id: std::option::Option<std::string::String>,
    /// <p>The ARN of the membership.</p>
    #[doc(hidden)]
    pub membership_arn: std::option::Option<std::string::String>,
    /// <p>The time at which the protected query was created.</p>
    #[doc(hidden)]
    pub create_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The protected query SQL parameters.</p>
    #[doc(hidden)]
    pub sql_parameters: std::option::Option<crate::model::ProtectedQuerySqlParameters>,
    /// <p>The status of the query.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ProtectedQueryStatus>,
    /// <p>Contains any details needed to write the query results.</p>
    #[doc(hidden)]
    pub result_configuration: std::option::Option<crate::model::ProtectedQueryResultConfiguration>,
    /// <p>Statistics about protected query execution.</p>
    #[doc(hidden)]
    pub statistics: std::option::Option<crate::model::ProtectedQueryStatistics>,
    /// <p>The result of the protected query.</p>
    #[doc(hidden)]
    pub result: std::option::Option<crate::model::ProtectedQueryResult>,
    /// <p>An error thrown by the protected query.</p>
    #[doc(hidden)]
    pub error: std::option::Option<crate::model::ProtectedQueryError>,
}
impl ProtectedQuery {
    /// <p>The identifier for a protected query instance.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The identifier for the membership.</p>
    pub fn membership_id(&self) -> std::option::Option<&str> {
        self.membership_id.as_deref()
    }
    /// <p>The ARN of the membership.</p>
    pub fn membership_arn(&self) -> std::option::Option<&str> {
        self.membership_arn.as_deref()
    }
    /// <p>The time at which the protected query was created.</p>
    pub fn create_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.create_time.as_ref()
    }
    /// <p>The protected query SQL parameters.</p>
    pub fn sql_parameters(
        &self,
    ) -> std::option::Option<&crate::model::ProtectedQuerySqlParameters> {
        self.sql_parameters.as_ref()
    }
    /// <p>The status of the query.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ProtectedQueryStatus> {
        self.status.as_ref()
    }
    /// <p>Contains any details needed to write the query results.</p>
    pub fn result_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ProtectedQueryResultConfiguration> {
        self.result_configuration.as_ref()
    }
    /// <p>Statistics about protected query execution.</p>
    pub fn statistics(&self) -> std::option::Option<&crate::model::ProtectedQueryStatistics> {
        self.statistics.as_ref()
    }
    /// <p>The result of the protected query.</p>
    pub fn result(&self) -> std::option::Option<&crate::model::ProtectedQueryResult> {
        self.result.as_ref()
    }
    /// <p>An error thrown by the protected query.</p>
    pub fn error(&self) -> std::option::Option<&crate::model::ProtectedQueryError> {
        self.error.as_ref()
    }
}
impl std::fmt::Debug for ProtectedQuery {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProtectedQuery");
        formatter.field("id", &self.id);
        formatter.field("membership_id", &self.membership_id);
        formatter.field("membership_arn", &self.membership_arn);
        formatter.field("create_time", &self.create_time);
        formatter.field("sql_parameters", &"*** Sensitive Data Redacted ***");
        formatter.field("status", &self.status);
        formatter.field("result_configuration", &self.result_configuration);
        formatter.field("statistics", &self.statistics);
        formatter.field("result", &self.result);
        formatter.field("error", &self.error);
        formatter.finish()
    }
}
/// See [`ProtectedQuery`](crate::model::ProtectedQuery).
pub mod protected_query {

    /// A builder for [`ProtectedQuery`](crate::model::ProtectedQuery).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) membership_id: std::option::Option<std::string::String>,
        pub(crate) membership_arn: std::option::Option<std::string::String>,
        pub(crate) create_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) sql_parameters: std::option::Option<crate::model::ProtectedQuerySqlParameters>,
        pub(crate) status: std::option::Option<crate::model::ProtectedQueryStatus>,
        pub(crate) result_configuration:
            std::option::Option<crate::model::ProtectedQueryResultConfiguration>,
        pub(crate) statistics: std::option::Option<crate::model::ProtectedQueryStatistics>,
        pub(crate) result: std::option::Option<crate::model::ProtectedQueryResult>,
        pub(crate) error: std::option::Option<crate::model::ProtectedQueryError>,
    }
    impl Builder {
        /// <p>The identifier for a protected query instance.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier for a protected query instance.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The identifier for the membership.</p>
        pub fn membership_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.membership_id = Some(input.into());
            self
        }
        /// <p>The identifier for the membership.</p>
        pub fn set_membership_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.membership_id = input;
            self
        }
        /// <p>The ARN of the membership.</p>
        pub fn membership_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.membership_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the membership.</p>
        pub fn set_membership_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.membership_arn = input;
            self
        }
        /// <p>The time at which the protected query was created.</p>
        pub fn create_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.create_time = Some(input);
            self
        }
        /// <p>The time at which the protected query was created.</p>
        pub fn set_create_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The protected query SQL parameters.</p>
        pub fn sql_parameters(mut self, input: crate::model::ProtectedQuerySqlParameters) -> Self {
            self.sql_parameters = Some(input);
            self
        }
        /// <p>The protected query SQL parameters.</p>
        pub fn set_sql_parameters(
            mut self,
            input: std::option::Option<crate::model::ProtectedQuerySqlParameters>,
        ) -> Self {
            self.sql_parameters = input;
            self
        }
        /// <p>The status of the query.</p>
        pub fn status(mut self, input: crate::model::ProtectedQueryStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the query.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ProtectedQueryStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>Contains any details needed to write the query results.</p>
        pub fn result_configuration(
            mut self,
            input: crate::model::ProtectedQueryResultConfiguration,
        ) -> Self {
            self.result_configuration = Some(input);
            self
        }
        /// <p>Contains any details needed to write the query results.</p>
        pub fn set_result_configuration(
            mut self,
            input: std::option::Option<crate::model::ProtectedQueryResultConfiguration>,
        ) -> Self {
            self.result_configuration = input;
            self
        }
        /// <p>Statistics about protected query execution.</p>
        pub fn statistics(mut self, input: crate::model::ProtectedQueryStatistics) -> Self {
            self.statistics = Some(input);
            self
        }
        /// <p>Statistics about protected query execution.</p>
        pub fn set_statistics(
            mut self,
            input: std::option::Option<crate::model::ProtectedQueryStatistics>,
        ) -> Self {
            self.statistics = input;
            self
        }
        /// <p>The result of the protected query.</p>
        pub fn result(mut self, input: crate::model::ProtectedQueryResult) -> Self {
            self.result = Some(input);
            self
        }
        /// <p>The result of the protected query.</p>
        pub fn set_result(
            mut self,
            input: std::option::Option<crate::model::ProtectedQueryResult>,
        ) -> Self {
            self.result = input;
            self
        }
        /// <p>An error thrown by the protected query.</p>
        pub fn error(mut self, input: crate::model::ProtectedQueryError) -> Self {
            self.error = Some(input);
            self
        }
        /// <p>An error thrown by the protected query.</p>
        pub fn set_error(
            mut self,
            input: std::option::Option<crate::model::ProtectedQueryError>,
        ) -> Self {
            self.error = input;
            self
        }
        /// Consumes the builder and constructs a [`ProtectedQuery`](crate::model::ProtectedQuery).
        pub fn build(self) -> crate::model::ProtectedQuery {
            crate::model::ProtectedQuery {
                id: self.id,
                membership_id: self.membership_id,
                membership_arn: self.membership_arn,
                create_time: self.create_time,
                sql_parameters: self.sql_parameters,
                status: self.status,
                result_configuration: self.result_configuration,
                statistics: self.statistics,
                result: self.result,
                error: self.error,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("id", &self.id);
            formatter.field("membership_id", &self.membership_id);
            formatter.field("membership_arn", &self.membership_arn);
            formatter.field("create_time", &self.create_time);
            formatter.field("sql_parameters", &"*** Sensitive Data Redacted ***");
            formatter.field("status", &self.status);
            formatter.field("result_configuration", &self.result_configuration);
            formatter.field("statistics", &self.statistics);
            formatter.field("result", &self.result);
            formatter.field("error", &self.error);
            formatter.finish()
        }
    }
}
impl ProtectedQuery {
    /// Creates a new builder-style object to manufacture [`ProtectedQuery`](crate::model::ProtectedQuery).
    pub fn builder() -> crate::model::protected_query::Builder {
        crate::model::protected_query::Builder::default()
    }
}

/// <p>Details of errors thrown by the protected query.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProtectedQueryError {
    /// <p>A description of why the query failed.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>An error code for the error.</p>
    #[doc(hidden)]
    pub code: std::option::Option<std::string::String>,
}
impl ProtectedQueryError {
    /// <p>A description of why the query failed.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>An error code for the error.</p>
    pub fn code(&self) -> std::option::Option<&str> {
        self.code.as_deref()
    }
}
/// See [`ProtectedQueryError`](crate::model::ProtectedQueryError).
pub mod protected_query_error {

    /// A builder for [`ProtectedQueryError`](crate::model::ProtectedQueryError).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A description of why the query failed.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A description of why the query failed.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>An error code for the error.</p>
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        /// <p>An error code for the error.</p>
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// Consumes the builder and constructs a [`ProtectedQueryError`](crate::model::ProtectedQueryError).
        pub fn build(self) -> crate::model::ProtectedQueryError {
            crate::model::ProtectedQueryError {
                message: self.message,
                code: self.code,
            }
        }
    }
}
impl ProtectedQueryError {
    /// Creates a new builder-style object to manufacture [`ProtectedQueryError`](crate::model::ProtectedQueryError).
    pub fn builder() -> crate::model::protected_query_error::Builder {
        crate::model::protected_query_error::Builder::default()
    }
}

/// <p>Details about the query results.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProtectedQueryResult {
    /// <p>The output of the protected query.</p>
    #[doc(hidden)]
    pub output: std::option::Option<crate::model::ProtectedQueryOutput>,
}
impl ProtectedQueryResult {
    /// <p>The output of the protected query.</p>
    pub fn output(&self) -> std::option::Option<&crate::model::ProtectedQueryOutput> {
        self.output.as_ref()
    }
}
/// See [`ProtectedQueryResult`](crate::model::ProtectedQueryResult).
pub mod protected_query_result {

    /// A builder for [`ProtectedQueryResult`](crate::model::ProtectedQueryResult).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) output: std::option::Option<crate::model::ProtectedQueryOutput>,
    }
    impl Builder {
        /// <p>The output of the protected query.</p>
        pub fn output(mut self, input: crate::model::ProtectedQueryOutput) -> Self {
            self.output = Some(input);
            self
        }
        /// <p>The output of the protected query.</p>
        pub fn set_output(
            mut self,
            input: std::option::Option<crate::model::ProtectedQueryOutput>,
        ) -> Self {
            self.output = input;
            self
        }
        /// Consumes the builder and constructs a [`ProtectedQueryResult`](crate::model::ProtectedQueryResult).
        pub fn build(self) -> crate::model::ProtectedQueryResult {
            crate::model::ProtectedQueryResult {
                output: self.output,
            }
        }
    }
}
impl ProtectedQueryResult {
    /// Creates a new builder-style object to manufacture [`ProtectedQueryResult`](crate::model::ProtectedQueryResult).
    pub fn builder() -> crate::model::protected_query_result::Builder {
        crate::model::protected_query_result::Builder::default()
    }
}

/// <p>Contains details about the protected query output.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum ProtectedQueryOutput {
    /// <p>If present, the output for a protected query with an `S3` output type.</p>
    S3(crate::model::ProtectedQueryS3Output),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl ProtectedQueryOutput {
    #[allow(irrefutable_let_patterns)]
    /// Tries to convert the enum instance into [`S3`](crate::model::ProtectedQueryOutput::S3), extracting the inner [`ProtectedQueryS3Output`](crate::model::ProtectedQueryS3Output).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_s3(&self) -> std::result::Result<&crate::model::ProtectedQueryS3Output, &Self> {
        if let ProtectedQueryOutput::S3(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`S3`](crate::model::ProtectedQueryOutput::S3).
    pub fn is_s3(&self) -> bool {
        self.as_s3().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Contains output information for protected queries with an S3 output type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProtectedQueryS3Output {
    /// <p>The S3 location of the result.</p>
    #[doc(hidden)]
    pub location: std::option::Option<std::string::String>,
}
impl ProtectedQueryS3Output {
    /// <p>The S3 location of the result.</p>
    pub fn location(&self) -> std::option::Option<&str> {
        self.location.as_deref()
    }
}
/// See [`ProtectedQueryS3Output`](crate::model::ProtectedQueryS3Output).
pub mod protected_query_s3_output {

    /// A builder for [`ProtectedQueryS3Output`](crate::model::ProtectedQueryS3Output).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) location: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The S3 location of the result.</p>
        pub fn location(mut self, input: impl Into<std::string::String>) -> Self {
            self.location = Some(input.into());
            self
        }
        /// <p>The S3 location of the result.</p>
        pub fn set_location(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.location = input;
            self
        }
        /// Consumes the builder and constructs a [`ProtectedQueryS3Output`](crate::model::ProtectedQueryS3Output).
        pub fn build(self) -> crate::model::ProtectedQueryS3Output {
            crate::model::ProtectedQueryS3Output {
                location: self.location,
            }
        }
    }
}
impl ProtectedQueryS3Output {
    /// Creates a new builder-style object to manufacture [`ProtectedQueryS3Output`](crate::model::ProtectedQueryS3Output).
    pub fn builder() -> crate::model::protected_query_s3_output::Builder {
        crate::model::protected_query_s3_output::Builder::default()
    }
}

/// <p>Contains statistics about the execution of the protected query.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProtectedQueryStatistics {
    /// <p>The duration of the Protected Query, from creation until query completion.</p>
    #[doc(hidden)]
    pub total_duration_in_millis: std::option::Option<i64>,
}
impl ProtectedQueryStatistics {
    /// <p>The duration of the Protected Query, from creation until query completion.</p>
    pub fn total_duration_in_millis(&self) -> std::option::Option<i64> {
        self.total_duration_in_millis
    }
}
/// See [`ProtectedQueryStatistics`](crate::model::ProtectedQueryStatistics).
pub mod protected_query_statistics {

    /// A builder for [`ProtectedQueryStatistics`](crate::model::ProtectedQueryStatistics).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) total_duration_in_millis: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The duration of the Protected Query, from creation until query completion.</p>
        pub fn total_duration_in_millis(mut self, input: i64) -> Self {
            self.total_duration_in_millis = Some(input);
            self
        }
        /// <p>The duration of the Protected Query, from creation until query completion.</p>
        pub fn set_total_duration_in_millis(mut self, input: std::option::Option<i64>) -> Self {
            self.total_duration_in_millis = input;
            self
        }
        /// Consumes the builder and constructs a [`ProtectedQueryStatistics`](crate::model::ProtectedQueryStatistics).
        pub fn build(self) -> crate::model::ProtectedQueryStatistics {
            crate::model::ProtectedQueryStatistics {
                total_duration_in_millis: self.total_duration_in_millis,
            }
        }
    }
}
impl ProtectedQueryStatistics {
    /// Creates a new builder-style object to manufacture [`ProtectedQueryStatistics`](crate::model::ProtectedQueryStatistics).
    pub fn builder() -> crate::model::protected_query_statistics::Builder {
        crate::model::protected_query_statistics::Builder::default()
    }
}

/// <p>Contains configurations for protected query results.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProtectedQueryResultConfiguration {
    /// <p>Configuration for protected query results.</p>
    #[doc(hidden)]
    pub output_configuration: std::option::Option<crate::model::ProtectedQueryOutputConfiguration>,
}
impl ProtectedQueryResultConfiguration {
    /// <p>Configuration for protected query results.</p>
    pub fn output_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ProtectedQueryOutputConfiguration> {
        self.output_configuration.as_ref()
    }
}
/// See [`ProtectedQueryResultConfiguration`](crate::model::ProtectedQueryResultConfiguration).
pub mod protected_query_result_configuration {

    /// A builder for [`ProtectedQueryResultConfiguration`](crate::model::ProtectedQueryResultConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) output_configuration:
            std::option::Option<crate::model::ProtectedQueryOutputConfiguration>,
    }
    impl Builder {
        /// <p>Configuration for protected query results.</p>
        pub fn output_configuration(
            mut self,
            input: crate::model::ProtectedQueryOutputConfiguration,
        ) -> Self {
            self.output_configuration = Some(input);
            self
        }
        /// <p>Configuration for protected query results.</p>
        pub fn set_output_configuration(
            mut self,
            input: std::option::Option<crate::model::ProtectedQueryOutputConfiguration>,
        ) -> Self {
            self.output_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`ProtectedQueryResultConfiguration`](crate::model::ProtectedQueryResultConfiguration).
        pub fn build(self) -> crate::model::ProtectedQueryResultConfiguration {
            crate::model::ProtectedQueryResultConfiguration {
                output_configuration: self.output_configuration,
            }
        }
    }
}
impl ProtectedQueryResultConfiguration {
    /// Creates a new builder-style object to manufacture [`ProtectedQueryResultConfiguration`](crate::model::ProtectedQueryResultConfiguration).
    pub fn builder() -> crate::model::protected_query_result_configuration::Builder {
        crate::model::protected_query_result_configuration::Builder::default()
    }
}

/// <p>Contains configuration details for protected query output.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum ProtectedQueryOutputConfiguration {
    /// <p>Required configuration for a protected query with an `S3` output type.</p>
    S3(crate::model::ProtectedQueryS3OutputConfiguration),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl ProtectedQueryOutputConfiguration {
    #[allow(irrefutable_let_patterns)]
    /// Tries to convert the enum instance into [`S3`](crate::model::ProtectedQueryOutputConfiguration::S3), extracting the inner [`ProtectedQueryS3OutputConfiguration`](crate::model::ProtectedQueryS3OutputConfiguration).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_s3(
        &self,
    ) -> std::result::Result<&crate::model::ProtectedQueryS3OutputConfiguration, &Self> {
        if let ProtectedQueryOutputConfiguration::S3(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`S3`](crate::model::ProtectedQueryOutputConfiguration::S3).
    pub fn is_s3(&self) -> bool {
        self.as_s3().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Contains the configuration to write the query results to S3.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProtectedQueryS3OutputConfiguration {
    /// <p>Intended file format of the result.</p>
    #[doc(hidden)]
    pub result_format: std::option::Option<crate::model::ResultFormat>,
    /// <p>The S3 bucket to unload the protected query results.</p>
    #[doc(hidden)]
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The S3 prefix to unload the protected query results.</p>
    #[doc(hidden)]
    pub key_prefix: std::option::Option<std::string::String>,
}
impl ProtectedQueryS3OutputConfiguration {
    /// <p>Intended file format of the result.</p>
    pub fn result_format(&self) -> std::option::Option<&crate::model::ResultFormat> {
        self.result_format.as_ref()
    }
    /// <p>The S3 bucket to unload the protected query results.</p>
    pub fn bucket(&self) -> std::option::Option<&str> {
        self.bucket.as_deref()
    }
    /// <p>The S3 prefix to unload the protected query results.</p>
    pub fn key_prefix(&self) -> std::option::Option<&str> {
        self.key_prefix.as_deref()
    }
}
/// See [`ProtectedQueryS3OutputConfiguration`](crate::model::ProtectedQueryS3OutputConfiguration).
pub mod protected_query_s3_output_configuration {

    /// A builder for [`ProtectedQueryS3OutputConfiguration`](crate::model::ProtectedQueryS3OutputConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) result_format: std::option::Option<crate::model::ResultFormat>,
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key_prefix: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Intended file format of the result.</p>
        pub fn result_format(mut self, input: crate::model::ResultFormat) -> Self {
            self.result_format = Some(input);
            self
        }
        /// <p>Intended file format of the result.</p>
        pub fn set_result_format(
            mut self,
            input: std::option::Option<crate::model::ResultFormat>,
        ) -> Self {
            self.result_format = input;
            self
        }
        /// <p>The S3 bucket to unload the protected query results.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        /// <p>The S3 bucket to unload the protected query results.</p>
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The S3 prefix to unload the protected query results.</p>
        pub fn key_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_prefix = Some(input.into());
            self
        }
        /// <p>The S3 prefix to unload the protected query results.</p>
        pub fn set_key_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_prefix = input;
            self
        }
        /// Consumes the builder and constructs a [`ProtectedQueryS3OutputConfiguration`](crate::model::ProtectedQueryS3OutputConfiguration).
        pub fn build(self) -> crate::model::ProtectedQueryS3OutputConfiguration {
            crate::model::ProtectedQueryS3OutputConfiguration {
                result_format: self.result_format,
                bucket: self.bucket,
                key_prefix: self.key_prefix,
            }
        }
    }
}
impl ProtectedQueryS3OutputConfiguration {
    /// Creates a new builder-style object to manufacture [`ProtectedQueryS3OutputConfiguration`](crate::model::ProtectedQueryS3OutputConfiguration).
    pub fn builder() -> crate::model::protected_query_s3_output_configuration::Builder {
        crate::model::protected_query_s3_output_configuration::Builder::default()
    }
}

/// When writing a match expression against `ResultFormat`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let resultformat = unimplemented!();
/// match resultformat {
///     ResultFormat::Csv => { /* ... */ },
///     ResultFormat::Parquet => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `resultformat` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ResultFormat::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ResultFormat::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ResultFormat::NewFeature` is defined.
/// Specifically, when `resultformat` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ResultFormat::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResultFormat {
    #[allow(missing_docs)] // documentation missing in model
    Csv,
    #[allow(missing_docs)] // documentation missing in model
    Parquet,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ResultFormat {
    fn from(s: &str) -> Self {
        match s {
            "CSV" => ResultFormat::Csv,
            "PARQUET" => ResultFormat::Parquet,
            other => ResultFormat::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ResultFormat {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResultFormat::from(s))
    }
}
impl ResultFormat {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ResultFormat::Csv => "CSV",
            ResultFormat::Parquet => "PARQUET",
            ResultFormat::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CSV", "PARQUET"]
    }
}
impl AsRef<str> for ResultFormat {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ProtectedQueryStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let protectedquerystatus = unimplemented!();
/// match protectedquerystatus {
///     ProtectedQueryStatus::Cancelled => { /* ... */ },
///     ProtectedQueryStatus::Cancelling => { /* ... */ },
///     ProtectedQueryStatus::Failed => { /* ... */ },
///     ProtectedQueryStatus::Started => { /* ... */ },
///     ProtectedQueryStatus::Submitted => { /* ... */ },
///     ProtectedQueryStatus::Success => { /* ... */ },
///     ProtectedQueryStatus::TimedOut => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `protectedquerystatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ProtectedQueryStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ProtectedQueryStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ProtectedQueryStatus::NewFeature` is defined.
/// Specifically, when `protectedquerystatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ProtectedQueryStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProtectedQueryStatus {
    #[allow(missing_docs)] // documentation missing in model
    Cancelled,
    #[allow(missing_docs)] // documentation missing in model
    Cancelling,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Started,
    #[allow(missing_docs)] // documentation missing in model
    Submitted,
    #[allow(missing_docs)] // documentation missing in model
    Success,
    #[allow(missing_docs)] // documentation missing in model
    TimedOut,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ProtectedQueryStatus {
    fn from(s: &str) -> Self {
        match s {
            "CANCELLED" => ProtectedQueryStatus::Cancelled,
            "CANCELLING" => ProtectedQueryStatus::Cancelling,
            "FAILED" => ProtectedQueryStatus::Failed,
            "STARTED" => ProtectedQueryStatus::Started,
            "SUBMITTED" => ProtectedQueryStatus::Submitted,
            "SUCCESS" => ProtectedQueryStatus::Success,
            "TIMED_OUT" => ProtectedQueryStatus::TimedOut,
            other => {
                ProtectedQueryStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ProtectedQueryStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProtectedQueryStatus::from(s))
    }
}
impl ProtectedQueryStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ProtectedQueryStatus::Cancelled => "CANCELLED",
            ProtectedQueryStatus::Cancelling => "CANCELLING",
            ProtectedQueryStatus::Failed => "FAILED",
            ProtectedQueryStatus::Started => "STARTED",
            ProtectedQueryStatus::Submitted => "SUBMITTED",
            ProtectedQueryStatus::Success => "SUCCESS",
            ProtectedQueryStatus::TimedOut => "TIMED_OUT",
            ProtectedQueryStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CANCELLED",
            "CANCELLING",
            "FAILED",
            "STARTED",
            "SUBMITTED",
            "SUCCESS",
            "TIMED_OUT",
        ]
    }
}
impl AsRef<str> for ProtectedQueryStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The parameters for the SQL type Protected Query.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProtectedQuerySqlParameters {
    /// <p>The query string to be submitted.</p>
    #[doc(hidden)]
    pub query_string: std::option::Option<std::string::String>,
}
impl ProtectedQuerySqlParameters {
    /// <p>The query string to be submitted.</p>
    pub fn query_string(&self) -> std::option::Option<&str> {
        self.query_string.as_deref()
    }
}
impl std::fmt::Debug for ProtectedQuerySqlParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProtectedQuerySqlParameters");
        formatter.field("query_string", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`ProtectedQuerySqlParameters`](crate::model::ProtectedQuerySqlParameters).
pub mod protected_query_sql_parameters {

    /// A builder for [`ProtectedQuerySqlParameters`](crate::model::ProtectedQuerySqlParameters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) query_string: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The query string to be submitted.</p>
        pub fn query_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_string = Some(input.into());
            self
        }
        /// <p>The query string to be submitted.</p>
        pub fn set_query_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query_string = input;
            self
        }
        /// Consumes the builder and constructs a [`ProtectedQuerySqlParameters`](crate::model::ProtectedQuerySqlParameters).
        pub fn build(self) -> crate::model::ProtectedQuerySqlParameters {
            crate::model::ProtectedQuerySqlParameters {
                query_string: self.query_string,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("query_string", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl ProtectedQuerySqlParameters {
    /// Creates a new builder-style object to manufacture [`ProtectedQuerySqlParameters`](crate::model::ProtectedQuerySqlParameters).
    pub fn builder() -> crate::model::protected_query_sql_parameters::Builder {
        crate::model::protected_query_sql_parameters::Builder::default()
    }
}

/// When writing a match expression against `TargetProtectedQueryStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let targetprotectedquerystatus = unimplemented!();
/// match targetprotectedquerystatus {
///     TargetProtectedQueryStatus::Cancelled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `targetprotectedquerystatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TargetProtectedQueryStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TargetProtectedQueryStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TargetProtectedQueryStatus::NewFeature` is defined.
/// Specifically, when `targetprotectedquerystatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TargetProtectedQueryStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TargetProtectedQueryStatus {
    #[allow(missing_docs)] // documentation missing in model
    Cancelled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TargetProtectedQueryStatus {
    fn from(s: &str) -> Self {
        match s {
            "CANCELLED" => TargetProtectedQueryStatus::Cancelled,
            other => TargetProtectedQueryStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for TargetProtectedQueryStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TargetProtectedQueryStatus::from(s))
    }
}
impl TargetProtectedQueryStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TargetProtectedQueryStatus::Cancelled => "CANCELLED",
            TargetProtectedQueryStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CANCELLED"]
    }
}
impl AsRef<str> for TargetProtectedQueryStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ProtectedQueryType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let protectedquerytype = unimplemented!();
/// match protectedquerytype {
///     ProtectedQueryType::Sql => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `protectedquerytype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ProtectedQueryType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ProtectedQueryType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ProtectedQueryType::NewFeature` is defined.
/// Specifically, when `protectedquerytype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ProtectedQueryType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProtectedQueryType {
    #[allow(missing_docs)] // documentation missing in model
    Sql,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ProtectedQueryType {
    fn from(s: &str) -> Self {
        match s {
            "SQL" => ProtectedQueryType::Sql,
            other => {
                ProtectedQueryType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ProtectedQueryType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProtectedQueryType::from(s))
    }
}
impl ProtectedQueryType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ProtectedQueryType::Sql => "SQL",
            ProtectedQueryType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["SQL"]
    }
}
impl AsRef<str> for ProtectedQueryType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The protected query summary for the objects listed by the request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProtectedQuerySummary {
    /// <p>The unique ID of the protected query.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The unique ID for the membership that initiated the protected query.</p>
    #[doc(hidden)]
    pub membership_id: std::option::Option<std::string::String>,
    /// <p>The unique ARN for the membership that initiated the protected query.</p>
    #[doc(hidden)]
    pub membership_arn: std::option::Option<std::string::String>,
    /// <p>The time the protected query was created.</p>
    #[doc(hidden)]
    pub create_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The status of the protected query. Value values are `SUBMITTED`, `STARTED`, `CANCELLED`, `CANCELLING`, `FAILED`, `SUCCESS`, `TIMED_OUT`.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ProtectedQueryStatus>,
}
impl ProtectedQuerySummary {
    /// <p>The unique ID of the protected query.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The unique ID for the membership that initiated the protected query.</p>
    pub fn membership_id(&self) -> std::option::Option<&str> {
        self.membership_id.as_deref()
    }
    /// <p>The unique ARN for the membership that initiated the protected query.</p>
    pub fn membership_arn(&self) -> std::option::Option<&str> {
        self.membership_arn.as_deref()
    }
    /// <p>The time the protected query was created.</p>
    pub fn create_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.create_time.as_ref()
    }
    /// <p>The status of the protected query. Value values are `SUBMITTED`, `STARTED`, `CANCELLED`, `CANCELLING`, `FAILED`, `SUCCESS`, `TIMED_OUT`.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ProtectedQueryStatus> {
        self.status.as_ref()
    }
}
/// See [`ProtectedQuerySummary`](crate::model::ProtectedQuerySummary).
pub mod protected_query_summary {

    /// A builder for [`ProtectedQuerySummary`](crate::model::ProtectedQuerySummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) membership_id: std::option::Option<std::string::String>,
        pub(crate) membership_arn: std::option::Option<std::string::String>,
        pub(crate) create_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) status: std::option::Option<crate::model::ProtectedQueryStatus>,
    }
    impl Builder {
        /// <p>The unique ID of the protected query.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique ID of the protected query.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The unique ID for the membership that initiated the protected query.</p>
        pub fn membership_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.membership_id = Some(input.into());
            self
        }
        /// <p>The unique ID for the membership that initiated the protected query.</p>
        pub fn set_membership_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.membership_id = input;
            self
        }
        /// <p>The unique ARN for the membership that initiated the protected query.</p>
        pub fn membership_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.membership_arn = Some(input.into());
            self
        }
        /// <p>The unique ARN for the membership that initiated the protected query.</p>
        pub fn set_membership_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.membership_arn = input;
            self
        }
        /// <p>The time the protected query was created.</p>
        pub fn create_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.create_time = Some(input);
            self
        }
        /// <p>The time the protected query was created.</p>
        pub fn set_create_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The status of the protected query. Value values are `SUBMITTED`, `STARTED`, `CANCELLED`, `CANCELLING`, `FAILED`, `SUCCESS`, `TIMED_OUT`.</p>
        pub fn status(mut self, input: crate::model::ProtectedQueryStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the protected query. Value values are `SUBMITTED`, `STARTED`, `CANCELLED`, `CANCELLING`, `FAILED`, `SUCCESS`, `TIMED_OUT`.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ProtectedQueryStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`ProtectedQuerySummary`](crate::model::ProtectedQuerySummary).
        pub fn build(self) -> crate::model::ProtectedQuerySummary {
            crate::model::ProtectedQuerySummary {
                id: self.id,
                membership_id: self.membership_id,
                membership_arn: self.membership_arn,
                create_time: self.create_time,
                status: self.status,
            }
        }
    }
}
impl ProtectedQuerySummary {
    /// Creates a new builder-style object to manufacture [`ProtectedQuerySummary`](crate::model::ProtectedQuerySummary).
    pub fn builder() -> crate::model::protected_query_summary::Builder {
        crate::model::protected_query_summary::Builder::default()
    }
}

/// <p>The membership object listed by the request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MembershipSummary {
    /// <p>The unique ID for the membership's collaboration.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The unique ARN for the membership.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The unique ARN for the membership's associated collaboration.</p>
    #[doc(hidden)]
    pub collaboration_arn: std::option::Option<std::string::String>,
    /// <p>The unique ID for the membership's collaboration.</p>
    #[doc(hidden)]
    pub collaboration_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the AWS principal that created the collaboration. Currently only supports AWS account ID.</p>
    #[doc(hidden)]
    pub collaboration_creator_account_id: std::option::Option<std::string::String>,
    /// <p>The display name of the collaboration creator.</p>
    #[doc(hidden)]
    pub collaboration_creator_display_name: std::option::Option<std::string::String>,
    /// <p>The name for the membership's collaboration.</p>
    #[doc(hidden)]
    pub collaboration_name: std::option::Option<std::string::String>,
    /// <p>The time when the membership was created.</p>
    #[doc(hidden)]
    pub create_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time the membership metadata was last updated.</p>
    #[doc(hidden)]
    pub update_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The status of the membership. Valid values are `ACTIVE`, `REMOVED`, and `COLLABORATION_DELETED`.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::MembershipStatus>,
    /// <p>The abilities granted to the collaboration member.</p>
    #[doc(hidden)]
    pub member_abilities: std::option::Option<std::vec::Vec<crate::model::MemberAbility>>,
}
impl MembershipSummary {
    /// <p>The unique ID for the membership's collaboration.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The unique ARN for the membership.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The unique ARN for the membership's associated collaboration.</p>
    pub fn collaboration_arn(&self) -> std::option::Option<&str> {
        self.collaboration_arn.as_deref()
    }
    /// <p>The unique ID for the membership's collaboration.</p>
    pub fn collaboration_id(&self) -> std::option::Option<&str> {
        self.collaboration_id.as_deref()
    }
    /// <p>The identifier of the AWS principal that created the collaboration. Currently only supports AWS account ID.</p>
    pub fn collaboration_creator_account_id(&self) -> std::option::Option<&str> {
        self.collaboration_creator_account_id.as_deref()
    }
    /// <p>The display name of the collaboration creator.</p>
    pub fn collaboration_creator_display_name(&self) -> std::option::Option<&str> {
        self.collaboration_creator_display_name.as_deref()
    }
    /// <p>The name for the membership's collaboration.</p>
    pub fn collaboration_name(&self) -> std::option::Option<&str> {
        self.collaboration_name.as_deref()
    }
    /// <p>The time when the membership was created.</p>
    pub fn create_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.create_time.as_ref()
    }
    /// <p>The time the membership metadata was last updated.</p>
    pub fn update_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.update_time.as_ref()
    }
    /// <p>The status of the membership. Valid values are `ACTIVE`, `REMOVED`, and `COLLABORATION_DELETED`.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::MembershipStatus> {
        self.status.as_ref()
    }
    /// <p>The abilities granted to the collaboration member.</p>
    pub fn member_abilities(&self) -> std::option::Option<&[crate::model::MemberAbility]> {
        self.member_abilities.as_deref()
    }
}
/// See [`MembershipSummary`](crate::model::MembershipSummary).
pub mod membership_summary {

    /// A builder for [`MembershipSummary`](crate::model::MembershipSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) collaboration_arn: std::option::Option<std::string::String>,
        pub(crate) collaboration_id: std::option::Option<std::string::String>,
        pub(crate) collaboration_creator_account_id: std::option::Option<std::string::String>,
        pub(crate) collaboration_creator_display_name: std::option::Option<std::string::String>,
        pub(crate) collaboration_name: std::option::Option<std::string::String>,
        pub(crate) create_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) status: std::option::Option<crate::model::MembershipStatus>,
        pub(crate) member_abilities:
            std::option::Option<std::vec::Vec<crate::model::MemberAbility>>,
    }
    impl Builder {
        /// <p>The unique ID for the membership's collaboration.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique ID for the membership's collaboration.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The unique ARN for the membership.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The unique ARN for the membership.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The unique ARN for the membership's associated collaboration.</p>
        pub fn collaboration_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.collaboration_arn = Some(input.into());
            self
        }
        /// <p>The unique ARN for the membership's associated collaboration.</p>
        pub fn set_collaboration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.collaboration_arn = input;
            self
        }
        /// <p>The unique ID for the membership's collaboration.</p>
        pub fn collaboration_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.collaboration_id = Some(input.into());
            self
        }
        /// <p>The unique ID for the membership's collaboration.</p>
        pub fn set_collaboration_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.collaboration_id = input;
            self
        }
        /// <p>The identifier of the AWS principal that created the collaboration. Currently only supports AWS account ID.</p>
        pub fn collaboration_creator_account_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.collaboration_creator_account_id = Some(input.into());
            self
        }
        /// <p>The identifier of the AWS principal that created the collaboration. Currently only supports AWS account ID.</p>
        pub fn set_collaboration_creator_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.collaboration_creator_account_id = input;
            self
        }
        /// <p>The display name of the collaboration creator.</p>
        pub fn collaboration_creator_display_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.collaboration_creator_display_name = Some(input.into());
            self
        }
        /// <p>The display name of the collaboration creator.</p>
        pub fn set_collaboration_creator_display_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.collaboration_creator_display_name = input;
            self
        }
        /// <p>The name for the membership's collaboration.</p>
        pub fn collaboration_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.collaboration_name = Some(input.into());
            self
        }
        /// <p>The name for the membership's collaboration.</p>
        pub fn set_collaboration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.collaboration_name = input;
            self
        }
        /// <p>The time when the membership was created.</p>
        pub fn create_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.create_time = Some(input);
            self
        }
        /// <p>The time when the membership was created.</p>
        pub fn set_create_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The time the membership metadata was last updated.</p>
        pub fn update_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_time = Some(input);
            self
        }
        /// <p>The time the membership metadata was last updated.</p>
        pub fn set_update_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.update_time = input;
            self
        }
        /// <p>The status of the membership. Valid values are `ACTIVE`, `REMOVED`, and `COLLABORATION_DELETED`.</p>
        pub fn status(mut self, input: crate::model::MembershipStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the membership. Valid values are `ACTIVE`, `REMOVED`, and `COLLABORATION_DELETED`.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::MembershipStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Appends an item to `member_abilities`.
        ///
        /// To override the contents of this collection use [`set_member_abilities`](Self::set_member_abilities).
        ///
        /// <p>The abilities granted to the collaboration member.</p>
        pub fn member_abilities(mut self, input: crate::model::MemberAbility) -> Self {
            let mut v = self.member_abilities.unwrap_or_default();
            v.push(input);
            self.member_abilities = Some(v);
            self
        }
        /// <p>The abilities granted to the collaboration member.</p>
        pub fn set_member_abilities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MemberAbility>>,
        ) -> Self {
            self.member_abilities = input;
            self
        }
        /// Consumes the builder and constructs a [`MembershipSummary`](crate::model::MembershipSummary).
        pub fn build(self) -> crate::model::MembershipSummary {
            crate::model::MembershipSummary {
                id: self.id,
                arn: self.arn,
                collaboration_arn: self.collaboration_arn,
                collaboration_id: self.collaboration_id,
                collaboration_creator_account_id: self.collaboration_creator_account_id,
                collaboration_creator_display_name: self.collaboration_creator_display_name,
                collaboration_name: self.collaboration_name,
                create_time: self.create_time,
                update_time: self.update_time,
                status: self.status,
                member_abilities: self.member_abilities,
            }
        }
    }
}
impl MembershipSummary {
    /// Creates a new builder-style object to manufacture [`MembershipSummary`](crate::model::MembershipSummary).
    pub fn builder() -> crate::model::membership_summary::Builder {
        crate::model::membership_summary::Builder::default()
    }
}

/// When writing a match expression against `MemberAbility`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let memberability = unimplemented!();
/// match memberability {
///     MemberAbility::CanQuery => { /* ... */ },
///     MemberAbility::CanReceiveResults => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `memberability` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `MemberAbility::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `MemberAbility::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `MemberAbility::NewFeature` is defined.
/// Specifically, when `memberability` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `MemberAbility::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MemberAbility {
    #[allow(missing_docs)] // documentation missing in model
    CanQuery,
    #[allow(missing_docs)] // documentation missing in model
    CanReceiveResults,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for MemberAbility {
    fn from(s: &str) -> Self {
        match s {
            "CAN_QUERY" => MemberAbility::CanQuery,
            "CAN_RECEIVE_RESULTS" => MemberAbility::CanReceiveResults,
            other => MemberAbility::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for MemberAbility {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MemberAbility::from(s))
    }
}
impl MemberAbility {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MemberAbility::CanQuery => "CAN_QUERY",
            MemberAbility::CanReceiveResults => "CAN_RECEIVE_RESULTS",
            MemberAbility::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CAN_QUERY", "CAN_RECEIVE_RESULTS"]
    }
}
impl AsRef<str> for MemberAbility {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `MembershipStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let membershipstatus = unimplemented!();
/// match membershipstatus {
///     MembershipStatus::Active => { /* ... */ },
///     MembershipStatus::CollaborationDeleted => { /* ... */ },
///     MembershipStatus::Removed => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `membershipstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `MembershipStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `MembershipStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `MembershipStatus::NewFeature` is defined.
/// Specifically, when `membershipstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `MembershipStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MembershipStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    CollaborationDeleted,
    #[allow(missing_docs)] // documentation missing in model
    Removed,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for MembershipStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => MembershipStatus::Active,
            "COLLABORATION_DELETED" => MembershipStatus::CollaborationDeleted,
            "REMOVED" => MembershipStatus::Removed,
            other => MembershipStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for MembershipStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MembershipStatus::from(s))
    }
}
impl MembershipStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MembershipStatus::Active => "ACTIVE",
            MembershipStatus::CollaborationDeleted => "COLLABORATION_DELETED",
            MembershipStatus::Removed => "REMOVED",
            MembershipStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "COLLABORATION_DELETED", "REMOVED"]
    }
}
impl AsRef<str> for MembershipStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The membership object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Membership {
    /// <p>The unique ID of the membership.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The unique ARN for the membership.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The unique ARN for the membership's associated collaboration.</p>
    #[doc(hidden)]
    pub collaboration_arn: std::option::Option<std::string::String>,
    /// <p>The unique ID for the membership's collaboration.</p>
    #[doc(hidden)]
    pub collaboration_id: std::option::Option<std::string::String>,
    /// <p>The identifier used to reference members of the collaboration. Currently only supports AWS account ID.</p>
    #[doc(hidden)]
    pub collaboration_creator_account_id: std::option::Option<std::string::String>,
    /// <p>The display name of the collaboration creator.</p>
    #[doc(hidden)]
    pub collaboration_creator_display_name: std::option::Option<std::string::String>,
    /// <p>The name of the membership's collaboration.</p>
    #[doc(hidden)]
    pub collaboration_name: std::option::Option<std::string::String>,
    /// <p>The time when the membership was created.</p>
    #[doc(hidden)]
    pub create_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time the membership metadata was last updated.</p>
    #[doc(hidden)]
    pub update_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The status of the membership. Valid values are `ACTIVE`, `REMOVED`, and `COLLABORATION_DELETED`.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::MembershipStatus>,
    /// <p>The abilities granted to the collaboration member.</p>
    #[doc(hidden)]
    pub member_abilities: std::option::Option<std::vec::Vec<crate::model::MemberAbility>>,
    /// <p>An indicator as to whether query logging has been enabled or disabled for the collaboration.</p>
    #[doc(hidden)]
    pub query_log_status: std::option::Option<crate::model::MembershipQueryLogStatus>,
}
impl Membership {
    /// <p>The unique ID of the membership.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The unique ARN for the membership.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The unique ARN for the membership's associated collaboration.</p>
    pub fn collaboration_arn(&self) -> std::option::Option<&str> {
        self.collaboration_arn.as_deref()
    }
    /// <p>The unique ID for the membership's collaboration.</p>
    pub fn collaboration_id(&self) -> std::option::Option<&str> {
        self.collaboration_id.as_deref()
    }
    /// <p>The identifier used to reference members of the collaboration. Currently only supports AWS account ID.</p>
    pub fn collaboration_creator_account_id(&self) -> std::option::Option<&str> {
        self.collaboration_creator_account_id.as_deref()
    }
    /// <p>The display name of the collaboration creator.</p>
    pub fn collaboration_creator_display_name(&self) -> std::option::Option<&str> {
        self.collaboration_creator_display_name.as_deref()
    }
    /// <p>The name of the membership's collaboration.</p>
    pub fn collaboration_name(&self) -> std::option::Option<&str> {
        self.collaboration_name.as_deref()
    }
    /// <p>The time when the membership was created.</p>
    pub fn create_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.create_time.as_ref()
    }
    /// <p>The time the membership metadata was last updated.</p>
    pub fn update_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.update_time.as_ref()
    }
    /// <p>The status of the membership. Valid values are `ACTIVE`, `REMOVED`, and `COLLABORATION_DELETED`.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::MembershipStatus> {
        self.status.as_ref()
    }
    /// <p>The abilities granted to the collaboration member.</p>
    pub fn member_abilities(&self) -> std::option::Option<&[crate::model::MemberAbility]> {
        self.member_abilities.as_deref()
    }
    /// <p>An indicator as to whether query logging has been enabled or disabled for the collaboration.</p>
    pub fn query_log_status(&self) -> std::option::Option<&crate::model::MembershipQueryLogStatus> {
        self.query_log_status.as_ref()
    }
}
/// See [`Membership`](crate::model::Membership).
pub mod membership {

    /// A builder for [`Membership`](crate::model::Membership).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) collaboration_arn: std::option::Option<std::string::String>,
        pub(crate) collaboration_id: std::option::Option<std::string::String>,
        pub(crate) collaboration_creator_account_id: std::option::Option<std::string::String>,
        pub(crate) collaboration_creator_display_name: std::option::Option<std::string::String>,
        pub(crate) collaboration_name: std::option::Option<std::string::String>,
        pub(crate) create_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) status: std::option::Option<crate::model::MembershipStatus>,
        pub(crate) member_abilities:
            std::option::Option<std::vec::Vec<crate::model::MemberAbility>>,
        pub(crate) query_log_status: std::option::Option<crate::model::MembershipQueryLogStatus>,
    }
    impl Builder {
        /// <p>The unique ID of the membership.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique ID of the membership.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The unique ARN for the membership.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The unique ARN for the membership.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The unique ARN for the membership's associated collaboration.</p>
        pub fn collaboration_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.collaboration_arn = Some(input.into());
            self
        }
        /// <p>The unique ARN for the membership's associated collaboration.</p>
        pub fn set_collaboration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.collaboration_arn = input;
            self
        }
        /// <p>The unique ID for the membership's collaboration.</p>
        pub fn collaboration_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.collaboration_id = Some(input.into());
            self
        }
        /// <p>The unique ID for the membership's collaboration.</p>
        pub fn set_collaboration_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.collaboration_id = input;
            self
        }
        /// <p>The identifier used to reference members of the collaboration. Currently only supports AWS account ID.</p>
        pub fn collaboration_creator_account_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.collaboration_creator_account_id = Some(input.into());
            self
        }
        /// <p>The identifier used to reference members of the collaboration. Currently only supports AWS account ID.</p>
        pub fn set_collaboration_creator_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.collaboration_creator_account_id = input;
            self
        }
        /// <p>The display name of the collaboration creator.</p>
        pub fn collaboration_creator_display_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.collaboration_creator_display_name = Some(input.into());
            self
        }
        /// <p>The display name of the collaboration creator.</p>
        pub fn set_collaboration_creator_display_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.collaboration_creator_display_name = input;
            self
        }
        /// <p>The name of the membership's collaboration.</p>
        pub fn collaboration_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.collaboration_name = Some(input.into());
            self
        }
        /// <p>The name of the membership's collaboration.</p>
        pub fn set_collaboration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.collaboration_name = input;
            self
        }
        /// <p>The time when the membership was created.</p>
        pub fn create_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.create_time = Some(input);
            self
        }
        /// <p>The time when the membership was created.</p>
        pub fn set_create_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The time the membership metadata was last updated.</p>
        pub fn update_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_time = Some(input);
            self
        }
        /// <p>The time the membership metadata was last updated.</p>
        pub fn set_update_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.update_time = input;
            self
        }
        /// <p>The status of the membership. Valid values are `ACTIVE`, `REMOVED`, and `COLLABORATION_DELETED`.</p>
        pub fn status(mut self, input: crate::model::MembershipStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the membership. Valid values are `ACTIVE`, `REMOVED`, and `COLLABORATION_DELETED`.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::MembershipStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Appends an item to `member_abilities`.
        ///
        /// To override the contents of this collection use [`set_member_abilities`](Self::set_member_abilities).
        ///
        /// <p>The abilities granted to the collaboration member.</p>
        pub fn member_abilities(mut self, input: crate::model::MemberAbility) -> Self {
            let mut v = self.member_abilities.unwrap_or_default();
            v.push(input);
            self.member_abilities = Some(v);
            self
        }
        /// <p>The abilities granted to the collaboration member.</p>
        pub fn set_member_abilities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MemberAbility>>,
        ) -> Self {
            self.member_abilities = input;
            self
        }
        /// <p>An indicator as to whether query logging has been enabled or disabled for the collaboration.</p>
        pub fn query_log_status(mut self, input: crate::model::MembershipQueryLogStatus) -> Self {
            self.query_log_status = Some(input);
            self
        }
        /// <p>An indicator as to whether query logging has been enabled or disabled for the collaboration.</p>
        pub fn set_query_log_status(
            mut self,
            input: std::option::Option<crate::model::MembershipQueryLogStatus>,
        ) -> Self {
            self.query_log_status = input;
            self
        }
        /// Consumes the builder and constructs a [`Membership`](crate::model::Membership).
        pub fn build(self) -> crate::model::Membership {
            crate::model::Membership {
                id: self.id,
                arn: self.arn,
                collaboration_arn: self.collaboration_arn,
                collaboration_id: self.collaboration_id,
                collaboration_creator_account_id: self.collaboration_creator_account_id,
                collaboration_creator_display_name: self.collaboration_creator_display_name,
                collaboration_name: self.collaboration_name,
                create_time: self.create_time,
                update_time: self.update_time,
                status: self.status,
                member_abilities: self.member_abilities,
                query_log_status: self.query_log_status,
            }
        }
    }
}
impl Membership {
    /// Creates a new builder-style object to manufacture [`Membership`](crate::model::Membership).
    pub fn builder() -> crate::model::membership::Builder {
        crate::model::membership::Builder::default()
    }
}

/// When writing a match expression against `MembershipQueryLogStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let membershipquerylogstatus = unimplemented!();
/// match membershipquerylogstatus {
///     MembershipQueryLogStatus::Disabled => { /* ... */ },
///     MembershipQueryLogStatus::Enabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `membershipquerylogstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `MembershipQueryLogStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `MembershipQueryLogStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `MembershipQueryLogStatus::NewFeature` is defined.
/// Specifically, when `membershipquerylogstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `MembershipQueryLogStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MembershipQueryLogStatus {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for MembershipQueryLogStatus {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => MembershipQueryLogStatus::Disabled,
            "ENABLED" => MembershipQueryLogStatus::Enabled,
            other => MembershipQueryLogStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for MembershipQueryLogStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MembershipQueryLogStatus::from(s))
    }
}
impl MembershipQueryLogStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MembershipQueryLogStatus::Disabled => "DISABLED",
            MembershipQueryLogStatus::Enabled => "ENABLED",
            MembershipQueryLogStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for MembershipQueryLogStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A configured table analysis rule, which limits how data for this table can be used.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfiguredTableAnalysisRule {
    /// <p>The unique ID for the configured table.</p>
    #[doc(hidden)]
    pub configured_table_id: std::option::Option<std::string::String>,
    /// <p>The unique ARN for the configured table.</p>
    #[doc(hidden)]
    pub configured_table_arn: std::option::Option<std::string::String>,
    /// <p>The policy that controls SQL query rules.</p>
    #[doc(hidden)]
    pub policy: std::option::Option<crate::model::ConfiguredTableAnalysisRulePolicy>,
    /// <p>The type of configured table analysis rule. Valid values are `AGGREGATION` and `LIST`.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::ConfiguredTableAnalysisRuleType>,
    /// <p>The time the configured table analysis rule was created.</p>
    #[doc(hidden)]
    pub create_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time the configured table analysis rule was last updated.</p>
    #[doc(hidden)]
    pub update_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl ConfiguredTableAnalysisRule {
    /// <p>The unique ID for the configured table.</p>
    pub fn configured_table_id(&self) -> std::option::Option<&str> {
        self.configured_table_id.as_deref()
    }
    /// <p>The unique ARN for the configured table.</p>
    pub fn configured_table_arn(&self) -> std::option::Option<&str> {
        self.configured_table_arn.as_deref()
    }
    /// <p>The policy that controls SQL query rules.</p>
    pub fn policy(&self) -> std::option::Option<&crate::model::ConfiguredTableAnalysisRulePolicy> {
        self.policy.as_ref()
    }
    /// <p>The type of configured table analysis rule. Valid values are `AGGREGATION` and `LIST`.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::ConfiguredTableAnalysisRuleType> {
        self.r#type.as_ref()
    }
    /// <p>The time the configured table analysis rule was created.</p>
    pub fn create_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.create_time.as_ref()
    }
    /// <p>The time the configured table analysis rule was last updated.</p>
    pub fn update_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.update_time.as_ref()
    }
}
/// See [`ConfiguredTableAnalysisRule`](crate::model::ConfiguredTableAnalysisRule).
pub mod configured_table_analysis_rule {

    /// A builder for [`ConfiguredTableAnalysisRule`](crate::model::ConfiguredTableAnalysisRule).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) configured_table_id: std::option::Option<std::string::String>,
        pub(crate) configured_table_arn: std::option::Option<std::string::String>,
        pub(crate) policy: std::option::Option<crate::model::ConfiguredTableAnalysisRulePolicy>,
        pub(crate) r#type: std::option::Option<crate::model::ConfiguredTableAnalysisRuleType>,
        pub(crate) create_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The unique ID for the configured table.</p>
        pub fn configured_table_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.configured_table_id = Some(input.into());
            self
        }
        /// <p>The unique ID for the configured table.</p>
        pub fn set_configured_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.configured_table_id = input;
            self
        }
        /// <p>The unique ARN for the configured table.</p>
        pub fn configured_table_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.configured_table_arn = Some(input.into());
            self
        }
        /// <p>The unique ARN for the configured table.</p>
        pub fn set_configured_table_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.configured_table_arn = input;
            self
        }
        /// <p>The policy that controls SQL query rules.</p>
        pub fn policy(mut self, input: crate::model::ConfiguredTableAnalysisRulePolicy) -> Self {
            self.policy = Some(input);
            self
        }
        /// <p>The policy that controls SQL query rules.</p>
        pub fn set_policy(
            mut self,
            input: std::option::Option<crate::model::ConfiguredTableAnalysisRulePolicy>,
        ) -> Self {
            self.policy = input;
            self
        }
        /// <p>The type of configured table analysis rule. Valid values are `AGGREGATION` and `LIST`.</p>
        pub fn r#type(mut self, input: crate::model::ConfiguredTableAnalysisRuleType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of configured table analysis rule. Valid values are `AGGREGATION` and `LIST`.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::ConfiguredTableAnalysisRuleType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The time the configured table analysis rule was created.</p>
        pub fn create_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.create_time = Some(input);
            self
        }
        /// <p>The time the configured table analysis rule was created.</p>
        pub fn set_create_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The time the configured table analysis rule was last updated.</p>
        pub fn update_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_time = Some(input);
            self
        }
        /// <p>The time the configured table analysis rule was last updated.</p>
        pub fn set_update_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.update_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfiguredTableAnalysisRule`](crate::model::ConfiguredTableAnalysisRule).
        pub fn build(self) -> crate::model::ConfiguredTableAnalysisRule {
            crate::model::ConfiguredTableAnalysisRule {
                configured_table_id: self.configured_table_id,
                configured_table_arn: self.configured_table_arn,
                policy: self.policy,
                r#type: self.r#type,
                create_time: self.create_time,
                update_time: self.update_time,
            }
        }
    }
}
impl ConfiguredTableAnalysisRule {
    /// Creates a new builder-style object to manufacture [`ConfiguredTableAnalysisRule`](crate::model::ConfiguredTableAnalysisRule).
    pub fn builder() -> crate::model::configured_table_analysis_rule::Builder {
        crate::model::configured_table_analysis_rule::Builder::default()
    }
}

/// When writing a match expression against `ConfiguredTableAnalysisRuleType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let configuredtableanalysisruletype = unimplemented!();
/// match configuredtableanalysisruletype {
///     ConfiguredTableAnalysisRuleType::Aggregation => { /* ... */ },
///     ConfiguredTableAnalysisRuleType::List => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `configuredtableanalysisruletype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConfiguredTableAnalysisRuleType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConfiguredTableAnalysisRuleType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConfiguredTableAnalysisRuleType::NewFeature` is defined.
/// Specifically, when `configuredtableanalysisruletype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConfiguredTableAnalysisRuleType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConfiguredTableAnalysisRuleType {
    #[allow(missing_docs)] // documentation missing in model
    Aggregation,
    #[allow(missing_docs)] // documentation missing in model
    List,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ConfiguredTableAnalysisRuleType {
    fn from(s: &str) -> Self {
        match s {
            "AGGREGATION" => ConfiguredTableAnalysisRuleType::Aggregation,
            "LIST" => ConfiguredTableAnalysisRuleType::List,
            other => ConfiguredTableAnalysisRuleType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ConfiguredTableAnalysisRuleType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConfiguredTableAnalysisRuleType::from(s))
    }
}
impl ConfiguredTableAnalysisRuleType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConfiguredTableAnalysisRuleType::Aggregation => "AGGREGATION",
            ConfiguredTableAnalysisRuleType::List => "LIST",
            ConfiguredTableAnalysisRuleType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AGGREGATION", "LIST"]
    }
}
impl AsRef<str> for ConfiguredTableAnalysisRuleType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Controls on the query specifications that can be run on a configured table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum ConfiguredTableAnalysisRulePolicy {
    /// <p>Controls on the query specifications that can be run on a configured table.</p>
    V1(crate::model::ConfiguredTableAnalysisRulePolicyV1),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl ConfiguredTableAnalysisRulePolicy {
    #[allow(irrefutable_let_patterns)]
    /// Tries to convert the enum instance into [`V1`](crate::model::ConfiguredTableAnalysisRulePolicy::V1), extracting the inner [`ConfiguredTableAnalysisRulePolicyV1`](crate::model::ConfiguredTableAnalysisRulePolicyV1).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_v1(
        &self,
    ) -> std::result::Result<&crate::model::ConfiguredTableAnalysisRulePolicyV1, &Self> {
        if let ConfiguredTableAnalysisRulePolicy::V1(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`V1`](crate::model::ConfiguredTableAnalysisRulePolicy::V1).
    pub fn is_v1(&self) -> bool {
        self.as_v1().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Controls on the query specifications that can be run on a configured table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum ConfiguredTableAnalysisRulePolicyV1 {
    /// <p>Analysis rule type that enables only aggregation queries on a configured table.</p>
    Aggregation(crate::model::AnalysisRuleAggregation),
    /// <p>Analysis rule type that enables only list queries on a configured table.</p>
    List(crate::model::AnalysisRuleList),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl ConfiguredTableAnalysisRulePolicyV1 {
    /// Tries to convert the enum instance into [`Aggregation`](crate::model::ConfiguredTableAnalysisRulePolicyV1::Aggregation), extracting the inner [`AnalysisRuleAggregation`](crate::model::AnalysisRuleAggregation).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_aggregation(
        &self,
    ) -> std::result::Result<&crate::model::AnalysisRuleAggregation, &Self> {
        if let ConfiguredTableAnalysisRulePolicyV1::Aggregation(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Aggregation`](crate::model::ConfiguredTableAnalysisRulePolicyV1::Aggregation).
    pub fn is_aggregation(&self) -> bool {
        self.as_aggregation().is_ok()
    }
    /// Tries to convert the enum instance into [`List`](crate::model::ConfiguredTableAnalysisRulePolicyV1::List), extracting the inner [`AnalysisRuleList`](crate::model::AnalysisRuleList).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_list(&self) -> std::result::Result<&crate::model::AnalysisRuleList, &Self> {
        if let ConfiguredTableAnalysisRulePolicyV1::List(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`List`](crate::model::ConfiguredTableAnalysisRulePolicyV1::List).
    pub fn is_list(&self) -> bool {
        self.as_list().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Enables query structure and specified queries that product aggregate statistics.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AnalysisRuleAggregation {
    /// <p>The columns that query runners are allowed to use in aggregation queries.</p>
    #[doc(hidden)]
    pub aggregate_columns: std::option::Option<std::vec::Vec<crate::model::AggregateColumn>>,
    /// <p>Columns in configured table that can be used in join statements and/or as aggregate columns. They can never be outputted directly.</p>
    #[doc(hidden)]
    pub join_columns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Control that requires member who runs query to do a join with their configured table and/or other configured table in query</p>
    #[doc(hidden)]
    pub join_required: std::option::Option<crate::model::JoinRequiredOption>,
    /// <p>The columns that query runners are allowed to select, group by, or filter by.</p>
    #[doc(hidden)]
    pub dimension_columns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Set of scalar functions that are allowed to be used on dimension columns and the output of aggregation of metrics.</p>
    #[doc(hidden)]
    pub scalar_functions: std::option::Option<std::vec::Vec<crate::model::ScalarFunctions>>,
    /// <p>Columns that must meet a specific threshold value (after an aggregation function is applied to it) for each output row to be returned.</p>
    #[doc(hidden)]
    pub output_constraints: std::option::Option<std::vec::Vec<crate::model::AggregationConstraint>>,
}
impl AnalysisRuleAggregation {
    /// <p>The columns that query runners are allowed to use in aggregation queries.</p>
    pub fn aggregate_columns(&self) -> std::option::Option<&[crate::model::AggregateColumn]> {
        self.aggregate_columns.as_deref()
    }
    /// <p>Columns in configured table that can be used in join statements and/or as aggregate columns. They can never be outputted directly.</p>
    pub fn join_columns(&self) -> std::option::Option<&[std::string::String]> {
        self.join_columns.as_deref()
    }
    /// <p>Control that requires member who runs query to do a join with their configured table and/or other configured table in query</p>
    pub fn join_required(&self) -> std::option::Option<&crate::model::JoinRequiredOption> {
        self.join_required.as_ref()
    }
    /// <p>The columns that query runners are allowed to select, group by, or filter by.</p>
    pub fn dimension_columns(&self) -> std::option::Option<&[std::string::String]> {
        self.dimension_columns.as_deref()
    }
    /// <p>Set of scalar functions that are allowed to be used on dimension columns and the output of aggregation of metrics.</p>
    pub fn scalar_functions(&self) -> std::option::Option<&[crate::model::ScalarFunctions]> {
        self.scalar_functions.as_deref()
    }
    /// <p>Columns that must meet a specific threshold value (after an aggregation function is applied to it) for each output row to be returned.</p>
    pub fn output_constraints(
        &self,
    ) -> std::option::Option<&[crate::model::AggregationConstraint]> {
        self.output_constraints.as_deref()
    }
}
/// See [`AnalysisRuleAggregation`](crate::model::AnalysisRuleAggregation).
pub mod analysis_rule_aggregation {

    /// A builder for [`AnalysisRuleAggregation`](crate::model::AnalysisRuleAggregation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) aggregate_columns:
            std::option::Option<std::vec::Vec<crate::model::AggregateColumn>>,
        pub(crate) join_columns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) join_required: std::option::Option<crate::model::JoinRequiredOption>,
        pub(crate) dimension_columns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) scalar_functions:
            std::option::Option<std::vec::Vec<crate::model::ScalarFunctions>>,
        pub(crate) output_constraints:
            std::option::Option<std::vec::Vec<crate::model::AggregationConstraint>>,
    }
    impl Builder {
        /// Appends an item to `aggregate_columns`.
        ///
        /// To override the contents of this collection use [`set_aggregate_columns`](Self::set_aggregate_columns).
        ///
        /// <p>The columns that query runners are allowed to use in aggregation queries.</p>
        pub fn aggregate_columns(mut self, input: crate::model::AggregateColumn) -> Self {
            let mut v = self.aggregate_columns.unwrap_or_default();
            v.push(input);
            self.aggregate_columns = Some(v);
            self
        }
        /// <p>The columns that query runners are allowed to use in aggregation queries.</p>
        pub fn set_aggregate_columns(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AggregateColumn>>,
        ) -> Self {
            self.aggregate_columns = input;
            self
        }
        /// Appends an item to `join_columns`.
        ///
        /// To override the contents of this collection use [`set_join_columns`](Self::set_join_columns).
        ///
        /// <p>Columns in configured table that can be used in join statements and/or as aggregate columns. They can never be outputted directly.</p>
        pub fn join_columns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.join_columns.unwrap_or_default();
            v.push(input.into());
            self.join_columns = Some(v);
            self
        }
        /// <p>Columns in configured table that can be used in join statements and/or as aggregate columns. They can never be outputted directly.</p>
        pub fn set_join_columns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.join_columns = input;
            self
        }
        /// <p>Control that requires member who runs query to do a join with their configured table and/or other configured table in query</p>
        pub fn join_required(mut self, input: crate::model::JoinRequiredOption) -> Self {
            self.join_required = Some(input);
            self
        }
        /// <p>Control that requires member who runs query to do a join with their configured table and/or other configured table in query</p>
        pub fn set_join_required(
            mut self,
            input: std::option::Option<crate::model::JoinRequiredOption>,
        ) -> Self {
            self.join_required = input;
            self
        }
        /// Appends an item to `dimension_columns`.
        ///
        /// To override the contents of this collection use [`set_dimension_columns`](Self::set_dimension_columns).
        ///
        /// <p>The columns that query runners are allowed to select, group by, or filter by.</p>
        pub fn dimension_columns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.dimension_columns.unwrap_or_default();
            v.push(input.into());
            self.dimension_columns = Some(v);
            self
        }
        /// <p>The columns that query runners are allowed to select, group by, or filter by.</p>
        pub fn set_dimension_columns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.dimension_columns = input;
            self
        }
        /// Appends an item to `scalar_functions`.
        ///
        /// To override the contents of this collection use [`set_scalar_functions`](Self::set_scalar_functions).
        ///
        /// <p>Set of scalar functions that are allowed to be used on dimension columns and the output of aggregation of metrics.</p>
        pub fn scalar_functions(mut self, input: crate::model::ScalarFunctions) -> Self {
            let mut v = self.scalar_functions.unwrap_or_default();
            v.push(input);
            self.scalar_functions = Some(v);
            self
        }
        /// <p>Set of scalar functions that are allowed to be used on dimension columns and the output of aggregation of metrics.</p>
        pub fn set_scalar_functions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ScalarFunctions>>,
        ) -> Self {
            self.scalar_functions = input;
            self
        }
        /// Appends an item to `output_constraints`.
        ///
        /// To override the contents of this collection use [`set_output_constraints`](Self::set_output_constraints).
        ///
        /// <p>Columns that must meet a specific threshold value (after an aggregation function is applied to it) for each output row to be returned.</p>
        pub fn output_constraints(mut self, input: crate::model::AggregationConstraint) -> Self {
            let mut v = self.output_constraints.unwrap_or_default();
            v.push(input);
            self.output_constraints = Some(v);
            self
        }
        /// <p>Columns that must meet a specific threshold value (after an aggregation function is applied to it) for each output row to be returned.</p>
        pub fn set_output_constraints(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AggregationConstraint>>,
        ) -> Self {
            self.output_constraints = input;
            self
        }
        /// Consumes the builder and constructs a [`AnalysisRuleAggregation`](crate::model::AnalysisRuleAggregation).
        pub fn build(self) -> crate::model::AnalysisRuleAggregation {
            crate::model::AnalysisRuleAggregation {
                aggregate_columns: self.aggregate_columns,
                join_columns: self.join_columns,
                join_required: self.join_required,
                dimension_columns: self.dimension_columns,
                scalar_functions: self.scalar_functions,
                output_constraints: self.output_constraints,
            }
        }
    }
}
impl AnalysisRuleAggregation {
    /// Creates a new builder-style object to manufacture [`AnalysisRuleAggregation`](crate::model::AnalysisRuleAggregation).
    pub fn builder() -> crate::model::analysis_rule_aggregation::Builder {
        crate::model::analysis_rule_aggregation::Builder::default()
    }
}

/// <p>Constraint on query output removing output rows that do not meet a minimum number of distinct values of a specified column.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AggregationConstraint {
    /// <p>Column in aggregation constraint for which there must be a minimum number of distinct values in an output row for it to be in the query output.</p>
    #[doc(hidden)]
    pub column_name: std::option::Option<std::string::String>,
    /// <p>The minimum number of distinct values that an output row must be an aggregation of. Minimum threshold of distinct values for a specified column that must exist in an output row for it to be in the query output.</p>
    #[doc(hidden)]
    pub minimum: std::option::Option<i32>,
    /// <p>The type of aggregation the constraint allows. The only valid value is currently `COUNT_DISTINCT`.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::AggregationType>,
}
impl AggregationConstraint {
    /// <p>Column in aggregation constraint for which there must be a minimum number of distinct values in an output row for it to be in the query output.</p>
    pub fn column_name(&self) -> std::option::Option<&str> {
        self.column_name.as_deref()
    }
    /// <p>The minimum number of distinct values that an output row must be an aggregation of. Minimum threshold of distinct values for a specified column that must exist in an output row for it to be in the query output.</p>
    pub fn minimum(&self) -> std::option::Option<i32> {
        self.minimum
    }
    /// <p>The type of aggregation the constraint allows. The only valid value is currently `COUNT_DISTINCT`.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::AggregationType> {
        self.r#type.as_ref()
    }
}
/// See [`AggregationConstraint`](crate::model::AggregationConstraint).
pub mod aggregation_constraint {

    /// A builder for [`AggregationConstraint`](crate::model::AggregationConstraint).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) column_name: std::option::Option<std::string::String>,
        pub(crate) minimum: std::option::Option<i32>,
        pub(crate) r#type: std::option::Option<crate::model::AggregationType>,
    }
    impl Builder {
        /// <p>Column in aggregation constraint for which there must be a minimum number of distinct values in an output row for it to be in the query output.</p>
        pub fn column_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.column_name = Some(input.into());
            self
        }
        /// <p>Column in aggregation constraint for which there must be a minimum number of distinct values in an output row for it to be in the query output.</p>
        pub fn set_column_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.column_name = input;
            self
        }
        /// <p>The minimum number of distinct values that an output row must be an aggregation of. Minimum threshold of distinct values for a specified column that must exist in an output row for it to be in the query output.</p>
        pub fn minimum(mut self, input: i32) -> Self {
            self.minimum = Some(input);
            self
        }
        /// <p>The minimum number of distinct values that an output row must be an aggregation of. Minimum threshold of distinct values for a specified column that must exist in an output row for it to be in the query output.</p>
        pub fn set_minimum(mut self, input: std::option::Option<i32>) -> Self {
            self.minimum = input;
            self
        }
        /// <p>The type of aggregation the constraint allows. The only valid value is currently `COUNT_DISTINCT`.</p>
        pub fn r#type(mut self, input: crate::model::AggregationType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of aggregation the constraint allows. The only valid value is currently `COUNT_DISTINCT`.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::AggregationType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`AggregationConstraint`](crate::model::AggregationConstraint).
        pub fn build(self) -> crate::model::AggregationConstraint {
            crate::model::AggregationConstraint {
                column_name: self.column_name,
                minimum: self.minimum,
                r#type: self.r#type,
            }
        }
    }
}
impl AggregationConstraint {
    /// Creates a new builder-style object to manufacture [`AggregationConstraint`](crate::model::AggregationConstraint).
    pub fn builder() -> crate::model::aggregation_constraint::Builder {
        crate::model::aggregation_constraint::Builder::default()
    }
}

/// When writing a match expression against `AggregationType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let aggregationtype = unimplemented!();
/// match aggregationtype {
///     AggregationType::CountDistinct => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `aggregationtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AggregationType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AggregationType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AggregationType::NewFeature` is defined.
/// Specifically, when `aggregationtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AggregationType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AggregationType {
    #[allow(missing_docs)] // documentation missing in model
    CountDistinct,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AggregationType {
    fn from(s: &str) -> Self {
        match s {
            "COUNT_DISTINCT" => AggregationType::CountDistinct,
            other => AggregationType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AggregationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AggregationType::from(s))
    }
}
impl AggregationType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AggregationType::CountDistinct => "COUNT_DISTINCT",
            AggregationType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["COUNT_DISTINCT"]
    }
}
impl AsRef<str> for AggregationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ScalarFunctions`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let scalarfunctions = unimplemented!();
/// match scalarfunctions {
///     ScalarFunctions::Abs => { /* ... */ },
///     ScalarFunctions::Cast => { /* ... */ },
///     ScalarFunctions::Ceiling => { /* ... */ },
///     ScalarFunctions::Coalesce => { /* ... */ },
///     ScalarFunctions::Floor => { /* ... */ },
///     ScalarFunctions::Ln => { /* ... */ },
///     ScalarFunctions::Log => { /* ... */ },
///     ScalarFunctions::Lower => { /* ... */ },
///     ScalarFunctions::Round => { /* ... */ },
///     ScalarFunctions::Rtrim => { /* ... */ },
///     ScalarFunctions::Sqrt => { /* ... */ },
///     ScalarFunctions::Trunc => { /* ... */ },
///     ScalarFunctions::Upper => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `scalarfunctions` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ScalarFunctions::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ScalarFunctions::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ScalarFunctions::NewFeature` is defined.
/// Specifically, when `scalarfunctions` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ScalarFunctions::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ScalarFunctions {
    #[allow(missing_docs)] // documentation missing in model
    Abs,
    #[allow(missing_docs)] // documentation missing in model
    Cast,
    #[allow(missing_docs)] // documentation missing in model
    Ceiling,
    #[allow(missing_docs)] // documentation missing in model
    Coalesce,
    #[allow(missing_docs)] // documentation missing in model
    Floor,
    #[allow(missing_docs)] // documentation missing in model
    Ln,
    #[allow(missing_docs)] // documentation missing in model
    Log,
    #[allow(missing_docs)] // documentation missing in model
    Lower,
    #[allow(missing_docs)] // documentation missing in model
    Round,
    #[allow(missing_docs)] // documentation missing in model
    Rtrim,
    #[allow(missing_docs)] // documentation missing in model
    Sqrt,
    #[allow(missing_docs)] // documentation missing in model
    Trunc,
    #[allow(missing_docs)] // documentation missing in model
    Upper,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ScalarFunctions {
    fn from(s: &str) -> Self {
        match s {
            "ABS" => ScalarFunctions::Abs,
            "CAST" => ScalarFunctions::Cast,
            "CEILING" => ScalarFunctions::Ceiling,
            "COALESCE" => ScalarFunctions::Coalesce,
            "FLOOR" => ScalarFunctions::Floor,
            "LN" => ScalarFunctions::Ln,
            "LOG" => ScalarFunctions::Log,
            "LOWER" => ScalarFunctions::Lower,
            "ROUND" => ScalarFunctions::Round,
            "RTRIM" => ScalarFunctions::Rtrim,
            "SQRT" => ScalarFunctions::Sqrt,
            "TRUNC" => ScalarFunctions::Trunc,
            "UPPER" => ScalarFunctions::Upper,
            other => ScalarFunctions::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ScalarFunctions {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ScalarFunctions::from(s))
    }
}
impl ScalarFunctions {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ScalarFunctions::Abs => "ABS",
            ScalarFunctions::Cast => "CAST",
            ScalarFunctions::Ceiling => "CEILING",
            ScalarFunctions::Coalesce => "COALESCE",
            ScalarFunctions::Floor => "FLOOR",
            ScalarFunctions::Ln => "LN",
            ScalarFunctions::Log => "LOG",
            ScalarFunctions::Lower => "LOWER",
            ScalarFunctions::Round => "ROUND",
            ScalarFunctions::Rtrim => "RTRIM",
            ScalarFunctions::Sqrt => "SQRT",
            ScalarFunctions::Trunc => "TRUNC",
            ScalarFunctions::Upper => "UPPER",
            ScalarFunctions::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ABS", "CAST", "CEILING", "COALESCE", "FLOOR", "LN", "LOG", "LOWER", "ROUND", "RTRIM",
            "SQRT", "TRUNC", "UPPER",
        ]
    }
}
impl AsRef<str> for ScalarFunctions {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `JoinRequiredOption`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let joinrequiredoption = unimplemented!();
/// match joinrequiredoption {
///     JoinRequiredOption::QueryRunner => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `joinrequiredoption` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `JoinRequiredOption::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `JoinRequiredOption::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `JoinRequiredOption::NewFeature` is defined.
/// Specifically, when `joinrequiredoption` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `JoinRequiredOption::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum JoinRequiredOption {
    #[allow(missing_docs)] // documentation missing in model
    QueryRunner,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for JoinRequiredOption {
    fn from(s: &str) -> Self {
        match s {
            "QUERY_RUNNER" => JoinRequiredOption::QueryRunner,
            other => {
                JoinRequiredOption::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for JoinRequiredOption {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(JoinRequiredOption::from(s))
    }
}
impl JoinRequiredOption {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            JoinRequiredOption::QueryRunner => "QUERY_RUNNER",
            JoinRequiredOption::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["QUERY_RUNNER"]
    }
}
impl AsRef<str> for JoinRequiredOption {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Column in configured table that can be used in aggregate function in query.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AggregateColumn {
    /// <p>Column names in configured table of aggregate columns.</p>
    #[doc(hidden)]
    pub column_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Aggregation function that can be applied to aggregate column in query.</p>
    #[doc(hidden)]
    pub function: std::option::Option<crate::model::AggregateFunctionName>,
}
impl AggregateColumn {
    /// <p>Column names in configured table of aggregate columns.</p>
    pub fn column_names(&self) -> std::option::Option<&[std::string::String]> {
        self.column_names.as_deref()
    }
    /// <p>Aggregation function that can be applied to aggregate column in query.</p>
    pub fn function(&self) -> std::option::Option<&crate::model::AggregateFunctionName> {
        self.function.as_ref()
    }
}
/// See [`AggregateColumn`](crate::model::AggregateColumn).
pub mod aggregate_column {

    /// A builder for [`AggregateColumn`](crate::model::AggregateColumn).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) column_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) function: std::option::Option<crate::model::AggregateFunctionName>,
    }
    impl Builder {
        /// Appends an item to `column_names`.
        ///
        /// To override the contents of this collection use [`set_column_names`](Self::set_column_names).
        ///
        /// <p>Column names in configured table of aggregate columns.</p>
        pub fn column_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.column_names.unwrap_or_default();
            v.push(input.into());
            self.column_names = Some(v);
            self
        }
        /// <p>Column names in configured table of aggregate columns.</p>
        pub fn set_column_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.column_names = input;
            self
        }
        /// <p>Aggregation function that can be applied to aggregate column in query.</p>
        pub fn function(mut self, input: crate::model::AggregateFunctionName) -> Self {
            self.function = Some(input);
            self
        }
        /// <p>Aggregation function that can be applied to aggregate column in query.</p>
        pub fn set_function(
            mut self,
            input: std::option::Option<crate::model::AggregateFunctionName>,
        ) -> Self {
            self.function = input;
            self
        }
        /// Consumes the builder and constructs a [`AggregateColumn`](crate::model::AggregateColumn).
        pub fn build(self) -> crate::model::AggregateColumn {
            crate::model::AggregateColumn {
                column_names: self.column_names,
                function: self.function,
            }
        }
    }
}
impl AggregateColumn {
    /// Creates a new builder-style object to manufacture [`AggregateColumn`](crate::model::AggregateColumn).
    pub fn builder() -> crate::model::aggregate_column::Builder {
        crate::model::aggregate_column::Builder::default()
    }
}

/// When writing a match expression against `AggregateFunctionName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let aggregatefunctionname = unimplemented!();
/// match aggregatefunctionname {
///     AggregateFunctionName::Avg => { /* ... */ },
///     AggregateFunctionName::Count => { /* ... */ },
///     AggregateFunctionName::CountDistinct => { /* ... */ },
///     AggregateFunctionName::Sum => { /* ... */ },
///     AggregateFunctionName::SumDistinct => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `aggregatefunctionname` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AggregateFunctionName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AggregateFunctionName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AggregateFunctionName::NewFeature` is defined.
/// Specifically, when `aggregatefunctionname` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AggregateFunctionName::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AggregateFunctionName {
    #[allow(missing_docs)] // documentation missing in model
    Avg,
    #[allow(missing_docs)] // documentation missing in model
    Count,
    #[allow(missing_docs)] // documentation missing in model
    CountDistinct,
    #[allow(missing_docs)] // documentation missing in model
    Sum,
    #[allow(missing_docs)] // documentation missing in model
    SumDistinct,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AggregateFunctionName {
    fn from(s: &str) -> Self {
        match s {
            "AVG" => AggregateFunctionName::Avg,
            "COUNT" => AggregateFunctionName::Count,
            "COUNT_DISTINCT" => AggregateFunctionName::CountDistinct,
            "SUM" => AggregateFunctionName::Sum,
            "SUM_DISTINCT" => AggregateFunctionName::SumDistinct,
            other => {
                AggregateFunctionName::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for AggregateFunctionName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AggregateFunctionName::from(s))
    }
}
impl AggregateFunctionName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AggregateFunctionName::Avg => "AVG",
            AggregateFunctionName::Count => "COUNT",
            AggregateFunctionName::CountDistinct => "COUNT_DISTINCT",
            AggregateFunctionName::Sum => "SUM",
            AggregateFunctionName::SumDistinct => "SUM_DISTINCT",
            AggregateFunctionName::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AVG", "COUNT", "COUNT_DISTINCT", "SUM", "SUM_DISTINCT"]
    }
}
impl AsRef<str> for AggregateFunctionName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A type of analysis rule that enables row-level analysis.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AnalysisRuleList {
    /// <p>Columns that can be used to join a configured table with the table of the member who can query and another members' configured tables.</p>
    #[doc(hidden)]
    pub join_columns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Columns that can be listed in the output.</p>
    #[doc(hidden)]
    pub list_columns: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl AnalysisRuleList {
    /// <p>Columns that can be used to join a configured table with the table of the member who can query and another members' configured tables.</p>
    pub fn join_columns(&self) -> std::option::Option<&[std::string::String]> {
        self.join_columns.as_deref()
    }
    /// <p>Columns that can be listed in the output.</p>
    pub fn list_columns(&self) -> std::option::Option<&[std::string::String]> {
        self.list_columns.as_deref()
    }
}
/// See [`AnalysisRuleList`](crate::model::AnalysisRuleList).
pub mod analysis_rule_list {

    /// A builder for [`AnalysisRuleList`](crate::model::AnalysisRuleList).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) join_columns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) list_columns: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `join_columns`.
        ///
        /// To override the contents of this collection use [`set_join_columns`](Self::set_join_columns).
        ///
        /// <p>Columns that can be used to join a configured table with the table of the member who can query and another members' configured tables.</p>
        pub fn join_columns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.join_columns.unwrap_or_default();
            v.push(input.into());
            self.join_columns = Some(v);
            self
        }
        /// <p>Columns that can be used to join a configured table with the table of the member who can query and another members' configured tables.</p>
        pub fn set_join_columns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.join_columns = input;
            self
        }
        /// Appends an item to `list_columns`.
        ///
        /// To override the contents of this collection use [`set_list_columns`](Self::set_list_columns).
        ///
        /// <p>Columns that can be listed in the output.</p>
        pub fn list_columns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.list_columns.unwrap_or_default();
            v.push(input.into());
            self.list_columns = Some(v);
            self
        }
        /// <p>Columns that can be listed in the output.</p>
        pub fn set_list_columns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.list_columns = input;
            self
        }
        /// Consumes the builder and constructs a [`AnalysisRuleList`](crate::model::AnalysisRuleList).
        pub fn build(self) -> crate::model::AnalysisRuleList {
            crate::model::AnalysisRuleList {
                join_columns: self.join_columns,
                list_columns: self.list_columns,
            }
        }
    }
}
impl AnalysisRuleList {
    /// Creates a new builder-style object to manufacture [`AnalysisRuleList`](crate::model::AnalysisRuleList).
    pub fn builder() -> crate::model::analysis_rule_list::Builder {
        crate::model::analysis_rule_list::Builder::default()
    }
}

/// <p>The configured table summary for the objects listed by the request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfiguredTableSummary {
    /// <p>The unique ID of the configured table.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The unique ARN of the configured table.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the configured table.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The time the configured table was created.</p>
    #[doc(hidden)]
    pub create_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time the configured table was last updated.</p>
    #[doc(hidden)]
    pub update_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The types of analysis rules associated with this configured table.</p>
    #[doc(hidden)]
    pub analysis_rule_types:
        std::option::Option<std::vec::Vec<crate::model::ConfiguredTableAnalysisRuleType>>,
    /// <p>The analysis method for the configured tables. The only valid value is currently `DIRECT_QUERY`.</p>
    #[doc(hidden)]
    pub analysis_method: std::option::Option<crate::model::AnalysisMethod>,
}
impl ConfiguredTableSummary {
    /// <p>The unique ID of the configured table.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The unique ARN of the configured table.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the configured table.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The time the configured table was created.</p>
    pub fn create_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.create_time.as_ref()
    }
    /// <p>The time the configured table was last updated.</p>
    pub fn update_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.update_time.as_ref()
    }
    /// <p>The types of analysis rules associated with this configured table.</p>
    pub fn analysis_rule_types(
        &self,
    ) -> std::option::Option<&[crate::model::ConfiguredTableAnalysisRuleType]> {
        self.analysis_rule_types.as_deref()
    }
    /// <p>The analysis method for the configured tables. The only valid value is currently `DIRECT_QUERY`.</p>
    pub fn analysis_method(&self) -> std::option::Option<&crate::model::AnalysisMethod> {
        self.analysis_method.as_ref()
    }
}
/// See [`ConfiguredTableSummary`](crate::model::ConfiguredTableSummary).
pub mod configured_table_summary {

    /// A builder for [`ConfiguredTableSummary`](crate::model::ConfiguredTableSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) create_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) analysis_rule_types:
            std::option::Option<std::vec::Vec<crate::model::ConfiguredTableAnalysisRuleType>>,
        pub(crate) analysis_method: std::option::Option<crate::model::AnalysisMethod>,
    }
    impl Builder {
        /// <p>The unique ID of the configured table.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique ID of the configured table.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The unique ARN of the configured table.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The unique ARN of the configured table.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the configured table.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the configured table.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The time the configured table was created.</p>
        pub fn create_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.create_time = Some(input);
            self
        }
        /// <p>The time the configured table was created.</p>
        pub fn set_create_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The time the configured table was last updated.</p>
        pub fn update_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_time = Some(input);
            self
        }
        /// <p>The time the configured table was last updated.</p>
        pub fn set_update_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.update_time = input;
            self
        }
        /// Appends an item to `analysis_rule_types`.
        ///
        /// To override the contents of this collection use [`set_analysis_rule_types`](Self::set_analysis_rule_types).
        ///
        /// <p>The types of analysis rules associated with this configured table.</p>
        pub fn analysis_rule_types(
            mut self,
            input: crate::model::ConfiguredTableAnalysisRuleType,
        ) -> Self {
            let mut v = self.analysis_rule_types.unwrap_or_default();
            v.push(input);
            self.analysis_rule_types = Some(v);
            self
        }
        /// <p>The types of analysis rules associated with this configured table.</p>
        pub fn set_analysis_rule_types(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ConfiguredTableAnalysisRuleType>,
            >,
        ) -> Self {
            self.analysis_rule_types = input;
            self
        }
        /// <p>The analysis method for the configured tables. The only valid value is currently `DIRECT_QUERY`.</p>
        pub fn analysis_method(mut self, input: crate::model::AnalysisMethod) -> Self {
            self.analysis_method = Some(input);
            self
        }
        /// <p>The analysis method for the configured tables. The only valid value is currently `DIRECT_QUERY`.</p>
        pub fn set_analysis_method(
            mut self,
            input: std::option::Option<crate::model::AnalysisMethod>,
        ) -> Self {
            self.analysis_method = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfiguredTableSummary`](crate::model::ConfiguredTableSummary).
        pub fn build(self) -> crate::model::ConfiguredTableSummary {
            crate::model::ConfiguredTableSummary {
                id: self.id,
                arn: self.arn,
                name: self.name,
                create_time: self.create_time,
                update_time: self.update_time,
                analysis_rule_types: self.analysis_rule_types,
                analysis_method: self.analysis_method,
            }
        }
    }
}
impl ConfiguredTableSummary {
    /// Creates a new builder-style object to manufacture [`ConfiguredTableSummary`](crate::model::ConfiguredTableSummary).
    pub fn builder() -> crate::model::configured_table_summary::Builder {
        crate::model::configured_table_summary::Builder::default()
    }
}

/// When writing a match expression against `AnalysisMethod`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let analysismethod = unimplemented!();
/// match analysismethod {
///     AnalysisMethod::DirectQuery => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `analysismethod` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AnalysisMethod::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AnalysisMethod::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AnalysisMethod::NewFeature` is defined.
/// Specifically, when `analysismethod` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AnalysisMethod::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AnalysisMethod {
    #[allow(missing_docs)] // documentation missing in model
    DirectQuery,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AnalysisMethod {
    fn from(s: &str) -> Self {
        match s {
            "DIRECT_QUERY" => AnalysisMethod::DirectQuery,
            other => AnalysisMethod::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AnalysisMethod {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AnalysisMethod::from(s))
    }
}
impl AnalysisMethod {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AnalysisMethod::DirectQuery => "DIRECT_QUERY",
            AnalysisMethod::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DIRECT_QUERY"]
    }
}
impl AsRef<str> for AnalysisMethod {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A table that has been configured for use in a collaboration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfiguredTable {
    /// <p>The unique ID for the configured table.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The unique ARN for the configured table.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>A name for the configured table.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A description for the configured table.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The AWS Glue table that this configured table represents.</p>
    #[doc(hidden)]
    pub table_reference: std::option::Option<crate::model::TableReference>,
    /// <p>The time the configured table was created.</p>
    #[doc(hidden)]
    pub create_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time the configured table was last updated</p>
    #[doc(hidden)]
    pub update_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The types of analysis rules associated with this configured table. Valid values are `AGGREGATION` and `LIST`. Currently, only one analysis rule may be associated with a configured table.</p>
    #[doc(hidden)]
    pub analysis_rule_types:
        std::option::Option<std::vec::Vec<crate::model::ConfiguredTableAnalysisRuleType>>,
    /// <p>The analysis method for the configured table. The only valid value is currently `DIRECT_QUERY`.</p>
    #[doc(hidden)]
    pub analysis_method: std::option::Option<crate::model::AnalysisMethod>,
    /// <p>The columns within the underlying AWS Glue table that can be utilized within collaborations.</p>
    #[doc(hidden)]
    pub allowed_columns: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl ConfiguredTable {
    /// <p>The unique ID for the configured table.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The unique ARN for the configured table.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>A name for the configured table.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A description for the configured table.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The AWS Glue table that this configured table represents.</p>
    pub fn table_reference(&self) -> std::option::Option<&crate::model::TableReference> {
        self.table_reference.as_ref()
    }
    /// <p>The time the configured table was created.</p>
    pub fn create_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.create_time.as_ref()
    }
    /// <p>The time the configured table was last updated</p>
    pub fn update_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.update_time.as_ref()
    }
    /// <p>The types of analysis rules associated with this configured table. Valid values are `AGGREGATION` and `LIST`. Currently, only one analysis rule may be associated with a configured table.</p>
    pub fn analysis_rule_types(
        &self,
    ) -> std::option::Option<&[crate::model::ConfiguredTableAnalysisRuleType]> {
        self.analysis_rule_types.as_deref()
    }
    /// <p>The analysis method for the configured table. The only valid value is currently `DIRECT_QUERY`.</p>
    pub fn analysis_method(&self) -> std::option::Option<&crate::model::AnalysisMethod> {
        self.analysis_method.as_ref()
    }
    /// <p>The columns within the underlying AWS Glue table that can be utilized within collaborations.</p>
    pub fn allowed_columns(&self) -> std::option::Option<&[std::string::String]> {
        self.allowed_columns.as_deref()
    }
}
/// See [`ConfiguredTable`](crate::model::ConfiguredTable).
pub mod configured_table {

    /// A builder for [`ConfiguredTable`](crate::model::ConfiguredTable).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) table_reference: std::option::Option<crate::model::TableReference>,
        pub(crate) create_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) analysis_rule_types:
            std::option::Option<std::vec::Vec<crate::model::ConfiguredTableAnalysisRuleType>>,
        pub(crate) analysis_method: std::option::Option<crate::model::AnalysisMethod>,
        pub(crate) allowed_columns: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The unique ID for the configured table.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique ID for the configured table.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The unique ARN for the configured table.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The unique ARN for the configured table.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>A name for the configured table.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A name for the configured table.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A description for the configured table.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description for the configured table.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The AWS Glue table that this configured table represents.</p>
        pub fn table_reference(mut self, input: crate::model::TableReference) -> Self {
            self.table_reference = Some(input);
            self
        }
        /// <p>The AWS Glue table that this configured table represents.</p>
        pub fn set_table_reference(
            mut self,
            input: std::option::Option<crate::model::TableReference>,
        ) -> Self {
            self.table_reference = input;
            self
        }
        /// <p>The time the configured table was created.</p>
        pub fn create_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.create_time = Some(input);
            self
        }
        /// <p>The time the configured table was created.</p>
        pub fn set_create_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The time the configured table was last updated</p>
        pub fn update_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_time = Some(input);
            self
        }
        /// <p>The time the configured table was last updated</p>
        pub fn set_update_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.update_time = input;
            self
        }
        /// Appends an item to `analysis_rule_types`.
        ///
        /// To override the contents of this collection use [`set_analysis_rule_types`](Self::set_analysis_rule_types).
        ///
        /// <p>The types of analysis rules associated with this configured table. Valid values are `AGGREGATION` and `LIST`. Currently, only one analysis rule may be associated with a configured table.</p>
        pub fn analysis_rule_types(
            mut self,
            input: crate::model::ConfiguredTableAnalysisRuleType,
        ) -> Self {
            let mut v = self.analysis_rule_types.unwrap_or_default();
            v.push(input);
            self.analysis_rule_types = Some(v);
            self
        }
        /// <p>The types of analysis rules associated with this configured table. Valid values are `AGGREGATION` and `LIST`. Currently, only one analysis rule may be associated with a configured table.</p>
        pub fn set_analysis_rule_types(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ConfiguredTableAnalysisRuleType>,
            >,
        ) -> Self {
            self.analysis_rule_types = input;
            self
        }
        /// <p>The analysis method for the configured table. The only valid value is currently `DIRECT_QUERY`.</p>
        pub fn analysis_method(mut self, input: crate::model::AnalysisMethod) -> Self {
            self.analysis_method = Some(input);
            self
        }
        /// <p>The analysis method for the configured table. The only valid value is currently `DIRECT_QUERY`.</p>
        pub fn set_analysis_method(
            mut self,
            input: std::option::Option<crate::model::AnalysisMethod>,
        ) -> Self {
            self.analysis_method = input;
            self
        }
        /// Appends an item to `allowed_columns`.
        ///
        /// To override the contents of this collection use [`set_allowed_columns`](Self::set_allowed_columns).
        ///
        /// <p>The columns within the underlying AWS Glue table that can be utilized within collaborations.</p>
        pub fn allowed_columns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.allowed_columns.unwrap_or_default();
            v.push(input.into());
            self.allowed_columns = Some(v);
            self
        }
        /// <p>The columns within the underlying AWS Glue table that can be utilized within collaborations.</p>
        pub fn set_allowed_columns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.allowed_columns = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfiguredTable`](crate::model::ConfiguredTable).
        pub fn build(self) -> crate::model::ConfiguredTable {
            crate::model::ConfiguredTable {
                id: self.id,
                arn: self.arn,
                name: self.name,
                description: self.description,
                table_reference: self.table_reference,
                create_time: self.create_time,
                update_time: self.update_time,
                analysis_rule_types: self.analysis_rule_types,
                analysis_method: self.analysis_method,
                allowed_columns: self.allowed_columns,
            }
        }
    }
}
impl ConfiguredTable {
    /// Creates a new builder-style object to manufacture [`ConfiguredTable`](crate::model::ConfiguredTable).
    pub fn builder() -> crate::model::configured_table::Builder {
        crate::model::configured_table::Builder::default()
    }
}

/// <p>A pointer to the data set that underlies this table. Currently, this can only be an AWS Glue table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum TableReference {
    /// <p>If present, a reference to the AWS Glue table referred to by this table reference.</p>
    Glue(crate::model::GlueTableReference),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl TableReference {
    #[allow(irrefutable_let_patterns)]
    /// Tries to convert the enum instance into [`Glue`](crate::model::TableReference::Glue), extracting the inner [`GlueTableReference`](crate::model::GlueTableReference).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_glue(&self) -> std::result::Result<&crate::model::GlueTableReference, &Self> {
        if let TableReference::Glue(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Glue`](crate::model::TableReference::Glue).
    pub fn is_glue(&self) -> bool {
        self.as_glue().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>A reference to a table within an AWS Glue data catalog.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GlueTableReference {
    /// <p>The name of the AWS Glue table.</p>
    #[doc(hidden)]
    pub table_name: std::option::Option<std::string::String>,
    /// <p>The name of the database the AWS Glue table belongs to.</p>
    #[doc(hidden)]
    pub database_name: std::option::Option<std::string::String>,
}
impl GlueTableReference {
    /// <p>The name of the AWS Glue table.</p>
    pub fn table_name(&self) -> std::option::Option<&str> {
        self.table_name.as_deref()
    }
    /// <p>The name of the database the AWS Glue table belongs to.</p>
    pub fn database_name(&self) -> std::option::Option<&str> {
        self.database_name.as_deref()
    }
}
/// See [`GlueTableReference`](crate::model::GlueTableReference).
pub mod glue_table_reference {

    /// A builder for [`GlueTableReference`](crate::model::GlueTableReference).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) table_name: std::option::Option<std::string::String>,
        pub(crate) database_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the AWS Glue table.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.table_name = Some(input.into());
            self
        }
        /// <p>The name of the AWS Glue table.</p>
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table_name = input;
            self
        }
        /// <p>The name of the database the AWS Glue table belongs to.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.database_name = Some(input.into());
            self
        }
        /// <p>The name of the database the AWS Glue table belongs to.</p>
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.database_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GlueTableReference`](crate::model::GlueTableReference).
        pub fn build(self) -> crate::model::GlueTableReference {
            crate::model::GlueTableReference {
                table_name: self.table_name,
                database_name: self.database_name,
            }
        }
    }
}
impl GlueTableReference {
    /// Creates a new builder-style object to manufacture [`GlueTableReference`](crate::model::GlueTableReference).
    pub fn builder() -> crate::model::glue_table_reference::Builder {
        crate::model::glue_table_reference::Builder::default()
    }
}

/// <p>The configured table association summary for the objects listed by the request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfiguredTableAssociationSummary {
    /// <p>The unique configured table ID that this configured table association refers to.</p>
    #[doc(hidden)]
    pub configured_table_id: std::option::Option<std::string::String>,
    /// <p>The unique ID for the membership that the configured table association belongs to.</p>
    #[doc(hidden)]
    pub membership_id: std::option::Option<std::string::String>,
    /// <p>The unique ARN for the membership that the configured table association belongs to.</p>
    #[doc(hidden)]
    pub membership_arn: std::option::Option<std::string::String>,
    /// <p>The name of the configured table association. The table is identified by this name when running Protected Queries against the underlying data.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The time the configured table association was created.</p>
    #[doc(hidden)]
    pub create_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time the configured table association was last updated.</p>
    #[doc(hidden)]
    pub update_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The unique ID for the configured table association.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The unique ARN for the configured table association.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
}
impl ConfiguredTableAssociationSummary {
    /// <p>The unique configured table ID that this configured table association refers to.</p>
    pub fn configured_table_id(&self) -> std::option::Option<&str> {
        self.configured_table_id.as_deref()
    }
    /// <p>The unique ID for the membership that the configured table association belongs to.</p>
    pub fn membership_id(&self) -> std::option::Option<&str> {
        self.membership_id.as_deref()
    }
    /// <p>The unique ARN for the membership that the configured table association belongs to.</p>
    pub fn membership_arn(&self) -> std::option::Option<&str> {
        self.membership_arn.as_deref()
    }
    /// <p>The name of the configured table association. The table is identified by this name when running Protected Queries against the underlying data.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The time the configured table association was created.</p>
    pub fn create_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.create_time.as_ref()
    }
    /// <p>The time the configured table association was last updated.</p>
    pub fn update_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.update_time.as_ref()
    }
    /// <p>The unique ID for the configured table association.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The unique ARN for the configured table association.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
/// See [`ConfiguredTableAssociationSummary`](crate::model::ConfiguredTableAssociationSummary).
pub mod configured_table_association_summary {

    /// A builder for [`ConfiguredTableAssociationSummary`](crate::model::ConfiguredTableAssociationSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) configured_table_id: std::option::Option<std::string::String>,
        pub(crate) membership_id: std::option::Option<std::string::String>,
        pub(crate) membership_arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) create_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique configured table ID that this configured table association refers to.</p>
        pub fn configured_table_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.configured_table_id = Some(input.into());
            self
        }
        /// <p>The unique configured table ID that this configured table association refers to.</p>
        pub fn set_configured_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.configured_table_id = input;
            self
        }
        /// <p>The unique ID for the membership that the configured table association belongs to.</p>
        pub fn membership_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.membership_id = Some(input.into());
            self
        }
        /// <p>The unique ID for the membership that the configured table association belongs to.</p>
        pub fn set_membership_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.membership_id = input;
            self
        }
        /// <p>The unique ARN for the membership that the configured table association belongs to.</p>
        pub fn membership_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.membership_arn = Some(input.into());
            self
        }
        /// <p>The unique ARN for the membership that the configured table association belongs to.</p>
        pub fn set_membership_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.membership_arn = input;
            self
        }
        /// <p>The name of the configured table association. The table is identified by this name when running Protected Queries against the underlying data.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the configured table association. The table is identified by this name when running Protected Queries against the underlying data.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The time the configured table association was created.</p>
        pub fn create_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.create_time = Some(input);
            self
        }
        /// <p>The time the configured table association was created.</p>
        pub fn set_create_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The time the configured table association was last updated.</p>
        pub fn update_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_time = Some(input);
            self
        }
        /// <p>The time the configured table association was last updated.</p>
        pub fn set_update_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.update_time = input;
            self
        }
        /// <p>The unique ID for the configured table association.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique ID for the configured table association.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The unique ARN for the configured table association.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The unique ARN for the configured table association.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfiguredTableAssociationSummary`](crate::model::ConfiguredTableAssociationSummary).
        pub fn build(self) -> crate::model::ConfiguredTableAssociationSummary {
            crate::model::ConfiguredTableAssociationSummary {
                configured_table_id: self.configured_table_id,
                membership_id: self.membership_id,
                membership_arn: self.membership_arn,
                name: self.name,
                create_time: self.create_time,
                update_time: self.update_time,
                id: self.id,
                arn: self.arn,
            }
        }
    }
}
impl ConfiguredTableAssociationSummary {
    /// Creates a new builder-style object to manufacture [`ConfiguredTableAssociationSummary`](crate::model::ConfiguredTableAssociationSummary).
    pub fn builder() -> crate::model::configured_table_association_summary::Builder {
        crate::model::configured_table_association_summary::Builder::default()
    }
}

/// <p>A configured table association links a configured table to a collaboration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfiguredTableAssociation {
    /// <p>The unique ARN for the configured table association.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The unique ID for the configured table association.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The unique ID for the configured table that the association refers to.</p>
    #[doc(hidden)]
    pub configured_table_id: std::option::Option<std::string::String>,
    /// <p>The unique ARN for the configured table that the association refers to.</p>
    #[doc(hidden)]
    pub configured_table_arn: std::option::Option<std::string::String>,
    /// <p>The unique ID for the membership this configured table association belongs to.</p>
    #[doc(hidden)]
    pub membership_id: std::option::Option<std::string::String>,
    /// <p>The unique ARN for the membership this configured table association belongs to.</p>
    #[doc(hidden)]
    pub membership_arn: std::option::Option<std::string::String>,
    /// <p>The service will assume this role to access catalog metadata and query the table.</p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The name of the configured table association, in lowercase. The table is identified by this name when running protected queries against the underlying data.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A description of the configured table association.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The time the configured table association was created.</p>
    #[doc(hidden)]
    pub create_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time the configured table association was last updated.</p>
    #[doc(hidden)]
    pub update_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl ConfiguredTableAssociation {
    /// <p>The unique ARN for the configured table association.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The unique ID for the configured table association.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The unique ID for the configured table that the association refers to.</p>
    pub fn configured_table_id(&self) -> std::option::Option<&str> {
        self.configured_table_id.as_deref()
    }
    /// <p>The unique ARN for the configured table that the association refers to.</p>
    pub fn configured_table_arn(&self) -> std::option::Option<&str> {
        self.configured_table_arn.as_deref()
    }
    /// <p>The unique ID for the membership this configured table association belongs to.</p>
    pub fn membership_id(&self) -> std::option::Option<&str> {
        self.membership_id.as_deref()
    }
    /// <p>The unique ARN for the membership this configured table association belongs to.</p>
    pub fn membership_arn(&self) -> std::option::Option<&str> {
        self.membership_arn.as_deref()
    }
    /// <p>The service will assume this role to access catalog metadata and query the table.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>The name of the configured table association, in lowercase. The table is identified by this name when running protected queries against the underlying data.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A description of the configured table association.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The time the configured table association was created.</p>
    pub fn create_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.create_time.as_ref()
    }
    /// <p>The time the configured table association was last updated.</p>
    pub fn update_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.update_time.as_ref()
    }
}
/// See [`ConfiguredTableAssociation`](crate::model::ConfiguredTableAssociation).
pub mod configured_table_association {

    /// A builder for [`ConfiguredTableAssociation`](crate::model::ConfiguredTableAssociation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) configured_table_id: std::option::Option<std::string::String>,
        pub(crate) configured_table_arn: std::option::Option<std::string::String>,
        pub(crate) membership_id: std::option::Option<std::string::String>,
        pub(crate) membership_arn: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) create_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The unique ARN for the configured table association.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The unique ARN for the configured table association.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The unique ID for the configured table association.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique ID for the configured table association.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The unique ID for the configured table that the association refers to.</p>
        pub fn configured_table_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.configured_table_id = Some(input.into());
            self
        }
        /// <p>The unique ID for the configured table that the association refers to.</p>
        pub fn set_configured_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.configured_table_id = input;
            self
        }
        /// <p>The unique ARN for the configured table that the association refers to.</p>
        pub fn configured_table_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.configured_table_arn = Some(input.into());
            self
        }
        /// <p>The unique ARN for the configured table that the association refers to.</p>
        pub fn set_configured_table_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.configured_table_arn = input;
            self
        }
        /// <p>The unique ID for the membership this configured table association belongs to.</p>
        pub fn membership_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.membership_id = Some(input.into());
            self
        }
        /// <p>The unique ID for the membership this configured table association belongs to.</p>
        pub fn set_membership_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.membership_id = input;
            self
        }
        /// <p>The unique ARN for the membership this configured table association belongs to.</p>
        pub fn membership_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.membership_arn = Some(input.into());
            self
        }
        /// <p>The unique ARN for the membership this configured table association belongs to.</p>
        pub fn set_membership_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.membership_arn = input;
            self
        }
        /// <p>The service will assume this role to access catalog metadata and query the table.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The service will assume this role to access catalog metadata and query the table.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>The name of the configured table association, in lowercase. The table is identified by this name when running protected queries against the underlying data.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the configured table association, in lowercase. The table is identified by this name when running protected queries against the underlying data.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A description of the configured table association.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the configured table association.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The time the configured table association was created.</p>
        pub fn create_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.create_time = Some(input);
            self
        }
        /// <p>The time the configured table association was created.</p>
        pub fn set_create_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The time the configured table association was last updated.</p>
        pub fn update_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_time = Some(input);
            self
        }
        /// <p>The time the configured table association was last updated.</p>
        pub fn set_update_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.update_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfiguredTableAssociation`](crate::model::ConfiguredTableAssociation).
        pub fn build(self) -> crate::model::ConfiguredTableAssociation {
            crate::model::ConfiguredTableAssociation {
                arn: self.arn,
                id: self.id,
                configured_table_id: self.configured_table_id,
                configured_table_arn: self.configured_table_arn,
                membership_id: self.membership_id,
                membership_arn: self.membership_arn,
                role_arn: self.role_arn,
                name: self.name,
                description: self.description,
                create_time: self.create_time,
                update_time: self.update_time,
            }
        }
    }
}
impl ConfiguredTableAssociation {
    /// Creates a new builder-style object to manufacture [`ConfiguredTableAssociation`](crate::model::ConfiguredTableAssociation).
    pub fn builder() -> crate::model::configured_table_association::Builder {
        crate::model::configured_table_association::Builder::default()
    }
}

/// <p>The schema summary for the objects listed by the request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SchemaSummary {
    /// <p>The name for the schema object.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of schema object. The only valid schema type is currently `TABLE`.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::SchemaType>,
    /// <p>The unique account ID for the AWS account that owns the schema.</p>
    #[doc(hidden)]
    pub creator_account_id: std::option::Option<std::string::String>,
    /// <p>The time the schema object was created.</p>
    #[doc(hidden)]
    pub create_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time the schema object was last updated.</p>
    #[doc(hidden)]
    pub update_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The unique ID for the collaboration that the schema belongs to.</p>
    #[doc(hidden)]
    pub collaboration_id: std::option::Option<std::string::String>,
    /// <p>The unique ARN for the collaboration that the schema belongs to.</p>
    #[doc(hidden)]
    pub collaboration_arn: std::option::Option<std::string::String>,
    /// <p>The types of analysis rules that are associated with this schema object.</p>
    #[doc(hidden)]
    pub analysis_rule_types: std::option::Option<std::vec::Vec<crate::model::AnalysisRuleType>>,
    /// <p>The analysis method for the associated schema. The only valid value is currently `DIRECT_QUERY`.</p>
    #[doc(hidden)]
    pub analysis_method: std::option::Option<crate::model::AnalysisMethod>,
}
impl SchemaSummary {
    /// <p>The name for the schema object.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of schema object. The only valid schema type is currently `TABLE`.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::SchemaType> {
        self.r#type.as_ref()
    }
    /// <p>The unique account ID for the AWS account that owns the schema.</p>
    pub fn creator_account_id(&self) -> std::option::Option<&str> {
        self.creator_account_id.as_deref()
    }
    /// <p>The time the schema object was created.</p>
    pub fn create_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.create_time.as_ref()
    }
    /// <p>The time the schema object was last updated.</p>
    pub fn update_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.update_time.as_ref()
    }
    /// <p>The unique ID for the collaboration that the schema belongs to.</p>
    pub fn collaboration_id(&self) -> std::option::Option<&str> {
        self.collaboration_id.as_deref()
    }
    /// <p>The unique ARN for the collaboration that the schema belongs to.</p>
    pub fn collaboration_arn(&self) -> std::option::Option<&str> {
        self.collaboration_arn.as_deref()
    }
    /// <p>The types of analysis rules that are associated with this schema object.</p>
    pub fn analysis_rule_types(&self) -> std::option::Option<&[crate::model::AnalysisRuleType]> {
        self.analysis_rule_types.as_deref()
    }
    /// <p>The analysis method for the associated schema. The only valid value is currently `DIRECT_QUERY`.</p>
    pub fn analysis_method(&self) -> std::option::Option<&crate::model::AnalysisMethod> {
        self.analysis_method.as_ref()
    }
}
/// See [`SchemaSummary`](crate::model::SchemaSummary).
pub mod schema_summary {

    /// A builder for [`SchemaSummary`](crate::model::SchemaSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::SchemaType>,
        pub(crate) creator_account_id: std::option::Option<std::string::String>,
        pub(crate) create_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) collaboration_id: std::option::Option<std::string::String>,
        pub(crate) collaboration_arn: std::option::Option<std::string::String>,
        pub(crate) analysis_rule_types:
            std::option::Option<std::vec::Vec<crate::model::AnalysisRuleType>>,
        pub(crate) analysis_method: std::option::Option<crate::model::AnalysisMethod>,
    }
    impl Builder {
        /// <p>The name for the schema object.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name for the schema object.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of schema object. The only valid schema type is currently `TABLE`.</p>
        pub fn r#type(mut self, input: crate::model::SchemaType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of schema object. The only valid schema type is currently `TABLE`.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::SchemaType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The unique account ID for the AWS account that owns the schema.</p>
        pub fn creator_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.creator_account_id = Some(input.into());
            self
        }
        /// <p>The unique account ID for the AWS account that owns the schema.</p>
        pub fn set_creator_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creator_account_id = input;
            self
        }
        /// <p>The time the schema object was created.</p>
        pub fn create_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.create_time = Some(input);
            self
        }
        /// <p>The time the schema object was created.</p>
        pub fn set_create_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The time the schema object was last updated.</p>
        pub fn update_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_time = Some(input);
            self
        }
        /// <p>The time the schema object was last updated.</p>
        pub fn set_update_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.update_time = input;
            self
        }
        /// <p>The unique ID for the collaboration that the schema belongs to.</p>
        pub fn collaboration_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.collaboration_id = Some(input.into());
            self
        }
        /// <p>The unique ID for the collaboration that the schema belongs to.</p>
        pub fn set_collaboration_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.collaboration_id = input;
            self
        }
        /// <p>The unique ARN for the collaboration that the schema belongs to.</p>
        pub fn collaboration_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.collaboration_arn = Some(input.into());
            self
        }
        /// <p>The unique ARN for the collaboration that the schema belongs to.</p>
        pub fn set_collaboration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.collaboration_arn = input;
            self
        }
        /// Appends an item to `analysis_rule_types`.
        ///
        /// To override the contents of this collection use [`set_analysis_rule_types`](Self::set_analysis_rule_types).
        ///
        /// <p>The types of analysis rules that are associated with this schema object.</p>
        pub fn analysis_rule_types(mut self, input: crate::model::AnalysisRuleType) -> Self {
            let mut v = self.analysis_rule_types.unwrap_or_default();
            v.push(input);
            self.analysis_rule_types = Some(v);
            self
        }
        /// <p>The types of analysis rules that are associated with this schema object.</p>
        pub fn set_analysis_rule_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AnalysisRuleType>>,
        ) -> Self {
            self.analysis_rule_types = input;
            self
        }
        /// <p>The analysis method for the associated schema. The only valid value is currently `DIRECT_QUERY`.</p>
        pub fn analysis_method(mut self, input: crate::model::AnalysisMethod) -> Self {
            self.analysis_method = Some(input);
            self
        }
        /// <p>The analysis method for the associated schema. The only valid value is currently `DIRECT_QUERY`.</p>
        pub fn set_analysis_method(
            mut self,
            input: std::option::Option<crate::model::AnalysisMethod>,
        ) -> Self {
            self.analysis_method = input;
            self
        }
        /// Consumes the builder and constructs a [`SchemaSummary`](crate::model::SchemaSummary).
        pub fn build(self) -> crate::model::SchemaSummary {
            crate::model::SchemaSummary {
                name: self.name,
                r#type: self.r#type,
                creator_account_id: self.creator_account_id,
                create_time: self.create_time,
                update_time: self.update_time,
                collaboration_id: self.collaboration_id,
                collaboration_arn: self.collaboration_arn,
                analysis_rule_types: self.analysis_rule_types,
                analysis_method: self.analysis_method,
            }
        }
    }
}
impl SchemaSummary {
    /// Creates a new builder-style object to manufacture [`SchemaSummary`](crate::model::SchemaSummary).
    pub fn builder() -> crate::model::schema_summary::Builder {
        crate::model::schema_summary::Builder::default()
    }
}

/// When writing a match expression against `AnalysisRuleType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let analysisruletype = unimplemented!();
/// match analysisruletype {
///     AnalysisRuleType::Aggregation => { /* ... */ },
///     AnalysisRuleType::List => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `analysisruletype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AnalysisRuleType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AnalysisRuleType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AnalysisRuleType::NewFeature` is defined.
/// Specifically, when `analysisruletype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AnalysisRuleType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AnalysisRuleType {
    #[allow(missing_docs)] // documentation missing in model
    Aggregation,
    #[allow(missing_docs)] // documentation missing in model
    List,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AnalysisRuleType {
    fn from(s: &str) -> Self {
        match s {
            "AGGREGATION" => AnalysisRuleType::Aggregation,
            "LIST" => AnalysisRuleType::List,
            other => AnalysisRuleType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AnalysisRuleType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AnalysisRuleType::from(s))
    }
}
impl AnalysisRuleType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AnalysisRuleType::Aggregation => "AGGREGATION",
            AnalysisRuleType::List => "LIST",
            AnalysisRuleType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AGGREGATION", "LIST"]
    }
}
impl AsRef<str> for AnalysisRuleType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `SchemaType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let schematype = unimplemented!();
/// match schematype {
///     SchemaType::Table => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `schematype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SchemaType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SchemaType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SchemaType::NewFeature` is defined.
/// Specifically, when `schematype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SchemaType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SchemaType {
    #[allow(missing_docs)] // documentation missing in model
    Table,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SchemaType {
    fn from(s: &str) -> Self {
        match s {
            "TABLE" => SchemaType::Table,
            other => SchemaType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SchemaType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SchemaType::from(s))
    }
}
impl SchemaType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SchemaType::Table => "TABLE",
            SchemaType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["TABLE"]
    }
}
impl AsRef<str> for SchemaType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The member object listed by the request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MemberSummary {
    /// <p>The identifier used to reference members of the collaboration. Currently only supports AWS Account ID.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The status of the member. Valid values are `INVITED`, `ACTIVE`, `LEFT`, and `REMOVED`.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::MemberStatus>,
    /// <p>The member's display name.</p>
    #[doc(hidden)]
    pub display_name: std::option::Option<std::string::String>,
    /// <p>The abilities granted to the collaboration member.</p>
    #[doc(hidden)]
    pub abilities: std::option::Option<std::vec::Vec<crate::model::MemberAbility>>,
    /// <p>The time when the member was created.</p>
    #[doc(hidden)]
    pub create_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time the member metadata was last updated.</p>
    #[doc(hidden)]
    pub update_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The unique ID for the member's associated membership, if present.</p>
    #[doc(hidden)]
    pub membership_id: std::option::Option<std::string::String>,
    /// <p>The unique ARN for the member's associated membership, if present.</p>
    #[doc(hidden)]
    pub membership_arn: std::option::Option<std::string::String>,
}
impl MemberSummary {
    /// <p>The identifier used to reference members of the collaboration. Currently only supports AWS Account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The status of the member. Valid values are `INVITED`, `ACTIVE`, `LEFT`, and `REMOVED`.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::MemberStatus> {
        self.status.as_ref()
    }
    /// <p>The member's display name.</p>
    pub fn display_name(&self) -> std::option::Option<&str> {
        self.display_name.as_deref()
    }
    /// <p>The abilities granted to the collaboration member.</p>
    pub fn abilities(&self) -> std::option::Option<&[crate::model::MemberAbility]> {
        self.abilities.as_deref()
    }
    /// <p>The time when the member was created.</p>
    pub fn create_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.create_time.as_ref()
    }
    /// <p>The time the member metadata was last updated.</p>
    pub fn update_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.update_time.as_ref()
    }
    /// <p>The unique ID for the member's associated membership, if present.</p>
    pub fn membership_id(&self) -> std::option::Option<&str> {
        self.membership_id.as_deref()
    }
    /// <p>The unique ARN for the member's associated membership, if present.</p>
    pub fn membership_arn(&self) -> std::option::Option<&str> {
        self.membership_arn.as_deref()
    }
}
/// See [`MemberSummary`](crate::model::MemberSummary).
pub mod member_summary {

    /// A builder for [`MemberSummary`](crate::model::MemberSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::MemberStatus>,
        pub(crate) display_name: std::option::Option<std::string::String>,
        pub(crate) abilities: std::option::Option<std::vec::Vec<crate::model::MemberAbility>>,
        pub(crate) create_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) membership_id: std::option::Option<std::string::String>,
        pub(crate) membership_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier used to reference members of the collaboration. Currently only supports AWS Account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The identifier used to reference members of the collaboration. Currently only supports AWS Account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The status of the member. Valid values are `INVITED`, `ACTIVE`, `LEFT`, and `REMOVED`.</p>
        pub fn status(mut self, input: crate::model::MemberStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the member. Valid values are `INVITED`, `ACTIVE`, `LEFT`, and `REMOVED`.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::MemberStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The member's display name.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        /// <p>The member's display name.</p>
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// Appends an item to `abilities`.
        ///
        /// To override the contents of this collection use [`set_abilities`](Self::set_abilities).
        ///
        /// <p>The abilities granted to the collaboration member.</p>
        pub fn abilities(mut self, input: crate::model::MemberAbility) -> Self {
            let mut v = self.abilities.unwrap_or_default();
            v.push(input);
            self.abilities = Some(v);
            self
        }
        /// <p>The abilities granted to the collaboration member.</p>
        pub fn set_abilities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MemberAbility>>,
        ) -> Self {
            self.abilities = input;
            self
        }
        /// <p>The time when the member was created.</p>
        pub fn create_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.create_time = Some(input);
            self
        }
        /// <p>The time when the member was created.</p>
        pub fn set_create_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The time the member metadata was last updated.</p>
        pub fn update_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_time = Some(input);
            self
        }
        /// <p>The time the member metadata was last updated.</p>
        pub fn set_update_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.update_time = input;
            self
        }
        /// <p>The unique ID for the member's associated membership, if present.</p>
        pub fn membership_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.membership_id = Some(input.into());
            self
        }
        /// <p>The unique ID for the member's associated membership, if present.</p>
        pub fn set_membership_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.membership_id = input;
            self
        }
        /// <p>The unique ARN for the member's associated membership, if present.</p>
        pub fn membership_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.membership_arn = Some(input.into());
            self
        }
        /// <p>The unique ARN for the member's associated membership, if present.</p>
        pub fn set_membership_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.membership_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`MemberSummary`](crate::model::MemberSummary).
        pub fn build(self) -> crate::model::MemberSummary {
            crate::model::MemberSummary {
                account_id: self.account_id,
                status: self.status,
                display_name: self.display_name,
                abilities: self.abilities,
                create_time: self.create_time,
                update_time: self.update_time,
                membership_id: self.membership_id,
                membership_arn: self.membership_arn,
            }
        }
    }
}
impl MemberSummary {
    /// Creates a new builder-style object to manufacture [`MemberSummary`](crate::model::MemberSummary).
    pub fn builder() -> crate::model::member_summary::Builder {
        crate::model::member_summary::Builder::default()
    }
}

/// When writing a match expression against `MemberStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let memberstatus = unimplemented!();
/// match memberstatus {
///     MemberStatus::Active => { /* ... */ },
///     MemberStatus::Invited => { /* ... */ },
///     MemberStatus::Left => { /* ... */ },
///     MemberStatus::Removed => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `memberstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `MemberStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `MemberStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `MemberStatus::NewFeature` is defined.
/// Specifically, when `memberstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `MemberStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MemberStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Invited,
    #[allow(missing_docs)] // documentation missing in model
    Left,
    #[allow(missing_docs)] // documentation missing in model
    Removed,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for MemberStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => MemberStatus::Active,
            "INVITED" => MemberStatus::Invited,
            "LEFT" => MemberStatus::Left,
            "REMOVED" => MemberStatus::Removed,
            other => MemberStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for MemberStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MemberStatus::from(s))
    }
}
impl MemberStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MemberStatus::Active => "ACTIVE",
            MemberStatus::Invited => "INVITED",
            MemberStatus::Left => "LEFT",
            MemberStatus::Removed => "REMOVED",
            MemberStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "INVITED", "LEFT", "REMOVED"]
    }
}
impl AsRef<str> for MemberStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A specification about how data from the configured table can be used in a query.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AnalysisRule {
    /// <p>The unique ID for the associated collaboration.</p>
    #[doc(hidden)]
    pub collaboration_id: std::option::Option<std::string::String>,
    /// <p>The type of analysis rule. Valid values are `AGGREGATION` and `LIST`.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::AnalysisRuleType>,
    /// <p>The name for the analysis rule.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The time the analysis rule was created.</p>
    #[doc(hidden)]
    pub create_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time the analysis rule was last updated.</p>
    #[doc(hidden)]
    pub update_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A policy that describes the associated data usage limitations.</p>
    #[doc(hidden)]
    pub policy: std::option::Option<crate::model::AnalysisRulePolicy>,
}
impl AnalysisRule {
    /// <p>The unique ID for the associated collaboration.</p>
    pub fn collaboration_id(&self) -> std::option::Option<&str> {
        self.collaboration_id.as_deref()
    }
    /// <p>The type of analysis rule. Valid values are `AGGREGATION` and `LIST`.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::AnalysisRuleType> {
        self.r#type.as_ref()
    }
    /// <p>The name for the analysis rule.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The time the analysis rule was created.</p>
    pub fn create_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.create_time.as_ref()
    }
    /// <p>The time the analysis rule was last updated.</p>
    pub fn update_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.update_time.as_ref()
    }
    /// <p>A policy that describes the associated data usage limitations.</p>
    pub fn policy(&self) -> std::option::Option<&crate::model::AnalysisRulePolicy> {
        self.policy.as_ref()
    }
}
/// See [`AnalysisRule`](crate::model::AnalysisRule).
pub mod analysis_rule {

    /// A builder for [`AnalysisRule`](crate::model::AnalysisRule).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) collaboration_id: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::AnalysisRuleType>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) create_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) policy: std::option::Option<crate::model::AnalysisRulePolicy>,
    }
    impl Builder {
        /// <p>The unique ID for the associated collaboration.</p>
        pub fn collaboration_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.collaboration_id = Some(input.into());
            self
        }
        /// <p>The unique ID for the associated collaboration.</p>
        pub fn set_collaboration_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.collaboration_id = input;
            self
        }
        /// <p>The type of analysis rule. Valid values are `AGGREGATION` and `LIST`.</p>
        pub fn r#type(mut self, input: crate::model::AnalysisRuleType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of analysis rule. Valid values are `AGGREGATION` and `LIST`.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::AnalysisRuleType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The name for the analysis rule.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name for the analysis rule.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The time the analysis rule was created.</p>
        pub fn create_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.create_time = Some(input);
            self
        }
        /// <p>The time the analysis rule was created.</p>
        pub fn set_create_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The time the analysis rule was last updated.</p>
        pub fn update_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_time = Some(input);
            self
        }
        /// <p>The time the analysis rule was last updated.</p>
        pub fn set_update_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.update_time = input;
            self
        }
        /// <p>A policy that describes the associated data usage limitations.</p>
        pub fn policy(mut self, input: crate::model::AnalysisRulePolicy) -> Self {
            self.policy = Some(input);
            self
        }
        /// <p>A policy that describes the associated data usage limitations.</p>
        pub fn set_policy(
            mut self,
            input: std::option::Option<crate::model::AnalysisRulePolicy>,
        ) -> Self {
            self.policy = input;
            self
        }
        /// Consumes the builder and constructs a [`AnalysisRule`](crate::model::AnalysisRule).
        pub fn build(self) -> crate::model::AnalysisRule {
            crate::model::AnalysisRule {
                collaboration_id: self.collaboration_id,
                r#type: self.r#type,
                name: self.name,
                create_time: self.create_time,
                update_time: self.update_time,
                policy: self.policy,
            }
        }
    }
}
impl AnalysisRule {
    /// Creates a new builder-style object to manufacture [`AnalysisRule`](crate::model::AnalysisRule).
    pub fn builder() -> crate::model::analysis_rule::Builder {
        crate::model::analysis_rule::Builder::default()
    }
}

/// <p>Controls on the query specifications that can be run on configured table..</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum AnalysisRulePolicy {
    /// <p>Controls on the query specifications that can be run on configured table..</p>
    V1(crate::model::AnalysisRulePolicyV1),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl AnalysisRulePolicy {
    #[allow(irrefutable_let_patterns)]
    /// Tries to convert the enum instance into [`V1`](crate::model::AnalysisRulePolicy::V1), extracting the inner [`AnalysisRulePolicyV1`](crate::model::AnalysisRulePolicyV1).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_v1(&self) -> std::result::Result<&crate::model::AnalysisRulePolicyV1, &Self> {
        if let AnalysisRulePolicy::V1(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`V1`](crate::model::AnalysisRulePolicy::V1).
    pub fn is_v1(&self) -> bool {
        self.as_v1().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Controls on the query specifications that can be run on configured table..</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum AnalysisRulePolicyV1 {
    /// <p>Analysis rule type that enables only aggregation queries on a configured table.</p>
    Aggregation(crate::model::AnalysisRuleAggregation),
    /// <p>Analysis rule type that enables only list queries on a configured table.</p>
    List(crate::model::AnalysisRuleList),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl AnalysisRulePolicyV1 {
    /// Tries to convert the enum instance into [`Aggregation`](crate::model::AnalysisRulePolicyV1::Aggregation), extracting the inner [`AnalysisRuleAggregation`](crate::model::AnalysisRuleAggregation).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_aggregation(
        &self,
    ) -> std::result::Result<&crate::model::AnalysisRuleAggregation, &Self> {
        if let AnalysisRulePolicyV1::Aggregation(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Aggregation`](crate::model::AnalysisRulePolicyV1::Aggregation).
    pub fn is_aggregation(&self) -> bool {
        self.as_aggregation().is_ok()
    }
    /// Tries to convert the enum instance into [`List`](crate::model::AnalysisRulePolicyV1::List), extracting the inner [`AnalysisRuleList`](crate::model::AnalysisRuleList).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_list(&self) -> std::result::Result<&crate::model::AnalysisRuleList, &Self> {
        if let AnalysisRulePolicyV1::List(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`List`](crate::model::AnalysisRulePolicyV1::List).
    pub fn is_list(&self) -> bool {
        self.as_list().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>A schema is a relation within a collaboration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Schema {
    /// <p>The columns for the relation this schema represents.</p>
    #[doc(hidden)]
    pub columns: std::option::Option<std::vec::Vec<crate::model::Column>>,
    /// <p>The partition keys for the data set underlying this schema.</p>
    #[doc(hidden)]
    pub partition_keys: std::option::Option<std::vec::Vec<crate::model::Column>>,
    /// <p>The analysis rule types associated with the schema. Valued values are LIST and AGGREGATION. Currently, only one entry is present.</p>
    #[doc(hidden)]
    pub analysis_rule_types: std::option::Option<std::vec::Vec<crate::model::AnalysisRuleType>>,
    /// <p>The analysis method for the schema. The only valid value is currently DIRECT_QUERY.</p>
    #[doc(hidden)]
    pub analysis_method: std::option::Option<crate::model::AnalysisMethod>,
    /// <p>The unique account ID for the AWS account that owns the schema.</p>
    #[doc(hidden)]
    pub creator_account_id: std::option::Option<std::string::String>,
    /// <p>A name for the schema. The schema relation is referred to by this name when queried by a protected query.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The unique ID for the collaboration that the schema belongs to.</p>
    #[doc(hidden)]
    pub collaboration_id: std::option::Option<std::string::String>,
    /// <p>The unique ARN for the collaboration that the schema belongs to.</p>
    #[doc(hidden)]
    pub collaboration_arn: std::option::Option<std::string::String>,
    /// <p>A description for the schema.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The time the schema was created.</p>
    #[doc(hidden)]
    pub create_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time the schema was last updated.</p>
    #[doc(hidden)]
    pub update_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The type of schema. The only valid value is currently `TABLE`.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::SchemaType>,
}
impl Schema {
    /// <p>The columns for the relation this schema represents.</p>
    pub fn columns(&self) -> std::option::Option<&[crate::model::Column]> {
        self.columns.as_deref()
    }
    /// <p>The partition keys for the data set underlying this schema.</p>
    pub fn partition_keys(&self) -> std::option::Option<&[crate::model::Column]> {
        self.partition_keys.as_deref()
    }
    /// <p>The analysis rule types associated with the schema. Valued values are LIST and AGGREGATION. Currently, only one entry is present.</p>
    pub fn analysis_rule_types(&self) -> std::option::Option<&[crate::model::AnalysisRuleType]> {
        self.analysis_rule_types.as_deref()
    }
    /// <p>The analysis method for the schema. The only valid value is currently DIRECT_QUERY.</p>
    pub fn analysis_method(&self) -> std::option::Option<&crate::model::AnalysisMethod> {
        self.analysis_method.as_ref()
    }
    /// <p>The unique account ID for the AWS account that owns the schema.</p>
    pub fn creator_account_id(&self) -> std::option::Option<&str> {
        self.creator_account_id.as_deref()
    }
    /// <p>A name for the schema. The schema relation is referred to by this name when queried by a protected query.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The unique ID for the collaboration that the schema belongs to.</p>
    pub fn collaboration_id(&self) -> std::option::Option<&str> {
        self.collaboration_id.as_deref()
    }
    /// <p>The unique ARN for the collaboration that the schema belongs to.</p>
    pub fn collaboration_arn(&self) -> std::option::Option<&str> {
        self.collaboration_arn.as_deref()
    }
    /// <p>A description for the schema.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The time the schema was created.</p>
    pub fn create_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.create_time.as_ref()
    }
    /// <p>The time the schema was last updated.</p>
    pub fn update_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.update_time.as_ref()
    }
    /// <p>The type of schema. The only valid value is currently `TABLE`.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::SchemaType> {
        self.r#type.as_ref()
    }
}
/// See [`Schema`](crate::model::Schema).
pub mod schema {

    /// A builder for [`Schema`](crate::model::Schema).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) columns: std::option::Option<std::vec::Vec<crate::model::Column>>,
        pub(crate) partition_keys: std::option::Option<std::vec::Vec<crate::model::Column>>,
        pub(crate) analysis_rule_types:
            std::option::Option<std::vec::Vec<crate::model::AnalysisRuleType>>,
        pub(crate) analysis_method: std::option::Option<crate::model::AnalysisMethod>,
        pub(crate) creator_account_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) collaboration_id: std::option::Option<std::string::String>,
        pub(crate) collaboration_arn: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) create_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) r#type: std::option::Option<crate::model::SchemaType>,
    }
    impl Builder {
        /// Appends an item to `columns`.
        ///
        /// To override the contents of this collection use [`set_columns`](Self::set_columns).
        ///
        /// <p>The columns for the relation this schema represents.</p>
        pub fn columns(mut self, input: crate::model::Column) -> Self {
            let mut v = self.columns.unwrap_or_default();
            v.push(input);
            self.columns = Some(v);
            self
        }
        /// <p>The columns for the relation this schema represents.</p>
        pub fn set_columns(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Column>>,
        ) -> Self {
            self.columns = input;
            self
        }
        /// Appends an item to `partition_keys`.
        ///
        /// To override the contents of this collection use [`set_partition_keys`](Self::set_partition_keys).
        ///
        /// <p>The partition keys for the data set underlying this schema.</p>
        pub fn partition_keys(mut self, input: crate::model::Column) -> Self {
            let mut v = self.partition_keys.unwrap_or_default();
            v.push(input);
            self.partition_keys = Some(v);
            self
        }
        /// <p>The partition keys for the data set underlying this schema.</p>
        pub fn set_partition_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Column>>,
        ) -> Self {
            self.partition_keys = input;
            self
        }
        /// Appends an item to `analysis_rule_types`.
        ///
        /// To override the contents of this collection use [`set_analysis_rule_types`](Self::set_analysis_rule_types).
        ///
        /// <p>The analysis rule types associated with the schema. Valued values are LIST and AGGREGATION. Currently, only one entry is present.</p>
        pub fn analysis_rule_types(mut self, input: crate::model::AnalysisRuleType) -> Self {
            let mut v = self.analysis_rule_types.unwrap_or_default();
            v.push(input);
            self.analysis_rule_types = Some(v);
            self
        }
        /// <p>The analysis rule types associated with the schema. Valued values are LIST and AGGREGATION. Currently, only one entry is present.</p>
        pub fn set_analysis_rule_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AnalysisRuleType>>,
        ) -> Self {
            self.analysis_rule_types = input;
            self
        }
        /// <p>The analysis method for the schema. The only valid value is currently DIRECT_QUERY.</p>
        pub fn analysis_method(mut self, input: crate::model::AnalysisMethod) -> Self {
            self.analysis_method = Some(input);
            self
        }
        /// <p>The analysis method for the schema. The only valid value is currently DIRECT_QUERY.</p>
        pub fn set_analysis_method(
            mut self,
            input: std::option::Option<crate::model::AnalysisMethod>,
        ) -> Self {
            self.analysis_method = input;
            self
        }
        /// <p>The unique account ID for the AWS account that owns the schema.</p>
        pub fn creator_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.creator_account_id = Some(input.into());
            self
        }
        /// <p>The unique account ID for the AWS account that owns the schema.</p>
        pub fn set_creator_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creator_account_id = input;
            self
        }
        /// <p>A name for the schema. The schema relation is referred to by this name when queried by a protected query.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A name for the schema. The schema relation is referred to by this name when queried by a protected query.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The unique ID for the collaboration that the schema belongs to.</p>
        pub fn collaboration_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.collaboration_id = Some(input.into());
            self
        }
        /// <p>The unique ID for the collaboration that the schema belongs to.</p>
        pub fn set_collaboration_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.collaboration_id = input;
            self
        }
        /// <p>The unique ARN for the collaboration that the schema belongs to.</p>
        pub fn collaboration_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.collaboration_arn = Some(input.into());
            self
        }
        /// <p>The unique ARN for the collaboration that the schema belongs to.</p>
        pub fn set_collaboration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.collaboration_arn = input;
            self
        }
        /// <p>A description for the schema.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description for the schema.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The time the schema was created.</p>
        pub fn create_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.create_time = Some(input);
            self
        }
        /// <p>The time the schema was created.</p>
        pub fn set_create_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The time the schema was last updated.</p>
        pub fn update_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_time = Some(input);
            self
        }
        /// <p>The time the schema was last updated.</p>
        pub fn set_update_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.update_time = input;
            self
        }
        /// <p>The type of schema. The only valid value is currently `TABLE`.</p>
        pub fn r#type(mut self, input: crate::model::SchemaType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of schema. The only valid value is currently `TABLE`.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::SchemaType>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`Schema`](crate::model::Schema).
        pub fn build(self) -> crate::model::Schema {
            crate::model::Schema {
                columns: self.columns,
                partition_keys: self.partition_keys,
                analysis_rule_types: self.analysis_rule_types,
                analysis_method: self.analysis_method,
                creator_account_id: self.creator_account_id,
                name: self.name,
                collaboration_id: self.collaboration_id,
                collaboration_arn: self.collaboration_arn,
                description: self.description,
                create_time: self.create_time,
                update_time: self.update_time,
                r#type: self.r#type,
            }
        }
    }
}
impl Schema {
    /// Creates a new builder-style object to manufacture [`Schema`](crate::model::Schema).
    pub fn builder() -> crate::model::schema::Builder {
        crate::model::schema::Builder::default()
    }
}

/// <p>A column within a schema relation, derived from the underlying AWS Glue table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Column {
    /// <p>The name of the column.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of the column.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
}
impl Column {
    /// <p>The name of the column.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of the column.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
/// See [`Column`](crate::model::Column).
pub mod column {

    /// A builder for [`Column`](crate::model::Column).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the column.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the column.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of the column.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of the column.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`Column`](crate::model::Column).
        pub fn build(self) -> crate::model::Column {
            crate::model::Column {
                name: self.name,
                r#type: self.r#type,
            }
        }
    }
}
impl Column {
    /// Creates a new builder-style object to manufacture [`Column`](crate::model::Column).
    pub fn builder() -> crate::model::column::Builder {
        crate::model::column::Builder::default()
    }
}

/// <p>An error describing why a schema could not be fetched.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchGetSchemaError {
    /// <p>An error name for the error.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>An error code for the error. </p>
    #[doc(hidden)]
    pub code: std::option::Option<std::string::String>,
    /// <p>An error message for the error.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl BatchGetSchemaError {
    /// <p>An error name for the error.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>An error code for the error. </p>
    pub fn code(&self) -> std::option::Option<&str> {
        self.code.as_deref()
    }
    /// <p>An error message for the error.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
/// See [`BatchGetSchemaError`](crate::model::BatchGetSchemaError).
pub mod batch_get_schema_error {

    /// A builder for [`BatchGetSchemaError`](crate::model::BatchGetSchemaError).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An error name for the error.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>An error name for the error.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>An error code for the error. </p>
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        /// <p>An error code for the error. </p>
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>An error message for the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>An error message for the error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchGetSchemaError`](crate::model::BatchGetSchemaError).
        pub fn build(self) -> crate::model::BatchGetSchemaError {
            crate::model::BatchGetSchemaError {
                name: self.name,
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl BatchGetSchemaError {
    /// Creates a new builder-style object to manufacture [`BatchGetSchemaError`](crate::model::BatchGetSchemaError).
    pub fn builder() -> crate::model::batch_get_schema_error::Builder {
        crate::model::batch_get_schema_error::Builder::default()
    }
}

/// <p>The metadata of the collaboration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CollaborationSummary {
    /// <p>The identifier for the collaboration.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The ARN of the collaboration.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>A human-readable identifier provided by the collaboration owner. Display names are not unique.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The identifier used to reference members of the collaboration. Currently only supports AWS Account ID.</p>
    #[doc(hidden)]
    pub creator_account_id: std::option::Option<std::string::String>,
    /// <p>The display name of the collaboration creator.</p>
    #[doc(hidden)]
    pub creator_display_name: std::option::Option<std::string::String>,
    /// <p>The time when the collaboration was created.</p>
    #[doc(hidden)]
    pub create_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time the collaboration metadata was last updated.</p>
    #[doc(hidden)]
    pub update_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The status of a member in a collaboration.</p>
    #[doc(hidden)]
    pub member_status: std::option::Option<crate::model::MemberStatus>,
    /// <p>The identifier of a member in a collaboration.</p>
    #[doc(hidden)]
    pub membership_id: std::option::Option<std::string::String>,
    /// <p>The ARN of a member in a collaboration.</p>
    #[doc(hidden)]
    pub membership_arn: std::option::Option<std::string::String>,
}
impl CollaborationSummary {
    /// <p>The identifier for the collaboration.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The ARN of the collaboration.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>A human-readable identifier provided by the collaboration owner. Display names are not unique.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The identifier used to reference members of the collaboration. Currently only supports AWS Account ID.</p>
    pub fn creator_account_id(&self) -> std::option::Option<&str> {
        self.creator_account_id.as_deref()
    }
    /// <p>The display name of the collaboration creator.</p>
    pub fn creator_display_name(&self) -> std::option::Option<&str> {
        self.creator_display_name.as_deref()
    }
    /// <p>The time when the collaboration was created.</p>
    pub fn create_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.create_time.as_ref()
    }
    /// <p>The time the collaboration metadata was last updated.</p>
    pub fn update_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.update_time.as_ref()
    }
    /// <p>The status of a member in a collaboration.</p>
    pub fn member_status(&self) -> std::option::Option<&crate::model::MemberStatus> {
        self.member_status.as_ref()
    }
    /// <p>The identifier of a member in a collaboration.</p>
    pub fn membership_id(&self) -> std::option::Option<&str> {
        self.membership_id.as_deref()
    }
    /// <p>The ARN of a member in a collaboration.</p>
    pub fn membership_arn(&self) -> std::option::Option<&str> {
        self.membership_arn.as_deref()
    }
}
/// See [`CollaborationSummary`](crate::model::CollaborationSummary).
pub mod collaboration_summary {

    /// A builder for [`CollaborationSummary`](crate::model::CollaborationSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) creator_account_id: std::option::Option<std::string::String>,
        pub(crate) creator_display_name: std::option::Option<std::string::String>,
        pub(crate) create_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) member_status: std::option::Option<crate::model::MemberStatus>,
        pub(crate) membership_id: std::option::Option<std::string::String>,
        pub(crate) membership_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the collaboration.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier for the collaboration.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The ARN of the collaboration.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the collaboration.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>A human-readable identifier provided by the collaboration owner. Display names are not unique.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A human-readable identifier provided by the collaboration owner. Display names are not unique.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The identifier used to reference members of the collaboration. Currently only supports AWS Account ID.</p>
        pub fn creator_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.creator_account_id = Some(input.into());
            self
        }
        /// <p>The identifier used to reference members of the collaboration. Currently only supports AWS Account ID.</p>
        pub fn set_creator_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creator_account_id = input;
            self
        }
        /// <p>The display name of the collaboration creator.</p>
        pub fn creator_display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.creator_display_name = Some(input.into());
            self
        }
        /// <p>The display name of the collaboration creator.</p>
        pub fn set_creator_display_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creator_display_name = input;
            self
        }
        /// <p>The time when the collaboration was created.</p>
        pub fn create_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.create_time = Some(input);
            self
        }
        /// <p>The time when the collaboration was created.</p>
        pub fn set_create_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The time the collaboration metadata was last updated.</p>
        pub fn update_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_time = Some(input);
            self
        }
        /// <p>The time the collaboration metadata was last updated.</p>
        pub fn set_update_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.update_time = input;
            self
        }
        /// <p>The status of a member in a collaboration.</p>
        pub fn member_status(mut self, input: crate::model::MemberStatus) -> Self {
            self.member_status = Some(input);
            self
        }
        /// <p>The status of a member in a collaboration.</p>
        pub fn set_member_status(
            mut self,
            input: std::option::Option<crate::model::MemberStatus>,
        ) -> Self {
            self.member_status = input;
            self
        }
        /// <p>The identifier of a member in a collaboration.</p>
        pub fn membership_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.membership_id = Some(input.into());
            self
        }
        /// <p>The identifier of a member in a collaboration.</p>
        pub fn set_membership_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.membership_id = input;
            self
        }
        /// <p>The ARN of a member in a collaboration.</p>
        pub fn membership_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.membership_arn = Some(input.into());
            self
        }
        /// <p>The ARN of a member in a collaboration.</p>
        pub fn set_membership_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.membership_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`CollaborationSummary`](crate::model::CollaborationSummary).
        pub fn build(self) -> crate::model::CollaborationSummary {
            crate::model::CollaborationSummary {
                id: self.id,
                arn: self.arn,
                name: self.name,
                creator_account_id: self.creator_account_id,
                creator_display_name: self.creator_display_name,
                create_time: self.create_time,
                update_time: self.update_time,
                member_status: self.member_status,
                membership_id: self.membership_id,
                membership_arn: self.membership_arn,
            }
        }
    }
}
impl CollaborationSummary {
    /// Creates a new builder-style object to manufacture [`CollaborationSummary`](crate::model::CollaborationSummary).
    pub fn builder() -> crate::model::collaboration_summary::Builder {
        crate::model::collaboration_summary::Builder::default()
    }
}

/// When writing a match expression against `FilterableMemberStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let filterablememberstatus = unimplemented!();
/// match filterablememberstatus {
///     FilterableMemberStatus::Active => { /* ... */ },
///     FilterableMemberStatus::Invited => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `filterablememberstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FilterableMemberStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FilterableMemberStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FilterableMemberStatus::NewFeature` is defined.
/// Specifically, when `filterablememberstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FilterableMemberStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FilterableMemberStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Invited,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FilterableMemberStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => FilterableMemberStatus::Active,
            "INVITED" => FilterableMemberStatus::Invited,
            other => {
                FilterableMemberStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for FilterableMemberStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FilterableMemberStatus::from(s))
    }
}
impl FilterableMemberStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FilterableMemberStatus::Active => "ACTIVE",
            FilterableMemberStatus::Invited => "INVITED",
            FilterableMemberStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "INVITED"]
    }
}
impl AsRef<str> for FilterableMemberStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The multi-party data share environment. The collaboration contains metadata about its purpose and participants.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Collaboration {
    /// <p>The unique ID for the collaboration.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The unique ARN for the collaboration.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>A human-readable identifier provided by the collaboration owner. Display names are not unique.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A description of the collaboration provided by the collaboration owner.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The identifier used to reference members of the collaboration. Currently only supports AWS account ID.</p>
    #[doc(hidden)]
    pub creator_account_id: std::option::Option<std::string::String>,
    /// <p>A display name of the collaboration creator.</p>
    #[doc(hidden)]
    pub creator_display_name: std::option::Option<std::string::String>,
    /// <p>The time when the collaboration was created.</p>
    #[doc(hidden)]
    pub create_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time the collaboration metadata was last updated.</p>
    #[doc(hidden)]
    pub update_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The status of a member in a collaboration.</p>
    #[doc(hidden)]
    pub member_status: std::option::Option<crate::model::MemberStatus>,
    /// <p>The unique ID for your membership within the collaboration.</p>
    #[doc(hidden)]
    pub membership_id: std::option::Option<std::string::String>,
    /// <p>The unique ARN for your membership within the collaboration.</p>
    #[doc(hidden)]
    pub membership_arn: std::option::Option<std::string::String>,
    /// <p>The settings for client-side encryption for cryptographic computing.</p>
    #[doc(hidden)]
    pub data_encryption_metadata: std::option::Option<crate::model::DataEncryptionMetadata>,
    /// <p>An indicator as to whether query logging has been enabled or disabled for the collaboration.</p>
    #[doc(hidden)]
    pub query_log_status: std::option::Option<crate::model::CollaborationQueryLogStatus>,
}
impl Collaboration {
    /// <p>The unique ID for the collaboration.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The unique ARN for the collaboration.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>A human-readable identifier provided by the collaboration owner. Display names are not unique.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A description of the collaboration provided by the collaboration owner.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The identifier used to reference members of the collaboration. Currently only supports AWS account ID.</p>
    pub fn creator_account_id(&self) -> std::option::Option<&str> {
        self.creator_account_id.as_deref()
    }
    /// <p>A display name of the collaboration creator.</p>
    pub fn creator_display_name(&self) -> std::option::Option<&str> {
        self.creator_display_name.as_deref()
    }
    /// <p>The time when the collaboration was created.</p>
    pub fn create_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.create_time.as_ref()
    }
    /// <p>The time the collaboration metadata was last updated.</p>
    pub fn update_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.update_time.as_ref()
    }
    /// <p>The status of a member in a collaboration.</p>
    pub fn member_status(&self) -> std::option::Option<&crate::model::MemberStatus> {
        self.member_status.as_ref()
    }
    /// <p>The unique ID for your membership within the collaboration.</p>
    pub fn membership_id(&self) -> std::option::Option<&str> {
        self.membership_id.as_deref()
    }
    /// <p>The unique ARN for your membership within the collaboration.</p>
    pub fn membership_arn(&self) -> std::option::Option<&str> {
        self.membership_arn.as_deref()
    }
    /// <p>The settings for client-side encryption for cryptographic computing.</p>
    pub fn data_encryption_metadata(
        &self,
    ) -> std::option::Option<&crate::model::DataEncryptionMetadata> {
        self.data_encryption_metadata.as_ref()
    }
    /// <p>An indicator as to whether query logging has been enabled or disabled for the collaboration.</p>
    pub fn query_log_status(
        &self,
    ) -> std::option::Option<&crate::model::CollaborationQueryLogStatus> {
        self.query_log_status.as_ref()
    }
}
/// See [`Collaboration`](crate::model::Collaboration).
pub mod collaboration {

    /// A builder for [`Collaboration`](crate::model::Collaboration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) creator_account_id: std::option::Option<std::string::String>,
        pub(crate) creator_display_name: std::option::Option<std::string::String>,
        pub(crate) create_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) member_status: std::option::Option<crate::model::MemberStatus>,
        pub(crate) membership_id: std::option::Option<std::string::String>,
        pub(crate) membership_arn: std::option::Option<std::string::String>,
        pub(crate) data_encryption_metadata:
            std::option::Option<crate::model::DataEncryptionMetadata>,
        pub(crate) query_log_status: std::option::Option<crate::model::CollaborationQueryLogStatus>,
    }
    impl Builder {
        /// <p>The unique ID for the collaboration.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique ID for the collaboration.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The unique ARN for the collaboration.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The unique ARN for the collaboration.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>A human-readable identifier provided by the collaboration owner. Display names are not unique.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A human-readable identifier provided by the collaboration owner. Display names are not unique.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A description of the collaboration provided by the collaboration owner.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the collaboration provided by the collaboration owner.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The identifier used to reference members of the collaboration. Currently only supports AWS account ID.</p>
        pub fn creator_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.creator_account_id = Some(input.into());
            self
        }
        /// <p>The identifier used to reference members of the collaboration. Currently only supports AWS account ID.</p>
        pub fn set_creator_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creator_account_id = input;
            self
        }
        /// <p>A display name of the collaboration creator.</p>
        pub fn creator_display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.creator_display_name = Some(input.into());
            self
        }
        /// <p>A display name of the collaboration creator.</p>
        pub fn set_creator_display_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creator_display_name = input;
            self
        }
        /// <p>The time when the collaboration was created.</p>
        pub fn create_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.create_time = Some(input);
            self
        }
        /// <p>The time when the collaboration was created.</p>
        pub fn set_create_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The time the collaboration metadata was last updated.</p>
        pub fn update_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_time = Some(input);
            self
        }
        /// <p>The time the collaboration metadata was last updated.</p>
        pub fn set_update_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.update_time = input;
            self
        }
        /// <p>The status of a member in a collaboration.</p>
        pub fn member_status(mut self, input: crate::model::MemberStatus) -> Self {
            self.member_status = Some(input);
            self
        }
        /// <p>The status of a member in a collaboration.</p>
        pub fn set_member_status(
            mut self,
            input: std::option::Option<crate::model::MemberStatus>,
        ) -> Self {
            self.member_status = input;
            self
        }
        /// <p>The unique ID for your membership within the collaboration.</p>
        pub fn membership_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.membership_id = Some(input.into());
            self
        }
        /// <p>The unique ID for your membership within the collaboration.</p>
        pub fn set_membership_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.membership_id = input;
            self
        }
        /// <p>The unique ARN for your membership within the collaboration.</p>
        pub fn membership_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.membership_arn = Some(input.into());
            self
        }
        /// <p>The unique ARN for your membership within the collaboration.</p>
        pub fn set_membership_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.membership_arn = input;
            self
        }
        /// <p>The settings for client-side encryption for cryptographic computing.</p>
        pub fn data_encryption_metadata(
            mut self,
            input: crate::model::DataEncryptionMetadata,
        ) -> Self {
            self.data_encryption_metadata = Some(input);
            self
        }
        /// <p>The settings for client-side encryption for cryptographic computing.</p>
        pub fn set_data_encryption_metadata(
            mut self,
            input: std::option::Option<crate::model::DataEncryptionMetadata>,
        ) -> Self {
            self.data_encryption_metadata = input;
            self
        }
        /// <p>An indicator as to whether query logging has been enabled or disabled for the collaboration.</p>
        pub fn query_log_status(
            mut self,
            input: crate::model::CollaborationQueryLogStatus,
        ) -> Self {
            self.query_log_status = Some(input);
            self
        }
        /// <p>An indicator as to whether query logging has been enabled or disabled for the collaboration.</p>
        pub fn set_query_log_status(
            mut self,
            input: std::option::Option<crate::model::CollaborationQueryLogStatus>,
        ) -> Self {
            self.query_log_status = input;
            self
        }
        /// Consumes the builder and constructs a [`Collaboration`](crate::model::Collaboration).
        pub fn build(self) -> crate::model::Collaboration {
            crate::model::Collaboration {
                id: self.id,
                arn: self.arn,
                name: self.name,
                description: self.description,
                creator_account_id: self.creator_account_id,
                creator_display_name: self.creator_display_name,
                create_time: self.create_time,
                update_time: self.update_time,
                member_status: self.member_status,
                membership_id: self.membership_id,
                membership_arn: self.membership_arn,
                data_encryption_metadata: self.data_encryption_metadata,
                query_log_status: self.query_log_status,
            }
        }
    }
}
impl Collaboration {
    /// Creates a new builder-style object to manufacture [`Collaboration`](crate::model::Collaboration).
    pub fn builder() -> crate::model::collaboration::Builder {
        crate::model::collaboration::Builder::default()
    }
}

/// When writing a match expression against `CollaborationQueryLogStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let collaborationquerylogstatus = unimplemented!();
/// match collaborationquerylogstatus {
///     CollaborationQueryLogStatus::Disabled => { /* ... */ },
///     CollaborationQueryLogStatus::Enabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `collaborationquerylogstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CollaborationQueryLogStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CollaborationQueryLogStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CollaborationQueryLogStatus::NewFeature` is defined.
/// Specifically, when `collaborationquerylogstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CollaborationQueryLogStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CollaborationQueryLogStatus {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CollaborationQueryLogStatus {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => CollaborationQueryLogStatus::Disabled,
            "ENABLED" => CollaborationQueryLogStatus::Enabled,
            other => CollaborationQueryLogStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for CollaborationQueryLogStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CollaborationQueryLogStatus::from(s))
    }
}
impl CollaborationQueryLogStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CollaborationQueryLogStatus::Disabled => "DISABLED",
            CollaborationQueryLogStatus::Enabled => "ENABLED",
            CollaborationQueryLogStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for CollaborationQueryLogStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The settings for client-side encryption for cryptographic computing.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataEncryptionMetadata {
    /// <p>Indicates whether encrypted tables can contain cleartext data (true) or are to cryptographically process every column (false).</p>
    #[doc(hidden)]
    pub allow_cleartext: std::option::Option<bool>,
    /// <p>Indicates whether Fingerprint columns can contain duplicate entries (true) or are to contain only non-repeated values (false).</p>
    #[doc(hidden)]
    pub allow_duplicates: std::option::Option<bool>,
    /// <p>Indicates whether Fingerprint columns can be joined on any other Fingerprint column with a different name (true) or can only be joined on Fingerprint columns of the same name (false).</p>
    #[doc(hidden)]
    pub allow_joins_on_columns_with_different_names: std::option::Option<bool>,
    /// <p>Indicates whether NULL values are to be copied as NULL to encrypted tables (true) or cryptographically processed (false).</p>
    #[doc(hidden)]
    pub preserve_nulls: std::option::Option<bool>,
}
impl DataEncryptionMetadata {
    /// <p>Indicates whether encrypted tables can contain cleartext data (true) or are to cryptographically process every column (false).</p>
    pub fn allow_cleartext(&self) -> std::option::Option<bool> {
        self.allow_cleartext
    }
    /// <p>Indicates whether Fingerprint columns can contain duplicate entries (true) or are to contain only non-repeated values (false).</p>
    pub fn allow_duplicates(&self) -> std::option::Option<bool> {
        self.allow_duplicates
    }
    /// <p>Indicates whether Fingerprint columns can be joined on any other Fingerprint column with a different name (true) or can only be joined on Fingerprint columns of the same name (false).</p>
    pub fn allow_joins_on_columns_with_different_names(&self) -> std::option::Option<bool> {
        self.allow_joins_on_columns_with_different_names
    }
    /// <p>Indicates whether NULL values are to be copied as NULL to encrypted tables (true) or cryptographically processed (false).</p>
    pub fn preserve_nulls(&self) -> std::option::Option<bool> {
        self.preserve_nulls
    }
}
/// See [`DataEncryptionMetadata`](crate::model::DataEncryptionMetadata).
pub mod data_encryption_metadata {

    /// A builder for [`DataEncryptionMetadata`](crate::model::DataEncryptionMetadata).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) allow_cleartext: std::option::Option<bool>,
        pub(crate) allow_duplicates: std::option::Option<bool>,
        pub(crate) allow_joins_on_columns_with_different_names: std::option::Option<bool>,
        pub(crate) preserve_nulls: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Indicates whether encrypted tables can contain cleartext data (true) or are to cryptographically process every column (false).</p>
        pub fn allow_cleartext(mut self, input: bool) -> Self {
            self.allow_cleartext = Some(input);
            self
        }
        /// <p>Indicates whether encrypted tables can contain cleartext data (true) or are to cryptographically process every column (false).</p>
        pub fn set_allow_cleartext(mut self, input: std::option::Option<bool>) -> Self {
            self.allow_cleartext = input;
            self
        }
        /// <p>Indicates whether Fingerprint columns can contain duplicate entries (true) or are to contain only non-repeated values (false).</p>
        pub fn allow_duplicates(mut self, input: bool) -> Self {
            self.allow_duplicates = Some(input);
            self
        }
        /// <p>Indicates whether Fingerprint columns can contain duplicate entries (true) or are to contain only non-repeated values (false).</p>
        pub fn set_allow_duplicates(mut self, input: std::option::Option<bool>) -> Self {
            self.allow_duplicates = input;
            self
        }
        /// <p>Indicates whether Fingerprint columns can be joined on any other Fingerprint column with a different name (true) or can only be joined on Fingerprint columns of the same name (false).</p>
        pub fn allow_joins_on_columns_with_different_names(mut self, input: bool) -> Self {
            self.allow_joins_on_columns_with_different_names = Some(input);
            self
        }
        /// <p>Indicates whether Fingerprint columns can be joined on any other Fingerprint column with a different name (true) or can only be joined on Fingerprint columns of the same name (false).</p>
        pub fn set_allow_joins_on_columns_with_different_names(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.allow_joins_on_columns_with_different_names = input;
            self
        }
        /// <p>Indicates whether NULL values are to be copied as NULL to encrypted tables (true) or cryptographically processed (false).</p>
        pub fn preserve_nulls(mut self, input: bool) -> Self {
            self.preserve_nulls = Some(input);
            self
        }
        /// <p>Indicates whether NULL values are to be copied as NULL to encrypted tables (true) or cryptographically processed (false).</p>
        pub fn set_preserve_nulls(mut self, input: std::option::Option<bool>) -> Self {
            self.preserve_nulls = input;
            self
        }
        /// Consumes the builder and constructs a [`DataEncryptionMetadata`](crate::model::DataEncryptionMetadata).
        pub fn build(self) -> crate::model::DataEncryptionMetadata {
            crate::model::DataEncryptionMetadata {
                allow_cleartext: self.allow_cleartext,
                allow_duplicates: self.allow_duplicates,
                allow_joins_on_columns_with_different_names: self
                    .allow_joins_on_columns_with_different_names,
                preserve_nulls: self.preserve_nulls,
            }
        }
    }
}
impl DataEncryptionMetadata {
    /// Creates a new builder-style object to manufacture [`DataEncryptionMetadata`](crate::model::DataEncryptionMetadata).
    pub fn builder() -> crate::model::data_encryption_metadata::Builder {
        crate::model::data_encryption_metadata::Builder::default()
    }
}

/// <p>Basic metadata used to construct a new member.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MemberSpecification {
    /// <p>The identifier used to reference members of the collaboration. Currently only supports AWS Account ID.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The abilities granted to the collaboration member.</p>
    #[doc(hidden)]
    pub member_abilities: std::option::Option<std::vec::Vec<crate::model::MemberAbility>>,
    /// <p>The member's display name.</p>
    #[doc(hidden)]
    pub display_name: std::option::Option<std::string::String>,
}
impl MemberSpecification {
    /// <p>The identifier used to reference members of the collaboration. Currently only supports AWS Account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The abilities granted to the collaboration member.</p>
    pub fn member_abilities(&self) -> std::option::Option<&[crate::model::MemberAbility]> {
        self.member_abilities.as_deref()
    }
    /// <p>The member's display name.</p>
    pub fn display_name(&self) -> std::option::Option<&str> {
        self.display_name.as_deref()
    }
}
/// See [`MemberSpecification`](crate::model::MemberSpecification).
pub mod member_specification {

    /// A builder for [`MemberSpecification`](crate::model::MemberSpecification).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) member_abilities:
            std::option::Option<std::vec::Vec<crate::model::MemberAbility>>,
        pub(crate) display_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier used to reference members of the collaboration. Currently only supports AWS Account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The identifier used to reference members of the collaboration. Currently only supports AWS Account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// Appends an item to `member_abilities`.
        ///
        /// To override the contents of this collection use [`set_member_abilities`](Self::set_member_abilities).
        ///
        /// <p>The abilities granted to the collaboration member.</p>
        pub fn member_abilities(mut self, input: crate::model::MemberAbility) -> Self {
            let mut v = self.member_abilities.unwrap_or_default();
            v.push(input);
            self.member_abilities = Some(v);
            self
        }
        /// <p>The abilities granted to the collaboration member.</p>
        pub fn set_member_abilities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MemberAbility>>,
        ) -> Self {
            self.member_abilities = input;
            self
        }
        /// <p>The member's display name.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        /// <p>The member's display name.</p>
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// Consumes the builder and constructs a [`MemberSpecification`](crate::model::MemberSpecification).
        pub fn build(self) -> crate::model::MemberSpecification {
            crate::model::MemberSpecification {
                account_id: self.account_id,
                member_abilities: self.member_abilities,
                display_name: self.display_name,
            }
        }
    }
}
impl MemberSpecification {
    /// Creates a new builder-style object to manufacture [`MemberSpecification`](crate::model::MemberSpecification).
    pub fn builder() -> crate::model::member_specification::Builder {
        crate::model::member_specification::Builder::default()
    }
}
