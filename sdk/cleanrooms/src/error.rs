// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Error type for the `UpdateProtectedQuery` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateProtectedQueryError {
    /// Kind of error that occurred.
                    pub kind: UpdateProtectedQueryErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateProtectedQueryError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: UpdateProtectedQueryErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `UpdateProtectedQuery` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateProtectedQueryErrorKind {
    /// <p>Caller does not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Updating or deleting a resource can cause an inconsistent state.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>Unexpected error during processing of request.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Request references a resource which does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Request was denied due to request throttling.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The input fails to satisfy the specified constraints.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for UpdateProtectedQueryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateProtectedQueryErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateProtectedQueryErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateProtectedQueryErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateProtectedQueryErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateProtectedQueryErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateProtectedQueryErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateProtectedQueryErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateProtectedQueryError {
    fn code(&self) -> Option<&str> {
        UpdateProtectedQueryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateProtectedQueryError {
    /// Creates a new `UpdateProtectedQueryError`.
                    pub fn new(kind: UpdateProtectedQueryErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `UpdateProtectedQueryError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: UpdateProtectedQueryErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `UpdateProtectedQueryError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: UpdateProtectedQueryErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `UpdateProtectedQueryErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UpdateProtectedQueryErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `UpdateProtectedQueryErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateProtectedQueryErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `UpdateProtectedQueryErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, UpdateProtectedQueryErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `UpdateProtectedQueryErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateProtectedQueryErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `UpdateProtectedQueryErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateProtectedQueryErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `UpdateProtectedQueryErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UpdateProtectedQueryErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UpdateProtectedQueryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateProtectedQueryErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            UpdateProtectedQueryErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            UpdateProtectedQueryErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            UpdateProtectedQueryErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            UpdateProtectedQueryErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            UpdateProtectedQueryErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            UpdateProtectedQueryErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// <p>The input fails to satisfy the specified constraints.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ValidationException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>A reason code for the exception.</p>
    #[doc(hidden)]
    pub reason: std::option::Option<crate::model::ValidationExceptionReason>,
    /// <p>Validation errors for specific input parameters.</p>
    #[doc(hidden)]
    pub field_list: std::option::Option<std::vec::Vec<crate::model::ValidationExceptionField>>,
}
impl ValidationException {
    /// <p>A reason code for the exception.</p>
    pub fn reason(&self) -> std::option::Option<& crate::model::ValidationExceptionReason> {
        self.reason.as_ref()
    }
    /// <p>Validation errors for specific input parameters.</p>
    pub fn field_list(&self) -> std::option::Option<& [crate::model::ValidationExceptionField]> {
        self.field_list.as_deref()
    }
}
impl ValidationException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ValidationException")?;
        if let Some(inner_1) = &self.message {
             {
                write!(f, ": {}", inner_1)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ValidationException {}
/// See [`ValidationException`](crate::error::ValidationException).
pub mod validation_exception {
    
    /// A builder for [`ValidationException`](crate::error::ValidationException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) reason: std::option::Option<crate::model::ValidationExceptionReason>,
        pub(crate) field_list: std::option::Option<std::vec::Vec<crate::model::ValidationExceptionField>>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// <p>A reason code for the exception.</p>
        pub fn reason(mut self, input: crate::model::ValidationExceptionReason) -> Self {
            self.reason = Some(input);
            self
        }
        /// <p>A reason code for the exception.</p>
        pub fn set_reason(mut self, input: std::option::Option<crate::model::ValidationExceptionReason>) -> Self {
            self.reason = input; self
        }
        /// Appends an item to `field_list`.
        ///
        /// To override the contents of this collection use [`set_field_list`](Self::set_field_list).
        ///
        /// <p>Validation errors for specific input parameters.</p>
        pub fn field_list(mut self, input: crate::model::ValidationExceptionField) -> Self {
            let mut v = self.field_list.unwrap_or_default();
                            v.push(input);
                            self.field_list = Some(v);
                            self
        }
        /// <p>Validation errors for specific input parameters.</p>
        pub fn set_field_list(mut self, input: std::option::Option<std::vec::Vec<crate::model::ValidationExceptionField>>) -> Self {
            self.field_list = input; self
        }
        /// Consumes the builder and constructs a [`ValidationException`](crate::error::ValidationException).
        pub fn build(self) -> crate::error::ValidationException {
            crate::error::ValidationException {
                message: self.message
                ,
                reason: self.reason
                ,
                field_list: self.field_list
                ,
            }
        }
    }
    
    
}
impl ValidationException {
    /// Creates a new builder-style object to manufacture [`ValidationException`](crate::error::ValidationException).
    pub fn builder() -> crate::error::validation_exception::Builder {
        crate::error::validation_exception::Builder::default()
    }
}

/// <p>Request was denied due to request throttling.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ThrottlingException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ThrottlingException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ThrottlingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ThrottlingException")?;
        if let Some(inner_2) = &self.message {
             {
                write!(f, ": {}", inner_2)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ThrottlingException {}
/// See [`ThrottlingException`](crate::error::ThrottlingException).
pub mod throttling_exception {
    
    /// A builder for [`ThrottlingException`](crate::error::ThrottlingException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`ThrottlingException`](crate::error::ThrottlingException).
        pub fn build(self) -> crate::error::ThrottlingException {
            crate::error::ThrottlingException {
                message: self.message
                ,
            }
        }
    }
    
    
}
impl ThrottlingException {
    /// Creates a new builder-style object to manufacture [`ThrottlingException`](crate::error::ThrottlingException).
    pub fn builder() -> crate::error::throttling_exception::Builder {
        crate::error::throttling_exception::Builder::default()
    }
}

/// <p>Request references a resource which does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceNotFoundException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Id of the missing resource.</p>
    #[doc(hidden)]
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The type of the missing resource.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<crate::model::ResourceType>,
}
impl ResourceNotFoundException {
    /// <p>The Id of the missing resource.</p>
    pub fn resource_id(&self) -> std::option::Option<& str> {
        self.resource_id.as_deref()
    }
    /// <p>The type of the missing resource.</p>
    pub fn resource_type(&self) -> std::option::Option<& crate::model::ResourceType> {
        self.resource_type.as_ref()
    }
}
impl ResourceNotFoundException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundException")?;
        if let Some(inner_3) = &self.message {
             {
                write!(f, ": {}", inner_3)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundException {}
/// See [`ResourceNotFoundException`](crate::error::ResourceNotFoundException).
pub mod resource_not_found_exception {
    
    /// A builder for [`ResourceNotFoundException`](crate::error::ResourceNotFoundException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<crate::model::ResourceType>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// <p>The Id of the missing resource.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        /// <p>The Id of the missing resource.</p>
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input; self
        }
        /// <p>The type of the missing resource.</p>
        pub fn resource_type(mut self, input: crate::model::ResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        /// <p>The type of the missing resource.</p>
        pub fn set_resource_type(mut self, input: std::option::Option<crate::model::ResourceType>) -> Self {
            self.resource_type = input; self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException).
        pub fn build(self) -> crate::error::ResourceNotFoundException {
            crate::error::ResourceNotFoundException {
                message: self.message
                ,
                resource_id: self.resource_id
                ,
                resource_type: self.resource_type
                ,
            }
        }
    }
    
    
}
impl ResourceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundException`](crate::error::ResourceNotFoundException).
    pub fn builder() -> crate::error::resource_not_found_exception::Builder {
        crate::error::resource_not_found_exception::Builder::default()
    }
}

/// <p>Unexpected error during processing of request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InternalServerException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl InternalServerException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for InternalServerException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServerException")?;
        if let Some(inner_4) = &self.message {
             {
                write!(f, ": {}", inner_4)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InternalServerException {}
/// See [`InternalServerException`](crate::error::InternalServerException).
pub mod internal_server_exception {
    
    /// A builder for [`InternalServerException`](crate::error::InternalServerException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`InternalServerException`](crate::error::InternalServerException).
        pub fn build(self) -> crate::error::InternalServerException {
            crate::error::InternalServerException {
                message: self.message
                ,
            }
        }
    }
    
    
}
impl InternalServerException {
    /// Creates a new builder-style object to manufacture [`InternalServerException`](crate::error::InternalServerException).
    pub fn builder() -> crate::error::internal_server_exception::Builder {
        crate::error::internal_server_exception::Builder::default()
    }
}

/// <p>Updating or deleting a resource can cause an inconsistent state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConflictException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The ID of the conflicting resource.</p>
    #[doc(hidden)]
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The type of the conflicting resource.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<crate::model::ResourceType>,
    /// <p>A reason code for the exception.</p>
    #[doc(hidden)]
    pub reason: std::option::Option<crate::model::ConflictExceptionReason>,
}
impl ConflictException {
    /// <p>The ID of the conflicting resource.</p>
    pub fn resource_id(&self) -> std::option::Option<& str> {
        self.resource_id.as_deref()
    }
    /// <p>The type of the conflicting resource.</p>
    pub fn resource_type(&self) -> std::option::Option<& crate::model::ResourceType> {
        self.resource_type.as_ref()
    }
    /// <p>A reason code for the exception.</p>
    pub fn reason(&self) -> std::option::Option<& crate::model::ConflictExceptionReason> {
        self.reason.as_ref()
    }
}
impl ConflictException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_5) = &self.message {
             {
                write!(f, ": {}", inner_5)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
/// See [`ConflictException`](crate::error::ConflictException).
pub mod conflict_exception {
    
    /// A builder for [`ConflictException`](crate::error::ConflictException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<crate::model::ResourceType>,
        pub(crate) reason: std::option::Option<crate::model::ConflictExceptionReason>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// <p>The ID of the conflicting resource.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        /// <p>The ID of the conflicting resource.</p>
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input; self
        }
        /// <p>The type of the conflicting resource.</p>
        pub fn resource_type(mut self, input: crate::model::ResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        /// <p>The type of the conflicting resource.</p>
        pub fn set_resource_type(mut self, input: std::option::Option<crate::model::ResourceType>) -> Self {
            self.resource_type = input; self
        }
        /// <p>A reason code for the exception.</p>
        pub fn reason(mut self, input: crate::model::ConflictExceptionReason) -> Self {
            self.reason = Some(input);
            self
        }
        /// <p>A reason code for the exception.</p>
        pub fn set_reason(mut self, input: std::option::Option<crate::model::ConflictExceptionReason>) -> Self {
            self.reason = input; self
        }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException).
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                message: self.message
                ,
                resource_id: self.resource_id
                ,
                resource_type: self.resource_type
                ,
                reason: self.reason
                ,
            }
        }
    }
    
    
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException).
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}

/// <p>Caller does not have sufficient access to perform this action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AccessDeniedException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>A reason code for the exception.</p>
    #[doc(hidden)]
    pub reason: std::option::Option<crate::model::AccessDeniedExceptionReason>,
}
impl AccessDeniedException {
    /// <p>A reason code for the exception.</p>
    pub fn reason(&self) -> std::option::Option<& crate::model::AccessDeniedExceptionReason> {
        self.reason.as_ref()
    }
}
impl AccessDeniedException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccessDeniedException")?;
        if let Some(inner_6) = &self.message {
             {
                write!(f, ": {}", inner_6)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for AccessDeniedException {}
/// See [`AccessDeniedException`](crate::error::AccessDeniedException).
pub mod access_denied_exception {
    
    /// A builder for [`AccessDeniedException`](crate::error::AccessDeniedException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) reason: std::option::Option<crate::model::AccessDeniedExceptionReason>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// <p>A reason code for the exception.</p>
        pub fn reason(mut self, input: crate::model::AccessDeniedExceptionReason) -> Self {
            self.reason = Some(input);
            self
        }
        /// <p>A reason code for the exception.</p>
        pub fn set_reason(mut self, input: std::option::Option<crate::model::AccessDeniedExceptionReason>) -> Self {
            self.reason = input; self
        }
        /// Consumes the builder and constructs a [`AccessDeniedException`](crate::error::AccessDeniedException).
        pub fn build(self) -> crate::error::AccessDeniedException {
            crate::error::AccessDeniedException {
                message: self.message
                ,
                reason: self.reason
                ,
            }
        }
    }
    
    
}
impl AccessDeniedException {
    /// Creates a new builder-style object to manufacture [`AccessDeniedException`](crate::error::AccessDeniedException).
    pub fn builder() -> crate::error::access_denied_exception::Builder {
        crate::error::access_denied_exception::Builder::default()
    }
}

/// Error type for the `StartProtectedQuery` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartProtectedQueryError {
    /// Kind of error that occurred.
                    pub kind: StartProtectedQueryErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for StartProtectedQueryError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: StartProtectedQueryErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `StartProtectedQuery` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartProtectedQueryErrorKind {
    /// <p>Caller does not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Unexpected error during processing of request.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Request references a resource which does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Request denied because service quota has been exceeded.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>Request was denied due to request throttling.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The input fails to satisfy the specified constraints.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for StartProtectedQueryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartProtectedQueryErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            StartProtectedQueryErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            StartProtectedQueryErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            StartProtectedQueryErrorKind::ServiceQuotaExceededException(_inner) =>
            _inner.fmt(f)
            ,
            StartProtectedQueryErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            StartProtectedQueryErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            StartProtectedQueryErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for StartProtectedQueryError {
    fn code(&self) -> Option<&str> {
        StartProtectedQueryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartProtectedQueryError {
    /// Creates a new `StartProtectedQueryError`.
                    pub fn new(kind: StartProtectedQueryErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `StartProtectedQueryError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: StartProtectedQueryErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `StartProtectedQueryError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: StartProtectedQueryErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `StartProtectedQueryErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, StartProtectedQueryErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `StartProtectedQueryErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, StartProtectedQueryErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `StartProtectedQueryErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, StartProtectedQueryErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `StartProtectedQueryErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(&self.kind, StartProtectedQueryErrorKind::ServiceQuotaExceededException(_))
    }
    /// Returns `true` if the error kind is `StartProtectedQueryErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, StartProtectedQueryErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `StartProtectedQueryErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, StartProtectedQueryErrorKind::ValidationException(_))
    }
}
impl std::error::Error for StartProtectedQueryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartProtectedQueryErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            StartProtectedQueryErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            StartProtectedQueryErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            StartProtectedQueryErrorKind::ServiceQuotaExceededException(_inner) =>
            Some(_inner)
            ,
            StartProtectedQueryErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            StartProtectedQueryErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            StartProtectedQueryErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// <p>Request denied because service quota has been exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServiceQuotaExceededException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The name of the quota.</p>
    #[doc(hidden)]
    pub quota_name: std::option::Option<std::string::String>,
    /// <p>The value of the quota.</p>
    #[doc(hidden)]
    pub quota_value: std::option::Option<f64>,
}
impl ServiceQuotaExceededException {
    /// <p>The name of the quota.</p>
    pub fn quota_name(&self) -> std::option::Option<& str> {
        self.quota_name.as_deref()
    }
    /// <p>The value of the quota.</p>
    pub fn quota_value(&self) -> std::option::Option<f64> {
        self.quota_value
    }
}
impl ServiceQuotaExceededException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ServiceQuotaExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceQuotaExceededException")?;
        if let Some(inner_7) = &self.message {
             {
                write!(f, ": {}", inner_7)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ServiceQuotaExceededException {}
/// See [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException).
pub mod service_quota_exceeded_exception {
    
    /// A builder for [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) quota_name: std::option::Option<std::string::String>,
        pub(crate) quota_value: std::option::Option<f64>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// <p>The name of the quota.</p>
        pub fn quota_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.quota_name = Some(input.into());
            self
        }
        /// <p>The name of the quota.</p>
        pub fn set_quota_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.quota_name = input; self
        }
        /// <p>The value of the quota.</p>
        pub fn quota_value(mut self, input: f64) -> Self {
            self.quota_value = Some(input);
            self
        }
        /// <p>The value of the quota.</p>
        pub fn set_quota_value(mut self, input: std::option::Option<f64>) -> Self {
            self.quota_value = input; self
        }
        /// Consumes the builder and constructs a [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException).
        pub fn build(self) -> crate::error::ServiceQuotaExceededException {
            crate::error::ServiceQuotaExceededException {
                message: self.message
                ,
                quota_name: self.quota_name
                ,
                quota_value: self.quota_value
                ,
            }
        }
    }
    
    
}
impl ServiceQuotaExceededException {
    /// Creates a new builder-style object to manufacture [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException).
    pub fn builder() -> crate::error::service_quota_exceeded_exception::Builder {
        crate::error::service_quota_exceeded_exception::Builder::default()
    }
}

/// Error type for the `ListProtectedQueries` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListProtectedQueriesError {
    /// Kind of error that occurred.
                    pub kind: ListProtectedQueriesErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListProtectedQueriesError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListProtectedQueriesErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListProtectedQueries` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListProtectedQueriesErrorKind {
    /// <p>Caller does not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Unexpected error during processing of request.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Request was denied due to request throttling.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The input fails to satisfy the specified constraints.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListProtectedQueriesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListProtectedQueriesErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListProtectedQueriesErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            ListProtectedQueriesErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            ListProtectedQueriesErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            ListProtectedQueriesErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListProtectedQueriesError {
    fn code(&self) -> Option<&str> {
        ListProtectedQueriesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListProtectedQueriesError {
    /// Creates a new `ListProtectedQueriesError`.
                    pub fn new(kind: ListProtectedQueriesErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListProtectedQueriesError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListProtectedQueriesErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListProtectedQueriesError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListProtectedQueriesErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListProtectedQueriesErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListProtectedQueriesErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListProtectedQueriesErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListProtectedQueriesErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `ListProtectedQueriesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListProtectedQueriesErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListProtectedQueriesErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListProtectedQueriesErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListProtectedQueriesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListProtectedQueriesErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListProtectedQueriesErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            ListProtectedQueriesErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            ListProtectedQueriesErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            ListProtectedQueriesErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetProtectedQuery` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetProtectedQueryError {
    /// Kind of error that occurred.
                    pub kind: GetProtectedQueryErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetProtectedQueryError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetProtectedQueryErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetProtectedQuery` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetProtectedQueryErrorKind {
    /// <p>Caller does not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Unexpected error during processing of request.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Request references a resource which does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Request was denied due to request throttling.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The input fails to satisfy the specified constraints.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetProtectedQueryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetProtectedQueryErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            GetProtectedQueryErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            GetProtectedQueryErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetProtectedQueryErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            GetProtectedQueryErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            GetProtectedQueryErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetProtectedQueryError {
    fn code(&self) -> Option<&str> {
        GetProtectedQueryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetProtectedQueryError {
    /// Creates a new `GetProtectedQueryError`.
                    pub fn new(kind: GetProtectedQueryErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetProtectedQueryError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetProtectedQueryErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetProtectedQueryError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetProtectedQueryErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetProtectedQueryErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetProtectedQueryErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetProtectedQueryErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, GetProtectedQueryErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `GetProtectedQueryErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetProtectedQueryErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetProtectedQueryErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetProtectedQueryErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `GetProtectedQueryErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, GetProtectedQueryErrorKind::ValidationException(_))
    }
}
impl std::error::Error for GetProtectedQueryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetProtectedQueryErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            GetProtectedQueryErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            GetProtectedQueryErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            GetProtectedQueryErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            GetProtectedQueryErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            GetProtectedQueryErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListMemberships` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListMembershipsError {
    /// Kind of error that occurred.
                    pub kind: ListMembershipsErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListMembershipsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListMembershipsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListMemberships` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListMembershipsErrorKind {
    /// <p>Caller does not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Unexpected error during processing of request.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Request was denied due to request throttling.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The input fails to satisfy the specified constraints.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListMembershipsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListMembershipsErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListMembershipsErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            ListMembershipsErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            ListMembershipsErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            ListMembershipsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListMembershipsError {
    fn code(&self) -> Option<&str> {
        ListMembershipsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListMembershipsError {
    /// Creates a new `ListMembershipsError`.
                    pub fn new(kind: ListMembershipsErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListMembershipsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListMembershipsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListMembershipsError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListMembershipsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListMembershipsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListMembershipsErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListMembershipsErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListMembershipsErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `ListMembershipsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListMembershipsErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListMembershipsErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListMembershipsErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListMembershipsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListMembershipsErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListMembershipsErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            ListMembershipsErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            ListMembershipsErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            ListMembershipsErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `CreateMembership` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateMembershipError {
    /// Kind of error that occurred.
                    pub kind: CreateMembershipErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for CreateMembershipError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: CreateMembershipErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `CreateMembership` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateMembershipErrorKind {
    /// <p>Caller does not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Updating or deleting a resource can cause an inconsistent state.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>Unexpected error during processing of request.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Request references a resource which does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Request denied because service quota has been exceeded.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>Request was denied due to request throttling.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The input fails to satisfy the specified constraints.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for CreateMembershipError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateMembershipErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            CreateMembershipErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            CreateMembershipErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            CreateMembershipErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            CreateMembershipErrorKind::ServiceQuotaExceededException(_inner) =>
            _inner.fmt(f)
            ,
            CreateMembershipErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            CreateMembershipErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            CreateMembershipErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateMembershipError {
    fn code(&self) -> Option<&str> {
        CreateMembershipError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateMembershipError {
    /// Creates a new `CreateMembershipError`.
                    pub fn new(kind: CreateMembershipErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `CreateMembershipError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: CreateMembershipErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `CreateMembershipError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: CreateMembershipErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `CreateMembershipErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateMembershipErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `CreateMembershipErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateMembershipErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `CreateMembershipErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, CreateMembershipErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `CreateMembershipErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateMembershipErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `CreateMembershipErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateMembershipErrorKind::ServiceQuotaExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateMembershipErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateMembershipErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `CreateMembershipErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, CreateMembershipErrorKind::ValidationException(_))
    }
}
impl std::error::Error for CreateMembershipError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateMembershipErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            CreateMembershipErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            CreateMembershipErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            CreateMembershipErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            CreateMembershipErrorKind::ServiceQuotaExceededException(_inner) =>
            Some(_inner)
            ,
            CreateMembershipErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            CreateMembershipErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            CreateMembershipErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `DeleteMembership` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteMembershipError {
    /// Kind of error that occurred.
                    pub kind: DeleteMembershipErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteMembershipError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeleteMembershipErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `DeleteMembership` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteMembershipErrorKind {
    /// <p>Caller does not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Updating or deleting a resource can cause an inconsistent state.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>Unexpected error during processing of request.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Request references a resource which does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Request was denied due to request throttling.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The input fails to satisfy the specified constraints.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeleteMembershipError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteMembershipErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteMembershipErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteMembershipErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteMembershipErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteMembershipErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteMembershipErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteMembershipErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteMembershipError {
    fn code(&self) -> Option<&str> {
        DeleteMembershipError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteMembershipError {
    /// Creates a new `DeleteMembershipError`.
                    pub fn new(kind: DeleteMembershipErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `DeleteMembershipError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: DeleteMembershipErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `DeleteMembershipError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: DeleteMembershipErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `DeleteMembershipErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DeleteMembershipErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DeleteMembershipErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteMembershipErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `DeleteMembershipErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, DeleteMembershipErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `DeleteMembershipErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteMembershipErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DeleteMembershipErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteMembershipErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `DeleteMembershipErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DeleteMembershipErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DeleteMembershipError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteMembershipErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            DeleteMembershipErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            DeleteMembershipErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            DeleteMembershipErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            DeleteMembershipErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            DeleteMembershipErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            DeleteMembershipErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `UpdateMembership` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateMembershipError {
    /// Kind of error that occurred.
                    pub kind: UpdateMembershipErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateMembershipError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: UpdateMembershipErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `UpdateMembership` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateMembershipErrorKind {
    /// <p>Caller does not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Updating or deleting a resource can cause an inconsistent state.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>Unexpected error during processing of request.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Request references a resource which does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Request was denied due to request throttling.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The input fails to satisfy the specified constraints.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for UpdateMembershipError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateMembershipErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateMembershipErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateMembershipErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateMembershipErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateMembershipErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateMembershipErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateMembershipErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateMembershipError {
    fn code(&self) -> Option<&str> {
        UpdateMembershipError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateMembershipError {
    /// Creates a new `UpdateMembershipError`.
                    pub fn new(kind: UpdateMembershipErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `UpdateMembershipError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: UpdateMembershipErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `UpdateMembershipError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: UpdateMembershipErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `UpdateMembershipErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UpdateMembershipErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `UpdateMembershipErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateMembershipErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `UpdateMembershipErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, UpdateMembershipErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `UpdateMembershipErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateMembershipErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `UpdateMembershipErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateMembershipErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `UpdateMembershipErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UpdateMembershipErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UpdateMembershipError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateMembershipErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            UpdateMembershipErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            UpdateMembershipErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            UpdateMembershipErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            UpdateMembershipErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            UpdateMembershipErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            UpdateMembershipErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetMembership` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetMembershipError {
    /// Kind of error that occurred.
                    pub kind: GetMembershipErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetMembershipError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetMembershipErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetMembership` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMembershipErrorKind {
    /// <p>Caller does not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Unexpected error during processing of request.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Request references a resource which does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Request was denied due to request throttling.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The input fails to satisfy the specified constraints.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetMembershipError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetMembershipErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            GetMembershipErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            GetMembershipErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetMembershipErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            GetMembershipErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            GetMembershipErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetMembershipError {
    fn code(&self) -> Option<&str> {
        GetMembershipError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMembershipError {
    /// Creates a new `GetMembershipError`.
                    pub fn new(kind: GetMembershipErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetMembershipError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetMembershipErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetMembershipError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetMembershipErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetMembershipErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetMembershipErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetMembershipErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, GetMembershipErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `GetMembershipErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetMembershipErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetMembershipErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetMembershipErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `GetMembershipErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, GetMembershipErrorKind::ValidationException(_))
    }
}
impl std::error::Error for GetMembershipError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetMembershipErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            GetMembershipErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            GetMembershipErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            GetMembershipErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            GetMembershipErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            GetMembershipErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `UpdateConfiguredTableAnalysisRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateConfiguredTableAnalysisRuleError {
    /// Kind of error that occurred.
                    pub kind: UpdateConfiguredTableAnalysisRuleErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateConfiguredTableAnalysisRuleError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: UpdateConfiguredTableAnalysisRuleErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `UpdateConfiguredTableAnalysisRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateConfiguredTableAnalysisRuleErrorKind {
    /// <p>Caller does not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Updating or deleting a resource can cause an inconsistent state.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>Unexpected error during processing of request.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Request references a resource which does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Request was denied due to request throttling.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The input fails to satisfy the specified constraints.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for UpdateConfiguredTableAnalysisRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateConfiguredTableAnalysisRuleErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateConfiguredTableAnalysisRuleErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateConfiguredTableAnalysisRuleErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateConfiguredTableAnalysisRuleErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateConfiguredTableAnalysisRuleErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateConfiguredTableAnalysisRuleErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateConfiguredTableAnalysisRuleErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateConfiguredTableAnalysisRuleError {
    fn code(&self) -> Option<&str> {
        UpdateConfiguredTableAnalysisRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateConfiguredTableAnalysisRuleError {
    /// Creates a new `UpdateConfiguredTableAnalysisRuleError`.
                    pub fn new(kind: UpdateConfiguredTableAnalysisRuleErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `UpdateConfiguredTableAnalysisRuleError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: UpdateConfiguredTableAnalysisRuleErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `UpdateConfiguredTableAnalysisRuleError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: UpdateConfiguredTableAnalysisRuleErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `UpdateConfiguredTableAnalysisRuleErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UpdateConfiguredTableAnalysisRuleErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `UpdateConfiguredTableAnalysisRuleErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateConfiguredTableAnalysisRuleErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `UpdateConfiguredTableAnalysisRuleErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, UpdateConfiguredTableAnalysisRuleErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `UpdateConfiguredTableAnalysisRuleErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateConfiguredTableAnalysisRuleErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `UpdateConfiguredTableAnalysisRuleErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateConfiguredTableAnalysisRuleErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `UpdateConfiguredTableAnalysisRuleErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UpdateConfiguredTableAnalysisRuleErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UpdateConfiguredTableAnalysisRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateConfiguredTableAnalysisRuleErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            UpdateConfiguredTableAnalysisRuleErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            UpdateConfiguredTableAnalysisRuleErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            UpdateConfiguredTableAnalysisRuleErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            UpdateConfiguredTableAnalysisRuleErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            UpdateConfiguredTableAnalysisRuleErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            UpdateConfiguredTableAnalysisRuleErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetConfiguredTableAnalysisRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetConfiguredTableAnalysisRuleError {
    /// Kind of error that occurred.
                    pub kind: GetConfiguredTableAnalysisRuleErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetConfiguredTableAnalysisRuleError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetConfiguredTableAnalysisRuleErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetConfiguredTableAnalysisRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetConfiguredTableAnalysisRuleErrorKind {
    /// <p>Caller does not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Unexpected error during processing of request.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Request references a resource which does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Request was denied due to request throttling.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The input fails to satisfy the specified constraints.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetConfiguredTableAnalysisRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetConfiguredTableAnalysisRuleErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            GetConfiguredTableAnalysisRuleErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            GetConfiguredTableAnalysisRuleErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetConfiguredTableAnalysisRuleErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            GetConfiguredTableAnalysisRuleErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            GetConfiguredTableAnalysisRuleErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetConfiguredTableAnalysisRuleError {
    fn code(&self) -> Option<&str> {
        GetConfiguredTableAnalysisRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetConfiguredTableAnalysisRuleError {
    /// Creates a new `GetConfiguredTableAnalysisRuleError`.
                    pub fn new(kind: GetConfiguredTableAnalysisRuleErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetConfiguredTableAnalysisRuleError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetConfiguredTableAnalysisRuleErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetConfiguredTableAnalysisRuleError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetConfiguredTableAnalysisRuleErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetConfiguredTableAnalysisRuleErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetConfiguredTableAnalysisRuleErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetConfiguredTableAnalysisRuleErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, GetConfiguredTableAnalysisRuleErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `GetConfiguredTableAnalysisRuleErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetConfiguredTableAnalysisRuleErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetConfiguredTableAnalysisRuleErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetConfiguredTableAnalysisRuleErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `GetConfiguredTableAnalysisRuleErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, GetConfiguredTableAnalysisRuleErrorKind::ValidationException(_))
    }
}
impl std::error::Error for GetConfiguredTableAnalysisRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetConfiguredTableAnalysisRuleErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            GetConfiguredTableAnalysisRuleErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            GetConfiguredTableAnalysisRuleErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            GetConfiguredTableAnalysisRuleErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            GetConfiguredTableAnalysisRuleErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            GetConfiguredTableAnalysisRuleErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `DeleteConfiguredTableAnalysisRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteConfiguredTableAnalysisRuleError {
    /// Kind of error that occurred.
                    pub kind: DeleteConfiguredTableAnalysisRuleErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteConfiguredTableAnalysisRuleError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeleteConfiguredTableAnalysisRuleErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `DeleteConfiguredTableAnalysisRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteConfiguredTableAnalysisRuleErrorKind {
    /// <p>Caller does not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Updating or deleting a resource can cause an inconsistent state.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>Unexpected error during processing of request.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Request references a resource which does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Request was denied due to request throttling.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The input fails to satisfy the specified constraints.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeleteConfiguredTableAnalysisRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteConfiguredTableAnalysisRuleErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteConfiguredTableAnalysisRuleErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteConfiguredTableAnalysisRuleErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteConfiguredTableAnalysisRuleErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteConfiguredTableAnalysisRuleErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteConfiguredTableAnalysisRuleErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteConfiguredTableAnalysisRuleErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteConfiguredTableAnalysisRuleError {
    fn code(&self) -> Option<&str> {
        DeleteConfiguredTableAnalysisRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteConfiguredTableAnalysisRuleError {
    /// Creates a new `DeleteConfiguredTableAnalysisRuleError`.
                    pub fn new(kind: DeleteConfiguredTableAnalysisRuleErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `DeleteConfiguredTableAnalysisRuleError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: DeleteConfiguredTableAnalysisRuleErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `DeleteConfiguredTableAnalysisRuleError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: DeleteConfiguredTableAnalysisRuleErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `DeleteConfiguredTableAnalysisRuleErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DeleteConfiguredTableAnalysisRuleErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DeleteConfiguredTableAnalysisRuleErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteConfiguredTableAnalysisRuleErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `DeleteConfiguredTableAnalysisRuleErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, DeleteConfiguredTableAnalysisRuleErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `DeleteConfiguredTableAnalysisRuleErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteConfiguredTableAnalysisRuleErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DeleteConfiguredTableAnalysisRuleErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteConfiguredTableAnalysisRuleErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `DeleteConfiguredTableAnalysisRuleErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DeleteConfiguredTableAnalysisRuleErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DeleteConfiguredTableAnalysisRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteConfiguredTableAnalysisRuleErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            DeleteConfiguredTableAnalysisRuleErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            DeleteConfiguredTableAnalysisRuleErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            DeleteConfiguredTableAnalysisRuleErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            DeleteConfiguredTableAnalysisRuleErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            DeleteConfiguredTableAnalysisRuleErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            DeleteConfiguredTableAnalysisRuleErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `CreateConfiguredTableAnalysisRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateConfiguredTableAnalysisRuleError {
    /// Kind of error that occurred.
                    pub kind: CreateConfiguredTableAnalysisRuleErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for CreateConfiguredTableAnalysisRuleError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: CreateConfiguredTableAnalysisRuleErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `CreateConfiguredTableAnalysisRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateConfiguredTableAnalysisRuleErrorKind {
    /// <p>Caller does not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Updating or deleting a resource can cause an inconsistent state.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>Unexpected error during processing of request.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Request references a resource which does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Request was denied due to request throttling.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The input fails to satisfy the specified constraints.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for CreateConfiguredTableAnalysisRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateConfiguredTableAnalysisRuleErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            CreateConfiguredTableAnalysisRuleErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            CreateConfiguredTableAnalysisRuleErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            CreateConfiguredTableAnalysisRuleErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            CreateConfiguredTableAnalysisRuleErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            CreateConfiguredTableAnalysisRuleErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            CreateConfiguredTableAnalysisRuleErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateConfiguredTableAnalysisRuleError {
    fn code(&self) -> Option<&str> {
        CreateConfiguredTableAnalysisRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateConfiguredTableAnalysisRuleError {
    /// Creates a new `CreateConfiguredTableAnalysisRuleError`.
                    pub fn new(kind: CreateConfiguredTableAnalysisRuleErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `CreateConfiguredTableAnalysisRuleError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: CreateConfiguredTableAnalysisRuleErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `CreateConfiguredTableAnalysisRuleError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: CreateConfiguredTableAnalysisRuleErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `CreateConfiguredTableAnalysisRuleErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateConfiguredTableAnalysisRuleErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `CreateConfiguredTableAnalysisRuleErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateConfiguredTableAnalysisRuleErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `CreateConfiguredTableAnalysisRuleErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, CreateConfiguredTableAnalysisRuleErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `CreateConfiguredTableAnalysisRuleErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateConfiguredTableAnalysisRuleErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `CreateConfiguredTableAnalysisRuleErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateConfiguredTableAnalysisRuleErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `CreateConfiguredTableAnalysisRuleErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, CreateConfiguredTableAnalysisRuleErrorKind::ValidationException(_))
    }
}
impl std::error::Error for CreateConfiguredTableAnalysisRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateConfiguredTableAnalysisRuleErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            CreateConfiguredTableAnalysisRuleErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            CreateConfiguredTableAnalysisRuleErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            CreateConfiguredTableAnalysisRuleErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            CreateConfiguredTableAnalysisRuleErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            CreateConfiguredTableAnalysisRuleErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            CreateConfiguredTableAnalysisRuleErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListConfiguredTables` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListConfiguredTablesError {
    /// Kind of error that occurred.
                    pub kind: ListConfiguredTablesErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListConfiguredTablesError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListConfiguredTablesErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListConfiguredTables` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListConfiguredTablesErrorKind {
    /// <p>Caller does not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Unexpected error during processing of request.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Request was denied due to request throttling.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The input fails to satisfy the specified constraints.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListConfiguredTablesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListConfiguredTablesErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListConfiguredTablesErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            ListConfiguredTablesErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            ListConfiguredTablesErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            ListConfiguredTablesErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListConfiguredTablesError {
    fn code(&self) -> Option<&str> {
        ListConfiguredTablesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListConfiguredTablesError {
    /// Creates a new `ListConfiguredTablesError`.
                    pub fn new(kind: ListConfiguredTablesErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListConfiguredTablesError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListConfiguredTablesErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListConfiguredTablesError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListConfiguredTablesErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListConfiguredTablesErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListConfiguredTablesErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListConfiguredTablesErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListConfiguredTablesErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `ListConfiguredTablesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListConfiguredTablesErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListConfiguredTablesErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListConfiguredTablesErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListConfiguredTablesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListConfiguredTablesErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListConfiguredTablesErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            ListConfiguredTablesErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            ListConfiguredTablesErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            ListConfiguredTablesErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `CreateConfiguredTable` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateConfiguredTableError {
    /// Kind of error that occurred.
                    pub kind: CreateConfiguredTableErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for CreateConfiguredTableError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: CreateConfiguredTableErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `CreateConfiguredTable` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateConfiguredTableErrorKind {
    /// <p>Caller does not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Updating or deleting a resource can cause an inconsistent state.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>Unexpected error during processing of request.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Request references a resource which does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Request denied because service quota has been exceeded.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>Request was denied due to request throttling.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The input fails to satisfy the specified constraints.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for CreateConfiguredTableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateConfiguredTableErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            CreateConfiguredTableErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            CreateConfiguredTableErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            CreateConfiguredTableErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            CreateConfiguredTableErrorKind::ServiceQuotaExceededException(_inner) =>
            _inner.fmt(f)
            ,
            CreateConfiguredTableErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            CreateConfiguredTableErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            CreateConfiguredTableErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateConfiguredTableError {
    fn code(&self) -> Option<&str> {
        CreateConfiguredTableError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateConfiguredTableError {
    /// Creates a new `CreateConfiguredTableError`.
                    pub fn new(kind: CreateConfiguredTableErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `CreateConfiguredTableError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: CreateConfiguredTableErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `CreateConfiguredTableError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: CreateConfiguredTableErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `CreateConfiguredTableErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateConfiguredTableErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `CreateConfiguredTableErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateConfiguredTableErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `CreateConfiguredTableErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, CreateConfiguredTableErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `CreateConfiguredTableErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateConfiguredTableErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `CreateConfiguredTableErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateConfiguredTableErrorKind::ServiceQuotaExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateConfiguredTableErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateConfiguredTableErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `CreateConfiguredTableErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, CreateConfiguredTableErrorKind::ValidationException(_))
    }
}
impl std::error::Error for CreateConfiguredTableError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateConfiguredTableErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            CreateConfiguredTableErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            CreateConfiguredTableErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            CreateConfiguredTableErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            CreateConfiguredTableErrorKind::ServiceQuotaExceededException(_inner) =>
            Some(_inner)
            ,
            CreateConfiguredTableErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            CreateConfiguredTableErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            CreateConfiguredTableErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `DeleteConfiguredTable` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteConfiguredTableError {
    /// Kind of error that occurred.
                    pub kind: DeleteConfiguredTableErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteConfiguredTableError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeleteConfiguredTableErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `DeleteConfiguredTable` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteConfiguredTableErrorKind {
    /// <p>Caller does not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Updating or deleting a resource can cause an inconsistent state.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>Unexpected error during processing of request.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Request references a resource which does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Request was denied due to request throttling.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The input fails to satisfy the specified constraints.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeleteConfiguredTableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteConfiguredTableErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteConfiguredTableErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteConfiguredTableErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteConfiguredTableErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteConfiguredTableErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteConfiguredTableErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteConfiguredTableErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteConfiguredTableError {
    fn code(&self) -> Option<&str> {
        DeleteConfiguredTableError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteConfiguredTableError {
    /// Creates a new `DeleteConfiguredTableError`.
                    pub fn new(kind: DeleteConfiguredTableErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `DeleteConfiguredTableError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: DeleteConfiguredTableErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `DeleteConfiguredTableError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: DeleteConfiguredTableErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `DeleteConfiguredTableErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DeleteConfiguredTableErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DeleteConfiguredTableErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteConfiguredTableErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `DeleteConfiguredTableErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, DeleteConfiguredTableErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `DeleteConfiguredTableErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteConfiguredTableErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DeleteConfiguredTableErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteConfiguredTableErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `DeleteConfiguredTableErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DeleteConfiguredTableErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DeleteConfiguredTableError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteConfiguredTableErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            DeleteConfiguredTableErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            DeleteConfiguredTableErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            DeleteConfiguredTableErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            DeleteConfiguredTableErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            DeleteConfiguredTableErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            DeleteConfiguredTableErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `UpdateConfiguredTable` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateConfiguredTableError {
    /// Kind of error that occurred.
                    pub kind: UpdateConfiguredTableErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateConfiguredTableError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: UpdateConfiguredTableErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `UpdateConfiguredTable` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateConfiguredTableErrorKind {
    /// <p>Caller does not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Updating or deleting a resource can cause an inconsistent state.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>Unexpected error during processing of request.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Request references a resource which does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Request was denied due to request throttling.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The input fails to satisfy the specified constraints.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for UpdateConfiguredTableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateConfiguredTableErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateConfiguredTableErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateConfiguredTableErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateConfiguredTableErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateConfiguredTableErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateConfiguredTableErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateConfiguredTableErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateConfiguredTableError {
    fn code(&self) -> Option<&str> {
        UpdateConfiguredTableError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateConfiguredTableError {
    /// Creates a new `UpdateConfiguredTableError`.
                    pub fn new(kind: UpdateConfiguredTableErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `UpdateConfiguredTableError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: UpdateConfiguredTableErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `UpdateConfiguredTableError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: UpdateConfiguredTableErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `UpdateConfiguredTableErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UpdateConfiguredTableErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `UpdateConfiguredTableErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateConfiguredTableErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `UpdateConfiguredTableErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, UpdateConfiguredTableErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `UpdateConfiguredTableErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateConfiguredTableErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `UpdateConfiguredTableErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateConfiguredTableErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `UpdateConfiguredTableErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UpdateConfiguredTableErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UpdateConfiguredTableError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateConfiguredTableErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            UpdateConfiguredTableErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            UpdateConfiguredTableErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            UpdateConfiguredTableErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            UpdateConfiguredTableErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            UpdateConfiguredTableErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            UpdateConfiguredTableErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetConfiguredTable` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetConfiguredTableError {
    /// Kind of error that occurred.
                    pub kind: GetConfiguredTableErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetConfiguredTableError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetConfiguredTableErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetConfiguredTable` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetConfiguredTableErrorKind {
    /// <p>Caller does not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Unexpected error during processing of request.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Request references a resource which does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Request was denied due to request throttling.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The input fails to satisfy the specified constraints.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetConfiguredTableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetConfiguredTableErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            GetConfiguredTableErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            GetConfiguredTableErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetConfiguredTableErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            GetConfiguredTableErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            GetConfiguredTableErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetConfiguredTableError {
    fn code(&self) -> Option<&str> {
        GetConfiguredTableError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetConfiguredTableError {
    /// Creates a new `GetConfiguredTableError`.
                    pub fn new(kind: GetConfiguredTableErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetConfiguredTableError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetConfiguredTableErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetConfiguredTableError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetConfiguredTableErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetConfiguredTableErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetConfiguredTableErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetConfiguredTableErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, GetConfiguredTableErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `GetConfiguredTableErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetConfiguredTableErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetConfiguredTableErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetConfiguredTableErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `GetConfiguredTableErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, GetConfiguredTableErrorKind::ValidationException(_))
    }
}
impl std::error::Error for GetConfiguredTableError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetConfiguredTableErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            GetConfiguredTableErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            GetConfiguredTableErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            GetConfiguredTableErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            GetConfiguredTableErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            GetConfiguredTableErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListConfiguredTableAssociations` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListConfiguredTableAssociationsError {
    /// Kind of error that occurred.
                    pub kind: ListConfiguredTableAssociationsErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListConfiguredTableAssociationsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListConfiguredTableAssociationsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListConfiguredTableAssociations` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListConfiguredTableAssociationsErrorKind {
    /// <p>Caller does not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Unexpected error during processing of request.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Request was denied due to request throttling.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The input fails to satisfy the specified constraints.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListConfiguredTableAssociationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListConfiguredTableAssociationsErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListConfiguredTableAssociationsErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            ListConfiguredTableAssociationsErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            ListConfiguredTableAssociationsErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            ListConfiguredTableAssociationsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListConfiguredTableAssociationsError {
    fn code(&self) -> Option<&str> {
        ListConfiguredTableAssociationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListConfiguredTableAssociationsError {
    /// Creates a new `ListConfiguredTableAssociationsError`.
                    pub fn new(kind: ListConfiguredTableAssociationsErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListConfiguredTableAssociationsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListConfiguredTableAssociationsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListConfiguredTableAssociationsError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListConfiguredTableAssociationsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListConfiguredTableAssociationsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListConfiguredTableAssociationsErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListConfiguredTableAssociationsErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListConfiguredTableAssociationsErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `ListConfiguredTableAssociationsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListConfiguredTableAssociationsErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListConfiguredTableAssociationsErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListConfiguredTableAssociationsErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListConfiguredTableAssociationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListConfiguredTableAssociationsErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListConfiguredTableAssociationsErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            ListConfiguredTableAssociationsErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            ListConfiguredTableAssociationsErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            ListConfiguredTableAssociationsErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `CreateConfiguredTableAssociation` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateConfiguredTableAssociationError {
    /// Kind of error that occurred.
                    pub kind: CreateConfiguredTableAssociationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for CreateConfiguredTableAssociationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: CreateConfiguredTableAssociationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `CreateConfiguredTableAssociation` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateConfiguredTableAssociationErrorKind {
    /// <p>Caller does not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Updating or deleting a resource can cause an inconsistent state.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>Unexpected error during processing of request.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Request references a resource which does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Request denied because service quota has been exceeded.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>Request was denied due to request throttling.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The input fails to satisfy the specified constraints.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for CreateConfiguredTableAssociationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateConfiguredTableAssociationErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            CreateConfiguredTableAssociationErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            CreateConfiguredTableAssociationErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            CreateConfiguredTableAssociationErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            CreateConfiguredTableAssociationErrorKind::ServiceQuotaExceededException(_inner) =>
            _inner.fmt(f)
            ,
            CreateConfiguredTableAssociationErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            CreateConfiguredTableAssociationErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            CreateConfiguredTableAssociationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateConfiguredTableAssociationError {
    fn code(&self) -> Option<&str> {
        CreateConfiguredTableAssociationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateConfiguredTableAssociationError {
    /// Creates a new `CreateConfiguredTableAssociationError`.
                    pub fn new(kind: CreateConfiguredTableAssociationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `CreateConfiguredTableAssociationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: CreateConfiguredTableAssociationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `CreateConfiguredTableAssociationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: CreateConfiguredTableAssociationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `CreateConfiguredTableAssociationErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateConfiguredTableAssociationErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `CreateConfiguredTableAssociationErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateConfiguredTableAssociationErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `CreateConfiguredTableAssociationErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, CreateConfiguredTableAssociationErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `CreateConfiguredTableAssociationErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateConfiguredTableAssociationErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `CreateConfiguredTableAssociationErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateConfiguredTableAssociationErrorKind::ServiceQuotaExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateConfiguredTableAssociationErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateConfiguredTableAssociationErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `CreateConfiguredTableAssociationErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, CreateConfiguredTableAssociationErrorKind::ValidationException(_))
    }
}
impl std::error::Error for CreateConfiguredTableAssociationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateConfiguredTableAssociationErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            CreateConfiguredTableAssociationErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            CreateConfiguredTableAssociationErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            CreateConfiguredTableAssociationErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            CreateConfiguredTableAssociationErrorKind::ServiceQuotaExceededException(_inner) =>
            Some(_inner)
            ,
            CreateConfiguredTableAssociationErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            CreateConfiguredTableAssociationErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            CreateConfiguredTableAssociationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `DeleteConfiguredTableAssociation` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteConfiguredTableAssociationError {
    /// Kind of error that occurred.
                    pub kind: DeleteConfiguredTableAssociationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteConfiguredTableAssociationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeleteConfiguredTableAssociationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `DeleteConfiguredTableAssociation` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteConfiguredTableAssociationErrorKind {
    /// <p>Caller does not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Updating or deleting a resource can cause an inconsistent state.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>Unexpected error during processing of request.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Request references a resource which does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Request was denied due to request throttling.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The input fails to satisfy the specified constraints.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeleteConfiguredTableAssociationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteConfiguredTableAssociationErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteConfiguredTableAssociationErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteConfiguredTableAssociationErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteConfiguredTableAssociationErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteConfiguredTableAssociationErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteConfiguredTableAssociationErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteConfiguredTableAssociationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteConfiguredTableAssociationError {
    fn code(&self) -> Option<&str> {
        DeleteConfiguredTableAssociationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteConfiguredTableAssociationError {
    /// Creates a new `DeleteConfiguredTableAssociationError`.
                    pub fn new(kind: DeleteConfiguredTableAssociationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `DeleteConfiguredTableAssociationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: DeleteConfiguredTableAssociationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `DeleteConfiguredTableAssociationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: DeleteConfiguredTableAssociationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `DeleteConfiguredTableAssociationErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DeleteConfiguredTableAssociationErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DeleteConfiguredTableAssociationErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteConfiguredTableAssociationErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `DeleteConfiguredTableAssociationErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, DeleteConfiguredTableAssociationErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `DeleteConfiguredTableAssociationErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteConfiguredTableAssociationErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DeleteConfiguredTableAssociationErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteConfiguredTableAssociationErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `DeleteConfiguredTableAssociationErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DeleteConfiguredTableAssociationErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DeleteConfiguredTableAssociationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteConfiguredTableAssociationErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            DeleteConfiguredTableAssociationErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            DeleteConfiguredTableAssociationErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            DeleteConfiguredTableAssociationErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            DeleteConfiguredTableAssociationErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            DeleteConfiguredTableAssociationErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            DeleteConfiguredTableAssociationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `UpdateConfiguredTableAssociation` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateConfiguredTableAssociationError {
    /// Kind of error that occurred.
                    pub kind: UpdateConfiguredTableAssociationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateConfiguredTableAssociationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: UpdateConfiguredTableAssociationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `UpdateConfiguredTableAssociation` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateConfiguredTableAssociationErrorKind {
    /// <p>Caller does not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Updating or deleting a resource can cause an inconsistent state.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>Unexpected error during processing of request.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Request references a resource which does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Request was denied due to request throttling.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The input fails to satisfy the specified constraints.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for UpdateConfiguredTableAssociationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateConfiguredTableAssociationErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateConfiguredTableAssociationErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateConfiguredTableAssociationErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateConfiguredTableAssociationErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateConfiguredTableAssociationErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateConfiguredTableAssociationErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateConfiguredTableAssociationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateConfiguredTableAssociationError {
    fn code(&self) -> Option<&str> {
        UpdateConfiguredTableAssociationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateConfiguredTableAssociationError {
    /// Creates a new `UpdateConfiguredTableAssociationError`.
                    pub fn new(kind: UpdateConfiguredTableAssociationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `UpdateConfiguredTableAssociationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: UpdateConfiguredTableAssociationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `UpdateConfiguredTableAssociationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: UpdateConfiguredTableAssociationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `UpdateConfiguredTableAssociationErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UpdateConfiguredTableAssociationErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `UpdateConfiguredTableAssociationErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateConfiguredTableAssociationErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `UpdateConfiguredTableAssociationErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, UpdateConfiguredTableAssociationErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `UpdateConfiguredTableAssociationErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateConfiguredTableAssociationErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `UpdateConfiguredTableAssociationErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateConfiguredTableAssociationErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `UpdateConfiguredTableAssociationErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UpdateConfiguredTableAssociationErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UpdateConfiguredTableAssociationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateConfiguredTableAssociationErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            UpdateConfiguredTableAssociationErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            UpdateConfiguredTableAssociationErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            UpdateConfiguredTableAssociationErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            UpdateConfiguredTableAssociationErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            UpdateConfiguredTableAssociationErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            UpdateConfiguredTableAssociationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetConfiguredTableAssociation` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetConfiguredTableAssociationError {
    /// Kind of error that occurred.
                    pub kind: GetConfiguredTableAssociationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetConfiguredTableAssociationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetConfiguredTableAssociationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetConfiguredTableAssociation` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetConfiguredTableAssociationErrorKind {
    /// <p>Caller does not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Unexpected error during processing of request.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Request references a resource which does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Request was denied due to request throttling.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The input fails to satisfy the specified constraints.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetConfiguredTableAssociationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetConfiguredTableAssociationErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            GetConfiguredTableAssociationErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            GetConfiguredTableAssociationErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetConfiguredTableAssociationErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            GetConfiguredTableAssociationErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            GetConfiguredTableAssociationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetConfiguredTableAssociationError {
    fn code(&self) -> Option<&str> {
        GetConfiguredTableAssociationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetConfiguredTableAssociationError {
    /// Creates a new `GetConfiguredTableAssociationError`.
                    pub fn new(kind: GetConfiguredTableAssociationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetConfiguredTableAssociationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetConfiguredTableAssociationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetConfiguredTableAssociationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetConfiguredTableAssociationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetConfiguredTableAssociationErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetConfiguredTableAssociationErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetConfiguredTableAssociationErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, GetConfiguredTableAssociationErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `GetConfiguredTableAssociationErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetConfiguredTableAssociationErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetConfiguredTableAssociationErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetConfiguredTableAssociationErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `GetConfiguredTableAssociationErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, GetConfiguredTableAssociationErrorKind::ValidationException(_))
    }
}
impl std::error::Error for GetConfiguredTableAssociationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetConfiguredTableAssociationErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            GetConfiguredTableAssociationErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            GetConfiguredTableAssociationErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            GetConfiguredTableAssociationErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            GetConfiguredTableAssociationErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            GetConfiguredTableAssociationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListSchemas` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSchemasError {
    /// Kind of error that occurred.
                    pub kind: ListSchemasErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListSchemasError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListSchemasErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListSchemas` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSchemasErrorKind {
    /// <p>Caller does not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Unexpected error during processing of request.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Request references a resource which does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Request was denied due to request throttling.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The input fails to satisfy the specified constraints.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListSchemasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSchemasErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListSchemasErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            ListSchemasErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            ListSchemasErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            ListSchemasErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            ListSchemasErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListSchemasError {
    fn code(&self) -> Option<&str> {
        ListSchemasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSchemasError {
    /// Creates a new `ListSchemasError`.
                    pub fn new(kind: ListSchemasErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListSchemasError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListSchemasErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListSchemasError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListSchemasErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListSchemasErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListSchemasErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListSchemasErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListSchemasErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `ListSchemasErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListSchemasErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListSchemasErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListSchemasErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListSchemasErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListSchemasErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListSchemasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSchemasErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListSchemasErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            ListSchemasErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            ListSchemasErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            ListSchemasErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            ListSchemasErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListMembers` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListMembersError {
    /// Kind of error that occurred.
                    pub kind: ListMembersErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListMembersError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListMembersErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListMembers` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListMembersErrorKind {
    /// <p>Caller does not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Unexpected error during processing of request.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Request references a resource which does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Request was denied due to request throttling.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The input fails to satisfy the specified constraints.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListMembersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListMembersErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListMembersErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            ListMembersErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            ListMembersErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            ListMembersErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            ListMembersErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListMembersError {
    fn code(&self) -> Option<&str> {
        ListMembersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListMembersError {
    /// Creates a new `ListMembersError`.
                    pub fn new(kind: ListMembersErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListMembersError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListMembersErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListMembersError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListMembersErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListMembersErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListMembersErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListMembersErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListMembersErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `ListMembersErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListMembersErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListMembersErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListMembersErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListMembersErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListMembersErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListMembersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListMembersErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListMembersErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            ListMembersErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            ListMembersErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            ListMembersErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            ListMembersErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetSchemaAnalysisRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSchemaAnalysisRuleError {
    /// Kind of error that occurred.
                    pub kind: GetSchemaAnalysisRuleErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetSchemaAnalysisRuleError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetSchemaAnalysisRuleErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetSchemaAnalysisRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSchemaAnalysisRuleErrorKind {
    /// <p>Caller does not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Unexpected error during processing of request.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Request references a resource which does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Request was denied due to request throttling.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The input fails to satisfy the specified constraints.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetSchemaAnalysisRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSchemaAnalysisRuleErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            GetSchemaAnalysisRuleErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            GetSchemaAnalysisRuleErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetSchemaAnalysisRuleErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            GetSchemaAnalysisRuleErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            GetSchemaAnalysisRuleErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetSchemaAnalysisRuleError {
    fn code(&self) -> Option<&str> {
        GetSchemaAnalysisRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSchemaAnalysisRuleError {
    /// Creates a new `GetSchemaAnalysisRuleError`.
                    pub fn new(kind: GetSchemaAnalysisRuleErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetSchemaAnalysisRuleError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetSchemaAnalysisRuleErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetSchemaAnalysisRuleError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetSchemaAnalysisRuleErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetSchemaAnalysisRuleErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetSchemaAnalysisRuleErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetSchemaAnalysisRuleErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, GetSchemaAnalysisRuleErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `GetSchemaAnalysisRuleErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetSchemaAnalysisRuleErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetSchemaAnalysisRuleErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetSchemaAnalysisRuleErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `GetSchemaAnalysisRuleErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, GetSchemaAnalysisRuleErrorKind::ValidationException(_))
    }
}
impl std::error::Error for GetSchemaAnalysisRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSchemaAnalysisRuleErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            GetSchemaAnalysisRuleErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            GetSchemaAnalysisRuleErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            GetSchemaAnalysisRuleErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            GetSchemaAnalysisRuleErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            GetSchemaAnalysisRuleErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetSchema` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSchemaError {
    /// Kind of error that occurred.
                    pub kind: GetSchemaErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetSchemaError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetSchemaErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetSchema` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSchemaErrorKind {
    /// <p>Caller does not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Unexpected error during processing of request.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Request references a resource which does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Request was denied due to request throttling.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The input fails to satisfy the specified constraints.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetSchemaError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSchemaErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            GetSchemaErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            GetSchemaErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetSchemaErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            GetSchemaErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            GetSchemaErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetSchemaError {
    fn code(&self) -> Option<&str> {
        GetSchemaError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSchemaError {
    /// Creates a new `GetSchemaError`.
                    pub fn new(kind: GetSchemaErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetSchemaError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetSchemaErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetSchemaError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetSchemaErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetSchemaErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetSchemaErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetSchemaErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, GetSchemaErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `GetSchemaErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetSchemaErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetSchemaErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetSchemaErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `GetSchemaErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, GetSchemaErrorKind::ValidationException(_))
    }
}
impl std::error::Error for GetSchemaError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSchemaErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            GetSchemaErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            GetSchemaErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            GetSchemaErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            GetSchemaErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            GetSchemaErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `DeleteMember` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteMemberError {
    /// Kind of error that occurred.
                    pub kind: DeleteMemberErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteMemberError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeleteMemberErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `DeleteMember` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteMemberErrorKind {
    /// <p>Caller does not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Updating or deleting a resource can cause an inconsistent state.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>Unexpected error during processing of request.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Request references a resource which does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Request was denied due to request throttling.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The input fails to satisfy the specified constraints.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeleteMemberError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteMemberErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteMemberErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteMemberErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteMemberErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteMemberErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteMemberErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteMemberErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteMemberError {
    fn code(&self) -> Option<&str> {
        DeleteMemberError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteMemberError {
    /// Creates a new `DeleteMemberError`.
                    pub fn new(kind: DeleteMemberErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `DeleteMemberError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: DeleteMemberErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `DeleteMemberError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: DeleteMemberErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `DeleteMemberErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DeleteMemberErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DeleteMemberErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteMemberErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `DeleteMemberErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, DeleteMemberErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `DeleteMemberErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteMemberErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DeleteMemberErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteMemberErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `DeleteMemberErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DeleteMemberErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DeleteMemberError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteMemberErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            DeleteMemberErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            DeleteMemberErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            DeleteMemberErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            DeleteMemberErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            DeleteMemberErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            DeleteMemberErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `BatchGetSchema` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchGetSchemaError {
    /// Kind of error that occurred.
                    pub kind: BatchGetSchemaErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for BatchGetSchemaError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: BatchGetSchemaErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `BatchGetSchema` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchGetSchemaErrorKind {
    /// <p>Caller does not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Unexpected error during processing of request.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Request references a resource which does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Request was denied due to request throttling.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The input fails to satisfy the specified constraints.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for BatchGetSchemaError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchGetSchemaErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            BatchGetSchemaErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            BatchGetSchemaErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            BatchGetSchemaErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            BatchGetSchemaErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            BatchGetSchemaErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for BatchGetSchemaError {
    fn code(&self) -> Option<&str> {
        BatchGetSchemaError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchGetSchemaError {
    /// Creates a new `BatchGetSchemaError`.
                    pub fn new(kind: BatchGetSchemaErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `BatchGetSchemaError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: BatchGetSchemaErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `BatchGetSchemaError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: BatchGetSchemaErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `BatchGetSchemaErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, BatchGetSchemaErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `BatchGetSchemaErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, BatchGetSchemaErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `BatchGetSchemaErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, BatchGetSchemaErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `BatchGetSchemaErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, BatchGetSchemaErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `BatchGetSchemaErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, BatchGetSchemaErrorKind::ValidationException(_))
    }
}
impl std::error::Error for BatchGetSchemaError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchGetSchemaErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            BatchGetSchemaErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            BatchGetSchemaErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            BatchGetSchemaErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            BatchGetSchemaErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            BatchGetSchemaErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListCollaborations` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListCollaborationsError {
    /// Kind of error that occurred.
                    pub kind: ListCollaborationsErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListCollaborationsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListCollaborationsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListCollaborations` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListCollaborationsErrorKind {
    /// <p>Caller does not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Unexpected error during processing of request.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Request was denied due to request throttling.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The input fails to satisfy the specified constraints.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListCollaborationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListCollaborationsErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListCollaborationsErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            ListCollaborationsErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            ListCollaborationsErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            ListCollaborationsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListCollaborationsError {
    fn code(&self) -> Option<&str> {
        ListCollaborationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListCollaborationsError {
    /// Creates a new `ListCollaborationsError`.
                    pub fn new(kind: ListCollaborationsErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListCollaborationsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListCollaborationsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListCollaborationsError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListCollaborationsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListCollaborationsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListCollaborationsErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListCollaborationsErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListCollaborationsErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `ListCollaborationsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListCollaborationsErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListCollaborationsErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListCollaborationsErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListCollaborationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListCollaborationsErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListCollaborationsErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            ListCollaborationsErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            ListCollaborationsErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            ListCollaborationsErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `CreateCollaboration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateCollaborationError {
    /// Kind of error that occurred.
                    pub kind: CreateCollaborationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for CreateCollaborationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: CreateCollaborationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `CreateCollaboration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCollaborationErrorKind {
    /// <p>Caller does not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Unexpected error during processing of request.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Request denied because service quota has been exceeded.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>Request was denied due to request throttling.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The input fails to satisfy the specified constraints.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for CreateCollaborationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateCollaborationErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            CreateCollaborationErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            CreateCollaborationErrorKind::ServiceQuotaExceededException(_inner) =>
            _inner.fmt(f)
            ,
            CreateCollaborationErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            CreateCollaborationErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            CreateCollaborationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateCollaborationError {
    fn code(&self) -> Option<&str> {
        CreateCollaborationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCollaborationError {
    /// Creates a new `CreateCollaborationError`.
                    pub fn new(kind: CreateCollaborationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `CreateCollaborationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: CreateCollaborationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `CreateCollaborationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: CreateCollaborationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `CreateCollaborationErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateCollaborationErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `CreateCollaborationErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, CreateCollaborationErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `CreateCollaborationErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateCollaborationErrorKind::ServiceQuotaExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateCollaborationErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateCollaborationErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `CreateCollaborationErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, CreateCollaborationErrorKind::ValidationException(_))
    }
}
impl std::error::Error for CreateCollaborationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateCollaborationErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            CreateCollaborationErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            CreateCollaborationErrorKind::ServiceQuotaExceededException(_inner) =>
            Some(_inner)
            ,
            CreateCollaborationErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            CreateCollaborationErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            CreateCollaborationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `DeleteCollaboration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteCollaborationError {
    /// Kind of error that occurred.
                    pub kind: DeleteCollaborationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteCollaborationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeleteCollaborationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `DeleteCollaboration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCollaborationErrorKind {
    /// <p>Caller does not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Unexpected error during processing of request.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Request was denied due to request throttling.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The input fails to satisfy the specified constraints.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeleteCollaborationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteCollaborationErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteCollaborationErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteCollaborationErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteCollaborationErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteCollaborationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteCollaborationError {
    fn code(&self) -> Option<&str> {
        DeleteCollaborationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteCollaborationError {
    /// Creates a new `DeleteCollaborationError`.
                    pub fn new(kind: DeleteCollaborationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `DeleteCollaborationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: DeleteCollaborationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `DeleteCollaborationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: DeleteCollaborationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `DeleteCollaborationErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DeleteCollaborationErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DeleteCollaborationErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, DeleteCollaborationErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `DeleteCollaborationErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteCollaborationErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `DeleteCollaborationErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DeleteCollaborationErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DeleteCollaborationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteCollaborationErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            DeleteCollaborationErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            DeleteCollaborationErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            DeleteCollaborationErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            DeleteCollaborationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `UpdateCollaboration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateCollaborationError {
    /// Kind of error that occurred.
                    pub kind: UpdateCollaborationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateCollaborationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: UpdateCollaborationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `UpdateCollaboration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateCollaborationErrorKind {
    /// <p>Caller does not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Unexpected error during processing of request.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Request was denied due to request throttling.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The input fails to satisfy the specified constraints.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for UpdateCollaborationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateCollaborationErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateCollaborationErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateCollaborationErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateCollaborationErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateCollaborationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateCollaborationError {
    fn code(&self) -> Option<&str> {
        UpdateCollaborationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateCollaborationError {
    /// Creates a new `UpdateCollaborationError`.
                    pub fn new(kind: UpdateCollaborationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `UpdateCollaborationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: UpdateCollaborationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `UpdateCollaborationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: UpdateCollaborationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `UpdateCollaborationErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UpdateCollaborationErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `UpdateCollaborationErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, UpdateCollaborationErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `UpdateCollaborationErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateCollaborationErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `UpdateCollaborationErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UpdateCollaborationErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UpdateCollaborationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateCollaborationErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            UpdateCollaborationErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            UpdateCollaborationErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            UpdateCollaborationErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            UpdateCollaborationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetCollaboration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCollaborationError {
    /// Kind of error that occurred.
                    pub kind: GetCollaborationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetCollaborationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetCollaborationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetCollaboration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCollaborationErrorKind {
    /// <p>Caller does not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Unexpected error during processing of request.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Request was denied due to request throttling.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The input fails to satisfy the specified constraints.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetCollaborationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCollaborationErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            GetCollaborationErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            GetCollaborationErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            GetCollaborationErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            GetCollaborationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetCollaborationError {
    fn code(&self) -> Option<&str> {
        GetCollaborationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCollaborationError {
    /// Creates a new `GetCollaborationError`.
                    pub fn new(kind: GetCollaborationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetCollaborationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetCollaborationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetCollaborationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetCollaborationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetCollaborationErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetCollaborationErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetCollaborationErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, GetCollaborationErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `GetCollaborationErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetCollaborationErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `GetCollaborationErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, GetCollaborationErrorKind::ValidationException(_))
    }
}
impl std::error::Error for GetCollaborationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCollaborationErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            GetCollaborationErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            GetCollaborationErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            GetCollaborationErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            GetCollaborationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// 
/// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
/// 
/// When logging an error from the SDK, it is recommended that you either wrap the error in
/// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
/// error reporter library that visits the error's cause/source chain, or call
/// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
/// 
#[derive(Debug)]
        pub struct Unhandled {
            source: Box<dyn std::error::Error + Send + Sync + 'static>,
        }
        impl Unhandled {
            #[allow(unused)]
            pub(crate) fn new(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
                Self { source }
            }
        }
        impl std::fmt::Display for Unhandled {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                write!(f, "unhandled error")
            }
        }
        impl std::error::Error for Unhandled {
            fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                Some(self.source.as_ref() as _)
            }
        }

