// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::create_stream_group::_create_stream_group_output::CreateStreamGroupOutputBuilder;

pub use crate::operation::create_stream_group::_create_stream_group_input::CreateStreamGroupInputBuilder;

impl crate::operation::create_stream_group::builders::CreateStreamGroupInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::create_stream_group::CreateStreamGroupOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_stream_group::CreateStreamGroupError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.create_stream_group();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `CreateStreamGroup`.
///
/// <p>Manage how Amazon GameLift Streams streams your applications by using a stream group. A stream group is a collection of resources that Amazon GameLift Streams uses to stream your application to end-users. When you create a stream group, you specify an application to stream by default and the type of hardware to use, such as the graphical processing unit (GPU). You can also link additional applications, which allows you to stream those applications using this stream group. Depending on your expected users, you also scale the number of concurrent streams you want to support at one time, and in what locations.</p>
/// <p>Stream capacity represents the number of concurrent streams that can be active at a time. You set stream capacity per location, per stream group. There are two types of capacity: always-on and on-demand:</p>
/// <ul>
/// <li>
/// <p><b>Always-on</b>: The streaming capacity that is allocated and ready to handle stream requests without delay. You pay for this capacity whether it's in use or not. Best for quickest time from streaming request to streaming session.</p></li>
/// <li>
/// <p><b>On-demand</b>: The streaming capacity that Amazon GameLift Streams can allocate in response to stream requests, and then de-allocate when the session has terminated. This offers a cost control measure at the expense of a greater startup time (typically under 5 minutes).</p></li>
/// </ul>
/// <p>To adjust the capacity of any <code>ACTIVE</code> stream group, call <code>UpdateStreamGroup</code>.</p>
/// <p>If the request is successful, Amazon GameLift Streams begins creating the stream group. Amazon GameLift Streams assigns a unique ID to the stream group resource and sets the status to <code>ACTIVATING</code>. When the stream group reaches <code>ACTIVE</code> status, you can start stream sessions by using <code>StartStreamSession</code>. To check the stream group's status, call <code>GetStreamGroup</code>.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct CreateStreamGroupFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::create_stream_group::builders::CreateStreamGroupInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::create_stream_group::CreateStreamGroupOutput,
        crate::operation::create_stream_group::CreateStreamGroupError,
    > for CreateStreamGroupFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::create_stream_group::CreateStreamGroupOutput,
            crate::operation::create_stream_group::CreateStreamGroupError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl CreateStreamGroupFluentBuilder {
    /// Creates a new `CreateStreamGroupFluentBuilder`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the CreateStreamGroup as a reference.
    pub fn as_input(&self) -> &crate::operation::create_stream_group::builders::CreateStreamGroupInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::create_stream_group::CreateStreamGroupOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_stream_group::CreateStreamGroupError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::create_stream_group::CreateStreamGroup::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::create_stream_group::CreateStreamGroup::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::create_stream_group::CreateStreamGroupOutput,
        crate::operation::create_stream_group::CreateStreamGroupError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl ::std::convert::Into<crate::config::Builder>) -> Self {
        self.set_config_override(::std::option::Option::Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: ::std::option::Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>A descriptive label for the stream group.</p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.description(input.into());
        self
    }
    /// <p>A descriptive label for the stream group.</p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_description(input);
        self
    }
    /// <p>A descriptive label for the stream group.</p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_description()
    }
    /// <p>The target stream quality for sessions that are hosted in this stream group. Set a stream class that is appropriate to the type of content that you're streaming. Stream class determines the type of computing resources Amazon GameLift Streams uses and impacts the cost of streaming. The following options are available:</p>
    /// <p>A stream class can be one of the following:</p>
    /// <ul>
    /// <li>
    /// <p><b> <code>gen5n_win2022</code> (NVIDIA, ultra)</b> Supports applications with extremely high 3D scene complexity. Runs applications on Microsoft Windows Server 2022 Base and supports DirectX 12. Compatible with most Unreal Engine 5.x builds, 32-bit applications, and anti-cheat technology. Uses NVIDIA A10G Tensor GPU.</p>
    /// <ul>
    /// <li>
    /// <p>Reference resolution: 1080p</p></li>
    /// <li>
    /// <p>Reference frame rate: 60 fps</p></li>
    /// <li>
    /// <p>Workload specifications: 8 vCPUs, 32 GB RAM, 24 GB VRAM</p></li>
    /// <li>
    /// <p>Tenancy: Supports 1 concurrent stream session</p></li>
    /// </ul></li>
    /// <li>
    /// <p><b> <code>gen5n_high</code> (NVIDIA, high)</b> Supports applications with moderate to high 3D scene complexity. Uses NVIDIA A10G Tensor GPU.</p>
    /// <ul>
    /// <li>
    /// <p>Reference resolution: 1080p</p></li>
    /// <li>
    /// <p>Reference frame rate: 60 fps</p></li>
    /// <li>
    /// <p>Workload specifications: 4 vCPUs, 16 GB RAM, 12 GB VRAM</p></li>
    /// <li>
    /// <p>Tenancy: Supports up to 2 concurrent stream sessions</p></li>
    /// </ul></li>
    /// <li>
    /// <p><b> <code>gen5n_ultra</code> (NVIDIA, ultra)</b> Supports applications with extremely high 3D scene complexity. Uses dedicated NVIDIA A10G Tensor GPU.</p>
    /// <ul>
    /// <li>
    /// <p>Reference resolution: 1080p</p></li>
    /// <li>
    /// <p>Reference frame rate: 60 fps</p></li>
    /// <li>
    /// <p>Workload specifications: 8 vCPUs, 32 GB RAM, 24 GB VRAM</p></li>
    /// <li>
    /// <p>Tenancy: Supports 1 concurrent stream session</p></li>
    /// </ul></li>
    /// <li>
    /// <p><b> <code>gen4n_win2022</code> (NVIDIA, ultra)</b> Supports applications with extremely high 3D scene complexity. Runs applications on Microsoft Windows Server 2022 Base and supports DirectX 12. Compatible with most Unreal Engine 5.2 and 5.3 builds, 32-bit applications, and anti-cheat technology. Uses NVIDIA T4 Tensor GPU.</p>
    /// <ul>
    /// <li>
    /// <p>Reference resolution: 1080p</p></li>
    /// <li>
    /// <p>Reference frame rate: 60 fps</p></li>
    /// <li>
    /// <p>Workload specifications: 8 vCPUs, 32 GB RAM, 16 GB VRAM</p></li>
    /// <li>
    /// <p>Tenancy: Supports 1 concurrent stream session</p></li>
    /// </ul></li>
    /// <li>
    /// <p><b> <code>gen4n_high</code> (NVIDIA, high)</b> Supports applications with moderate to high 3D scene complexity. Uses NVIDIA T4 Tensor GPU.</p>
    /// <ul>
    /// <li>
    /// <p>Reference resolution: 1080p</p></li>
    /// <li>
    /// <p>Reference frame rate: 60 fps</p></li>
    /// <li>
    /// <p>Workload specifications: 4 vCPUs, 16 GB RAM, 8 GB VRAM</p></li>
    /// <li>
    /// <p>Tenancy: Supports up to 2 concurrent stream sessions</p></li>
    /// </ul></li>
    /// <li>
    /// <p><b> <code>gen4n_ultra</code> (NVIDIA, ultra)</b> Supports applications with high 3D scene complexity. Uses dedicated NVIDIA T4 Tensor GPU.</p>
    /// <ul>
    /// <li>
    /// <p>Reference resolution: 1080p</p></li>
    /// <li>
    /// <p>Reference frame rate: 60 fps</p></li>
    /// <li>
    /// <p>Workload specifications: 8 vCPUs, 32 GB RAM, 16 GB VRAM</p></li>
    /// <li>
    /// <p>Tenancy: Supports 1 concurrent stream session</p></li>
    /// </ul></li>
    /// </ul>
    pub fn stream_class(mut self, input: crate::types::StreamClass) -> Self {
        self.inner = self.inner.stream_class(input);
        self
    }
    /// <p>The target stream quality for sessions that are hosted in this stream group. Set a stream class that is appropriate to the type of content that you're streaming. Stream class determines the type of computing resources Amazon GameLift Streams uses and impacts the cost of streaming. The following options are available:</p>
    /// <p>A stream class can be one of the following:</p>
    /// <ul>
    /// <li>
    /// <p><b> <code>gen5n_win2022</code> (NVIDIA, ultra)</b> Supports applications with extremely high 3D scene complexity. Runs applications on Microsoft Windows Server 2022 Base and supports DirectX 12. Compatible with most Unreal Engine 5.x builds, 32-bit applications, and anti-cheat technology. Uses NVIDIA A10G Tensor GPU.</p>
    /// <ul>
    /// <li>
    /// <p>Reference resolution: 1080p</p></li>
    /// <li>
    /// <p>Reference frame rate: 60 fps</p></li>
    /// <li>
    /// <p>Workload specifications: 8 vCPUs, 32 GB RAM, 24 GB VRAM</p></li>
    /// <li>
    /// <p>Tenancy: Supports 1 concurrent stream session</p></li>
    /// </ul></li>
    /// <li>
    /// <p><b> <code>gen5n_high</code> (NVIDIA, high)</b> Supports applications with moderate to high 3D scene complexity. Uses NVIDIA A10G Tensor GPU.</p>
    /// <ul>
    /// <li>
    /// <p>Reference resolution: 1080p</p></li>
    /// <li>
    /// <p>Reference frame rate: 60 fps</p></li>
    /// <li>
    /// <p>Workload specifications: 4 vCPUs, 16 GB RAM, 12 GB VRAM</p></li>
    /// <li>
    /// <p>Tenancy: Supports up to 2 concurrent stream sessions</p></li>
    /// </ul></li>
    /// <li>
    /// <p><b> <code>gen5n_ultra</code> (NVIDIA, ultra)</b> Supports applications with extremely high 3D scene complexity. Uses dedicated NVIDIA A10G Tensor GPU.</p>
    /// <ul>
    /// <li>
    /// <p>Reference resolution: 1080p</p></li>
    /// <li>
    /// <p>Reference frame rate: 60 fps</p></li>
    /// <li>
    /// <p>Workload specifications: 8 vCPUs, 32 GB RAM, 24 GB VRAM</p></li>
    /// <li>
    /// <p>Tenancy: Supports 1 concurrent stream session</p></li>
    /// </ul></li>
    /// <li>
    /// <p><b> <code>gen4n_win2022</code> (NVIDIA, ultra)</b> Supports applications with extremely high 3D scene complexity. Runs applications on Microsoft Windows Server 2022 Base and supports DirectX 12. Compatible with most Unreal Engine 5.2 and 5.3 builds, 32-bit applications, and anti-cheat technology. Uses NVIDIA T4 Tensor GPU.</p>
    /// <ul>
    /// <li>
    /// <p>Reference resolution: 1080p</p></li>
    /// <li>
    /// <p>Reference frame rate: 60 fps</p></li>
    /// <li>
    /// <p>Workload specifications: 8 vCPUs, 32 GB RAM, 16 GB VRAM</p></li>
    /// <li>
    /// <p>Tenancy: Supports 1 concurrent stream session</p></li>
    /// </ul></li>
    /// <li>
    /// <p><b> <code>gen4n_high</code> (NVIDIA, high)</b> Supports applications with moderate to high 3D scene complexity. Uses NVIDIA T4 Tensor GPU.</p>
    /// <ul>
    /// <li>
    /// <p>Reference resolution: 1080p</p></li>
    /// <li>
    /// <p>Reference frame rate: 60 fps</p></li>
    /// <li>
    /// <p>Workload specifications: 4 vCPUs, 16 GB RAM, 8 GB VRAM</p></li>
    /// <li>
    /// <p>Tenancy: Supports up to 2 concurrent stream sessions</p></li>
    /// </ul></li>
    /// <li>
    /// <p><b> <code>gen4n_ultra</code> (NVIDIA, ultra)</b> Supports applications with high 3D scene complexity. Uses dedicated NVIDIA T4 Tensor GPU.</p>
    /// <ul>
    /// <li>
    /// <p>Reference resolution: 1080p</p></li>
    /// <li>
    /// <p>Reference frame rate: 60 fps</p></li>
    /// <li>
    /// <p>Workload specifications: 8 vCPUs, 32 GB RAM, 16 GB VRAM</p></li>
    /// <li>
    /// <p>Tenancy: Supports 1 concurrent stream session</p></li>
    /// </ul></li>
    /// </ul>
    pub fn set_stream_class(mut self, input: ::std::option::Option<crate::types::StreamClass>) -> Self {
        self.inner = self.inner.set_stream_class(input);
        self
    }
    /// <p>The target stream quality for sessions that are hosted in this stream group. Set a stream class that is appropriate to the type of content that you're streaming. Stream class determines the type of computing resources Amazon GameLift Streams uses and impacts the cost of streaming. The following options are available:</p>
    /// <p>A stream class can be one of the following:</p>
    /// <ul>
    /// <li>
    /// <p><b> <code>gen5n_win2022</code> (NVIDIA, ultra)</b> Supports applications with extremely high 3D scene complexity. Runs applications on Microsoft Windows Server 2022 Base and supports DirectX 12. Compatible with most Unreal Engine 5.x builds, 32-bit applications, and anti-cheat technology. Uses NVIDIA A10G Tensor GPU.</p>
    /// <ul>
    /// <li>
    /// <p>Reference resolution: 1080p</p></li>
    /// <li>
    /// <p>Reference frame rate: 60 fps</p></li>
    /// <li>
    /// <p>Workload specifications: 8 vCPUs, 32 GB RAM, 24 GB VRAM</p></li>
    /// <li>
    /// <p>Tenancy: Supports 1 concurrent stream session</p></li>
    /// </ul></li>
    /// <li>
    /// <p><b> <code>gen5n_high</code> (NVIDIA, high)</b> Supports applications with moderate to high 3D scene complexity. Uses NVIDIA A10G Tensor GPU.</p>
    /// <ul>
    /// <li>
    /// <p>Reference resolution: 1080p</p></li>
    /// <li>
    /// <p>Reference frame rate: 60 fps</p></li>
    /// <li>
    /// <p>Workload specifications: 4 vCPUs, 16 GB RAM, 12 GB VRAM</p></li>
    /// <li>
    /// <p>Tenancy: Supports up to 2 concurrent stream sessions</p></li>
    /// </ul></li>
    /// <li>
    /// <p><b> <code>gen5n_ultra</code> (NVIDIA, ultra)</b> Supports applications with extremely high 3D scene complexity. Uses dedicated NVIDIA A10G Tensor GPU.</p>
    /// <ul>
    /// <li>
    /// <p>Reference resolution: 1080p</p></li>
    /// <li>
    /// <p>Reference frame rate: 60 fps</p></li>
    /// <li>
    /// <p>Workload specifications: 8 vCPUs, 32 GB RAM, 24 GB VRAM</p></li>
    /// <li>
    /// <p>Tenancy: Supports 1 concurrent stream session</p></li>
    /// </ul></li>
    /// <li>
    /// <p><b> <code>gen4n_win2022</code> (NVIDIA, ultra)</b> Supports applications with extremely high 3D scene complexity. Runs applications on Microsoft Windows Server 2022 Base and supports DirectX 12. Compatible with most Unreal Engine 5.2 and 5.3 builds, 32-bit applications, and anti-cheat technology. Uses NVIDIA T4 Tensor GPU.</p>
    /// <ul>
    /// <li>
    /// <p>Reference resolution: 1080p</p></li>
    /// <li>
    /// <p>Reference frame rate: 60 fps</p></li>
    /// <li>
    /// <p>Workload specifications: 8 vCPUs, 32 GB RAM, 16 GB VRAM</p></li>
    /// <li>
    /// <p>Tenancy: Supports 1 concurrent stream session</p></li>
    /// </ul></li>
    /// <li>
    /// <p><b> <code>gen4n_high</code> (NVIDIA, high)</b> Supports applications with moderate to high 3D scene complexity. Uses NVIDIA T4 Tensor GPU.</p>
    /// <ul>
    /// <li>
    /// <p>Reference resolution: 1080p</p></li>
    /// <li>
    /// <p>Reference frame rate: 60 fps</p></li>
    /// <li>
    /// <p>Workload specifications: 4 vCPUs, 16 GB RAM, 8 GB VRAM</p></li>
    /// <li>
    /// <p>Tenancy: Supports up to 2 concurrent stream sessions</p></li>
    /// </ul></li>
    /// <li>
    /// <p><b> <code>gen4n_ultra</code> (NVIDIA, ultra)</b> Supports applications with high 3D scene complexity. Uses dedicated NVIDIA T4 Tensor GPU.</p>
    /// <ul>
    /// <li>
    /// <p>Reference resolution: 1080p</p></li>
    /// <li>
    /// <p>Reference frame rate: 60 fps</p></li>
    /// <li>
    /// <p>Workload specifications: 8 vCPUs, 32 GB RAM, 16 GB VRAM</p></li>
    /// <li>
    /// <p>Tenancy: Supports 1 concurrent stream session</p></li>
    /// </ul></li>
    /// </ul>
    pub fn get_stream_class(&self) -> &::std::option::Option<crate::types::StreamClass> {
        self.inner.get_stream_class()
    }
    /// <p>The unique identifier of the Amazon GameLift Streams application that you want to associate to a stream group as the default application. The application must be in <code>READY</code> status. By setting the default application identifier, you will optimize startup performance of this application in your stream group. Once set, this application cannot be disassociated from the stream group, unlike applications that are associated using AssociateApplications. If not set when creating a stream group, you will need to call AssociateApplications later, before you can start streaming.</p>
    pub fn default_application_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.default_application_identifier(input.into());
        self
    }
    /// <p>The unique identifier of the Amazon GameLift Streams application that you want to associate to a stream group as the default application. The application must be in <code>READY</code> status. By setting the default application identifier, you will optimize startup performance of this application in your stream group. Once set, this application cannot be disassociated from the stream group, unlike applications that are associated using AssociateApplications. If not set when creating a stream group, you will need to call AssociateApplications later, before you can start streaming.</p>
    pub fn set_default_application_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_default_application_identifier(input);
        self
    }
    /// <p>The unique identifier of the Amazon GameLift Streams application that you want to associate to a stream group as the default application. The application must be in <code>READY</code> status. By setting the default application identifier, you will optimize startup performance of this application in your stream group. Once set, this application cannot be disassociated from the stream group, unlike applications that are associated using AssociateApplications. If not set when creating a stream group, you will need to call AssociateApplications later, before you can start streaming.</p>
    pub fn get_default_application_identifier(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_default_application_identifier()
    }
    ///
    /// Appends an item to `LocationConfigurations`.
    ///
    /// To override the contents of this collection use [`set_location_configurations`](Self::set_location_configurations).
    ///
    /// <p>A set of one or more locations and the streaming capacity for each location.</p>
    pub fn location_configurations(mut self, input: crate::types::LocationConfiguration) -> Self {
        self.inner = self.inner.location_configurations(input);
        self
    }
    /// <p>A set of one or more locations and the streaming capacity for each location.</p>
    pub fn set_location_configurations(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::LocationConfiguration>>) -> Self {
        self.inner = self.inner.set_location_configurations(input);
        self
    }
    /// <p>A set of one or more locations and the streaming capacity for each location.</p>
    pub fn get_location_configurations(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::LocationConfiguration>> {
        self.inner.get_location_configurations()
    }
    ///
    /// Adds a key-value pair to `Tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>A list of labels to assign to the new stream group resource. Tags are developer-defined key-value pairs. It is useful to tag Amazon Web Services resources for resource management, access management, and cost allocation. See <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html"> Tagging Amazon Web Services Resources</a> in the <i>Amazon Web Services General Reference</i>. You can use <code>TagResource</code>, <code>UntagResource</code>, and <code>ListTagsForResource</code> to add, remove, and view tags on existing resources. The maximum tag limit might be lower than stated. See the <i>Amazon Web Services </i> for actual tagging limits.</p>
    pub fn tags(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.tags(k.into(), v.into());
        self
    }
    /// <p>A list of labels to assign to the new stream group resource. Tags are developer-defined key-value pairs. It is useful to tag Amazon Web Services resources for resource management, access management, and cost allocation. See <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html"> Tagging Amazon Web Services Resources</a> in the <i>Amazon Web Services General Reference</i>. You can use <code>TagResource</code>, <code>UntagResource</code>, and <code>ListTagsForResource</code> to add, remove, and view tags on existing resources. The maximum tag limit might be lower than stated. See the <i>Amazon Web Services </i> for actual tagging limits.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.inner = self.inner.set_tags(input);
        self
    }
    /// <p>A list of labels to assign to the new stream group resource. Tags are developer-defined key-value pairs. It is useful to tag Amazon Web Services resources for resource management, access management, and cost allocation. See <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html"> Tagging Amazon Web Services Resources</a> in the <i>Amazon Web Services General Reference</i>. You can use <code>TagResource</code>, <code>UntagResource</code>, and <code>ListTagsForResource</code> to add, remove, and view tags on existing resources. The maximum tag limit might be lower than stated. See the <i>Amazon Web Services </i> for actual tagging limits.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.inner.get_tags()
    }
    /// <p>A unique identifier that represents a client request. The request is idempotent, which ensures that an API request completes only once. When users send a request, Amazon GameLift Streams automatically populates this field.</p>
    pub fn client_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.client_token(input.into());
        self
    }
    /// <p>A unique identifier that represents a client request. The request is idempotent, which ensures that an API request completes only once. When users send a request, Amazon GameLift Streams automatically populates this field.</p>
    pub fn set_client_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_client_token(input);
        self
    }
    /// <p>A unique identifier that represents a client request. The request is idempotent, which ensures that an API request completes only once. When users send a request, Amazon GameLift Streams automatically populates this field.</p>
    pub fn get_client_token(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_client_token()
    }
}
