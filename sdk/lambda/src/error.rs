// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddLayerVersionPermissionError {
    pub kind: AddLayerVersionPermissionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddLayerVersionPermissionErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    PolicyLengthExceededError(crate::error::PolicyLengthExceededError),
    PreconditionFailedError(crate::error::PreconditionFailedError),
    ResourceConflictError(crate::error::ResourceConflictError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddLayerVersionPermissionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AddLayerVersionPermissionErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            AddLayerVersionPermissionErrorKind::PolicyLengthExceededError(_inner) => _inner.fmt(f),
            AddLayerVersionPermissionErrorKind::PreconditionFailedError(_inner) => _inner.fmt(f),
            AddLayerVersionPermissionErrorKind::ResourceConflictError(_inner) => _inner.fmt(f),
            AddLayerVersionPermissionErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            AddLayerVersionPermissionErrorKind::ServiceError(_inner) => _inner.fmt(f),
            AddLayerVersionPermissionErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            AddLayerVersionPermissionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AddLayerVersionPermissionError {
    fn code(&self) -> Option<&str> {
        AddLayerVersionPermissionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl AddLayerVersionPermissionError {
    pub fn new(kind: AddLayerVersionPermissionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AddLayerVersionPermissionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AddLayerVersionPermissionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for AddLayerVersionPermissionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AddLayerVersionPermissionErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            AddLayerVersionPermissionErrorKind::PolicyLengthExceededError(_inner) => Some(_inner),
            AddLayerVersionPermissionErrorKind::PreconditionFailedError(_inner) => Some(_inner),
            AddLayerVersionPermissionErrorKind::ResourceConflictError(_inner) => Some(_inner),
            AddLayerVersionPermissionErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            AddLayerVersionPermissionErrorKind::ServiceError(_inner) => Some(_inner),
            AddLayerVersionPermissionErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            AddLayerVersionPermissionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddPermissionError {
    pub kind: AddPermissionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddPermissionErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    PolicyLengthExceededError(crate::error::PolicyLengthExceededError),
    PreconditionFailedError(crate::error::PreconditionFailedError),
    ResourceConflictError(crate::error::ResourceConflictError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddPermissionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AddPermissionErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            AddPermissionErrorKind::PolicyLengthExceededError(_inner) => _inner.fmt(f),
            AddPermissionErrorKind::PreconditionFailedError(_inner) => _inner.fmt(f),
            AddPermissionErrorKind::ResourceConflictError(_inner) => _inner.fmt(f),
            AddPermissionErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            AddPermissionErrorKind::ServiceError(_inner) => _inner.fmt(f),
            AddPermissionErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            AddPermissionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AddPermissionError {
    fn code(&self) -> Option<&str> {
        AddPermissionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl AddPermissionError {
    pub fn new(kind: AddPermissionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AddPermissionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AddPermissionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for AddPermissionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AddPermissionErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            AddPermissionErrorKind::PolicyLengthExceededError(_inner) => Some(_inner),
            AddPermissionErrorKind::PreconditionFailedError(_inner) => Some(_inner),
            AddPermissionErrorKind::ResourceConflictError(_inner) => Some(_inner),
            AddPermissionErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            AddPermissionErrorKind::ServiceError(_inner) => Some(_inner),
            AddPermissionErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            AddPermissionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAliasError {
    pub kind: CreateAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAliasErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceConflictError(crate::error::ResourceConflictError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAliasErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            CreateAliasErrorKind::ResourceConflictError(_inner) => _inner.fmt(f),
            CreateAliasErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            CreateAliasErrorKind::ServiceError(_inner) => _inner.fmt(f),
            CreateAliasErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CreateAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateAliasError {
    fn code(&self) -> Option<&str> {
        CreateAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl CreateAliasError {
    pub fn new(kind: CreateAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for CreateAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAliasErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            CreateAliasErrorKind::ResourceConflictError(_inner) => Some(_inner),
            CreateAliasErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            CreateAliasErrorKind::ServiceError(_inner) => Some(_inner),
            CreateAliasErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CreateAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateCodeSigningConfigError {
    pub kind: CreateCodeSigningConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCodeSigningConfigErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ServiceError(crate::error::ServiceError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateCodeSigningConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateCodeSigningConfigErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            CreateCodeSigningConfigErrorKind::ServiceError(_inner) => _inner.fmt(f),
            CreateCodeSigningConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateCodeSigningConfigError {
    fn code(&self) -> Option<&str> {
        CreateCodeSigningConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl CreateCodeSigningConfigError {
    pub fn new(kind: CreateCodeSigningConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateCodeSigningConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateCodeSigningConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for CreateCodeSigningConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateCodeSigningConfigErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            CreateCodeSigningConfigErrorKind::ServiceError(_inner) => Some(_inner),
            CreateCodeSigningConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateEventSourceMappingError {
    pub kind: CreateEventSourceMappingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateEventSourceMappingErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceConflictError(crate::error::ResourceConflictError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateEventSourceMappingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateEventSourceMappingErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            CreateEventSourceMappingErrorKind::ResourceConflictError(_inner) => _inner.fmt(f),
            CreateEventSourceMappingErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            CreateEventSourceMappingErrorKind::ServiceError(_inner) => _inner.fmt(f),
            CreateEventSourceMappingErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CreateEventSourceMappingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateEventSourceMappingError {
    fn code(&self) -> Option<&str> {
        CreateEventSourceMappingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl CreateEventSourceMappingError {
    pub fn new(kind: CreateEventSourceMappingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateEventSourceMappingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateEventSourceMappingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for CreateEventSourceMappingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateEventSourceMappingErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            CreateEventSourceMappingErrorKind::ResourceConflictError(_inner) => Some(_inner),
            CreateEventSourceMappingErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            CreateEventSourceMappingErrorKind::ServiceError(_inner) => Some(_inner),
            CreateEventSourceMappingErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CreateEventSourceMappingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateFunctionError {
    pub kind: CreateFunctionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateFunctionErrorKind {
    CodeSigningConfigNotFoundError(crate::error::CodeSigningConfigNotFoundError),
    CodeStorageExceededError(crate::error::CodeStorageExceededError),
    CodeVerificationFailedError(crate::error::CodeVerificationFailedError),
    InvalidCodeSignatureError(crate::error::InvalidCodeSignatureError),
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceConflictError(crate::error::ResourceConflictError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateFunctionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateFunctionErrorKind::CodeSigningConfigNotFoundError(_inner) => _inner.fmt(f),
            CreateFunctionErrorKind::CodeStorageExceededError(_inner) => _inner.fmt(f),
            CreateFunctionErrorKind::CodeVerificationFailedError(_inner) => _inner.fmt(f),
            CreateFunctionErrorKind::InvalidCodeSignatureError(_inner) => _inner.fmt(f),
            CreateFunctionErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            CreateFunctionErrorKind::ResourceConflictError(_inner) => _inner.fmt(f),
            CreateFunctionErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            CreateFunctionErrorKind::ServiceError(_inner) => _inner.fmt(f),
            CreateFunctionErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CreateFunctionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateFunctionError {
    fn code(&self) -> Option<&str> {
        CreateFunctionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl CreateFunctionError {
    pub fn new(kind: CreateFunctionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateFunctionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateFunctionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for CreateFunctionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateFunctionErrorKind::CodeSigningConfigNotFoundError(_inner) => Some(_inner),
            CreateFunctionErrorKind::CodeStorageExceededError(_inner) => Some(_inner),
            CreateFunctionErrorKind::CodeVerificationFailedError(_inner) => Some(_inner),
            CreateFunctionErrorKind::InvalidCodeSignatureError(_inner) => Some(_inner),
            CreateFunctionErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            CreateFunctionErrorKind::ResourceConflictError(_inner) => Some(_inner),
            CreateFunctionErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            CreateFunctionErrorKind::ServiceError(_inner) => Some(_inner),
            CreateFunctionErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CreateFunctionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAliasError {
    pub kind: DeleteAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAliasErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceConflictError(crate::error::ResourceConflictError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAliasErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            DeleteAliasErrorKind::ResourceConflictError(_inner) => _inner.fmt(f),
            DeleteAliasErrorKind::ServiceError(_inner) => _inner.fmt(f),
            DeleteAliasErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAliasError {
    fn code(&self) -> Option<&str> {
        DeleteAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl DeleteAliasError {
    pub fn new(kind: DeleteAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for DeleteAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAliasErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            DeleteAliasErrorKind::ResourceConflictError(_inner) => Some(_inner),
            DeleteAliasErrorKind::ServiceError(_inner) => Some(_inner),
            DeleteAliasErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteCodeSigningConfigError {
    pub kind: DeleteCodeSigningConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCodeSigningConfigErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceConflictError(crate::error::ResourceConflictError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteCodeSigningConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteCodeSigningConfigErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            DeleteCodeSigningConfigErrorKind::ResourceConflictError(_inner) => _inner.fmt(f),
            DeleteCodeSigningConfigErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DeleteCodeSigningConfigErrorKind::ServiceError(_inner) => _inner.fmt(f),
            DeleteCodeSigningConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteCodeSigningConfigError {
    fn code(&self) -> Option<&str> {
        DeleteCodeSigningConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl DeleteCodeSigningConfigError {
    pub fn new(kind: DeleteCodeSigningConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteCodeSigningConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteCodeSigningConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for DeleteCodeSigningConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteCodeSigningConfigErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            DeleteCodeSigningConfigErrorKind::ResourceConflictError(_inner) => Some(_inner),
            DeleteCodeSigningConfigErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            DeleteCodeSigningConfigErrorKind::ServiceError(_inner) => Some(_inner),
            DeleteCodeSigningConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteEventSourceMappingError {
    pub kind: DeleteEventSourceMappingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteEventSourceMappingErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceInUseError(crate::error::ResourceInUseError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteEventSourceMappingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteEventSourceMappingErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            DeleteEventSourceMappingErrorKind::ResourceInUseError(_inner) => _inner.fmt(f),
            DeleteEventSourceMappingErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DeleteEventSourceMappingErrorKind::ServiceError(_inner) => _inner.fmt(f),
            DeleteEventSourceMappingErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteEventSourceMappingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteEventSourceMappingError {
    fn code(&self) -> Option<&str> {
        DeleteEventSourceMappingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl DeleteEventSourceMappingError {
    pub fn new(kind: DeleteEventSourceMappingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteEventSourceMappingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteEventSourceMappingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for DeleteEventSourceMappingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteEventSourceMappingErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            DeleteEventSourceMappingErrorKind::ResourceInUseError(_inner) => Some(_inner),
            DeleteEventSourceMappingErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            DeleteEventSourceMappingErrorKind::ServiceError(_inner) => Some(_inner),
            DeleteEventSourceMappingErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteEventSourceMappingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteFunctionError {
    pub kind: DeleteFunctionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteFunctionErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceConflictError(crate::error::ResourceConflictError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteFunctionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteFunctionErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            DeleteFunctionErrorKind::ResourceConflictError(_inner) => _inner.fmt(f),
            DeleteFunctionErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DeleteFunctionErrorKind::ServiceError(_inner) => _inner.fmt(f),
            DeleteFunctionErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteFunctionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteFunctionError {
    fn code(&self) -> Option<&str> {
        DeleteFunctionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl DeleteFunctionError {
    pub fn new(kind: DeleteFunctionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteFunctionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteFunctionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for DeleteFunctionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteFunctionErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            DeleteFunctionErrorKind::ResourceConflictError(_inner) => Some(_inner),
            DeleteFunctionErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            DeleteFunctionErrorKind::ServiceError(_inner) => Some(_inner),
            DeleteFunctionErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteFunctionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteFunctionCodeSigningConfigError {
    pub kind: DeleteFunctionCodeSigningConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteFunctionCodeSigningConfigErrorKind {
    CodeSigningConfigNotFoundError(crate::error::CodeSigningConfigNotFoundError),
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceConflictError(crate::error::ResourceConflictError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteFunctionCodeSigningConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteFunctionCodeSigningConfigErrorKind::CodeSigningConfigNotFoundError(_inner) => {
                _inner.fmt(f)
            }
            DeleteFunctionCodeSigningConfigErrorKind::InvalidParameterValueError(_inner) => {
                _inner.fmt(f)
            }
            DeleteFunctionCodeSigningConfigErrorKind::ResourceConflictError(_inner) => {
                _inner.fmt(f)
            }
            DeleteFunctionCodeSigningConfigErrorKind::ResourceNotFoundError(_inner) => {
                _inner.fmt(f)
            }
            DeleteFunctionCodeSigningConfigErrorKind::ServiceError(_inner) => _inner.fmt(f),
            DeleteFunctionCodeSigningConfigErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteFunctionCodeSigningConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteFunctionCodeSigningConfigError {
    fn code(&self) -> Option<&str> {
        DeleteFunctionCodeSigningConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl DeleteFunctionCodeSigningConfigError {
    pub fn new(kind: DeleteFunctionCodeSigningConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteFunctionCodeSigningConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteFunctionCodeSigningConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for DeleteFunctionCodeSigningConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteFunctionCodeSigningConfigErrorKind::CodeSigningConfigNotFoundError(_inner) => {
                Some(_inner)
            }
            DeleteFunctionCodeSigningConfigErrorKind::InvalidParameterValueError(_inner) => {
                Some(_inner)
            }
            DeleteFunctionCodeSigningConfigErrorKind::ResourceConflictError(_inner) => Some(_inner),
            DeleteFunctionCodeSigningConfigErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            DeleteFunctionCodeSigningConfigErrorKind::ServiceError(_inner) => Some(_inner),
            DeleteFunctionCodeSigningConfigErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteFunctionCodeSigningConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteFunctionConcurrencyError {
    pub kind: DeleteFunctionConcurrencyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteFunctionConcurrencyErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceConflictError(crate::error::ResourceConflictError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteFunctionConcurrencyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteFunctionConcurrencyErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            DeleteFunctionConcurrencyErrorKind::ResourceConflictError(_inner) => _inner.fmt(f),
            DeleteFunctionConcurrencyErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DeleteFunctionConcurrencyErrorKind::ServiceError(_inner) => _inner.fmt(f),
            DeleteFunctionConcurrencyErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteFunctionConcurrencyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteFunctionConcurrencyError {
    fn code(&self) -> Option<&str> {
        DeleteFunctionConcurrencyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl DeleteFunctionConcurrencyError {
    pub fn new(kind: DeleteFunctionConcurrencyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteFunctionConcurrencyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteFunctionConcurrencyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for DeleteFunctionConcurrencyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteFunctionConcurrencyErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            DeleteFunctionConcurrencyErrorKind::ResourceConflictError(_inner) => Some(_inner),
            DeleteFunctionConcurrencyErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            DeleteFunctionConcurrencyErrorKind::ServiceError(_inner) => Some(_inner),
            DeleteFunctionConcurrencyErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteFunctionConcurrencyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteFunctionEventInvokeConfigError {
    pub kind: DeleteFunctionEventInvokeConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteFunctionEventInvokeConfigErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteFunctionEventInvokeConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteFunctionEventInvokeConfigErrorKind::InvalidParameterValueError(_inner) => {
                _inner.fmt(f)
            }
            DeleteFunctionEventInvokeConfigErrorKind::ResourceNotFoundError(_inner) => {
                _inner.fmt(f)
            }
            DeleteFunctionEventInvokeConfigErrorKind::ServiceError(_inner) => _inner.fmt(f),
            DeleteFunctionEventInvokeConfigErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteFunctionEventInvokeConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteFunctionEventInvokeConfigError {
    fn code(&self) -> Option<&str> {
        DeleteFunctionEventInvokeConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl DeleteFunctionEventInvokeConfigError {
    pub fn new(kind: DeleteFunctionEventInvokeConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteFunctionEventInvokeConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteFunctionEventInvokeConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for DeleteFunctionEventInvokeConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteFunctionEventInvokeConfigErrorKind::InvalidParameterValueError(_inner) => {
                Some(_inner)
            }
            DeleteFunctionEventInvokeConfigErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            DeleteFunctionEventInvokeConfigErrorKind::ServiceError(_inner) => Some(_inner),
            DeleteFunctionEventInvokeConfigErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteFunctionEventInvokeConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteLayerVersionError {
    pub kind: DeleteLayerVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteLayerVersionErrorKind {
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteLayerVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteLayerVersionErrorKind::ServiceError(_inner) => _inner.fmt(f),
            DeleteLayerVersionErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteLayerVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteLayerVersionError {
    fn code(&self) -> Option<&str> {
        DeleteLayerVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl DeleteLayerVersionError {
    pub fn new(kind: DeleteLayerVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteLayerVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteLayerVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for DeleteLayerVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteLayerVersionErrorKind::ServiceError(_inner) => Some(_inner),
            DeleteLayerVersionErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteLayerVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteProvisionedConcurrencyConfigError {
    pub kind: DeleteProvisionedConcurrencyConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteProvisionedConcurrencyConfigErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceConflictError(crate::error::ResourceConflictError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteProvisionedConcurrencyConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteProvisionedConcurrencyConfigErrorKind::InvalidParameterValueError(_inner) => {
                _inner.fmt(f)
            }
            DeleteProvisionedConcurrencyConfigErrorKind::ResourceConflictError(_inner) => {
                _inner.fmt(f)
            }
            DeleteProvisionedConcurrencyConfigErrorKind::ResourceNotFoundError(_inner) => {
                _inner.fmt(f)
            }
            DeleteProvisionedConcurrencyConfigErrorKind::ServiceError(_inner) => _inner.fmt(f),
            DeleteProvisionedConcurrencyConfigErrorKind::TooManyRequestsError(_inner) => {
                _inner.fmt(f)
            }
            DeleteProvisionedConcurrencyConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteProvisionedConcurrencyConfigError {
    fn code(&self) -> Option<&str> {
        DeleteProvisionedConcurrencyConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl DeleteProvisionedConcurrencyConfigError {
    pub fn new(
        kind: DeleteProvisionedConcurrencyConfigErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteProvisionedConcurrencyConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteProvisionedConcurrencyConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for DeleteProvisionedConcurrencyConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteProvisionedConcurrencyConfigErrorKind::InvalidParameterValueError(_inner) => {
                Some(_inner)
            }
            DeleteProvisionedConcurrencyConfigErrorKind::ResourceConflictError(_inner) => {
                Some(_inner)
            }
            DeleteProvisionedConcurrencyConfigErrorKind::ResourceNotFoundError(_inner) => {
                Some(_inner)
            }
            DeleteProvisionedConcurrencyConfigErrorKind::ServiceError(_inner) => Some(_inner),
            DeleteProvisionedConcurrencyConfigErrorKind::TooManyRequestsError(_inner) => {
                Some(_inner)
            }
            DeleteProvisionedConcurrencyConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAccountSettingsError {
    pub kind: GetAccountSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAccountSettingsErrorKind {
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAccountSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAccountSettingsErrorKind::ServiceError(_inner) => _inner.fmt(f),
            GetAccountSettingsErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetAccountSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAccountSettingsError {
    fn code(&self) -> Option<&str> {
        GetAccountSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetAccountSettingsError {
    pub fn new(kind: GetAccountSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAccountSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAccountSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetAccountSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAccountSettingsErrorKind::ServiceError(_inner) => Some(_inner),
            GetAccountSettingsErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetAccountSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAliasError {
    pub kind: GetAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAliasErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAliasErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            GetAliasErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            GetAliasErrorKind::ServiceError(_inner) => _inner.fmt(f),
            GetAliasErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAliasError {
    fn code(&self) -> Option<&str> {
        GetAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetAliasError {
    pub fn new(kind: GetAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAliasErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            GetAliasErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            GetAliasErrorKind::ServiceError(_inner) => Some(_inner),
            GetAliasErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCodeSigningConfigError {
    pub kind: GetCodeSigningConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCodeSigningConfigErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCodeSigningConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCodeSigningConfigErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            GetCodeSigningConfigErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            GetCodeSigningConfigErrorKind::ServiceError(_inner) => _inner.fmt(f),
            GetCodeSigningConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetCodeSigningConfigError {
    fn code(&self) -> Option<&str> {
        GetCodeSigningConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetCodeSigningConfigError {
    pub fn new(kind: GetCodeSigningConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCodeSigningConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCodeSigningConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetCodeSigningConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCodeSigningConfigErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            GetCodeSigningConfigErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            GetCodeSigningConfigErrorKind::ServiceError(_inner) => Some(_inner),
            GetCodeSigningConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetEventSourceMappingError {
    pub kind: GetEventSourceMappingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetEventSourceMappingErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetEventSourceMappingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetEventSourceMappingErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            GetEventSourceMappingErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            GetEventSourceMappingErrorKind::ServiceError(_inner) => _inner.fmt(f),
            GetEventSourceMappingErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetEventSourceMappingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetEventSourceMappingError {
    fn code(&self) -> Option<&str> {
        GetEventSourceMappingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetEventSourceMappingError {
    pub fn new(kind: GetEventSourceMappingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetEventSourceMappingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetEventSourceMappingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetEventSourceMappingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetEventSourceMappingErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            GetEventSourceMappingErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            GetEventSourceMappingErrorKind::ServiceError(_inner) => Some(_inner),
            GetEventSourceMappingErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetEventSourceMappingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetFunctionError {
    pub kind: GetFunctionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFunctionErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetFunctionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetFunctionErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            GetFunctionErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            GetFunctionErrorKind::ServiceError(_inner) => _inner.fmt(f),
            GetFunctionErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetFunctionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetFunctionError {
    fn code(&self) -> Option<&str> {
        GetFunctionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetFunctionError {
    pub fn new(kind: GetFunctionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetFunctionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetFunctionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetFunctionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetFunctionErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            GetFunctionErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            GetFunctionErrorKind::ServiceError(_inner) => Some(_inner),
            GetFunctionErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetFunctionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetFunctionCodeSigningConfigError {
    pub kind: GetFunctionCodeSigningConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFunctionCodeSigningConfigErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetFunctionCodeSigningConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetFunctionCodeSigningConfigErrorKind::InvalidParameterValueError(_inner) => {
                _inner.fmt(f)
            }
            GetFunctionCodeSigningConfigErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            GetFunctionCodeSigningConfigErrorKind::ServiceError(_inner) => _inner.fmt(f),
            GetFunctionCodeSigningConfigErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetFunctionCodeSigningConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetFunctionCodeSigningConfigError {
    fn code(&self) -> Option<&str> {
        GetFunctionCodeSigningConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetFunctionCodeSigningConfigError {
    pub fn new(kind: GetFunctionCodeSigningConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetFunctionCodeSigningConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetFunctionCodeSigningConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetFunctionCodeSigningConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetFunctionCodeSigningConfigErrorKind::InvalidParameterValueError(_inner) => {
                Some(_inner)
            }
            GetFunctionCodeSigningConfigErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            GetFunctionCodeSigningConfigErrorKind::ServiceError(_inner) => Some(_inner),
            GetFunctionCodeSigningConfigErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetFunctionCodeSigningConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetFunctionConcurrencyError {
    pub kind: GetFunctionConcurrencyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFunctionConcurrencyErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetFunctionConcurrencyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetFunctionConcurrencyErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            GetFunctionConcurrencyErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            GetFunctionConcurrencyErrorKind::ServiceError(_inner) => _inner.fmt(f),
            GetFunctionConcurrencyErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetFunctionConcurrencyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetFunctionConcurrencyError {
    fn code(&self) -> Option<&str> {
        GetFunctionConcurrencyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetFunctionConcurrencyError {
    pub fn new(kind: GetFunctionConcurrencyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetFunctionConcurrencyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetFunctionConcurrencyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetFunctionConcurrencyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetFunctionConcurrencyErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            GetFunctionConcurrencyErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            GetFunctionConcurrencyErrorKind::ServiceError(_inner) => Some(_inner),
            GetFunctionConcurrencyErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetFunctionConcurrencyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetFunctionConfigurationError {
    pub kind: GetFunctionConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFunctionConfigurationErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetFunctionConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetFunctionConfigurationErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            GetFunctionConfigurationErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            GetFunctionConfigurationErrorKind::ServiceError(_inner) => _inner.fmt(f),
            GetFunctionConfigurationErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetFunctionConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetFunctionConfigurationError {
    fn code(&self) -> Option<&str> {
        GetFunctionConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetFunctionConfigurationError {
    pub fn new(kind: GetFunctionConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetFunctionConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetFunctionConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetFunctionConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetFunctionConfigurationErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            GetFunctionConfigurationErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            GetFunctionConfigurationErrorKind::ServiceError(_inner) => Some(_inner),
            GetFunctionConfigurationErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetFunctionConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetFunctionEventInvokeConfigError {
    pub kind: GetFunctionEventInvokeConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFunctionEventInvokeConfigErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetFunctionEventInvokeConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetFunctionEventInvokeConfigErrorKind::InvalidParameterValueError(_inner) => {
                _inner.fmt(f)
            }
            GetFunctionEventInvokeConfigErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            GetFunctionEventInvokeConfigErrorKind::ServiceError(_inner) => _inner.fmt(f),
            GetFunctionEventInvokeConfigErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetFunctionEventInvokeConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetFunctionEventInvokeConfigError {
    fn code(&self) -> Option<&str> {
        GetFunctionEventInvokeConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetFunctionEventInvokeConfigError {
    pub fn new(kind: GetFunctionEventInvokeConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetFunctionEventInvokeConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetFunctionEventInvokeConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetFunctionEventInvokeConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetFunctionEventInvokeConfigErrorKind::InvalidParameterValueError(_inner) => {
                Some(_inner)
            }
            GetFunctionEventInvokeConfigErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            GetFunctionEventInvokeConfigErrorKind::ServiceError(_inner) => Some(_inner),
            GetFunctionEventInvokeConfigErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetFunctionEventInvokeConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetLayerVersionError {
    pub kind: GetLayerVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetLayerVersionErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetLayerVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetLayerVersionErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            GetLayerVersionErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            GetLayerVersionErrorKind::ServiceError(_inner) => _inner.fmt(f),
            GetLayerVersionErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetLayerVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetLayerVersionError {
    fn code(&self) -> Option<&str> {
        GetLayerVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetLayerVersionError {
    pub fn new(kind: GetLayerVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetLayerVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetLayerVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetLayerVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetLayerVersionErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            GetLayerVersionErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            GetLayerVersionErrorKind::ServiceError(_inner) => Some(_inner),
            GetLayerVersionErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetLayerVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetLayerVersionByArnError {
    pub kind: GetLayerVersionByArnErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetLayerVersionByArnErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetLayerVersionByArnError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetLayerVersionByArnErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            GetLayerVersionByArnErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            GetLayerVersionByArnErrorKind::ServiceError(_inner) => _inner.fmt(f),
            GetLayerVersionByArnErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetLayerVersionByArnErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetLayerVersionByArnError {
    fn code(&self) -> Option<&str> {
        GetLayerVersionByArnError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetLayerVersionByArnError {
    pub fn new(kind: GetLayerVersionByArnErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetLayerVersionByArnErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetLayerVersionByArnErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetLayerVersionByArnError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetLayerVersionByArnErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            GetLayerVersionByArnErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            GetLayerVersionByArnErrorKind::ServiceError(_inner) => Some(_inner),
            GetLayerVersionByArnErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetLayerVersionByArnErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetLayerVersionPolicyError {
    pub kind: GetLayerVersionPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetLayerVersionPolicyErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetLayerVersionPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetLayerVersionPolicyErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            GetLayerVersionPolicyErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            GetLayerVersionPolicyErrorKind::ServiceError(_inner) => _inner.fmt(f),
            GetLayerVersionPolicyErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetLayerVersionPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetLayerVersionPolicyError {
    fn code(&self) -> Option<&str> {
        GetLayerVersionPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetLayerVersionPolicyError {
    pub fn new(kind: GetLayerVersionPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetLayerVersionPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetLayerVersionPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetLayerVersionPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetLayerVersionPolicyErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            GetLayerVersionPolicyErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            GetLayerVersionPolicyErrorKind::ServiceError(_inner) => Some(_inner),
            GetLayerVersionPolicyErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetLayerVersionPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPolicyError {
    pub kind: GetPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPolicyErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPolicyErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            GetPolicyErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            GetPolicyErrorKind::ServiceError(_inner) => _inner.fmt(f),
            GetPolicyErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetPolicyError {
    fn code(&self) -> Option<&str> {
        GetPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetPolicyError {
    pub fn new(kind: GetPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPolicyErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            GetPolicyErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            GetPolicyErrorKind::ServiceError(_inner) => Some(_inner),
            GetPolicyErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetProvisionedConcurrencyConfigError {
    pub kind: GetProvisionedConcurrencyConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetProvisionedConcurrencyConfigErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ProvisionedConcurrencyConfigNotFoundError(
        crate::error::ProvisionedConcurrencyConfigNotFoundError,
    ),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetProvisionedConcurrencyConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetProvisionedConcurrencyConfigErrorKind::InvalidParameterValueError(_inner) => {
                _inner.fmt(f)
            }
            GetProvisionedConcurrencyConfigErrorKind::ProvisionedConcurrencyConfigNotFoundError(
                _inner,
            ) => _inner.fmt(f),
            GetProvisionedConcurrencyConfigErrorKind::ResourceNotFoundError(_inner) => {
                _inner.fmt(f)
            }
            GetProvisionedConcurrencyConfigErrorKind::ServiceError(_inner) => _inner.fmt(f),
            GetProvisionedConcurrencyConfigErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetProvisionedConcurrencyConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetProvisionedConcurrencyConfigError {
    fn code(&self) -> Option<&str> {
        GetProvisionedConcurrencyConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetProvisionedConcurrencyConfigError {
    pub fn new(kind: GetProvisionedConcurrencyConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetProvisionedConcurrencyConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetProvisionedConcurrencyConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetProvisionedConcurrencyConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetProvisionedConcurrencyConfigErrorKind::InvalidParameterValueError(_inner) => {
                Some(_inner)
            }
            GetProvisionedConcurrencyConfigErrorKind::ProvisionedConcurrencyConfigNotFoundError(
                _inner,
            ) => Some(_inner),
            GetProvisionedConcurrencyConfigErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            GetProvisionedConcurrencyConfigErrorKind::ServiceError(_inner) => Some(_inner),
            GetProvisionedConcurrencyConfigErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetProvisionedConcurrencyConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct InvokeError {
    pub kind: InvokeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum InvokeErrorKind {
    EC2AccessDeniedError(crate::error::EC2AccessDeniedError),
    EC2ThrottledError(crate::error::EC2ThrottledError),
    EC2UnexpectedError(crate::error::EC2UnexpectedError),
    EFSIOError(crate::error::EFSIOError),
    EFSMountConnectivityError(crate::error::EFSMountConnectivityError),
    EFSMountFailureError(crate::error::EFSMountFailureError),
    EFSMountTimeoutError(crate::error::EFSMountTimeoutError),
    ENILimitReachedError(crate::error::ENILimitReachedError),
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    InvalidRequestContentError(crate::error::InvalidRequestContentError),
    InvalidRuntimeError(crate::error::InvalidRuntimeError),
    InvalidSecurityGroupIDError(crate::error::InvalidSecurityGroupIDError),
    InvalidSubnetIDError(crate::error::InvalidSubnetIDError),
    InvalidZipFileError(crate::error::InvalidZipFileError),
    KMSAccessDeniedError(crate::error::KMSAccessDeniedError),
    KMSDisabledError(crate::error::KMSDisabledError),
    KMSInvalidStateError(crate::error::KMSInvalidStateError),
    KMSNotFoundError(crate::error::KMSNotFoundError),
    RequestTooLargeError(crate::error::RequestTooLargeError),
    ResourceConflictError(crate::error::ResourceConflictError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ResourceNotReadyError(crate::error::ResourceNotReadyError),
    ServiceError(crate::error::ServiceError),
    SubnetIPAddressLimitReachedError(crate::error::SubnetIPAddressLimitReachedError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnsupportedMediaTypeError(crate::error::UnsupportedMediaTypeError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for InvokeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            InvokeErrorKind::EC2AccessDeniedError(_inner) => _inner.fmt(f),
            InvokeErrorKind::EC2ThrottledError(_inner) => _inner.fmt(f),
            InvokeErrorKind::EC2UnexpectedError(_inner) => _inner.fmt(f),
            InvokeErrorKind::EFSIOError(_inner) => _inner.fmt(f),
            InvokeErrorKind::EFSMountConnectivityError(_inner) => _inner.fmt(f),
            InvokeErrorKind::EFSMountFailureError(_inner) => _inner.fmt(f),
            InvokeErrorKind::EFSMountTimeoutError(_inner) => _inner.fmt(f),
            InvokeErrorKind::ENILimitReachedError(_inner) => _inner.fmt(f),
            InvokeErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            InvokeErrorKind::InvalidRequestContentError(_inner) => _inner.fmt(f),
            InvokeErrorKind::InvalidRuntimeError(_inner) => _inner.fmt(f),
            InvokeErrorKind::InvalidSecurityGroupIDError(_inner) => _inner.fmt(f),
            InvokeErrorKind::InvalidSubnetIDError(_inner) => _inner.fmt(f),
            InvokeErrorKind::InvalidZipFileError(_inner) => _inner.fmt(f),
            InvokeErrorKind::KMSAccessDeniedError(_inner) => _inner.fmt(f),
            InvokeErrorKind::KMSDisabledError(_inner) => _inner.fmt(f),
            InvokeErrorKind::KMSInvalidStateError(_inner) => _inner.fmt(f),
            InvokeErrorKind::KMSNotFoundError(_inner) => _inner.fmt(f),
            InvokeErrorKind::RequestTooLargeError(_inner) => _inner.fmt(f),
            InvokeErrorKind::ResourceConflictError(_inner) => _inner.fmt(f),
            InvokeErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            InvokeErrorKind::ResourceNotReadyError(_inner) => _inner.fmt(f),
            InvokeErrorKind::ServiceError(_inner) => _inner.fmt(f),
            InvokeErrorKind::SubnetIPAddressLimitReachedError(_inner) => _inner.fmt(f),
            InvokeErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            InvokeErrorKind::UnsupportedMediaTypeError(_inner) => _inner.fmt(f),
            InvokeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for InvokeError {
    fn code(&self) -> Option<&str> {
        InvokeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl InvokeError {
    pub fn new(kind: InvokeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: InvokeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: InvokeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for InvokeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            InvokeErrorKind::EC2AccessDeniedError(_inner) => Some(_inner),
            InvokeErrorKind::EC2ThrottledError(_inner) => Some(_inner),
            InvokeErrorKind::EC2UnexpectedError(_inner) => Some(_inner),
            InvokeErrorKind::EFSIOError(_inner) => Some(_inner),
            InvokeErrorKind::EFSMountConnectivityError(_inner) => Some(_inner),
            InvokeErrorKind::EFSMountFailureError(_inner) => Some(_inner),
            InvokeErrorKind::EFSMountTimeoutError(_inner) => Some(_inner),
            InvokeErrorKind::ENILimitReachedError(_inner) => Some(_inner),
            InvokeErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            InvokeErrorKind::InvalidRequestContentError(_inner) => Some(_inner),
            InvokeErrorKind::InvalidRuntimeError(_inner) => Some(_inner),
            InvokeErrorKind::InvalidSecurityGroupIDError(_inner) => Some(_inner),
            InvokeErrorKind::InvalidSubnetIDError(_inner) => Some(_inner),
            InvokeErrorKind::InvalidZipFileError(_inner) => Some(_inner),
            InvokeErrorKind::KMSAccessDeniedError(_inner) => Some(_inner),
            InvokeErrorKind::KMSDisabledError(_inner) => Some(_inner),
            InvokeErrorKind::KMSInvalidStateError(_inner) => Some(_inner),
            InvokeErrorKind::KMSNotFoundError(_inner) => Some(_inner),
            InvokeErrorKind::RequestTooLargeError(_inner) => Some(_inner),
            InvokeErrorKind::ResourceConflictError(_inner) => Some(_inner),
            InvokeErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            InvokeErrorKind::ResourceNotReadyError(_inner) => Some(_inner),
            InvokeErrorKind::ServiceError(_inner) => Some(_inner),
            InvokeErrorKind::SubnetIPAddressLimitReachedError(_inner) => Some(_inner),
            InvokeErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            InvokeErrorKind::UnsupportedMediaTypeError(_inner) => Some(_inner),
            InvokeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct InvokeAsyncError {
    pub kind: InvokeAsyncErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum InvokeAsyncErrorKind {
    InvalidRequestContentError(crate::error::InvalidRequestContentError),
    InvalidRuntimeError(crate::error::InvalidRuntimeError),
    ResourceConflictError(crate::error::ResourceConflictError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for InvokeAsyncError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            InvokeAsyncErrorKind::InvalidRequestContentError(_inner) => _inner.fmt(f),
            InvokeAsyncErrorKind::InvalidRuntimeError(_inner) => _inner.fmt(f),
            InvokeAsyncErrorKind::ResourceConflictError(_inner) => _inner.fmt(f),
            InvokeAsyncErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            InvokeAsyncErrorKind::ServiceError(_inner) => _inner.fmt(f),
            InvokeAsyncErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for InvokeAsyncError {
    fn code(&self) -> Option<&str> {
        InvokeAsyncError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl InvokeAsyncError {
    pub fn new(kind: InvokeAsyncErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: InvokeAsyncErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: InvokeAsyncErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for InvokeAsyncError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            InvokeAsyncErrorKind::InvalidRequestContentError(_inner) => Some(_inner),
            InvokeAsyncErrorKind::InvalidRuntimeError(_inner) => Some(_inner),
            InvokeAsyncErrorKind::ResourceConflictError(_inner) => Some(_inner),
            InvokeAsyncErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            InvokeAsyncErrorKind::ServiceError(_inner) => Some(_inner),
            InvokeAsyncErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAliasesError {
    pub kind: ListAliasesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAliasesErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAliasesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAliasesErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            ListAliasesErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            ListAliasesErrorKind::ServiceError(_inner) => _inner.fmt(f),
            ListAliasesErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            ListAliasesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAliasesError {
    fn code(&self) -> Option<&str> {
        ListAliasesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl ListAliasesError {
    pub fn new(kind: ListAliasesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAliasesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAliasesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for ListAliasesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAliasesErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            ListAliasesErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            ListAliasesErrorKind::ServiceError(_inner) => Some(_inner),
            ListAliasesErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            ListAliasesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListCodeSigningConfigsError {
    pub kind: ListCodeSigningConfigsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListCodeSigningConfigsErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ServiceError(crate::error::ServiceError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListCodeSigningConfigsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListCodeSigningConfigsErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            ListCodeSigningConfigsErrorKind::ServiceError(_inner) => _inner.fmt(f),
            ListCodeSigningConfigsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListCodeSigningConfigsError {
    fn code(&self) -> Option<&str> {
        ListCodeSigningConfigsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl ListCodeSigningConfigsError {
    pub fn new(kind: ListCodeSigningConfigsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListCodeSigningConfigsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListCodeSigningConfigsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for ListCodeSigningConfigsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListCodeSigningConfigsErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            ListCodeSigningConfigsErrorKind::ServiceError(_inner) => Some(_inner),
            ListCodeSigningConfigsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListEventSourceMappingsError {
    pub kind: ListEventSourceMappingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListEventSourceMappingsErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListEventSourceMappingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListEventSourceMappingsErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            ListEventSourceMappingsErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            ListEventSourceMappingsErrorKind::ServiceError(_inner) => _inner.fmt(f),
            ListEventSourceMappingsErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            ListEventSourceMappingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListEventSourceMappingsError {
    fn code(&self) -> Option<&str> {
        ListEventSourceMappingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl ListEventSourceMappingsError {
    pub fn new(kind: ListEventSourceMappingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListEventSourceMappingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListEventSourceMappingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for ListEventSourceMappingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListEventSourceMappingsErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            ListEventSourceMappingsErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            ListEventSourceMappingsErrorKind::ServiceError(_inner) => Some(_inner),
            ListEventSourceMappingsErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            ListEventSourceMappingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListFunctionEventInvokeConfigsError {
    pub kind: ListFunctionEventInvokeConfigsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListFunctionEventInvokeConfigsErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListFunctionEventInvokeConfigsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListFunctionEventInvokeConfigsErrorKind::InvalidParameterValueError(_inner) => {
                _inner.fmt(f)
            }
            ListFunctionEventInvokeConfigsErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            ListFunctionEventInvokeConfigsErrorKind::ServiceError(_inner) => _inner.fmt(f),
            ListFunctionEventInvokeConfigsErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            ListFunctionEventInvokeConfigsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListFunctionEventInvokeConfigsError {
    fn code(&self) -> Option<&str> {
        ListFunctionEventInvokeConfigsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl ListFunctionEventInvokeConfigsError {
    pub fn new(kind: ListFunctionEventInvokeConfigsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListFunctionEventInvokeConfigsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListFunctionEventInvokeConfigsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for ListFunctionEventInvokeConfigsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListFunctionEventInvokeConfigsErrorKind::InvalidParameterValueError(_inner) => {
                Some(_inner)
            }
            ListFunctionEventInvokeConfigsErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            ListFunctionEventInvokeConfigsErrorKind::ServiceError(_inner) => Some(_inner),
            ListFunctionEventInvokeConfigsErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            ListFunctionEventInvokeConfigsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListFunctionsError {
    pub kind: ListFunctionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListFunctionsErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListFunctionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListFunctionsErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            ListFunctionsErrorKind::ServiceError(_inner) => _inner.fmt(f),
            ListFunctionsErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            ListFunctionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListFunctionsError {
    fn code(&self) -> Option<&str> {
        ListFunctionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl ListFunctionsError {
    pub fn new(kind: ListFunctionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListFunctionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListFunctionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for ListFunctionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListFunctionsErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            ListFunctionsErrorKind::ServiceError(_inner) => Some(_inner),
            ListFunctionsErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            ListFunctionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListFunctionsByCodeSigningConfigError {
    pub kind: ListFunctionsByCodeSigningConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListFunctionsByCodeSigningConfigErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListFunctionsByCodeSigningConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListFunctionsByCodeSigningConfigErrorKind::InvalidParameterValueError(_inner) => {
                _inner.fmt(f)
            }
            ListFunctionsByCodeSigningConfigErrorKind::ResourceNotFoundError(_inner) => {
                _inner.fmt(f)
            }
            ListFunctionsByCodeSigningConfigErrorKind::ServiceError(_inner) => _inner.fmt(f),
            ListFunctionsByCodeSigningConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListFunctionsByCodeSigningConfigError {
    fn code(&self) -> Option<&str> {
        ListFunctionsByCodeSigningConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl ListFunctionsByCodeSigningConfigError {
    pub fn new(kind: ListFunctionsByCodeSigningConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListFunctionsByCodeSigningConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListFunctionsByCodeSigningConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for ListFunctionsByCodeSigningConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListFunctionsByCodeSigningConfigErrorKind::InvalidParameterValueError(_inner) => {
                Some(_inner)
            }
            ListFunctionsByCodeSigningConfigErrorKind::ResourceNotFoundError(_inner) => {
                Some(_inner)
            }
            ListFunctionsByCodeSigningConfigErrorKind::ServiceError(_inner) => Some(_inner),
            ListFunctionsByCodeSigningConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListLayersError {
    pub kind: ListLayersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListLayersErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListLayersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListLayersErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            ListLayersErrorKind::ServiceError(_inner) => _inner.fmt(f),
            ListLayersErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            ListLayersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListLayersError {
    fn code(&self) -> Option<&str> {
        ListLayersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl ListLayersError {
    pub fn new(kind: ListLayersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListLayersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListLayersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for ListLayersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListLayersErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            ListLayersErrorKind::ServiceError(_inner) => Some(_inner),
            ListLayersErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            ListLayersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListLayerVersionsError {
    pub kind: ListLayerVersionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListLayerVersionsErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListLayerVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListLayerVersionsErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            ListLayerVersionsErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            ListLayerVersionsErrorKind::ServiceError(_inner) => _inner.fmt(f),
            ListLayerVersionsErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            ListLayerVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListLayerVersionsError {
    fn code(&self) -> Option<&str> {
        ListLayerVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl ListLayerVersionsError {
    pub fn new(kind: ListLayerVersionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListLayerVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListLayerVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for ListLayerVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListLayerVersionsErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            ListLayerVersionsErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            ListLayerVersionsErrorKind::ServiceError(_inner) => Some(_inner),
            ListLayerVersionsErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            ListLayerVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListProvisionedConcurrencyConfigsError {
    pub kind: ListProvisionedConcurrencyConfigsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListProvisionedConcurrencyConfigsErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListProvisionedConcurrencyConfigsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListProvisionedConcurrencyConfigsErrorKind::InvalidParameterValueError(_inner) => {
                _inner.fmt(f)
            }
            ListProvisionedConcurrencyConfigsErrorKind::ResourceNotFoundError(_inner) => {
                _inner.fmt(f)
            }
            ListProvisionedConcurrencyConfigsErrorKind::ServiceError(_inner) => _inner.fmt(f),
            ListProvisionedConcurrencyConfigsErrorKind::TooManyRequestsError(_inner) => {
                _inner.fmt(f)
            }
            ListProvisionedConcurrencyConfigsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListProvisionedConcurrencyConfigsError {
    fn code(&self) -> Option<&str> {
        ListProvisionedConcurrencyConfigsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl ListProvisionedConcurrencyConfigsError {
    pub fn new(
        kind: ListProvisionedConcurrencyConfigsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListProvisionedConcurrencyConfigsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListProvisionedConcurrencyConfigsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for ListProvisionedConcurrencyConfigsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListProvisionedConcurrencyConfigsErrorKind::InvalidParameterValueError(_inner) => {
                Some(_inner)
            }
            ListProvisionedConcurrencyConfigsErrorKind::ResourceNotFoundError(_inner) => {
                Some(_inner)
            }
            ListProvisionedConcurrencyConfigsErrorKind::ServiceError(_inner) => Some(_inner),
            ListProvisionedConcurrencyConfigsErrorKind::TooManyRequestsError(_inner) => {
                Some(_inner)
            }
            ListProvisionedConcurrencyConfigsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsError {
    pub kind: ListTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            ListTagsErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            ListTagsErrorKind::ServiceError(_inner) => _inner.fmt(f),
            ListTagsErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            ListTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsError {
    fn code(&self) -> Option<&str> {
        ListTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl ListTagsError {
    pub fn new(kind: ListTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for ListTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            ListTagsErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            ListTagsErrorKind::ServiceError(_inner) => Some(_inner),
            ListTagsErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            ListTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListVersionsByFunctionError {
    pub kind: ListVersionsByFunctionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListVersionsByFunctionErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListVersionsByFunctionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListVersionsByFunctionErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            ListVersionsByFunctionErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            ListVersionsByFunctionErrorKind::ServiceError(_inner) => _inner.fmt(f),
            ListVersionsByFunctionErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            ListVersionsByFunctionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListVersionsByFunctionError {
    fn code(&self) -> Option<&str> {
        ListVersionsByFunctionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl ListVersionsByFunctionError {
    pub fn new(kind: ListVersionsByFunctionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListVersionsByFunctionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListVersionsByFunctionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for ListVersionsByFunctionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListVersionsByFunctionErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            ListVersionsByFunctionErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            ListVersionsByFunctionErrorKind::ServiceError(_inner) => Some(_inner),
            ListVersionsByFunctionErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            ListVersionsByFunctionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PublishLayerVersionError {
    pub kind: PublishLayerVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PublishLayerVersionErrorKind {
    CodeStorageExceededError(crate::error::CodeStorageExceededError),
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PublishLayerVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PublishLayerVersionErrorKind::CodeStorageExceededError(_inner) => _inner.fmt(f),
            PublishLayerVersionErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            PublishLayerVersionErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            PublishLayerVersionErrorKind::ServiceError(_inner) => _inner.fmt(f),
            PublishLayerVersionErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            PublishLayerVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PublishLayerVersionError {
    fn code(&self) -> Option<&str> {
        PublishLayerVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl PublishLayerVersionError {
    pub fn new(kind: PublishLayerVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PublishLayerVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PublishLayerVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for PublishLayerVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PublishLayerVersionErrorKind::CodeStorageExceededError(_inner) => Some(_inner),
            PublishLayerVersionErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            PublishLayerVersionErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            PublishLayerVersionErrorKind::ServiceError(_inner) => Some(_inner),
            PublishLayerVersionErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            PublishLayerVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PublishVersionError {
    pub kind: PublishVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PublishVersionErrorKind {
    CodeStorageExceededError(crate::error::CodeStorageExceededError),
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    PreconditionFailedError(crate::error::PreconditionFailedError),
    ResourceConflictError(crate::error::ResourceConflictError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PublishVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PublishVersionErrorKind::CodeStorageExceededError(_inner) => _inner.fmt(f),
            PublishVersionErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            PublishVersionErrorKind::PreconditionFailedError(_inner) => _inner.fmt(f),
            PublishVersionErrorKind::ResourceConflictError(_inner) => _inner.fmt(f),
            PublishVersionErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            PublishVersionErrorKind::ServiceError(_inner) => _inner.fmt(f),
            PublishVersionErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            PublishVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PublishVersionError {
    fn code(&self) -> Option<&str> {
        PublishVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl PublishVersionError {
    pub fn new(kind: PublishVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PublishVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PublishVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for PublishVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PublishVersionErrorKind::CodeStorageExceededError(_inner) => Some(_inner),
            PublishVersionErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            PublishVersionErrorKind::PreconditionFailedError(_inner) => Some(_inner),
            PublishVersionErrorKind::ResourceConflictError(_inner) => Some(_inner),
            PublishVersionErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            PublishVersionErrorKind::ServiceError(_inner) => Some(_inner),
            PublishVersionErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            PublishVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutFunctionCodeSigningConfigError {
    pub kind: PutFunctionCodeSigningConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutFunctionCodeSigningConfigErrorKind {
    CodeSigningConfigNotFoundError(crate::error::CodeSigningConfigNotFoundError),
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceConflictError(crate::error::ResourceConflictError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutFunctionCodeSigningConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutFunctionCodeSigningConfigErrorKind::CodeSigningConfigNotFoundError(_inner) => {
                _inner.fmt(f)
            }
            PutFunctionCodeSigningConfigErrorKind::InvalidParameterValueError(_inner) => {
                _inner.fmt(f)
            }
            PutFunctionCodeSigningConfigErrorKind::ResourceConflictError(_inner) => _inner.fmt(f),
            PutFunctionCodeSigningConfigErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            PutFunctionCodeSigningConfigErrorKind::ServiceError(_inner) => _inner.fmt(f),
            PutFunctionCodeSigningConfigErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            PutFunctionCodeSigningConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutFunctionCodeSigningConfigError {
    fn code(&self) -> Option<&str> {
        PutFunctionCodeSigningConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl PutFunctionCodeSigningConfigError {
    pub fn new(kind: PutFunctionCodeSigningConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutFunctionCodeSigningConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutFunctionCodeSigningConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for PutFunctionCodeSigningConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutFunctionCodeSigningConfigErrorKind::CodeSigningConfigNotFoundError(_inner) => {
                Some(_inner)
            }
            PutFunctionCodeSigningConfigErrorKind::InvalidParameterValueError(_inner) => {
                Some(_inner)
            }
            PutFunctionCodeSigningConfigErrorKind::ResourceConflictError(_inner) => Some(_inner),
            PutFunctionCodeSigningConfigErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            PutFunctionCodeSigningConfigErrorKind::ServiceError(_inner) => Some(_inner),
            PutFunctionCodeSigningConfigErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            PutFunctionCodeSigningConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutFunctionConcurrencyError {
    pub kind: PutFunctionConcurrencyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutFunctionConcurrencyErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceConflictError(crate::error::ResourceConflictError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutFunctionConcurrencyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutFunctionConcurrencyErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            PutFunctionConcurrencyErrorKind::ResourceConflictError(_inner) => _inner.fmt(f),
            PutFunctionConcurrencyErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            PutFunctionConcurrencyErrorKind::ServiceError(_inner) => _inner.fmt(f),
            PutFunctionConcurrencyErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            PutFunctionConcurrencyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutFunctionConcurrencyError {
    fn code(&self) -> Option<&str> {
        PutFunctionConcurrencyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl PutFunctionConcurrencyError {
    pub fn new(kind: PutFunctionConcurrencyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutFunctionConcurrencyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutFunctionConcurrencyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for PutFunctionConcurrencyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutFunctionConcurrencyErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            PutFunctionConcurrencyErrorKind::ResourceConflictError(_inner) => Some(_inner),
            PutFunctionConcurrencyErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            PutFunctionConcurrencyErrorKind::ServiceError(_inner) => Some(_inner),
            PutFunctionConcurrencyErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            PutFunctionConcurrencyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutFunctionEventInvokeConfigError {
    pub kind: PutFunctionEventInvokeConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutFunctionEventInvokeConfigErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutFunctionEventInvokeConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutFunctionEventInvokeConfigErrorKind::InvalidParameterValueError(_inner) => {
                _inner.fmt(f)
            }
            PutFunctionEventInvokeConfigErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            PutFunctionEventInvokeConfigErrorKind::ServiceError(_inner) => _inner.fmt(f),
            PutFunctionEventInvokeConfigErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            PutFunctionEventInvokeConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutFunctionEventInvokeConfigError {
    fn code(&self) -> Option<&str> {
        PutFunctionEventInvokeConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl PutFunctionEventInvokeConfigError {
    pub fn new(kind: PutFunctionEventInvokeConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutFunctionEventInvokeConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutFunctionEventInvokeConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for PutFunctionEventInvokeConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutFunctionEventInvokeConfigErrorKind::InvalidParameterValueError(_inner) => {
                Some(_inner)
            }
            PutFunctionEventInvokeConfigErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            PutFunctionEventInvokeConfigErrorKind::ServiceError(_inner) => Some(_inner),
            PutFunctionEventInvokeConfigErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            PutFunctionEventInvokeConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutProvisionedConcurrencyConfigError {
    pub kind: PutProvisionedConcurrencyConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutProvisionedConcurrencyConfigErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceConflictError(crate::error::ResourceConflictError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutProvisionedConcurrencyConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutProvisionedConcurrencyConfigErrorKind::InvalidParameterValueError(_inner) => {
                _inner.fmt(f)
            }
            PutProvisionedConcurrencyConfigErrorKind::ResourceConflictError(_inner) => {
                _inner.fmt(f)
            }
            PutProvisionedConcurrencyConfigErrorKind::ResourceNotFoundError(_inner) => {
                _inner.fmt(f)
            }
            PutProvisionedConcurrencyConfigErrorKind::ServiceError(_inner) => _inner.fmt(f),
            PutProvisionedConcurrencyConfigErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            PutProvisionedConcurrencyConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutProvisionedConcurrencyConfigError {
    fn code(&self) -> Option<&str> {
        PutProvisionedConcurrencyConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl PutProvisionedConcurrencyConfigError {
    pub fn new(kind: PutProvisionedConcurrencyConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutProvisionedConcurrencyConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutProvisionedConcurrencyConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for PutProvisionedConcurrencyConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutProvisionedConcurrencyConfigErrorKind::InvalidParameterValueError(_inner) => {
                Some(_inner)
            }
            PutProvisionedConcurrencyConfigErrorKind::ResourceConflictError(_inner) => Some(_inner),
            PutProvisionedConcurrencyConfigErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            PutProvisionedConcurrencyConfigErrorKind::ServiceError(_inner) => Some(_inner),
            PutProvisionedConcurrencyConfigErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            PutProvisionedConcurrencyConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveLayerVersionPermissionError {
    pub kind: RemoveLayerVersionPermissionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveLayerVersionPermissionErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    PreconditionFailedError(crate::error::PreconditionFailedError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveLayerVersionPermissionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemoveLayerVersionPermissionErrorKind::InvalidParameterValueError(_inner) => {
                _inner.fmt(f)
            }
            RemoveLayerVersionPermissionErrorKind::PreconditionFailedError(_inner) => _inner.fmt(f),
            RemoveLayerVersionPermissionErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            RemoveLayerVersionPermissionErrorKind::ServiceError(_inner) => _inner.fmt(f),
            RemoveLayerVersionPermissionErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            RemoveLayerVersionPermissionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RemoveLayerVersionPermissionError {
    fn code(&self) -> Option<&str> {
        RemoveLayerVersionPermissionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl RemoveLayerVersionPermissionError {
    pub fn new(kind: RemoveLayerVersionPermissionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemoveLayerVersionPermissionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemoveLayerVersionPermissionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for RemoveLayerVersionPermissionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemoveLayerVersionPermissionErrorKind::InvalidParameterValueError(_inner) => {
                Some(_inner)
            }
            RemoveLayerVersionPermissionErrorKind::PreconditionFailedError(_inner) => Some(_inner),
            RemoveLayerVersionPermissionErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            RemoveLayerVersionPermissionErrorKind::ServiceError(_inner) => Some(_inner),
            RemoveLayerVersionPermissionErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            RemoveLayerVersionPermissionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemovePermissionError {
    pub kind: RemovePermissionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemovePermissionErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    PreconditionFailedError(crate::error::PreconditionFailedError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemovePermissionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemovePermissionErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            RemovePermissionErrorKind::PreconditionFailedError(_inner) => _inner.fmt(f),
            RemovePermissionErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            RemovePermissionErrorKind::ServiceError(_inner) => _inner.fmt(f),
            RemovePermissionErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            RemovePermissionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RemovePermissionError {
    fn code(&self) -> Option<&str> {
        RemovePermissionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl RemovePermissionError {
    pub fn new(kind: RemovePermissionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemovePermissionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemovePermissionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for RemovePermissionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemovePermissionErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            RemovePermissionErrorKind::PreconditionFailedError(_inner) => Some(_inner),
            RemovePermissionErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            RemovePermissionErrorKind::ServiceError(_inner) => Some(_inner),
            RemovePermissionErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            RemovePermissionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceConflictError(crate::error::ResourceConflictError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ResourceConflictError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ServiceError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            TagResourceErrorKind::ResourceConflictError(_inner) => Some(_inner),
            TagResourceErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            TagResourceErrorKind::ServiceError(_inner) => Some(_inner),
            TagResourceErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceConflictError(crate::error::ResourceConflictError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ResourceConflictError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ServiceError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            UntagResourceErrorKind::ResourceConflictError(_inner) => Some(_inner),
            UntagResourceErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            UntagResourceErrorKind::ServiceError(_inner) => Some(_inner),
            UntagResourceErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAliasError {
    pub kind: UpdateAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAliasErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    PreconditionFailedError(crate::error::PreconditionFailedError),
    ResourceConflictError(crate::error::ResourceConflictError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAliasErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            UpdateAliasErrorKind::PreconditionFailedError(_inner) => _inner.fmt(f),
            UpdateAliasErrorKind::ResourceConflictError(_inner) => _inner.fmt(f),
            UpdateAliasErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            UpdateAliasErrorKind::ServiceError(_inner) => _inner.fmt(f),
            UpdateAliasErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UpdateAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAliasError {
    fn code(&self) -> Option<&str> {
        UpdateAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl UpdateAliasError {
    pub fn new(kind: UpdateAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for UpdateAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAliasErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            UpdateAliasErrorKind::PreconditionFailedError(_inner) => Some(_inner),
            UpdateAliasErrorKind::ResourceConflictError(_inner) => Some(_inner),
            UpdateAliasErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            UpdateAliasErrorKind::ServiceError(_inner) => Some(_inner),
            UpdateAliasErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UpdateAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateCodeSigningConfigError {
    pub kind: UpdateCodeSigningConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateCodeSigningConfigErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateCodeSigningConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateCodeSigningConfigErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            UpdateCodeSigningConfigErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            UpdateCodeSigningConfigErrorKind::ServiceError(_inner) => _inner.fmt(f),
            UpdateCodeSigningConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateCodeSigningConfigError {
    fn code(&self) -> Option<&str> {
        UpdateCodeSigningConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl UpdateCodeSigningConfigError {
    pub fn new(kind: UpdateCodeSigningConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateCodeSigningConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateCodeSigningConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for UpdateCodeSigningConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateCodeSigningConfigErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            UpdateCodeSigningConfigErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            UpdateCodeSigningConfigErrorKind::ServiceError(_inner) => Some(_inner),
            UpdateCodeSigningConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateEventSourceMappingError {
    pub kind: UpdateEventSourceMappingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateEventSourceMappingErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceConflictError(crate::error::ResourceConflictError),
    ResourceInUseError(crate::error::ResourceInUseError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateEventSourceMappingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateEventSourceMappingErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            UpdateEventSourceMappingErrorKind::ResourceConflictError(_inner) => _inner.fmt(f),
            UpdateEventSourceMappingErrorKind::ResourceInUseError(_inner) => _inner.fmt(f),
            UpdateEventSourceMappingErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            UpdateEventSourceMappingErrorKind::ServiceError(_inner) => _inner.fmt(f),
            UpdateEventSourceMappingErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UpdateEventSourceMappingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateEventSourceMappingError {
    fn code(&self) -> Option<&str> {
        UpdateEventSourceMappingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl UpdateEventSourceMappingError {
    pub fn new(kind: UpdateEventSourceMappingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateEventSourceMappingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateEventSourceMappingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for UpdateEventSourceMappingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateEventSourceMappingErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            UpdateEventSourceMappingErrorKind::ResourceConflictError(_inner) => Some(_inner),
            UpdateEventSourceMappingErrorKind::ResourceInUseError(_inner) => Some(_inner),
            UpdateEventSourceMappingErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            UpdateEventSourceMappingErrorKind::ServiceError(_inner) => Some(_inner),
            UpdateEventSourceMappingErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UpdateEventSourceMappingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateFunctionCodeError {
    pub kind: UpdateFunctionCodeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateFunctionCodeErrorKind {
    CodeSigningConfigNotFoundError(crate::error::CodeSigningConfigNotFoundError),
    CodeStorageExceededError(crate::error::CodeStorageExceededError),
    CodeVerificationFailedError(crate::error::CodeVerificationFailedError),
    InvalidCodeSignatureError(crate::error::InvalidCodeSignatureError),
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    PreconditionFailedError(crate::error::PreconditionFailedError),
    ResourceConflictError(crate::error::ResourceConflictError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateFunctionCodeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateFunctionCodeErrorKind::CodeSigningConfigNotFoundError(_inner) => _inner.fmt(f),
            UpdateFunctionCodeErrorKind::CodeStorageExceededError(_inner) => _inner.fmt(f),
            UpdateFunctionCodeErrorKind::CodeVerificationFailedError(_inner) => _inner.fmt(f),
            UpdateFunctionCodeErrorKind::InvalidCodeSignatureError(_inner) => _inner.fmt(f),
            UpdateFunctionCodeErrorKind::InvalidParameterValueError(_inner) => _inner.fmt(f),
            UpdateFunctionCodeErrorKind::PreconditionFailedError(_inner) => _inner.fmt(f),
            UpdateFunctionCodeErrorKind::ResourceConflictError(_inner) => _inner.fmt(f),
            UpdateFunctionCodeErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            UpdateFunctionCodeErrorKind::ServiceError(_inner) => _inner.fmt(f),
            UpdateFunctionCodeErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UpdateFunctionCodeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateFunctionCodeError {
    fn code(&self) -> Option<&str> {
        UpdateFunctionCodeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl UpdateFunctionCodeError {
    pub fn new(kind: UpdateFunctionCodeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateFunctionCodeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateFunctionCodeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for UpdateFunctionCodeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateFunctionCodeErrorKind::CodeSigningConfigNotFoundError(_inner) => Some(_inner),
            UpdateFunctionCodeErrorKind::CodeStorageExceededError(_inner) => Some(_inner),
            UpdateFunctionCodeErrorKind::CodeVerificationFailedError(_inner) => Some(_inner),
            UpdateFunctionCodeErrorKind::InvalidCodeSignatureError(_inner) => Some(_inner),
            UpdateFunctionCodeErrorKind::InvalidParameterValueError(_inner) => Some(_inner),
            UpdateFunctionCodeErrorKind::PreconditionFailedError(_inner) => Some(_inner),
            UpdateFunctionCodeErrorKind::ResourceConflictError(_inner) => Some(_inner),
            UpdateFunctionCodeErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            UpdateFunctionCodeErrorKind::ServiceError(_inner) => Some(_inner),
            UpdateFunctionCodeErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UpdateFunctionCodeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateFunctionConfigurationError {
    pub kind: UpdateFunctionConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateFunctionConfigurationErrorKind {
    CodeSigningConfigNotFoundError(crate::error::CodeSigningConfigNotFoundError),
    CodeVerificationFailedError(crate::error::CodeVerificationFailedError),
    InvalidCodeSignatureError(crate::error::InvalidCodeSignatureError),
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    PreconditionFailedError(crate::error::PreconditionFailedError),
    ResourceConflictError(crate::error::ResourceConflictError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateFunctionConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateFunctionConfigurationErrorKind::CodeSigningConfigNotFoundError(_inner) => {
                _inner.fmt(f)
            }
            UpdateFunctionConfigurationErrorKind::CodeVerificationFailedError(_inner) => {
                _inner.fmt(f)
            }
            UpdateFunctionConfigurationErrorKind::InvalidCodeSignatureError(_inner) => {
                _inner.fmt(f)
            }
            UpdateFunctionConfigurationErrorKind::InvalidParameterValueError(_inner) => {
                _inner.fmt(f)
            }
            UpdateFunctionConfigurationErrorKind::PreconditionFailedError(_inner) => _inner.fmt(f),
            UpdateFunctionConfigurationErrorKind::ResourceConflictError(_inner) => _inner.fmt(f),
            UpdateFunctionConfigurationErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            UpdateFunctionConfigurationErrorKind::ServiceError(_inner) => _inner.fmt(f),
            UpdateFunctionConfigurationErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UpdateFunctionConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateFunctionConfigurationError {
    fn code(&self) -> Option<&str> {
        UpdateFunctionConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl UpdateFunctionConfigurationError {
    pub fn new(kind: UpdateFunctionConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateFunctionConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateFunctionConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for UpdateFunctionConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateFunctionConfigurationErrorKind::CodeSigningConfigNotFoundError(_inner) => {
                Some(_inner)
            }
            UpdateFunctionConfigurationErrorKind::CodeVerificationFailedError(_inner) => {
                Some(_inner)
            }
            UpdateFunctionConfigurationErrorKind::InvalidCodeSignatureError(_inner) => Some(_inner),
            UpdateFunctionConfigurationErrorKind::InvalidParameterValueError(_inner) => {
                Some(_inner)
            }
            UpdateFunctionConfigurationErrorKind::PreconditionFailedError(_inner) => Some(_inner),
            UpdateFunctionConfigurationErrorKind::ResourceConflictError(_inner) => Some(_inner),
            UpdateFunctionConfigurationErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            UpdateFunctionConfigurationErrorKind::ServiceError(_inner) => Some(_inner),
            UpdateFunctionConfigurationErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UpdateFunctionConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateFunctionEventInvokeConfigError {
    pub kind: UpdateFunctionEventInvokeConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateFunctionEventInvokeConfigErrorKind {
    InvalidParameterValueError(crate::error::InvalidParameterValueError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceError(crate::error::ServiceError),
    TooManyRequestsError(crate::error::TooManyRequestsError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateFunctionEventInvokeConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateFunctionEventInvokeConfigErrorKind::InvalidParameterValueError(_inner) => {
                _inner.fmt(f)
            }
            UpdateFunctionEventInvokeConfigErrorKind::ResourceNotFoundError(_inner) => {
                _inner.fmt(f)
            }
            UpdateFunctionEventInvokeConfigErrorKind::ServiceError(_inner) => _inner.fmt(f),
            UpdateFunctionEventInvokeConfigErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UpdateFunctionEventInvokeConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateFunctionEventInvokeConfigError {
    fn code(&self) -> Option<&str> {
        UpdateFunctionEventInvokeConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl UpdateFunctionEventInvokeConfigError {
    pub fn new(kind: UpdateFunctionEventInvokeConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateFunctionEventInvokeConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateFunctionEventInvokeConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for UpdateFunctionEventInvokeConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateFunctionEventInvokeConfigErrorKind::InvalidParameterValueError(_inner) => {
                Some(_inner)
            }
            UpdateFunctionEventInvokeConfigErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            UpdateFunctionEventInvokeConfigErrorKind::ServiceError(_inner) => Some(_inner),
            UpdateFunctionEventInvokeConfigErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UpdateFunctionEventInvokeConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The request throughput limit was exceeded.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct TooManyRequestsError {
    /// <p>The number of seconds the caller should wait before retrying.</p>
    #[serde(rename = "retryAfterSeconds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub retry_after_seconds: std::option::Option<std::string::String>,
    #[serde(rename = "Type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub r#type: std::option::Option<std::string::String>,
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
    #[serde(rename = "Reason")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub reason: std::option::Option<crate::model::ThrottleReason>,
}
impl std::fmt::Debug for TooManyRequestsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TooManyRequestsError");
        formatter.field("retry_after_seconds", &self.retry_after_seconds);
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.field("reason", &self.reason);
        formatter.finish()
    }
}
impl TooManyRequestsError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyRequestsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyRequestsError [TooManyRequestsException]")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for TooManyRequestsError {}
/// See [`TooManyRequestsError`](crate::error::TooManyRequestsError)
pub mod too_many_requests_error {
    /// A builder for [`TooManyRequestsError`](crate::error::TooManyRequestsError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) retry_after_seconds: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) reason: std::option::Option<crate::model::ThrottleReason>,
    }
    impl Builder {
        /// <p>The number of seconds the caller should wait before retrying.</p>
        pub fn retry_after_seconds(mut self, inp: impl Into<std::string::String>) -> Self {
            self.retry_after_seconds = Some(inp.into());
            self
        }
        pub fn set_retry_after_seconds(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.retry_after_seconds = inp;
            self
        }
        pub fn r#type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.r#type = Some(inp.into());
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.r#type = inp;
            self
        }
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        pub fn reason(mut self, inp: crate::model::ThrottleReason) -> Self {
            self.reason = Some(inp);
            self
        }
        pub fn set_reason(
            mut self,
            inp: std::option::Option<crate::model::ThrottleReason>,
        ) -> Self {
            self.reason = inp;
            self
        }
        /// Consumes the builder and constructs a [`TooManyRequestsError`](crate::error::TooManyRequestsError)
        pub fn build(self) -> crate::error::TooManyRequestsError {
            crate::error::TooManyRequestsError {
                retry_after_seconds: self.retry_after_seconds,
                r#type: self.r#type,
                message: self.message,
                reason: self.reason,
            }
        }
    }
}
impl TooManyRequestsError {
    /// Creates a new builder-style object to manufacture [`TooManyRequestsError`](crate::error::TooManyRequestsError)
    pub fn builder() -> crate::error::too_many_requests_error::Builder {
        crate::error::too_many_requests_error::Builder::default()
    }
}

/// <p>The AWS Lambda service encountered an internal error.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceError {
    #[serde(rename = "Type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub r#type: std::option::Option<std::string::String>,
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceError");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceError [ServiceException]")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceError {}
/// See [`ServiceError`](crate::error::ServiceError)
pub mod service_error {
    /// A builder for [`ServiceError`](crate::error::ServiceError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.r#type = Some(inp.into());
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.r#type = inp;
            self
        }
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`ServiceError`](crate::error::ServiceError)
        pub fn build(self) -> crate::error::ServiceError {
            crate::error::ServiceError {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl ServiceError {
    /// Creates a new builder-style object to manufacture [`ServiceError`](crate::error::ServiceError)
    pub fn builder() -> crate::error::service_error::Builder {
        crate::error::service_error::Builder::default()
    }
}

/// <p>The resource specified in the request does not exist.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundError {
    #[serde(rename = "Type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub r#type: std::option::Option<std::string::String>,
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundError");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundError [ResourceNotFoundException]")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundError {}
/// See [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
pub mod resource_not_found_error {
    /// A builder for [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.r#type = Some(inp.into());
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.r#type = inp;
            self
        }
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
        pub fn build(self) -> crate::error::ResourceNotFoundError {
            crate::error::ResourceNotFoundError {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl ResourceNotFoundError {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
    pub fn builder() -> crate::error::resource_not_found_error::Builder {
        crate::error::resource_not_found_error::Builder::default()
    }
}

/// <p>One of the parameters in the request is invalid.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidParameterValueError {
    /// <p>The exception type.</p>
    #[serde(rename = "Type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The exception message.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidParameterValueError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidParameterValueError");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidParameterValueError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidParameterValueError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidParameterValueError [InvalidParameterValueException]"
        )?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidParameterValueError {}
/// See [`InvalidParameterValueError`](crate::error::InvalidParameterValueError)
pub mod invalid_parameter_value_error {
    /// A builder for [`InvalidParameterValueError`](crate::error::InvalidParameterValueError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The exception type.</p>
        pub fn r#type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.r#type = Some(inp.into());
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.r#type = inp;
            self
        }
        /// <p>The exception message.</p>
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`InvalidParameterValueError`](crate::error::InvalidParameterValueError)
        pub fn build(self) -> crate::error::InvalidParameterValueError {
            crate::error::InvalidParameterValueError {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl InvalidParameterValueError {
    /// Creates a new builder-style object to manufacture [`InvalidParameterValueError`](crate::error::InvalidParameterValueError)
    pub fn builder() -> crate::error::invalid_parameter_value_error::Builder {
        crate::error::invalid_parameter_value_error::Builder::default()
    }
}

/// <p>The resource already exists, or another operation is in progress.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceConflictError {
    /// <p>The exception type.</p>
    #[serde(rename = "Type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The exception message.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceConflictError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceConflictError");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceConflictError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceConflictError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceConflictError [ResourceConflictException]")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceConflictError {}
/// See [`ResourceConflictError`](crate::error::ResourceConflictError)
pub mod resource_conflict_error {
    /// A builder for [`ResourceConflictError`](crate::error::ResourceConflictError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The exception type.</p>
        pub fn r#type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.r#type = Some(inp.into());
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.r#type = inp;
            self
        }
        /// <p>The exception message.</p>
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`ResourceConflictError`](crate::error::ResourceConflictError)
        pub fn build(self) -> crate::error::ResourceConflictError {
            crate::error::ResourceConflictError {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl ResourceConflictError {
    /// Creates a new builder-style object to manufacture [`ResourceConflictError`](crate::error::ResourceConflictError)
    pub fn builder() -> crate::error::resource_conflict_error::Builder {
        crate::error::resource_conflict_error::Builder::default()
    }
}

/// <p>The RevisionId provided does not match the latest RevisionId for the Lambda function or alias. Call the
/// <code>GetFunction</code> or the <code>GetAlias</code> API to retrieve the latest RevisionId for your
/// resource.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PreconditionFailedError {
    /// <p>The exception type.</p>
    #[serde(rename = "Type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The exception message.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PreconditionFailedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PreconditionFailedError");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PreconditionFailedError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PreconditionFailedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PreconditionFailedError [PreconditionFailedException]")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for PreconditionFailedError {}
/// See [`PreconditionFailedError`](crate::error::PreconditionFailedError)
pub mod precondition_failed_error {
    /// A builder for [`PreconditionFailedError`](crate::error::PreconditionFailedError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The exception type.</p>
        pub fn r#type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.r#type = Some(inp.into());
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.r#type = inp;
            self
        }
        /// <p>The exception message.</p>
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`PreconditionFailedError`](crate::error::PreconditionFailedError)
        pub fn build(self) -> crate::error::PreconditionFailedError {
            crate::error::PreconditionFailedError {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl PreconditionFailedError {
    /// Creates a new builder-style object to manufacture [`PreconditionFailedError`](crate::error::PreconditionFailedError)
    pub fn builder() -> crate::error::precondition_failed_error::Builder {
        crate::error::precondition_failed_error::Builder::default()
    }
}

/// <p>The code signature failed the integrity check. Lambda always blocks deployment if the integrity check
/// fails, even if code signing policy is set to WARN.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidCodeSignatureError {
    #[serde(rename = "Type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub r#type: std::option::Option<std::string::String>,
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidCodeSignatureError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidCodeSignatureError");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidCodeSignatureError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidCodeSignatureError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidCodeSignatureError [InvalidCodeSignatureException]"
        )?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidCodeSignatureError {}
/// See [`InvalidCodeSignatureError`](crate::error::InvalidCodeSignatureError)
pub mod invalid_code_signature_error {
    /// A builder for [`InvalidCodeSignatureError`](crate::error::InvalidCodeSignatureError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.r#type = Some(inp.into());
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.r#type = inp;
            self
        }
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`InvalidCodeSignatureError`](crate::error::InvalidCodeSignatureError)
        pub fn build(self) -> crate::error::InvalidCodeSignatureError {
            crate::error::InvalidCodeSignatureError {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl InvalidCodeSignatureError {
    /// Creates a new builder-style object to manufacture [`InvalidCodeSignatureError`](crate::error::InvalidCodeSignatureError)
    pub fn builder() -> crate::error::invalid_code_signature_error::Builder {
        crate::error::invalid_code_signature_error::Builder::default()
    }
}

/// <p>The code signature failed one or more of the validation checks for signature mismatch or expiry, and the code signing policy
/// is set to ENFORCE. Lambda blocks the deployment. </p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CodeVerificationFailedError {
    #[serde(rename = "Type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub r#type: std::option::Option<std::string::String>,
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CodeVerificationFailedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CodeVerificationFailedError");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CodeVerificationFailedError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CodeVerificationFailedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "CodeVerificationFailedError [CodeVerificationFailedException]"
        )?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for CodeVerificationFailedError {}
/// See [`CodeVerificationFailedError`](crate::error::CodeVerificationFailedError)
pub mod code_verification_failed_error {
    /// A builder for [`CodeVerificationFailedError`](crate::error::CodeVerificationFailedError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.r#type = Some(inp.into());
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.r#type = inp;
            self
        }
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`CodeVerificationFailedError`](crate::error::CodeVerificationFailedError)
        pub fn build(self) -> crate::error::CodeVerificationFailedError {
            crate::error::CodeVerificationFailedError {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl CodeVerificationFailedError {
    /// Creates a new builder-style object to manufacture [`CodeVerificationFailedError`](crate::error::CodeVerificationFailedError)
    pub fn builder() -> crate::error::code_verification_failed_error::Builder {
        crate::error::code_verification_failed_error::Builder::default()
    }
}

/// <p>The specified code signing configuration does not exist.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CodeSigningConfigNotFoundError {
    #[serde(rename = "Type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub r#type: std::option::Option<std::string::String>,
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CodeSigningConfigNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CodeSigningConfigNotFoundError");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CodeSigningConfigNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CodeSigningConfigNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "CodeSigningConfigNotFoundError [CodeSigningConfigNotFoundException]"
        )?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for CodeSigningConfigNotFoundError {}
/// See [`CodeSigningConfigNotFoundError`](crate::error::CodeSigningConfigNotFoundError)
pub mod code_signing_config_not_found_error {
    /// A builder for [`CodeSigningConfigNotFoundError`](crate::error::CodeSigningConfigNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.r#type = Some(inp.into());
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.r#type = inp;
            self
        }
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`CodeSigningConfigNotFoundError`](crate::error::CodeSigningConfigNotFoundError)
        pub fn build(self) -> crate::error::CodeSigningConfigNotFoundError {
            crate::error::CodeSigningConfigNotFoundError {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl CodeSigningConfigNotFoundError {
    /// Creates a new builder-style object to manufacture [`CodeSigningConfigNotFoundError`](crate::error::CodeSigningConfigNotFoundError)
    pub fn builder() -> crate::error::code_signing_config_not_found_error::Builder {
        crate::error::code_signing_config_not_found_error::Builder::default()
    }
}

/// <p>You have exceeded your maximum total code size per account. <a href="https://docs.aws.amazon.com/lambda/latest/dg/limits.html">Learn more</a>
/// </p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CodeStorageExceededError {
    /// <p>The exception type.</p>
    #[serde(rename = "Type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub r#type: std::option::Option<std::string::String>,
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CodeStorageExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CodeStorageExceededError");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CodeStorageExceededError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CodeStorageExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CodeStorageExceededError [CodeStorageExceededException]")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for CodeStorageExceededError {}
/// See [`CodeStorageExceededError`](crate::error::CodeStorageExceededError)
pub mod code_storage_exceeded_error {
    /// A builder for [`CodeStorageExceededError`](crate::error::CodeStorageExceededError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The exception type.</p>
        pub fn r#type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.r#type = Some(inp.into());
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.r#type = inp;
            self
        }
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`CodeStorageExceededError`](crate::error::CodeStorageExceededError)
        pub fn build(self) -> crate::error::CodeStorageExceededError {
            crate::error::CodeStorageExceededError {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl CodeStorageExceededError {
    /// Creates a new builder-style object to manufacture [`CodeStorageExceededError`](crate::error::CodeStorageExceededError)
    pub fn builder() -> crate::error::code_storage_exceeded_error::Builder {
        crate::error::code_storage_exceeded_error::Builder::default()
    }
}

/// <p>The operation conflicts with the resource's availability. For example, you attempted to update an EventSource
/// Mapping in CREATING, or tried to delete a EventSource mapping currently in the UPDATING state.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceInUseError {
    #[serde(rename = "Type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub r#type: std::option::Option<std::string::String>,
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceInUseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceInUseError");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceInUseError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceInUseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceInUseError [ResourceInUseException]")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceInUseError {}
/// See [`ResourceInUseError`](crate::error::ResourceInUseError)
pub mod resource_in_use_error {
    /// A builder for [`ResourceInUseError`](crate::error::ResourceInUseError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.r#type = Some(inp.into());
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.r#type = inp;
            self
        }
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`ResourceInUseError`](crate::error::ResourceInUseError)
        pub fn build(self) -> crate::error::ResourceInUseError {
            crate::error::ResourceInUseError {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl ResourceInUseError {
    /// Creates a new builder-style object to manufacture [`ResourceInUseError`](crate::error::ResourceInUseError)
    pub fn builder() -> crate::error::resource_in_use_error::Builder {
        crate::error::resource_in_use_error::Builder::default()
    }
}

/// <p>The runtime or runtime version specified is not supported.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRuntimeError {
    #[serde(rename = "Type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub r#type: std::option::Option<std::string::String>,
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRuntimeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRuntimeError");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRuntimeError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRuntimeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRuntimeError [InvalidRuntimeException]")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRuntimeError {}
/// See [`InvalidRuntimeError`](crate::error::InvalidRuntimeError)
pub mod invalid_runtime_error {
    /// A builder for [`InvalidRuntimeError`](crate::error::InvalidRuntimeError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.r#type = Some(inp.into());
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.r#type = inp;
            self
        }
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRuntimeError`](crate::error::InvalidRuntimeError)
        pub fn build(self) -> crate::error::InvalidRuntimeError {
            crate::error::InvalidRuntimeError {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl InvalidRuntimeError {
    /// Creates a new builder-style object to manufacture [`InvalidRuntimeError`](crate::error::InvalidRuntimeError)
    pub fn builder() -> crate::error::invalid_runtime_error::Builder {
        crate::error::invalid_runtime_error::Builder::default()
    }
}

/// <p>The request body could not be parsed as JSON.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRequestContentError {
    /// <p>The exception type.</p>
    #[serde(rename = "Type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The exception message.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRequestContentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRequestContentError");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRequestContentError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRequestContentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidRequestContentError [InvalidRequestContentException]"
        )?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRequestContentError {}
/// See [`InvalidRequestContentError`](crate::error::InvalidRequestContentError)
pub mod invalid_request_content_error {
    /// A builder for [`InvalidRequestContentError`](crate::error::InvalidRequestContentError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The exception type.</p>
        pub fn r#type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.r#type = Some(inp.into());
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.r#type = inp;
            self
        }
        /// <p>The exception message.</p>
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRequestContentError`](crate::error::InvalidRequestContentError)
        pub fn build(self) -> crate::error::InvalidRequestContentError {
            crate::error::InvalidRequestContentError {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl InvalidRequestContentError {
    /// Creates a new builder-style object to manufacture [`InvalidRequestContentError`](crate::error::InvalidRequestContentError)
    pub fn builder() -> crate::error::invalid_request_content_error::Builder {
        crate::error::invalid_request_content_error::Builder::default()
    }
}

/// <p>The content type of the <code>Invoke</code> request body is not JSON.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UnsupportedMediaTypeError {
    #[serde(rename = "Type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub r#type: std::option::Option<std::string::String>,
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnsupportedMediaTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnsupportedMediaTypeError");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnsupportedMediaTypeError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedMediaTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "UnsupportedMediaTypeError [UnsupportedMediaTypeException]"
        )?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedMediaTypeError {}
/// See [`UnsupportedMediaTypeError`](crate::error::UnsupportedMediaTypeError)
pub mod unsupported_media_type_error {
    /// A builder for [`UnsupportedMediaTypeError`](crate::error::UnsupportedMediaTypeError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.r#type = Some(inp.into());
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.r#type = inp;
            self
        }
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedMediaTypeError`](crate::error::UnsupportedMediaTypeError)
        pub fn build(self) -> crate::error::UnsupportedMediaTypeError {
            crate::error::UnsupportedMediaTypeError {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl UnsupportedMediaTypeError {
    /// Creates a new builder-style object to manufacture [`UnsupportedMediaTypeError`](crate::error::UnsupportedMediaTypeError)
    pub fn builder() -> crate::error::unsupported_media_type_error::Builder {
        crate::error::unsupported_media_type_error::Builder::default()
    }
}

/// <p>AWS Lambda was not able to set up VPC access for the Lambda function because one or more configured subnets
/// has no available IP addresses.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct SubnetIPAddressLimitReachedError {
    #[serde(rename = "Type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub r#type: std::option::Option<std::string::String>,
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SubnetIPAddressLimitReachedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SubnetIPAddressLimitReachedError");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SubnetIPAddressLimitReachedError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SubnetIPAddressLimitReachedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SubnetIPAddressLimitReachedError [SubnetIPAddressLimitReachedException]"
        )?;
        if let Some(inner_15) = &self.message {
            write!(f, ": {}", inner_15)?;
        }
        Ok(())
    }
}
impl std::error::Error for SubnetIPAddressLimitReachedError {}
/// See [`SubnetIPAddressLimitReachedError`](crate::error::SubnetIPAddressLimitReachedError)
pub mod subnet_ip_address_limit_reached_error {
    /// A builder for [`SubnetIPAddressLimitReachedError`](crate::error::SubnetIPAddressLimitReachedError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.r#type = Some(inp.into());
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.r#type = inp;
            self
        }
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`SubnetIPAddressLimitReachedError`](crate::error::SubnetIPAddressLimitReachedError)
        pub fn build(self) -> crate::error::SubnetIPAddressLimitReachedError {
            crate::error::SubnetIPAddressLimitReachedError {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl SubnetIPAddressLimitReachedError {
    /// Creates a new builder-style object to manufacture [`SubnetIPAddressLimitReachedError`](crate::error::SubnetIPAddressLimitReachedError)
    pub fn builder() -> crate::error::subnet_ip_address_limit_reached_error::Builder {
        crate::error::subnet_ip_address_limit_reached_error::Builder::default()
    }
}

/// <p>The function is inactive and its VPC connection is no longer available. Wait for the VPC connection to
/// reestablish and try again.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotReadyError {
    /// <p>The exception type.</p>
    #[serde(rename = "Type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The exception message.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotReadyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotReadyError");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceNotReadyError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotReadyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotReadyError [ResourceNotReadyException]")?;
        if let Some(inner_16) = &self.message {
            write!(f, ": {}", inner_16)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotReadyError {}
/// See [`ResourceNotReadyError`](crate::error::ResourceNotReadyError)
pub mod resource_not_ready_error {
    /// A builder for [`ResourceNotReadyError`](crate::error::ResourceNotReadyError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The exception type.</p>
        pub fn r#type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.r#type = Some(inp.into());
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.r#type = inp;
            self
        }
        /// <p>The exception message.</p>
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotReadyError`](crate::error::ResourceNotReadyError)
        pub fn build(self) -> crate::error::ResourceNotReadyError {
            crate::error::ResourceNotReadyError {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl ResourceNotReadyError {
    /// Creates a new builder-style object to manufacture [`ResourceNotReadyError`](crate::error::ResourceNotReadyError)
    pub fn builder() -> crate::error::resource_not_ready_error::Builder {
        crate::error::resource_not_ready_error::Builder::default()
    }
}

/// <p>The request payload exceeded the <code>Invoke</code> request body JSON input limit. For more information, see
/// <a href="https://docs.aws.amazon.com/lambda/latest/dg/limits.html">Limits</a>. </p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct RequestTooLargeError {
    #[serde(rename = "Type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub r#type: std::option::Option<std::string::String>,
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RequestTooLargeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RequestTooLargeError");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RequestTooLargeError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RequestTooLargeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RequestTooLargeError [RequestTooLargeException]")?;
        if let Some(inner_17) = &self.message {
            write!(f, ": {}", inner_17)?;
        }
        Ok(())
    }
}
impl std::error::Error for RequestTooLargeError {}
/// See [`RequestTooLargeError`](crate::error::RequestTooLargeError)
pub mod request_too_large_error {
    /// A builder for [`RequestTooLargeError`](crate::error::RequestTooLargeError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.r#type = Some(inp.into());
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.r#type = inp;
            self
        }
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`RequestTooLargeError`](crate::error::RequestTooLargeError)
        pub fn build(self) -> crate::error::RequestTooLargeError {
            crate::error::RequestTooLargeError {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl RequestTooLargeError {
    /// Creates a new builder-style object to manufacture [`RequestTooLargeError`](crate::error::RequestTooLargeError)
    pub fn builder() -> crate::error::request_too_large_error::Builder {
        crate::error::request_too_large_error::Builder::default()
    }
}

/// <p>Lambda was unable to decrypt the environment variables because the KMS key was not found. Check the function's
/// KMS key settings. </p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct KMSNotFoundError {
    #[serde(rename = "Type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub r#type: std::option::Option<std::string::String>,
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for KMSNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KMSNotFoundError");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KMSNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for KMSNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KMSNotFoundError [KMSNotFoundException]")?;
        if let Some(inner_18) = &self.message {
            write!(f, ": {}", inner_18)?;
        }
        Ok(())
    }
}
impl std::error::Error for KMSNotFoundError {}
/// See [`KMSNotFoundError`](crate::error::KMSNotFoundError)
pub mod kms_not_found_error {
    /// A builder for [`KMSNotFoundError`](crate::error::KMSNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.r#type = Some(inp.into());
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.r#type = inp;
            self
        }
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`KMSNotFoundError`](crate::error::KMSNotFoundError)
        pub fn build(self) -> crate::error::KMSNotFoundError {
            crate::error::KMSNotFoundError {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl KMSNotFoundError {
    /// Creates a new builder-style object to manufacture [`KMSNotFoundError`](crate::error::KMSNotFoundError)
    pub fn builder() -> crate::error::kms_not_found_error::Builder {
        crate::error::kms_not_found_error::Builder::default()
    }
}

/// <p>Lambda was unable to decrypt the environment variables because the KMS key used is in an invalid state for
/// Decrypt. Check the function's KMS key settings.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct KMSInvalidStateError {
    #[serde(rename = "Type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub r#type: std::option::Option<std::string::String>,
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for KMSInvalidStateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KMSInvalidStateError");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KMSInvalidStateError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for KMSInvalidStateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KMSInvalidStateError [KMSInvalidStateException]")?;
        if let Some(inner_19) = &self.message {
            write!(f, ": {}", inner_19)?;
        }
        Ok(())
    }
}
impl std::error::Error for KMSInvalidStateError {}
/// See [`KMSInvalidStateError`](crate::error::KMSInvalidStateError)
pub mod kms_invalid_state_error {
    /// A builder for [`KMSInvalidStateError`](crate::error::KMSInvalidStateError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.r#type = Some(inp.into());
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.r#type = inp;
            self
        }
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`KMSInvalidStateError`](crate::error::KMSInvalidStateError)
        pub fn build(self) -> crate::error::KMSInvalidStateError {
            crate::error::KMSInvalidStateError {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl KMSInvalidStateError {
    /// Creates a new builder-style object to manufacture [`KMSInvalidStateError`](crate::error::KMSInvalidStateError)
    pub fn builder() -> crate::error::kms_invalid_state_error::Builder {
        crate::error::kms_invalid_state_error::Builder::default()
    }
}

/// <p>Lambda was unable to decrypt the environment variables because the KMS key used is disabled. Check the Lambda
/// function's KMS key settings.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct KMSDisabledError {
    #[serde(rename = "Type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub r#type: std::option::Option<std::string::String>,
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for KMSDisabledError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KMSDisabledError");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KMSDisabledError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for KMSDisabledError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KMSDisabledError [KMSDisabledException]")?;
        if let Some(inner_20) = &self.message {
            write!(f, ": {}", inner_20)?;
        }
        Ok(())
    }
}
impl std::error::Error for KMSDisabledError {}
/// See [`KMSDisabledError`](crate::error::KMSDisabledError)
pub mod kms_disabled_error {
    /// A builder for [`KMSDisabledError`](crate::error::KMSDisabledError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.r#type = Some(inp.into());
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.r#type = inp;
            self
        }
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`KMSDisabledError`](crate::error::KMSDisabledError)
        pub fn build(self) -> crate::error::KMSDisabledError {
            crate::error::KMSDisabledError {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl KMSDisabledError {
    /// Creates a new builder-style object to manufacture [`KMSDisabledError`](crate::error::KMSDisabledError)
    pub fn builder() -> crate::error::kms_disabled_error::Builder {
        crate::error::kms_disabled_error::Builder::default()
    }
}

/// <p>Lambda was unable to decrypt the environment variables because KMS access was denied. Check the Lambda
/// function's KMS permissions.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct KMSAccessDeniedError {
    #[serde(rename = "Type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub r#type: std::option::Option<std::string::String>,
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for KMSAccessDeniedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KMSAccessDeniedError");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KMSAccessDeniedError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for KMSAccessDeniedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KMSAccessDeniedError [KMSAccessDeniedException]")?;
        if let Some(inner_21) = &self.message {
            write!(f, ": {}", inner_21)?;
        }
        Ok(())
    }
}
impl std::error::Error for KMSAccessDeniedError {}
/// See [`KMSAccessDeniedError`](crate::error::KMSAccessDeniedError)
pub mod kms_access_denied_error {
    /// A builder for [`KMSAccessDeniedError`](crate::error::KMSAccessDeniedError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.r#type = Some(inp.into());
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.r#type = inp;
            self
        }
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`KMSAccessDeniedError`](crate::error::KMSAccessDeniedError)
        pub fn build(self) -> crate::error::KMSAccessDeniedError {
            crate::error::KMSAccessDeniedError {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl KMSAccessDeniedError {
    /// Creates a new builder-style object to manufacture [`KMSAccessDeniedError`](crate::error::KMSAccessDeniedError)
    pub fn builder() -> crate::error::kms_access_denied_error::Builder {
        crate::error::kms_access_denied_error::Builder::default()
    }
}

/// <p>AWS Lambda could not unzip the deployment package.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidZipFileError {
    #[serde(rename = "Type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub r#type: std::option::Option<std::string::String>,
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidZipFileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidZipFileError");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidZipFileError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidZipFileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidZipFileError [InvalidZipFileException]")?;
        if let Some(inner_22) = &self.message {
            write!(f, ": {}", inner_22)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidZipFileError {}
/// See [`InvalidZipFileError`](crate::error::InvalidZipFileError)
pub mod invalid_zip_file_error {
    /// A builder for [`InvalidZipFileError`](crate::error::InvalidZipFileError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.r#type = Some(inp.into());
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.r#type = inp;
            self
        }
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`InvalidZipFileError`](crate::error::InvalidZipFileError)
        pub fn build(self) -> crate::error::InvalidZipFileError {
            crate::error::InvalidZipFileError {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl InvalidZipFileError {
    /// Creates a new builder-style object to manufacture [`InvalidZipFileError`](crate::error::InvalidZipFileError)
    pub fn builder() -> crate::error::invalid_zip_file_error::Builder {
        crate::error::invalid_zip_file_error::Builder::default()
    }
}

/// <p>The Subnet ID provided in the Lambda function VPC configuration is invalid.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidSubnetIDError {
    #[serde(rename = "Type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub r#type: std::option::Option<std::string::String>,
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidSubnetIDError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidSubnetIDError");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidSubnetIDError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSubnetIDError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidSubnetIDError [InvalidSubnetIDException]")?;
        if let Some(inner_23) = &self.message {
            write!(f, ": {}", inner_23)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSubnetIDError {}
/// See [`InvalidSubnetIDError`](crate::error::InvalidSubnetIDError)
pub mod invalid_subnet_id_error {
    /// A builder for [`InvalidSubnetIDError`](crate::error::InvalidSubnetIDError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.r#type = Some(inp.into());
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.r#type = inp;
            self
        }
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSubnetIDError`](crate::error::InvalidSubnetIDError)
        pub fn build(self) -> crate::error::InvalidSubnetIDError {
            crate::error::InvalidSubnetIDError {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl InvalidSubnetIDError {
    /// Creates a new builder-style object to manufacture [`InvalidSubnetIDError`](crate::error::InvalidSubnetIDError)
    pub fn builder() -> crate::error::invalid_subnet_id_error::Builder {
        crate::error::invalid_subnet_id_error::Builder::default()
    }
}

/// <p>The Security Group ID provided in the Lambda function VPC configuration is invalid.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidSecurityGroupIDError {
    #[serde(rename = "Type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub r#type: std::option::Option<std::string::String>,
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidSecurityGroupIDError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidSecurityGroupIDError");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidSecurityGroupIDError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSecurityGroupIDError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidSecurityGroupIDError [InvalidSecurityGroupIDException]"
        )?;
        if let Some(inner_24) = &self.message {
            write!(f, ": {}", inner_24)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSecurityGroupIDError {}
/// See [`InvalidSecurityGroupIDError`](crate::error::InvalidSecurityGroupIDError)
pub mod invalid_security_group_id_error {
    /// A builder for [`InvalidSecurityGroupIDError`](crate::error::InvalidSecurityGroupIDError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.r#type = Some(inp.into());
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.r#type = inp;
            self
        }
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSecurityGroupIDError`](crate::error::InvalidSecurityGroupIDError)
        pub fn build(self) -> crate::error::InvalidSecurityGroupIDError {
            crate::error::InvalidSecurityGroupIDError {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl InvalidSecurityGroupIDError {
    /// Creates a new builder-style object to manufacture [`InvalidSecurityGroupIDError`](crate::error::InvalidSecurityGroupIDError)
    pub fn builder() -> crate::error::invalid_security_group_id_error::Builder {
        crate::error::invalid_security_group_id_error::Builder::default()
    }
}

/// <p>AWS Lambda was not able to create an elastic network interface in the VPC, specified as part of Lambda
/// function configuration, because the limit for network interfaces has been reached.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ENILimitReachedError {
    #[serde(rename = "Type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub r#type: std::option::Option<std::string::String>,
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ENILimitReachedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ENILimitReachedError");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ENILimitReachedError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ENILimitReachedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ENILimitReachedError [ENILimitReachedException]")?;
        if let Some(inner_25) = &self.message {
            write!(f, ": {}", inner_25)?;
        }
        Ok(())
    }
}
impl std::error::Error for ENILimitReachedError {}
/// See [`ENILimitReachedError`](crate::error::ENILimitReachedError)
pub mod eni_limit_reached_error {
    /// A builder for [`ENILimitReachedError`](crate::error::ENILimitReachedError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.r#type = Some(inp.into());
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.r#type = inp;
            self
        }
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`ENILimitReachedError`](crate::error::ENILimitReachedError)
        pub fn build(self) -> crate::error::ENILimitReachedError {
            crate::error::ENILimitReachedError {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl ENILimitReachedError {
    /// Creates a new builder-style object to manufacture [`ENILimitReachedError`](crate::error::ENILimitReachedError)
    pub fn builder() -> crate::error::eni_limit_reached_error::Builder {
        crate::error::eni_limit_reached_error::Builder::default()
    }
}

/// <p>The function was able to make a network connection to the configured file system, but the mount operation
/// timed out.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct EFSMountTimeoutError {
    #[serde(rename = "Type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub r#type: std::option::Option<std::string::String>,
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EFSMountTimeoutError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EFSMountTimeoutError");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl EFSMountTimeoutError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EFSMountTimeoutError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EFSMountTimeoutError [EFSMountTimeoutException]")?;
        if let Some(inner_26) = &self.message {
            write!(f, ": {}", inner_26)?;
        }
        Ok(())
    }
}
impl std::error::Error for EFSMountTimeoutError {}
/// See [`EFSMountTimeoutError`](crate::error::EFSMountTimeoutError)
pub mod efs_mount_timeout_error {
    /// A builder for [`EFSMountTimeoutError`](crate::error::EFSMountTimeoutError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.r#type = Some(inp.into());
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.r#type = inp;
            self
        }
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`EFSMountTimeoutError`](crate::error::EFSMountTimeoutError)
        pub fn build(self) -> crate::error::EFSMountTimeoutError {
            crate::error::EFSMountTimeoutError {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl EFSMountTimeoutError {
    /// Creates a new builder-style object to manufacture [`EFSMountTimeoutError`](crate::error::EFSMountTimeoutError)
    pub fn builder() -> crate::error::efs_mount_timeout_error::Builder {
        crate::error::efs_mount_timeout_error::Builder::default()
    }
}

/// <p>The function couldn't mount the configured file system due to a permission or configuration issue.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct EFSMountFailureError {
    #[serde(rename = "Type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub r#type: std::option::Option<std::string::String>,
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EFSMountFailureError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EFSMountFailureError");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl EFSMountFailureError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EFSMountFailureError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EFSMountFailureError [EFSMountFailureException]")?;
        if let Some(inner_27) = &self.message {
            write!(f, ": {}", inner_27)?;
        }
        Ok(())
    }
}
impl std::error::Error for EFSMountFailureError {}
/// See [`EFSMountFailureError`](crate::error::EFSMountFailureError)
pub mod efs_mount_failure_error {
    /// A builder for [`EFSMountFailureError`](crate::error::EFSMountFailureError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.r#type = Some(inp.into());
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.r#type = inp;
            self
        }
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`EFSMountFailureError`](crate::error::EFSMountFailureError)
        pub fn build(self) -> crate::error::EFSMountFailureError {
            crate::error::EFSMountFailureError {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl EFSMountFailureError {
    /// Creates a new builder-style object to manufacture [`EFSMountFailureError`](crate::error::EFSMountFailureError)
    pub fn builder() -> crate::error::efs_mount_failure_error::Builder {
        crate::error::efs_mount_failure_error::Builder::default()
    }
}

/// <p>The function couldn't make a network connection to the configured file system.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct EFSMountConnectivityError {
    #[serde(rename = "Type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub r#type: std::option::Option<std::string::String>,
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EFSMountConnectivityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EFSMountConnectivityError");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl EFSMountConnectivityError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EFSMountConnectivityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "EFSMountConnectivityError [EFSMountConnectivityException]"
        )?;
        if let Some(inner_28) = &self.message {
            write!(f, ": {}", inner_28)?;
        }
        Ok(())
    }
}
impl std::error::Error for EFSMountConnectivityError {}
/// See [`EFSMountConnectivityError`](crate::error::EFSMountConnectivityError)
pub mod efs_mount_connectivity_error {
    /// A builder for [`EFSMountConnectivityError`](crate::error::EFSMountConnectivityError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.r#type = Some(inp.into());
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.r#type = inp;
            self
        }
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`EFSMountConnectivityError`](crate::error::EFSMountConnectivityError)
        pub fn build(self) -> crate::error::EFSMountConnectivityError {
            crate::error::EFSMountConnectivityError {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl EFSMountConnectivityError {
    /// Creates a new builder-style object to manufacture [`EFSMountConnectivityError`](crate::error::EFSMountConnectivityError)
    pub fn builder() -> crate::error::efs_mount_connectivity_error::Builder {
        crate::error::efs_mount_connectivity_error::Builder::default()
    }
}

/// <p>An error occured when reading from or writing to a connected file system.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct EFSIOError {
    #[serde(rename = "Type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub r#type: std::option::Option<std::string::String>,
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EFSIOError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EFSIOError");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl EFSIOError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EFSIOError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EFSIOError [EFSIOException]")?;
        if let Some(inner_29) = &self.message {
            write!(f, ": {}", inner_29)?;
        }
        Ok(())
    }
}
impl std::error::Error for EFSIOError {}
/// See [`EFSIOError`](crate::error::EFSIOError)
pub mod efsio_error {
    /// A builder for [`EFSIOError`](crate::error::EFSIOError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.r#type = Some(inp.into());
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.r#type = inp;
            self
        }
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`EFSIOError`](crate::error::EFSIOError)
        pub fn build(self) -> crate::error::EFSIOError {
            crate::error::EFSIOError {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl EFSIOError {
    /// Creates a new builder-style object to manufacture [`EFSIOError`](crate::error::EFSIOError)
    pub fn builder() -> crate::error::efsio_error::Builder {
        crate::error::efsio_error::Builder::default()
    }
}

/// <p>AWS Lambda received an unexpected EC2 client exception while setting up for the Lambda function.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct EC2UnexpectedError {
    #[serde(rename = "Type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub r#type: std::option::Option<std::string::String>,
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
    #[serde(rename = "EC2ErrorCode")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub ec2_error_code: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EC2UnexpectedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EC2UnexpectedError");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.field("ec2_error_code", &self.ec2_error_code);
        formatter.finish()
    }
}
impl EC2UnexpectedError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EC2UnexpectedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EC2UnexpectedError [EC2UnexpectedException]")?;
        if let Some(inner_30) = &self.message {
            write!(f, ": {}", inner_30)?;
        }
        Ok(())
    }
}
impl std::error::Error for EC2UnexpectedError {}
/// See [`EC2UnexpectedError`](crate::error::EC2UnexpectedError)
pub mod ec2_unexpected_error {
    /// A builder for [`EC2UnexpectedError`](crate::error::EC2UnexpectedError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) ec2_error_code: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.r#type = Some(inp.into());
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.r#type = inp;
            self
        }
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        pub fn ec2_error_code(mut self, inp: impl Into<std::string::String>) -> Self {
            self.ec2_error_code = Some(inp.into());
            self
        }
        pub fn set_ec2_error_code(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.ec2_error_code = inp;
            self
        }
        /// Consumes the builder and constructs a [`EC2UnexpectedError`](crate::error::EC2UnexpectedError)
        pub fn build(self) -> crate::error::EC2UnexpectedError {
            crate::error::EC2UnexpectedError {
                r#type: self.r#type,
                message: self.message,
                ec2_error_code: self.ec2_error_code,
            }
        }
    }
}
impl EC2UnexpectedError {
    /// Creates a new builder-style object to manufacture [`EC2UnexpectedError`](crate::error::EC2UnexpectedError)
    pub fn builder() -> crate::error::ec2_unexpected_error::Builder {
        crate::error::ec2_unexpected_error::Builder::default()
    }
}

/// <p>AWS Lambda was throttled by Amazon EC2 during Lambda function initialization using the execution role provided
/// for the Lambda function.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct EC2ThrottledError {
    #[serde(rename = "Type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub r#type: std::option::Option<std::string::String>,
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EC2ThrottledError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EC2ThrottledError");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl EC2ThrottledError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EC2ThrottledError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EC2ThrottledError [EC2ThrottledException]")?;
        if let Some(inner_31) = &self.message {
            write!(f, ": {}", inner_31)?;
        }
        Ok(())
    }
}
impl std::error::Error for EC2ThrottledError {}
/// See [`EC2ThrottledError`](crate::error::EC2ThrottledError)
pub mod ec2_throttled_error {
    /// A builder for [`EC2ThrottledError`](crate::error::EC2ThrottledError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.r#type = Some(inp.into());
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.r#type = inp;
            self
        }
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`EC2ThrottledError`](crate::error::EC2ThrottledError)
        pub fn build(self) -> crate::error::EC2ThrottledError {
            crate::error::EC2ThrottledError {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl EC2ThrottledError {
    /// Creates a new builder-style object to manufacture [`EC2ThrottledError`](crate::error::EC2ThrottledError)
    pub fn builder() -> crate::error::ec2_throttled_error::Builder {
        crate::error::ec2_throttled_error::Builder::default()
    }
}

/// <p>Need additional permissions to configure VPC settings.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct EC2AccessDeniedError {
    #[serde(rename = "Type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub r#type: std::option::Option<std::string::String>,
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EC2AccessDeniedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EC2AccessDeniedError");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl EC2AccessDeniedError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EC2AccessDeniedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EC2AccessDeniedError [EC2AccessDeniedException]")?;
        if let Some(inner_32) = &self.message {
            write!(f, ": {}", inner_32)?;
        }
        Ok(())
    }
}
impl std::error::Error for EC2AccessDeniedError {}
/// See [`EC2AccessDeniedError`](crate::error::EC2AccessDeniedError)
pub mod ec2_access_denied_error {
    /// A builder for [`EC2AccessDeniedError`](crate::error::EC2AccessDeniedError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.r#type = Some(inp.into());
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.r#type = inp;
            self
        }
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`EC2AccessDeniedError`](crate::error::EC2AccessDeniedError)
        pub fn build(self) -> crate::error::EC2AccessDeniedError {
            crate::error::EC2AccessDeniedError {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl EC2AccessDeniedError {
    /// Creates a new builder-style object to manufacture [`EC2AccessDeniedError`](crate::error::EC2AccessDeniedError)
    pub fn builder() -> crate::error::ec2_access_denied_error::Builder {
        crate::error::ec2_access_denied_error::Builder::default()
    }
}

/// <p>The specified configuration does not exist.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ProvisionedConcurrencyConfigNotFoundError {
    #[serde(rename = "Type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub r#type: std::option::Option<std::string::String>,
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ProvisionedConcurrencyConfigNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProvisionedConcurrencyConfigNotFoundError");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ProvisionedConcurrencyConfigNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ProvisionedConcurrencyConfigNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ProvisionedConcurrencyConfigNotFoundError [ProvisionedConcurrencyConfigNotFoundException]")?;
        if let Some(inner_33) = &self.message {
            write!(f, ": {}", inner_33)?;
        }
        Ok(())
    }
}
impl std::error::Error for ProvisionedConcurrencyConfigNotFoundError {}
/// See [`ProvisionedConcurrencyConfigNotFoundError`](crate::error::ProvisionedConcurrencyConfigNotFoundError)
pub mod provisioned_concurrency_config_not_found_error {
    /// A builder for [`ProvisionedConcurrencyConfigNotFoundError`](crate::error::ProvisionedConcurrencyConfigNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.r#type = Some(inp.into());
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.r#type = inp;
            self
        }
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`ProvisionedConcurrencyConfigNotFoundError`](crate::error::ProvisionedConcurrencyConfigNotFoundError)
        pub fn build(self) -> crate::error::ProvisionedConcurrencyConfigNotFoundError {
            crate::error::ProvisionedConcurrencyConfigNotFoundError {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl ProvisionedConcurrencyConfigNotFoundError {
    /// Creates a new builder-style object to manufacture [`ProvisionedConcurrencyConfigNotFoundError`](crate::error::ProvisionedConcurrencyConfigNotFoundError)
    pub fn builder() -> crate::error::provisioned_concurrency_config_not_found_error::Builder {
        crate::error::provisioned_concurrency_config_not_found_error::Builder::default()
    }
}

/// <p>The permissions policy for the resource is too large. <a href="https://docs.aws.amazon.com/lambda/latest/dg/limits.html">Learn more</a>
/// </p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PolicyLengthExceededError {
    #[serde(rename = "Type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub r#type: std::option::Option<std::string::String>,
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PolicyLengthExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PolicyLengthExceededError");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PolicyLengthExceededError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PolicyLengthExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "PolicyLengthExceededError [PolicyLengthExceededException]"
        )?;
        if let Some(inner_34) = &self.message {
            write!(f, ": {}", inner_34)?;
        }
        Ok(())
    }
}
impl std::error::Error for PolicyLengthExceededError {}
/// See [`PolicyLengthExceededError`](crate::error::PolicyLengthExceededError)
pub mod policy_length_exceeded_error {
    /// A builder for [`PolicyLengthExceededError`](crate::error::PolicyLengthExceededError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.r#type = Some(inp.into());
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.r#type = inp;
            self
        }
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`PolicyLengthExceededError`](crate::error::PolicyLengthExceededError)
        pub fn build(self) -> crate::error::PolicyLengthExceededError {
            crate::error::PolicyLengthExceededError {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl PolicyLengthExceededError {
    /// Creates a new builder-style object to manufacture [`PolicyLengthExceededError`](crate::error::PolicyLengthExceededError)
    pub fn builder() -> crate::error::policy_length_exceeded_error::Builder {
        crate::error::policy_length_exceeded_error::Builder::default()
    }
}
