// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddLayerVersionPermissionError {
    pub kind: AddLayerVersionPermissionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddLayerVersionPermissionErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    PolicyLengthExceededException(crate::error::PolicyLengthExceededException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    ResourceConflictException(crate::error::ResourceConflictException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddLayerVersionPermissionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AddLayerVersionPermissionErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            AddLayerVersionPermissionErrorKind::PolicyLengthExceededException(_inner) => {
                _inner.fmt(f)
            }
            AddLayerVersionPermissionErrorKind::PreconditionFailedException(_inner) => {
                _inner.fmt(f)
            }
            AddLayerVersionPermissionErrorKind::ResourceConflictException(_inner) => _inner.fmt(f),
            AddLayerVersionPermissionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AddLayerVersionPermissionErrorKind::ServiceException(_inner) => _inner.fmt(f),
            AddLayerVersionPermissionErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            AddLayerVersionPermissionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AddLayerVersionPermissionError {
    fn code(&self) -> Option<&str> {
        AddLayerVersionPermissionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddLayerVersionPermissionError {
    pub fn new(kind: AddLayerVersionPermissionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AddLayerVersionPermissionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AddLayerVersionPermissionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddLayerVersionPermissionErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_policy_length_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddLayerVersionPermissionErrorKind::PolicyLengthExceededException(_)
        )
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddLayerVersionPermissionErrorKind::PreconditionFailedException(_)
        )
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddLayerVersionPermissionErrorKind::ResourceConflictException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddLayerVersionPermissionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddLayerVersionPermissionErrorKind::ServiceException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddLayerVersionPermissionErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for AddLayerVersionPermissionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AddLayerVersionPermissionErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            AddLayerVersionPermissionErrorKind::PolicyLengthExceededException(_inner) => {
                Some(_inner)
            }
            AddLayerVersionPermissionErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            AddLayerVersionPermissionErrorKind::ResourceConflictException(_inner) => Some(_inner),
            AddLayerVersionPermissionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AddLayerVersionPermissionErrorKind::ServiceException(_inner) => Some(_inner),
            AddLayerVersionPermissionErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            AddLayerVersionPermissionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddPermissionError {
    pub kind: AddPermissionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddPermissionErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    PolicyLengthExceededException(crate::error::PolicyLengthExceededException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    ResourceConflictException(crate::error::ResourceConflictException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddPermissionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AddPermissionErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            AddPermissionErrorKind::PolicyLengthExceededException(_inner) => _inner.fmt(f),
            AddPermissionErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            AddPermissionErrorKind::ResourceConflictException(_inner) => _inner.fmt(f),
            AddPermissionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AddPermissionErrorKind::ServiceException(_inner) => _inner.fmt(f),
            AddPermissionErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            AddPermissionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AddPermissionError {
    fn code(&self) -> Option<&str> {
        AddPermissionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddPermissionError {
    pub fn new(kind: AddPermissionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AddPermissionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AddPermissionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddPermissionErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_policy_length_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddPermissionErrorKind::PolicyLengthExceededException(_)
        )
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddPermissionErrorKind::PreconditionFailedException(_)
        )
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddPermissionErrorKind::ResourceConflictException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddPermissionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, AddPermissionErrorKind::ServiceException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddPermissionErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for AddPermissionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AddPermissionErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            AddPermissionErrorKind::PolicyLengthExceededException(_inner) => Some(_inner),
            AddPermissionErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            AddPermissionErrorKind::ResourceConflictException(_inner) => Some(_inner),
            AddPermissionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AddPermissionErrorKind::ServiceException(_inner) => Some(_inner),
            AddPermissionErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            AddPermissionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAliasError {
    pub kind: CreateAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAliasErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceConflictException(crate::error::ResourceConflictException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAliasErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            CreateAliasErrorKind::ResourceConflictException(_inner) => _inner.fmt(f),
            CreateAliasErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateAliasErrorKind::ServiceException(_inner) => _inner.fmt(f),
            CreateAliasErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateAliasError {
    fn code(&self) -> Option<&str> {
        CreateAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAliasError {
    pub fn new(kind: CreateAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAliasErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAliasErrorKind::ResourceConflictException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAliasErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, CreateAliasErrorKind::ServiceException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAliasErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAliasErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            CreateAliasErrorKind::ResourceConflictException(_inner) => Some(_inner),
            CreateAliasErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateAliasErrorKind::ServiceException(_inner) => Some(_inner),
            CreateAliasErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateCodeSigningConfigError {
    pub kind: CreateCodeSigningConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCodeSigningConfigErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ServiceException(crate::error::ServiceException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateCodeSigningConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateCodeSigningConfigErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            CreateCodeSigningConfigErrorKind::ServiceException(_inner) => _inner.fmt(f),
            CreateCodeSigningConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateCodeSigningConfigError {
    fn code(&self) -> Option<&str> {
        CreateCodeSigningConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCodeSigningConfigError {
    pub fn new(kind: CreateCodeSigningConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateCodeSigningConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateCodeSigningConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCodeSigningConfigErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCodeSigningConfigErrorKind::ServiceException(_)
        )
    }
}
impl std::error::Error for CreateCodeSigningConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateCodeSigningConfigErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            CreateCodeSigningConfigErrorKind::ServiceException(_inner) => Some(_inner),
            CreateCodeSigningConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateEventSourceMappingError {
    pub kind: CreateEventSourceMappingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateEventSourceMappingErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceConflictException(crate::error::ResourceConflictException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateEventSourceMappingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateEventSourceMappingErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            CreateEventSourceMappingErrorKind::ResourceConflictException(_inner) => _inner.fmt(f),
            CreateEventSourceMappingErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateEventSourceMappingErrorKind::ServiceException(_inner) => _inner.fmt(f),
            CreateEventSourceMappingErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateEventSourceMappingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateEventSourceMappingError {
    fn code(&self) -> Option<&str> {
        CreateEventSourceMappingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateEventSourceMappingError {
    pub fn new(kind: CreateEventSourceMappingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateEventSourceMappingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateEventSourceMappingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEventSourceMappingErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEventSourceMappingErrorKind::ResourceConflictException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEventSourceMappingErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEventSourceMappingErrorKind::ServiceException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEventSourceMappingErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateEventSourceMappingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateEventSourceMappingErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            CreateEventSourceMappingErrorKind::ResourceConflictException(_inner) => Some(_inner),
            CreateEventSourceMappingErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateEventSourceMappingErrorKind::ServiceException(_inner) => Some(_inner),
            CreateEventSourceMappingErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateEventSourceMappingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateFunctionError {
    pub kind: CreateFunctionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateFunctionErrorKind {
    CodeSigningConfigNotFoundException(crate::error::CodeSigningConfigNotFoundException),
    CodeStorageExceededException(crate::error::CodeStorageExceededException),
    CodeVerificationFailedException(crate::error::CodeVerificationFailedException),
    InvalidCodeSignatureException(crate::error::InvalidCodeSignatureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceConflictException(crate::error::ResourceConflictException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateFunctionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateFunctionErrorKind::CodeSigningConfigNotFoundException(_inner) => _inner.fmt(f),
            CreateFunctionErrorKind::CodeStorageExceededException(_inner) => _inner.fmt(f),
            CreateFunctionErrorKind::CodeVerificationFailedException(_inner) => _inner.fmt(f),
            CreateFunctionErrorKind::InvalidCodeSignatureException(_inner) => _inner.fmt(f),
            CreateFunctionErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            CreateFunctionErrorKind::ResourceConflictException(_inner) => _inner.fmt(f),
            CreateFunctionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateFunctionErrorKind::ServiceException(_inner) => _inner.fmt(f),
            CreateFunctionErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateFunctionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateFunctionError {
    fn code(&self) -> Option<&str> {
        CreateFunctionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateFunctionError {
    pub fn new(kind: CreateFunctionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateFunctionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateFunctionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_code_signing_config_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFunctionErrorKind::CodeSigningConfigNotFoundException(_)
        )
    }
    pub fn is_code_storage_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFunctionErrorKind::CodeStorageExceededException(_)
        )
    }
    pub fn is_code_verification_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFunctionErrorKind::CodeVerificationFailedException(_)
        )
    }
    pub fn is_invalid_code_signature_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFunctionErrorKind::InvalidCodeSignatureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFunctionErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFunctionErrorKind::ResourceConflictException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFunctionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, CreateFunctionErrorKind::ServiceException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFunctionErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateFunctionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateFunctionErrorKind::CodeSigningConfigNotFoundException(_inner) => Some(_inner),
            CreateFunctionErrorKind::CodeStorageExceededException(_inner) => Some(_inner),
            CreateFunctionErrorKind::CodeVerificationFailedException(_inner) => Some(_inner),
            CreateFunctionErrorKind::InvalidCodeSignatureException(_inner) => Some(_inner),
            CreateFunctionErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            CreateFunctionErrorKind::ResourceConflictException(_inner) => Some(_inner),
            CreateFunctionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateFunctionErrorKind::ServiceException(_inner) => Some(_inner),
            CreateFunctionErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateFunctionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAliasError {
    pub kind: DeleteAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAliasErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceConflictException(crate::error::ResourceConflictException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAliasErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DeleteAliasErrorKind::ResourceConflictException(_inner) => _inner.fmt(f),
            DeleteAliasErrorKind::ServiceException(_inner) => _inner.fmt(f),
            DeleteAliasErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAliasError {
    fn code(&self) -> Option<&str> {
        DeleteAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAliasError {
    pub fn new(kind: DeleteAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAliasErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAliasErrorKind::ResourceConflictException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, DeleteAliasErrorKind::ServiceException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAliasErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAliasErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DeleteAliasErrorKind::ResourceConflictException(_inner) => Some(_inner),
            DeleteAliasErrorKind::ServiceException(_inner) => Some(_inner),
            DeleteAliasErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteCodeSigningConfigError {
    pub kind: DeleteCodeSigningConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCodeSigningConfigErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceConflictException(crate::error::ResourceConflictException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteCodeSigningConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteCodeSigningConfigErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DeleteCodeSigningConfigErrorKind::ResourceConflictException(_inner) => _inner.fmt(f),
            DeleteCodeSigningConfigErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteCodeSigningConfigErrorKind::ServiceException(_inner) => _inner.fmt(f),
            DeleteCodeSigningConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteCodeSigningConfigError {
    fn code(&self) -> Option<&str> {
        DeleteCodeSigningConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteCodeSigningConfigError {
    pub fn new(kind: DeleteCodeSigningConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteCodeSigningConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteCodeSigningConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCodeSigningConfigErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCodeSigningConfigErrorKind::ResourceConflictException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCodeSigningConfigErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCodeSigningConfigErrorKind::ServiceException(_)
        )
    }
}
impl std::error::Error for DeleteCodeSigningConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteCodeSigningConfigErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DeleteCodeSigningConfigErrorKind::ResourceConflictException(_inner) => Some(_inner),
            DeleteCodeSigningConfigErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteCodeSigningConfigErrorKind::ServiceException(_inner) => Some(_inner),
            DeleteCodeSigningConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteEventSourceMappingError {
    pub kind: DeleteEventSourceMappingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteEventSourceMappingErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceInUseException(crate::error::ResourceInUseException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteEventSourceMappingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteEventSourceMappingErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DeleteEventSourceMappingErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            DeleteEventSourceMappingErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteEventSourceMappingErrorKind::ServiceException(_inner) => _inner.fmt(f),
            DeleteEventSourceMappingErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteEventSourceMappingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteEventSourceMappingError {
    fn code(&self) -> Option<&str> {
        DeleteEventSourceMappingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteEventSourceMappingError {
    pub fn new(kind: DeleteEventSourceMappingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteEventSourceMappingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteEventSourceMappingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEventSourceMappingErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEventSourceMappingErrorKind::ResourceInUseException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEventSourceMappingErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEventSourceMappingErrorKind::ServiceException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEventSourceMappingErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteEventSourceMappingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteEventSourceMappingErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DeleteEventSourceMappingErrorKind::ResourceInUseException(_inner) => Some(_inner),
            DeleteEventSourceMappingErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteEventSourceMappingErrorKind::ServiceException(_inner) => Some(_inner),
            DeleteEventSourceMappingErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteEventSourceMappingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteFunctionError {
    pub kind: DeleteFunctionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteFunctionErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceConflictException(crate::error::ResourceConflictException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteFunctionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteFunctionErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DeleteFunctionErrorKind::ResourceConflictException(_inner) => _inner.fmt(f),
            DeleteFunctionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteFunctionErrorKind::ServiceException(_inner) => _inner.fmt(f),
            DeleteFunctionErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteFunctionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteFunctionError {
    fn code(&self) -> Option<&str> {
        DeleteFunctionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteFunctionError {
    pub fn new(kind: DeleteFunctionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteFunctionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteFunctionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFunctionErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFunctionErrorKind::ResourceConflictException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFunctionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, DeleteFunctionErrorKind::ServiceException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFunctionErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteFunctionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteFunctionErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DeleteFunctionErrorKind::ResourceConflictException(_inner) => Some(_inner),
            DeleteFunctionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteFunctionErrorKind::ServiceException(_inner) => Some(_inner),
            DeleteFunctionErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteFunctionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteFunctionCodeSigningConfigError {
    pub kind: DeleteFunctionCodeSigningConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteFunctionCodeSigningConfigErrorKind {
    CodeSigningConfigNotFoundException(crate::error::CodeSigningConfigNotFoundException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceConflictException(crate::error::ResourceConflictException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteFunctionCodeSigningConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteFunctionCodeSigningConfigErrorKind::CodeSigningConfigNotFoundException(
                _inner,
            ) => _inner.fmt(f),
            DeleteFunctionCodeSigningConfigErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DeleteFunctionCodeSigningConfigErrorKind::ResourceConflictException(_inner) => {
                _inner.fmt(f)
            }
            DeleteFunctionCodeSigningConfigErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DeleteFunctionCodeSigningConfigErrorKind::ServiceException(_inner) => _inner.fmt(f),
            DeleteFunctionCodeSigningConfigErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            DeleteFunctionCodeSigningConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteFunctionCodeSigningConfigError {
    fn code(&self) -> Option<&str> {
        DeleteFunctionCodeSigningConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteFunctionCodeSigningConfigError {
    pub fn new(kind: DeleteFunctionCodeSigningConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteFunctionCodeSigningConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteFunctionCodeSigningConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_code_signing_config_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFunctionCodeSigningConfigErrorKind::CodeSigningConfigNotFoundException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFunctionCodeSigningConfigErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFunctionCodeSigningConfigErrorKind::ResourceConflictException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFunctionCodeSigningConfigErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFunctionCodeSigningConfigErrorKind::ServiceException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFunctionCodeSigningConfigErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteFunctionCodeSigningConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteFunctionCodeSigningConfigErrorKind::CodeSigningConfigNotFoundException(
                _inner,
            ) => Some(_inner),
            DeleteFunctionCodeSigningConfigErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DeleteFunctionCodeSigningConfigErrorKind::ResourceConflictException(_inner) => {
                Some(_inner)
            }
            DeleteFunctionCodeSigningConfigErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DeleteFunctionCodeSigningConfigErrorKind::ServiceException(_inner) => Some(_inner),
            DeleteFunctionCodeSigningConfigErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            DeleteFunctionCodeSigningConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteFunctionConcurrencyError {
    pub kind: DeleteFunctionConcurrencyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteFunctionConcurrencyErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceConflictException(crate::error::ResourceConflictException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteFunctionConcurrencyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteFunctionConcurrencyErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DeleteFunctionConcurrencyErrorKind::ResourceConflictException(_inner) => _inner.fmt(f),
            DeleteFunctionConcurrencyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteFunctionConcurrencyErrorKind::ServiceException(_inner) => _inner.fmt(f),
            DeleteFunctionConcurrencyErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteFunctionConcurrencyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteFunctionConcurrencyError {
    fn code(&self) -> Option<&str> {
        DeleteFunctionConcurrencyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteFunctionConcurrencyError {
    pub fn new(kind: DeleteFunctionConcurrencyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteFunctionConcurrencyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteFunctionConcurrencyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFunctionConcurrencyErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFunctionConcurrencyErrorKind::ResourceConflictException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFunctionConcurrencyErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFunctionConcurrencyErrorKind::ServiceException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFunctionConcurrencyErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteFunctionConcurrencyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteFunctionConcurrencyErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DeleteFunctionConcurrencyErrorKind::ResourceConflictException(_inner) => Some(_inner),
            DeleteFunctionConcurrencyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteFunctionConcurrencyErrorKind::ServiceException(_inner) => Some(_inner),
            DeleteFunctionConcurrencyErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteFunctionConcurrencyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteFunctionEventInvokeConfigError {
    pub kind: DeleteFunctionEventInvokeConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteFunctionEventInvokeConfigErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceConflictException(crate::error::ResourceConflictException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteFunctionEventInvokeConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteFunctionEventInvokeConfigErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DeleteFunctionEventInvokeConfigErrorKind::ResourceConflictException(_inner) => {
                _inner.fmt(f)
            }
            DeleteFunctionEventInvokeConfigErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DeleteFunctionEventInvokeConfigErrorKind::ServiceException(_inner) => _inner.fmt(f),
            DeleteFunctionEventInvokeConfigErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            DeleteFunctionEventInvokeConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteFunctionEventInvokeConfigError {
    fn code(&self) -> Option<&str> {
        DeleteFunctionEventInvokeConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteFunctionEventInvokeConfigError {
    pub fn new(kind: DeleteFunctionEventInvokeConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteFunctionEventInvokeConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteFunctionEventInvokeConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFunctionEventInvokeConfigErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFunctionEventInvokeConfigErrorKind::ResourceConflictException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFunctionEventInvokeConfigErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFunctionEventInvokeConfigErrorKind::ServiceException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFunctionEventInvokeConfigErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteFunctionEventInvokeConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteFunctionEventInvokeConfigErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DeleteFunctionEventInvokeConfigErrorKind::ResourceConflictException(_inner) => {
                Some(_inner)
            }
            DeleteFunctionEventInvokeConfigErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DeleteFunctionEventInvokeConfigErrorKind::ServiceException(_inner) => Some(_inner),
            DeleteFunctionEventInvokeConfigErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            DeleteFunctionEventInvokeConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteLayerVersionError {
    pub kind: DeleteLayerVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteLayerVersionErrorKind {
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteLayerVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteLayerVersionErrorKind::ServiceException(_inner) => _inner.fmt(f),
            DeleteLayerVersionErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteLayerVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteLayerVersionError {
    fn code(&self) -> Option<&str> {
        DeleteLayerVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteLayerVersionError {
    pub fn new(kind: DeleteLayerVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteLayerVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteLayerVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, DeleteLayerVersionErrorKind::ServiceException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLayerVersionErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteLayerVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteLayerVersionErrorKind::ServiceException(_inner) => Some(_inner),
            DeleteLayerVersionErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteLayerVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteProvisionedConcurrencyConfigError {
    pub kind: DeleteProvisionedConcurrencyConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteProvisionedConcurrencyConfigErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceConflictException(crate::error::ResourceConflictException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteProvisionedConcurrencyConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteProvisionedConcurrencyConfigErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DeleteProvisionedConcurrencyConfigErrorKind::ResourceConflictException(_inner) => {
                _inner.fmt(f)
            }
            DeleteProvisionedConcurrencyConfigErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DeleteProvisionedConcurrencyConfigErrorKind::ServiceException(_inner) => _inner.fmt(f),
            DeleteProvisionedConcurrencyConfigErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            DeleteProvisionedConcurrencyConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteProvisionedConcurrencyConfigError {
    fn code(&self) -> Option<&str> {
        DeleteProvisionedConcurrencyConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteProvisionedConcurrencyConfigError {
    pub fn new(
        kind: DeleteProvisionedConcurrencyConfigErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteProvisionedConcurrencyConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteProvisionedConcurrencyConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProvisionedConcurrencyConfigErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProvisionedConcurrencyConfigErrorKind::ResourceConflictException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProvisionedConcurrencyConfigErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProvisionedConcurrencyConfigErrorKind::ServiceException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProvisionedConcurrencyConfigErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteProvisionedConcurrencyConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteProvisionedConcurrencyConfigErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DeleteProvisionedConcurrencyConfigErrorKind::ResourceConflictException(_inner) => {
                Some(_inner)
            }
            DeleteProvisionedConcurrencyConfigErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DeleteProvisionedConcurrencyConfigErrorKind::ServiceException(_inner) => Some(_inner),
            DeleteProvisionedConcurrencyConfigErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            DeleteProvisionedConcurrencyConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAccountSettingsError {
    pub kind: GetAccountSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAccountSettingsErrorKind {
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAccountSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAccountSettingsErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetAccountSettingsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetAccountSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAccountSettingsError {
    fn code(&self) -> Option<&str> {
        GetAccountSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAccountSettingsError {
    pub fn new(kind: GetAccountSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAccountSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAccountSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, GetAccountSettingsErrorKind::ServiceException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAccountSettingsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetAccountSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAccountSettingsErrorKind::ServiceException(_inner) => Some(_inner),
            GetAccountSettingsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetAccountSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAliasError {
    pub kind: GetAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAliasErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAliasErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            GetAliasErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetAliasErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetAliasErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAliasError {
    fn code(&self) -> Option<&str> {
        GetAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAliasError {
    pub fn new(kind: GetAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAliasErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetAliasErrorKind::ResourceNotFoundException(_))
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, GetAliasErrorKind::ServiceException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, GetAliasErrorKind::TooManyRequestsException(_))
    }
}
impl std::error::Error for GetAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAliasErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            GetAliasErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetAliasErrorKind::ServiceException(_inner) => Some(_inner),
            GetAliasErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCodeSigningConfigError {
    pub kind: GetCodeSigningConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCodeSigningConfigErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCodeSigningConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCodeSigningConfigErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            GetCodeSigningConfigErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetCodeSigningConfigErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetCodeSigningConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetCodeSigningConfigError {
    fn code(&self) -> Option<&str> {
        GetCodeSigningConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCodeSigningConfigError {
    pub fn new(kind: GetCodeSigningConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCodeSigningConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCodeSigningConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCodeSigningConfigErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCodeSigningConfigErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCodeSigningConfigErrorKind::ServiceException(_)
        )
    }
}
impl std::error::Error for GetCodeSigningConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCodeSigningConfigErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            GetCodeSigningConfigErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetCodeSigningConfigErrorKind::ServiceException(_inner) => Some(_inner),
            GetCodeSigningConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetEventSourceMappingError {
    pub kind: GetEventSourceMappingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetEventSourceMappingErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetEventSourceMappingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetEventSourceMappingErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            GetEventSourceMappingErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetEventSourceMappingErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetEventSourceMappingErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetEventSourceMappingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetEventSourceMappingError {
    fn code(&self) -> Option<&str> {
        GetEventSourceMappingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetEventSourceMappingError {
    pub fn new(kind: GetEventSourceMappingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetEventSourceMappingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetEventSourceMappingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEventSourceMappingErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEventSourceMappingErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEventSourceMappingErrorKind::ServiceException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEventSourceMappingErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetEventSourceMappingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetEventSourceMappingErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            GetEventSourceMappingErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetEventSourceMappingErrorKind::ServiceException(_inner) => Some(_inner),
            GetEventSourceMappingErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetEventSourceMappingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetFunctionError {
    pub kind: GetFunctionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFunctionErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetFunctionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetFunctionErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            GetFunctionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetFunctionErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetFunctionErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetFunctionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetFunctionError {
    fn code(&self) -> Option<&str> {
        GetFunctionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetFunctionError {
    pub fn new(kind: GetFunctionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetFunctionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetFunctionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFunctionErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFunctionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, GetFunctionErrorKind::ServiceException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFunctionErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetFunctionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetFunctionErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            GetFunctionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetFunctionErrorKind::ServiceException(_inner) => Some(_inner),
            GetFunctionErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetFunctionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetFunctionCodeSigningConfigError {
    pub kind: GetFunctionCodeSigningConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFunctionCodeSigningConfigErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetFunctionCodeSigningConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetFunctionCodeSigningConfigErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            GetFunctionCodeSigningConfigErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetFunctionCodeSigningConfigErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetFunctionCodeSigningConfigErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            GetFunctionCodeSigningConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetFunctionCodeSigningConfigError {
    fn code(&self) -> Option<&str> {
        GetFunctionCodeSigningConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetFunctionCodeSigningConfigError {
    pub fn new(kind: GetFunctionCodeSigningConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetFunctionCodeSigningConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetFunctionCodeSigningConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFunctionCodeSigningConfigErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFunctionCodeSigningConfigErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFunctionCodeSigningConfigErrorKind::ServiceException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFunctionCodeSigningConfigErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetFunctionCodeSigningConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetFunctionCodeSigningConfigErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            GetFunctionCodeSigningConfigErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            GetFunctionCodeSigningConfigErrorKind::ServiceException(_inner) => Some(_inner),
            GetFunctionCodeSigningConfigErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetFunctionCodeSigningConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetFunctionConcurrencyError {
    pub kind: GetFunctionConcurrencyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFunctionConcurrencyErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetFunctionConcurrencyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetFunctionConcurrencyErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            GetFunctionConcurrencyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetFunctionConcurrencyErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetFunctionConcurrencyErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetFunctionConcurrencyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetFunctionConcurrencyError {
    fn code(&self) -> Option<&str> {
        GetFunctionConcurrencyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetFunctionConcurrencyError {
    pub fn new(kind: GetFunctionConcurrencyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetFunctionConcurrencyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetFunctionConcurrencyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFunctionConcurrencyErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFunctionConcurrencyErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFunctionConcurrencyErrorKind::ServiceException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFunctionConcurrencyErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetFunctionConcurrencyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetFunctionConcurrencyErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            GetFunctionConcurrencyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetFunctionConcurrencyErrorKind::ServiceException(_inner) => Some(_inner),
            GetFunctionConcurrencyErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetFunctionConcurrencyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetFunctionConfigurationError {
    pub kind: GetFunctionConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFunctionConfigurationErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetFunctionConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetFunctionConfigurationErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            GetFunctionConfigurationErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetFunctionConfigurationErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetFunctionConfigurationErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetFunctionConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetFunctionConfigurationError {
    fn code(&self) -> Option<&str> {
        GetFunctionConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetFunctionConfigurationError {
    pub fn new(kind: GetFunctionConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetFunctionConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetFunctionConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFunctionConfigurationErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFunctionConfigurationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFunctionConfigurationErrorKind::ServiceException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFunctionConfigurationErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetFunctionConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetFunctionConfigurationErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            GetFunctionConfigurationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetFunctionConfigurationErrorKind::ServiceException(_inner) => Some(_inner),
            GetFunctionConfigurationErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetFunctionConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetFunctionEventInvokeConfigError {
    pub kind: GetFunctionEventInvokeConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFunctionEventInvokeConfigErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetFunctionEventInvokeConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetFunctionEventInvokeConfigErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            GetFunctionEventInvokeConfigErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetFunctionEventInvokeConfigErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetFunctionEventInvokeConfigErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            GetFunctionEventInvokeConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetFunctionEventInvokeConfigError {
    fn code(&self) -> Option<&str> {
        GetFunctionEventInvokeConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetFunctionEventInvokeConfigError {
    pub fn new(kind: GetFunctionEventInvokeConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetFunctionEventInvokeConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetFunctionEventInvokeConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFunctionEventInvokeConfigErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFunctionEventInvokeConfigErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFunctionEventInvokeConfigErrorKind::ServiceException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFunctionEventInvokeConfigErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetFunctionEventInvokeConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetFunctionEventInvokeConfigErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            GetFunctionEventInvokeConfigErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            GetFunctionEventInvokeConfigErrorKind::ServiceException(_inner) => Some(_inner),
            GetFunctionEventInvokeConfigErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetFunctionEventInvokeConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetLayerVersionError {
    pub kind: GetLayerVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetLayerVersionErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetLayerVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetLayerVersionErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            GetLayerVersionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetLayerVersionErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetLayerVersionErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetLayerVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetLayerVersionError {
    fn code(&self) -> Option<&str> {
        GetLayerVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetLayerVersionError {
    pub fn new(kind: GetLayerVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetLayerVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetLayerVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLayerVersionErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLayerVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, GetLayerVersionErrorKind::ServiceException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLayerVersionErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetLayerVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetLayerVersionErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            GetLayerVersionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetLayerVersionErrorKind::ServiceException(_inner) => Some(_inner),
            GetLayerVersionErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetLayerVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetLayerVersionByArnError {
    pub kind: GetLayerVersionByArnErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetLayerVersionByArnErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetLayerVersionByArnError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetLayerVersionByArnErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            GetLayerVersionByArnErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetLayerVersionByArnErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetLayerVersionByArnErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetLayerVersionByArnErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetLayerVersionByArnError {
    fn code(&self) -> Option<&str> {
        GetLayerVersionByArnError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetLayerVersionByArnError {
    pub fn new(kind: GetLayerVersionByArnErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetLayerVersionByArnErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetLayerVersionByArnErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLayerVersionByArnErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLayerVersionByArnErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLayerVersionByArnErrorKind::ServiceException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLayerVersionByArnErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetLayerVersionByArnError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetLayerVersionByArnErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            GetLayerVersionByArnErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetLayerVersionByArnErrorKind::ServiceException(_inner) => Some(_inner),
            GetLayerVersionByArnErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetLayerVersionByArnErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetLayerVersionPolicyError {
    pub kind: GetLayerVersionPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetLayerVersionPolicyErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetLayerVersionPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetLayerVersionPolicyErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            GetLayerVersionPolicyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetLayerVersionPolicyErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetLayerVersionPolicyErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetLayerVersionPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetLayerVersionPolicyError {
    fn code(&self) -> Option<&str> {
        GetLayerVersionPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetLayerVersionPolicyError {
    pub fn new(kind: GetLayerVersionPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetLayerVersionPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetLayerVersionPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLayerVersionPolicyErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLayerVersionPolicyErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLayerVersionPolicyErrorKind::ServiceException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLayerVersionPolicyErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetLayerVersionPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetLayerVersionPolicyErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            GetLayerVersionPolicyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetLayerVersionPolicyErrorKind::ServiceException(_inner) => Some(_inner),
            GetLayerVersionPolicyErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetLayerVersionPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPolicyError {
    pub kind: GetPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPolicyErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPolicyErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            GetPolicyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetPolicyErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetPolicyErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetPolicyError {
    fn code(&self) -> Option<&str> {
        GetPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPolicyError {
    pub fn new(kind: GetPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPolicyErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetPolicyErrorKind::ResourceNotFoundException(_))
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, GetPolicyErrorKind::ServiceException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, GetPolicyErrorKind::TooManyRequestsException(_))
    }
}
impl std::error::Error for GetPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPolicyErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            GetPolicyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetPolicyErrorKind::ServiceException(_inner) => Some(_inner),
            GetPolicyErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetProvisionedConcurrencyConfigError {
    pub kind: GetProvisionedConcurrencyConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetProvisionedConcurrencyConfigErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ProvisionedConcurrencyConfigNotFoundException(
        crate::error::ProvisionedConcurrencyConfigNotFoundException,
    ),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetProvisionedConcurrencyConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetProvisionedConcurrencyConfigErrorKind::InvalidParameterValueException(_inner) =>
            _inner.fmt(f)
            ,
            GetProvisionedConcurrencyConfigErrorKind::ProvisionedConcurrencyConfigNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetProvisionedConcurrencyConfigErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetProvisionedConcurrencyConfigErrorKind::ServiceException(_inner) =>
            _inner.fmt(f)
            ,
            GetProvisionedConcurrencyConfigErrorKind::TooManyRequestsException(_inner) =>
            _inner.fmt(f)
            ,
            GetProvisionedConcurrencyConfigErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetProvisionedConcurrencyConfigError {
    fn code(&self) -> Option<&str> {
        GetProvisionedConcurrencyConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetProvisionedConcurrencyConfigError {
    pub fn new(kind: GetProvisionedConcurrencyConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetProvisionedConcurrencyConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetProvisionedConcurrencyConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetProvisionedConcurrencyConfigErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_provisioned_concurrency_config_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetProvisionedConcurrencyConfigErrorKind::ProvisionedConcurrencyConfigNotFoundException(
                _
            )
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetProvisionedConcurrencyConfigErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetProvisionedConcurrencyConfigErrorKind::ServiceException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetProvisionedConcurrencyConfigErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetProvisionedConcurrencyConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetProvisionedConcurrencyConfigErrorKind::InvalidParameterValueException(_inner) =>
            Some(_inner)
            ,
            GetProvisionedConcurrencyConfigErrorKind::ProvisionedConcurrencyConfigNotFoundException(_inner) =>
            Some(_inner)
            ,
            GetProvisionedConcurrencyConfigErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            GetProvisionedConcurrencyConfigErrorKind::ServiceException(_inner) =>
            Some(_inner)
            ,
            GetProvisionedConcurrencyConfigErrorKind::TooManyRequestsException(_inner) =>
            Some(_inner)
            ,
            GetProvisionedConcurrencyConfigErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct InvokeError {
    pub kind: InvokeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum InvokeErrorKind {
    Ec2AccessDeniedException(crate::error::Ec2AccessDeniedException),
    Ec2ThrottledException(crate::error::Ec2ThrottledException),
    Ec2UnexpectedException(crate::error::Ec2UnexpectedException),
    EfsioException(crate::error::EfsioException),
    EfsMountConnectivityException(crate::error::EfsMountConnectivityException),
    EfsMountFailureException(crate::error::EfsMountFailureException),
    EfsMountTimeoutException(crate::error::EfsMountTimeoutException),
    EniLimitReachedException(crate::error::EniLimitReachedException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    InvalidRequestContentException(crate::error::InvalidRequestContentException),
    InvalidRuntimeException(crate::error::InvalidRuntimeException),
    InvalidSecurityGroupIdException(crate::error::InvalidSecurityGroupIdException),
    InvalidSubnetIdException(crate::error::InvalidSubnetIdException),
    InvalidZipFileException(crate::error::InvalidZipFileException),
    KmsAccessDeniedException(crate::error::KmsAccessDeniedException),
    KmsDisabledException(crate::error::KmsDisabledException),
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    KmsNotFoundException(crate::error::KmsNotFoundException),
    RequestTooLargeException(crate::error::RequestTooLargeException),
    ResourceConflictException(crate::error::ResourceConflictException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceNotReadyException(crate::error::ResourceNotReadyException),
    ServiceException(crate::error::ServiceException),
    SubnetIpAddressLimitReachedException(crate::error::SubnetIpAddressLimitReachedException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnsupportedMediaTypeException(crate::error::UnsupportedMediaTypeException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for InvokeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            InvokeErrorKind::Ec2AccessDeniedException(_inner) => _inner.fmt(f),
            InvokeErrorKind::Ec2ThrottledException(_inner) => _inner.fmt(f),
            InvokeErrorKind::Ec2UnexpectedException(_inner) => _inner.fmt(f),
            InvokeErrorKind::EfsioException(_inner) => _inner.fmt(f),
            InvokeErrorKind::EfsMountConnectivityException(_inner) => _inner.fmt(f),
            InvokeErrorKind::EfsMountFailureException(_inner) => _inner.fmt(f),
            InvokeErrorKind::EfsMountTimeoutException(_inner) => _inner.fmt(f),
            InvokeErrorKind::EniLimitReachedException(_inner) => _inner.fmt(f),
            InvokeErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            InvokeErrorKind::InvalidRequestContentException(_inner) => _inner.fmt(f),
            InvokeErrorKind::InvalidRuntimeException(_inner) => _inner.fmt(f),
            InvokeErrorKind::InvalidSecurityGroupIdException(_inner) => _inner.fmt(f),
            InvokeErrorKind::InvalidSubnetIdException(_inner) => _inner.fmt(f),
            InvokeErrorKind::InvalidZipFileException(_inner) => _inner.fmt(f),
            InvokeErrorKind::KmsAccessDeniedException(_inner) => _inner.fmt(f),
            InvokeErrorKind::KmsDisabledException(_inner) => _inner.fmt(f),
            InvokeErrorKind::KmsInvalidStateException(_inner) => _inner.fmt(f),
            InvokeErrorKind::KmsNotFoundException(_inner) => _inner.fmt(f),
            InvokeErrorKind::RequestTooLargeException(_inner) => _inner.fmt(f),
            InvokeErrorKind::ResourceConflictException(_inner) => _inner.fmt(f),
            InvokeErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            InvokeErrorKind::ResourceNotReadyException(_inner) => _inner.fmt(f),
            InvokeErrorKind::ServiceException(_inner) => _inner.fmt(f),
            InvokeErrorKind::SubnetIpAddressLimitReachedException(_inner) => _inner.fmt(f),
            InvokeErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            InvokeErrorKind::UnsupportedMediaTypeException(_inner) => _inner.fmt(f),
            InvokeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for InvokeError {
    fn code(&self) -> Option<&str> {
        InvokeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl InvokeError {
    pub fn new(kind: InvokeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: InvokeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: InvokeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_ec2_access_denied_exception(&self) -> bool {
        matches!(&self.kind, InvokeErrorKind::Ec2AccessDeniedException(_))
    }
    pub fn is_ec2_throttled_exception(&self) -> bool {
        matches!(&self.kind, InvokeErrorKind::Ec2ThrottledException(_))
    }
    pub fn is_ec2_unexpected_exception(&self) -> bool {
        matches!(&self.kind, InvokeErrorKind::Ec2UnexpectedException(_))
    }
    pub fn is_efsio_exception(&self) -> bool {
        matches!(&self.kind, InvokeErrorKind::EfsioException(_))
    }
    pub fn is_efs_mount_connectivity_exception(&self) -> bool {
        matches!(
            &self.kind,
            InvokeErrorKind::EfsMountConnectivityException(_)
        )
    }
    pub fn is_efs_mount_failure_exception(&self) -> bool {
        matches!(&self.kind, InvokeErrorKind::EfsMountFailureException(_))
    }
    pub fn is_efs_mount_timeout_exception(&self) -> bool {
        matches!(&self.kind, InvokeErrorKind::EfsMountTimeoutException(_))
    }
    pub fn is_eni_limit_reached_exception(&self) -> bool {
        matches!(&self.kind, InvokeErrorKind::EniLimitReachedException(_))
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            InvokeErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_invalid_request_content_exception(&self) -> bool {
        matches!(
            &self.kind,
            InvokeErrorKind::InvalidRequestContentException(_)
        )
    }
    pub fn is_invalid_runtime_exception(&self) -> bool {
        matches!(&self.kind, InvokeErrorKind::InvalidRuntimeException(_))
    }
    pub fn is_invalid_security_group_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            InvokeErrorKind::InvalidSecurityGroupIdException(_)
        )
    }
    pub fn is_invalid_subnet_id_exception(&self) -> bool {
        matches!(&self.kind, InvokeErrorKind::InvalidSubnetIdException(_))
    }
    pub fn is_invalid_zip_file_exception(&self) -> bool {
        matches!(&self.kind, InvokeErrorKind::InvalidZipFileException(_))
    }
    pub fn is_kms_access_denied_exception(&self) -> bool {
        matches!(&self.kind, InvokeErrorKind::KmsAccessDeniedException(_))
    }
    pub fn is_kms_disabled_exception(&self) -> bool {
        matches!(&self.kind, InvokeErrorKind::KmsDisabledException(_))
    }
    pub fn is_kms_invalid_state_exception(&self) -> bool {
        matches!(&self.kind, InvokeErrorKind::KmsInvalidStateException(_))
    }
    pub fn is_kms_not_found_exception(&self) -> bool {
        matches!(&self.kind, InvokeErrorKind::KmsNotFoundException(_))
    }
    pub fn is_request_too_large_exception(&self) -> bool {
        matches!(&self.kind, InvokeErrorKind::RequestTooLargeException(_))
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(&self.kind, InvokeErrorKind::ResourceConflictException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, InvokeErrorKind::ResourceNotFoundException(_))
    }
    pub fn is_resource_not_ready_exception(&self) -> bool {
        matches!(&self.kind, InvokeErrorKind::ResourceNotReadyException(_))
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, InvokeErrorKind::ServiceException(_))
    }
    pub fn is_subnet_ip_address_limit_reached_exception(&self) -> bool {
        matches!(
            &self.kind,
            InvokeErrorKind::SubnetIpAddressLimitReachedException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, InvokeErrorKind::TooManyRequestsException(_))
    }
    pub fn is_unsupported_media_type_exception(&self) -> bool {
        matches!(
            &self.kind,
            InvokeErrorKind::UnsupportedMediaTypeException(_)
        )
    }
}
impl std::error::Error for InvokeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            InvokeErrorKind::Ec2AccessDeniedException(_inner) => Some(_inner),
            InvokeErrorKind::Ec2ThrottledException(_inner) => Some(_inner),
            InvokeErrorKind::Ec2UnexpectedException(_inner) => Some(_inner),
            InvokeErrorKind::EfsioException(_inner) => Some(_inner),
            InvokeErrorKind::EfsMountConnectivityException(_inner) => Some(_inner),
            InvokeErrorKind::EfsMountFailureException(_inner) => Some(_inner),
            InvokeErrorKind::EfsMountTimeoutException(_inner) => Some(_inner),
            InvokeErrorKind::EniLimitReachedException(_inner) => Some(_inner),
            InvokeErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            InvokeErrorKind::InvalidRequestContentException(_inner) => Some(_inner),
            InvokeErrorKind::InvalidRuntimeException(_inner) => Some(_inner),
            InvokeErrorKind::InvalidSecurityGroupIdException(_inner) => Some(_inner),
            InvokeErrorKind::InvalidSubnetIdException(_inner) => Some(_inner),
            InvokeErrorKind::InvalidZipFileException(_inner) => Some(_inner),
            InvokeErrorKind::KmsAccessDeniedException(_inner) => Some(_inner),
            InvokeErrorKind::KmsDisabledException(_inner) => Some(_inner),
            InvokeErrorKind::KmsInvalidStateException(_inner) => Some(_inner),
            InvokeErrorKind::KmsNotFoundException(_inner) => Some(_inner),
            InvokeErrorKind::RequestTooLargeException(_inner) => Some(_inner),
            InvokeErrorKind::ResourceConflictException(_inner) => Some(_inner),
            InvokeErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            InvokeErrorKind::ResourceNotReadyException(_inner) => Some(_inner),
            InvokeErrorKind::ServiceException(_inner) => Some(_inner),
            InvokeErrorKind::SubnetIpAddressLimitReachedException(_inner) => Some(_inner),
            InvokeErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            InvokeErrorKind::UnsupportedMediaTypeException(_inner) => Some(_inner),
            InvokeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct InvokeAsyncError {
    pub kind: InvokeAsyncErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum InvokeAsyncErrorKind {
    InvalidRequestContentException(crate::error::InvalidRequestContentException),
    InvalidRuntimeException(crate::error::InvalidRuntimeException),
    ResourceConflictException(crate::error::ResourceConflictException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for InvokeAsyncError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            InvokeAsyncErrorKind::InvalidRequestContentException(_inner) => _inner.fmt(f),
            InvokeAsyncErrorKind::InvalidRuntimeException(_inner) => _inner.fmt(f),
            InvokeAsyncErrorKind::ResourceConflictException(_inner) => _inner.fmt(f),
            InvokeAsyncErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            InvokeAsyncErrorKind::ServiceException(_inner) => _inner.fmt(f),
            InvokeAsyncErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for InvokeAsyncError {
    fn code(&self) -> Option<&str> {
        InvokeAsyncError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl InvokeAsyncError {
    pub fn new(kind: InvokeAsyncErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: InvokeAsyncErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: InvokeAsyncErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_request_content_exception(&self) -> bool {
        matches!(
            &self.kind,
            InvokeAsyncErrorKind::InvalidRequestContentException(_)
        )
    }
    pub fn is_invalid_runtime_exception(&self) -> bool {
        matches!(&self.kind, InvokeAsyncErrorKind::InvalidRuntimeException(_))
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            InvokeAsyncErrorKind::ResourceConflictException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            InvokeAsyncErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, InvokeAsyncErrorKind::ServiceException(_))
    }
}
impl std::error::Error for InvokeAsyncError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            InvokeAsyncErrorKind::InvalidRequestContentException(_inner) => Some(_inner),
            InvokeAsyncErrorKind::InvalidRuntimeException(_inner) => Some(_inner),
            InvokeAsyncErrorKind::ResourceConflictException(_inner) => Some(_inner),
            InvokeAsyncErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            InvokeAsyncErrorKind::ServiceException(_inner) => Some(_inner),
            InvokeAsyncErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAliasesError {
    pub kind: ListAliasesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAliasesErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAliasesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAliasesErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListAliasesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListAliasesErrorKind::ServiceException(_inner) => _inner.fmt(f),
            ListAliasesErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListAliasesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAliasesError {
    fn code(&self) -> Option<&str> {
        ListAliasesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAliasesError {
    pub fn new(kind: ListAliasesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAliasesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAliasesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAliasesErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAliasesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, ListAliasesErrorKind::ServiceException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAliasesErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListAliasesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAliasesErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListAliasesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListAliasesErrorKind::ServiceException(_inner) => Some(_inner),
            ListAliasesErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListAliasesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListCodeSigningConfigsError {
    pub kind: ListCodeSigningConfigsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListCodeSigningConfigsErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ServiceException(crate::error::ServiceException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListCodeSigningConfigsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListCodeSigningConfigsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            ListCodeSigningConfigsErrorKind::ServiceException(_inner) => _inner.fmt(f),
            ListCodeSigningConfigsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListCodeSigningConfigsError {
    fn code(&self) -> Option<&str> {
        ListCodeSigningConfigsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListCodeSigningConfigsError {
    pub fn new(kind: ListCodeSigningConfigsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListCodeSigningConfigsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListCodeSigningConfigsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCodeSigningConfigsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCodeSigningConfigsErrorKind::ServiceException(_)
        )
    }
}
impl std::error::Error for ListCodeSigningConfigsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListCodeSigningConfigsErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListCodeSigningConfigsErrorKind::ServiceException(_inner) => Some(_inner),
            ListCodeSigningConfigsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListEventSourceMappingsError {
    pub kind: ListEventSourceMappingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListEventSourceMappingsErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListEventSourceMappingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListEventSourceMappingsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            ListEventSourceMappingsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListEventSourceMappingsErrorKind::ServiceException(_inner) => _inner.fmt(f),
            ListEventSourceMappingsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListEventSourceMappingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListEventSourceMappingsError {
    fn code(&self) -> Option<&str> {
        ListEventSourceMappingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListEventSourceMappingsError {
    pub fn new(kind: ListEventSourceMappingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListEventSourceMappingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListEventSourceMappingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEventSourceMappingsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEventSourceMappingsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEventSourceMappingsErrorKind::ServiceException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEventSourceMappingsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListEventSourceMappingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListEventSourceMappingsErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            ListEventSourceMappingsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListEventSourceMappingsErrorKind::ServiceException(_inner) => Some(_inner),
            ListEventSourceMappingsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListEventSourceMappingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListFunctionEventInvokeConfigsError {
    pub kind: ListFunctionEventInvokeConfigsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListFunctionEventInvokeConfigsErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListFunctionEventInvokeConfigsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListFunctionEventInvokeConfigsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            ListFunctionEventInvokeConfigsErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            ListFunctionEventInvokeConfigsErrorKind::ServiceException(_inner) => _inner.fmt(f),
            ListFunctionEventInvokeConfigsErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            ListFunctionEventInvokeConfigsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListFunctionEventInvokeConfigsError {
    fn code(&self) -> Option<&str> {
        ListFunctionEventInvokeConfigsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListFunctionEventInvokeConfigsError {
    pub fn new(kind: ListFunctionEventInvokeConfigsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListFunctionEventInvokeConfigsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListFunctionEventInvokeConfigsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFunctionEventInvokeConfigsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFunctionEventInvokeConfigsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFunctionEventInvokeConfigsErrorKind::ServiceException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFunctionEventInvokeConfigsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListFunctionEventInvokeConfigsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListFunctionEventInvokeConfigsErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            ListFunctionEventInvokeConfigsErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            ListFunctionEventInvokeConfigsErrorKind::ServiceException(_inner) => Some(_inner),
            ListFunctionEventInvokeConfigsErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            ListFunctionEventInvokeConfigsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListFunctionsError {
    pub kind: ListFunctionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListFunctionsErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListFunctionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListFunctionsErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListFunctionsErrorKind::ServiceException(_inner) => _inner.fmt(f),
            ListFunctionsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListFunctionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListFunctionsError {
    fn code(&self) -> Option<&str> {
        ListFunctionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListFunctionsError {
    pub fn new(kind: ListFunctionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListFunctionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListFunctionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFunctionsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, ListFunctionsErrorKind::ServiceException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFunctionsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListFunctionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListFunctionsErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListFunctionsErrorKind::ServiceException(_inner) => Some(_inner),
            ListFunctionsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListFunctionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListFunctionsByCodeSigningConfigError {
    pub kind: ListFunctionsByCodeSigningConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListFunctionsByCodeSigningConfigErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListFunctionsByCodeSigningConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListFunctionsByCodeSigningConfigErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            ListFunctionsByCodeSigningConfigErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            ListFunctionsByCodeSigningConfigErrorKind::ServiceException(_inner) => _inner.fmt(f),
            ListFunctionsByCodeSigningConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListFunctionsByCodeSigningConfigError {
    fn code(&self) -> Option<&str> {
        ListFunctionsByCodeSigningConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListFunctionsByCodeSigningConfigError {
    pub fn new(kind: ListFunctionsByCodeSigningConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListFunctionsByCodeSigningConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListFunctionsByCodeSigningConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFunctionsByCodeSigningConfigErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFunctionsByCodeSigningConfigErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFunctionsByCodeSigningConfigErrorKind::ServiceException(_)
        )
    }
}
impl std::error::Error for ListFunctionsByCodeSigningConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListFunctionsByCodeSigningConfigErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            ListFunctionsByCodeSigningConfigErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            ListFunctionsByCodeSigningConfigErrorKind::ServiceException(_inner) => Some(_inner),
            ListFunctionsByCodeSigningConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListLayersError {
    pub kind: ListLayersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListLayersErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListLayersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListLayersErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListLayersErrorKind::ServiceException(_inner) => _inner.fmt(f),
            ListLayersErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListLayersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListLayersError {
    fn code(&self) -> Option<&str> {
        ListLayersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListLayersError {
    pub fn new(kind: ListLayersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListLayersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListLayersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLayersErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, ListLayersErrorKind::ServiceException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, ListLayersErrorKind::TooManyRequestsException(_))
    }
}
impl std::error::Error for ListLayersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListLayersErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListLayersErrorKind::ServiceException(_inner) => Some(_inner),
            ListLayersErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListLayersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListLayerVersionsError {
    pub kind: ListLayerVersionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListLayerVersionsErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListLayerVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListLayerVersionsErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListLayerVersionsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListLayerVersionsErrorKind::ServiceException(_inner) => _inner.fmt(f),
            ListLayerVersionsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListLayerVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListLayerVersionsError {
    fn code(&self) -> Option<&str> {
        ListLayerVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListLayerVersionsError {
    pub fn new(kind: ListLayerVersionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListLayerVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListLayerVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLayerVersionsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLayerVersionsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, ListLayerVersionsErrorKind::ServiceException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLayerVersionsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListLayerVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListLayerVersionsErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListLayerVersionsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListLayerVersionsErrorKind::ServiceException(_inner) => Some(_inner),
            ListLayerVersionsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListLayerVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListProvisionedConcurrencyConfigsError {
    pub kind: ListProvisionedConcurrencyConfigsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListProvisionedConcurrencyConfigsErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListProvisionedConcurrencyConfigsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListProvisionedConcurrencyConfigsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            ListProvisionedConcurrencyConfigsErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            ListProvisionedConcurrencyConfigsErrorKind::ServiceException(_inner) => _inner.fmt(f),
            ListProvisionedConcurrencyConfigsErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            ListProvisionedConcurrencyConfigsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListProvisionedConcurrencyConfigsError {
    fn code(&self) -> Option<&str> {
        ListProvisionedConcurrencyConfigsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListProvisionedConcurrencyConfigsError {
    pub fn new(
        kind: ListProvisionedConcurrencyConfigsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListProvisionedConcurrencyConfigsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListProvisionedConcurrencyConfigsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProvisionedConcurrencyConfigsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProvisionedConcurrencyConfigsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProvisionedConcurrencyConfigsErrorKind::ServiceException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProvisionedConcurrencyConfigsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListProvisionedConcurrencyConfigsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListProvisionedConcurrencyConfigsErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            ListProvisionedConcurrencyConfigsErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            ListProvisionedConcurrencyConfigsErrorKind::ServiceException(_inner) => Some(_inner),
            ListProvisionedConcurrencyConfigsErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            ListProvisionedConcurrencyConfigsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsError {
    pub kind: ListTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListTagsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListTagsErrorKind::ServiceException(_inner) => _inner.fmt(f),
            ListTagsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsError {
    fn code(&self) -> Option<&str> {
        ListTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsError {
    pub fn new(kind: ListTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListTagsErrorKind::ResourceNotFoundException(_))
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, ListTagsErrorKind::ServiceException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, ListTagsErrorKind::TooManyRequestsException(_))
    }
}
impl std::error::Error for ListTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListTagsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListTagsErrorKind::ServiceException(_inner) => Some(_inner),
            ListTagsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListVersionsByFunctionError {
    pub kind: ListVersionsByFunctionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListVersionsByFunctionErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListVersionsByFunctionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListVersionsByFunctionErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            ListVersionsByFunctionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListVersionsByFunctionErrorKind::ServiceException(_inner) => _inner.fmt(f),
            ListVersionsByFunctionErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListVersionsByFunctionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListVersionsByFunctionError {
    fn code(&self) -> Option<&str> {
        ListVersionsByFunctionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListVersionsByFunctionError {
    pub fn new(kind: ListVersionsByFunctionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListVersionsByFunctionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListVersionsByFunctionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVersionsByFunctionErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVersionsByFunctionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVersionsByFunctionErrorKind::ServiceException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVersionsByFunctionErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListVersionsByFunctionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListVersionsByFunctionErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListVersionsByFunctionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListVersionsByFunctionErrorKind::ServiceException(_inner) => Some(_inner),
            ListVersionsByFunctionErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListVersionsByFunctionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PublishLayerVersionError {
    pub kind: PublishLayerVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PublishLayerVersionErrorKind {
    CodeStorageExceededException(crate::error::CodeStorageExceededException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PublishLayerVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PublishLayerVersionErrorKind::CodeStorageExceededException(_inner) => _inner.fmt(f),
            PublishLayerVersionErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            PublishLayerVersionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            PublishLayerVersionErrorKind::ServiceException(_inner) => _inner.fmt(f),
            PublishLayerVersionErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            PublishLayerVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PublishLayerVersionError {
    fn code(&self) -> Option<&str> {
        PublishLayerVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PublishLayerVersionError {
    pub fn new(kind: PublishLayerVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PublishLayerVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PublishLayerVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_code_storage_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PublishLayerVersionErrorKind::CodeStorageExceededException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            PublishLayerVersionErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PublishLayerVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            PublishLayerVersionErrorKind::ServiceException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            PublishLayerVersionErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for PublishLayerVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PublishLayerVersionErrorKind::CodeStorageExceededException(_inner) => Some(_inner),
            PublishLayerVersionErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            PublishLayerVersionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            PublishLayerVersionErrorKind::ServiceException(_inner) => Some(_inner),
            PublishLayerVersionErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            PublishLayerVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PublishVersionError {
    pub kind: PublishVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PublishVersionErrorKind {
    CodeStorageExceededException(crate::error::CodeStorageExceededException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    ResourceConflictException(crate::error::ResourceConflictException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PublishVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PublishVersionErrorKind::CodeStorageExceededException(_inner) => _inner.fmt(f),
            PublishVersionErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            PublishVersionErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            PublishVersionErrorKind::ResourceConflictException(_inner) => _inner.fmt(f),
            PublishVersionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            PublishVersionErrorKind::ServiceException(_inner) => _inner.fmt(f),
            PublishVersionErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            PublishVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PublishVersionError {
    fn code(&self) -> Option<&str> {
        PublishVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PublishVersionError {
    pub fn new(kind: PublishVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PublishVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PublishVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_code_storage_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PublishVersionErrorKind::CodeStorageExceededException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            PublishVersionErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            PublishVersionErrorKind::PreconditionFailedException(_)
        )
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            PublishVersionErrorKind::ResourceConflictException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PublishVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, PublishVersionErrorKind::ServiceException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            PublishVersionErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for PublishVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PublishVersionErrorKind::CodeStorageExceededException(_inner) => Some(_inner),
            PublishVersionErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            PublishVersionErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            PublishVersionErrorKind::ResourceConflictException(_inner) => Some(_inner),
            PublishVersionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            PublishVersionErrorKind::ServiceException(_inner) => Some(_inner),
            PublishVersionErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            PublishVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutFunctionCodeSigningConfigError {
    pub kind: PutFunctionCodeSigningConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutFunctionCodeSigningConfigErrorKind {
    CodeSigningConfigNotFoundException(crate::error::CodeSigningConfigNotFoundException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceConflictException(crate::error::ResourceConflictException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutFunctionCodeSigningConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutFunctionCodeSigningConfigErrorKind::CodeSigningConfigNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            PutFunctionCodeSigningConfigErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            PutFunctionCodeSigningConfigErrorKind::ResourceConflictException(_inner) => {
                _inner.fmt(f)
            }
            PutFunctionCodeSigningConfigErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            PutFunctionCodeSigningConfigErrorKind::ServiceException(_inner) => _inner.fmt(f),
            PutFunctionCodeSigningConfigErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            PutFunctionCodeSigningConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutFunctionCodeSigningConfigError {
    fn code(&self) -> Option<&str> {
        PutFunctionCodeSigningConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutFunctionCodeSigningConfigError {
    pub fn new(kind: PutFunctionCodeSigningConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutFunctionCodeSigningConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutFunctionCodeSigningConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_code_signing_config_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFunctionCodeSigningConfigErrorKind::CodeSigningConfigNotFoundException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFunctionCodeSigningConfigErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFunctionCodeSigningConfigErrorKind::ResourceConflictException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFunctionCodeSigningConfigErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFunctionCodeSigningConfigErrorKind::ServiceException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFunctionCodeSigningConfigErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for PutFunctionCodeSigningConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutFunctionCodeSigningConfigErrorKind::CodeSigningConfigNotFoundException(_inner) => {
                Some(_inner)
            }
            PutFunctionCodeSigningConfigErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            PutFunctionCodeSigningConfigErrorKind::ResourceConflictException(_inner) => {
                Some(_inner)
            }
            PutFunctionCodeSigningConfigErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            PutFunctionCodeSigningConfigErrorKind::ServiceException(_inner) => Some(_inner),
            PutFunctionCodeSigningConfigErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            PutFunctionCodeSigningConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutFunctionConcurrencyError {
    pub kind: PutFunctionConcurrencyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutFunctionConcurrencyErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceConflictException(crate::error::ResourceConflictException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutFunctionConcurrencyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutFunctionConcurrencyErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            PutFunctionConcurrencyErrorKind::ResourceConflictException(_inner) => _inner.fmt(f),
            PutFunctionConcurrencyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            PutFunctionConcurrencyErrorKind::ServiceException(_inner) => _inner.fmt(f),
            PutFunctionConcurrencyErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            PutFunctionConcurrencyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutFunctionConcurrencyError {
    fn code(&self) -> Option<&str> {
        PutFunctionConcurrencyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutFunctionConcurrencyError {
    pub fn new(kind: PutFunctionConcurrencyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutFunctionConcurrencyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutFunctionConcurrencyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFunctionConcurrencyErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFunctionConcurrencyErrorKind::ResourceConflictException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFunctionConcurrencyErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFunctionConcurrencyErrorKind::ServiceException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFunctionConcurrencyErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for PutFunctionConcurrencyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutFunctionConcurrencyErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            PutFunctionConcurrencyErrorKind::ResourceConflictException(_inner) => Some(_inner),
            PutFunctionConcurrencyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            PutFunctionConcurrencyErrorKind::ServiceException(_inner) => Some(_inner),
            PutFunctionConcurrencyErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            PutFunctionConcurrencyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutFunctionEventInvokeConfigError {
    pub kind: PutFunctionEventInvokeConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutFunctionEventInvokeConfigErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceConflictException(crate::error::ResourceConflictException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutFunctionEventInvokeConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutFunctionEventInvokeConfigErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            PutFunctionEventInvokeConfigErrorKind::ResourceConflictException(_inner) => {
                _inner.fmt(f)
            }
            PutFunctionEventInvokeConfigErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            PutFunctionEventInvokeConfigErrorKind::ServiceException(_inner) => _inner.fmt(f),
            PutFunctionEventInvokeConfigErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            PutFunctionEventInvokeConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutFunctionEventInvokeConfigError {
    fn code(&self) -> Option<&str> {
        PutFunctionEventInvokeConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutFunctionEventInvokeConfigError {
    pub fn new(kind: PutFunctionEventInvokeConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutFunctionEventInvokeConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutFunctionEventInvokeConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFunctionEventInvokeConfigErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFunctionEventInvokeConfigErrorKind::ResourceConflictException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFunctionEventInvokeConfigErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFunctionEventInvokeConfigErrorKind::ServiceException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFunctionEventInvokeConfigErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for PutFunctionEventInvokeConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutFunctionEventInvokeConfigErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            PutFunctionEventInvokeConfigErrorKind::ResourceConflictException(_inner) => {
                Some(_inner)
            }
            PutFunctionEventInvokeConfigErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            PutFunctionEventInvokeConfigErrorKind::ServiceException(_inner) => Some(_inner),
            PutFunctionEventInvokeConfigErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            PutFunctionEventInvokeConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutProvisionedConcurrencyConfigError {
    pub kind: PutProvisionedConcurrencyConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutProvisionedConcurrencyConfigErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceConflictException(crate::error::ResourceConflictException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutProvisionedConcurrencyConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutProvisionedConcurrencyConfigErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            PutProvisionedConcurrencyConfigErrorKind::ResourceConflictException(_inner) => {
                _inner.fmt(f)
            }
            PutProvisionedConcurrencyConfigErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            PutProvisionedConcurrencyConfigErrorKind::ServiceException(_inner) => _inner.fmt(f),
            PutProvisionedConcurrencyConfigErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            PutProvisionedConcurrencyConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutProvisionedConcurrencyConfigError {
    fn code(&self) -> Option<&str> {
        PutProvisionedConcurrencyConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutProvisionedConcurrencyConfigError {
    pub fn new(kind: PutProvisionedConcurrencyConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutProvisionedConcurrencyConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutProvisionedConcurrencyConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutProvisionedConcurrencyConfigErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutProvisionedConcurrencyConfigErrorKind::ResourceConflictException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutProvisionedConcurrencyConfigErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutProvisionedConcurrencyConfigErrorKind::ServiceException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutProvisionedConcurrencyConfigErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for PutProvisionedConcurrencyConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutProvisionedConcurrencyConfigErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            PutProvisionedConcurrencyConfigErrorKind::ResourceConflictException(_inner) => {
                Some(_inner)
            }
            PutProvisionedConcurrencyConfigErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            PutProvisionedConcurrencyConfigErrorKind::ServiceException(_inner) => Some(_inner),
            PutProvisionedConcurrencyConfigErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            PutProvisionedConcurrencyConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveLayerVersionPermissionError {
    pub kind: RemoveLayerVersionPermissionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveLayerVersionPermissionErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveLayerVersionPermissionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemoveLayerVersionPermissionErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            RemoveLayerVersionPermissionErrorKind::PreconditionFailedException(_inner) => {
                _inner.fmt(f)
            }
            RemoveLayerVersionPermissionErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            RemoveLayerVersionPermissionErrorKind::ServiceException(_inner) => _inner.fmt(f),
            RemoveLayerVersionPermissionErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            RemoveLayerVersionPermissionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RemoveLayerVersionPermissionError {
    fn code(&self) -> Option<&str> {
        RemoveLayerVersionPermissionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveLayerVersionPermissionError {
    pub fn new(kind: RemoveLayerVersionPermissionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemoveLayerVersionPermissionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemoveLayerVersionPermissionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveLayerVersionPermissionErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveLayerVersionPermissionErrorKind::PreconditionFailedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveLayerVersionPermissionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveLayerVersionPermissionErrorKind::ServiceException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveLayerVersionPermissionErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for RemoveLayerVersionPermissionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemoveLayerVersionPermissionErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            RemoveLayerVersionPermissionErrorKind::PreconditionFailedException(_inner) => {
                Some(_inner)
            }
            RemoveLayerVersionPermissionErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            RemoveLayerVersionPermissionErrorKind::ServiceException(_inner) => Some(_inner),
            RemoveLayerVersionPermissionErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            RemoveLayerVersionPermissionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemovePermissionError {
    pub kind: RemovePermissionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemovePermissionErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemovePermissionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemovePermissionErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            RemovePermissionErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            RemovePermissionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            RemovePermissionErrorKind::ServiceException(_inner) => _inner.fmt(f),
            RemovePermissionErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            RemovePermissionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RemovePermissionError {
    fn code(&self) -> Option<&str> {
        RemovePermissionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemovePermissionError {
    pub fn new(kind: RemovePermissionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemovePermissionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemovePermissionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemovePermissionErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemovePermissionErrorKind::PreconditionFailedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemovePermissionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, RemovePermissionErrorKind::ServiceException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemovePermissionErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for RemovePermissionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemovePermissionErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            RemovePermissionErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            RemovePermissionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            RemovePermissionErrorKind::ServiceException(_inner) => Some(_inner),
            RemovePermissionErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            RemovePermissionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceConflictException(crate::error::ResourceConflictException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ResourceConflictException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ServiceException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ResourceConflictException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ServiceException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            TagResourceErrorKind::ResourceConflictException(_inner) => Some(_inner),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            TagResourceErrorKind::ServiceException(_inner) => Some(_inner),
            TagResourceErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceConflictException(crate::error::ResourceConflictException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ResourceConflictException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ServiceException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ResourceConflictException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ServiceException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            UntagResourceErrorKind::ResourceConflictException(_inner) => Some(_inner),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UntagResourceErrorKind::ServiceException(_inner) => Some(_inner),
            UntagResourceErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAliasError {
    pub kind: UpdateAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAliasErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    ResourceConflictException(crate::error::ResourceConflictException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAliasErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            UpdateAliasErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            UpdateAliasErrorKind::ResourceConflictException(_inner) => _inner.fmt(f),
            UpdateAliasErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateAliasErrorKind::ServiceException(_inner) => _inner.fmt(f),
            UpdateAliasErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAliasError {
    fn code(&self) -> Option<&str> {
        UpdateAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAliasError {
    pub fn new(kind: UpdateAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAliasErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAliasErrorKind::PreconditionFailedException(_)
        )
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAliasErrorKind::ResourceConflictException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAliasErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, UpdateAliasErrorKind::ServiceException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAliasErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAliasErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            UpdateAliasErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            UpdateAliasErrorKind::ResourceConflictException(_inner) => Some(_inner),
            UpdateAliasErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateAliasErrorKind::ServiceException(_inner) => Some(_inner),
            UpdateAliasErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateCodeSigningConfigError {
    pub kind: UpdateCodeSigningConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateCodeSigningConfigErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateCodeSigningConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateCodeSigningConfigErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            UpdateCodeSigningConfigErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateCodeSigningConfigErrorKind::ServiceException(_inner) => _inner.fmt(f),
            UpdateCodeSigningConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateCodeSigningConfigError {
    fn code(&self) -> Option<&str> {
        UpdateCodeSigningConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateCodeSigningConfigError {
    pub fn new(kind: UpdateCodeSigningConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateCodeSigningConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateCodeSigningConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCodeSigningConfigErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCodeSigningConfigErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCodeSigningConfigErrorKind::ServiceException(_)
        )
    }
}
impl std::error::Error for UpdateCodeSigningConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateCodeSigningConfigErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            UpdateCodeSigningConfigErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateCodeSigningConfigErrorKind::ServiceException(_inner) => Some(_inner),
            UpdateCodeSigningConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateEventSourceMappingError {
    pub kind: UpdateEventSourceMappingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateEventSourceMappingErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceConflictException(crate::error::ResourceConflictException),
    ResourceInUseException(crate::error::ResourceInUseException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateEventSourceMappingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateEventSourceMappingErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            UpdateEventSourceMappingErrorKind::ResourceConflictException(_inner) => _inner.fmt(f),
            UpdateEventSourceMappingErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            UpdateEventSourceMappingErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateEventSourceMappingErrorKind::ServiceException(_inner) => _inner.fmt(f),
            UpdateEventSourceMappingErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateEventSourceMappingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateEventSourceMappingError {
    fn code(&self) -> Option<&str> {
        UpdateEventSourceMappingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateEventSourceMappingError {
    pub fn new(kind: UpdateEventSourceMappingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateEventSourceMappingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateEventSourceMappingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEventSourceMappingErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEventSourceMappingErrorKind::ResourceConflictException(_)
        )
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEventSourceMappingErrorKind::ResourceInUseException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEventSourceMappingErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEventSourceMappingErrorKind::ServiceException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEventSourceMappingErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateEventSourceMappingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateEventSourceMappingErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            UpdateEventSourceMappingErrorKind::ResourceConflictException(_inner) => Some(_inner),
            UpdateEventSourceMappingErrorKind::ResourceInUseException(_inner) => Some(_inner),
            UpdateEventSourceMappingErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateEventSourceMappingErrorKind::ServiceException(_inner) => Some(_inner),
            UpdateEventSourceMappingErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateEventSourceMappingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateFunctionCodeError {
    pub kind: UpdateFunctionCodeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateFunctionCodeErrorKind {
    CodeSigningConfigNotFoundException(crate::error::CodeSigningConfigNotFoundException),
    CodeStorageExceededException(crate::error::CodeStorageExceededException),
    CodeVerificationFailedException(crate::error::CodeVerificationFailedException),
    InvalidCodeSignatureException(crate::error::InvalidCodeSignatureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    ResourceConflictException(crate::error::ResourceConflictException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateFunctionCodeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateFunctionCodeErrorKind::CodeSigningConfigNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateFunctionCodeErrorKind::CodeStorageExceededException(_inner) => _inner.fmt(f),
            UpdateFunctionCodeErrorKind::CodeVerificationFailedException(_inner) => _inner.fmt(f),
            UpdateFunctionCodeErrorKind::InvalidCodeSignatureException(_inner) => _inner.fmt(f),
            UpdateFunctionCodeErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            UpdateFunctionCodeErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            UpdateFunctionCodeErrorKind::ResourceConflictException(_inner) => _inner.fmt(f),
            UpdateFunctionCodeErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateFunctionCodeErrorKind::ServiceException(_inner) => _inner.fmt(f),
            UpdateFunctionCodeErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateFunctionCodeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateFunctionCodeError {
    fn code(&self) -> Option<&str> {
        UpdateFunctionCodeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateFunctionCodeError {
    pub fn new(kind: UpdateFunctionCodeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateFunctionCodeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateFunctionCodeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_code_signing_config_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFunctionCodeErrorKind::CodeSigningConfigNotFoundException(_)
        )
    }
    pub fn is_code_storage_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFunctionCodeErrorKind::CodeStorageExceededException(_)
        )
    }
    pub fn is_code_verification_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFunctionCodeErrorKind::CodeVerificationFailedException(_)
        )
    }
    pub fn is_invalid_code_signature_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFunctionCodeErrorKind::InvalidCodeSignatureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFunctionCodeErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFunctionCodeErrorKind::PreconditionFailedException(_)
        )
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFunctionCodeErrorKind::ResourceConflictException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFunctionCodeErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, UpdateFunctionCodeErrorKind::ServiceException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFunctionCodeErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateFunctionCodeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateFunctionCodeErrorKind::CodeSigningConfigNotFoundException(_inner) => Some(_inner),
            UpdateFunctionCodeErrorKind::CodeStorageExceededException(_inner) => Some(_inner),
            UpdateFunctionCodeErrorKind::CodeVerificationFailedException(_inner) => Some(_inner),
            UpdateFunctionCodeErrorKind::InvalidCodeSignatureException(_inner) => Some(_inner),
            UpdateFunctionCodeErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            UpdateFunctionCodeErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            UpdateFunctionCodeErrorKind::ResourceConflictException(_inner) => Some(_inner),
            UpdateFunctionCodeErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateFunctionCodeErrorKind::ServiceException(_inner) => Some(_inner),
            UpdateFunctionCodeErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateFunctionCodeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateFunctionConfigurationError {
    pub kind: UpdateFunctionConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateFunctionConfigurationErrorKind {
    CodeSigningConfigNotFoundException(crate::error::CodeSigningConfigNotFoundException),
    CodeVerificationFailedException(crate::error::CodeVerificationFailedException),
    InvalidCodeSignatureException(crate::error::InvalidCodeSignatureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    ResourceConflictException(crate::error::ResourceConflictException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateFunctionConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateFunctionConfigurationErrorKind::CodeSigningConfigNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateFunctionConfigurationErrorKind::CodeVerificationFailedException(_inner) => {
                _inner.fmt(f)
            }
            UpdateFunctionConfigurationErrorKind::InvalidCodeSignatureException(_inner) => {
                _inner.fmt(f)
            }
            UpdateFunctionConfigurationErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            UpdateFunctionConfigurationErrorKind::PreconditionFailedException(_inner) => {
                _inner.fmt(f)
            }
            UpdateFunctionConfigurationErrorKind::ResourceConflictException(_inner) => {
                _inner.fmt(f)
            }
            UpdateFunctionConfigurationErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateFunctionConfigurationErrorKind::ServiceException(_inner) => _inner.fmt(f),
            UpdateFunctionConfigurationErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateFunctionConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateFunctionConfigurationError {
    fn code(&self) -> Option<&str> {
        UpdateFunctionConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateFunctionConfigurationError {
    pub fn new(kind: UpdateFunctionConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateFunctionConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateFunctionConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_code_signing_config_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFunctionConfigurationErrorKind::CodeSigningConfigNotFoundException(_)
        )
    }
    pub fn is_code_verification_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFunctionConfigurationErrorKind::CodeVerificationFailedException(_)
        )
    }
    pub fn is_invalid_code_signature_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFunctionConfigurationErrorKind::InvalidCodeSignatureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFunctionConfigurationErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFunctionConfigurationErrorKind::PreconditionFailedException(_)
        )
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFunctionConfigurationErrorKind::ResourceConflictException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFunctionConfigurationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFunctionConfigurationErrorKind::ServiceException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFunctionConfigurationErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateFunctionConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateFunctionConfigurationErrorKind::CodeSigningConfigNotFoundException(_inner) => {
                Some(_inner)
            }
            UpdateFunctionConfigurationErrorKind::CodeVerificationFailedException(_inner) => {
                Some(_inner)
            }
            UpdateFunctionConfigurationErrorKind::InvalidCodeSignatureException(_inner) => {
                Some(_inner)
            }
            UpdateFunctionConfigurationErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            UpdateFunctionConfigurationErrorKind::PreconditionFailedException(_inner) => {
                Some(_inner)
            }
            UpdateFunctionConfigurationErrorKind::ResourceConflictException(_inner) => Some(_inner),
            UpdateFunctionConfigurationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateFunctionConfigurationErrorKind::ServiceException(_inner) => Some(_inner),
            UpdateFunctionConfigurationErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateFunctionConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateFunctionEventInvokeConfigError {
    pub kind: UpdateFunctionEventInvokeConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateFunctionEventInvokeConfigErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceConflictException(crate::error::ResourceConflictException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceException(crate::error::ServiceException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateFunctionEventInvokeConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateFunctionEventInvokeConfigErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            UpdateFunctionEventInvokeConfigErrorKind::ResourceConflictException(_inner) => {
                _inner.fmt(f)
            }
            UpdateFunctionEventInvokeConfigErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateFunctionEventInvokeConfigErrorKind::ServiceException(_inner) => _inner.fmt(f),
            UpdateFunctionEventInvokeConfigErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            UpdateFunctionEventInvokeConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateFunctionEventInvokeConfigError {
    fn code(&self) -> Option<&str> {
        UpdateFunctionEventInvokeConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateFunctionEventInvokeConfigError {
    pub fn new(kind: UpdateFunctionEventInvokeConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateFunctionEventInvokeConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateFunctionEventInvokeConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFunctionEventInvokeConfigErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFunctionEventInvokeConfigErrorKind::ResourceConflictException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFunctionEventInvokeConfigErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFunctionEventInvokeConfigErrorKind::ServiceException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFunctionEventInvokeConfigErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateFunctionEventInvokeConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateFunctionEventInvokeConfigErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            UpdateFunctionEventInvokeConfigErrorKind::ResourceConflictException(_inner) => {
                Some(_inner)
            }
            UpdateFunctionEventInvokeConfigErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            UpdateFunctionEventInvokeConfigErrorKind::ServiceException(_inner) => Some(_inner),
            UpdateFunctionEventInvokeConfigErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            UpdateFunctionEventInvokeConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The request throughput limit was exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TooManyRequestsException {
    /// <p>The number of seconds the caller should wait before retrying.</p>
    pub retry_after_seconds: std::option::Option<std::string::String>,
    pub r#type: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
    pub reason: std::option::Option<crate::model::ThrottleReason>,
}
impl std::fmt::Debug for TooManyRequestsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TooManyRequestsException");
        formatter.field("retry_after_seconds", &self.retry_after_seconds);
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.field("reason", &self.reason);
        formatter.finish()
    }
}
impl TooManyRequestsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyRequestsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyRequestsException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for TooManyRequestsException {}
/// See [`TooManyRequestsException`](crate::error::TooManyRequestsException)
pub mod too_many_requests_exception {
    /// A builder for [`TooManyRequestsException`](crate::error::TooManyRequestsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) retry_after_seconds: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) reason: std::option::Option<crate::model::ThrottleReason>,
    }
    impl Builder {
        /// <p>The number of seconds the caller should wait before retrying.</p>
        pub fn retry_after_seconds(mut self, input: impl Into<std::string::String>) -> Self {
            self.retry_after_seconds = Some(input.into());
            self
        }
        pub fn set_retry_after_seconds(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.retry_after_seconds = input;
            self
        }
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn reason(mut self, input: crate::model::ThrottleReason) -> Self {
            self.reason = Some(input);
            self
        }
        pub fn set_reason(
            mut self,
            input: std::option::Option<crate::model::ThrottleReason>,
        ) -> Self {
            self.reason = input;
            self
        }
        /// Consumes the builder and constructs a [`TooManyRequestsException`](crate::error::TooManyRequestsException)
        pub fn build(self) -> crate::error::TooManyRequestsException {
            crate::error::TooManyRequestsException {
                retry_after_seconds: self.retry_after_seconds,
                r#type: self.r#type,
                message: self.message,
                reason: self.reason,
            }
        }
    }
}
impl TooManyRequestsException {
    /// Creates a new builder-style object to manufacture [`TooManyRequestsException`](crate::error::TooManyRequestsException)
    pub fn builder() -> crate::error::too_many_requests_exception::Builder {
        crate::error::too_many_requests_exception::Builder::default()
    }
}

/// <p>The Lambda service encountered an internal error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceException {
    pub r#type: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceException");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceException {}
/// See [`ServiceException`](crate::error::ServiceException)
pub mod service_exception {
    /// A builder for [`ServiceException`](crate::error::ServiceException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceException`](crate::error::ServiceException)
        pub fn build(self) -> crate::error::ServiceException {
            crate::error::ServiceException {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl ServiceException {
    /// Creates a new builder-style object to manufacture [`ServiceException`](crate::error::ServiceException)
    pub fn builder() -> crate::error::service_exception::Builder {
        crate::error::service_exception::Builder::default()
    }
}

/// <p>The resource specified in the request does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundException {
    pub r#type: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundException");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundException {}
/// See [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
pub mod resource_not_found_exception {
    /// A builder for [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
        pub fn build(self) -> crate::error::ResourceNotFoundException {
            crate::error::ResourceNotFoundException {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl ResourceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    pub fn builder() -> crate::error::resource_not_found_exception::Builder {
        crate::error::resource_not_found_exception::Builder::default()
    }
}

/// <p>The resource already exists, or another operation is in progress.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceConflictException {
    /// <p>The exception type.</p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The exception message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceConflictException");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceConflictException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceConflictException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceConflictException {}
/// See [`ResourceConflictException`](crate::error::ResourceConflictException)
pub mod resource_conflict_exception {
    /// A builder for [`ResourceConflictException`](crate::error::ResourceConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The exception type.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The exception message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceConflictException`](crate::error::ResourceConflictException)
        pub fn build(self) -> crate::error::ResourceConflictException {
            crate::error::ResourceConflictException {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl ResourceConflictException {
    /// Creates a new builder-style object to manufacture [`ResourceConflictException`](crate::error::ResourceConflictException)
    pub fn builder() -> crate::error::resource_conflict_exception::Builder {
        crate::error::resource_conflict_exception::Builder::default()
    }
}

/// <p>One of the parameters in the request is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidParameterValueException {
    /// <p>The exception type.</p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The exception message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidParameterValueException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidParameterValueException");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidParameterValueException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidParameterValueException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidParameterValueException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidParameterValueException {}
/// See [`InvalidParameterValueException`](crate::error::InvalidParameterValueException)
pub mod invalid_parameter_value_exception {
    /// A builder for [`InvalidParameterValueException`](crate::error::InvalidParameterValueException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The exception type.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The exception message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidParameterValueException`](crate::error::InvalidParameterValueException)
        pub fn build(self) -> crate::error::InvalidParameterValueException {
            crate::error::InvalidParameterValueException {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl InvalidParameterValueException {
    /// Creates a new builder-style object to manufacture [`InvalidParameterValueException`](crate::error::InvalidParameterValueException)
    pub fn builder() -> crate::error::invalid_parameter_value_exception::Builder {
        crate::error::invalid_parameter_value_exception::Builder::default()
    }
}

/// <p>The RevisionId provided does not match the latest RevisionId for the Lambda function or alias. Call the
/// <code>GetFunction</code> or the <code>GetAlias</code> API to retrieve the latest RevisionId for your
/// resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PreconditionFailedException {
    /// <p>The exception type.</p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The exception message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PreconditionFailedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PreconditionFailedException");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PreconditionFailedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PreconditionFailedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PreconditionFailedException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for PreconditionFailedException {}
/// See [`PreconditionFailedException`](crate::error::PreconditionFailedException)
pub mod precondition_failed_exception {
    /// A builder for [`PreconditionFailedException`](crate::error::PreconditionFailedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The exception type.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The exception message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PreconditionFailedException`](crate::error::PreconditionFailedException)
        pub fn build(self) -> crate::error::PreconditionFailedException {
            crate::error::PreconditionFailedException {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl PreconditionFailedException {
    /// Creates a new builder-style object to manufacture [`PreconditionFailedException`](crate::error::PreconditionFailedException)
    pub fn builder() -> crate::error::precondition_failed_exception::Builder {
        crate::error::precondition_failed_exception::Builder::default()
    }
}

/// <p>The code signature failed the integrity check. Lambda always blocks deployment if the integrity check
/// fails, even if code signing policy is set to WARN.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidCodeSignatureException {
    pub r#type: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidCodeSignatureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidCodeSignatureException");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidCodeSignatureException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidCodeSignatureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidCodeSignatureException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidCodeSignatureException {}
/// See [`InvalidCodeSignatureException`](crate::error::InvalidCodeSignatureException)
pub mod invalid_code_signature_exception {
    /// A builder for [`InvalidCodeSignatureException`](crate::error::InvalidCodeSignatureException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidCodeSignatureException`](crate::error::InvalidCodeSignatureException)
        pub fn build(self) -> crate::error::InvalidCodeSignatureException {
            crate::error::InvalidCodeSignatureException {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl InvalidCodeSignatureException {
    /// Creates a new builder-style object to manufacture [`InvalidCodeSignatureException`](crate::error::InvalidCodeSignatureException)
    pub fn builder() -> crate::error::invalid_code_signature_exception::Builder {
        crate::error::invalid_code_signature_exception::Builder::default()
    }
}

/// <p>The code signature failed one or more of the validation checks for signature mismatch or expiry, and the code signing policy
/// is set to ENFORCE. Lambda blocks the deployment. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CodeVerificationFailedException {
    pub r#type: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CodeVerificationFailedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CodeVerificationFailedException");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CodeVerificationFailedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CodeVerificationFailedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CodeVerificationFailedException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for CodeVerificationFailedException {}
/// See [`CodeVerificationFailedException`](crate::error::CodeVerificationFailedException)
pub mod code_verification_failed_exception {
    /// A builder for [`CodeVerificationFailedException`](crate::error::CodeVerificationFailedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CodeVerificationFailedException`](crate::error::CodeVerificationFailedException)
        pub fn build(self) -> crate::error::CodeVerificationFailedException {
            crate::error::CodeVerificationFailedException {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl CodeVerificationFailedException {
    /// Creates a new builder-style object to manufacture [`CodeVerificationFailedException`](crate::error::CodeVerificationFailedException)
    pub fn builder() -> crate::error::code_verification_failed_exception::Builder {
        crate::error::code_verification_failed_exception::Builder::default()
    }
}

/// <p>The specified code signing configuration does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CodeSigningConfigNotFoundException {
    pub r#type: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CodeSigningConfigNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CodeSigningConfigNotFoundException");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CodeSigningConfigNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CodeSigningConfigNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CodeSigningConfigNotFoundException")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for CodeSigningConfigNotFoundException {}
/// See [`CodeSigningConfigNotFoundException`](crate::error::CodeSigningConfigNotFoundException)
pub mod code_signing_config_not_found_exception {
    /// A builder for [`CodeSigningConfigNotFoundException`](crate::error::CodeSigningConfigNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CodeSigningConfigNotFoundException`](crate::error::CodeSigningConfigNotFoundException)
        pub fn build(self) -> crate::error::CodeSigningConfigNotFoundException {
            crate::error::CodeSigningConfigNotFoundException {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl CodeSigningConfigNotFoundException {
    /// Creates a new builder-style object to manufacture [`CodeSigningConfigNotFoundException`](crate::error::CodeSigningConfigNotFoundException)
    pub fn builder() -> crate::error::code_signing_config_not_found_exception::Builder {
        crate::error::code_signing_config_not_found_exception::Builder::default()
    }
}

/// <p>You have exceeded your maximum total code size per account. <a href="https://docs.aws.amazon.com/lambda/latest/dg/limits.html">Learn more</a>
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CodeStorageExceededException {
    /// <p>The exception type.</p>
    pub r#type: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CodeStorageExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CodeStorageExceededException");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CodeStorageExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CodeStorageExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CodeStorageExceededException")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for CodeStorageExceededException {}
/// See [`CodeStorageExceededException`](crate::error::CodeStorageExceededException)
pub mod code_storage_exceeded_exception {
    /// A builder for [`CodeStorageExceededException`](crate::error::CodeStorageExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The exception type.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CodeStorageExceededException`](crate::error::CodeStorageExceededException)
        pub fn build(self) -> crate::error::CodeStorageExceededException {
            crate::error::CodeStorageExceededException {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl CodeStorageExceededException {
    /// Creates a new builder-style object to manufacture [`CodeStorageExceededException`](crate::error::CodeStorageExceededException)
    pub fn builder() -> crate::error::code_storage_exceeded_exception::Builder {
        crate::error::code_storage_exceeded_exception::Builder::default()
    }
}

/// <p>The operation conflicts with the resource's availability. For example, you attempted to update an EventSource
/// Mapping in CREATING, or tried to delete a EventSource mapping currently in the UPDATING state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceInUseException {
    pub r#type: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceInUseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceInUseException");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceInUseException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceInUseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceInUseException")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceInUseException {}
/// See [`ResourceInUseException`](crate::error::ResourceInUseException)
pub mod resource_in_use_exception {
    /// A builder for [`ResourceInUseException`](crate::error::ResourceInUseException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceInUseException`](crate::error::ResourceInUseException)
        pub fn build(self) -> crate::error::ResourceInUseException {
            crate::error::ResourceInUseException {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl ResourceInUseException {
    /// Creates a new builder-style object to manufacture [`ResourceInUseException`](crate::error::ResourceInUseException)
    pub fn builder() -> crate::error::resource_in_use_exception::Builder {
        crate::error::resource_in_use_exception::Builder::default()
    }
}

/// <p>The runtime or runtime version specified is not supported.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRuntimeException {
    pub r#type: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRuntimeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRuntimeException");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRuntimeException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRuntimeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRuntimeException")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRuntimeException {}
/// See [`InvalidRuntimeException`](crate::error::InvalidRuntimeException)
pub mod invalid_runtime_exception {
    /// A builder for [`InvalidRuntimeException`](crate::error::InvalidRuntimeException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRuntimeException`](crate::error::InvalidRuntimeException)
        pub fn build(self) -> crate::error::InvalidRuntimeException {
            crate::error::InvalidRuntimeException {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl InvalidRuntimeException {
    /// Creates a new builder-style object to manufacture [`InvalidRuntimeException`](crate::error::InvalidRuntimeException)
    pub fn builder() -> crate::error::invalid_runtime_exception::Builder {
        crate::error::invalid_runtime_exception::Builder::default()
    }
}

/// <p>The request body could not be parsed as JSON.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRequestContentException {
    /// <p>The exception type.</p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The exception message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRequestContentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRequestContentException");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRequestContentException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRequestContentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRequestContentException")?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRequestContentException {}
/// See [`InvalidRequestContentException`](crate::error::InvalidRequestContentException)
pub mod invalid_request_content_exception {
    /// A builder for [`InvalidRequestContentException`](crate::error::InvalidRequestContentException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The exception type.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The exception message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRequestContentException`](crate::error::InvalidRequestContentException)
        pub fn build(self) -> crate::error::InvalidRequestContentException {
            crate::error::InvalidRequestContentException {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl InvalidRequestContentException {
    /// Creates a new builder-style object to manufacture [`InvalidRequestContentException`](crate::error::InvalidRequestContentException)
    pub fn builder() -> crate::error::invalid_request_content_exception::Builder {
        crate::error::invalid_request_content_exception::Builder::default()
    }
}

/// <p>The content type of the <code>Invoke</code> request body is not JSON.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnsupportedMediaTypeException {
    pub r#type: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnsupportedMediaTypeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnsupportedMediaTypeException");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnsupportedMediaTypeException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedMediaTypeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnsupportedMediaTypeException")?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedMediaTypeException {}
/// See [`UnsupportedMediaTypeException`](crate::error::UnsupportedMediaTypeException)
pub mod unsupported_media_type_exception {
    /// A builder for [`UnsupportedMediaTypeException`](crate::error::UnsupportedMediaTypeException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedMediaTypeException`](crate::error::UnsupportedMediaTypeException)
        pub fn build(self) -> crate::error::UnsupportedMediaTypeException {
            crate::error::UnsupportedMediaTypeException {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl UnsupportedMediaTypeException {
    /// Creates a new builder-style object to manufacture [`UnsupportedMediaTypeException`](crate::error::UnsupportedMediaTypeException)
    pub fn builder() -> crate::error::unsupported_media_type_exception::Builder {
        crate::error::unsupported_media_type_exception::Builder::default()
    }
}

/// <p>Lambda was not able to set up VPC access for the Lambda function because one or more configured subnets
/// has no available IP addresses.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SubnetIpAddressLimitReachedException {
    pub r#type: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SubnetIpAddressLimitReachedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SubnetIpAddressLimitReachedException");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SubnetIpAddressLimitReachedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SubnetIpAddressLimitReachedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SubnetIpAddressLimitReachedException [SubnetIPAddressLimitReachedException]"
        )?;
        if let Some(inner_15) = &self.message {
            write!(f, ": {}", inner_15)?;
        }
        Ok(())
    }
}
impl std::error::Error for SubnetIpAddressLimitReachedException {}
/// See [`SubnetIpAddressLimitReachedException`](crate::error::SubnetIpAddressLimitReachedException)
pub mod subnet_ip_address_limit_reached_exception {
    /// A builder for [`SubnetIpAddressLimitReachedException`](crate::error::SubnetIpAddressLimitReachedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SubnetIpAddressLimitReachedException`](crate::error::SubnetIpAddressLimitReachedException)
        pub fn build(self) -> crate::error::SubnetIpAddressLimitReachedException {
            crate::error::SubnetIpAddressLimitReachedException {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl SubnetIpAddressLimitReachedException {
    /// Creates a new builder-style object to manufacture [`SubnetIpAddressLimitReachedException`](crate::error::SubnetIpAddressLimitReachedException)
    pub fn builder() -> crate::error::subnet_ip_address_limit_reached_exception::Builder {
        crate::error::subnet_ip_address_limit_reached_exception::Builder::default()
    }
}

/// <p>The function is inactive and its VPC connection is no longer available. Wait for the VPC connection to
/// reestablish and try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotReadyException {
    /// <p>The exception type.</p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The exception message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotReadyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotReadyException");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceNotReadyException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotReadyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotReadyException")?;
        if let Some(inner_16) = &self.message {
            write!(f, ": {}", inner_16)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotReadyException {}
/// See [`ResourceNotReadyException`](crate::error::ResourceNotReadyException)
pub mod resource_not_ready_exception {
    /// A builder for [`ResourceNotReadyException`](crate::error::ResourceNotReadyException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The exception type.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The exception message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotReadyException`](crate::error::ResourceNotReadyException)
        pub fn build(self) -> crate::error::ResourceNotReadyException {
            crate::error::ResourceNotReadyException {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl ResourceNotReadyException {
    /// Creates a new builder-style object to manufacture [`ResourceNotReadyException`](crate::error::ResourceNotReadyException)
    pub fn builder() -> crate::error::resource_not_ready_exception::Builder {
        crate::error::resource_not_ready_exception::Builder::default()
    }
}

/// <p>The request payload exceeded the <code>Invoke</code> request body JSON input limit. For more information, see
/// <a href="https://docs.aws.amazon.com/lambda/latest/dg/limits.html">Limits</a>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RequestTooLargeException {
    pub r#type: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RequestTooLargeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RequestTooLargeException");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RequestTooLargeException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RequestTooLargeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RequestTooLargeException")?;
        if let Some(inner_17) = &self.message {
            write!(f, ": {}", inner_17)?;
        }
        Ok(())
    }
}
impl std::error::Error for RequestTooLargeException {}
/// See [`RequestTooLargeException`](crate::error::RequestTooLargeException)
pub mod request_too_large_exception {
    /// A builder for [`RequestTooLargeException`](crate::error::RequestTooLargeException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RequestTooLargeException`](crate::error::RequestTooLargeException)
        pub fn build(self) -> crate::error::RequestTooLargeException {
            crate::error::RequestTooLargeException {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl RequestTooLargeException {
    /// Creates a new builder-style object to manufacture [`RequestTooLargeException`](crate::error::RequestTooLargeException)
    pub fn builder() -> crate::error::request_too_large_exception::Builder {
        crate::error::request_too_large_exception::Builder::default()
    }
}

/// <p>Lambda was unable to decrypt the environment variables because the KMS key was not found. Check the function's
/// KMS key settings. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KmsNotFoundException {
    pub r#type: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for KmsNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KmsNotFoundException");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KmsNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for KmsNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KmsNotFoundException [KMSNotFoundException]")?;
        if let Some(inner_18) = &self.message {
            write!(f, ": {}", inner_18)?;
        }
        Ok(())
    }
}
impl std::error::Error for KmsNotFoundException {}
/// See [`KmsNotFoundException`](crate::error::KmsNotFoundException)
pub mod kms_not_found_exception {
    /// A builder for [`KmsNotFoundException`](crate::error::KmsNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`KmsNotFoundException`](crate::error::KmsNotFoundException)
        pub fn build(self) -> crate::error::KmsNotFoundException {
            crate::error::KmsNotFoundException {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl KmsNotFoundException {
    /// Creates a new builder-style object to manufacture [`KmsNotFoundException`](crate::error::KmsNotFoundException)
    pub fn builder() -> crate::error::kms_not_found_exception::Builder {
        crate::error::kms_not_found_exception::Builder::default()
    }
}

/// <p>Lambda was unable to decrypt the environment variables because the KMS key used is in an invalid state for
/// Decrypt. Check the function's KMS key settings.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KmsInvalidStateException {
    pub r#type: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for KmsInvalidStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KmsInvalidStateException");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KmsInvalidStateException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for KmsInvalidStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KmsInvalidStateException [KMSInvalidStateException]")?;
        if let Some(inner_19) = &self.message {
            write!(f, ": {}", inner_19)?;
        }
        Ok(())
    }
}
impl std::error::Error for KmsInvalidStateException {}
/// See [`KmsInvalidStateException`](crate::error::KmsInvalidStateException)
pub mod kms_invalid_state_exception {
    /// A builder for [`KmsInvalidStateException`](crate::error::KmsInvalidStateException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`KmsInvalidStateException`](crate::error::KmsInvalidStateException)
        pub fn build(self) -> crate::error::KmsInvalidStateException {
            crate::error::KmsInvalidStateException {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl KmsInvalidStateException {
    /// Creates a new builder-style object to manufacture [`KmsInvalidStateException`](crate::error::KmsInvalidStateException)
    pub fn builder() -> crate::error::kms_invalid_state_exception::Builder {
        crate::error::kms_invalid_state_exception::Builder::default()
    }
}

/// <p>Lambda was unable to decrypt the environment variables because the KMS key used is disabled. Check the Lambda
/// function's KMS key settings.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KmsDisabledException {
    pub r#type: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for KmsDisabledException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KmsDisabledException");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KmsDisabledException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for KmsDisabledException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KmsDisabledException [KMSDisabledException]")?;
        if let Some(inner_20) = &self.message {
            write!(f, ": {}", inner_20)?;
        }
        Ok(())
    }
}
impl std::error::Error for KmsDisabledException {}
/// See [`KmsDisabledException`](crate::error::KmsDisabledException)
pub mod kms_disabled_exception {
    /// A builder for [`KmsDisabledException`](crate::error::KmsDisabledException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`KmsDisabledException`](crate::error::KmsDisabledException)
        pub fn build(self) -> crate::error::KmsDisabledException {
            crate::error::KmsDisabledException {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl KmsDisabledException {
    /// Creates a new builder-style object to manufacture [`KmsDisabledException`](crate::error::KmsDisabledException)
    pub fn builder() -> crate::error::kms_disabled_exception::Builder {
        crate::error::kms_disabled_exception::Builder::default()
    }
}

/// <p>Lambda was unable to decrypt the environment variables because KMS access was denied. Check the Lambda
/// function's KMS permissions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KmsAccessDeniedException {
    pub r#type: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for KmsAccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KmsAccessDeniedException");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KmsAccessDeniedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for KmsAccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KmsAccessDeniedException [KMSAccessDeniedException]")?;
        if let Some(inner_21) = &self.message {
            write!(f, ": {}", inner_21)?;
        }
        Ok(())
    }
}
impl std::error::Error for KmsAccessDeniedException {}
/// See [`KmsAccessDeniedException`](crate::error::KmsAccessDeniedException)
pub mod kms_access_denied_exception {
    /// A builder for [`KmsAccessDeniedException`](crate::error::KmsAccessDeniedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`KmsAccessDeniedException`](crate::error::KmsAccessDeniedException)
        pub fn build(self) -> crate::error::KmsAccessDeniedException {
            crate::error::KmsAccessDeniedException {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl KmsAccessDeniedException {
    /// Creates a new builder-style object to manufacture [`KmsAccessDeniedException`](crate::error::KmsAccessDeniedException)
    pub fn builder() -> crate::error::kms_access_denied_exception::Builder {
        crate::error::kms_access_denied_exception::Builder::default()
    }
}

/// <p>Lambda could not unzip the deployment package.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidZipFileException {
    pub r#type: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidZipFileException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidZipFileException");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidZipFileException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidZipFileException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidZipFileException")?;
        if let Some(inner_22) = &self.message {
            write!(f, ": {}", inner_22)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidZipFileException {}
/// See [`InvalidZipFileException`](crate::error::InvalidZipFileException)
pub mod invalid_zip_file_exception {
    /// A builder for [`InvalidZipFileException`](crate::error::InvalidZipFileException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidZipFileException`](crate::error::InvalidZipFileException)
        pub fn build(self) -> crate::error::InvalidZipFileException {
            crate::error::InvalidZipFileException {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl InvalidZipFileException {
    /// Creates a new builder-style object to manufacture [`InvalidZipFileException`](crate::error::InvalidZipFileException)
    pub fn builder() -> crate::error::invalid_zip_file_exception::Builder {
        crate::error::invalid_zip_file_exception::Builder::default()
    }
}

/// <p>The Subnet ID provided in the Lambda function VPC configuration is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidSubnetIdException {
    pub r#type: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidSubnetIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidSubnetIdException");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidSubnetIdException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSubnetIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidSubnetIdException [InvalidSubnetIDException]")?;
        if let Some(inner_23) = &self.message {
            write!(f, ": {}", inner_23)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSubnetIdException {}
/// See [`InvalidSubnetIdException`](crate::error::InvalidSubnetIdException)
pub mod invalid_subnet_id_exception {
    /// A builder for [`InvalidSubnetIdException`](crate::error::InvalidSubnetIdException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSubnetIdException`](crate::error::InvalidSubnetIdException)
        pub fn build(self) -> crate::error::InvalidSubnetIdException {
            crate::error::InvalidSubnetIdException {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl InvalidSubnetIdException {
    /// Creates a new builder-style object to manufacture [`InvalidSubnetIdException`](crate::error::InvalidSubnetIdException)
    pub fn builder() -> crate::error::invalid_subnet_id_exception::Builder {
        crate::error::invalid_subnet_id_exception::Builder::default()
    }
}

/// <p>The Security Group ID provided in the Lambda function VPC configuration is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidSecurityGroupIdException {
    pub r#type: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidSecurityGroupIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidSecurityGroupIdException");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidSecurityGroupIdException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSecurityGroupIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidSecurityGroupIdException [InvalidSecurityGroupIDException]"
        )?;
        if let Some(inner_24) = &self.message {
            write!(f, ": {}", inner_24)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSecurityGroupIdException {}
/// See [`InvalidSecurityGroupIdException`](crate::error::InvalidSecurityGroupIdException)
pub mod invalid_security_group_id_exception {
    /// A builder for [`InvalidSecurityGroupIdException`](crate::error::InvalidSecurityGroupIdException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSecurityGroupIdException`](crate::error::InvalidSecurityGroupIdException)
        pub fn build(self) -> crate::error::InvalidSecurityGroupIdException {
            crate::error::InvalidSecurityGroupIdException {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl InvalidSecurityGroupIdException {
    /// Creates a new builder-style object to manufacture [`InvalidSecurityGroupIdException`](crate::error::InvalidSecurityGroupIdException)
    pub fn builder() -> crate::error::invalid_security_group_id_exception::Builder {
        crate::error::invalid_security_group_id_exception::Builder::default()
    }
}

/// <p>Lambda was not able to create an elastic network interface in the VPC, specified as part of Lambda
/// function configuration, because the limit for network interfaces has been reached.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EniLimitReachedException {
    pub r#type: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EniLimitReachedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EniLimitReachedException");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl EniLimitReachedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EniLimitReachedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EniLimitReachedException [ENILimitReachedException]")?;
        if let Some(inner_25) = &self.message {
            write!(f, ": {}", inner_25)?;
        }
        Ok(())
    }
}
impl std::error::Error for EniLimitReachedException {}
/// See [`EniLimitReachedException`](crate::error::EniLimitReachedException)
pub mod eni_limit_reached_exception {
    /// A builder for [`EniLimitReachedException`](crate::error::EniLimitReachedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`EniLimitReachedException`](crate::error::EniLimitReachedException)
        pub fn build(self) -> crate::error::EniLimitReachedException {
            crate::error::EniLimitReachedException {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl EniLimitReachedException {
    /// Creates a new builder-style object to manufacture [`EniLimitReachedException`](crate::error::EniLimitReachedException)
    pub fn builder() -> crate::error::eni_limit_reached_exception::Builder {
        crate::error::eni_limit_reached_exception::Builder::default()
    }
}

/// <p>The function was able to make a network connection to the configured file system, but the mount operation
/// timed out.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EfsMountTimeoutException {
    pub r#type: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EfsMountTimeoutException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EfsMountTimeoutException");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl EfsMountTimeoutException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EfsMountTimeoutException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EfsMountTimeoutException [EFSMountTimeoutException]")?;
        if let Some(inner_26) = &self.message {
            write!(f, ": {}", inner_26)?;
        }
        Ok(())
    }
}
impl std::error::Error for EfsMountTimeoutException {}
/// See [`EfsMountTimeoutException`](crate::error::EfsMountTimeoutException)
pub mod efs_mount_timeout_exception {
    /// A builder for [`EfsMountTimeoutException`](crate::error::EfsMountTimeoutException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`EfsMountTimeoutException`](crate::error::EfsMountTimeoutException)
        pub fn build(self) -> crate::error::EfsMountTimeoutException {
            crate::error::EfsMountTimeoutException {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl EfsMountTimeoutException {
    /// Creates a new builder-style object to manufacture [`EfsMountTimeoutException`](crate::error::EfsMountTimeoutException)
    pub fn builder() -> crate::error::efs_mount_timeout_exception::Builder {
        crate::error::efs_mount_timeout_exception::Builder::default()
    }
}

/// <p>The function couldn't mount the configured file system due to a permission or configuration issue.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EfsMountFailureException {
    pub r#type: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EfsMountFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EfsMountFailureException");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl EfsMountFailureException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EfsMountFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EfsMountFailureException [EFSMountFailureException]")?;
        if let Some(inner_27) = &self.message {
            write!(f, ": {}", inner_27)?;
        }
        Ok(())
    }
}
impl std::error::Error for EfsMountFailureException {}
/// See [`EfsMountFailureException`](crate::error::EfsMountFailureException)
pub mod efs_mount_failure_exception {
    /// A builder for [`EfsMountFailureException`](crate::error::EfsMountFailureException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`EfsMountFailureException`](crate::error::EfsMountFailureException)
        pub fn build(self) -> crate::error::EfsMountFailureException {
            crate::error::EfsMountFailureException {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl EfsMountFailureException {
    /// Creates a new builder-style object to manufacture [`EfsMountFailureException`](crate::error::EfsMountFailureException)
    pub fn builder() -> crate::error::efs_mount_failure_exception::Builder {
        crate::error::efs_mount_failure_exception::Builder::default()
    }
}

/// <p>The function couldn't make a network connection to the configured file system.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EfsMountConnectivityException {
    pub r#type: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EfsMountConnectivityException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EfsMountConnectivityException");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl EfsMountConnectivityException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EfsMountConnectivityException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "EfsMountConnectivityException [EFSMountConnectivityException]"
        )?;
        if let Some(inner_28) = &self.message {
            write!(f, ": {}", inner_28)?;
        }
        Ok(())
    }
}
impl std::error::Error for EfsMountConnectivityException {}
/// See [`EfsMountConnectivityException`](crate::error::EfsMountConnectivityException)
pub mod efs_mount_connectivity_exception {
    /// A builder for [`EfsMountConnectivityException`](crate::error::EfsMountConnectivityException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`EfsMountConnectivityException`](crate::error::EfsMountConnectivityException)
        pub fn build(self) -> crate::error::EfsMountConnectivityException {
            crate::error::EfsMountConnectivityException {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl EfsMountConnectivityException {
    /// Creates a new builder-style object to manufacture [`EfsMountConnectivityException`](crate::error::EfsMountConnectivityException)
    pub fn builder() -> crate::error::efs_mount_connectivity_exception::Builder {
        crate::error::efs_mount_connectivity_exception::Builder::default()
    }
}

/// <p>An error occured when reading from or writing to a connected file system.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EfsioException {
    pub r#type: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EfsioException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EfsioException");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl EfsioException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EfsioException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EfsioException [EFSIOException]")?;
        if let Some(inner_29) = &self.message {
            write!(f, ": {}", inner_29)?;
        }
        Ok(())
    }
}
impl std::error::Error for EfsioException {}
/// See [`EfsioException`](crate::error::EfsioException)
pub mod efsio_exception {
    /// A builder for [`EfsioException`](crate::error::EfsioException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`EfsioException`](crate::error::EfsioException)
        pub fn build(self) -> crate::error::EfsioException {
            crate::error::EfsioException {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl EfsioException {
    /// Creates a new builder-style object to manufacture [`EfsioException`](crate::error::EfsioException)
    pub fn builder() -> crate::error::efsio_exception::Builder {
        crate::error::efsio_exception::Builder::default()
    }
}

/// <p>Lambda received an unexpected EC2 client exception while setting up for the Lambda function.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Ec2UnexpectedException {
    pub r#type: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
    pub ec2_error_code: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Ec2UnexpectedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Ec2UnexpectedException");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.field("ec2_error_code", &self.ec2_error_code);
        formatter.finish()
    }
}
impl Ec2UnexpectedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for Ec2UnexpectedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Ec2UnexpectedException [EC2UnexpectedException]")?;
        if let Some(inner_30) = &self.message {
            write!(f, ": {}", inner_30)?;
        }
        Ok(())
    }
}
impl std::error::Error for Ec2UnexpectedException {}
/// See [`Ec2UnexpectedException`](crate::error::Ec2UnexpectedException)
pub mod ec2_unexpected_exception {
    /// A builder for [`Ec2UnexpectedException`](crate::error::Ec2UnexpectedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) ec2_error_code: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn ec2_error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.ec2_error_code = Some(input.into());
            self
        }
        pub fn set_ec2_error_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ec2_error_code = input;
            self
        }
        /// Consumes the builder and constructs a [`Ec2UnexpectedException`](crate::error::Ec2UnexpectedException)
        pub fn build(self) -> crate::error::Ec2UnexpectedException {
            crate::error::Ec2UnexpectedException {
                r#type: self.r#type,
                message: self.message,
                ec2_error_code: self.ec2_error_code,
            }
        }
    }
}
impl Ec2UnexpectedException {
    /// Creates a new builder-style object to manufacture [`Ec2UnexpectedException`](crate::error::Ec2UnexpectedException)
    pub fn builder() -> crate::error::ec2_unexpected_exception::Builder {
        crate::error::ec2_unexpected_exception::Builder::default()
    }
}

/// <p>Lambda was throttled by Amazon EC2 during Lambda function initialization using the execution role provided
/// for the Lambda function.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Ec2ThrottledException {
    pub r#type: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Ec2ThrottledException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Ec2ThrottledException");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl Ec2ThrottledException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for Ec2ThrottledException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Ec2ThrottledException [EC2ThrottledException]")?;
        if let Some(inner_31) = &self.message {
            write!(f, ": {}", inner_31)?;
        }
        Ok(())
    }
}
impl std::error::Error for Ec2ThrottledException {}
/// See [`Ec2ThrottledException`](crate::error::Ec2ThrottledException)
pub mod ec2_throttled_exception {
    /// A builder for [`Ec2ThrottledException`](crate::error::Ec2ThrottledException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`Ec2ThrottledException`](crate::error::Ec2ThrottledException)
        pub fn build(self) -> crate::error::Ec2ThrottledException {
            crate::error::Ec2ThrottledException {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl Ec2ThrottledException {
    /// Creates a new builder-style object to manufacture [`Ec2ThrottledException`](crate::error::Ec2ThrottledException)
    pub fn builder() -> crate::error::ec2_throttled_exception::Builder {
        crate::error::ec2_throttled_exception::Builder::default()
    }
}

/// <p>Need additional permissions to configure VPC settings.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Ec2AccessDeniedException {
    pub r#type: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Ec2AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Ec2AccessDeniedException");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl Ec2AccessDeniedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for Ec2AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Ec2AccessDeniedException [EC2AccessDeniedException]")?;
        if let Some(inner_32) = &self.message {
            write!(f, ": {}", inner_32)?;
        }
        Ok(())
    }
}
impl std::error::Error for Ec2AccessDeniedException {}
/// See [`Ec2AccessDeniedException`](crate::error::Ec2AccessDeniedException)
pub mod ec2_access_denied_exception {
    /// A builder for [`Ec2AccessDeniedException`](crate::error::Ec2AccessDeniedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`Ec2AccessDeniedException`](crate::error::Ec2AccessDeniedException)
        pub fn build(self) -> crate::error::Ec2AccessDeniedException {
            crate::error::Ec2AccessDeniedException {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl Ec2AccessDeniedException {
    /// Creates a new builder-style object to manufacture [`Ec2AccessDeniedException`](crate::error::Ec2AccessDeniedException)
    pub fn builder() -> crate::error::ec2_access_denied_exception::Builder {
        crate::error::ec2_access_denied_exception::Builder::default()
    }
}

/// <p>The specified configuration does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProvisionedConcurrencyConfigNotFoundException {
    pub r#type: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ProvisionedConcurrencyConfigNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProvisionedConcurrencyConfigNotFoundException");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ProvisionedConcurrencyConfigNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ProvisionedConcurrencyConfigNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ProvisionedConcurrencyConfigNotFoundException")?;
        if let Some(inner_33) = &self.message {
            write!(f, ": {}", inner_33)?;
        }
        Ok(())
    }
}
impl std::error::Error for ProvisionedConcurrencyConfigNotFoundException {}
/// See [`ProvisionedConcurrencyConfigNotFoundException`](crate::error::ProvisionedConcurrencyConfigNotFoundException)
pub mod provisioned_concurrency_config_not_found_exception {
    /// A builder for [`ProvisionedConcurrencyConfigNotFoundException`](crate::error::ProvisionedConcurrencyConfigNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ProvisionedConcurrencyConfigNotFoundException`](crate::error::ProvisionedConcurrencyConfigNotFoundException)
        pub fn build(self) -> crate::error::ProvisionedConcurrencyConfigNotFoundException {
            crate::error::ProvisionedConcurrencyConfigNotFoundException {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl ProvisionedConcurrencyConfigNotFoundException {
    /// Creates a new builder-style object to manufacture [`ProvisionedConcurrencyConfigNotFoundException`](crate::error::ProvisionedConcurrencyConfigNotFoundException)
    pub fn builder() -> crate::error::provisioned_concurrency_config_not_found_exception::Builder {
        crate::error::provisioned_concurrency_config_not_found_exception::Builder::default()
    }
}

/// <p>The permissions policy for the resource is too large. <a href="https://docs.aws.amazon.com/lambda/latest/dg/limits.html">Learn more</a>
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PolicyLengthExceededException {
    pub r#type: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PolicyLengthExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PolicyLengthExceededException");
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PolicyLengthExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PolicyLengthExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PolicyLengthExceededException")?;
        if let Some(inner_34) = &self.message {
            write!(f, ": {}", inner_34)?;
        }
        Ok(())
    }
}
impl std::error::Error for PolicyLengthExceededException {}
/// See [`PolicyLengthExceededException`](crate::error::PolicyLengthExceededException)
pub mod policy_length_exceeded_exception {
    /// A builder for [`PolicyLengthExceededException`](crate::error::PolicyLengthExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PolicyLengthExceededException`](crate::error::PolicyLengthExceededException)
        pub fn build(self) -> crate::error::PolicyLengthExceededException {
            crate::error::PolicyLengthExceededException {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl PolicyLengthExceededException {
    /// Creates a new builder-style object to manufacture [`PolicyLengthExceededException`](crate::error::PolicyLengthExceededException)
    pub fn builder() -> crate::error::policy_length_exceeded_exception::Builder {
        crate::error::policy_length_exceeded_exception::Builder::default()
    }
}
