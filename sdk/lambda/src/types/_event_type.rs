// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// When writing a match expression against `EventType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let eventtype = unimplemented!();
/// match eventtype {
///     EventType::CallbackFailed => { /* ... */ },
///     EventType::CallbackStarted => { /* ... */ },
///     EventType::CallbackSucceeded => { /* ... */ },
///     EventType::CallbackTimedOut => { /* ... */ },
///     EventType::ChainedInvokeFailed => { /* ... */ },
///     EventType::ChainedInvokeStarted => { /* ... */ },
///     EventType::ChainedInvokeStopped => { /* ... */ },
///     EventType::ChainedInvokeSucceeded => { /* ... */ },
///     EventType::ChainedInvokeTimedOut => { /* ... */ },
///     EventType::ContextFailed => { /* ... */ },
///     EventType::ContextStarted => { /* ... */ },
///     EventType::ContextSucceeded => { /* ... */ },
///     EventType::ExecutionFailed => { /* ... */ },
///     EventType::ExecutionStarted => { /* ... */ },
///     EventType::ExecutionStopped => { /* ... */ },
///     EventType::ExecutionSucceeded => { /* ... */ },
///     EventType::ExecutionTimedOut => { /* ... */ },
///     EventType::InvocationCompleted => { /* ... */ },
///     EventType::StepFailed => { /* ... */ },
///     EventType::StepStarted => { /* ... */ },
///     EventType::StepSucceeded => { /* ... */ },
///     EventType::WaitCancelled => { /* ... */ },
///     EventType::WaitStarted => { /* ... */ },
///     EventType::WaitSucceeded => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `eventtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EventType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EventType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EventType::NewFeature` is defined.
/// Specifically, when `eventtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EventType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
///
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    ::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::Ord, ::std::cmp::PartialEq, ::std::cmp::PartialOrd, ::std::fmt::Debug, ::std::hash::Hash,
)]
pub enum EventType {
    #[allow(missing_docs)] // documentation missing in model
    CallbackFailed,
    #[allow(missing_docs)] // documentation missing in model
    CallbackStarted,
    #[allow(missing_docs)] // documentation missing in model
    CallbackSucceeded,
    #[allow(missing_docs)] // documentation missing in model
    CallbackTimedOut,
    #[allow(missing_docs)] // documentation missing in model
    ChainedInvokeFailed,
    #[allow(missing_docs)] // documentation missing in model
    ChainedInvokeStarted,
    #[allow(missing_docs)] // documentation missing in model
    ChainedInvokeStopped,
    #[allow(missing_docs)] // documentation missing in model
    ChainedInvokeSucceeded,
    #[allow(missing_docs)] // documentation missing in model
    ChainedInvokeTimedOut,
    #[allow(missing_docs)] // documentation missing in model
    ContextFailed,
    #[allow(missing_docs)] // documentation missing in model
    ContextStarted,
    #[allow(missing_docs)] // documentation missing in model
    ContextSucceeded,
    #[allow(missing_docs)] // documentation missing in model
    ExecutionFailed,
    #[allow(missing_docs)] // documentation missing in model
    ExecutionStarted,
    #[allow(missing_docs)] // documentation missing in model
    ExecutionStopped,
    #[allow(missing_docs)] // documentation missing in model
    ExecutionSucceeded,
    #[allow(missing_docs)] // documentation missing in model
    ExecutionTimedOut,
    #[allow(missing_docs)] // documentation missing in model
    InvocationCompleted,
    #[allow(missing_docs)] // documentation missing in model
    StepFailed,
    #[allow(missing_docs)] // documentation missing in model
    StepStarted,
    #[allow(missing_docs)] // documentation missing in model
    StepSucceeded,
    #[allow(missing_docs)] // documentation missing in model
    WaitCancelled,
    #[allow(missing_docs)] // documentation missing in model
    WaitStarted,
    #[allow(missing_docs)] // documentation missing in model
    WaitSucceeded,
    /// `Unknown` contains new variants that have been added since this code was generated.
    #[deprecated(note = "Don't directly match on `Unknown`. See the docs on this enum for the correct way to handle unknown variants.")]
    Unknown(crate::primitives::sealed_enum_unknown::UnknownVariantValue),
}
impl ::std::convert::From<&str> for EventType {
    fn from(s: &str) -> Self {
        match s {
            "CallbackFailed" => EventType::CallbackFailed,
            "CallbackStarted" => EventType::CallbackStarted,
            "CallbackSucceeded" => EventType::CallbackSucceeded,
            "CallbackTimedOut" => EventType::CallbackTimedOut,
            "ChainedInvokeFailed" => EventType::ChainedInvokeFailed,
            "ChainedInvokeStarted" => EventType::ChainedInvokeStarted,
            "ChainedInvokeStopped" => EventType::ChainedInvokeStopped,
            "ChainedInvokeSucceeded" => EventType::ChainedInvokeSucceeded,
            "ChainedInvokeTimedOut" => EventType::ChainedInvokeTimedOut,
            "ContextFailed" => EventType::ContextFailed,
            "ContextStarted" => EventType::ContextStarted,
            "ContextSucceeded" => EventType::ContextSucceeded,
            "ExecutionFailed" => EventType::ExecutionFailed,
            "ExecutionStarted" => EventType::ExecutionStarted,
            "ExecutionStopped" => EventType::ExecutionStopped,
            "ExecutionSucceeded" => EventType::ExecutionSucceeded,
            "ExecutionTimedOut" => EventType::ExecutionTimedOut,
            "InvocationCompleted" => EventType::InvocationCompleted,
            "StepFailed" => EventType::StepFailed,
            "StepStarted" => EventType::StepStarted,
            "StepSucceeded" => EventType::StepSucceeded,
            "WaitCancelled" => EventType::WaitCancelled,
            "WaitStarted" => EventType::WaitStarted,
            "WaitSucceeded" => EventType::WaitSucceeded,
            other => EventType::Unknown(crate::primitives::sealed_enum_unknown::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl ::std::str::FromStr for EventType {
    type Err = ::std::convert::Infallible;

    fn from_str(s: &str) -> ::std::result::Result<Self, <Self as ::std::str::FromStr>::Err> {
        ::std::result::Result::Ok(EventType::from(s))
    }
}
impl EventType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EventType::CallbackFailed => "CallbackFailed",
            EventType::CallbackStarted => "CallbackStarted",
            EventType::CallbackSucceeded => "CallbackSucceeded",
            EventType::CallbackTimedOut => "CallbackTimedOut",
            EventType::ChainedInvokeFailed => "ChainedInvokeFailed",
            EventType::ChainedInvokeStarted => "ChainedInvokeStarted",
            EventType::ChainedInvokeStopped => "ChainedInvokeStopped",
            EventType::ChainedInvokeSucceeded => "ChainedInvokeSucceeded",
            EventType::ChainedInvokeTimedOut => "ChainedInvokeTimedOut",
            EventType::ContextFailed => "ContextFailed",
            EventType::ContextStarted => "ContextStarted",
            EventType::ContextSucceeded => "ContextSucceeded",
            EventType::ExecutionFailed => "ExecutionFailed",
            EventType::ExecutionStarted => "ExecutionStarted",
            EventType::ExecutionStopped => "ExecutionStopped",
            EventType::ExecutionSucceeded => "ExecutionSucceeded",
            EventType::ExecutionTimedOut => "ExecutionTimedOut",
            EventType::InvocationCompleted => "InvocationCompleted",
            EventType::StepFailed => "StepFailed",
            EventType::StepStarted => "StepStarted",
            EventType::StepSucceeded => "StepSucceeded",
            EventType::WaitCancelled => "WaitCancelled",
            EventType::WaitStarted => "WaitStarted",
            EventType::WaitSucceeded => "WaitSucceeded",
            EventType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CallbackFailed",
            "CallbackStarted",
            "CallbackSucceeded",
            "CallbackTimedOut",
            "ChainedInvokeFailed",
            "ChainedInvokeStarted",
            "ChainedInvokeStopped",
            "ChainedInvokeSucceeded",
            "ChainedInvokeTimedOut",
            "ContextFailed",
            "ContextStarted",
            "ContextSucceeded",
            "ExecutionFailed",
            "ExecutionStarted",
            "ExecutionStopped",
            "ExecutionSucceeded",
            "ExecutionTimedOut",
            "InvocationCompleted",
            "StepFailed",
            "StepStarted",
            "StepSucceeded",
            "WaitCancelled",
            "WaitStarted",
            "WaitSucceeded",
        ]
    }
}
impl ::std::convert::AsRef<str> for EventType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl EventType {
    /// Parses the enum value while disallowing unknown variants.
    ///
    /// Unknown variants will result in an error.
    pub fn try_parse(value: &str) -> ::std::result::Result<Self, crate::error::UnknownVariantError> {
        match Self::from(value) {
            #[allow(deprecated)]
            Self::Unknown(_) => ::std::result::Result::Err(crate::error::UnknownVariantError::new(value)),
            known => Ok(known),
        }
    }
}
impl ::std::fmt::Display for EventType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            EventType::CallbackFailed => write!(f, "CallbackFailed"),
            EventType::CallbackStarted => write!(f, "CallbackStarted"),
            EventType::CallbackSucceeded => write!(f, "CallbackSucceeded"),
            EventType::CallbackTimedOut => write!(f, "CallbackTimedOut"),
            EventType::ChainedInvokeFailed => write!(f, "ChainedInvokeFailed"),
            EventType::ChainedInvokeStarted => write!(f, "ChainedInvokeStarted"),
            EventType::ChainedInvokeStopped => write!(f, "ChainedInvokeStopped"),
            EventType::ChainedInvokeSucceeded => write!(f, "ChainedInvokeSucceeded"),
            EventType::ChainedInvokeTimedOut => write!(f, "ChainedInvokeTimedOut"),
            EventType::ContextFailed => write!(f, "ContextFailed"),
            EventType::ContextStarted => write!(f, "ContextStarted"),
            EventType::ContextSucceeded => write!(f, "ContextSucceeded"),
            EventType::ExecutionFailed => write!(f, "ExecutionFailed"),
            EventType::ExecutionStarted => write!(f, "ExecutionStarted"),
            EventType::ExecutionStopped => write!(f, "ExecutionStopped"),
            EventType::ExecutionSucceeded => write!(f, "ExecutionSucceeded"),
            EventType::ExecutionTimedOut => write!(f, "ExecutionTimedOut"),
            EventType::InvocationCompleted => write!(f, "InvocationCompleted"),
            EventType::StepFailed => write!(f, "StepFailed"),
            EventType::StepStarted => write!(f, "StepStarted"),
            EventType::StepSucceeded => write!(f, "StepSucceeded"),
            EventType::WaitCancelled => write!(f, "WaitCancelled"),
            EventType::WaitStarted => write!(f, "WaitStarted"),
            EventType::WaitSucceeded => write!(f, "WaitSucceeded"),
            EventType::Unknown(value) => write!(f, "{value}"),
        }
    }
}
