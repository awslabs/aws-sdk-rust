// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_layer_version_permission_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::AddLayerVersionPermissionOutput,
    crate::error::AddLayerVersionPermissionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::AddLayerVersionPermissionError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::AddLayerVersionPermissionError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::AddLayerVersionPermissionError {
            meta: generic,
            kind: crate::error::AddLayerVersionPermissionErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AddLayerVersionPermissionError::unhandled)?;
                output.build()
            }),
        },
        "PolicyLengthExceededException" => crate::error::AddLayerVersionPermissionError {
            meta: generic,
            kind: crate::error::AddLayerVersionPermissionErrorKind::PolicyLengthExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::policy_length_exceeded_error::Builder::default();
                let _ = response;
                output = crate::json_deser::policy_length_exceeded_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AddLayerVersionPermissionError::unhandled)?;
                output.build()
            }),
        },
        "PreconditionFailedException" => crate::error::AddLayerVersionPermissionError {
            meta: generic,
            kind: crate::error::AddLayerVersionPermissionErrorKind::PreconditionFailedError({
                #[allow(unused_mut)]
                let mut output = crate::error::precondition_failed_error::Builder::default();
                let _ = response;
                output = crate::json_deser::precondition_failed_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AddLayerVersionPermissionError::unhandled)?;
                output.build()
            }),
        },
        "ResourceConflictException" => crate::error::AddLayerVersionPermissionError {
            meta: generic,
            kind: crate::error::AddLayerVersionPermissionErrorKind::ResourceConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_conflict_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AddLayerVersionPermissionError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::AddLayerVersionPermissionError {
            meta: generic,
            kind: crate::error::AddLayerVersionPermissionErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AddLayerVersionPermissionError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::AddLayerVersionPermissionError {
            meta: generic,
            kind: crate::error::AddLayerVersionPermissionErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::AddLayerVersionPermissionError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::AddLayerVersionPermissionError {
            meta: generic,
            kind: crate::error::AddLayerVersionPermissionErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AddLayerVersionPermissionError::unhandled)?;
                output = output.set_retry_after_seconds(
                
                                        crate::http_serde::deser_header_add_layer_version_permission_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::AddLayerVersionPermissionError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                        
            );
                output.build()
            }),
        },
        _ => crate::error::AddLayerVersionPermissionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_layer_version_permission_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::AddLayerVersionPermissionOutput,
    crate::error::AddLayerVersionPermissionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::add_layer_version_permission_output::Builder::default();
        let _ = response;
        output = crate::json_deser::add_layer_version_permission_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AddLayerVersionPermissionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_permission_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::AddPermissionOutput, crate::error::AddPermissionError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::AddPermissionError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AddPermissionError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::AddPermissionError {
            meta: generic,
            kind: crate::error::AddPermissionErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AddPermissionError::unhandled)?;
                output.build()
            }),
        },
        "PolicyLengthExceededException" => crate::error::AddPermissionError {
            meta: generic,
            kind: crate::error::AddPermissionErrorKind::PolicyLengthExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::policy_length_exceeded_error::Builder::default();
                let _ = response;
                output = crate::json_deser::policy_length_exceeded_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AddPermissionError::unhandled)?;
                output.build()
            }),
        },
        "PreconditionFailedException" => crate::error::AddPermissionError {
            meta: generic,
            kind: crate::error::AddPermissionErrorKind::PreconditionFailedError({
                #[allow(unused_mut)]
                let mut output = crate::error::precondition_failed_error::Builder::default();
                let _ = response;
                output = crate::json_deser::precondition_failed_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AddPermissionError::unhandled)?;
                output.build()
            }),
        },
        "ResourceConflictException" => crate::error::AddPermissionError {
            meta: generic,
            kind: crate::error::AddPermissionErrorKind::ResourceConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_conflict_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AddPermissionError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::AddPermissionError {
            meta: generic,
            kind: crate::error::AddPermissionErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AddPermissionError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::AddPermissionError {
            meta: generic,
            kind: crate::error::AddPermissionErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::AddPermissionError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::AddPermissionError {
            meta: generic,
            kind: crate::error::AddPermissionErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AddPermissionError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_add_permission_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::AddPermissionError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        _ => crate::error::AddPermissionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_permission_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::AddPermissionOutput, crate::error::AddPermissionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::add_permission_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::add_permission_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::AddPermissionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_alias_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CreateAliasOutput, crate::error::CreateAliasError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateAliasError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateAliasError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::CreateAliasError {
            meta: generic,
            kind: crate::error::CreateAliasErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateAliasError::unhandled)?;
                output.build()
            }),
        },
        "ResourceConflictException" => crate::error::CreateAliasError {
            meta: generic,
            kind: crate::error::CreateAliasErrorKind::ResourceConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_conflict_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateAliasError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::CreateAliasError {
            meta: generic,
            kind: crate::error::CreateAliasErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateAliasError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::CreateAliasError {
            meta: generic,
            kind: crate::error::CreateAliasErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateAliasError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::CreateAliasError {
            meta: generic,
            kind: crate::error::CreateAliasErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateAliasError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_create_alias_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::CreateAliasError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        _ => crate::error::CreateAliasError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_alias_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CreateAliasOutput, crate::error::CreateAliasError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_alias_output::Builder::default();
        let _ = response;
        output = crate::json_deser::create_alias_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::CreateAliasError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_code_signing_config_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CreateCodeSigningConfigOutput, crate::error::CreateCodeSigningConfigError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateCodeSigningConfigError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateCodeSigningConfigError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::CreateCodeSigningConfigError {
            meta: generic,
            kind: crate::error::CreateCodeSigningConfigErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateCodeSigningConfigError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::CreateCodeSigningConfigError {
            meta: generic,
            kind: crate::error::CreateCodeSigningConfigErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateCodeSigningConfigError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateCodeSigningConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_code_signing_config_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CreateCodeSigningConfigOutput, crate::error::CreateCodeSigningConfigError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_code_signing_config_output::Builder::default();
        let _ = response;
        output = crate::json_deser::create_code_signing_config_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateCodeSigningConfigError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_event_source_mapping_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::CreateEventSourceMappingOutput,
    crate::error::CreateEventSourceMappingError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateEventSourceMappingError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateEventSourceMappingError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::CreateEventSourceMappingError {
            meta: generic,
            kind: crate::error::CreateEventSourceMappingErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateEventSourceMappingError::unhandled)?;
                output.build()
            }),
        },
        "ResourceConflictException" => crate::error::CreateEventSourceMappingError {
            meta: generic,
            kind: crate::error::CreateEventSourceMappingErrorKind::ResourceConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_conflict_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateEventSourceMappingError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::CreateEventSourceMappingError {
            meta: generic,
            kind: crate::error::CreateEventSourceMappingErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateEventSourceMappingError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::CreateEventSourceMappingError {
            meta: generic,
            kind: crate::error::CreateEventSourceMappingErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateEventSourceMappingError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::CreateEventSourceMappingError {
            meta: generic,
            kind: crate::error::CreateEventSourceMappingErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateEventSourceMappingError::unhandled)?;
                output = output.set_retry_after_seconds(
                
                                        crate::http_serde::deser_header_create_event_source_mapping_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::CreateEventSourceMappingError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                        
            );
                output.build()
            }),
        },
        _ => crate::error::CreateEventSourceMappingError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_event_source_mapping_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::CreateEventSourceMappingOutput,
    crate::error::CreateEventSourceMappingError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_event_source_mapping_output::Builder::default();
        let _ = response;
        output = crate::json_deser::create_event_source_mapping_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateEventSourceMappingError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_function_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CreateFunctionOutput, crate::error::CreateFunctionError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateFunctionError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateFunctionError::unhandled(generic)),
    };
    Err(match error_code {
        "CodeSigningConfigNotFoundException" => crate::error::CreateFunctionError {
            meta: generic,
            kind: crate::error::CreateFunctionErrorKind::CodeSigningConfigNotFoundError({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::code_signing_config_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::code_signing_config_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateFunctionError::unhandled)?;
                output.build()
            }),
        },
        "CodeStorageExceededException" => crate::error::CreateFunctionError {
            meta: generic,
            kind: crate::error::CreateFunctionErrorKind::CodeStorageExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::code_storage_exceeded_error::Builder::default();
                let _ = response;
                output = crate::json_deser::code_storage_exceeded_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateFunctionError::unhandled)?;
                output.build()
            }),
        },
        "CodeVerificationFailedException" => crate::error::CreateFunctionError {
            meta: generic,
            kind: crate::error::CreateFunctionErrorKind::CodeVerificationFailedError({
                #[allow(unused_mut)]
                let mut output = crate::error::code_verification_failed_error::Builder::default();
                let _ = response;
                output = crate::json_deser::code_verification_failed_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateFunctionError::unhandled)?;
                output.build()
            }),
        },
        "InvalidCodeSignatureException" => crate::error::CreateFunctionError {
            meta: generic,
            kind: crate::error::CreateFunctionErrorKind::InvalidCodeSignatureError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_code_signature_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_code_signature_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateFunctionError::unhandled)?;
                output.build()
            }),
        },
        "InvalidParameterValueException" => crate::error::CreateFunctionError {
            meta: generic,
            kind: crate::error::CreateFunctionErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateFunctionError::unhandled)?;
                output.build()
            }),
        },
        "ResourceConflictException" => crate::error::CreateFunctionError {
            meta: generic,
            kind: crate::error::CreateFunctionErrorKind::ResourceConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_conflict_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateFunctionError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::CreateFunctionError {
            meta: generic,
            kind: crate::error::CreateFunctionErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateFunctionError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::CreateFunctionError {
            meta: generic,
            kind: crate::error::CreateFunctionErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateFunctionError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::CreateFunctionError {
            meta: generic,
            kind: crate::error::CreateFunctionErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateFunctionError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_create_function_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::CreateFunctionError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        _ => crate::error::CreateFunctionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_function_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::CreateFunctionOutput, crate::error::CreateFunctionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_function_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::create_function_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::CreateFunctionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_alias_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteAliasOutput, crate::error::DeleteAliasError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteAliasError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteAliasError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::DeleteAliasError {
            meta: generic,
            kind: crate::error::DeleteAliasErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteAliasError::unhandled)?;
                output.build()
            }),
        },
        "ResourceConflictException" => crate::error::DeleteAliasError {
            meta: generic,
            kind: crate::error::DeleteAliasErrorKind::ResourceConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_conflict_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteAliasError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::DeleteAliasError {
            meta: generic,
            kind: crate::error::DeleteAliasErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteAliasError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::DeleteAliasError {
            meta: generic,
            kind: crate::error::DeleteAliasErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteAliasError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_delete_alias_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::DeleteAliasError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        _ => crate::error::DeleteAliasError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_alias_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteAliasOutput, crate::error::DeleteAliasError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_alias_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_code_signing_config_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteCodeSigningConfigOutput, crate::error::DeleteCodeSigningConfigError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteCodeSigningConfigError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteCodeSigningConfigError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::DeleteCodeSigningConfigError {
            meta: generic,
            kind: crate::error::DeleteCodeSigningConfigErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteCodeSigningConfigError::unhandled)?;
                output.build()
            }),
        },
        "ResourceConflictException" => crate::error::DeleteCodeSigningConfigError {
            meta: generic,
            kind: crate::error::DeleteCodeSigningConfigErrorKind::ResourceConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_conflict_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteCodeSigningConfigError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::DeleteCodeSigningConfigError {
            meta: generic,
            kind: crate::error::DeleteCodeSigningConfigErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteCodeSigningConfigError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::DeleteCodeSigningConfigError {
            meta: generic,
            kind: crate::error::DeleteCodeSigningConfigErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteCodeSigningConfigError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteCodeSigningConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_code_signing_config_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteCodeSigningConfigOutput, crate::error::DeleteCodeSigningConfigError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_code_signing_config_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_event_source_mapping_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::DeleteEventSourceMappingOutput,
    crate::error::DeleteEventSourceMappingError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteEventSourceMappingError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteEventSourceMappingError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::DeleteEventSourceMappingError {
            meta: generic,
            kind: crate::error::DeleteEventSourceMappingErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteEventSourceMappingError::unhandled)?;
                output.build()
            }),
        },
        "ResourceInUseException" => crate::error::DeleteEventSourceMappingError {
            meta: generic,
            kind: crate::error::DeleteEventSourceMappingErrorKind::ResourceInUseError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::resource_in_use_exception(response.body().as_ref(), output)
                        .map_err(crate::error::DeleteEventSourceMappingError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::DeleteEventSourceMappingError {
            meta: generic,
            kind: crate::error::DeleteEventSourceMappingErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteEventSourceMappingError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::DeleteEventSourceMappingError {
            meta: generic,
            kind: crate::error::DeleteEventSourceMappingErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteEventSourceMappingError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::DeleteEventSourceMappingError {
            meta: generic,
            kind: crate::error::DeleteEventSourceMappingErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteEventSourceMappingError::unhandled)?;
                output = output.set_retry_after_seconds(
                
                                        crate::http_serde::deser_header_delete_event_source_mapping_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::DeleteEventSourceMappingError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                        
            );
                output.build()
            }),
        },
        _ => crate::error::DeleteEventSourceMappingError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_event_source_mapping_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::DeleteEventSourceMappingOutput,
    crate::error::DeleteEventSourceMappingError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_event_source_mapping_output::Builder::default();
        let _ = response;
        output = crate::json_deser::delete_event_source_mapping_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteEventSourceMappingError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_function_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteFunctionOutput, crate::error::DeleteFunctionError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteFunctionError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteFunctionError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::DeleteFunctionError {
            meta: generic,
            kind: crate::error::DeleteFunctionErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteFunctionError::unhandled)?;
                output.build()
            }),
        },
        "ResourceConflictException" => crate::error::DeleteFunctionError {
            meta: generic,
            kind: crate::error::DeleteFunctionErrorKind::ResourceConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_conflict_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteFunctionError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::DeleteFunctionError {
            meta: generic,
            kind: crate::error::DeleteFunctionErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteFunctionError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::DeleteFunctionError {
            meta: generic,
            kind: crate::error::DeleteFunctionErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteFunctionError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::DeleteFunctionError {
            meta: generic,
            kind: crate::error::DeleteFunctionErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteFunctionError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_delete_function_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::DeleteFunctionError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        _ => crate::error::DeleteFunctionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_function_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteFunctionOutput, crate::error::DeleteFunctionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_function_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_function_code_signing_config_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::DeleteFunctionCodeSigningConfigOutput,
    crate::error::DeleteFunctionCodeSigningConfigError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteFunctionCodeSigningConfigError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteFunctionCodeSigningConfigError::unhandled(generic)),
    };
    Err(match error_code {
        "CodeSigningConfigNotFoundException" => crate::error::DeleteFunctionCodeSigningConfigError { meta: generic, kind: crate::error::DeleteFunctionCodeSigningConfigErrorKind::CodeSigningConfigNotFoundError({
            #[allow(unused_mut)]let mut output = crate::error::code_signing_config_not_found_error::Builder::default();
            let _ = response;
            output = crate::json_deser::code_signing_config_not_found_exception(response.body().as_ref(), output).map_err(crate::error::DeleteFunctionCodeSigningConfigError::unhandled)?;
            output.build()
        })},
        "InvalidParameterValueException" => crate::error::DeleteFunctionCodeSigningConfigError { meta: generic, kind: crate::error::DeleteFunctionCodeSigningConfigErrorKind::InvalidParameterValueError({
            #[allow(unused_mut)]let mut output = crate::error::invalid_parameter_value_error::Builder::default();
            let _ = response;
            output = crate::json_deser::invalid_parameter_value_exception(response.body().as_ref(), output).map_err(crate::error::DeleteFunctionCodeSigningConfigError::unhandled)?;
            output.build()
        })},
        "ResourceConflictException" => crate::error::DeleteFunctionCodeSigningConfigError { meta: generic, kind: crate::error::DeleteFunctionCodeSigningConfigErrorKind::ResourceConflictError({
            #[allow(unused_mut)]let mut output = crate::error::resource_conflict_error::Builder::default();
            let _ = response;
            output = crate::json_deser::resource_conflict_exception(response.body().as_ref(), output).map_err(crate::error::DeleteFunctionCodeSigningConfigError::unhandled)?;
            output.build()
        })},
        "ResourceNotFoundException" => crate::error::DeleteFunctionCodeSigningConfigError { meta: generic, kind: crate::error::DeleteFunctionCodeSigningConfigErrorKind::ResourceNotFoundError({
            #[allow(unused_mut)]let mut output = crate::error::resource_not_found_error::Builder::default();
            let _ = response;
            output = crate::json_deser::resource_not_found_exception(response.body().as_ref(), output).map_err(crate::error::DeleteFunctionCodeSigningConfigError::unhandled)?;
            output.build()
        })},
        "ServiceException" => crate::error::DeleteFunctionCodeSigningConfigError { meta: generic, kind: crate::error::DeleteFunctionCodeSigningConfigErrorKind::ServiceError({
            #[allow(unused_mut)]let mut output = crate::error::service_error::Builder::default();
            let _ = response;
            output = crate::json_deser::service_exception(response.body().as_ref(), output).map_err(crate::error::DeleteFunctionCodeSigningConfigError::unhandled)?;
            output.build()
        })},
        "TooManyRequestsException" => crate::error::DeleteFunctionCodeSigningConfigError { meta: generic, kind: crate::error::DeleteFunctionCodeSigningConfigErrorKind::TooManyRequestsError({
            #[allow(unused_mut)]let mut output = crate::error::too_many_requests_error::Builder::default();
            let _ = response;
            output = crate::json_deser::too_many_requests_exception(response.body().as_ref(), output).map_err(crate::error::DeleteFunctionCodeSigningConfigError::unhandled)?;
            output = output.set_retry_after_seconds(
                
                                        crate::http_serde::deser_header_delete_function_code_signing_config_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::DeleteFunctionCodeSigningConfigError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                        
            );
            output.build()
        })},
        _ => crate::error::DeleteFunctionCodeSigningConfigError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_function_code_signing_config_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::DeleteFunctionCodeSigningConfigOutput,
    crate::error::DeleteFunctionCodeSigningConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_function_code_signing_config_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_function_concurrency_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::DeleteFunctionConcurrencyOutput,
    crate::error::DeleteFunctionConcurrencyError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteFunctionConcurrencyError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteFunctionConcurrencyError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::DeleteFunctionConcurrencyError {
            meta: generic,
            kind: crate::error::DeleteFunctionConcurrencyErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteFunctionConcurrencyError::unhandled)?;
                output.build()
            }),
        },
        "ResourceConflictException" => crate::error::DeleteFunctionConcurrencyError {
            meta: generic,
            kind: crate::error::DeleteFunctionConcurrencyErrorKind::ResourceConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_conflict_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteFunctionConcurrencyError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::DeleteFunctionConcurrencyError {
            meta: generic,
            kind: crate::error::DeleteFunctionConcurrencyErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteFunctionConcurrencyError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::DeleteFunctionConcurrencyError {
            meta: generic,
            kind: crate::error::DeleteFunctionConcurrencyErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteFunctionConcurrencyError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::DeleteFunctionConcurrencyError {
            meta: generic,
            kind: crate::error::DeleteFunctionConcurrencyErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteFunctionConcurrencyError::unhandled)?;
                output = output.set_retry_after_seconds(
                
                                        crate::http_serde::deser_header_delete_function_concurrency_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::DeleteFunctionConcurrencyError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                        
            );
                output.build()
            }),
        },
        _ => crate::error::DeleteFunctionConcurrencyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_function_concurrency_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::DeleteFunctionConcurrencyOutput,
    crate::error::DeleteFunctionConcurrencyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_function_concurrency_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_function_event_invoke_config_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::DeleteFunctionEventInvokeConfigOutput,
    crate::error::DeleteFunctionEventInvokeConfigError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteFunctionEventInvokeConfigError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteFunctionEventInvokeConfigError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::DeleteFunctionEventInvokeConfigError {
            meta: generic,
            kind:
                crate::error::DeleteFunctionEventInvokeConfigErrorKind::InvalidParameterValueError(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_parameter_value_error::Builder::default();
                        let _ = response;
                        output = crate::json_deser::invalid_parameter_value_exception(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DeleteFunctionEventInvokeConfigError::unhandled)?;
                        output.build()
                    },
                ),
        },
        "ResourceNotFoundException" => crate::error::DeleteFunctionEventInvokeConfigError {
            meta: generic,
            kind: crate::error::DeleteFunctionEventInvokeConfigErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteFunctionEventInvokeConfigError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::DeleteFunctionEventInvokeConfigError {
            meta: generic,
            kind: crate::error::DeleteFunctionEventInvokeConfigErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteFunctionEventInvokeConfigError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::DeleteFunctionEventInvokeConfigError {
            meta: generic,
            kind: crate::error::DeleteFunctionEventInvokeConfigErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteFunctionEventInvokeConfigError::unhandled)?;
                output = output.set_retry_after_seconds(
                
                                        crate::http_serde::deser_header_delete_function_event_invoke_config_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::DeleteFunctionEventInvokeConfigError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                        
            );
                output.build()
            }),
        },
        _ => crate::error::DeleteFunctionEventInvokeConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_function_event_invoke_config_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::DeleteFunctionEventInvokeConfigOutput,
    crate::error::DeleteFunctionEventInvokeConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_function_event_invoke_config_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_layer_version_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteLayerVersionOutput, crate::error::DeleteLayerVersionError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteLayerVersionError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteLayerVersionError::unhandled(generic)),
    };
    Err(match error_code {
        "ServiceException" => crate::error::DeleteLayerVersionError {
            meta: generic,
            kind: crate::error::DeleteLayerVersionErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteLayerVersionError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::DeleteLayerVersionError {
            meta: generic,
            kind: crate::error::DeleteLayerVersionErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteLayerVersionError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_delete_layer_version_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::DeleteLayerVersionError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        _ => crate::error::DeleteLayerVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_layer_version_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::DeleteLayerVersionOutput, crate::error::DeleteLayerVersionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_layer_version_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_provisioned_concurrency_config_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::DeleteProvisionedConcurrencyConfigOutput,
    crate::error::DeleteProvisionedConcurrencyConfigError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteProvisionedConcurrencyConfigError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteProvisionedConcurrencyConfigError::unhandled(generic))
        }
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::DeleteProvisionedConcurrencyConfigError { meta: generic, kind: crate::error::DeleteProvisionedConcurrencyConfigErrorKind::InvalidParameterValueError({
            #[allow(unused_mut)]let mut output = crate::error::invalid_parameter_value_error::Builder::default();
            let _ = response;
            output = crate::json_deser::invalid_parameter_value_exception(response.body().as_ref(), output).map_err(crate::error::DeleteProvisionedConcurrencyConfigError::unhandled)?;
            output.build()
        })},
        "ResourceConflictException" => crate::error::DeleteProvisionedConcurrencyConfigError { meta: generic, kind: crate::error::DeleteProvisionedConcurrencyConfigErrorKind::ResourceConflictError({
            #[allow(unused_mut)]let mut output = crate::error::resource_conflict_error::Builder::default();
            let _ = response;
            output = crate::json_deser::resource_conflict_exception(response.body().as_ref(), output).map_err(crate::error::DeleteProvisionedConcurrencyConfigError::unhandled)?;
            output.build()
        })},
        "ResourceNotFoundException" => crate::error::DeleteProvisionedConcurrencyConfigError { meta: generic, kind: crate::error::DeleteProvisionedConcurrencyConfigErrorKind::ResourceNotFoundError({
            #[allow(unused_mut)]let mut output = crate::error::resource_not_found_error::Builder::default();
            let _ = response;
            output = crate::json_deser::resource_not_found_exception(response.body().as_ref(), output).map_err(crate::error::DeleteProvisionedConcurrencyConfigError::unhandled)?;
            output.build()
        })},
        "ServiceException" => crate::error::DeleteProvisionedConcurrencyConfigError { meta: generic, kind: crate::error::DeleteProvisionedConcurrencyConfigErrorKind::ServiceError({
            #[allow(unused_mut)]let mut output = crate::error::service_error::Builder::default();
            let _ = response;
            output = crate::json_deser::service_exception(response.body().as_ref(), output).map_err(crate::error::DeleteProvisionedConcurrencyConfigError::unhandled)?;
            output.build()
        })},
        "TooManyRequestsException" => crate::error::DeleteProvisionedConcurrencyConfigError { meta: generic, kind: crate::error::DeleteProvisionedConcurrencyConfigErrorKind::TooManyRequestsError({
            #[allow(unused_mut)]let mut output = crate::error::too_many_requests_error::Builder::default();
            let _ = response;
            output = crate::json_deser::too_many_requests_exception(response.body().as_ref(), output).map_err(crate::error::DeleteProvisionedConcurrencyConfigError::unhandled)?;
            output = output.set_retry_after_seconds(
                
                                        crate::http_serde::deser_header_delete_provisioned_concurrency_config_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::DeleteProvisionedConcurrencyConfigError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                        
            );
            output.build()
        })},
        _ => crate::error::DeleteProvisionedConcurrencyConfigError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_provisioned_concurrency_config_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::DeleteProvisionedConcurrencyConfigOutput,
    crate::error::DeleteProvisionedConcurrencyConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_provisioned_concurrency_config_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_account_settings_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetAccountSettingsOutput, crate::error::GetAccountSettingsError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetAccountSettingsError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetAccountSettingsError::unhandled(generic)),
    };
    Err(match error_code {
        "ServiceException" => crate::error::GetAccountSettingsError {
            meta: generic,
            kind: crate::error::GetAccountSettingsErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetAccountSettingsError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetAccountSettingsError {
            meta: generic,
            kind: crate::error::GetAccountSettingsErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetAccountSettingsError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_account_settings_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetAccountSettingsError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        _ => crate::error::GetAccountSettingsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_account_settings_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetAccountSettingsOutput, crate::error::GetAccountSettingsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_account_settings_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_account_settings_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetAccountSettingsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_alias_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetAliasOutput, crate::error::GetAliasError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetAliasError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetAliasError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::GetAliasError {
            meta: generic,
            kind: crate::error::GetAliasErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetAliasError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::GetAliasError {
            meta: generic,
            kind: crate::error::GetAliasErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetAliasError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::GetAliasError {
            meta: generic,
            kind: crate::error::GetAliasErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetAliasError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetAliasError {
            meta: generic,
            kind: crate::error::GetAliasErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetAliasError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_alias_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetAliasError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        _ => crate::error::GetAliasError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_alias_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetAliasOutput, crate::error::GetAliasError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_alias_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_alias_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::GetAliasError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_code_signing_config_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetCodeSigningConfigOutput, crate::error::GetCodeSigningConfigError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetCodeSigningConfigError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetCodeSigningConfigError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::GetCodeSigningConfigError {
            meta: generic,
            kind: crate::error::GetCodeSigningConfigErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetCodeSigningConfigError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::GetCodeSigningConfigError {
            meta: generic,
            kind: crate::error::GetCodeSigningConfigErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetCodeSigningConfigError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::GetCodeSigningConfigError {
            meta: generic,
            kind: crate::error::GetCodeSigningConfigErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetCodeSigningConfigError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetCodeSigningConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_code_signing_config_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetCodeSigningConfigOutput, crate::error::GetCodeSigningConfigError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_code_signing_config_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_code_signing_config_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetCodeSigningConfigError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_event_source_mapping_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetEventSourceMappingOutput, crate::error::GetEventSourceMappingError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetEventSourceMappingError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetEventSourceMappingError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::GetEventSourceMappingError {
            meta: generic,
            kind: crate::error::GetEventSourceMappingErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetEventSourceMappingError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::GetEventSourceMappingError {
            meta: generic,
            kind: crate::error::GetEventSourceMappingErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetEventSourceMappingError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::GetEventSourceMappingError {
            meta: generic,
            kind: crate::error::GetEventSourceMappingErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetEventSourceMappingError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => {
            crate::error::GetEventSourceMappingError {
                meta: generic,
                kind: crate::error::GetEventSourceMappingErrorKind::TooManyRequestsError({
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_requests_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::too_many_requests_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetEventSourceMappingError::unhandled)?;
                    output = output.set_retry_after_seconds(
                
                                        crate::http_serde::deser_header_get_event_source_mapping_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::GetEventSourceMappingError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                        
            );
                    output.build()
                }),
            }
        }
        _ => crate::error::GetEventSourceMappingError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_event_source_mapping_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetEventSourceMappingOutput, crate::error::GetEventSourceMappingError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_event_source_mapping_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_event_source_mapping_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetEventSourceMappingError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_function_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetFunctionOutput, crate::error::GetFunctionError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetFunctionError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetFunctionError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::GetFunctionError {
            meta: generic,
            kind: crate::error::GetFunctionErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetFunctionError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::GetFunctionError {
            meta: generic,
            kind: crate::error::GetFunctionErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetFunctionError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::GetFunctionError {
            meta: generic,
            kind: crate::error::GetFunctionErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetFunctionError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetFunctionError {
            meta: generic,
            kind: crate::error::GetFunctionErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetFunctionError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_function_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetFunctionError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        _ => crate::error::GetFunctionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_function_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetFunctionOutput, crate::error::GetFunctionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_function_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_function_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::GetFunctionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_function_code_signing_config_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetFunctionCodeSigningConfigOutput,
    crate::error::GetFunctionCodeSigningConfigError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetFunctionCodeSigningConfigError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetFunctionCodeSigningConfigError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::GetFunctionCodeSigningConfigError {
            meta: generic,
            kind: crate::error::GetFunctionCodeSigningConfigErrorKind::InvalidParameterValueError(
                {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_parameter_value_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::invalid_parameter_value_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetFunctionCodeSigningConfigError::unhandled)?;
                    output.build()
                },
            ),
        },
        "ResourceNotFoundException" => crate::error::GetFunctionCodeSigningConfigError {
            meta: generic,
            kind: crate::error::GetFunctionCodeSigningConfigErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetFunctionCodeSigningConfigError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::GetFunctionCodeSigningConfigError {
            meta: generic,
            kind: crate::error::GetFunctionCodeSigningConfigErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetFunctionCodeSigningConfigError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetFunctionCodeSigningConfigError {
            meta: generic,
            kind: crate::error::GetFunctionCodeSigningConfigErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetFunctionCodeSigningConfigError::unhandled)?;
                output = output.set_retry_after_seconds(
                
                                        crate::http_serde::deser_header_get_function_code_signing_config_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::GetFunctionCodeSigningConfigError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                        
            );
                output.build()
            }),
        },
        _ => crate::error::GetFunctionCodeSigningConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_function_code_signing_config_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetFunctionCodeSigningConfigOutput,
    crate::error::GetFunctionCodeSigningConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_function_code_signing_config_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_function_code_signing_config_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetFunctionCodeSigningConfigError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_function_concurrency_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetFunctionConcurrencyOutput, crate::error::GetFunctionConcurrencyError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetFunctionConcurrencyError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetFunctionConcurrencyError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::GetFunctionConcurrencyError {
            meta: generic,
            kind: crate::error::GetFunctionConcurrencyErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetFunctionConcurrencyError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::GetFunctionConcurrencyError {
            meta: generic,
            kind: crate::error::GetFunctionConcurrencyErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetFunctionConcurrencyError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::GetFunctionConcurrencyError {
            meta: generic,
            kind: crate::error::GetFunctionConcurrencyErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetFunctionConcurrencyError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => {
            crate::error::GetFunctionConcurrencyError {
                meta: generic,
                kind: crate::error::GetFunctionConcurrencyErrorKind::TooManyRequestsError({
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_requests_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::too_many_requests_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetFunctionConcurrencyError::unhandled)?;
                    output = output.set_retry_after_seconds(
                
                                        crate::http_serde::deser_header_get_function_concurrency_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::GetFunctionConcurrencyError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                        
            );
                    output.build()
                }),
            }
        }
        _ => crate::error::GetFunctionConcurrencyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_function_concurrency_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetFunctionConcurrencyOutput, crate::error::GetFunctionConcurrencyError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_function_concurrency_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_function_concurrency_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetFunctionConcurrencyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_function_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetFunctionConfigurationOutput,
    crate::error::GetFunctionConfigurationError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetFunctionConfigurationError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetFunctionConfigurationError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::GetFunctionConfigurationError {
            meta: generic,
            kind: crate::error::GetFunctionConfigurationErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetFunctionConfigurationError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::GetFunctionConfigurationError {
            meta: generic,
            kind: crate::error::GetFunctionConfigurationErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetFunctionConfigurationError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::GetFunctionConfigurationError {
            meta: generic,
            kind: crate::error::GetFunctionConfigurationErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetFunctionConfigurationError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => {
            crate::error::GetFunctionConfigurationError {
                meta: generic,
                kind: crate::error::GetFunctionConfigurationErrorKind::TooManyRequestsError({
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_requests_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::too_many_requests_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetFunctionConfigurationError::unhandled)?;
                    output = output.set_retry_after_seconds(
                
                                        crate::http_serde::deser_header_get_function_configuration_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::GetFunctionConfigurationError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                        
            );
                    output.build()
                }),
            }
        }
        _ => crate::error::GetFunctionConfigurationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_function_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetFunctionConfigurationOutput,
    crate::error::GetFunctionConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_function_configuration_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_function_configuration_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetFunctionConfigurationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_function_event_invoke_config_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetFunctionEventInvokeConfigOutput,
    crate::error::GetFunctionEventInvokeConfigError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetFunctionEventInvokeConfigError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetFunctionEventInvokeConfigError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::GetFunctionEventInvokeConfigError {
            meta: generic,
            kind: crate::error::GetFunctionEventInvokeConfigErrorKind::InvalidParameterValueError(
                {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_parameter_value_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::invalid_parameter_value_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetFunctionEventInvokeConfigError::unhandled)?;
                    output.build()
                },
            ),
        },
        "ResourceNotFoundException" => crate::error::GetFunctionEventInvokeConfigError {
            meta: generic,
            kind: crate::error::GetFunctionEventInvokeConfigErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetFunctionEventInvokeConfigError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::GetFunctionEventInvokeConfigError {
            meta: generic,
            kind: crate::error::GetFunctionEventInvokeConfigErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetFunctionEventInvokeConfigError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetFunctionEventInvokeConfigError {
            meta: generic,
            kind: crate::error::GetFunctionEventInvokeConfigErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetFunctionEventInvokeConfigError::unhandled)?;
                output = output.set_retry_after_seconds(
                
                                        crate::http_serde::deser_header_get_function_event_invoke_config_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::GetFunctionEventInvokeConfigError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                        
            );
                output.build()
            }),
        },
        _ => crate::error::GetFunctionEventInvokeConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_function_event_invoke_config_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetFunctionEventInvokeConfigOutput,
    crate::error::GetFunctionEventInvokeConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_function_event_invoke_config_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_function_event_invoke_config_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetFunctionEventInvokeConfigError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_layer_version_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetLayerVersionOutput, crate::error::GetLayerVersionError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetLayerVersionError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetLayerVersionError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::GetLayerVersionError {
            meta: generic,
            kind: crate::error::GetLayerVersionErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetLayerVersionError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::GetLayerVersionError {
            meta: generic,
            kind: crate::error::GetLayerVersionErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetLayerVersionError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::GetLayerVersionError {
            meta: generic,
            kind: crate::error::GetLayerVersionErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetLayerVersionError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetLayerVersionError {
            meta: generic,
            kind: crate::error::GetLayerVersionErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetLayerVersionError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_layer_version_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetLayerVersionError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        _ => crate::error::GetLayerVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_layer_version_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetLayerVersionOutput, crate::error::GetLayerVersionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_layer_version_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::get_layer_version_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::GetLayerVersionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_layer_version_by_arn_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetLayerVersionByArnOutput, crate::error::GetLayerVersionByArnError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetLayerVersionByArnError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetLayerVersionByArnError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::GetLayerVersionByArnError {
            meta: generic,
            kind: crate::error::GetLayerVersionByArnErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetLayerVersionByArnError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::GetLayerVersionByArnError {
            meta: generic,
            kind: crate::error::GetLayerVersionByArnErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetLayerVersionByArnError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::GetLayerVersionByArnError {
            meta: generic,
            kind: crate::error::GetLayerVersionByArnErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetLayerVersionByArnError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => {
            crate::error::GetLayerVersionByArnError {
                meta: generic,
                kind: crate::error::GetLayerVersionByArnErrorKind::TooManyRequestsError({
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_requests_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::too_many_requests_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetLayerVersionByArnError::unhandled)?;
                    output = output.set_retry_after_seconds(
                
                                        crate::http_serde::deser_header_get_layer_version_by_arn_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::GetLayerVersionByArnError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                        
            );
                    output.build()
                }),
            }
        }
        _ => crate::error::GetLayerVersionByArnError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_layer_version_by_arn_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetLayerVersionByArnOutput, crate::error::GetLayerVersionByArnError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_layer_version_by_arn_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_layer_version_by_arn_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetLayerVersionByArnError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_layer_version_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetLayerVersionPolicyOutput, crate::error::GetLayerVersionPolicyError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetLayerVersionPolicyError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetLayerVersionPolicyError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::GetLayerVersionPolicyError {
            meta: generic,
            kind: crate::error::GetLayerVersionPolicyErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetLayerVersionPolicyError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::GetLayerVersionPolicyError {
            meta: generic,
            kind: crate::error::GetLayerVersionPolicyErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetLayerVersionPolicyError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::GetLayerVersionPolicyError {
            meta: generic,
            kind: crate::error::GetLayerVersionPolicyErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetLayerVersionPolicyError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => {
            crate::error::GetLayerVersionPolicyError {
                meta: generic,
                kind: crate::error::GetLayerVersionPolicyErrorKind::TooManyRequestsError({
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_requests_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::too_many_requests_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetLayerVersionPolicyError::unhandled)?;
                    output = output.set_retry_after_seconds(
                
                                        crate::http_serde::deser_header_get_layer_version_policy_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::GetLayerVersionPolicyError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                        
            );
                    output.build()
                }),
            }
        }
        _ => crate::error::GetLayerVersionPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_layer_version_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetLayerVersionPolicyOutput, crate::error::GetLayerVersionPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_layer_version_policy_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_layer_version_policy_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetLayerVersionPolicyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetPolicyOutput, crate::error::GetPolicyError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetPolicyError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetPolicyError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::GetPolicyError {
            meta: generic,
            kind: crate::error::GetPolicyErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetPolicyError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::GetPolicyError {
            meta: generic,
            kind: crate::error::GetPolicyErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetPolicyError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::GetPolicyError {
            meta: generic,
            kind: crate::error::GetPolicyErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetPolicyError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetPolicyError {
            meta: generic,
            kind: crate::error::GetPolicyErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetPolicyError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_policy_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetPolicyError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        _ => crate::error::GetPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::GetPolicyOutput, crate::error::GetPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_policy_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_policy_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::GetPolicyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_provisioned_concurrency_config_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetProvisionedConcurrencyConfigOutput,
    crate::error::GetProvisionedConcurrencyConfigError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetProvisionedConcurrencyConfigError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetProvisionedConcurrencyConfigError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::GetProvisionedConcurrencyConfigError { meta: generic, kind: crate::error::GetProvisionedConcurrencyConfigErrorKind::InvalidParameterValueError({
            #[allow(unused_mut)]let mut output = crate::error::invalid_parameter_value_error::Builder::default();
            let _ = response;
            output = crate::json_deser::invalid_parameter_value_exception(response.body().as_ref(), output).map_err(crate::error::GetProvisionedConcurrencyConfigError::unhandled)?;
            output.build()
        })},
        "ProvisionedConcurrencyConfigNotFoundException" => crate::error::GetProvisionedConcurrencyConfigError { meta: generic, kind: crate::error::GetProvisionedConcurrencyConfigErrorKind::ProvisionedConcurrencyConfigNotFoundError({
            #[allow(unused_mut)]let mut output = crate::error::provisioned_concurrency_config_not_found_error::Builder::default();
            let _ = response;
            output = crate::json_deser::provisioned_concurrency_config_not_found_exception(response.body().as_ref(), output).map_err(crate::error::GetProvisionedConcurrencyConfigError::unhandled)?;
            output.build()
        })},
        "ResourceNotFoundException" => crate::error::GetProvisionedConcurrencyConfigError { meta: generic, kind: crate::error::GetProvisionedConcurrencyConfigErrorKind::ResourceNotFoundError({
            #[allow(unused_mut)]let mut output = crate::error::resource_not_found_error::Builder::default();
            let _ = response;
            output = crate::json_deser::resource_not_found_exception(response.body().as_ref(), output).map_err(crate::error::GetProvisionedConcurrencyConfigError::unhandled)?;
            output.build()
        })},
        "ServiceException" => crate::error::GetProvisionedConcurrencyConfigError { meta: generic, kind: crate::error::GetProvisionedConcurrencyConfigErrorKind::ServiceError({
            #[allow(unused_mut)]let mut output = crate::error::service_error::Builder::default();
            let _ = response;
            output = crate::json_deser::service_exception(response.body().as_ref(), output).map_err(crate::error::GetProvisionedConcurrencyConfigError::unhandled)?;
            output.build()
        })},
        "TooManyRequestsException" => crate::error::GetProvisionedConcurrencyConfigError { meta: generic, kind: crate::error::GetProvisionedConcurrencyConfigErrorKind::TooManyRequestsError({
            #[allow(unused_mut)]let mut output = crate::error::too_many_requests_error::Builder::default();
            let _ = response;
            output = crate::json_deser::too_many_requests_exception(response.body().as_ref(), output).map_err(crate::error::GetProvisionedConcurrencyConfigError::unhandled)?;
            output = output.set_retry_after_seconds(
                
                                        crate::http_serde::deser_header_get_provisioned_concurrency_config_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::GetProvisionedConcurrencyConfigError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                        
            );
            output.build()
        })},
        _ => crate::error::GetProvisionedConcurrencyConfigError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_provisioned_concurrency_config_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::GetProvisionedConcurrencyConfigOutput,
    crate::error::GetProvisionedConcurrencyConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_provisioned_concurrency_config_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_provisioned_concurrency_config_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetProvisionedConcurrencyConfigError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_invoke_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::InvokeOutput, crate::error::InvokeError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::InvokeError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::InvokeError::unhandled(generic)),
    };
    Err(match error_code {
        "EC2AccessDeniedException" => crate::error::InvokeError {
            meta: generic,
            kind: crate::error::InvokeErrorKind::EC2AccessDeniedError({
                #[allow(unused_mut)]
                let mut output = crate::error::ec2_access_denied_error::Builder::default();
                let _ = response;
                output = crate::json_deser::ec2_access_denied_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::InvokeError::unhandled)?;
                output.build()
            }),
        },
        "EC2ThrottledException" => crate::error::InvokeError {
            meta: generic,
            kind: crate::error::InvokeErrorKind::EC2ThrottledError({
                #[allow(unused_mut)]
                let mut output = crate::error::ec2_throttled_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::ec2_throttled_exception(response.body().as_ref(), output)
                        .map_err(crate::error::InvokeError::unhandled)?;
                output.build()
            }),
        },
        "EC2UnexpectedException" => crate::error::InvokeError {
            meta: generic,
            kind: crate::error::InvokeErrorKind::EC2UnexpectedError({
                #[allow(unused_mut)]
                let mut output = crate::error::ec2_unexpected_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::ec2_unexpected_exception(response.body().as_ref(), output)
                        .map_err(crate::error::InvokeError::unhandled)?;
                output.build()
            }),
        },
        "EFSIOException" => crate::error::InvokeError {
            meta: generic,
            kind: crate::error::InvokeErrorKind::EFSIOError({
                #[allow(unused_mut)]
                let mut output = crate::error::efsio_error::Builder::default();
                let _ = response;
                output = crate::json_deser::efsio_exception(response.body().as_ref(), output)
                    .map_err(crate::error::InvokeError::unhandled)?;
                output.build()
            }),
        },
        "EFSMountConnectivityException" => crate::error::InvokeError {
            meta: generic,
            kind: crate::error::InvokeErrorKind::EFSMountConnectivityError({
                #[allow(unused_mut)]
                let mut output = crate::error::efs_mount_connectivity_error::Builder::default();
                let _ = response;
                output = crate::json_deser::efs_mount_connectivity_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::InvokeError::unhandled)?;
                output.build()
            }),
        },
        "EFSMountFailureException" => crate::error::InvokeError {
            meta: generic,
            kind: crate::error::InvokeErrorKind::EFSMountFailureError({
                #[allow(unused_mut)]
                let mut output = crate::error::efs_mount_failure_error::Builder::default();
                let _ = response;
                output = crate::json_deser::efs_mount_failure_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::InvokeError::unhandled)?;
                output.build()
            }),
        },
        "EFSMountTimeoutException" => crate::error::InvokeError {
            meta: generic,
            kind: crate::error::InvokeErrorKind::EFSMountTimeoutError({
                #[allow(unused_mut)]
                let mut output = crate::error::efs_mount_timeout_error::Builder::default();
                let _ = response;
                output = crate::json_deser::efs_mount_timeout_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::InvokeError::unhandled)?;
                output.build()
            }),
        },
        "ENILimitReachedException" => crate::error::InvokeError {
            meta: generic,
            kind: crate::error::InvokeErrorKind::ENILimitReachedError({
                #[allow(unused_mut)]
                let mut output = crate::error::eni_limit_reached_error::Builder::default();
                let _ = response;
                output = crate::json_deser::eni_limit_reached_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::InvokeError::unhandled)?;
                output.build()
            }),
        },
        "InvalidParameterValueException" => crate::error::InvokeError {
            meta: generic,
            kind: crate::error::InvokeErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::InvokeError::unhandled)?;
                output.build()
            }),
        },
        "InvalidRequestContentException" => crate::error::InvokeError {
            meta: generic,
            kind: crate::error::InvokeErrorKind::InvalidRequestContentError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_request_content_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_request_content_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::InvokeError::unhandled)?;
                output.build()
            }),
        },
        "InvalidRuntimeException" => crate::error::InvokeError {
            meta: generic,
            kind: crate::error::InvokeErrorKind::InvalidRuntimeError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_runtime_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::invalid_runtime_exception(response.body().as_ref(), output)
                        .map_err(crate::error::InvokeError::unhandled)?;
                output.build()
            }),
        },
        "InvalidSecurityGroupIDException" => crate::error::InvokeError {
            meta: generic,
            kind: crate::error::InvokeErrorKind::InvalidSecurityGroupIDError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_security_group_id_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_security_group_id_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::InvokeError::unhandled)?;
                output.build()
            }),
        },
        "InvalidSubnetIDException" => crate::error::InvokeError {
            meta: generic,
            kind: crate::error::InvokeErrorKind::InvalidSubnetIDError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_subnet_id_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_subnet_id_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::InvokeError::unhandled)?;
                output.build()
            }),
        },
        "InvalidZipFileException" => crate::error::InvokeError {
            meta: generic,
            kind: crate::error::InvokeErrorKind::InvalidZipFileError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_zip_file_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::invalid_zip_file_exception(response.body().as_ref(), output)
                        .map_err(crate::error::InvokeError::unhandled)?;
                output.build()
            }),
        },
        "KMSAccessDeniedException" => crate::error::InvokeError {
            meta: generic,
            kind: crate::error::InvokeErrorKind::KMSAccessDeniedError({
                #[allow(unused_mut)]
                let mut output = crate::error::kms_access_denied_error::Builder::default();
                let _ = response;
                output = crate::json_deser::kms_access_denied_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::InvokeError::unhandled)?;
                output.build()
            }),
        },
        "KMSDisabledException" => crate::error::InvokeError {
            meta: generic,
            kind: crate::error::InvokeErrorKind::KMSDisabledError({
                #[allow(unused_mut)]
                let mut output = crate::error::kms_disabled_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::kms_disabled_exception(response.body().as_ref(), output)
                        .map_err(crate::error::InvokeError::unhandled)?;
                output.build()
            }),
        },
        "KMSInvalidStateException" => crate::error::InvokeError {
            meta: generic,
            kind: crate::error::InvokeErrorKind::KMSInvalidStateError({
                #[allow(unused_mut)]
                let mut output = crate::error::kms_invalid_state_error::Builder::default();
                let _ = response;
                output = crate::json_deser::kms_invalid_state_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::InvokeError::unhandled)?;
                output.build()
            }),
        },
        "KMSNotFoundException" => crate::error::InvokeError {
            meta: generic,
            kind: crate::error::InvokeErrorKind::KMSNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::kms_not_found_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::kms_not_found_exception(response.body().as_ref(), output)
                        .map_err(crate::error::InvokeError::unhandled)?;
                output.build()
            }),
        },
        "RequestTooLargeException" => crate::error::InvokeError {
            meta: generic,
            kind: crate::error::InvokeErrorKind::RequestTooLargeError({
                #[allow(unused_mut)]
                let mut output = crate::error::request_too_large_error::Builder::default();
                let _ = response;
                output = crate::json_deser::request_too_large_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::InvokeError::unhandled)?;
                output.build()
            }),
        },
        "ResourceConflictException" => crate::error::InvokeError {
            meta: generic,
            kind: crate::error::InvokeErrorKind::ResourceConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_conflict_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::InvokeError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::InvokeError {
            meta: generic,
            kind: crate::error::InvokeErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::InvokeError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotReadyException" => crate::error::InvokeError {
            meta: generic,
            kind: crate::error::InvokeErrorKind::ResourceNotReadyError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_ready_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_ready_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::InvokeError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::InvokeError {
            meta: generic,
            kind: crate::error::InvokeErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::InvokeError::unhandled)?;
                output.build()
            }),
        },
        "SubnetIPAddressLimitReachedException" => crate::error::InvokeError {
            meta: generic,
            kind: crate::error::InvokeErrorKind::SubnetIPAddressLimitReachedError({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::subnet_ip_address_limit_reached_error::Builder::default();
                let _ = response;
                output = crate::json_deser::subnet_ip_address_limit_reached_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::InvokeError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::InvokeError {
            meta: generic,
            kind: crate::error::InvokeErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::InvokeError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_invoke_retry_after_seconds(response.headers())
                        .map_err(|_| {
                            crate::error::InvokeError::unhandled(
                                "Failed to parse retryAfterSeconds from header `Retry-After",
                            )
                        })?,
                );
                output.build()
            }),
        },
        "UnsupportedMediaTypeException" => crate::error::InvokeError {
            meta: generic,
            kind: crate::error::InvokeErrorKind::UnsupportedMediaTypeError({
                #[allow(unused_mut)]
                let mut output = crate::error::unsupported_media_type_error::Builder::default();
                let _ = response;
                output = crate::json_deser::unsupported_media_type_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::InvokeError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::InvokeError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_invoke_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::InvokeOutput, crate::error::InvokeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::invoke_output::Builder::default();
        let _ = response;
        output = output.set_status_code(response.status().as_u16() as _);
        output = output.set_function_error(
            crate::http_serde::deser_header_invoke_function_error(response.headers()).map_err(
                |_| {
                    crate::error::InvokeError::unhandled(
                        "Failed to parse FunctionError from header `X-Amz-Function-Error",
                    )
                },
            )?,
        );
        output = output.set_log_result(
            crate::http_serde::deser_header_invoke_log_result(response.headers()).map_err(
                |_| {
                    crate::error::InvokeError::unhandled(
                        "Failed to parse LogResult from header `X-Amz-Log-Result",
                    )
                },
            )?,
        );
        output = output.set_payload(crate::http_serde::deser_payload_invoke_payload(
            response.body().as_ref(),
        )?);
        output = output.set_executed_version(
            crate::http_serde::deser_header_invoke_executed_version(response.headers()).map_err(
                |_| {
                    crate::error::InvokeError::unhandled(
                        "Failed to parse ExecutedVersion from header `X-Amz-Executed-Version",
                    )
                },
            )?,
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_invoke_async_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::InvokeAsyncOutput, crate::error::InvokeAsyncError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::InvokeAsyncError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::InvokeAsyncError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidRequestContentException" => crate::error::InvokeAsyncError {
            meta: generic,
            kind: crate::error::InvokeAsyncErrorKind::InvalidRequestContentError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_request_content_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_request_content_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::InvokeAsyncError::unhandled)?;
                output.build()
            }),
        },
        "InvalidRuntimeException" => crate::error::InvokeAsyncError {
            meta: generic,
            kind: crate::error::InvokeAsyncErrorKind::InvalidRuntimeError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_runtime_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::invalid_runtime_exception(response.body().as_ref(), output)
                        .map_err(crate::error::InvokeAsyncError::unhandled)?;
                output.build()
            }),
        },
        "ResourceConflictException" => crate::error::InvokeAsyncError {
            meta: generic,
            kind: crate::error::InvokeAsyncErrorKind::ResourceConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_conflict_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::InvokeAsyncError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::InvokeAsyncError {
            meta: generic,
            kind: crate::error::InvokeAsyncErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::InvokeAsyncError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::InvokeAsyncError {
            meta: generic,
            kind: crate::error::InvokeAsyncErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::InvokeAsyncError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::InvokeAsyncError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_invoke_async_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::InvokeAsyncOutput, crate::error::InvokeAsyncError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::invoke_async_output::Builder::default();
        let _ = response;
        output = output.set_status(response.status().as_u16() as _);
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_aliases_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListAliasesOutput, crate::error::ListAliasesError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListAliasesError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListAliasesError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::ListAliasesError {
            meta: generic,
            kind: crate::error::ListAliasesErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListAliasesError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::ListAliasesError {
            meta: generic,
            kind: crate::error::ListAliasesErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListAliasesError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::ListAliasesError {
            meta: generic,
            kind: crate::error::ListAliasesErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::ListAliasesError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::ListAliasesError {
            meta: generic,
            kind: crate::error::ListAliasesErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListAliasesError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_list_aliases_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::ListAliasesError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        _ => crate::error::ListAliasesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_aliases_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListAliasesOutput, crate::error::ListAliasesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_aliases_output::Builder::default();
        let _ = response;
        output = crate::json_deser::list_aliases_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::ListAliasesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_code_signing_configs_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListCodeSigningConfigsOutput, crate::error::ListCodeSigningConfigsError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListCodeSigningConfigsError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListCodeSigningConfigsError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::ListCodeSigningConfigsError {
            meta: generic,
            kind: crate::error::ListCodeSigningConfigsErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListCodeSigningConfigsError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::ListCodeSigningConfigsError {
            meta: generic,
            kind: crate::error::ListCodeSigningConfigsErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::ListCodeSigningConfigsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListCodeSigningConfigsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_code_signing_configs_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListCodeSigningConfigsOutput, crate::error::ListCodeSigningConfigsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_code_signing_configs_output::Builder::default();
        let _ = response;
        output = crate::json_deser::list_code_signing_configs_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListCodeSigningConfigsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_event_source_mappings_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListEventSourceMappingsOutput, crate::error::ListEventSourceMappingsError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListEventSourceMappingsError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListEventSourceMappingsError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::ListEventSourceMappingsError {
            meta: generic,
            kind: crate::error::ListEventSourceMappingsErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListEventSourceMappingsError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::ListEventSourceMappingsError {
            meta: generic,
            kind: crate::error::ListEventSourceMappingsErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListEventSourceMappingsError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::ListEventSourceMappingsError {
            meta: generic,
            kind: crate::error::ListEventSourceMappingsErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::ListEventSourceMappingsError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => {
            crate::error::ListEventSourceMappingsError {
                meta: generic,
                kind: crate::error::ListEventSourceMappingsErrorKind::TooManyRequestsError({
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_requests_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::too_many_requests_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListEventSourceMappingsError::unhandled)?;
                    output = output.set_retry_after_seconds(
                
                                        crate::http_serde::deser_header_list_event_source_mappings_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::ListEventSourceMappingsError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                        
            );
                    output.build()
                }),
            }
        }
        _ => crate::error::ListEventSourceMappingsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_event_source_mappings_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListEventSourceMappingsOutput, crate::error::ListEventSourceMappingsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_event_source_mappings_output::Builder::default();
        let _ = response;
        output = crate::json_deser::list_event_source_mappings_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListEventSourceMappingsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_function_event_invoke_configs_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::ListFunctionEventInvokeConfigsOutput,
    crate::error::ListFunctionEventInvokeConfigsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListFunctionEventInvokeConfigsError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListFunctionEventInvokeConfigsError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::ListFunctionEventInvokeConfigsError {
            meta: generic,
            kind: crate::error::ListFunctionEventInvokeConfigsErrorKind::InvalidParameterValueError(
                {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_parameter_value_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::invalid_parameter_value_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListFunctionEventInvokeConfigsError::unhandled)?;
                    output.build()
                },
            ),
        },
        "ResourceNotFoundException" => crate::error::ListFunctionEventInvokeConfigsError {
            meta: generic,
            kind: crate::error::ListFunctionEventInvokeConfigsErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListFunctionEventInvokeConfigsError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::ListFunctionEventInvokeConfigsError {
            meta: generic,
            kind: crate::error::ListFunctionEventInvokeConfigsErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::ListFunctionEventInvokeConfigsError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::ListFunctionEventInvokeConfigsError {
            meta: generic,
            kind: crate::error::ListFunctionEventInvokeConfigsErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListFunctionEventInvokeConfigsError::unhandled)?;
                output = output.set_retry_after_seconds(
                
                                        crate::http_serde::deser_header_list_function_event_invoke_configs_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::ListFunctionEventInvokeConfigsError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                        
            );
                output.build()
            }),
        },
        _ => crate::error::ListFunctionEventInvokeConfigsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_function_event_invoke_configs_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::ListFunctionEventInvokeConfigsOutput,
    crate::error::ListFunctionEventInvokeConfigsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_function_event_invoke_configs_output::Builder::default();
        let _ = response;
        output = crate::json_deser::list_function_event_invoke_configs_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListFunctionEventInvokeConfigsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_functions_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListFunctionsOutput, crate::error::ListFunctionsError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListFunctionsError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListFunctionsError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::ListFunctionsError {
            meta: generic,
            kind: crate::error::ListFunctionsErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListFunctionsError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::ListFunctionsError {
            meta: generic,
            kind: crate::error::ListFunctionsErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::ListFunctionsError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::ListFunctionsError {
            meta: generic,
            kind: crate::error::ListFunctionsErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListFunctionsError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_list_functions_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::ListFunctionsError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        _ => crate::error::ListFunctionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_functions_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListFunctionsOutput, crate::error::ListFunctionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_functions_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::list_functions_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::ListFunctionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_functions_by_code_signing_config_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::ListFunctionsByCodeSigningConfigOutput,
    crate::error::ListFunctionsByCodeSigningConfigError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListFunctionsByCodeSigningConfigError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListFunctionsByCodeSigningConfigError::unhandled(generic))
        }
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::ListFunctionsByCodeSigningConfigError {
            meta: generic,
            kind:
                crate::error::ListFunctionsByCodeSigningConfigErrorKind::InvalidParameterValueError(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_parameter_value_error::Builder::default();
                        let _ = response;
                        output = crate::json_deser::invalid_parameter_value_exception(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::ListFunctionsByCodeSigningConfigError::unhandled)?;
                        output.build()
                    },
                ),
        },
        "ResourceNotFoundException" => crate::error::ListFunctionsByCodeSigningConfigError {
            meta: generic,
            kind: crate::error::ListFunctionsByCodeSigningConfigErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListFunctionsByCodeSigningConfigError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::ListFunctionsByCodeSigningConfigError {
            meta: generic,
            kind: crate::error::ListFunctionsByCodeSigningConfigErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::ListFunctionsByCodeSigningConfigError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListFunctionsByCodeSigningConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_functions_by_code_signing_config_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::ListFunctionsByCodeSigningConfigOutput,
    crate::error::ListFunctionsByCodeSigningConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_functions_by_code_signing_config_output::Builder::default();
        let _ = response;
        output = crate::json_deser::list_functions_by_code_signing_config_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListFunctionsByCodeSigningConfigError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_layers_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListLayersOutput, crate::error::ListLayersError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListLayersError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListLayersError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::ListLayersError {
            meta: generic,
            kind: crate::error::ListLayersErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListLayersError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::ListLayersError {
            meta: generic,
            kind: crate::error::ListLayersErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::ListLayersError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::ListLayersError {
            meta: generic,
            kind: crate::error::ListLayersErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListLayersError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_list_layers_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::ListLayersError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        _ => crate::error::ListLayersError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_layers_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListLayersOutput, crate::error::ListLayersError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_layers_output::Builder::default();
        let _ = response;
        output = crate::json_deser::list_layers_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::ListLayersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_layer_versions_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListLayerVersionsOutput, crate::error::ListLayerVersionsError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListLayerVersionsError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListLayerVersionsError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::ListLayerVersionsError {
            meta: generic,
            kind: crate::error::ListLayerVersionsErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListLayerVersionsError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::ListLayerVersionsError {
            meta: generic,
            kind: crate::error::ListLayerVersionsErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListLayerVersionsError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::ListLayerVersionsError {
            meta: generic,
            kind: crate::error::ListLayerVersionsErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::ListLayerVersionsError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::ListLayerVersionsError {
            meta: generic,
            kind: crate::error::ListLayerVersionsErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListLayerVersionsError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_list_layer_versions_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::ListLayerVersionsError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        _ => crate::error::ListLayerVersionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_layer_versions_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListLayerVersionsOutput, crate::error::ListLayerVersionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_layer_versions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::list_layer_versions_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListLayerVersionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_provisioned_concurrency_configs_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::ListProvisionedConcurrencyConfigsOutput,
    crate::error::ListProvisionedConcurrencyConfigsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListProvisionedConcurrencyConfigsError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListProvisionedConcurrencyConfigsError::unhandled(generic))
        }
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::ListProvisionedConcurrencyConfigsError {
            meta: generic,
            kind:
                crate::error::ListProvisionedConcurrencyConfigsErrorKind::InvalidParameterValueError(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_parameter_value_error::Builder::default();
                        let _ = response;
                        output = crate::json_deser::invalid_parameter_value_exception(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::ListProvisionedConcurrencyConfigsError::unhandled)?;
                        output.build()
                    },
                ),
        },
        "ResourceNotFoundException" => crate::error::ListProvisionedConcurrencyConfigsError {
            meta: generic,
            kind: crate::error::ListProvisionedConcurrencyConfigsErrorKind::ResourceNotFoundError(
                {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::resource_not_found_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListProvisionedConcurrencyConfigsError::unhandled)?;
                    output.build()
                },
            ),
        },
        "ServiceException" => crate::error::ListProvisionedConcurrencyConfigsError {
            meta: generic,
            kind: crate::error::ListProvisionedConcurrencyConfigsErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::ListProvisionedConcurrencyConfigsError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::ListProvisionedConcurrencyConfigsError {
            meta: generic,
            kind: crate::error::ListProvisionedConcurrencyConfigsErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListProvisionedConcurrencyConfigsError::unhandled)?;
                output = output.set_retry_after_seconds(
                
                                        crate::http_serde::deser_header_list_provisioned_concurrency_configs_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::ListProvisionedConcurrencyConfigsError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                        
            );
                output.build()
            }),
        },
        _ => crate::error::ListProvisionedConcurrencyConfigsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_provisioned_concurrency_configs_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::ListProvisionedConcurrencyConfigsOutput,
    crate::error::ListProvisionedConcurrencyConfigsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_provisioned_concurrency_configs_output::Builder::default();
        let _ = response;
        output = crate::json_deser::list_provisioned_concurrency_configs_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListProvisionedConcurrencyConfigsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListTagsOutput, crate::error::ListTagsError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListTagsError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListTagsError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::ListTagsError {
            meta: generic,
            kind: crate::error::ListTagsErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListTagsError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::ListTagsError {
            meta: generic,
            kind: crate::error::ListTagsErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListTagsError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::ListTagsError {
            meta: generic,
            kind: crate::error::ListTagsErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::ListTagsError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::ListTagsError {
            meta: generic,
            kind: crate::error::ListTagsErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListTagsError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_list_tags_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::ListTagsError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        _ => crate::error::ListTagsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListTagsOutput, crate::error::ListTagsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_tags_output::Builder::default();
        let _ = response;
        output = crate::json_deser::list_tags_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::ListTagsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_versions_by_function_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListVersionsByFunctionOutput, crate::error::ListVersionsByFunctionError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListVersionsByFunctionError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListVersionsByFunctionError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::ListVersionsByFunctionError {
            meta: generic,
            kind: crate::error::ListVersionsByFunctionErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListVersionsByFunctionError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::ListVersionsByFunctionError {
            meta: generic,
            kind: crate::error::ListVersionsByFunctionErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListVersionsByFunctionError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::ListVersionsByFunctionError {
            meta: generic,
            kind: crate::error::ListVersionsByFunctionErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::ListVersionsByFunctionError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => {
            crate::error::ListVersionsByFunctionError {
                meta: generic,
                kind: crate::error::ListVersionsByFunctionErrorKind::TooManyRequestsError({
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_requests_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::too_many_requests_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListVersionsByFunctionError::unhandled)?;
                    output = output.set_retry_after_seconds(
                
                                        crate::http_serde::deser_header_list_versions_by_function_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::ListVersionsByFunctionError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                        
            );
                    output.build()
                }),
            }
        }
        _ => crate::error::ListVersionsByFunctionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_versions_by_function_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::ListVersionsByFunctionOutput, crate::error::ListVersionsByFunctionError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_versions_by_function_output::Builder::default();
        let _ = response;
        output = crate::json_deser::list_versions_by_function_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListVersionsByFunctionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_publish_layer_version_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PublishLayerVersionOutput, crate::error::PublishLayerVersionError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PublishLayerVersionError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PublishLayerVersionError::unhandled(generic)),
    };
    Err(match error_code {
        "CodeStorageExceededException" => crate::error::PublishLayerVersionError {
            meta: generic,
            kind: crate::error::PublishLayerVersionErrorKind::CodeStorageExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::code_storage_exceeded_error::Builder::default();
                let _ = response;
                output = crate::json_deser::code_storage_exceeded_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PublishLayerVersionError::unhandled)?;
                output.build()
            }),
        },
        "InvalidParameterValueException" => crate::error::PublishLayerVersionError {
            meta: generic,
            kind: crate::error::PublishLayerVersionErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PublishLayerVersionError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::PublishLayerVersionError {
            meta: generic,
            kind: crate::error::PublishLayerVersionErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PublishLayerVersionError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::PublishLayerVersionError {
            meta: generic,
            kind: crate::error::PublishLayerVersionErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PublishLayerVersionError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::PublishLayerVersionError {
            meta: generic,
            kind: crate::error::PublishLayerVersionErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PublishLayerVersionError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_publish_layer_version_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::PublishLayerVersionError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        _ => crate::error::PublishLayerVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_publish_layer_version_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PublishLayerVersionOutput, crate::error::PublishLayerVersionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::publish_layer_version_output::Builder::default();
        let _ = response;
        output = crate::json_deser::publish_layer_version_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PublishLayerVersionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_publish_version_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PublishVersionOutput, crate::error::PublishVersionError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PublishVersionError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PublishVersionError::unhandled(generic)),
    };
    Err(match error_code {
        "CodeStorageExceededException" => crate::error::PublishVersionError {
            meta: generic,
            kind: crate::error::PublishVersionErrorKind::CodeStorageExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::code_storage_exceeded_error::Builder::default();
                let _ = response;
                output = crate::json_deser::code_storage_exceeded_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PublishVersionError::unhandled)?;
                output.build()
            }),
        },
        "InvalidParameterValueException" => crate::error::PublishVersionError {
            meta: generic,
            kind: crate::error::PublishVersionErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PublishVersionError::unhandled)?;
                output.build()
            }),
        },
        "PreconditionFailedException" => crate::error::PublishVersionError {
            meta: generic,
            kind: crate::error::PublishVersionErrorKind::PreconditionFailedError({
                #[allow(unused_mut)]
                let mut output = crate::error::precondition_failed_error::Builder::default();
                let _ = response;
                output = crate::json_deser::precondition_failed_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PublishVersionError::unhandled)?;
                output.build()
            }),
        },
        "ResourceConflictException" => crate::error::PublishVersionError {
            meta: generic,
            kind: crate::error::PublishVersionErrorKind::ResourceConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_conflict_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PublishVersionError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::PublishVersionError {
            meta: generic,
            kind: crate::error::PublishVersionErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PublishVersionError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::PublishVersionError {
            meta: generic,
            kind: crate::error::PublishVersionErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PublishVersionError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::PublishVersionError {
            meta: generic,
            kind: crate::error::PublishVersionErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PublishVersionError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_publish_version_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::PublishVersionError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        _ => crate::error::PublishVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_publish_version_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PublishVersionOutput, crate::error::PublishVersionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::publish_version_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::publish_version_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::PublishVersionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_function_code_signing_config_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::PutFunctionCodeSigningConfigOutput,
    crate::error::PutFunctionCodeSigningConfigError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PutFunctionCodeSigningConfigError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::PutFunctionCodeSigningConfigError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "CodeSigningConfigNotFoundException" => crate::error::PutFunctionCodeSigningConfigError {
            meta: generic,
            kind:
                crate::error::PutFunctionCodeSigningConfigErrorKind::CodeSigningConfigNotFoundError(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::code_signing_config_not_found_error::Builder::default();
                        let _ = response;
                        output = crate::json_deser::code_signing_config_not_found_exception(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::PutFunctionCodeSigningConfigError::unhandled)?;
                        output.build()
                    },
                ),
        },
        "InvalidParameterValueException" => crate::error::PutFunctionCodeSigningConfigError {
            meta: generic,
            kind: crate::error::PutFunctionCodeSigningConfigErrorKind::InvalidParameterValueError(
                {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_parameter_value_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::invalid_parameter_value_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::PutFunctionCodeSigningConfigError::unhandled)?;
                    output.build()
                },
            ),
        },
        "ResourceConflictException" => crate::error::PutFunctionCodeSigningConfigError {
            meta: generic,
            kind: crate::error::PutFunctionCodeSigningConfigErrorKind::ResourceConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_conflict_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutFunctionCodeSigningConfigError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::PutFunctionCodeSigningConfigError {
            meta: generic,
            kind: crate::error::PutFunctionCodeSigningConfigErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutFunctionCodeSigningConfigError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::PutFunctionCodeSigningConfigError {
            meta: generic,
            kind: crate::error::PutFunctionCodeSigningConfigErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutFunctionCodeSigningConfigError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::PutFunctionCodeSigningConfigError {
            meta: generic,
            kind: crate::error::PutFunctionCodeSigningConfigErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutFunctionCodeSigningConfigError::unhandled)?;
                output = output.set_retry_after_seconds(
                
                                        crate::http_serde::deser_header_put_function_code_signing_config_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::PutFunctionCodeSigningConfigError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                        
            );
                output.build()
            }),
        },
        _ => crate::error::PutFunctionCodeSigningConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_function_code_signing_config_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::PutFunctionCodeSigningConfigOutput,
    crate::error::PutFunctionCodeSigningConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_function_code_signing_config_output::Builder::default();
        let _ = response;
        output = crate::json_deser::put_function_code_signing_config_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PutFunctionCodeSigningConfigError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_function_concurrency_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutFunctionConcurrencyOutput, crate::error::PutFunctionConcurrencyError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PutFunctionConcurrencyError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::PutFunctionConcurrencyError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::PutFunctionConcurrencyError {
            meta: generic,
            kind: crate::error::PutFunctionConcurrencyErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutFunctionConcurrencyError::unhandled)?;
                output.build()
            }),
        },
        "ResourceConflictException" => crate::error::PutFunctionConcurrencyError {
            meta: generic,
            kind: crate::error::PutFunctionConcurrencyErrorKind::ResourceConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_conflict_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutFunctionConcurrencyError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::PutFunctionConcurrencyError {
            meta: generic,
            kind: crate::error::PutFunctionConcurrencyErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutFunctionConcurrencyError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::PutFunctionConcurrencyError {
            meta: generic,
            kind: crate::error::PutFunctionConcurrencyErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutFunctionConcurrencyError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => {
            crate::error::PutFunctionConcurrencyError {
                meta: generic,
                kind: crate::error::PutFunctionConcurrencyErrorKind::TooManyRequestsError({
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_requests_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::too_many_requests_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::PutFunctionConcurrencyError::unhandled)?;
                    output = output.set_retry_after_seconds(
                
                                        crate::http_serde::deser_header_put_function_concurrency_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::PutFunctionConcurrencyError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                        
            );
                    output.build()
                }),
            }
        }
        _ => crate::error::PutFunctionConcurrencyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_function_concurrency_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::PutFunctionConcurrencyOutput, crate::error::PutFunctionConcurrencyError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_function_concurrency_output::Builder::default();
        let _ = response;
        output = crate::json_deser::put_function_concurrency_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PutFunctionConcurrencyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_function_event_invoke_config_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::PutFunctionEventInvokeConfigOutput,
    crate::error::PutFunctionEventInvokeConfigError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PutFunctionEventInvokeConfigError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::PutFunctionEventInvokeConfigError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::PutFunctionEventInvokeConfigError {
            meta: generic,
            kind: crate::error::PutFunctionEventInvokeConfigErrorKind::InvalidParameterValueError(
                {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_parameter_value_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::invalid_parameter_value_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::PutFunctionEventInvokeConfigError::unhandled)?;
                    output.build()
                },
            ),
        },
        "ResourceNotFoundException" => crate::error::PutFunctionEventInvokeConfigError {
            meta: generic,
            kind: crate::error::PutFunctionEventInvokeConfigErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutFunctionEventInvokeConfigError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::PutFunctionEventInvokeConfigError {
            meta: generic,
            kind: crate::error::PutFunctionEventInvokeConfigErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutFunctionEventInvokeConfigError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::PutFunctionEventInvokeConfigError {
            meta: generic,
            kind: crate::error::PutFunctionEventInvokeConfigErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutFunctionEventInvokeConfigError::unhandled)?;
                output = output.set_retry_after_seconds(
                
                                        crate::http_serde::deser_header_put_function_event_invoke_config_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::PutFunctionEventInvokeConfigError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                        
            );
                output.build()
            }),
        },
        _ => crate::error::PutFunctionEventInvokeConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_function_event_invoke_config_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::PutFunctionEventInvokeConfigOutput,
    crate::error::PutFunctionEventInvokeConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_function_event_invoke_config_output::Builder::default();
        let _ = response;
        output = crate::json_deser::put_function_event_invoke_config_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PutFunctionEventInvokeConfigError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_provisioned_concurrency_config_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::PutProvisionedConcurrencyConfigOutput,
    crate::error::PutProvisionedConcurrencyConfigError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PutProvisionedConcurrencyConfigError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutProvisionedConcurrencyConfigError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::PutProvisionedConcurrencyConfigError {
            meta: generic,
            kind:
                crate::error::PutProvisionedConcurrencyConfigErrorKind::InvalidParameterValueError(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_parameter_value_error::Builder::default();
                        let _ = response;
                        output = crate::json_deser::invalid_parameter_value_exception(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::PutProvisionedConcurrencyConfigError::unhandled)?;
                        output.build()
                    },
                ),
        },
        "ResourceConflictException" => crate::error::PutProvisionedConcurrencyConfigError {
            meta: generic,
            kind: crate::error::PutProvisionedConcurrencyConfigErrorKind::ResourceConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_conflict_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutProvisionedConcurrencyConfigError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::PutProvisionedConcurrencyConfigError {
            meta: generic,
            kind: crate::error::PutProvisionedConcurrencyConfigErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutProvisionedConcurrencyConfigError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::PutProvisionedConcurrencyConfigError {
            meta: generic,
            kind: crate::error::PutProvisionedConcurrencyConfigErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutProvisionedConcurrencyConfigError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::PutProvisionedConcurrencyConfigError {
            meta: generic,
            kind: crate::error::PutProvisionedConcurrencyConfigErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutProvisionedConcurrencyConfigError::unhandled)?;
                output = output.set_retry_after_seconds(
                
                                        crate::http_serde::deser_header_put_provisioned_concurrency_config_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::PutProvisionedConcurrencyConfigError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                        
            );
                output.build()
            }),
        },
        _ => crate::error::PutProvisionedConcurrencyConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_provisioned_concurrency_config_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::PutProvisionedConcurrencyConfigOutput,
    crate::error::PutProvisionedConcurrencyConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::put_provisioned_concurrency_config_output::Builder::default();
        let _ = response;
        output = crate::json_deser::put_provisioned_concurrency_config_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PutProvisionedConcurrencyConfigError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_layer_version_permission_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::RemoveLayerVersionPermissionOutput,
    crate::error::RemoveLayerVersionPermissionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::RemoveLayerVersionPermissionError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RemoveLayerVersionPermissionError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::RemoveLayerVersionPermissionError {
            meta: generic,
            kind: crate::error::RemoveLayerVersionPermissionErrorKind::InvalidParameterValueError(
                {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_parameter_value_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::invalid_parameter_value_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::RemoveLayerVersionPermissionError::unhandled)?;
                    output.build()
                },
            ),
        },
        "PreconditionFailedException" => crate::error::RemoveLayerVersionPermissionError {
            meta: generic,
            kind: crate::error::RemoveLayerVersionPermissionErrorKind::PreconditionFailedError({
                #[allow(unused_mut)]
                let mut output = crate::error::precondition_failed_error::Builder::default();
                let _ = response;
                output = crate::json_deser::precondition_failed_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RemoveLayerVersionPermissionError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::RemoveLayerVersionPermissionError {
            meta: generic,
            kind: crate::error::RemoveLayerVersionPermissionErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RemoveLayerVersionPermissionError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::RemoveLayerVersionPermissionError {
            meta: generic,
            kind: crate::error::RemoveLayerVersionPermissionErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::RemoveLayerVersionPermissionError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::RemoveLayerVersionPermissionError {
            meta: generic,
            kind: crate::error::RemoveLayerVersionPermissionErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RemoveLayerVersionPermissionError::unhandled)?;
                output = output.set_retry_after_seconds(
                
                                        crate::http_serde::deser_header_remove_layer_version_permission_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::RemoveLayerVersionPermissionError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                        
            );
                output.build()
            }),
        },
        _ => crate::error::RemoveLayerVersionPermissionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_layer_version_permission_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::RemoveLayerVersionPermissionOutput,
    crate::error::RemoveLayerVersionPermissionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::remove_layer_version_permission_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_permission_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::RemovePermissionOutput, crate::error::RemovePermissionError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::RemovePermissionError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::RemovePermissionError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::RemovePermissionError {
            meta: generic,
            kind: crate::error::RemovePermissionErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RemovePermissionError::unhandled)?;
                output.build()
            }),
        },
        "PreconditionFailedException" => crate::error::RemovePermissionError {
            meta: generic,
            kind: crate::error::RemovePermissionErrorKind::PreconditionFailedError({
                #[allow(unused_mut)]
                let mut output = crate::error::precondition_failed_error::Builder::default();
                let _ = response;
                output = crate::json_deser::precondition_failed_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RemovePermissionError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::RemovePermissionError {
            meta: generic,
            kind: crate::error::RemovePermissionErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RemovePermissionError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::RemovePermissionError {
            meta: generic,
            kind: crate::error::RemovePermissionErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::RemovePermissionError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::RemovePermissionError {
            meta: generic,
            kind: crate::error::RemovePermissionErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::RemovePermissionError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_remove_permission_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::RemovePermissionError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        _ => crate::error::RemovePermissionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_permission_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::RemovePermissionOutput, crate::error::RemovePermissionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::remove_permission_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::TagResourceError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::TagResourceError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::TagResourceError {
            meta: generic,
            kind: crate::error::TagResourceErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagResourceError::unhandled)?;
                output.build()
            }),
        },
        "ResourceConflictException" => crate::error::TagResourceError {
            meta: generic,
            kind: crate::error::TagResourceErrorKind::ResourceConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_conflict_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagResourceError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::TagResourceError {
            meta: generic,
            kind: crate::error::TagResourceErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagResourceError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::TagResourceError {
            meta: generic,
            kind: crate::error::TagResourceErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::TagResourceError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::TagResourceError {
            meta: generic,
            kind: crate::error::TagResourceErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagResourceError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_tag_resource_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::TagResourceError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        _ => crate::error::TagResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::tag_resource_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UntagResourceError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UntagResourceError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::UntagResourceError {
            meta: generic,
            kind: crate::error::UntagResourceErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagResourceError::unhandled)?;
                output.build()
            }),
        },
        "ResourceConflictException" => crate::error::UntagResourceError {
            meta: generic,
            kind: crate::error::UntagResourceErrorKind::ResourceConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_conflict_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagResourceError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::UntagResourceError {
            meta: generic,
            kind: crate::error::UntagResourceErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagResourceError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::UntagResourceError {
            meta: generic,
            kind: crate::error::UntagResourceErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UntagResourceError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::UntagResourceError {
            meta: generic,
            kind: crate::error::UntagResourceErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagResourceError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_untag_resource_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::UntagResourceError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        _ => crate::error::UntagResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::untag_resource_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_alias_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UpdateAliasOutput, crate::error::UpdateAliasError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateAliasError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateAliasError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::UpdateAliasError {
            meta: generic,
            kind: crate::error::UpdateAliasErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateAliasError::unhandled)?;
                output.build()
            }),
        },
        "PreconditionFailedException" => crate::error::UpdateAliasError {
            meta: generic,
            kind: crate::error::UpdateAliasErrorKind::PreconditionFailedError({
                #[allow(unused_mut)]
                let mut output = crate::error::precondition_failed_error::Builder::default();
                let _ = response;
                output = crate::json_deser::precondition_failed_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateAliasError::unhandled)?;
                output.build()
            }),
        },
        "ResourceConflictException" => crate::error::UpdateAliasError {
            meta: generic,
            kind: crate::error::UpdateAliasErrorKind::ResourceConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_conflict_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateAliasError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::UpdateAliasError {
            meta: generic,
            kind: crate::error::UpdateAliasErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateAliasError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::UpdateAliasError {
            meta: generic,
            kind: crate::error::UpdateAliasErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateAliasError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::UpdateAliasError {
            meta: generic,
            kind: crate::error::UpdateAliasErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateAliasError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_update_alias_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::UpdateAliasError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        _ => crate::error::UpdateAliasError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_alias_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UpdateAliasOutput, crate::error::UpdateAliasError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_alias_output::Builder::default();
        let _ = response;
        output = crate::json_deser::update_alias_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::UpdateAliasError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_code_signing_config_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UpdateCodeSigningConfigOutput, crate::error::UpdateCodeSigningConfigError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateCodeSigningConfigError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateCodeSigningConfigError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::UpdateCodeSigningConfigError {
            meta: generic,
            kind: crate::error::UpdateCodeSigningConfigErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateCodeSigningConfigError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::UpdateCodeSigningConfigError {
            meta: generic,
            kind: crate::error::UpdateCodeSigningConfigErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateCodeSigningConfigError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::UpdateCodeSigningConfigError {
            meta: generic,
            kind: crate::error::UpdateCodeSigningConfigErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateCodeSigningConfigError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateCodeSigningConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_code_signing_config_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UpdateCodeSigningConfigOutput, crate::error::UpdateCodeSigningConfigError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_code_signing_config_output::Builder::default();
        let _ = response;
        output = crate::json_deser::update_code_signing_config_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateCodeSigningConfigError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_event_source_mapping_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::UpdateEventSourceMappingOutput,
    crate::error::UpdateEventSourceMappingError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateEventSourceMappingError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateEventSourceMappingError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::UpdateEventSourceMappingError {
            meta: generic,
            kind: crate::error::UpdateEventSourceMappingErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateEventSourceMappingError::unhandled)?;
                output.build()
            }),
        },
        "ResourceConflictException" => crate::error::UpdateEventSourceMappingError {
            meta: generic,
            kind: crate::error::UpdateEventSourceMappingErrorKind::ResourceConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_conflict_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateEventSourceMappingError::unhandled)?;
                output.build()
            }),
        },
        "ResourceInUseException" => crate::error::UpdateEventSourceMappingError {
            meta: generic,
            kind: crate::error::UpdateEventSourceMappingErrorKind::ResourceInUseError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::resource_in_use_exception(response.body().as_ref(), output)
                        .map_err(crate::error::UpdateEventSourceMappingError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::UpdateEventSourceMappingError {
            meta: generic,
            kind: crate::error::UpdateEventSourceMappingErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateEventSourceMappingError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::UpdateEventSourceMappingError {
            meta: generic,
            kind: crate::error::UpdateEventSourceMappingErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateEventSourceMappingError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::UpdateEventSourceMappingError {
            meta: generic,
            kind: crate::error::UpdateEventSourceMappingErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateEventSourceMappingError::unhandled)?;
                output = output.set_retry_after_seconds(
                
                                        crate::http_serde::deser_header_update_event_source_mapping_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::UpdateEventSourceMappingError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                        
            );
                output.build()
            }),
        },
        _ => crate::error::UpdateEventSourceMappingError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_event_source_mapping_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::UpdateEventSourceMappingOutput,
    crate::error::UpdateEventSourceMappingError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_event_source_mapping_output::Builder::default();
        let _ = response;
        output = crate::json_deser::update_event_source_mapping_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateEventSourceMappingError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_function_code_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UpdateFunctionCodeOutput, crate::error::UpdateFunctionCodeError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateFunctionCodeError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateFunctionCodeError::unhandled(generic)),
    };
    Err(match error_code {
        "CodeSigningConfigNotFoundException" => crate::error::UpdateFunctionCodeError {
            meta: generic,
            kind: crate::error::UpdateFunctionCodeErrorKind::CodeSigningConfigNotFoundError({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::code_signing_config_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::code_signing_config_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateFunctionCodeError::unhandled)?;
                output.build()
            }),
        },
        "CodeStorageExceededException" => crate::error::UpdateFunctionCodeError {
            meta: generic,
            kind: crate::error::UpdateFunctionCodeErrorKind::CodeStorageExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::code_storage_exceeded_error::Builder::default();
                let _ = response;
                output = crate::json_deser::code_storage_exceeded_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateFunctionCodeError::unhandled)?;
                output.build()
            }),
        },
        "CodeVerificationFailedException" => crate::error::UpdateFunctionCodeError {
            meta: generic,
            kind: crate::error::UpdateFunctionCodeErrorKind::CodeVerificationFailedError({
                #[allow(unused_mut)]
                let mut output = crate::error::code_verification_failed_error::Builder::default();
                let _ = response;
                output = crate::json_deser::code_verification_failed_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateFunctionCodeError::unhandled)?;
                output.build()
            }),
        },
        "InvalidCodeSignatureException" => crate::error::UpdateFunctionCodeError {
            meta: generic,
            kind: crate::error::UpdateFunctionCodeErrorKind::InvalidCodeSignatureError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_code_signature_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_code_signature_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateFunctionCodeError::unhandled)?;
                output.build()
            }),
        },
        "InvalidParameterValueException" => crate::error::UpdateFunctionCodeError {
            meta: generic,
            kind: crate::error::UpdateFunctionCodeErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateFunctionCodeError::unhandled)?;
                output.build()
            }),
        },
        "PreconditionFailedException" => crate::error::UpdateFunctionCodeError {
            meta: generic,
            kind: crate::error::UpdateFunctionCodeErrorKind::PreconditionFailedError({
                #[allow(unused_mut)]
                let mut output = crate::error::precondition_failed_error::Builder::default();
                let _ = response;
                output = crate::json_deser::precondition_failed_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateFunctionCodeError::unhandled)?;
                output.build()
            }),
        },
        "ResourceConflictException" => crate::error::UpdateFunctionCodeError {
            meta: generic,
            kind: crate::error::UpdateFunctionCodeErrorKind::ResourceConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_conflict_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateFunctionCodeError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::UpdateFunctionCodeError {
            meta: generic,
            kind: crate::error::UpdateFunctionCodeErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateFunctionCodeError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::UpdateFunctionCodeError {
            meta: generic,
            kind: crate::error::UpdateFunctionCodeErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateFunctionCodeError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::UpdateFunctionCodeError {
            meta: generic,
            kind: crate::error::UpdateFunctionCodeErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateFunctionCodeError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_update_function_code_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::UpdateFunctionCodeError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        _ => crate::error::UpdateFunctionCodeError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_function_code_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<crate::output::UpdateFunctionCodeOutput, crate::error::UpdateFunctionCodeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_function_code_output::Builder::default();
        let _ = response;
        output = crate::json_deser::update_function_code_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateFunctionCodeError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_function_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::UpdateFunctionConfigurationOutput,
    crate::error::UpdateFunctionConfigurationError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateFunctionConfigurationError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateFunctionConfigurationError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "CodeSigningConfigNotFoundException" => crate::error::UpdateFunctionConfigurationError {
            meta: generic,
            kind:
                crate::error::UpdateFunctionConfigurationErrorKind::CodeSigningConfigNotFoundError(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::code_signing_config_not_found_error::Builder::default();
                        let _ = response;
                        output = crate::json_deser::code_signing_config_not_found_exception(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::UpdateFunctionConfigurationError::unhandled)?;
                        output.build()
                    },
                ),
        },
        "CodeVerificationFailedException" => crate::error::UpdateFunctionConfigurationError {
            meta: generic,
            kind: crate::error::UpdateFunctionConfigurationErrorKind::CodeVerificationFailedError(
                {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::code_verification_failed_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::code_verification_failed_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateFunctionConfigurationError::unhandled)?;
                    output.build()
                },
            ),
        },
        "InvalidCodeSignatureException" => crate::error::UpdateFunctionConfigurationError {
            meta: generic,
            kind: crate::error::UpdateFunctionConfigurationErrorKind::InvalidCodeSignatureError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_code_signature_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_code_signature_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateFunctionConfigurationError::unhandled)?;
                output.build()
            }),
        },
        "InvalidParameterValueException" => crate::error::UpdateFunctionConfigurationError {
            meta: generic,
            kind: crate::error::UpdateFunctionConfigurationErrorKind::InvalidParameterValueError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_parameter_value_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_parameter_value_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateFunctionConfigurationError::unhandled)?;
                output.build()
            }),
        },
        "PreconditionFailedException" => crate::error::UpdateFunctionConfigurationError {
            meta: generic,
            kind: crate::error::UpdateFunctionConfigurationErrorKind::PreconditionFailedError({
                #[allow(unused_mut)]
                let mut output = crate::error::precondition_failed_error::Builder::default();
                let _ = response;
                output = crate::json_deser::precondition_failed_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateFunctionConfigurationError::unhandled)?;
                output.build()
            }),
        },
        "ResourceConflictException" => crate::error::UpdateFunctionConfigurationError {
            meta: generic,
            kind: crate::error::UpdateFunctionConfigurationErrorKind::ResourceConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_conflict_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateFunctionConfigurationError::unhandled)?;
                output.build()
            }),
        },
        "ResourceNotFoundException" => crate::error::UpdateFunctionConfigurationError {
            meta: generic,
            kind: crate::error::UpdateFunctionConfigurationErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateFunctionConfigurationError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::UpdateFunctionConfigurationError {
            meta: generic,
            kind: crate::error::UpdateFunctionConfigurationErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateFunctionConfigurationError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::UpdateFunctionConfigurationError {
            meta: generic,
            kind: crate::error::UpdateFunctionConfigurationErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateFunctionConfigurationError::unhandled)?;
                output = output.set_retry_after_seconds(
                
                                        crate::http_serde::deser_header_update_function_configuration_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::UpdateFunctionConfigurationError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                        
            );
                output.build()
            }),
        },
        _ => crate::error::UpdateFunctionConfigurationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_function_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::UpdateFunctionConfigurationOutput,
    crate::error::UpdateFunctionConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_function_configuration_output::Builder::default();
        let _ = response;
        output = crate::json_deser::update_function_configuration_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateFunctionConfigurationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_function_event_invoke_config_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::UpdateFunctionEventInvokeConfigOutput,
    crate::error::UpdateFunctionEventInvokeConfigError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateFunctionEventInvokeConfigError::unhandled)?;

    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateFunctionEventInvokeConfigError::unhandled(generic)),
    };
    Err(match error_code {
        "InvalidParameterValueException" => crate::error::UpdateFunctionEventInvokeConfigError {
            meta: generic,
            kind:
                crate::error::UpdateFunctionEventInvokeConfigErrorKind::InvalidParameterValueError(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_parameter_value_error::Builder::default();
                        let _ = response;
                        output = crate::json_deser::invalid_parameter_value_exception(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::UpdateFunctionEventInvokeConfigError::unhandled)?;
                        output.build()
                    },
                ),
        },
        "ResourceNotFoundException" => crate::error::UpdateFunctionEventInvokeConfigError {
            meta: generic,
            kind: crate::error::UpdateFunctionEventInvokeConfigErrorKind::ResourceNotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::resource_not_found_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateFunctionEventInvokeConfigError::unhandled)?;
                output.build()
            }),
        },
        "ServiceException" => crate::error::UpdateFunctionEventInvokeConfigError {
            meta: generic,
            kind: crate::error::UpdateFunctionEventInvokeConfigErrorKind::ServiceError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateFunctionEventInvokeConfigError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::UpdateFunctionEventInvokeConfigError {
            meta: generic,
            kind: crate::error::UpdateFunctionEventInvokeConfigErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateFunctionEventInvokeConfigError::unhandled)?;
                output = output.set_retry_after_seconds(
                
                                        crate::http_serde::deser_header_update_function_event_invoke_config_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::UpdateFunctionEventInvokeConfigError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                        
            );
                output.build()
            }),
        },
        _ => crate::error::UpdateFunctionEventInvokeConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_function_event_invoke_config_response(
    response: &http::Response<bytes::Bytes>,
) -> Result<
    crate::output::UpdateFunctionEventInvokeConfigOutput,
    crate::error::UpdateFunctionEventInvokeConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::update_function_event_invoke_config_output::Builder::default();
        let _ = response;
        output = crate::json_deser::update_function_event_invoke_config_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateFunctionEventInvokeConfigError::unhandled)?;
        output.build()
    })
}
