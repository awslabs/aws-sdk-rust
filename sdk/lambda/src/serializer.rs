// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AddLayerVersionPermissionInputBody<'a> {
    /// <p>An identifier that distinguishes the policy from others on the same layer version.</p>
    pub statement_id: &'a std::option::Option<std::string::String>,
    /// <p>The API action that grants access to the layer. For example, <code>lambda:GetLayerVersion</code>.</p>
    pub action: &'a std::option::Option<std::string::String>,
    /// <p>An account ID, or <code>*</code> to grant permission to all AWS accounts.</p>
    pub principal: &'a std::option::Option<std::string::String>,
    /// <p>With the principal set to <code>*</code>, grant permission to all accounts in the specified
    /// organization.</p>
    pub organization_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for AddLayerVersionPermissionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AddLayerVersionPermissionInputBody");
        formatter.field("statement_id", &self.statement_id);
        formatter.field("action", &self.action);
        formatter.field("principal", &self.principal);
        formatter.field("organization_id", &self.organization_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AddPermissionInputBody<'a> {
    /// <p>A statement identifier that differentiates the statement from others in the same policy.</p>
    pub statement_id: &'a std::option::Option<std::string::String>,
    /// <p>The action that the principal can use on the function. For example, <code>lambda:InvokeFunction</code> or
    /// <code>lambda:GetFunction</code>.</p>
    pub action: &'a std::option::Option<std::string::String>,
    /// <p>The AWS service or account that invokes the function. If you specify a service, use <code>SourceArn</code> or
    /// <code>SourceAccount</code> to limit who can invoke the function through that service.</p>
    pub principal: &'a std::option::Option<std::string::String>,
    /// <p>For AWS services, the ARN of the AWS resource that invokes the function. For example, an Amazon S3 bucket or
    /// Amazon SNS topic.</p>
    pub source_arn: &'a std::option::Option<std::string::String>,
    /// <p>For Amazon S3, the ID of the account that owns the resource. Use this together with <code>SourceArn</code> to
    /// ensure that the resource is owned by the specified account. It is possible for an Amazon S3 bucket to be deleted
    /// by its owner and recreated by another account.</p>
    pub source_account: &'a std::option::Option<std::string::String>,
    /// <p>For Alexa Smart Home functions, a token that must be supplied by the invoker.</p>
    pub event_source_token: &'a std::option::Option<std::string::String>,
    /// <p>Only update the policy if the revision ID matches the ID that's specified. Use this option to avoid modifying a
    /// policy that has changed since you last read it.</p>
    pub revision_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for AddPermissionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AddPermissionInputBody");
        formatter.field("statement_id", &self.statement_id);
        formatter.field("action", &self.action);
        formatter.field("principal", &self.principal);
        formatter.field("source_arn", &self.source_arn);
        formatter.field("source_account", &self.source_account);
        formatter.field("event_source_token", &self.event_source_token);
        formatter.field("revision_id", &self.revision_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateAliasInputBody<'a> {
    /// <p>The name of the alias.</p>
    pub name: &'a std::option::Option<std::string::String>,
    /// <p>The function version that the alias invokes.</p>
    pub function_version: &'a std::option::Option<std::string::String>,
    /// <p>A description of the alias.</p>
    pub description: &'a std::option::Option<std::string::String>,
    /// <p>The <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html#configuring-alias-routing">routing
    /// configuration</a> of the alias.</p>
    pub routing_config: &'a std::option::Option<crate::model::AliasRoutingConfiguration>,
}
impl<'a> std::fmt::Debug for CreateAliasInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateAliasInputBody");
        formatter.field("name", &self.name);
        formatter.field("function_version", &self.function_version);
        formatter.field("description", &self.description);
        formatter.field("routing_config", &self.routing_config);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateCodeSigningConfigInputBody<'a> {
    /// <p>Descriptive name for this code signing configuration.</p>
    pub description: &'a std::option::Option<std::string::String>,
    /// <p>Signing profiles for this code signing configuration.</p>
    pub allowed_publishers: &'a std::option::Option<crate::model::AllowedPublishers>,
    /// <p>The code signing policies define the actions to take if the validation checks fail. </p>
    pub code_signing_policies: &'a std::option::Option<crate::model::CodeSigningPolicies>,
}
impl<'a> std::fmt::Debug for CreateCodeSigningConfigInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateCodeSigningConfigInputBody");
        formatter.field("description", &self.description);
        formatter.field("allowed_publishers", &self.allowed_publishers);
        formatter.field("code_signing_policies", &self.code_signing_policies);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateEventSourceMappingInputBody<'a> {
    /// <p>The Amazon Resource Name (ARN) of the event source.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>Amazon Kinesis</b> - The ARN of the data stream or a stream consumer.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Amazon DynamoDB Streams</b> - The ARN of the stream.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Amazon Simple Queue Service</b> - The ARN of the queue.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Amazon Managed Streaming for Apache Kafka</b> - The ARN of the cluster.</p>
    /// </li>
    /// </ul>
    pub event_source_arn: &'a std::option::Option<std::string::String>,
    /// <p>The name of the Lambda function.</p>
    /// <p class="title">
    /// <b>Name formats</b>
    /// </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>Function name</b> - <code>MyFunction</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Version or Alias ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction:PROD</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Partial ARN</b> - <code>123456789012:function:MyFunction</code>.</p>
    /// </li>
    /// </ul>
    /// <p>The length constraint applies only to the full ARN. If you specify only the function name, it's limited to 64
    /// characters in length.</p>
    pub function_name: &'a std::option::Option<std::string::String>,
    /// <p>If true, the event source mapping is active. Set to false to pause polling and invocation.</p>
    pub enabled: &'a std::option::Option<bool>,
    /// <p>The maximum number of items to retrieve in a single batch.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>Amazon Kinesis</b> - Default 100. Max 10,000.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Amazon DynamoDB Streams</b> - Default 100. Max 1,000.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Amazon Simple Queue Service</b> - Default 10. For standard queues the max is 10,000. For FIFO queues the max is 10.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Amazon Managed Streaming for Apache Kafka</b> - Default 100. Max 10,000.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Self-Managed Apache Kafka</b> - Default 100. Max 10,000.</p>
    /// </li>
    /// </ul>
    pub batch_size: &'a std::option::Option<i32>,
    /// <p>(Streams and SQS standard queues) The maximum amount of time to gather records before invoking the function, in seconds.</p>
    pub maximum_batching_window_in_seconds: &'a std::option::Option<i32>,
    /// <p>(Streams) The number of batches to process from each shard concurrently.</p>
    pub parallelization_factor: &'a std::option::Option<i32>,
    /// <p>The position in a stream from which to start reading. Required for Amazon Kinesis, Amazon DynamoDB, and Amazon MSK Streams
    /// sources. <code>AT_TIMESTAMP</code> is only supported for Amazon Kinesis streams.</p>
    pub starting_position: &'a std::option::Option<crate::model::EventSourcePosition>,
    /// <p>With <code>StartingPosition</code> set to <code>AT_TIMESTAMP</code>, the time from which to start
    /// reading.</p>
    pub starting_position_timestamp: &'a std::option::Option<smithy_types::Instant>,
    /// <p>(Streams) An Amazon SQS queue or Amazon SNS topic destination for discarded records.</p>
    pub destination_config: &'a std::option::Option<crate::model::DestinationConfig>,
    /// <p>(Streams) Discard records older than the specified age. The default value is infinite (-1).</p>
    pub maximum_record_age_in_seconds: &'a std::option::Option<i32>,
    /// <p>(Streams) If the function returns an error, split the batch in two and retry.</p>
    pub bisect_batch_on_function_error: &'a std::option::Option<bool>,
    /// <p>(Streams) Discard records after the specified number of retries. The default value is infinite (-1). When set to infinite (-1), failed records will be retried until the record expires.</p>
    pub maximum_retry_attempts: &'a std::option::Option<i32>,
    /// <p>(Streams) The duration in seconds of a processing window. The range is between 1 second up to 900 seconds.</p>
    pub tumbling_window_in_seconds: &'a std::option::Option<i32>,
    /// <p>The name of the Kafka topic.</p>
    pub topics: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>
    /// (MQ) The name of the Amazon MQ broker destination queue to consume.
    /// </p>
    pub queues: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>An array of the authentication protocol, or the VPC components to secure your event source.</p>
    pub source_access_configurations:
        &'a std::option::Option<std::vec::Vec<crate::model::SourceAccessConfiguration>>,
    /// <p>The Self-Managed Apache Kafka cluster to send records.</p>
    pub self_managed_event_source: &'a std::option::Option<crate::model::SelfManagedEventSource>,
    /// <p>(Streams) A list of current response type enums applied to the event source mapping.</p>
    pub function_response_types:
        &'a std::option::Option<std::vec::Vec<crate::model::FunctionResponseType>>,
}
impl<'a> std::fmt::Debug for CreateEventSourceMappingInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateEventSourceMappingInputBody");
        formatter.field("event_source_arn", &self.event_source_arn);
        formatter.field("function_name", &self.function_name);
        formatter.field("enabled", &self.enabled);
        formatter.field("batch_size", &self.batch_size);
        formatter.field(
            "maximum_batching_window_in_seconds",
            &self.maximum_batching_window_in_seconds,
        );
        formatter.field("parallelization_factor", &self.parallelization_factor);
        formatter.field("starting_position", &self.starting_position);
        formatter.field(
            "starting_position_timestamp",
            &self.starting_position_timestamp,
        );
        formatter.field("destination_config", &self.destination_config);
        formatter.field(
            "maximum_record_age_in_seconds",
            &self.maximum_record_age_in_seconds,
        );
        formatter.field(
            "bisect_batch_on_function_error",
            &self.bisect_batch_on_function_error,
        );
        formatter.field("maximum_retry_attempts", &self.maximum_retry_attempts);
        formatter.field(
            "tumbling_window_in_seconds",
            &self.tumbling_window_in_seconds,
        );
        formatter.field("topics", &self.topics);
        formatter.field("queues", &self.queues);
        formatter.field(
            "source_access_configurations",
            &self.source_access_configurations,
        );
        formatter.field("self_managed_event_source", &self.self_managed_event_source);
        formatter.field("function_response_types", &self.function_response_types);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateFunctionInputBody<'a> {
    /// <p>The name of the Lambda function.</p>
    /// <p class="title">
    /// <b>Name formats</b>
    /// </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>Function name</b> - <code>my-function</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
    /// </li>
    /// </ul>
    /// <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    /// characters in length.</p>
    pub function_name: &'a std::option::Option<std::string::String>,
    /// <p>The identifier of the function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html">runtime</a>.</p>
    pub runtime: &'a std::option::Option<crate::model::Runtime>,
    /// <p>The Amazon Resource Name (ARN) of the function's execution role.</p>
    pub role: &'a std::option::Option<std::string::String>,
    /// <p>The name of the method within your code that Lambda calls to execute your function. The format includes the
    /// file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information,
    /// see <a href="https://docs.aws.amazon.com/lambda/latest/dg/programming-model-v2.html">Programming Model</a>.</p>
    pub handler: &'a std::option::Option<std::string::String>,
    /// <p>The code for the function.</p>
    pub code: &'a std::option::Option<crate::model::FunctionCode>,
    /// <p>A description of the function.</p>
    pub description: &'a std::option::Option<std::string::String>,
    /// <p>The amount of time that Lambda allows a function to run before stopping it. The default is 3 seconds. The
    /// maximum allowed value is 900 seconds.</p>
    pub timeout: &'a std::option::Option<i32>,
    /// <p>The amount of memory available to the function at runtime. Increasing the function's memory also increases its CPU
    /// allocation. The default value is 128 MB. The value can be any multiple of 1 MB.</p>
    pub memory_size: &'a std::option::Option<i32>,
    /// <p>Set to true to publish the first version of the function during creation.</p>
    pub publish: &'a bool,
    /// <p>For network connectivity to AWS resources in a VPC, specify a list of security groups and subnets in the VPC.
    /// When you connect a function to a VPC, it can only access resources and the internet through that VPC. For more
    /// information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html">VPC Settings</a>.</p>
    pub vpc_config: &'a std::option::Option<crate::model::VpcConfig>,
    /// <p>The type of deployment package. Set to <code>Image</code> for container image and set <code>Zip</code> for ZIP archive.</p>
    pub package_type: &'a std::option::Option<crate::model::PackageType>,
    /// <p>A dead letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events
    /// when they fail processing. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#dlq">Dead Letter Queues</a>.</p>
    pub dead_letter_config: &'a std::option::Option<crate::model::DeadLetterConfig>,
    /// <p>Environment variables that are accessible from function code during execution.</p>
    pub environment: &'a std::option::Option<crate::model::Environment>,
    /// <p>The ARN of the AWS Key Management Service (AWS KMS) key that's used to encrypt your function's environment
    /// variables. If it's not provided, AWS Lambda uses a default service key.</p>
    pub kms_key_arn: &'a std::option::Option<std::string::String>,
    /// <p>Set <code>Mode</code> to <code>Active</code> to sample and trace a subset of incoming requests with AWS
    /// X-Ray.</p>
    pub tracing_config: &'a std::option::Option<crate::model::TracingConfig>,
    /// <p>A list of <a href="https://docs.aws.amazon.com/lambda/latest/dg/tagging.html">tags</a> to apply to the
    /// function.</p>
    pub tags: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::string::String>,
    >,
    /// <p>A list of <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">function layers</a>
    /// to add to the function's execution environment. Specify each layer by its ARN, including the version.</p>
    pub layers: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Connection settings for an Amazon EFS file system.</p>
    pub file_system_configs: &'a std::option::Option<std::vec::Vec<crate::model::FileSystemConfig>>,
    /// <p>
    /// <a href="https://docs.aws.amazon.com/lambda/latest/dg/images-parms.html">Container image configuration
    /// values</a> that override the values in the container image Dockerfile.</p>
    pub image_config: &'a std::option::Option<crate::model::ImageConfig>,
    /// <p>To enable code signing for this function, specify the ARN of a code-signing configuration. A code-signing configuration
    /// includes a set of signing profiles, which define the trusted publishers for this function.</p>
    pub code_signing_config_arn: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for CreateFunctionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateFunctionInputBody");
        formatter.field("function_name", &self.function_name);
        formatter.field("runtime", &self.runtime);
        formatter.field("role", &self.role);
        formatter.field("handler", &self.handler);
        formatter.field("code", &self.code);
        formatter.field("description", &self.description);
        formatter.field("timeout", &self.timeout);
        formatter.field("memory_size", &self.memory_size);
        formatter.field("publish", &self.publish);
        formatter.field("vpc_config", &self.vpc_config);
        formatter.field("package_type", &self.package_type);
        formatter.field("dead_letter_config", &self.dead_letter_config);
        formatter.field("environment", &self.environment);
        formatter.field("kms_key_arn", &self.kms_key_arn);
        formatter.field("tracing_config", &self.tracing_config);
        formatter.field("tags", &self.tags);
        formatter.field("layers", &self.layers);
        formatter.field("file_system_configs", &self.file_system_configs);
        formatter.field("image_config", &self.image_config);
        formatter.field("code_signing_config_arn", &self.code_signing_config_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PublishLayerVersionInputBody<'a> {
    /// <p>The description of the version.</p>
    pub description: &'a std::option::Option<std::string::String>,
    /// <p>The function layer archive.</p>
    pub content: &'a std::option::Option<crate::model::LayerVersionContentInput>,
    /// <p>A list of compatible <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html">function
    /// runtimes</a>. Used for filtering with <a>ListLayers</a> and <a>ListLayerVersions</a>.</p>
    pub compatible_runtimes: &'a std::option::Option<std::vec::Vec<crate::model::Runtime>>,
    /// <p>The layer's software license. It can be any of the following:</p>
    /// <ul>
    /// <li>
    /// <p>An <a href="https://spdx.org/licenses/">SPDX license identifier</a>. For example,
    /// <code>MIT</code>.</p>
    /// </li>
    /// <li>
    /// <p>The URL of a license hosted on the internet. For example,
    /// <code>https://opensource.org/licenses/MIT</code>.</p>
    /// </li>
    /// <li>
    /// <p>The full text of the license.</p>
    /// </li>
    /// </ul>
    pub license_info: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for PublishLayerVersionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PublishLayerVersionInputBody");
        formatter.field("description", &self.description);
        formatter.field("content", &self.content);
        formatter.field("compatible_runtimes", &self.compatible_runtimes);
        formatter.field("license_info", &self.license_info);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PublishVersionInputBody<'a> {
    /// <p>Only publish a version if the hash value matches the value that's specified. Use this option to avoid
    /// publishing a version if the function code has changed since you last updated it. You can get the hash for the
    /// version that you uploaded from the output of <a>UpdateFunctionCode</a>.</p>
    pub code_sha256: &'a std::option::Option<std::string::String>,
    /// <p>A description for the version to override the description in the function configuration.</p>
    pub description: &'a std::option::Option<std::string::String>,
    /// <p>Only update the function if the revision ID matches the ID that's specified. Use this option to avoid
    /// publishing a version if the function configuration has changed since you last updated it.</p>
    pub revision_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for PublishVersionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PublishVersionInputBody");
        formatter.field("code_sha256", &self.code_sha256);
        formatter.field("description", &self.description);
        formatter.field("revision_id", &self.revision_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutFunctionCodeSigningConfigInputBody<'a> {
    /// <p>The The Amazon Resource Name (ARN) of the code signing configuration.</p>
    pub code_signing_config_arn: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for PutFunctionCodeSigningConfigInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutFunctionCodeSigningConfigInputBody");
        formatter.field("code_signing_config_arn", &self.code_signing_config_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutFunctionConcurrencyInputBody<'a> {
    /// <p>The number of simultaneous executions to reserve for the function.</p>
    pub reserved_concurrent_executions: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for PutFunctionConcurrencyInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutFunctionConcurrencyInputBody");
        formatter.field(
            "reserved_concurrent_executions",
            &self.reserved_concurrent_executions,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutFunctionEventInvokeConfigInputBody<'a> {
    /// <p>The maximum number of times to retry when the function returns an error.</p>
    pub maximum_retry_attempts: &'a std::option::Option<i32>,
    /// <p>The maximum age of a request that Lambda sends to a function for processing.</p>
    pub maximum_event_age_in_seconds: &'a std::option::Option<i32>,
    /// <p>A destination for events after they have been sent to a function for processing.</p>
    /// <p class="title">
    /// <b>Destinations</b>
    /// </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>Function</b> - The Amazon Resource Name (ARN) of a Lambda function.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Queue</b> - The ARN of an SQS queue.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Topic</b> - The ARN of an SNS topic.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Event Bus</b> - The ARN of an Amazon EventBridge event bus.</p>
    /// </li>
    /// </ul>
    pub destination_config: &'a std::option::Option<crate::model::DestinationConfig>,
}
impl<'a> std::fmt::Debug for PutFunctionEventInvokeConfigInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutFunctionEventInvokeConfigInputBody");
        formatter.field("maximum_retry_attempts", &self.maximum_retry_attempts);
        formatter.field(
            "maximum_event_age_in_seconds",
            &self.maximum_event_age_in_seconds,
        );
        formatter.field("destination_config", &self.destination_config);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutProvisionedConcurrencyConfigInputBody<'a> {
    /// <p>The amount of provisioned concurrency to allocate for the version or alias.</p>
    pub provisioned_concurrent_executions: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for PutProvisionedConcurrencyConfigInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutProvisionedConcurrencyConfigInputBody");
        formatter.field(
            "provisioned_concurrent_executions",
            &self.provisioned_concurrent_executions,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagResourceInputBody<'a> {
    /// <p>A list of tags to apply to the function.</p>
    pub tags: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::string::String>,
    >,
}
impl<'a> std::fmt::Debug for TagResourceInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagResourceInputBody");
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateAliasInputBody<'a> {
    /// <p>The function version that the alias invokes.</p>
    pub function_version: &'a std::option::Option<std::string::String>,
    /// <p>A description of the alias.</p>
    pub description: &'a std::option::Option<std::string::String>,
    /// <p>The <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html#configuring-alias-routing">routing
    /// configuration</a> of the alias.</p>
    pub routing_config: &'a std::option::Option<crate::model::AliasRoutingConfiguration>,
    /// <p>Only update the alias if the revision ID matches the ID that's specified. Use this option to avoid modifying
    /// an alias that has changed since you last read it.</p>
    pub revision_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for UpdateAliasInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateAliasInputBody");
        formatter.field("function_version", &self.function_version);
        formatter.field("description", &self.description);
        formatter.field("routing_config", &self.routing_config);
        formatter.field("revision_id", &self.revision_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateCodeSigningConfigInputBody<'a> {
    /// <p>Descriptive name for this code signing configuration.</p>
    pub description: &'a std::option::Option<std::string::String>,
    /// <p>Signing profiles for this code signing configuration.</p>
    pub allowed_publishers: &'a std::option::Option<crate::model::AllowedPublishers>,
    /// <p>The code signing policy.</p>
    pub code_signing_policies: &'a std::option::Option<crate::model::CodeSigningPolicies>,
}
impl<'a> std::fmt::Debug for UpdateCodeSigningConfigInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateCodeSigningConfigInputBody");
        formatter.field("description", &self.description);
        formatter.field("allowed_publishers", &self.allowed_publishers);
        formatter.field("code_signing_policies", &self.code_signing_policies);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateEventSourceMappingInputBody<'a> {
    /// <p>The name of the Lambda function.</p>
    /// <p class="title">
    /// <b>Name formats</b>
    /// </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>Function name</b> - <code>MyFunction</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Version or Alias ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction:PROD</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Partial ARN</b> - <code>123456789012:function:MyFunction</code>.</p>
    /// </li>
    /// </ul>
    /// <p>The length constraint applies only to the full ARN. If you specify only the function name, it's limited to 64
    /// characters in length.</p>
    pub function_name: &'a std::option::Option<std::string::String>,
    /// <p>If true, the event source mapping is active. Set to false to pause polling and invocation.</p>
    pub enabled: &'a std::option::Option<bool>,
    /// <p>The maximum number of items to retrieve in a single batch.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>Amazon Kinesis</b> - Default 100. Max 10,000.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Amazon DynamoDB Streams</b> - Default 100. Max 1,000.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Amazon Simple Queue Service</b> - Default 10. For standard queues the max is 10,000. For FIFO queues the max is 10.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Amazon Managed Streaming for Apache Kafka</b> - Default 100. Max 10,000.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Self-Managed Apache Kafka</b> - Default 100. Max 10,000.</p>
    /// </li>
    /// </ul>
    pub batch_size: &'a std::option::Option<i32>,
    /// <p>(Streams and SQS standard queues) The maximum amount of time to gather records before invoking the function, in seconds.</p>
    pub maximum_batching_window_in_seconds: &'a std::option::Option<i32>,
    /// <p>(Streams) An Amazon SQS queue or Amazon SNS topic destination for discarded records.</p>
    pub destination_config: &'a std::option::Option<crate::model::DestinationConfig>,
    /// <p>(Streams) Discard records older than the specified age. The default value is infinite (-1).</p>
    pub maximum_record_age_in_seconds: &'a std::option::Option<i32>,
    /// <p>(Streams) If the function returns an error, split the batch in two and retry.</p>
    pub bisect_batch_on_function_error: &'a std::option::Option<bool>,
    /// <p>(Streams) Discard records after the specified number of retries. The default value is infinite (-1). When set to infinite (-1), failed records will be retried until the record expires.</p>
    pub maximum_retry_attempts: &'a std::option::Option<i32>,
    /// <p>(Streams) The number of batches to process from each shard concurrently.</p>
    pub parallelization_factor: &'a std::option::Option<i32>,
    /// <p>An array of the authentication protocol, or the VPC components to secure your event source.</p>
    pub source_access_configurations:
        &'a std::option::Option<std::vec::Vec<crate::model::SourceAccessConfiguration>>,
    /// <p>(Streams) The duration in seconds of a processing window. The range is between 1 second up to 900 seconds.</p>
    pub tumbling_window_in_seconds: &'a std::option::Option<i32>,
    /// <p>(Streams) A list of current response type enums applied to the event source mapping.</p>
    pub function_response_types:
        &'a std::option::Option<std::vec::Vec<crate::model::FunctionResponseType>>,
}
impl<'a> std::fmt::Debug for UpdateEventSourceMappingInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateEventSourceMappingInputBody");
        formatter.field("function_name", &self.function_name);
        formatter.field("enabled", &self.enabled);
        formatter.field("batch_size", &self.batch_size);
        formatter.field(
            "maximum_batching_window_in_seconds",
            &self.maximum_batching_window_in_seconds,
        );
        formatter.field("destination_config", &self.destination_config);
        formatter.field(
            "maximum_record_age_in_seconds",
            &self.maximum_record_age_in_seconds,
        );
        formatter.field(
            "bisect_batch_on_function_error",
            &self.bisect_batch_on_function_error,
        );
        formatter.field("maximum_retry_attempts", &self.maximum_retry_attempts);
        formatter.field("parallelization_factor", &self.parallelization_factor);
        formatter.field(
            "source_access_configurations",
            &self.source_access_configurations,
        );
        formatter.field(
            "tumbling_window_in_seconds",
            &self.tumbling_window_in_seconds,
        );
        formatter.field("function_response_types", &self.function_response_types);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateFunctionCodeInputBody<'a> {
    /// <p>The base64-encoded contents of the deployment package. AWS SDK and AWS CLI clients handle the encoding for
    /// you.</p>
    pub zip_file: &'a std::option::Option<smithy_types::Blob>,
    /// <p>An Amazon S3 bucket in the same AWS Region as your function. The bucket can be in a different AWS account.</p>
    pub s3_bucket: &'a std::option::Option<std::string::String>,
    /// <p>The Amazon S3 key of the deployment package.</p>
    pub s3_key: &'a std::option::Option<std::string::String>,
    /// <p>For versioned objects, the version of the deployment package object to use.</p>
    pub s3_object_version: &'a std::option::Option<std::string::String>,
    /// <p>URI of a container image in the Amazon ECR registry.</p>
    pub image_uri: &'a std::option::Option<std::string::String>,
    /// <p>Set to true to publish a new version of the function after updating the code. This has the same effect as
    /// calling <a>PublishVersion</a> separately.</p>
    pub publish: &'a bool,
    /// <p>Set to true to validate the request parameters and access permissions without modifying the function
    /// code.</p>
    pub dry_run: &'a bool,
    /// <p>Only update the function if the revision ID matches the ID that's specified. Use this option to avoid modifying a
    /// function that has changed since you last read it.</p>
    pub revision_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for UpdateFunctionCodeInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateFunctionCodeInputBody");
        formatter.field("zip_file", &"*** Sensitive Data Redacted ***");
        formatter.field("s3_bucket", &self.s3_bucket);
        formatter.field("s3_key", &self.s3_key);
        formatter.field("s3_object_version", &self.s3_object_version);
        formatter.field("image_uri", &self.image_uri);
        formatter.field("publish", &self.publish);
        formatter.field("dry_run", &self.dry_run);
        formatter.field("revision_id", &self.revision_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateFunctionConfigurationInputBody<'a> {
    /// <p>The Amazon Resource Name (ARN) of the function's execution role.</p>
    pub role: &'a std::option::Option<std::string::String>,
    /// <p>The name of the method within your code that Lambda calls to execute your function. The format includes the
    /// file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information,
    /// see <a href="https://docs.aws.amazon.com/lambda/latest/dg/programming-model-v2.html">Programming Model</a>.</p>
    pub handler: &'a std::option::Option<std::string::String>,
    /// <p>A description of the function.</p>
    pub description: &'a std::option::Option<std::string::String>,
    /// <p>The amount of time that Lambda allows a function to run before stopping it. The default is 3 seconds. The
    /// maximum allowed value is 900 seconds.</p>
    pub timeout: &'a std::option::Option<i32>,
    /// <p>The amount of memory available to the function at runtime. Increasing the function's memory also increases its CPU
    /// allocation. The default value is 128 MB. The value can be any multiple of 1 MB.</p>
    pub memory_size: &'a std::option::Option<i32>,
    /// <p>For network connectivity to AWS resources in a VPC, specify a list of security groups and subnets in the VPC.
    /// When you connect a function to a VPC, it can only access resources and the internet through that VPC. For more
    /// information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html">VPC Settings</a>.</p>
    pub vpc_config: &'a std::option::Option<crate::model::VpcConfig>,
    /// <p>Environment variables that are accessible from function code during execution.</p>
    pub environment: &'a std::option::Option<crate::model::Environment>,
    /// <p>The identifier of the function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html">runtime</a>.</p>
    pub runtime: &'a std::option::Option<crate::model::Runtime>,
    /// <p>A dead letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events
    /// when they fail processing. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#dlq">Dead Letter Queues</a>.</p>
    pub dead_letter_config: &'a std::option::Option<crate::model::DeadLetterConfig>,
    /// <p>The ARN of the AWS Key Management Service (AWS KMS) key that's used to encrypt your function's environment
    /// variables. If it's not provided, AWS Lambda uses a default service key.</p>
    pub kms_key_arn: &'a std::option::Option<std::string::String>,
    /// <p>Set <code>Mode</code> to <code>Active</code> to sample and trace a subset of incoming requests with AWS
    /// X-Ray.</p>
    pub tracing_config: &'a std::option::Option<crate::model::TracingConfig>,
    /// <p>Only update the function if the revision ID matches the ID that's specified. Use this option to avoid modifying a
    /// function that has changed since you last read it.</p>
    pub revision_id: &'a std::option::Option<std::string::String>,
    /// <p>A list of <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">function layers</a>
    /// to add to the function's execution environment. Specify each layer by its ARN, including the version.</p>
    pub layers: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Connection settings for an Amazon EFS file system.</p>
    pub file_system_configs: &'a std::option::Option<std::vec::Vec<crate::model::FileSystemConfig>>,
    /// <p>
    /// <a href="https://docs.aws.amazon.com/lambda/latest/dg/images-parms.html">Container image configuration
    /// values</a> that override the values in the container image Dockerfile.</p>
    pub image_config: &'a std::option::Option<crate::model::ImageConfig>,
}
impl<'a> std::fmt::Debug for UpdateFunctionConfigurationInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateFunctionConfigurationInputBody");
        formatter.field("role", &self.role);
        formatter.field("handler", &self.handler);
        formatter.field("description", &self.description);
        formatter.field("timeout", &self.timeout);
        formatter.field("memory_size", &self.memory_size);
        formatter.field("vpc_config", &self.vpc_config);
        formatter.field("environment", &self.environment);
        formatter.field("runtime", &self.runtime);
        formatter.field("dead_letter_config", &self.dead_letter_config);
        formatter.field("kms_key_arn", &self.kms_key_arn);
        formatter.field("tracing_config", &self.tracing_config);
        formatter.field("revision_id", &self.revision_id);
        formatter.field("layers", &self.layers);
        formatter.field("file_system_configs", &self.file_system_configs);
        formatter.field("image_config", &self.image_config);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateFunctionEventInvokeConfigInputBody<'a> {
    /// <p>The maximum number of times to retry when the function returns an error.</p>
    pub maximum_retry_attempts: &'a std::option::Option<i32>,
    /// <p>The maximum age of a request that Lambda sends to a function for processing.</p>
    pub maximum_event_age_in_seconds: &'a std::option::Option<i32>,
    /// <p>A destination for events after they have been sent to a function for processing.</p>
    /// <p class="title">
    /// <b>Destinations</b>
    /// </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>Function</b> - The Amazon Resource Name (ARN) of a Lambda function.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Queue</b> - The ARN of an SQS queue.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Topic</b> - The ARN of an SNS topic.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Event Bus</b> - The ARN of an Amazon EventBridge event bus.</p>
    /// </li>
    /// </ul>
    pub destination_config: &'a std::option::Option<crate::model::DestinationConfig>,
}
impl<'a> std::fmt::Debug for UpdateFunctionEventInvokeConfigInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateFunctionEventInvokeConfigInputBody");
        formatter.field("maximum_retry_attempts", &self.maximum_retry_attempts);
        formatter.field(
            "maximum_event_age_in_seconds",
            &self.maximum_event_age_in_seconds,
        );
        formatter.field("destination_config", &self.destination_config);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AddLayerVersionPermissionOutputBody {
    /// <p>The permission statement.</p>
    #[serde(rename = "Statement")]
    #[serde(default)]
    pub statement: std::option::Option<std::string::String>,
    /// <p>A unique identifier for the current revision of the policy.</p>
    #[serde(rename = "RevisionId")]
    #[serde(default)]
    pub revision_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AddLayerVersionPermissionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AddLayerVersionPermissionOutputBody");
        formatter.field("statement", &self.statement);
        formatter.field("revision_id", &self.revision_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AddPermissionOutputBody {
    /// <p>The permission statement that's added to the function policy.</p>
    #[serde(rename = "Statement")]
    #[serde(default)]
    pub statement: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AddPermissionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AddPermissionOutputBody");
        formatter.field("statement", &self.statement);
        formatter.finish()
    }
}

/// <p>Provides configuration information about a Lambda function <a href="https://docs.aws.amazon.com/lambda/latest/dg/versioning-aliases.html">alias</a>.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateAliasOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the alias.</p>
    #[serde(rename = "AliasArn")]
    #[serde(default)]
    pub alias_arn: std::option::Option<std::string::String>,
    /// <p>The name of the alias.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The function version that the alias invokes.</p>
    #[serde(rename = "FunctionVersion")]
    #[serde(default)]
    pub function_version: std::option::Option<std::string::String>,
    /// <p>A description of the alias.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html">routing
    /// configuration</a> of the alias.</p>
    #[serde(rename = "RoutingConfig")]
    #[serde(default)]
    pub routing_config: std::option::Option<crate::model::AliasRoutingConfiguration>,
    /// <p>A unique identifier that changes when you update the alias.</p>
    #[serde(rename = "RevisionId")]
    #[serde(default)]
    pub revision_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateAliasOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateAliasOutputBody");
        formatter.field("alias_arn", &self.alias_arn);
        formatter.field("name", &self.name);
        formatter.field("function_version", &self.function_version);
        formatter.field("description", &self.description);
        formatter.field("routing_config", &self.routing_config);
        formatter.field("revision_id", &self.revision_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateCodeSigningConfigOutputBody {
    /// <p>The code signing configuration.</p>
    #[serde(rename = "CodeSigningConfig")]
    #[serde(default)]
    pub code_signing_config: std::option::Option<crate::model::CodeSigningConfig>,
}
impl std::fmt::Debug for CreateCodeSigningConfigOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateCodeSigningConfigOutputBody");
        formatter.field("code_signing_config", &self.code_signing_config);
        formatter.finish()
    }
}

/// <p>A mapping between an AWS resource and an AWS Lambda function. See <a>CreateEventSourceMapping</a> for details.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateEventSourceMappingOutputBody {
    /// <p>The identifier of the event source mapping.</p>
    #[serde(rename = "UUID")]
    #[serde(default)]
    pub uuid: std::option::Option<std::string::String>,
    /// <p>The position in a stream from which to start reading. Required for Amazon Kinesis, Amazon DynamoDB, and Amazon MSK Streams
    /// sources. <code>AT_TIMESTAMP</code> is only supported for Amazon Kinesis streams.</p>
    #[serde(rename = "StartingPosition")]
    #[serde(default)]
    pub starting_position: std::option::Option<crate::model::EventSourcePosition>,
    /// <p>With <code>StartingPosition</code> set to <code>AT_TIMESTAMP</code>, the time from which to start
    /// reading.</p>
    #[serde(rename = "StartingPositionTimestamp")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub starting_position_timestamp: std::option::Option<smithy_types::Instant>,
    /// <p>The maximum number of items to retrieve in a single batch.</p>
    #[serde(rename = "BatchSize")]
    #[serde(default)]
    pub batch_size: std::option::Option<i32>,
    /// <p>(Streams and SQS standard queues) The maximum amount of time to gather records before invoking the function, in seconds. The default value is zero.</p>
    #[serde(rename = "MaximumBatchingWindowInSeconds")]
    #[serde(default)]
    pub maximum_batching_window_in_seconds: std::option::Option<i32>,
    /// <p>(Streams) The number of batches to process from each shard concurrently. The default value is 1.</p>
    #[serde(rename = "ParallelizationFactor")]
    #[serde(default)]
    pub parallelization_factor: std::option::Option<i32>,
    /// <p>The Amazon Resource Name (ARN) of the event source.</p>
    #[serde(rename = "EventSourceArn")]
    #[serde(default)]
    pub event_source_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the Lambda function.</p>
    #[serde(rename = "FunctionArn")]
    #[serde(default)]
    pub function_arn: std::option::Option<std::string::String>,
    /// <p>The date that the event source mapping was last updated, or its state changed.</p>
    #[serde(rename = "LastModified")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified: std::option::Option<smithy_types::Instant>,
    /// <p>The result of the last AWS Lambda invocation of your Lambda function.</p>
    #[serde(rename = "LastProcessingResult")]
    #[serde(default)]
    pub last_processing_result: std::option::Option<std::string::String>,
    /// <p>The state of the event source mapping. It can be one of the following: <code>Creating</code>,
    /// <code>Enabling</code>, <code>Enabled</code>, <code>Disabling</code>, <code>Disabled</code>,
    /// <code>Updating</code>, or <code>Deleting</code>.</p>
    #[serde(rename = "State")]
    #[serde(default)]
    pub state: std::option::Option<std::string::String>,
    /// <p>Indicates whether the last change to the event source mapping was made by a user, or by the Lambda
    /// service.</p>
    #[serde(rename = "StateTransitionReason")]
    #[serde(default)]
    pub state_transition_reason: std::option::Option<std::string::String>,
    /// <p>(Streams) An Amazon SQS queue or Amazon SNS topic destination for discarded records.</p>
    #[serde(rename = "DestinationConfig")]
    #[serde(default)]
    pub destination_config: std::option::Option<crate::model::DestinationConfig>,
    /// <p>The name of the Kafka topic.</p>
    #[serde(rename = "Topics")]
    #[serde(default)]
    pub topics: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>
    /// (MQ) The name of the Amazon MQ broker destination queue to consume.
    /// </p>
    #[serde(rename = "Queues")]
    #[serde(default)]
    pub queues: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>An array of the authentication protocol, or the VPC components to secure your event source.</p>
    #[serde(rename = "SourceAccessConfigurations")]
    #[serde(default)]
    pub source_access_configurations:
        std::option::Option<std::vec::Vec<crate::model::SourceAccessConfiguration>>,
    /// <p>The Self-Managed Apache Kafka cluster for your event source.</p>
    #[serde(rename = "SelfManagedEventSource")]
    #[serde(default)]
    pub self_managed_event_source: std::option::Option<crate::model::SelfManagedEventSource>,
    /// <p>(Streams) Discard records older than the specified age. The default value is infinite (-1). When set to infinite (-1), failed records are retried until the record expires.</p>
    #[serde(rename = "MaximumRecordAgeInSeconds")]
    #[serde(default)]
    pub maximum_record_age_in_seconds: std::option::Option<i32>,
    /// <p>(Streams) If the function returns an error, split the batch in two and retry. The default value is false.</p>
    #[serde(rename = "BisectBatchOnFunctionError")]
    #[serde(default)]
    pub bisect_batch_on_function_error: std::option::Option<bool>,
    /// <p>(Streams) Discard records after the specified number of retries. The default value is infinite (-1). When set to infinite (-1), failed records are retried until the record expires.</p>
    #[serde(rename = "MaximumRetryAttempts")]
    #[serde(default)]
    pub maximum_retry_attempts: std::option::Option<i32>,
    /// <p>(Streams) The duration in seconds of a processing window. The range is between 1 second up to 900 seconds.</p>
    #[serde(rename = "TumblingWindowInSeconds")]
    #[serde(default)]
    pub tumbling_window_in_seconds: std::option::Option<i32>,
    /// <p>(Streams) A list of current response type enums applied to the event source mapping.</p>
    #[serde(rename = "FunctionResponseTypes")]
    #[serde(default)]
    pub function_response_types:
        std::option::Option<std::vec::Vec<crate::model::FunctionResponseType>>,
}
impl std::fmt::Debug for CreateEventSourceMappingOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateEventSourceMappingOutputBody");
        formatter.field("uuid", &self.uuid);
        formatter.field("starting_position", &self.starting_position);
        formatter.field(
            "starting_position_timestamp",
            &self.starting_position_timestamp,
        );
        formatter.field("batch_size", &self.batch_size);
        formatter.field(
            "maximum_batching_window_in_seconds",
            &self.maximum_batching_window_in_seconds,
        );
        formatter.field("parallelization_factor", &self.parallelization_factor);
        formatter.field("event_source_arn", &self.event_source_arn);
        formatter.field("function_arn", &self.function_arn);
        formatter.field("last_modified", &self.last_modified);
        formatter.field("last_processing_result", &self.last_processing_result);
        formatter.field("state", &self.state);
        formatter.field("state_transition_reason", &self.state_transition_reason);
        formatter.field("destination_config", &self.destination_config);
        formatter.field("topics", &self.topics);
        formatter.field("queues", &self.queues);
        formatter.field(
            "source_access_configurations",
            &self.source_access_configurations,
        );
        formatter.field("self_managed_event_source", &self.self_managed_event_source);
        formatter.field(
            "maximum_record_age_in_seconds",
            &self.maximum_record_age_in_seconds,
        );
        formatter.field(
            "bisect_batch_on_function_error",
            &self.bisect_batch_on_function_error,
        );
        formatter.field("maximum_retry_attempts", &self.maximum_retry_attempts);
        formatter.field(
            "tumbling_window_in_seconds",
            &self.tumbling_window_in_seconds,
        );
        formatter.field("function_response_types", &self.function_response_types);
        formatter.finish()
    }
}

/// <p>Details about a function's configuration.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateFunctionOutputBody {
    /// <p>The name of the function.</p>
    #[serde(rename = "FunctionName")]
    #[serde(default)]
    pub function_name: std::option::Option<std::string::String>,
    /// <p>The function's Amazon Resource Name (ARN).</p>
    #[serde(rename = "FunctionArn")]
    #[serde(default)]
    pub function_arn: std::option::Option<std::string::String>,
    /// <p>The runtime environment for the Lambda function.</p>
    #[serde(rename = "Runtime")]
    #[serde(default)]
    pub runtime: std::option::Option<crate::model::Runtime>,
    /// <p>The function's execution role.</p>
    #[serde(rename = "Role")]
    #[serde(default)]
    pub role: std::option::Option<std::string::String>,
    /// <p>The function that Lambda calls to begin executing your function.</p>
    #[serde(rename = "Handler")]
    #[serde(default)]
    pub handler: std::option::Option<std::string::String>,
    /// <p>The size of the function's deployment package, in bytes.</p>
    #[serde(rename = "CodeSize")]
    #[serde(default)]
    pub code_size: i64,
    /// <p>The function's description.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The amount of time in seconds that Lambda allows a function to run before stopping it.</p>
    #[serde(rename = "Timeout")]
    #[serde(default)]
    pub timeout: std::option::Option<i32>,
    /// <p>The amount of memory available to the function at runtime. </p>
    #[serde(rename = "MemorySize")]
    #[serde(default)]
    pub memory_size: std::option::Option<i32>,
    /// <p>The date and time that the function was last updated, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format</a> (YYYY-MM-DDThh:mm:ss.sTZD).</p>
    #[serde(rename = "LastModified")]
    #[serde(default)]
    pub last_modified: std::option::Option<std::string::String>,
    /// <p>The SHA256 hash of the function's deployment package.</p>
    #[serde(rename = "CodeSha256")]
    #[serde(default)]
    pub code_sha256: std::option::Option<std::string::String>,
    /// <p>The version of the Lambda function.</p>
    #[serde(rename = "Version")]
    #[serde(default)]
    pub version: std::option::Option<std::string::String>,
    /// <p>The function's networking configuration.</p>
    #[serde(rename = "VpcConfig")]
    #[serde(default)]
    pub vpc_config: std::option::Option<crate::model::VpcConfigResponse>,
    /// <p>The function's dead letter queue.</p>
    #[serde(rename = "DeadLetterConfig")]
    #[serde(default)]
    pub dead_letter_config: std::option::Option<crate::model::DeadLetterConfig>,
    /// <p>The function's environment variables.</p>
    #[serde(rename = "Environment")]
    #[serde(default)]
    pub environment: std::option::Option<crate::model::EnvironmentResponse>,
    /// <p>The KMS key that's used to encrypt the function's environment variables. This key is only returned if you've
    /// configured a customer managed CMK.</p>
    #[serde(rename = "KMSKeyArn")]
    #[serde(default)]
    pub kms_key_arn: std::option::Option<std::string::String>,
    /// <p>The function's AWS X-Ray tracing configuration.</p>
    #[serde(rename = "TracingConfig")]
    #[serde(default)]
    pub tracing_config: std::option::Option<crate::model::TracingConfigResponse>,
    /// <p>For Lambda@Edge functions, the ARN of the master function.</p>
    #[serde(rename = "MasterArn")]
    #[serde(default)]
    pub master_arn: std::option::Option<std::string::String>,
    /// <p>The latest updated revision of the function or alias.</p>
    #[serde(rename = "RevisionId")]
    #[serde(default)]
    pub revision_id: std::option::Option<std::string::String>,
    /// <p>The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">
    /// layers</a>.</p>
    #[serde(rename = "Layers")]
    #[serde(default)]
    pub layers: std::option::Option<std::vec::Vec<crate::model::Layer>>,
    /// <p>The current state of the function. When the state is <code>Inactive</code>, you can reactivate the function by
    /// invoking it.</p>
    #[serde(rename = "State")]
    #[serde(default)]
    pub state: std::option::Option<crate::model::State>,
    /// <p>The reason for the function's current state.</p>
    #[serde(rename = "StateReason")]
    #[serde(default)]
    pub state_reason: std::option::Option<std::string::String>,
    /// <p>The reason code for the function's current state. When the code is <code>Creating</code>, you can't invoke or
    /// modify the function.</p>
    #[serde(rename = "StateReasonCode")]
    #[serde(default)]
    pub state_reason_code: std::option::Option<crate::model::StateReasonCode>,
    /// <p>The status of the last update that was performed on the function. This is first set to <code>Successful</code>
    /// after function creation completes.</p>
    #[serde(rename = "LastUpdateStatus")]
    #[serde(default)]
    pub last_update_status: std::option::Option<crate::model::LastUpdateStatus>,
    /// <p>The reason for the last update that was performed on the function.</p>
    #[serde(rename = "LastUpdateStatusReason")]
    #[serde(default)]
    pub last_update_status_reason: std::option::Option<std::string::String>,
    /// <p>The reason code for the last update that was performed on the function.</p>
    #[serde(rename = "LastUpdateStatusReasonCode")]
    #[serde(default)]
    pub last_update_status_reason_code:
        std::option::Option<crate::model::LastUpdateStatusReasonCode>,
    /// <p>Connection settings for an Amazon EFS file system.</p>
    #[serde(rename = "FileSystemConfigs")]
    #[serde(default)]
    pub file_system_configs: std::option::Option<std::vec::Vec<crate::model::FileSystemConfig>>,
    /// <p>The type of deployment package. Set to <code>Image</code> for container image and set <code>Zip</code> for .zip file archive.</p>
    #[serde(rename = "PackageType")]
    #[serde(default)]
    pub package_type: std::option::Option<crate::model::PackageType>,
    /// <p>The function's image configuration values.</p>
    #[serde(rename = "ImageConfigResponse")]
    #[serde(default)]
    pub image_config_response: std::option::Option<crate::model::ImageConfigResponse>,
    /// <p>The ARN of the signing profile version.</p>
    #[serde(rename = "SigningProfileVersionArn")]
    #[serde(default)]
    pub signing_profile_version_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the signing job.</p>
    #[serde(rename = "SigningJobArn")]
    #[serde(default)]
    pub signing_job_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateFunctionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateFunctionOutputBody");
        formatter.field("function_name", &self.function_name);
        formatter.field("function_arn", &self.function_arn);
        formatter.field("runtime", &self.runtime);
        formatter.field("role", &self.role);
        formatter.field("handler", &self.handler);
        formatter.field("code_size", &self.code_size);
        formatter.field("description", &self.description);
        formatter.field("timeout", &self.timeout);
        formatter.field("memory_size", &self.memory_size);
        formatter.field("last_modified", &self.last_modified);
        formatter.field("code_sha256", &self.code_sha256);
        formatter.field("version", &self.version);
        formatter.field("vpc_config", &self.vpc_config);
        formatter.field("dead_letter_config", &self.dead_letter_config);
        formatter.field("environment", &self.environment);
        formatter.field("kms_key_arn", &self.kms_key_arn);
        formatter.field("tracing_config", &self.tracing_config);
        formatter.field("master_arn", &self.master_arn);
        formatter.field("revision_id", &self.revision_id);
        formatter.field("layers", &self.layers);
        formatter.field("state", &self.state);
        formatter.field("state_reason", &self.state_reason);
        formatter.field("state_reason_code", &self.state_reason_code);
        formatter.field("last_update_status", &self.last_update_status);
        formatter.field("last_update_status_reason", &self.last_update_status_reason);
        formatter.field(
            "last_update_status_reason_code",
            &self.last_update_status_reason_code,
        );
        formatter.field("file_system_configs", &self.file_system_configs);
        formatter.field("package_type", &self.package_type);
        formatter.field("image_config_response", &self.image_config_response);
        formatter.field(
            "signing_profile_version_arn",
            &self.signing_profile_version_arn,
        );
        formatter.field("signing_job_arn", &self.signing_job_arn);
        formatter.finish()
    }
}

/// <p>A mapping between an AWS resource and an AWS Lambda function. See <a>CreateEventSourceMapping</a> for details.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteEventSourceMappingOutputBody {
    /// <p>The identifier of the event source mapping.</p>
    #[serde(rename = "UUID")]
    #[serde(default)]
    pub uuid: std::option::Option<std::string::String>,
    /// <p>The position in a stream from which to start reading. Required for Amazon Kinesis, Amazon DynamoDB, and Amazon MSK Streams
    /// sources. <code>AT_TIMESTAMP</code> is only supported for Amazon Kinesis streams.</p>
    #[serde(rename = "StartingPosition")]
    #[serde(default)]
    pub starting_position: std::option::Option<crate::model::EventSourcePosition>,
    /// <p>With <code>StartingPosition</code> set to <code>AT_TIMESTAMP</code>, the time from which to start
    /// reading.</p>
    #[serde(rename = "StartingPositionTimestamp")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub starting_position_timestamp: std::option::Option<smithy_types::Instant>,
    /// <p>The maximum number of items to retrieve in a single batch.</p>
    #[serde(rename = "BatchSize")]
    #[serde(default)]
    pub batch_size: std::option::Option<i32>,
    /// <p>(Streams and SQS standard queues) The maximum amount of time to gather records before invoking the function, in seconds. The default value is zero.</p>
    #[serde(rename = "MaximumBatchingWindowInSeconds")]
    #[serde(default)]
    pub maximum_batching_window_in_seconds: std::option::Option<i32>,
    /// <p>(Streams) The number of batches to process from each shard concurrently. The default value is 1.</p>
    #[serde(rename = "ParallelizationFactor")]
    #[serde(default)]
    pub parallelization_factor: std::option::Option<i32>,
    /// <p>The Amazon Resource Name (ARN) of the event source.</p>
    #[serde(rename = "EventSourceArn")]
    #[serde(default)]
    pub event_source_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the Lambda function.</p>
    #[serde(rename = "FunctionArn")]
    #[serde(default)]
    pub function_arn: std::option::Option<std::string::String>,
    /// <p>The date that the event source mapping was last updated, or its state changed.</p>
    #[serde(rename = "LastModified")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified: std::option::Option<smithy_types::Instant>,
    /// <p>The result of the last AWS Lambda invocation of your Lambda function.</p>
    #[serde(rename = "LastProcessingResult")]
    #[serde(default)]
    pub last_processing_result: std::option::Option<std::string::String>,
    /// <p>The state of the event source mapping. It can be one of the following: <code>Creating</code>,
    /// <code>Enabling</code>, <code>Enabled</code>, <code>Disabling</code>, <code>Disabled</code>,
    /// <code>Updating</code>, or <code>Deleting</code>.</p>
    #[serde(rename = "State")]
    #[serde(default)]
    pub state: std::option::Option<std::string::String>,
    /// <p>Indicates whether the last change to the event source mapping was made by a user, or by the Lambda
    /// service.</p>
    #[serde(rename = "StateTransitionReason")]
    #[serde(default)]
    pub state_transition_reason: std::option::Option<std::string::String>,
    /// <p>(Streams) An Amazon SQS queue or Amazon SNS topic destination for discarded records.</p>
    #[serde(rename = "DestinationConfig")]
    #[serde(default)]
    pub destination_config: std::option::Option<crate::model::DestinationConfig>,
    /// <p>The name of the Kafka topic.</p>
    #[serde(rename = "Topics")]
    #[serde(default)]
    pub topics: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>
    /// (MQ) The name of the Amazon MQ broker destination queue to consume.
    /// </p>
    #[serde(rename = "Queues")]
    #[serde(default)]
    pub queues: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>An array of the authentication protocol, or the VPC components to secure your event source.</p>
    #[serde(rename = "SourceAccessConfigurations")]
    #[serde(default)]
    pub source_access_configurations:
        std::option::Option<std::vec::Vec<crate::model::SourceAccessConfiguration>>,
    /// <p>The Self-Managed Apache Kafka cluster for your event source.</p>
    #[serde(rename = "SelfManagedEventSource")]
    #[serde(default)]
    pub self_managed_event_source: std::option::Option<crate::model::SelfManagedEventSource>,
    /// <p>(Streams) Discard records older than the specified age. The default value is infinite (-1). When set to infinite (-1), failed records are retried until the record expires.</p>
    #[serde(rename = "MaximumRecordAgeInSeconds")]
    #[serde(default)]
    pub maximum_record_age_in_seconds: std::option::Option<i32>,
    /// <p>(Streams) If the function returns an error, split the batch in two and retry. The default value is false.</p>
    #[serde(rename = "BisectBatchOnFunctionError")]
    #[serde(default)]
    pub bisect_batch_on_function_error: std::option::Option<bool>,
    /// <p>(Streams) Discard records after the specified number of retries. The default value is infinite (-1). When set to infinite (-1), failed records are retried until the record expires.</p>
    #[serde(rename = "MaximumRetryAttempts")]
    #[serde(default)]
    pub maximum_retry_attempts: std::option::Option<i32>,
    /// <p>(Streams) The duration in seconds of a processing window. The range is between 1 second up to 900 seconds.</p>
    #[serde(rename = "TumblingWindowInSeconds")]
    #[serde(default)]
    pub tumbling_window_in_seconds: std::option::Option<i32>,
    /// <p>(Streams) A list of current response type enums applied to the event source mapping.</p>
    #[serde(rename = "FunctionResponseTypes")]
    #[serde(default)]
    pub function_response_types:
        std::option::Option<std::vec::Vec<crate::model::FunctionResponseType>>,
}
impl std::fmt::Debug for DeleteEventSourceMappingOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteEventSourceMappingOutputBody");
        formatter.field("uuid", &self.uuid);
        formatter.field("starting_position", &self.starting_position);
        formatter.field(
            "starting_position_timestamp",
            &self.starting_position_timestamp,
        );
        formatter.field("batch_size", &self.batch_size);
        formatter.field(
            "maximum_batching_window_in_seconds",
            &self.maximum_batching_window_in_seconds,
        );
        formatter.field("parallelization_factor", &self.parallelization_factor);
        formatter.field("event_source_arn", &self.event_source_arn);
        formatter.field("function_arn", &self.function_arn);
        formatter.field("last_modified", &self.last_modified);
        formatter.field("last_processing_result", &self.last_processing_result);
        formatter.field("state", &self.state);
        formatter.field("state_transition_reason", &self.state_transition_reason);
        formatter.field("destination_config", &self.destination_config);
        formatter.field("topics", &self.topics);
        formatter.field("queues", &self.queues);
        formatter.field(
            "source_access_configurations",
            &self.source_access_configurations,
        );
        formatter.field("self_managed_event_source", &self.self_managed_event_source);
        formatter.field(
            "maximum_record_age_in_seconds",
            &self.maximum_record_age_in_seconds,
        );
        formatter.field(
            "bisect_batch_on_function_error",
            &self.bisect_batch_on_function_error,
        );
        formatter.field("maximum_retry_attempts", &self.maximum_retry_attempts);
        formatter.field(
            "tumbling_window_in_seconds",
            &self.tumbling_window_in_seconds,
        );
        formatter.field("function_response_types", &self.function_response_types);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetAccountSettingsOutputBody {
    /// <p>Limits that are related to concurrency and code storage.</p>
    #[serde(rename = "AccountLimit")]
    #[serde(default)]
    pub account_limit: std::option::Option<crate::model::AccountLimit>,
    /// <p>The number of functions and amount of storage in use.</p>
    #[serde(rename = "AccountUsage")]
    #[serde(default)]
    pub account_usage: std::option::Option<crate::model::AccountUsage>,
}
impl std::fmt::Debug for GetAccountSettingsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetAccountSettingsOutputBody");
        formatter.field("account_limit", &self.account_limit);
        formatter.field("account_usage", &self.account_usage);
        formatter.finish()
    }
}

/// <p>Provides configuration information about a Lambda function <a href="https://docs.aws.amazon.com/lambda/latest/dg/versioning-aliases.html">alias</a>.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetAliasOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the alias.</p>
    #[serde(rename = "AliasArn")]
    #[serde(default)]
    pub alias_arn: std::option::Option<std::string::String>,
    /// <p>The name of the alias.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The function version that the alias invokes.</p>
    #[serde(rename = "FunctionVersion")]
    #[serde(default)]
    pub function_version: std::option::Option<std::string::String>,
    /// <p>A description of the alias.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html">routing
    /// configuration</a> of the alias.</p>
    #[serde(rename = "RoutingConfig")]
    #[serde(default)]
    pub routing_config: std::option::Option<crate::model::AliasRoutingConfiguration>,
    /// <p>A unique identifier that changes when you update the alias.</p>
    #[serde(rename = "RevisionId")]
    #[serde(default)]
    pub revision_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetAliasOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetAliasOutputBody");
        formatter.field("alias_arn", &self.alias_arn);
        formatter.field("name", &self.name);
        formatter.field("function_version", &self.function_version);
        formatter.field("description", &self.description);
        formatter.field("routing_config", &self.routing_config);
        formatter.field("revision_id", &self.revision_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetCodeSigningConfigOutputBody {
    /// <p>The code signing configuration</p>
    #[serde(rename = "CodeSigningConfig")]
    #[serde(default)]
    pub code_signing_config: std::option::Option<crate::model::CodeSigningConfig>,
}
impl std::fmt::Debug for GetCodeSigningConfigOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetCodeSigningConfigOutputBody");
        formatter.field("code_signing_config", &self.code_signing_config);
        formatter.finish()
    }
}

/// <p>A mapping between an AWS resource and an AWS Lambda function. See <a>CreateEventSourceMapping</a> for details.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetEventSourceMappingOutputBody {
    /// <p>The identifier of the event source mapping.</p>
    #[serde(rename = "UUID")]
    #[serde(default)]
    pub uuid: std::option::Option<std::string::String>,
    /// <p>The position in a stream from which to start reading. Required for Amazon Kinesis, Amazon DynamoDB, and Amazon MSK Streams
    /// sources. <code>AT_TIMESTAMP</code> is only supported for Amazon Kinesis streams.</p>
    #[serde(rename = "StartingPosition")]
    #[serde(default)]
    pub starting_position: std::option::Option<crate::model::EventSourcePosition>,
    /// <p>With <code>StartingPosition</code> set to <code>AT_TIMESTAMP</code>, the time from which to start
    /// reading.</p>
    #[serde(rename = "StartingPositionTimestamp")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub starting_position_timestamp: std::option::Option<smithy_types::Instant>,
    /// <p>The maximum number of items to retrieve in a single batch.</p>
    #[serde(rename = "BatchSize")]
    #[serde(default)]
    pub batch_size: std::option::Option<i32>,
    /// <p>(Streams and SQS standard queues) The maximum amount of time to gather records before invoking the function, in seconds. The default value is zero.</p>
    #[serde(rename = "MaximumBatchingWindowInSeconds")]
    #[serde(default)]
    pub maximum_batching_window_in_seconds: std::option::Option<i32>,
    /// <p>(Streams) The number of batches to process from each shard concurrently. The default value is 1.</p>
    #[serde(rename = "ParallelizationFactor")]
    #[serde(default)]
    pub parallelization_factor: std::option::Option<i32>,
    /// <p>The Amazon Resource Name (ARN) of the event source.</p>
    #[serde(rename = "EventSourceArn")]
    #[serde(default)]
    pub event_source_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the Lambda function.</p>
    #[serde(rename = "FunctionArn")]
    #[serde(default)]
    pub function_arn: std::option::Option<std::string::String>,
    /// <p>The date that the event source mapping was last updated, or its state changed.</p>
    #[serde(rename = "LastModified")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified: std::option::Option<smithy_types::Instant>,
    /// <p>The result of the last AWS Lambda invocation of your Lambda function.</p>
    #[serde(rename = "LastProcessingResult")]
    #[serde(default)]
    pub last_processing_result: std::option::Option<std::string::String>,
    /// <p>The state of the event source mapping. It can be one of the following: <code>Creating</code>,
    /// <code>Enabling</code>, <code>Enabled</code>, <code>Disabling</code>, <code>Disabled</code>,
    /// <code>Updating</code>, or <code>Deleting</code>.</p>
    #[serde(rename = "State")]
    #[serde(default)]
    pub state: std::option::Option<std::string::String>,
    /// <p>Indicates whether the last change to the event source mapping was made by a user, or by the Lambda
    /// service.</p>
    #[serde(rename = "StateTransitionReason")]
    #[serde(default)]
    pub state_transition_reason: std::option::Option<std::string::String>,
    /// <p>(Streams) An Amazon SQS queue or Amazon SNS topic destination for discarded records.</p>
    #[serde(rename = "DestinationConfig")]
    #[serde(default)]
    pub destination_config: std::option::Option<crate::model::DestinationConfig>,
    /// <p>The name of the Kafka topic.</p>
    #[serde(rename = "Topics")]
    #[serde(default)]
    pub topics: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>
    /// (MQ) The name of the Amazon MQ broker destination queue to consume.
    /// </p>
    #[serde(rename = "Queues")]
    #[serde(default)]
    pub queues: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>An array of the authentication protocol, or the VPC components to secure your event source.</p>
    #[serde(rename = "SourceAccessConfigurations")]
    #[serde(default)]
    pub source_access_configurations:
        std::option::Option<std::vec::Vec<crate::model::SourceAccessConfiguration>>,
    /// <p>The Self-Managed Apache Kafka cluster for your event source.</p>
    #[serde(rename = "SelfManagedEventSource")]
    #[serde(default)]
    pub self_managed_event_source: std::option::Option<crate::model::SelfManagedEventSource>,
    /// <p>(Streams) Discard records older than the specified age. The default value is infinite (-1). When set to infinite (-1), failed records are retried until the record expires.</p>
    #[serde(rename = "MaximumRecordAgeInSeconds")]
    #[serde(default)]
    pub maximum_record_age_in_seconds: std::option::Option<i32>,
    /// <p>(Streams) If the function returns an error, split the batch in two and retry. The default value is false.</p>
    #[serde(rename = "BisectBatchOnFunctionError")]
    #[serde(default)]
    pub bisect_batch_on_function_error: std::option::Option<bool>,
    /// <p>(Streams) Discard records after the specified number of retries. The default value is infinite (-1). When set to infinite (-1), failed records are retried until the record expires.</p>
    #[serde(rename = "MaximumRetryAttempts")]
    #[serde(default)]
    pub maximum_retry_attempts: std::option::Option<i32>,
    /// <p>(Streams) The duration in seconds of a processing window. The range is between 1 second up to 900 seconds.</p>
    #[serde(rename = "TumblingWindowInSeconds")]
    #[serde(default)]
    pub tumbling_window_in_seconds: std::option::Option<i32>,
    /// <p>(Streams) A list of current response type enums applied to the event source mapping.</p>
    #[serde(rename = "FunctionResponseTypes")]
    #[serde(default)]
    pub function_response_types:
        std::option::Option<std::vec::Vec<crate::model::FunctionResponseType>>,
}
impl std::fmt::Debug for GetEventSourceMappingOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetEventSourceMappingOutputBody");
        formatter.field("uuid", &self.uuid);
        formatter.field("starting_position", &self.starting_position);
        formatter.field(
            "starting_position_timestamp",
            &self.starting_position_timestamp,
        );
        formatter.field("batch_size", &self.batch_size);
        formatter.field(
            "maximum_batching_window_in_seconds",
            &self.maximum_batching_window_in_seconds,
        );
        formatter.field("parallelization_factor", &self.parallelization_factor);
        formatter.field("event_source_arn", &self.event_source_arn);
        formatter.field("function_arn", &self.function_arn);
        formatter.field("last_modified", &self.last_modified);
        formatter.field("last_processing_result", &self.last_processing_result);
        formatter.field("state", &self.state);
        formatter.field("state_transition_reason", &self.state_transition_reason);
        formatter.field("destination_config", &self.destination_config);
        formatter.field("topics", &self.topics);
        formatter.field("queues", &self.queues);
        formatter.field(
            "source_access_configurations",
            &self.source_access_configurations,
        );
        formatter.field("self_managed_event_source", &self.self_managed_event_source);
        formatter.field(
            "maximum_record_age_in_seconds",
            &self.maximum_record_age_in_seconds,
        );
        formatter.field(
            "bisect_batch_on_function_error",
            &self.bisect_batch_on_function_error,
        );
        formatter.field("maximum_retry_attempts", &self.maximum_retry_attempts);
        formatter.field(
            "tumbling_window_in_seconds",
            &self.tumbling_window_in_seconds,
        );
        formatter.field("function_response_types", &self.function_response_types);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetFunctionOutputBody {
    /// <p>The configuration of the function or version.</p>
    #[serde(rename = "Configuration")]
    #[serde(default)]
    pub configuration: std::option::Option<crate::model::FunctionConfiguration>,
    /// <p>The deployment package of the function or version.</p>
    #[serde(rename = "Code")]
    #[serde(default)]
    pub code: std::option::Option<crate::model::FunctionCodeLocation>,
    /// <p>The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/tagging.html">tags</a>.</p>
    #[serde(rename = "Tags")]
    #[serde(default)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/concurrent-executions.html">reserved
    /// concurrency</a>.</p>
    #[serde(rename = "Concurrency")]
    #[serde(default)]
    pub concurrency: std::option::Option<crate::model::Concurrency>,
}
impl std::fmt::Debug for GetFunctionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetFunctionOutputBody");
        formatter.field("configuration", &self.configuration);
        formatter.field("code", &self.code);
        formatter.field("tags", &self.tags);
        formatter.field("concurrency", &self.concurrency);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetFunctionCodeSigningConfigOutputBody {
    /// <p>The The Amazon Resource Name (ARN) of the code signing configuration.</p>
    #[serde(rename = "CodeSigningConfigArn")]
    #[serde(default)]
    pub code_signing_config_arn: std::option::Option<std::string::String>,
    /// <p>The name of the Lambda function.</p>
    /// <p class="title">
    /// <b>Name formats</b>
    /// </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>Function name</b> - <code>MyFunction</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Partial ARN</b> - <code>123456789012:function:MyFunction</code>.</p>
    /// </li>
    /// </ul>
    /// <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    /// characters in length.</p>
    #[serde(rename = "FunctionName")]
    #[serde(default)]
    pub function_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetFunctionCodeSigningConfigOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetFunctionCodeSigningConfigOutputBody");
        formatter.field("code_signing_config_arn", &self.code_signing_config_arn);
        formatter.field("function_name", &self.function_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetFunctionConcurrencyOutputBody {
    /// <p>The number of simultaneous executions that are reserved for the function.</p>
    #[serde(rename = "ReservedConcurrentExecutions")]
    #[serde(default)]
    pub reserved_concurrent_executions: std::option::Option<i32>,
}
impl std::fmt::Debug for GetFunctionConcurrencyOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetFunctionConcurrencyOutputBody");
        formatter.field(
            "reserved_concurrent_executions",
            &self.reserved_concurrent_executions,
        );
        formatter.finish()
    }
}

/// <p>Details about a function's configuration.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetFunctionConfigurationOutputBody {
    /// <p>The name of the function.</p>
    #[serde(rename = "FunctionName")]
    #[serde(default)]
    pub function_name: std::option::Option<std::string::String>,
    /// <p>The function's Amazon Resource Name (ARN).</p>
    #[serde(rename = "FunctionArn")]
    #[serde(default)]
    pub function_arn: std::option::Option<std::string::String>,
    /// <p>The runtime environment for the Lambda function.</p>
    #[serde(rename = "Runtime")]
    #[serde(default)]
    pub runtime: std::option::Option<crate::model::Runtime>,
    /// <p>The function's execution role.</p>
    #[serde(rename = "Role")]
    #[serde(default)]
    pub role: std::option::Option<std::string::String>,
    /// <p>The function that Lambda calls to begin executing your function.</p>
    #[serde(rename = "Handler")]
    #[serde(default)]
    pub handler: std::option::Option<std::string::String>,
    /// <p>The size of the function's deployment package, in bytes.</p>
    #[serde(rename = "CodeSize")]
    #[serde(default)]
    pub code_size: i64,
    /// <p>The function's description.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The amount of time in seconds that Lambda allows a function to run before stopping it.</p>
    #[serde(rename = "Timeout")]
    #[serde(default)]
    pub timeout: std::option::Option<i32>,
    /// <p>The amount of memory available to the function at runtime. </p>
    #[serde(rename = "MemorySize")]
    #[serde(default)]
    pub memory_size: std::option::Option<i32>,
    /// <p>The date and time that the function was last updated, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format</a> (YYYY-MM-DDThh:mm:ss.sTZD).</p>
    #[serde(rename = "LastModified")]
    #[serde(default)]
    pub last_modified: std::option::Option<std::string::String>,
    /// <p>The SHA256 hash of the function's deployment package.</p>
    #[serde(rename = "CodeSha256")]
    #[serde(default)]
    pub code_sha256: std::option::Option<std::string::String>,
    /// <p>The version of the Lambda function.</p>
    #[serde(rename = "Version")]
    #[serde(default)]
    pub version: std::option::Option<std::string::String>,
    /// <p>The function's networking configuration.</p>
    #[serde(rename = "VpcConfig")]
    #[serde(default)]
    pub vpc_config: std::option::Option<crate::model::VpcConfigResponse>,
    /// <p>The function's dead letter queue.</p>
    #[serde(rename = "DeadLetterConfig")]
    #[serde(default)]
    pub dead_letter_config: std::option::Option<crate::model::DeadLetterConfig>,
    /// <p>The function's environment variables.</p>
    #[serde(rename = "Environment")]
    #[serde(default)]
    pub environment: std::option::Option<crate::model::EnvironmentResponse>,
    /// <p>The KMS key that's used to encrypt the function's environment variables. This key is only returned if you've
    /// configured a customer managed CMK.</p>
    #[serde(rename = "KMSKeyArn")]
    #[serde(default)]
    pub kms_key_arn: std::option::Option<std::string::String>,
    /// <p>The function's AWS X-Ray tracing configuration.</p>
    #[serde(rename = "TracingConfig")]
    #[serde(default)]
    pub tracing_config: std::option::Option<crate::model::TracingConfigResponse>,
    /// <p>For Lambda@Edge functions, the ARN of the master function.</p>
    #[serde(rename = "MasterArn")]
    #[serde(default)]
    pub master_arn: std::option::Option<std::string::String>,
    /// <p>The latest updated revision of the function or alias.</p>
    #[serde(rename = "RevisionId")]
    #[serde(default)]
    pub revision_id: std::option::Option<std::string::String>,
    /// <p>The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">
    /// layers</a>.</p>
    #[serde(rename = "Layers")]
    #[serde(default)]
    pub layers: std::option::Option<std::vec::Vec<crate::model::Layer>>,
    /// <p>The current state of the function. When the state is <code>Inactive</code>, you can reactivate the function by
    /// invoking it.</p>
    #[serde(rename = "State")]
    #[serde(default)]
    pub state: std::option::Option<crate::model::State>,
    /// <p>The reason for the function's current state.</p>
    #[serde(rename = "StateReason")]
    #[serde(default)]
    pub state_reason: std::option::Option<std::string::String>,
    /// <p>The reason code for the function's current state. When the code is <code>Creating</code>, you can't invoke or
    /// modify the function.</p>
    #[serde(rename = "StateReasonCode")]
    #[serde(default)]
    pub state_reason_code: std::option::Option<crate::model::StateReasonCode>,
    /// <p>The status of the last update that was performed on the function. This is first set to <code>Successful</code>
    /// after function creation completes.</p>
    #[serde(rename = "LastUpdateStatus")]
    #[serde(default)]
    pub last_update_status: std::option::Option<crate::model::LastUpdateStatus>,
    /// <p>The reason for the last update that was performed on the function.</p>
    #[serde(rename = "LastUpdateStatusReason")]
    #[serde(default)]
    pub last_update_status_reason: std::option::Option<std::string::String>,
    /// <p>The reason code for the last update that was performed on the function.</p>
    #[serde(rename = "LastUpdateStatusReasonCode")]
    #[serde(default)]
    pub last_update_status_reason_code:
        std::option::Option<crate::model::LastUpdateStatusReasonCode>,
    /// <p>Connection settings for an Amazon EFS file system.</p>
    #[serde(rename = "FileSystemConfigs")]
    #[serde(default)]
    pub file_system_configs: std::option::Option<std::vec::Vec<crate::model::FileSystemConfig>>,
    /// <p>The type of deployment package. Set to <code>Image</code> for container image and set <code>Zip</code> for .zip file archive.</p>
    #[serde(rename = "PackageType")]
    #[serde(default)]
    pub package_type: std::option::Option<crate::model::PackageType>,
    /// <p>The function's image configuration values.</p>
    #[serde(rename = "ImageConfigResponse")]
    #[serde(default)]
    pub image_config_response: std::option::Option<crate::model::ImageConfigResponse>,
    /// <p>The ARN of the signing profile version.</p>
    #[serde(rename = "SigningProfileVersionArn")]
    #[serde(default)]
    pub signing_profile_version_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the signing job.</p>
    #[serde(rename = "SigningJobArn")]
    #[serde(default)]
    pub signing_job_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetFunctionConfigurationOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetFunctionConfigurationOutputBody");
        formatter.field("function_name", &self.function_name);
        formatter.field("function_arn", &self.function_arn);
        formatter.field("runtime", &self.runtime);
        formatter.field("role", &self.role);
        formatter.field("handler", &self.handler);
        formatter.field("code_size", &self.code_size);
        formatter.field("description", &self.description);
        formatter.field("timeout", &self.timeout);
        formatter.field("memory_size", &self.memory_size);
        formatter.field("last_modified", &self.last_modified);
        formatter.field("code_sha256", &self.code_sha256);
        formatter.field("version", &self.version);
        formatter.field("vpc_config", &self.vpc_config);
        formatter.field("dead_letter_config", &self.dead_letter_config);
        formatter.field("environment", &self.environment);
        formatter.field("kms_key_arn", &self.kms_key_arn);
        formatter.field("tracing_config", &self.tracing_config);
        formatter.field("master_arn", &self.master_arn);
        formatter.field("revision_id", &self.revision_id);
        formatter.field("layers", &self.layers);
        formatter.field("state", &self.state);
        formatter.field("state_reason", &self.state_reason);
        formatter.field("state_reason_code", &self.state_reason_code);
        formatter.field("last_update_status", &self.last_update_status);
        formatter.field("last_update_status_reason", &self.last_update_status_reason);
        formatter.field(
            "last_update_status_reason_code",
            &self.last_update_status_reason_code,
        );
        formatter.field("file_system_configs", &self.file_system_configs);
        formatter.field("package_type", &self.package_type);
        formatter.field("image_config_response", &self.image_config_response);
        formatter.field(
            "signing_profile_version_arn",
            &self.signing_profile_version_arn,
        );
        formatter.field("signing_job_arn", &self.signing_job_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetFunctionEventInvokeConfigOutputBody {
    /// <p>The date and time that the configuration was last updated.</p>
    #[serde(rename = "LastModified")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified: std::option::Option<smithy_types::Instant>,
    /// <p>The Amazon Resource Name (ARN) of the function.</p>
    #[serde(rename = "FunctionArn")]
    #[serde(default)]
    pub function_arn: std::option::Option<std::string::String>,
    /// <p>The maximum number of times to retry when the function returns an error.</p>
    #[serde(rename = "MaximumRetryAttempts")]
    #[serde(default)]
    pub maximum_retry_attempts: std::option::Option<i32>,
    /// <p>The maximum age of a request that Lambda sends to a function for processing.</p>
    #[serde(rename = "MaximumEventAgeInSeconds")]
    #[serde(default)]
    pub maximum_event_age_in_seconds: std::option::Option<i32>,
    /// <p>A destination for events after they have been sent to a function for processing.</p>
    /// <p class="title">
    /// <b>Destinations</b>
    /// </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>Function</b> - The Amazon Resource Name (ARN) of a Lambda function.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Queue</b> - The ARN of an SQS queue.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Topic</b> - The ARN of an SNS topic.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Event Bus</b> - The ARN of an Amazon EventBridge event bus.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "DestinationConfig")]
    #[serde(default)]
    pub destination_config: std::option::Option<crate::model::DestinationConfig>,
}
impl std::fmt::Debug for GetFunctionEventInvokeConfigOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetFunctionEventInvokeConfigOutputBody");
        formatter.field("last_modified", &self.last_modified);
        formatter.field("function_arn", &self.function_arn);
        formatter.field("maximum_retry_attempts", &self.maximum_retry_attempts);
        formatter.field(
            "maximum_event_age_in_seconds",
            &self.maximum_event_age_in_seconds,
        );
        formatter.field("destination_config", &self.destination_config);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetLayerVersionOutputBody {
    /// <p>Details about the layer version.</p>
    #[serde(rename = "Content")]
    #[serde(default)]
    pub content: std::option::Option<crate::model::LayerVersionContentOutput>,
    /// <p>The ARN of the layer.</p>
    #[serde(rename = "LayerArn")]
    #[serde(default)]
    pub layer_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the layer version.</p>
    #[serde(rename = "LayerVersionArn")]
    #[serde(default)]
    pub layer_version_arn: std::option::Option<std::string::String>,
    /// <p>The description of the version.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The date that the layer version was created, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format</a> (YYYY-MM-DDThh:mm:ss.sTZD).</p>
    #[serde(rename = "CreatedDate")]
    #[serde(default)]
    pub created_date: std::option::Option<std::string::String>,
    /// <p>The version number.</p>
    #[serde(rename = "Version")]
    #[serde(default)]
    pub version: i64,
    /// <p>The layer's compatible runtimes.</p>
    #[serde(rename = "CompatibleRuntimes")]
    #[serde(default)]
    pub compatible_runtimes: std::option::Option<std::vec::Vec<crate::model::Runtime>>,
    /// <p>The layer's software license.</p>
    #[serde(rename = "LicenseInfo")]
    #[serde(default)]
    pub license_info: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetLayerVersionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetLayerVersionOutputBody");
        formatter.field("content", &self.content);
        formatter.field("layer_arn", &self.layer_arn);
        formatter.field("layer_version_arn", &self.layer_version_arn);
        formatter.field("description", &self.description);
        formatter.field("created_date", &self.created_date);
        formatter.field("version", &self.version);
        formatter.field("compatible_runtimes", &self.compatible_runtimes);
        formatter.field("license_info", &self.license_info);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetLayerVersionByArnOutputBody {
    /// <p>Details about the layer version.</p>
    #[serde(rename = "Content")]
    #[serde(default)]
    pub content: std::option::Option<crate::model::LayerVersionContentOutput>,
    /// <p>The ARN of the layer.</p>
    #[serde(rename = "LayerArn")]
    #[serde(default)]
    pub layer_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the layer version.</p>
    #[serde(rename = "LayerVersionArn")]
    #[serde(default)]
    pub layer_version_arn: std::option::Option<std::string::String>,
    /// <p>The description of the version.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The date that the layer version was created, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format</a> (YYYY-MM-DDThh:mm:ss.sTZD).</p>
    #[serde(rename = "CreatedDate")]
    #[serde(default)]
    pub created_date: std::option::Option<std::string::String>,
    /// <p>The version number.</p>
    #[serde(rename = "Version")]
    #[serde(default)]
    pub version: i64,
    /// <p>The layer's compatible runtimes.</p>
    #[serde(rename = "CompatibleRuntimes")]
    #[serde(default)]
    pub compatible_runtimes: std::option::Option<std::vec::Vec<crate::model::Runtime>>,
    /// <p>The layer's software license.</p>
    #[serde(rename = "LicenseInfo")]
    #[serde(default)]
    pub license_info: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetLayerVersionByArnOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetLayerVersionByArnOutputBody");
        formatter.field("content", &self.content);
        formatter.field("layer_arn", &self.layer_arn);
        formatter.field("layer_version_arn", &self.layer_version_arn);
        formatter.field("description", &self.description);
        formatter.field("created_date", &self.created_date);
        formatter.field("version", &self.version);
        formatter.field("compatible_runtimes", &self.compatible_runtimes);
        formatter.field("license_info", &self.license_info);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetLayerVersionPolicyOutputBody {
    /// <p>The policy document.</p>
    #[serde(rename = "Policy")]
    #[serde(default)]
    pub policy: std::option::Option<std::string::String>,
    /// <p>A unique identifier for the current revision of the policy.</p>
    #[serde(rename = "RevisionId")]
    #[serde(default)]
    pub revision_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetLayerVersionPolicyOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetLayerVersionPolicyOutputBody");
        formatter.field("policy", &self.policy);
        formatter.field("revision_id", &self.revision_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetPolicyOutputBody {
    /// <p>The resource-based policy.</p>
    #[serde(rename = "Policy")]
    #[serde(default)]
    pub policy: std::option::Option<std::string::String>,
    /// <p>A unique identifier for the current revision of the policy.</p>
    #[serde(rename = "RevisionId")]
    #[serde(default)]
    pub revision_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetPolicyOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetPolicyOutputBody");
        formatter.field("policy", &self.policy);
        formatter.field("revision_id", &self.revision_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetProvisionedConcurrencyConfigOutputBody {
    /// <p>The amount of provisioned concurrency requested.</p>
    #[serde(rename = "RequestedProvisionedConcurrentExecutions")]
    #[serde(default)]
    pub requested_provisioned_concurrent_executions: std::option::Option<i32>,
    /// <p>The amount of provisioned concurrency available.</p>
    #[serde(rename = "AvailableProvisionedConcurrentExecutions")]
    #[serde(default)]
    pub available_provisioned_concurrent_executions: std::option::Option<i32>,
    /// <p>The amount of provisioned concurrency allocated.</p>
    #[serde(rename = "AllocatedProvisionedConcurrentExecutions")]
    #[serde(default)]
    pub allocated_provisioned_concurrent_executions: std::option::Option<i32>,
    /// <p>The status of the allocation process.</p>
    #[serde(rename = "Status")]
    #[serde(default)]
    pub status: std::option::Option<crate::model::ProvisionedConcurrencyStatusEnum>,
    /// <p>For failed allocations, the reason that provisioned concurrency could not be allocated.</p>
    #[serde(rename = "StatusReason")]
    #[serde(default)]
    pub status_reason: std::option::Option<std::string::String>,
    /// <p>The date and time that a user last updated the configuration, in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601 format</a>.</p>
    #[serde(rename = "LastModified")]
    #[serde(default)]
    pub last_modified: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetProvisionedConcurrencyConfigOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetProvisionedConcurrencyConfigOutputBody");
        formatter.field(
            "requested_provisioned_concurrent_executions",
            &self.requested_provisioned_concurrent_executions,
        );
        formatter.field(
            "available_provisioned_concurrent_executions",
            &self.available_provisioned_concurrent_executions,
        );
        formatter.field(
            "allocated_provisioned_concurrent_executions",
            &self.allocated_provisioned_concurrent_executions,
        );
        formatter.field("status", &self.status);
        formatter.field("status_reason", &self.status_reason);
        formatter.field("last_modified", &self.last_modified);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAliasesOutputBody {
    /// <p>The pagination token that's included if more results are available.</p>
    #[serde(rename = "NextMarker")]
    #[serde(default)]
    pub next_marker: std::option::Option<std::string::String>,
    /// <p>A list of aliases.</p>
    #[serde(rename = "Aliases")]
    #[serde(default)]
    pub aliases: std::option::Option<std::vec::Vec<crate::model::AliasConfiguration>>,
}
impl std::fmt::Debug for ListAliasesOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAliasesOutputBody");
        formatter.field("next_marker", &self.next_marker);
        formatter.field("aliases", &self.aliases);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListCodeSigningConfigsOutputBody {
    /// <p>The pagination token that's included if more results are available.</p>
    #[serde(rename = "NextMarker")]
    #[serde(default)]
    pub next_marker: std::option::Option<std::string::String>,
    /// <p>The code signing configurations</p>
    #[serde(rename = "CodeSigningConfigs")]
    #[serde(default)]
    pub code_signing_configs: std::option::Option<std::vec::Vec<crate::model::CodeSigningConfig>>,
}
impl std::fmt::Debug for ListCodeSigningConfigsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListCodeSigningConfigsOutputBody");
        formatter.field("next_marker", &self.next_marker);
        formatter.field("code_signing_configs", &self.code_signing_configs);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListEventSourceMappingsOutputBody {
    /// <p>A pagination token that's returned when the response doesn't contain all event source mappings.</p>
    #[serde(rename = "NextMarker")]
    #[serde(default)]
    pub next_marker: std::option::Option<std::string::String>,
    /// <p>A list of event source mappings.</p>
    #[serde(rename = "EventSourceMappings")]
    #[serde(default)]
    pub event_source_mappings:
        std::option::Option<std::vec::Vec<crate::model::EventSourceMappingConfiguration>>,
}
impl std::fmt::Debug for ListEventSourceMappingsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListEventSourceMappingsOutputBody");
        formatter.field("next_marker", &self.next_marker);
        formatter.field("event_source_mappings", &self.event_source_mappings);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListFunctionEventInvokeConfigsOutputBody {
    /// <p>A list of configurations.</p>
    #[serde(rename = "FunctionEventInvokeConfigs")]
    #[serde(default)]
    pub function_event_invoke_configs:
        std::option::Option<std::vec::Vec<crate::model::FunctionEventInvokeConfig>>,
    /// <p>The pagination token that's included if more results are available.</p>
    #[serde(rename = "NextMarker")]
    #[serde(default)]
    pub next_marker: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListFunctionEventInvokeConfigsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListFunctionEventInvokeConfigsOutputBody");
        formatter.field(
            "function_event_invoke_configs",
            &self.function_event_invoke_configs,
        );
        formatter.field("next_marker", &self.next_marker);
        formatter.finish()
    }
}

/// <p>A list of Lambda functions.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListFunctionsOutputBody {
    /// <p>The pagination token that's included if more results are available.</p>
    #[serde(rename = "NextMarker")]
    #[serde(default)]
    pub next_marker: std::option::Option<std::string::String>,
    /// <p>A list of Lambda functions.</p>
    #[serde(rename = "Functions")]
    #[serde(default)]
    pub functions: std::option::Option<std::vec::Vec<crate::model::FunctionConfiguration>>,
}
impl std::fmt::Debug for ListFunctionsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListFunctionsOutputBody");
        formatter.field("next_marker", &self.next_marker);
        formatter.field("functions", &self.functions);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListFunctionsByCodeSigningConfigOutputBody {
    /// <p>The pagination token that's included if more results are available.</p>
    #[serde(rename = "NextMarker")]
    #[serde(default)]
    pub next_marker: std::option::Option<std::string::String>,
    /// <p>The function ARNs. </p>
    #[serde(rename = "FunctionArns")]
    #[serde(default)]
    pub function_arns: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for ListFunctionsByCodeSigningConfigOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListFunctionsByCodeSigningConfigOutputBody");
        formatter.field("next_marker", &self.next_marker);
        formatter.field("function_arns", &self.function_arns);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListLayersOutputBody {
    /// <p>A pagination token returned when the response doesn't contain all layers.</p>
    #[serde(rename = "NextMarker")]
    #[serde(default)]
    pub next_marker: std::option::Option<std::string::String>,
    /// <p>A list of function layers.</p>
    #[serde(rename = "Layers")]
    #[serde(default)]
    pub layers: std::option::Option<std::vec::Vec<crate::model::LayersListItem>>,
}
impl std::fmt::Debug for ListLayersOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListLayersOutputBody");
        formatter.field("next_marker", &self.next_marker);
        formatter.field("layers", &self.layers);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListLayerVersionsOutputBody {
    /// <p>A pagination token returned when the response doesn't contain all versions.</p>
    #[serde(rename = "NextMarker")]
    #[serde(default)]
    pub next_marker: std::option::Option<std::string::String>,
    /// <p>A list of versions.</p>
    #[serde(rename = "LayerVersions")]
    #[serde(default)]
    pub layer_versions: std::option::Option<std::vec::Vec<crate::model::LayerVersionsListItem>>,
}
impl std::fmt::Debug for ListLayerVersionsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListLayerVersionsOutputBody");
        formatter.field("next_marker", &self.next_marker);
        formatter.field("layer_versions", &self.layer_versions);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListProvisionedConcurrencyConfigsOutputBody {
    /// <p>A list of provisioned concurrency configurations.</p>
    #[serde(rename = "ProvisionedConcurrencyConfigs")]
    #[serde(default)]
    pub provisioned_concurrency_configs:
        std::option::Option<std::vec::Vec<crate::model::ProvisionedConcurrencyConfigListItem>>,
    /// <p>The pagination token that's included if more results are available.</p>
    #[serde(rename = "NextMarker")]
    #[serde(default)]
    pub next_marker: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListProvisionedConcurrencyConfigsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListProvisionedConcurrencyConfigsOutputBody");
        formatter.field(
            "provisioned_concurrency_configs",
            &self.provisioned_concurrency_configs,
        );
        formatter.field("next_marker", &self.next_marker);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsOutputBody {
    /// <p>The function's tags.</p>
    #[serde(rename = "Tags")]
    #[serde(default)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for ListTagsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsOutputBody");
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListVersionsByFunctionOutputBody {
    /// <p>The pagination token that's included if more results are available.</p>
    #[serde(rename = "NextMarker")]
    #[serde(default)]
    pub next_marker: std::option::Option<std::string::String>,
    /// <p>A list of Lambda function versions.</p>
    #[serde(rename = "Versions")]
    #[serde(default)]
    pub versions: std::option::Option<std::vec::Vec<crate::model::FunctionConfiguration>>,
}
impl std::fmt::Debug for ListVersionsByFunctionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListVersionsByFunctionOutputBody");
        formatter.field("next_marker", &self.next_marker);
        formatter.field("versions", &self.versions);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PublishLayerVersionOutputBody {
    /// <p>Details about the layer version.</p>
    #[serde(rename = "Content")]
    #[serde(default)]
    pub content: std::option::Option<crate::model::LayerVersionContentOutput>,
    /// <p>The ARN of the layer.</p>
    #[serde(rename = "LayerArn")]
    #[serde(default)]
    pub layer_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the layer version.</p>
    #[serde(rename = "LayerVersionArn")]
    #[serde(default)]
    pub layer_version_arn: std::option::Option<std::string::String>,
    /// <p>The description of the version.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The date that the layer version was created, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format</a> (YYYY-MM-DDThh:mm:ss.sTZD).</p>
    #[serde(rename = "CreatedDate")]
    #[serde(default)]
    pub created_date: std::option::Option<std::string::String>,
    /// <p>The version number.</p>
    #[serde(rename = "Version")]
    #[serde(default)]
    pub version: i64,
    /// <p>The layer's compatible runtimes.</p>
    #[serde(rename = "CompatibleRuntimes")]
    #[serde(default)]
    pub compatible_runtimes: std::option::Option<std::vec::Vec<crate::model::Runtime>>,
    /// <p>The layer's software license.</p>
    #[serde(rename = "LicenseInfo")]
    #[serde(default)]
    pub license_info: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PublishLayerVersionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PublishLayerVersionOutputBody");
        formatter.field("content", &self.content);
        formatter.field("layer_arn", &self.layer_arn);
        formatter.field("layer_version_arn", &self.layer_version_arn);
        formatter.field("description", &self.description);
        formatter.field("created_date", &self.created_date);
        formatter.field("version", &self.version);
        formatter.field("compatible_runtimes", &self.compatible_runtimes);
        formatter.field("license_info", &self.license_info);
        formatter.finish()
    }
}

/// <p>Details about a function's configuration.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PublishVersionOutputBody {
    /// <p>The name of the function.</p>
    #[serde(rename = "FunctionName")]
    #[serde(default)]
    pub function_name: std::option::Option<std::string::String>,
    /// <p>The function's Amazon Resource Name (ARN).</p>
    #[serde(rename = "FunctionArn")]
    #[serde(default)]
    pub function_arn: std::option::Option<std::string::String>,
    /// <p>The runtime environment for the Lambda function.</p>
    #[serde(rename = "Runtime")]
    #[serde(default)]
    pub runtime: std::option::Option<crate::model::Runtime>,
    /// <p>The function's execution role.</p>
    #[serde(rename = "Role")]
    #[serde(default)]
    pub role: std::option::Option<std::string::String>,
    /// <p>The function that Lambda calls to begin executing your function.</p>
    #[serde(rename = "Handler")]
    #[serde(default)]
    pub handler: std::option::Option<std::string::String>,
    /// <p>The size of the function's deployment package, in bytes.</p>
    #[serde(rename = "CodeSize")]
    #[serde(default)]
    pub code_size: i64,
    /// <p>The function's description.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The amount of time in seconds that Lambda allows a function to run before stopping it.</p>
    #[serde(rename = "Timeout")]
    #[serde(default)]
    pub timeout: std::option::Option<i32>,
    /// <p>The amount of memory available to the function at runtime. </p>
    #[serde(rename = "MemorySize")]
    #[serde(default)]
    pub memory_size: std::option::Option<i32>,
    /// <p>The date and time that the function was last updated, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format</a> (YYYY-MM-DDThh:mm:ss.sTZD).</p>
    #[serde(rename = "LastModified")]
    #[serde(default)]
    pub last_modified: std::option::Option<std::string::String>,
    /// <p>The SHA256 hash of the function's deployment package.</p>
    #[serde(rename = "CodeSha256")]
    #[serde(default)]
    pub code_sha256: std::option::Option<std::string::String>,
    /// <p>The version of the Lambda function.</p>
    #[serde(rename = "Version")]
    #[serde(default)]
    pub version: std::option::Option<std::string::String>,
    /// <p>The function's networking configuration.</p>
    #[serde(rename = "VpcConfig")]
    #[serde(default)]
    pub vpc_config: std::option::Option<crate::model::VpcConfigResponse>,
    /// <p>The function's dead letter queue.</p>
    #[serde(rename = "DeadLetterConfig")]
    #[serde(default)]
    pub dead_letter_config: std::option::Option<crate::model::DeadLetterConfig>,
    /// <p>The function's environment variables.</p>
    #[serde(rename = "Environment")]
    #[serde(default)]
    pub environment: std::option::Option<crate::model::EnvironmentResponse>,
    /// <p>The KMS key that's used to encrypt the function's environment variables. This key is only returned if you've
    /// configured a customer managed CMK.</p>
    #[serde(rename = "KMSKeyArn")]
    #[serde(default)]
    pub kms_key_arn: std::option::Option<std::string::String>,
    /// <p>The function's AWS X-Ray tracing configuration.</p>
    #[serde(rename = "TracingConfig")]
    #[serde(default)]
    pub tracing_config: std::option::Option<crate::model::TracingConfigResponse>,
    /// <p>For Lambda@Edge functions, the ARN of the master function.</p>
    #[serde(rename = "MasterArn")]
    #[serde(default)]
    pub master_arn: std::option::Option<std::string::String>,
    /// <p>The latest updated revision of the function or alias.</p>
    #[serde(rename = "RevisionId")]
    #[serde(default)]
    pub revision_id: std::option::Option<std::string::String>,
    /// <p>The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">
    /// layers</a>.</p>
    #[serde(rename = "Layers")]
    #[serde(default)]
    pub layers: std::option::Option<std::vec::Vec<crate::model::Layer>>,
    /// <p>The current state of the function. When the state is <code>Inactive</code>, you can reactivate the function by
    /// invoking it.</p>
    #[serde(rename = "State")]
    #[serde(default)]
    pub state: std::option::Option<crate::model::State>,
    /// <p>The reason for the function's current state.</p>
    #[serde(rename = "StateReason")]
    #[serde(default)]
    pub state_reason: std::option::Option<std::string::String>,
    /// <p>The reason code for the function's current state. When the code is <code>Creating</code>, you can't invoke or
    /// modify the function.</p>
    #[serde(rename = "StateReasonCode")]
    #[serde(default)]
    pub state_reason_code: std::option::Option<crate::model::StateReasonCode>,
    /// <p>The status of the last update that was performed on the function. This is first set to <code>Successful</code>
    /// after function creation completes.</p>
    #[serde(rename = "LastUpdateStatus")]
    #[serde(default)]
    pub last_update_status: std::option::Option<crate::model::LastUpdateStatus>,
    /// <p>The reason for the last update that was performed on the function.</p>
    #[serde(rename = "LastUpdateStatusReason")]
    #[serde(default)]
    pub last_update_status_reason: std::option::Option<std::string::String>,
    /// <p>The reason code for the last update that was performed on the function.</p>
    #[serde(rename = "LastUpdateStatusReasonCode")]
    #[serde(default)]
    pub last_update_status_reason_code:
        std::option::Option<crate::model::LastUpdateStatusReasonCode>,
    /// <p>Connection settings for an Amazon EFS file system.</p>
    #[serde(rename = "FileSystemConfigs")]
    #[serde(default)]
    pub file_system_configs: std::option::Option<std::vec::Vec<crate::model::FileSystemConfig>>,
    /// <p>The type of deployment package. Set to <code>Image</code> for container image and set <code>Zip</code> for .zip file archive.</p>
    #[serde(rename = "PackageType")]
    #[serde(default)]
    pub package_type: std::option::Option<crate::model::PackageType>,
    /// <p>The function's image configuration values.</p>
    #[serde(rename = "ImageConfigResponse")]
    #[serde(default)]
    pub image_config_response: std::option::Option<crate::model::ImageConfigResponse>,
    /// <p>The ARN of the signing profile version.</p>
    #[serde(rename = "SigningProfileVersionArn")]
    #[serde(default)]
    pub signing_profile_version_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the signing job.</p>
    #[serde(rename = "SigningJobArn")]
    #[serde(default)]
    pub signing_job_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PublishVersionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PublishVersionOutputBody");
        formatter.field("function_name", &self.function_name);
        formatter.field("function_arn", &self.function_arn);
        formatter.field("runtime", &self.runtime);
        formatter.field("role", &self.role);
        formatter.field("handler", &self.handler);
        formatter.field("code_size", &self.code_size);
        formatter.field("description", &self.description);
        formatter.field("timeout", &self.timeout);
        formatter.field("memory_size", &self.memory_size);
        formatter.field("last_modified", &self.last_modified);
        formatter.field("code_sha256", &self.code_sha256);
        formatter.field("version", &self.version);
        formatter.field("vpc_config", &self.vpc_config);
        formatter.field("dead_letter_config", &self.dead_letter_config);
        formatter.field("environment", &self.environment);
        formatter.field("kms_key_arn", &self.kms_key_arn);
        formatter.field("tracing_config", &self.tracing_config);
        formatter.field("master_arn", &self.master_arn);
        formatter.field("revision_id", &self.revision_id);
        formatter.field("layers", &self.layers);
        formatter.field("state", &self.state);
        formatter.field("state_reason", &self.state_reason);
        formatter.field("state_reason_code", &self.state_reason_code);
        formatter.field("last_update_status", &self.last_update_status);
        formatter.field("last_update_status_reason", &self.last_update_status_reason);
        formatter.field(
            "last_update_status_reason_code",
            &self.last_update_status_reason_code,
        );
        formatter.field("file_system_configs", &self.file_system_configs);
        formatter.field("package_type", &self.package_type);
        formatter.field("image_config_response", &self.image_config_response);
        formatter.field(
            "signing_profile_version_arn",
            &self.signing_profile_version_arn,
        );
        formatter.field("signing_job_arn", &self.signing_job_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PutFunctionCodeSigningConfigOutputBody {
    /// <p>The The Amazon Resource Name (ARN) of the code signing configuration.</p>
    #[serde(rename = "CodeSigningConfigArn")]
    #[serde(default)]
    pub code_signing_config_arn: std::option::Option<std::string::String>,
    /// <p>The name of the Lambda function.</p>
    /// <p class="title">
    /// <b>Name formats</b>
    /// </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>Function name</b> - <code>MyFunction</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Partial ARN</b> - <code>123456789012:function:MyFunction</code>.</p>
    /// </li>
    /// </ul>
    /// <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    /// characters in length.</p>
    #[serde(rename = "FunctionName")]
    #[serde(default)]
    pub function_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutFunctionCodeSigningConfigOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutFunctionCodeSigningConfigOutputBody");
        formatter.field("code_signing_config_arn", &self.code_signing_config_arn);
        formatter.field("function_name", &self.function_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PutFunctionConcurrencyOutputBody {
    /// <p>The number of concurrent executions that are reserved for this function. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/concurrent-executions.html">Managing Concurrency</a>.</p>
    #[serde(rename = "ReservedConcurrentExecutions")]
    #[serde(default)]
    pub reserved_concurrent_executions: std::option::Option<i32>,
}
impl std::fmt::Debug for PutFunctionConcurrencyOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutFunctionConcurrencyOutputBody");
        formatter.field(
            "reserved_concurrent_executions",
            &self.reserved_concurrent_executions,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PutFunctionEventInvokeConfigOutputBody {
    /// <p>The date and time that the configuration was last updated.</p>
    #[serde(rename = "LastModified")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified: std::option::Option<smithy_types::Instant>,
    /// <p>The Amazon Resource Name (ARN) of the function.</p>
    #[serde(rename = "FunctionArn")]
    #[serde(default)]
    pub function_arn: std::option::Option<std::string::String>,
    /// <p>The maximum number of times to retry when the function returns an error.</p>
    #[serde(rename = "MaximumRetryAttempts")]
    #[serde(default)]
    pub maximum_retry_attempts: std::option::Option<i32>,
    /// <p>The maximum age of a request that Lambda sends to a function for processing.</p>
    #[serde(rename = "MaximumEventAgeInSeconds")]
    #[serde(default)]
    pub maximum_event_age_in_seconds: std::option::Option<i32>,
    /// <p>A destination for events after they have been sent to a function for processing.</p>
    /// <p class="title">
    /// <b>Destinations</b>
    /// </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>Function</b> - The Amazon Resource Name (ARN) of a Lambda function.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Queue</b> - The ARN of an SQS queue.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Topic</b> - The ARN of an SNS topic.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Event Bus</b> - The ARN of an Amazon EventBridge event bus.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "DestinationConfig")]
    #[serde(default)]
    pub destination_config: std::option::Option<crate::model::DestinationConfig>,
}
impl std::fmt::Debug for PutFunctionEventInvokeConfigOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutFunctionEventInvokeConfigOutputBody");
        formatter.field("last_modified", &self.last_modified);
        formatter.field("function_arn", &self.function_arn);
        formatter.field("maximum_retry_attempts", &self.maximum_retry_attempts);
        formatter.field(
            "maximum_event_age_in_seconds",
            &self.maximum_event_age_in_seconds,
        );
        formatter.field("destination_config", &self.destination_config);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PutProvisionedConcurrencyConfigOutputBody {
    /// <p>The amount of provisioned concurrency requested.</p>
    #[serde(rename = "RequestedProvisionedConcurrentExecutions")]
    #[serde(default)]
    pub requested_provisioned_concurrent_executions: std::option::Option<i32>,
    /// <p>The amount of provisioned concurrency available.</p>
    #[serde(rename = "AvailableProvisionedConcurrentExecutions")]
    #[serde(default)]
    pub available_provisioned_concurrent_executions: std::option::Option<i32>,
    /// <p>The amount of provisioned concurrency allocated.</p>
    #[serde(rename = "AllocatedProvisionedConcurrentExecutions")]
    #[serde(default)]
    pub allocated_provisioned_concurrent_executions: std::option::Option<i32>,
    /// <p>The status of the allocation process.</p>
    #[serde(rename = "Status")]
    #[serde(default)]
    pub status: std::option::Option<crate::model::ProvisionedConcurrencyStatusEnum>,
    /// <p>For failed allocations, the reason that provisioned concurrency could not be allocated.</p>
    #[serde(rename = "StatusReason")]
    #[serde(default)]
    pub status_reason: std::option::Option<std::string::String>,
    /// <p>The date and time that a user last updated the configuration, in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601 format</a>.</p>
    #[serde(rename = "LastModified")]
    #[serde(default)]
    pub last_modified: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutProvisionedConcurrencyConfigOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutProvisionedConcurrencyConfigOutputBody");
        formatter.field(
            "requested_provisioned_concurrent_executions",
            &self.requested_provisioned_concurrent_executions,
        );
        formatter.field(
            "available_provisioned_concurrent_executions",
            &self.available_provisioned_concurrent_executions,
        );
        formatter.field(
            "allocated_provisioned_concurrent_executions",
            &self.allocated_provisioned_concurrent_executions,
        );
        formatter.field("status", &self.status);
        formatter.field("status_reason", &self.status_reason);
        formatter.field("last_modified", &self.last_modified);
        formatter.finish()
    }
}

/// <p>Provides configuration information about a Lambda function <a href="https://docs.aws.amazon.com/lambda/latest/dg/versioning-aliases.html">alias</a>.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateAliasOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the alias.</p>
    #[serde(rename = "AliasArn")]
    #[serde(default)]
    pub alias_arn: std::option::Option<std::string::String>,
    /// <p>The name of the alias.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The function version that the alias invokes.</p>
    #[serde(rename = "FunctionVersion")]
    #[serde(default)]
    pub function_version: std::option::Option<std::string::String>,
    /// <p>A description of the alias.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html">routing
    /// configuration</a> of the alias.</p>
    #[serde(rename = "RoutingConfig")]
    #[serde(default)]
    pub routing_config: std::option::Option<crate::model::AliasRoutingConfiguration>,
    /// <p>A unique identifier that changes when you update the alias.</p>
    #[serde(rename = "RevisionId")]
    #[serde(default)]
    pub revision_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateAliasOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateAliasOutputBody");
        formatter.field("alias_arn", &self.alias_arn);
        formatter.field("name", &self.name);
        formatter.field("function_version", &self.function_version);
        formatter.field("description", &self.description);
        formatter.field("routing_config", &self.routing_config);
        formatter.field("revision_id", &self.revision_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateCodeSigningConfigOutputBody {
    /// <p>The code signing configuration</p>
    #[serde(rename = "CodeSigningConfig")]
    #[serde(default)]
    pub code_signing_config: std::option::Option<crate::model::CodeSigningConfig>,
}
impl std::fmt::Debug for UpdateCodeSigningConfigOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateCodeSigningConfigOutputBody");
        formatter.field("code_signing_config", &self.code_signing_config);
        formatter.finish()
    }
}

/// <p>A mapping between an AWS resource and an AWS Lambda function. See <a>CreateEventSourceMapping</a> for details.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateEventSourceMappingOutputBody {
    /// <p>The identifier of the event source mapping.</p>
    #[serde(rename = "UUID")]
    #[serde(default)]
    pub uuid: std::option::Option<std::string::String>,
    /// <p>The position in a stream from which to start reading. Required for Amazon Kinesis, Amazon DynamoDB, and Amazon MSK Streams
    /// sources. <code>AT_TIMESTAMP</code> is only supported for Amazon Kinesis streams.</p>
    #[serde(rename = "StartingPosition")]
    #[serde(default)]
    pub starting_position: std::option::Option<crate::model::EventSourcePosition>,
    /// <p>With <code>StartingPosition</code> set to <code>AT_TIMESTAMP</code>, the time from which to start
    /// reading.</p>
    #[serde(rename = "StartingPositionTimestamp")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub starting_position_timestamp: std::option::Option<smithy_types::Instant>,
    /// <p>The maximum number of items to retrieve in a single batch.</p>
    #[serde(rename = "BatchSize")]
    #[serde(default)]
    pub batch_size: std::option::Option<i32>,
    /// <p>(Streams and SQS standard queues) The maximum amount of time to gather records before invoking the function, in seconds. The default value is zero.</p>
    #[serde(rename = "MaximumBatchingWindowInSeconds")]
    #[serde(default)]
    pub maximum_batching_window_in_seconds: std::option::Option<i32>,
    /// <p>(Streams) The number of batches to process from each shard concurrently. The default value is 1.</p>
    #[serde(rename = "ParallelizationFactor")]
    #[serde(default)]
    pub parallelization_factor: std::option::Option<i32>,
    /// <p>The Amazon Resource Name (ARN) of the event source.</p>
    #[serde(rename = "EventSourceArn")]
    #[serde(default)]
    pub event_source_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the Lambda function.</p>
    #[serde(rename = "FunctionArn")]
    #[serde(default)]
    pub function_arn: std::option::Option<std::string::String>,
    /// <p>The date that the event source mapping was last updated, or its state changed.</p>
    #[serde(rename = "LastModified")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified: std::option::Option<smithy_types::Instant>,
    /// <p>The result of the last AWS Lambda invocation of your Lambda function.</p>
    #[serde(rename = "LastProcessingResult")]
    #[serde(default)]
    pub last_processing_result: std::option::Option<std::string::String>,
    /// <p>The state of the event source mapping. It can be one of the following: <code>Creating</code>,
    /// <code>Enabling</code>, <code>Enabled</code>, <code>Disabling</code>, <code>Disabled</code>,
    /// <code>Updating</code>, or <code>Deleting</code>.</p>
    #[serde(rename = "State")]
    #[serde(default)]
    pub state: std::option::Option<std::string::String>,
    /// <p>Indicates whether the last change to the event source mapping was made by a user, or by the Lambda
    /// service.</p>
    #[serde(rename = "StateTransitionReason")]
    #[serde(default)]
    pub state_transition_reason: std::option::Option<std::string::String>,
    /// <p>(Streams) An Amazon SQS queue or Amazon SNS topic destination for discarded records.</p>
    #[serde(rename = "DestinationConfig")]
    #[serde(default)]
    pub destination_config: std::option::Option<crate::model::DestinationConfig>,
    /// <p>The name of the Kafka topic.</p>
    #[serde(rename = "Topics")]
    #[serde(default)]
    pub topics: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>
    /// (MQ) The name of the Amazon MQ broker destination queue to consume.
    /// </p>
    #[serde(rename = "Queues")]
    #[serde(default)]
    pub queues: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>An array of the authentication protocol, or the VPC components to secure your event source.</p>
    #[serde(rename = "SourceAccessConfigurations")]
    #[serde(default)]
    pub source_access_configurations:
        std::option::Option<std::vec::Vec<crate::model::SourceAccessConfiguration>>,
    /// <p>The Self-Managed Apache Kafka cluster for your event source.</p>
    #[serde(rename = "SelfManagedEventSource")]
    #[serde(default)]
    pub self_managed_event_source: std::option::Option<crate::model::SelfManagedEventSource>,
    /// <p>(Streams) Discard records older than the specified age. The default value is infinite (-1). When set to infinite (-1), failed records are retried until the record expires.</p>
    #[serde(rename = "MaximumRecordAgeInSeconds")]
    #[serde(default)]
    pub maximum_record_age_in_seconds: std::option::Option<i32>,
    /// <p>(Streams) If the function returns an error, split the batch in two and retry. The default value is false.</p>
    #[serde(rename = "BisectBatchOnFunctionError")]
    #[serde(default)]
    pub bisect_batch_on_function_error: std::option::Option<bool>,
    /// <p>(Streams) Discard records after the specified number of retries. The default value is infinite (-1). When set to infinite (-1), failed records are retried until the record expires.</p>
    #[serde(rename = "MaximumRetryAttempts")]
    #[serde(default)]
    pub maximum_retry_attempts: std::option::Option<i32>,
    /// <p>(Streams) The duration in seconds of a processing window. The range is between 1 second up to 900 seconds.</p>
    #[serde(rename = "TumblingWindowInSeconds")]
    #[serde(default)]
    pub tumbling_window_in_seconds: std::option::Option<i32>,
    /// <p>(Streams) A list of current response type enums applied to the event source mapping.</p>
    #[serde(rename = "FunctionResponseTypes")]
    #[serde(default)]
    pub function_response_types:
        std::option::Option<std::vec::Vec<crate::model::FunctionResponseType>>,
}
impl std::fmt::Debug for UpdateEventSourceMappingOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateEventSourceMappingOutputBody");
        formatter.field("uuid", &self.uuid);
        formatter.field("starting_position", &self.starting_position);
        formatter.field(
            "starting_position_timestamp",
            &self.starting_position_timestamp,
        );
        formatter.field("batch_size", &self.batch_size);
        formatter.field(
            "maximum_batching_window_in_seconds",
            &self.maximum_batching_window_in_seconds,
        );
        formatter.field("parallelization_factor", &self.parallelization_factor);
        formatter.field("event_source_arn", &self.event_source_arn);
        formatter.field("function_arn", &self.function_arn);
        formatter.field("last_modified", &self.last_modified);
        formatter.field("last_processing_result", &self.last_processing_result);
        formatter.field("state", &self.state);
        formatter.field("state_transition_reason", &self.state_transition_reason);
        formatter.field("destination_config", &self.destination_config);
        formatter.field("topics", &self.topics);
        formatter.field("queues", &self.queues);
        formatter.field(
            "source_access_configurations",
            &self.source_access_configurations,
        );
        formatter.field("self_managed_event_source", &self.self_managed_event_source);
        formatter.field(
            "maximum_record_age_in_seconds",
            &self.maximum_record_age_in_seconds,
        );
        formatter.field(
            "bisect_batch_on_function_error",
            &self.bisect_batch_on_function_error,
        );
        formatter.field("maximum_retry_attempts", &self.maximum_retry_attempts);
        formatter.field(
            "tumbling_window_in_seconds",
            &self.tumbling_window_in_seconds,
        );
        formatter.field("function_response_types", &self.function_response_types);
        formatter.finish()
    }
}

/// <p>Details about a function's configuration.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateFunctionCodeOutputBody {
    /// <p>The name of the function.</p>
    #[serde(rename = "FunctionName")]
    #[serde(default)]
    pub function_name: std::option::Option<std::string::String>,
    /// <p>The function's Amazon Resource Name (ARN).</p>
    #[serde(rename = "FunctionArn")]
    #[serde(default)]
    pub function_arn: std::option::Option<std::string::String>,
    /// <p>The runtime environment for the Lambda function.</p>
    #[serde(rename = "Runtime")]
    #[serde(default)]
    pub runtime: std::option::Option<crate::model::Runtime>,
    /// <p>The function's execution role.</p>
    #[serde(rename = "Role")]
    #[serde(default)]
    pub role: std::option::Option<std::string::String>,
    /// <p>The function that Lambda calls to begin executing your function.</p>
    #[serde(rename = "Handler")]
    #[serde(default)]
    pub handler: std::option::Option<std::string::String>,
    /// <p>The size of the function's deployment package, in bytes.</p>
    #[serde(rename = "CodeSize")]
    #[serde(default)]
    pub code_size: i64,
    /// <p>The function's description.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The amount of time in seconds that Lambda allows a function to run before stopping it.</p>
    #[serde(rename = "Timeout")]
    #[serde(default)]
    pub timeout: std::option::Option<i32>,
    /// <p>The amount of memory available to the function at runtime. </p>
    #[serde(rename = "MemorySize")]
    #[serde(default)]
    pub memory_size: std::option::Option<i32>,
    /// <p>The date and time that the function was last updated, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format</a> (YYYY-MM-DDThh:mm:ss.sTZD).</p>
    #[serde(rename = "LastModified")]
    #[serde(default)]
    pub last_modified: std::option::Option<std::string::String>,
    /// <p>The SHA256 hash of the function's deployment package.</p>
    #[serde(rename = "CodeSha256")]
    #[serde(default)]
    pub code_sha256: std::option::Option<std::string::String>,
    /// <p>The version of the Lambda function.</p>
    #[serde(rename = "Version")]
    #[serde(default)]
    pub version: std::option::Option<std::string::String>,
    /// <p>The function's networking configuration.</p>
    #[serde(rename = "VpcConfig")]
    #[serde(default)]
    pub vpc_config: std::option::Option<crate::model::VpcConfigResponse>,
    /// <p>The function's dead letter queue.</p>
    #[serde(rename = "DeadLetterConfig")]
    #[serde(default)]
    pub dead_letter_config: std::option::Option<crate::model::DeadLetterConfig>,
    /// <p>The function's environment variables.</p>
    #[serde(rename = "Environment")]
    #[serde(default)]
    pub environment: std::option::Option<crate::model::EnvironmentResponse>,
    /// <p>The KMS key that's used to encrypt the function's environment variables. This key is only returned if you've
    /// configured a customer managed CMK.</p>
    #[serde(rename = "KMSKeyArn")]
    #[serde(default)]
    pub kms_key_arn: std::option::Option<std::string::String>,
    /// <p>The function's AWS X-Ray tracing configuration.</p>
    #[serde(rename = "TracingConfig")]
    #[serde(default)]
    pub tracing_config: std::option::Option<crate::model::TracingConfigResponse>,
    /// <p>For Lambda@Edge functions, the ARN of the master function.</p>
    #[serde(rename = "MasterArn")]
    #[serde(default)]
    pub master_arn: std::option::Option<std::string::String>,
    /// <p>The latest updated revision of the function or alias.</p>
    #[serde(rename = "RevisionId")]
    #[serde(default)]
    pub revision_id: std::option::Option<std::string::String>,
    /// <p>The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">
    /// layers</a>.</p>
    #[serde(rename = "Layers")]
    #[serde(default)]
    pub layers: std::option::Option<std::vec::Vec<crate::model::Layer>>,
    /// <p>The current state of the function. When the state is <code>Inactive</code>, you can reactivate the function by
    /// invoking it.</p>
    #[serde(rename = "State")]
    #[serde(default)]
    pub state: std::option::Option<crate::model::State>,
    /// <p>The reason for the function's current state.</p>
    #[serde(rename = "StateReason")]
    #[serde(default)]
    pub state_reason: std::option::Option<std::string::String>,
    /// <p>The reason code for the function's current state. When the code is <code>Creating</code>, you can't invoke or
    /// modify the function.</p>
    #[serde(rename = "StateReasonCode")]
    #[serde(default)]
    pub state_reason_code: std::option::Option<crate::model::StateReasonCode>,
    /// <p>The status of the last update that was performed on the function. This is first set to <code>Successful</code>
    /// after function creation completes.</p>
    #[serde(rename = "LastUpdateStatus")]
    #[serde(default)]
    pub last_update_status: std::option::Option<crate::model::LastUpdateStatus>,
    /// <p>The reason for the last update that was performed on the function.</p>
    #[serde(rename = "LastUpdateStatusReason")]
    #[serde(default)]
    pub last_update_status_reason: std::option::Option<std::string::String>,
    /// <p>The reason code for the last update that was performed on the function.</p>
    #[serde(rename = "LastUpdateStatusReasonCode")]
    #[serde(default)]
    pub last_update_status_reason_code:
        std::option::Option<crate::model::LastUpdateStatusReasonCode>,
    /// <p>Connection settings for an Amazon EFS file system.</p>
    #[serde(rename = "FileSystemConfigs")]
    #[serde(default)]
    pub file_system_configs: std::option::Option<std::vec::Vec<crate::model::FileSystemConfig>>,
    /// <p>The type of deployment package. Set to <code>Image</code> for container image and set <code>Zip</code> for .zip file archive.</p>
    #[serde(rename = "PackageType")]
    #[serde(default)]
    pub package_type: std::option::Option<crate::model::PackageType>,
    /// <p>The function's image configuration values.</p>
    #[serde(rename = "ImageConfigResponse")]
    #[serde(default)]
    pub image_config_response: std::option::Option<crate::model::ImageConfigResponse>,
    /// <p>The ARN of the signing profile version.</p>
    #[serde(rename = "SigningProfileVersionArn")]
    #[serde(default)]
    pub signing_profile_version_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the signing job.</p>
    #[serde(rename = "SigningJobArn")]
    #[serde(default)]
    pub signing_job_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateFunctionCodeOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateFunctionCodeOutputBody");
        formatter.field("function_name", &self.function_name);
        formatter.field("function_arn", &self.function_arn);
        formatter.field("runtime", &self.runtime);
        formatter.field("role", &self.role);
        formatter.field("handler", &self.handler);
        formatter.field("code_size", &self.code_size);
        formatter.field("description", &self.description);
        formatter.field("timeout", &self.timeout);
        formatter.field("memory_size", &self.memory_size);
        formatter.field("last_modified", &self.last_modified);
        formatter.field("code_sha256", &self.code_sha256);
        formatter.field("version", &self.version);
        formatter.field("vpc_config", &self.vpc_config);
        formatter.field("dead_letter_config", &self.dead_letter_config);
        formatter.field("environment", &self.environment);
        formatter.field("kms_key_arn", &self.kms_key_arn);
        formatter.field("tracing_config", &self.tracing_config);
        formatter.field("master_arn", &self.master_arn);
        formatter.field("revision_id", &self.revision_id);
        formatter.field("layers", &self.layers);
        formatter.field("state", &self.state);
        formatter.field("state_reason", &self.state_reason);
        formatter.field("state_reason_code", &self.state_reason_code);
        formatter.field("last_update_status", &self.last_update_status);
        formatter.field("last_update_status_reason", &self.last_update_status_reason);
        formatter.field(
            "last_update_status_reason_code",
            &self.last_update_status_reason_code,
        );
        formatter.field("file_system_configs", &self.file_system_configs);
        formatter.field("package_type", &self.package_type);
        formatter.field("image_config_response", &self.image_config_response);
        formatter.field(
            "signing_profile_version_arn",
            &self.signing_profile_version_arn,
        );
        formatter.field("signing_job_arn", &self.signing_job_arn);
        formatter.finish()
    }
}

/// <p>Details about a function's configuration.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateFunctionConfigurationOutputBody {
    /// <p>The name of the function.</p>
    #[serde(rename = "FunctionName")]
    #[serde(default)]
    pub function_name: std::option::Option<std::string::String>,
    /// <p>The function's Amazon Resource Name (ARN).</p>
    #[serde(rename = "FunctionArn")]
    #[serde(default)]
    pub function_arn: std::option::Option<std::string::String>,
    /// <p>The runtime environment for the Lambda function.</p>
    #[serde(rename = "Runtime")]
    #[serde(default)]
    pub runtime: std::option::Option<crate::model::Runtime>,
    /// <p>The function's execution role.</p>
    #[serde(rename = "Role")]
    #[serde(default)]
    pub role: std::option::Option<std::string::String>,
    /// <p>The function that Lambda calls to begin executing your function.</p>
    #[serde(rename = "Handler")]
    #[serde(default)]
    pub handler: std::option::Option<std::string::String>,
    /// <p>The size of the function's deployment package, in bytes.</p>
    #[serde(rename = "CodeSize")]
    #[serde(default)]
    pub code_size: i64,
    /// <p>The function's description.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The amount of time in seconds that Lambda allows a function to run before stopping it.</p>
    #[serde(rename = "Timeout")]
    #[serde(default)]
    pub timeout: std::option::Option<i32>,
    /// <p>The amount of memory available to the function at runtime. </p>
    #[serde(rename = "MemorySize")]
    #[serde(default)]
    pub memory_size: std::option::Option<i32>,
    /// <p>The date and time that the function was last updated, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format</a> (YYYY-MM-DDThh:mm:ss.sTZD).</p>
    #[serde(rename = "LastModified")]
    #[serde(default)]
    pub last_modified: std::option::Option<std::string::String>,
    /// <p>The SHA256 hash of the function's deployment package.</p>
    #[serde(rename = "CodeSha256")]
    #[serde(default)]
    pub code_sha256: std::option::Option<std::string::String>,
    /// <p>The version of the Lambda function.</p>
    #[serde(rename = "Version")]
    #[serde(default)]
    pub version: std::option::Option<std::string::String>,
    /// <p>The function's networking configuration.</p>
    #[serde(rename = "VpcConfig")]
    #[serde(default)]
    pub vpc_config: std::option::Option<crate::model::VpcConfigResponse>,
    /// <p>The function's dead letter queue.</p>
    #[serde(rename = "DeadLetterConfig")]
    #[serde(default)]
    pub dead_letter_config: std::option::Option<crate::model::DeadLetterConfig>,
    /// <p>The function's environment variables.</p>
    #[serde(rename = "Environment")]
    #[serde(default)]
    pub environment: std::option::Option<crate::model::EnvironmentResponse>,
    /// <p>The KMS key that's used to encrypt the function's environment variables. This key is only returned if you've
    /// configured a customer managed CMK.</p>
    #[serde(rename = "KMSKeyArn")]
    #[serde(default)]
    pub kms_key_arn: std::option::Option<std::string::String>,
    /// <p>The function's AWS X-Ray tracing configuration.</p>
    #[serde(rename = "TracingConfig")]
    #[serde(default)]
    pub tracing_config: std::option::Option<crate::model::TracingConfigResponse>,
    /// <p>For Lambda@Edge functions, the ARN of the master function.</p>
    #[serde(rename = "MasterArn")]
    #[serde(default)]
    pub master_arn: std::option::Option<std::string::String>,
    /// <p>The latest updated revision of the function or alias.</p>
    #[serde(rename = "RevisionId")]
    #[serde(default)]
    pub revision_id: std::option::Option<std::string::String>,
    /// <p>The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">
    /// layers</a>.</p>
    #[serde(rename = "Layers")]
    #[serde(default)]
    pub layers: std::option::Option<std::vec::Vec<crate::model::Layer>>,
    /// <p>The current state of the function. When the state is <code>Inactive</code>, you can reactivate the function by
    /// invoking it.</p>
    #[serde(rename = "State")]
    #[serde(default)]
    pub state: std::option::Option<crate::model::State>,
    /// <p>The reason for the function's current state.</p>
    #[serde(rename = "StateReason")]
    #[serde(default)]
    pub state_reason: std::option::Option<std::string::String>,
    /// <p>The reason code for the function's current state. When the code is <code>Creating</code>, you can't invoke or
    /// modify the function.</p>
    #[serde(rename = "StateReasonCode")]
    #[serde(default)]
    pub state_reason_code: std::option::Option<crate::model::StateReasonCode>,
    /// <p>The status of the last update that was performed on the function. This is first set to <code>Successful</code>
    /// after function creation completes.</p>
    #[serde(rename = "LastUpdateStatus")]
    #[serde(default)]
    pub last_update_status: std::option::Option<crate::model::LastUpdateStatus>,
    /// <p>The reason for the last update that was performed on the function.</p>
    #[serde(rename = "LastUpdateStatusReason")]
    #[serde(default)]
    pub last_update_status_reason: std::option::Option<std::string::String>,
    /// <p>The reason code for the last update that was performed on the function.</p>
    #[serde(rename = "LastUpdateStatusReasonCode")]
    #[serde(default)]
    pub last_update_status_reason_code:
        std::option::Option<crate::model::LastUpdateStatusReasonCode>,
    /// <p>Connection settings for an Amazon EFS file system.</p>
    #[serde(rename = "FileSystemConfigs")]
    #[serde(default)]
    pub file_system_configs: std::option::Option<std::vec::Vec<crate::model::FileSystemConfig>>,
    /// <p>The type of deployment package. Set to <code>Image</code> for container image and set <code>Zip</code> for .zip file archive.</p>
    #[serde(rename = "PackageType")]
    #[serde(default)]
    pub package_type: std::option::Option<crate::model::PackageType>,
    /// <p>The function's image configuration values.</p>
    #[serde(rename = "ImageConfigResponse")]
    #[serde(default)]
    pub image_config_response: std::option::Option<crate::model::ImageConfigResponse>,
    /// <p>The ARN of the signing profile version.</p>
    #[serde(rename = "SigningProfileVersionArn")]
    #[serde(default)]
    pub signing_profile_version_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the signing job.</p>
    #[serde(rename = "SigningJobArn")]
    #[serde(default)]
    pub signing_job_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateFunctionConfigurationOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateFunctionConfigurationOutputBody");
        formatter.field("function_name", &self.function_name);
        formatter.field("function_arn", &self.function_arn);
        formatter.field("runtime", &self.runtime);
        formatter.field("role", &self.role);
        formatter.field("handler", &self.handler);
        formatter.field("code_size", &self.code_size);
        formatter.field("description", &self.description);
        formatter.field("timeout", &self.timeout);
        formatter.field("memory_size", &self.memory_size);
        formatter.field("last_modified", &self.last_modified);
        formatter.field("code_sha256", &self.code_sha256);
        formatter.field("version", &self.version);
        formatter.field("vpc_config", &self.vpc_config);
        formatter.field("dead_letter_config", &self.dead_letter_config);
        formatter.field("environment", &self.environment);
        formatter.field("kms_key_arn", &self.kms_key_arn);
        formatter.field("tracing_config", &self.tracing_config);
        formatter.field("master_arn", &self.master_arn);
        formatter.field("revision_id", &self.revision_id);
        formatter.field("layers", &self.layers);
        formatter.field("state", &self.state);
        formatter.field("state_reason", &self.state_reason);
        formatter.field("state_reason_code", &self.state_reason_code);
        formatter.field("last_update_status", &self.last_update_status);
        formatter.field("last_update_status_reason", &self.last_update_status_reason);
        formatter.field(
            "last_update_status_reason_code",
            &self.last_update_status_reason_code,
        );
        formatter.field("file_system_configs", &self.file_system_configs);
        formatter.field("package_type", &self.package_type);
        formatter.field("image_config_response", &self.image_config_response);
        formatter.field(
            "signing_profile_version_arn",
            &self.signing_profile_version_arn,
        );
        formatter.field("signing_job_arn", &self.signing_job_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateFunctionEventInvokeConfigOutputBody {
    /// <p>The date and time that the configuration was last updated.</p>
    #[serde(rename = "LastModified")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_modified: std::option::Option<smithy_types::Instant>,
    /// <p>The Amazon Resource Name (ARN) of the function.</p>
    #[serde(rename = "FunctionArn")]
    #[serde(default)]
    pub function_arn: std::option::Option<std::string::String>,
    /// <p>The maximum number of times to retry when the function returns an error.</p>
    #[serde(rename = "MaximumRetryAttempts")]
    #[serde(default)]
    pub maximum_retry_attempts: std::option::Option<i32>,
    /// <p>The maximum age of a request that Lambda sends to a function for processing.</p>
    #[serde(rename = "MaximumEventAgeInSeconds")]
    #[serde(default)]
    pub maximum_event_age_in_seconds: std::option::Option<i32>,
    /// <p>A destination for events after they have been sent to a function for processing.</p>
    /// <p class="title">
    /// <b>Destinations</b>
    /// </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>Function</b> - The Amazon Resource Name (ARN) of a Lambda function.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Queue</b> - The ARN of an SQS queue.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Topic</b> - The ARN of an SNS topic.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Event Bus</b> - The ARN of an Amazon EventBridge event bus.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "DestinationConfig")]
    #[serde(default)]
    pub destination_config: std::option::Option<crate::model::DestinationConfig>,
}
impl std::fmt::Debug for UpdateFunctionEventInvokeConfigOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateFunctionEventInvokeConfigOutputBody");
        formatter.field("last_modified", &self.last_modified);
        formatter.field("function_arn", &self.function_arn);
        formatter.field("maximum_retry_attempts", &self.maximum_retry_attempts);
        formatter.field(
            "maximum_event_age_in_seconds",
            &self.maximum_event_age_in_seconds,
        );
        formatter.field("destination_config", &self.destination_config);
        formatter.finish()
    }
}
