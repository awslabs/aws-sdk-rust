// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(Debug)]
pub struct InvokeWithResponseStreamResponseEventUnmarshaller;

impl InvokeWithResponseStreamResponseEventUnmarshaller {
    pub fn new() -> Self {
        InvokeWithResponseStreamResponseEventUnmarshaller
    }
}
impl ::aws_smithy_eventstream::frame::UnmarshallMessage for InvokeWithResponseStreamResponseEventUnmarshaller {
    type Output = crate::types::InvokeWithResponseStreamResponseEvent;
    type Error = crate::types::error::InvokeWithResponseStreamResponseEventError;
    fn unmarshall(
        &self,
        message: &::aws_smithy_types::event_stream::Message,
    ) -> std::result::Result<::aws_smithy_eventstream::frame::UnmarshalledMessage<Self::Output, Self::Error>, ::aws_smithy_eventstream::error::Error>
    {
        let response_headers = ::aws_smithy_eventstream::smithy::parse_response_headers(message)?;
        match response_headers.message_type.as_str() {
            "event" => match response_headers.smithy_type.as_str() {
                "PayloadChunk" => {
                    let mut builder = crate::types::builders::InvokeResponseStreamUpdateBuilder::default();
                    let content_type = response_headers.content_type().unwrap_or_default();
                    if content_type != "application/octet-stream" {
                        return Err(::aws_smithy_eventstream::error::Error::unmarshalling(format!(
                            "expected :content-type to be 'application/octet-stream', but was '{}'",
                            content_type
                        )));
                    }
                    builder = builder.set_payload(Some(::aws_smithy_types::Blob::new(message.payload().as_ref())));
                    Ok(::aws_smithy_eventstream::frame::UnmarshalledMessage::Event(
                        crate::types::InvokeWithResponseStreamResponseEvent::PayloadChunk(builder.build()),
                    ))
                }
                "InvokeComplete" => {
                    let parsed =
                            crate::protocol_serde::shape_invoke_with_response_stream_complete_event::de_invoke_with_response_stream_complete_event_payload(&message.payload()[..])
                                            .map_err(|err| {
                                                ::aws_smithy_eventstream::error::Error::unmarshalling(format!("failed to unmarshall InvokeComplete: {}", err))
                                            })?
                        ;
                    Ok(::aws_smithy_eventstream::frame::UnmarshalledMessage::Event(
                        crate::types::InvokeWithResponseStreamResponseEvent::InvokeComplete(parsed),
                    ))
                }
                _unknown_variant => Ok(::aws_smithy_eventstream::frame::UnmarshalledMessage::Event(
                    crate::types::InvokeWithResponseStreamResponseEvent::Unknown,
                )),
            },
            "exception" => {
                let generic = match crate::protocol_serde::parse_event_stream_error_metadata(message.payload()) {
                    Ok(builder) => builder.build(),
                    Err(err) => {
                        return Ok(::aws_smithy_eventstream::frame::UnmarshalledMessage::Error(
                            crate::types::error::InvokeWithResponseStreamResponseEventError::unhandled(err),
                        ))
                    }
                };
                Ok(::aws_smithy_eventstream::frame::UnmarshalledMessage::Error(
                    crate::types::error::InvokeWithResponseStreamResponseEventError::generic(generic),
                ))
            }
            value => {
                return Err(::aws_smithy_eventstream::error::Error::unmarshalling(format!(
                    "unrecognized :message-type: {}",
                    value
                )));
            }
        }
    }
}
