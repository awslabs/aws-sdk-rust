// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn add_layer_version_permission(&self) -> fluent_builders::AddLayerVersionPermission<C> {
        fluent_builders::AddLayerVersionPermission::new(self.handle.clone())
    }
    pub fn add_permission(&self) -> fluent_builders::AddPermission<C> {
        fluent_builders::AddPermission::new(self.handle.clone())
    }
    pub fn create_alias(&self) -> fluent_builders::CreateAlias<C> {
        fluent_builders::CreateAlias::new(self.handle.clone())
    }
    pub fn create_code_signing_config(&self) -> fluent_builders::CreateCodeSigningConfig<C> {
        fluent_builders::CreateCodeSigningConfig::new(self.handle.clone())
    }
    pub fn create_event_source_mapping(&self) -> fluent_builders::CreateEventSourceMapping<C> {
        fluent_builders::CreateEventSourceMapping::new(self.handle.clone())
    }
    pub fn create_function(&self) -> fluent_builders::CreateFunction<C> {
        fluent_builders::CreateFunction::new(self.handle.clone())
    }
    pub fn delete_alias(&self) -> fluent_builders::DeleteAlias<C> {
        fluent_builders::DeleteAlias::new(self.handle.clone())
    }
    pub fn delete_code_signing_config(&self) -> fluent_builders::DeleteCodeSigningConfig<C> {
        fluent_builders::DeleteCodeSigningConfig::new(self.handle.clone())
    }
    pub fn delete_event_source_mapping(&self) -> fluent_builders::DeleteEventSourceMapping<C> {
        fluent_builders::DeleteEventSourceMapping::new(self.handle.clone())
    }
    pub fn delete_function(&self) -> fluent_builders::DeleteFunction<C> {
        fluent_builders::DeleteFunction::new(self.handle.clone())
    }
    pub fn delete_function_code_signing_config(
        &self,
    ) -> fluent_builders::DeleteFunctionCodeSigningConfig<C> {
        fluent_builders::DeleteFunctionCodeSigningConfig::new(self.handle.clone())
    }
    pub fn delete_function_concurrency(&self) -> fluent_builders::DeleteFunctionConcurrency<C> {
        fluent_builders::DeleteFunctionConcurrency::new(self.handle.clone())
    }
    pub fn delete_function_event_invoke_config(
        &self,
    ) -> fluent_builders::DeleteFunctionEventInvokeConfig<C> {
        fluent_builders::DeleteFunctionEventInvokeConfig::new(self.handle.clone())
    }
    pub fn delete_layer_version(&self) -> fluent_builders::DeleteLayerVersion<C> {
        fluent_builders::DeleteLayerVersion::new(self.handle.clone())
    }
    pub fn delete_provisioned_concurrency_config(
        &self,
    ) -> fluent_builders::DeleteProvisionedConcurrencyConfig<C> {
        fluent_builders::DeleteProvisionedConcurrencyConfig::new(self.handle.clone())
    }
    pub fn get_account_settings(&self) -> fluent_builders::GetAccountSettings<C> {
        fluent_builders::GetAccountSettings::new(self.handle.clone())
    }
    pub fn get_alias(&self) -> fluent_builders::GetAlias<C> {
        fluent_builders::GetAlias::new(self.handle.clone())
    }
    pub fn get_code_signing_config(&self) -> fluent_builders::GetCodeSigningConfig<C> {
        fluent_builders::GetCodeSigningConfig::new(self.handle.clone())
    }
    pub fn get_event_source_mapping(&self) -> fluent_builders::GetEventSourceMapping<C> {
        fluent_builders::GetEventSourceMapping::new(self.handle.clone())
    }
    pub fn get_function(&self) -> fluent_builders::GetFunction<C> {
        fluent_builders::GetFunction::new(self.handle.clone())
    }
    pub fn get_function_code_signing_config(
        &self,
    ) -> fluent_builders::GetFunctionCodeSigningConfig<C> {
        fluent_builders::GetFunctionCodeSigningConfig::new(self.handle.clone())
    }
    pub fn get_function_concurrency(&self) -> fluent_builders::GetFunctionConcurrency<C> {
        fluent_builders::GetFunctionConcurrency::new(self.handle.clone())
    }
    pub fn get_function_configuration(&self) -> fluent_builders::GetFunctionConfiguration<C> {
        fluent_builders::GetFunctionConfiguration::new(self.handle.clone())
    }
    pub fn get_function_event_invoke_config(
        &self,
    ) -> fluent_builders::GetFunctionEventInvokeConfig<C> {
        fluent_builders::GetFunctionEventInvokeConfig::new(self.handle.clone())
    }
    pub fn get_layer_version(&self) -> fluent_builders::GetLayerVersion<C> {
        fluent_builders::GetLayerVersion::new(self.handle.clone())
    }
    pub fn get_layer_version_by_arn(&self) -> fluent_builders::GetLayerVersionByArn<C> {
        fluent_builders::GetLayerVersionByArn::new(self.handle.clone())
    }
    pub fn get_layer_version_policy(&self) -> fluent_builders::GetLayerVersionPolicy<C> {
        fluent_builders::GetLayerVersionPolicy::new(self.handle.clone())
    }
    pub fn get_policy(&self) -> fluent_builders::GetPolicy<C> {
        fluent_builders::GetPolicy::new(self.handle.clone())
    }
    pub fn get_provisioned_concurrency_config(
        &self,
    ) -> fluent_builders::GetProvisionedConcurrencyConfig<C> {
        fluent_builders::GetProvisionedConcurrencyConfig::new(self.handle.clone())
    }
    pub fn invoke(&self) -> fluent_builders::Invoke<C> {
        fluent_builders::Invoke::new(self.handle.clone())
    }
    pub fn invoke_async(&self) -> fluent_builders::InvokeAsync<C> {
        fluent_builders::InvokeAsync::new(self.handle.clone())
    }
    pub fn list_aliases(&self) -> fluent_builders::ListAliases<C> {
        fluent_builders::ListAliases::new(self.handle.clone())
    }
    pub fn list_code_signing_configs(&self) -> fluent_builders::ListCodeSigningConfigs<C> {
        fluent_builders::ListCodeSigningConfigs::new(self.handle.clone())
    }
    pub fn list_event_source_mappings(&self) -> fluent_builders::ListEventSourceMappings<C> {
        fluent_builders::ListEventSourceMappings::new(self.handle.clone())
    }
    pub fn list_function_event_invoke_configs(
        &self,
    ) -> fluent_builders::ListFunctionEventInvokeConfigs<C> {
        fluent_builders::ListFunctionEventInvokeConfigs::new(self.handle.clone())
    }
    pub fn list_functions(&self) -> fluent_builders::ListFunctions<C> {
        fluent_builders::ListFunctions::new(self.handle.clone())
    }
    pub fn list_functions_by_code_signing_config(
        &self,
    ) -> fluent_builders::ListFunctionsByCodeSigningConfig<C> {
        fluent_builders::ListFunctionsByCodeSigningConfig::new(self.handle.clone())
    }
    pub fn list_layers(&self) -> fluent_builders::ListLayers<C> {
        fluent_builders::ListLayers::new(self.handle.clone())
    }
    pub fn list_layer_versions(&self) -> fluent_builders::ListLayerVersions<C> {
        fluent_builders::ListLayerVersions::new(self.handle.clone())
    }
    pub fn list_provisioned_concurrency_configs(
        &self,
    ) -> fluent_builders::ListProvisionedConcurrencyConfigs<C> {
        fluent_builders::ListProvisionedConcurrencyConfigs::new(self.handle.clone())
    }
    pub fn list_tags(&self) -> fluent_builders::ListTags<C> {
        fluent_builders::ListTags::new(self.handle.clone())
    }
    pub fn list_versions_by_function(&self) -> fluent_builders::ListVersionsByFunction<C> {
        fluent_builders::ListVersionsByFunction::new(self.handle.clone())
    }
    pub fn publish_layer_version(&self) -> fluent_builders::PublishLayerVersion<C> {
        fluent_builders::PublishLayerVersion::new(self.handle.clone())
    }
    pub fn publish_version(&self) -> fluent_builders::PublishVersion<C> {
        fluent_builders::PublishVersion::new(self.handle.clone())
    }
    pub fn put_function_code_signing_config(
        &self,
    ) -> fluent_builders::PutFunctionCodeSigningConfig<C> {
        fluent_builders::PutFunctionCodeSigningConfig::new(self.handle.clone())
    }
    pub fn put_function_concurrency(&self) -> fluent_builders::PutFunctionConcurrency<C> {
        fluent_builders::PutFunctionConcurrency::new(self.handle.clone())
    }
    pub fn put_function_event_invoke_config(
        &self,
    ) -> fluent_builders::PutFunctionEventInvokeConfig<C> {
        fluent_builders::PutFunctionEventInvokeConfig::new(self.handle.clone())
    }
    pub fn put_provisioned_concurrency_config(
        &self,
    ) -> fluent_builders::PutProvisionedConcurrencyConfig<C> {
        fluent_builders::PutProvisionedConcurrencyConfig::new(self.handle.clone())
    }
    pub fn remove_layer_version_permission(
        &self,
    ) -> fluent_builders::RemoveLayerVersionPermission<C> {
        fluent_builders::RemoveLayerVersionPermission::new(self.handle.clone())
    }
    pub fn remove_permission(&self) -> fluent_builders::RemovePermission<C> {
        fluent_builders::RemovePermission::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_alias(&self) -> fluent_builders::UpdateAlias<C> {
        fluent_builders::UpdateAlias::new(self.handle.clone())
    }
    pub fn update_code_signing_config(&self) -> fluent_builders::UpdateCodeSigningConfig<C> {
        fluent_builders::UpdateCodeSigningConfig::new(self.handle.clone())
    }
    pub fn update_event_source_mapping(&self) -> fluent_builders::UpdateEventSourceMapping<C> {
        fluent_builders::UpdateEventSourceMapping::new(self.handle.clone())
    }
    pub fn update_function_code(&self) -> fluent_builders::UpdateFunctionCode<C> {
        fluent_builders::UpdateFunctionCode::new(self.handle.clone())
    }
    pub fn update_function_configuration(&self) -> fluent_builders::UpdateFunctionConfiguration<C> {
        fluent_builders::UpdateFunctionConfiguration::new(self.handle.clone())
    }
    pub fn update_function_event_invoke_config(
        &self,
    ) -> fluent_builders::UpdateFunctionEventInvokeConfig<C> {
        fluent_builders::UpdateFunctionEventInvokeConfig::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AddLayerVersionPermission<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::add_layer_version_permission_input::Builder,
    }
    impl<C> AddLayerVersionPermission<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::AddLayerVersionPermissionOutput,
            smithy_http::result::SdkError<crate::error::AddLayerVersionPermissionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name or Amazon Resource Name (ARN) of the layer.</p>
        pub fn layer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.layer_name(inp);
            self
        }
        pub fn set_layer_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_layer_name(inp);
            self
        }
        /// <p>The version number.</p>
        pub fn version_number(mut self, inp: i64) -> Self {
            self.inner = self.inner.version_number(inp);
            self
        }
        pub fn set_version_number(mut self, inp: i64) -> Self {
            self.inner = self.inner.set_version_number(inp);
            self
        }
        /// <p>An identifier that distinguishes the policy from others on the same layer version.</p>
        pub fn statement_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.statement_id(inp);
            self
        }
        pub fn set_statement_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_statement_id(inp);
            self
        }
        /// <p>The API action that grants access to the layer. For example, <code>lambda:GetLayerVersion</code>.</p>
        pub fn action(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.action(inp);
            self
        }
        pub fn set_action(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_action(inp);
            self
        }
        /// <p>An account ID, or <code>*</code> to grant permission to all AWS accounts.</p>
        pub fn principal(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.principal(inp);
            self
        }
        pub fn set_principal(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_principal(inp);
            self
        }
        /// <p>With the principal set to <code>*</code>, grant permission to all accounts in the specified
        /// organization.</p>
        pub fn organization_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.organization_id(inp);
            self
        }
        pub fn set_organization_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_organization_id(inp);
            self
        }
        /// <p>Only update the policy if the revision ID matches the ID specified. Use this option to avoid modifying a
        /// policy that has changed since you last read it.</p>
        pub fn revision_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.revision_id(inp);
            self
        }
        pub fn set_revision_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_revision_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AddPermission<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::add_permission_input::Builder,
    }
    impl<C> AddPermission<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::AddPermissionOutput,
            smithy_http::result::SdkError<crate::error::AddPermissionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Lambda function, version, or alias.</p>
        /// <p class="title">
        /// <b>Name formats</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function name</b> - <code>my-function</code> (name-only), <code>my-function:v1</code> (with alias).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
        /// </li>
        /// </ul>
        /// <p>You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN.
        /// If you specify only the function name, it is limited to 64 characters in length.</p>
        pub fn function_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(inp);
            self
        }
        pub fn set_function_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_function_name(inp);
            self
        }
        /// <p>A statement identifier that differentiates the statement from others in the same policy.</p>
        pub fn statement_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.statement_id(inp);
            self
        }
        pub fn set_statement_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_statement_id(inp);
            self
        }
        /// <p>The action that the principal can use on the function. For example, <code>lambda:InvokeFunction</code> or
        /// <code>lambda:GetFunction</code>.</p>
        pub fn action(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.action(inp);
            self
        }
        pub fn set_action(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_action(inp);
            self
        }
        /// <p>The AWS service or account that invokes the function. If you specify a service, use <code>SourceArn</code> or
        /// <code>SourceAccount</code> to limit who can invoke the function through that service.</p>
        pub fn principal(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.principal(inp);
            self
        }
        pub fn set_principal(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_principal(inp);
            self
        }
        /// <p>For AWS services, the ARN of the AWS resource that invokes the function. For example, an Amazon S3 bucket or
        /// Amazon SNS topic.</p>
        pub fn source_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_arn(inp);
            self
        }
        pub fn set_source_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_source_arn(inp);
            self
        }
        /// <p>For Amazon S3, the ID of the account that owns the resource. Use this together with <code>SourceArn</code> to
        /// ensure that the resource is owned by the specified account. It is possible for an Amazon S3 bucket to be deleted
        /// by its owner and recreated by another account.</p>
        pub fn source_account(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_account(inp);
            self
        }
        pub fn set_source_account(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_source_account(inp);
            self
        }
        /// <p>For Alexa Smart Home functions, a token that must be supplied by the invoker.</p>
        pub fn event_source_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.event_source_token(inp);
            self
        }
        pub fn set_event_source_token(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_event_source_token(inp);
            self
        }
        /// <p>Specify a version or alias to add permissions to a published version of the function.</p>
        pub fn qualifier(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.qualifier(inp);
            self
        }
        pub fn set_qualifier(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_qualifier(inp);
            self
        }
        /// <p>Only update the policy if the revision ID matches the ID that's specified. Use this option to avoid modifying a
        /// policy that has changed since you last read it.</p>
        pub fn revision_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.revision_id(inp);
            self
        }
        pub fn set_revision_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_revision_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateAlias<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_alias_input::Builder,
    }
    impl<C> CreateAlias<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateAliasOutput,
            smithy_http::result::SdkError<crate::error::CreateAliasError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Lambda function.</p>
        /// <p class="title">
        /// <b>Name formats</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function name</b> - <code>MyFunction</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Partial ARN</b> - <code>123456789012:function:MyFunction</code>.</p>
        /// </li>
        /// </ul>
        /// <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
        /// characters in length.</p>
        pub fn function_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(inp);
            self
        }
        pub fn set_function_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_function_name(inp);
            self
        }
        /// <p>The name of the alias.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>The function version that the alias invokes.</p>
        pub fn function_version(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_version(inp);
            self
        }
        pub fn set_function_version(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_function_version(inp);
            self
        }
        /// <p>A description of the alias.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(inp);
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html#configuring-alias-routing">routing
        /// configuration</a> of the alias.</p>
        pub fn routing_config(mut self, inp: crate::model::AliasRoutingConfiguration) -> Self {
            self.inner = self.inner.routing_config(inp);
            self
        }
        pub fn set_routing_config(
            mut self,
            inp: std::option::Option<crate::model::AliasRoutingConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_routing_config(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateCodeSigningConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_code_signing_config_input::Builder,
    }
    impl<C> CreateCodeSigningConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateCodeSigningConfigOutput,
            smithy_http::result::SdkError<crate::error::CreateCodeSigningConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Descriptive name for this code signing configuration.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(inp);
            self
        }
        /// <p>Signing profiles for this code signing configuration.</p>
        pub fn allowed_publishers(mut self, inp: crate::model::AllowedPublishers) -> Self {
            self.inner = self.inner.allowed_publishers(inp);
            self
        }
        pub fn set_allowed_publishers(
            mut self,
            inp: std::option::Option<crate::model::AllowedPublishers>,
        ) -> Self {
            self.inner = self.inner.set_allowed_publishers(inp);
            self
        }
        /// <p>The code signing policies define the actions to take if the validation checks fail. </p>
        pub fn code_signing_policies(mut self, inp: crate::model::CodeSigningPolicies) -> Self {
            self.inner = self.inner.code_signing_policies(inp);
            self
        }
        pub fn set_code_signing_policies(
            mut self,
            inp: std::option::Option<crate::model::CodeSigningPolicies>,
        ) -> Self {
            self.inner = self.inner.set_code_signing_policies(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateEventSourceMapping<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_event_source_mapping_input::Builder,
    }
    impl<C> CreateEventSourceMapping<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateEventSourceMappingOutput,
            smithy_http::result::SdkError<crate::error::CreateEventSourceMappingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the event source.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Amazon Kinesis</b> - The ARN of the data stream or a stream consumer.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Amazon DynamoDB Streams</b> - The ARN of the stream.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Amazon Simple Queue Service</b> - The ARN of the queue.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Amazon Managed Streaming for Apache Kafka</b> - The ARN of the cluster.</p>
        /// </li>
        /// </ul>
        pub fn event_source_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.event_source_arn(inp);
            self
        }
        pub fn set_event_source_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_event_source_arn(inp);
            self
        }
        /// <p>The name of the Lambda function.</p>
        /// <p class="title">
        /// <b>Name formats</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function name</b> - <code>MyFunction</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Version or Alias ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction:PROD</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Partial ARN</b> - <code>123456789012:function:MyFunction</code>.</p>
        /// </li>
        /// </ul>
        /// <p>The length constraint applies only to the full ARN. If you specify only the function name, it's limited to 64
        /// characters in length.</p>
        pub fn function_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(inp);
            self
        }
        pub fn set_function_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_function_name(inp);
            self
        }
        /// <p>If true, the event source mapping is active. Set to false to pause polling and invocation.</p>
        pub fn enabled(mut self, inp: bool) -> Self {
            self.inner = self.inner.enabled(inp);
            self
        }
        pub fn set_enabled(mut self, inp: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_enabled(inp);
            self
        }
        /// <p>The maximum number of items to retrieve in a single batch.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Amazon Kinesis</b> - Default 100. Max 10,000.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Amazon DynamoDB Streams</b> - Default 100. Max 1,000.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Amazon Simple Queue Service</b> - Default 10. For standard queues the max is 10,000. For FIFO queues the max is 10.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Amazon Managed Streaming for Apache Kafka</b> - Default 100. Max 10,000.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Self-Managed Apache Kafka</b> - Default 100. Max 10,000.</p>
        /// </li>
        /// </ul>
        pub fn batch_size(mut self, inp: i32) -> Self {
            self.inner = self.inner.batch_size(inp);
            self
        }
        pub fn set_batch_size(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_batch_size(inp);
            self
        }
        /// <p>(Streams and SQS standard queues) The maximum amount of time to gather records before invoking the function, in seconds.</p>
        pub fn maximum_batching_window_in_seconds(mut self, inp: i32) -> Self {
            self.inner = self.inner.maximum_batching_window_in_seconds(inp);
            self
        }
        pub fn set_maximum_batching_window_in_seconds(
            mut self,
            inp: std::option::Option<i32>,
        ) -> Self {
            self.inner = self.inner.set_maximum_batching_window_in_seconds(inp);
            self
        }
        /// <p>(Streams) The number of batches to process from each shard concurrently.</p>
        pub fn parallelization_factor(mut self, inp: i32) -> Self {
            self.inner = self.inner.parallelization_factor(inp);
            self
        }
        pub fn set_parallelization_factor(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_parallelization_factor(inp);
            self
        }
        /// <p>The position in a stream from which to start reading. Required for Amazon Kinesis, Amazon DynamoDB, and Amazon MSK Streams
        /// sources. <code>AT_TIMESTAMP</code> is only supported for Amazon Kinesis streams.</p>
        pub fn starting_position(mut self, inp: crate::model::EventSourcePosition) -> Self {
            self.inner = self.inner.starting_position(inp);
            self
        }
        pub fn set_starting_position(
            mut self,
            inp: std::option::Option<crate::model::EventSourcePosition>,
        ) -> Self {
            self.inner = self.inner.set_starting_position(inp);
            self
        }
        /// <p>With <code>StartingPosition</code> set to <code>AT_TIMESTAMP</code>, the time from which to start
        /// reading.</p>
        pub fn starting_position_timestamp(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.starting_position_timestamp(inp);
            self
        }
        pub fn set_starting_position_timestamp(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_starting_position_timestamp(inp);
            self
        }
        /// <p>(Streams) An Amazon SQS queue or Amazon SNS topic destination for discarded records.</p>
        pub fn destination_config(mut self, inp: crate::model::DestinationConfig) -> Self {
            self.inner = self.inner.destination_config(inp);
            self
        }
        pub fn set_destination_config(
            mut self,
            inp: std::option::Option<crate::model::DestinationConfig>,
        ) -> Self {
            self.inner = self.inner.set_destination_config(inp);
            self
        }
        /// <p>(Streams) Discard records older than the specified age. The default value is infinite (-1).</p>
        pub fn maximum_record_age_in_seconds(mut self, inp: i32) -> Self {
            self.inner = self.inner.maximum_record_age_in_seconds(inp);
            self
        }
        pub fn set_maximum_record_age_in_seconds(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_maximum_record_age_in_seconds(inp);
            self
        }
        /// <p>(Streams) If the function returns an error, split the batch in two and retry.</p>
        pub fn bisect_batch_on_function_error(mut self, inp: bool) -> Self {
            self.inner = self.inner.bisect_batch_on_function_error(inp);
            self
        }
        pub fn set_bisect_batch_on_function_error(
            mut self,
            inp: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_bisect_batch_on_function_error(inp);
            self
        }
        /// <p>(Streams) Discard records after the specified number of retries. The default value is infinite (-1). When set to infinite (-1), failed records will be retried until the record expires.</p>
        pub fn maximum_retry_attempts(mut self, inp: i32) -> Self {
            self.inner = self.inner.maximum_retry_attempts(inp);
            self
        }
        pub fn set_maximum_retry_attempts(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_maximum_retry_attempts(inp);
            self
        }
        /// <p>(Streams) The duration in seconds of a processing window. The range is between 1 second up to 900 seconds.</p>
        pub fn tumbling_window_in_seconds(mut self, inp: i32) -> Self {
            self.inner = self.inner.tumbling_window_in_seconds(inp);
            self
        }
        pub fn set_tumbling_window_in_seconds(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_tumbling_window_in_seconds(inp);
            self
        }
        /// <p>The name of the Kafka topic.</p>
        pub fn topics(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.topics(inp);
            self
        }
        pub fn set_topics(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_topics(inp);
            self
        }
        /// <p>
        /// (MQ) The name of the Amazon MQ broker destination queue to consume.
        /// </p>
        pub fn queues(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.queues(inp);
            self
        }
        pub fn set_queues(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_queues(inp);
            self
        }
        /// <p>An array of the authentication protocol, or the VPC components to secure your event source.</p>
        pub fn source_access_configurations(
            mut self,
            inp: impl Into<crate::model::SourceAccessConfiguration>,
        ) -> Self {
            self.inner = self.inner.source_access_configurations(inp);
            self
        }
        pub fn set_source_access_configurations(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::SourceAccessConfiguration>>,
        ) -> Self {
            self.inner = self.inner.set_source_access_configurations(inp);
            self
        }
        /// <p>The Self-Managed Apache Kafka cluster to send records.</p>
        pub fn self_managed_event_source(
            mut self,
            inp: crate::model::SelfManagedEventSource,
        ) -> Self {
            self.inner = self.inner.self_managed_event_source(inp);
            self
        }
        pub fn set_self_managed_event_source(
            mut self,
            inp: std::option::Option<crate::model::SelfManagedEventSource>,
        ) -> Self {
            self.inner = self.inner.set_self_managed_event_source(inp);
            self
        }
        /// <p>(Streams) A list of current response type enums applied to the event source mapping.</p>
        pub fn function_response_types(
            mut self,
            inp: impl Into<crate::model::FunctionResponseType>,
        ) -> Self {
            self.inner = self.inner.function_response_types(inp);
            self
        }
        pub fn set_function_response_types(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::FunctionResponseType>>,
        ) -> Self {
            self.inner = self.inner.set_function_response_types(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateFunction<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_function_input::Builder,
    }
    impl<C> CreateFunction<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateFunctionOutput,
            smithy_http::result::SdkError<crate::error::CreateFunctionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Lambda function.</p>
        /// <p class="title">
        /// <b>Name formats</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function name</b> - <code>my-function</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
        /// </li>
        /// </ul>
        /// <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
        /// characters in length.</p>
        pub fn function_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(inp);
            self
        }
        pub fn set_function_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_function_name(inp);
            self
        }
        /// <p>The identifier of the function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html">runtime</a>.</p>
        pub fn runtime(mut self, inp: crate::model::Runtime) -> Self {
            self.inner = self.inner.runtime(inp);
            self
        }
        pub fn set_runtime(mut self, inp: std::option::Option<crate::model::Runtime>) -> Self {
            self.inner = self.inner.set_runtime(inp);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the function's execution role.</p>
        pub fn role(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role(inp);
            self
        }
        pub fn set_role(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role(inp);
            self
        }
        /// <p>The name of the method within your code that Lambda calls to execute your function. The format includes the
        /// file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information,
        /// see <a href="https://docs.aws.amazon.com/lambda/latest/dg/programming-model-v2.html">Programming Model</a>.</p>
        pub fn handler(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.handler(inp);
            self
        }
        pub fn set_handler(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_handler(inp);
            self
        }
        /// <p>The code for the function.</p>
        pub fn code(mut self, inp: crate::model::FunctionCode) -> Self {
            self.inner = self.inner.code(inp);
            self
        }
        pub fn set_code(mut self, inp: std::option::Option<crate::model::FunctionCode>) -> Self {
            self.inner = self.inner.set_code(inp);
            self
        }
        /// <p>A description of the function.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(inp);
            self
        }
        /// <p>The amount of time that Lambda allows a function to run before stopping it. The default is 3 seconds. The
        /// maximum allowed value is 900 seconds.</p>
        pub fn timeout(mut self, inp: i32) -> Self {
            self.inner = self.inner.timeout(inp);
            self
        }
        pub fn set_timeout(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_timeout(inp);
            self
        }
        /// <p>The amount of memory available to the function at runtime. Increasing the function's memory also increases its CPU
        /// allocation. The default value is 128 MB. The value can be any multiple of 1 MB.</p>
        pub fn memory_size(mut self, inp: i32) -> Self {
            self.inner = self.inner.memory_size(inp);
            self
        }
        pub fn set_memory_size(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_memory_size(inp);
            self
        }
        /// <p>Set to true to publish the first version of the function during creation.</p>
        pub fn publish(mut self, inp: bool) -> Self {
            self.inner = self.inner.publish(inp);
            self
        }
        pub fn set_publish(mut self, inp: bool) -> Self {
            self.inner = self.inner.set_publish(inp);
            self
        }
        /// <p>For network connectivity to AWS resources in a VPC, specify a list of security groups and subnets in the VPC.
        /// When you connect a function to a VPC, it can only access resources and the internet through that VPC. For more
        /// information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html">VPC Settings</a>.</p>
        pub fn vpc_config(mut self, inp: crate::model::VpcConfig) -> Self {
            self.inner = self.inner.vpc_config(inp);
            self
        }
        pub fn set_vpc_config(mut self, inp: std::option::Option<crate::model::VpcConfig>) -> Self {
            self.inner = self.inner.set_vpc_config(inp);
            self
        }
        /// <p>The type of deployment package. Set to <code>Image</code> for container image and set <code>Zip</code> for ZIP archive.</p>
        pub fn package_type(mut self, inp: crate::model::PackageType) -> Self {
            self.inner = self.inner.package_type(inp);
            self
        }
        pub fn set_package_type(
            mut self,
            inp: std::option::Option<crate::model::PackageType>,
        ) -> Self {
            self.inner = self.inner.set_package_type(inp);
            self
        }
        /// <p>A dead letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events
        /// when they fail processing. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#dlq">Dead Letter Queues</a>.</p>
        pub fn dead_letter_config(mut self, inp: crate::model::DeadLetterConfig) -> Self {
            self.inner = self.inner.dead_letter_config(inp);
            self
        }
        pub fn set_dead_letter_config(
            mut self,
            inp: std::option::Option<crate::model::DeadLetterConfig>,
        ) -> Self {
            self.inner = self.inner.set_dead_letter_config(inp);
            self
        }
        /// <p>Environment variables that are accessible from function code during execution.</p>
        pub fn environment(mut self, inp: crate::model::Environment) -> Self {
            self.inner = self.inner.environment(inp);
            self
        }
        pub fn set_environment(
            mut self,
            inp: std::option::Option<crate::model::Environment>,
        ) -> Self {
            self.inner = self.inner.set_environment(inp);
            self
        }
        /// <p>The ARN of the AWS Key Management Service (AWS KMS) key that's used to encrypt your function's environment
        /// variables. If it's not provided, AWS Lambda uses a default service key.</p>
        pub fn kms_key_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key_arn(inp);
            self
        }
        pub fn set_kms_key_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key_arn(inp);
            self
        }
        /// <p>Set <code>Mode</code> to <code>Active</code> to sample and trace a subset of incoming requests with AWS
        /// X-Ray.</p>
        pub fn tracing_config(mut self, inp: crate::model::TracingConfig) -> Self {
            self.inner = self.inner.tracing_config(inp);
            self
        }
        pub fn set_tracing_config(
            mut self,
            inp: std::option::Option<crate::model::TracingConfig>,
        ) -> Self {
            self.inner = self.inner.set_tracing_config(inp);
            self
        }
        /// <p>A list of <a href="https://docs.aws.amazon.com/lambda/latest/dg/tagging.html">tags</a> to apply to the
        /// function.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
        /// <p>A list of <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">function layers</a>
        /// to add to the function's execution environment. Specify each layer by its ARN, including the version.</p>
        pub fn layers(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.layers(inp);
            self
        }
        pub fn set_layers(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_layers(inp);
            self
        }
        /// <p>Connection settings for an Amazon EFS file system.</p>
        pub fn file_system_configs(
            mut self,
            inp: impl Into<crate::model::FileSystemConfig>,
        ) -> Self {
            self.inner = self.inner.file_system_configs(inp);
            self
        }
        pub fn set_file_system_configs(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::FileSystemConfig>>,
        ) -> Self {
            self.inner = self.inner.set_file_system_configs(inp);
            self
        }
        /// <p>
        /// <a href="https://docs.aws.amazon.com/lambda/latest/dg/images-parms.html">Container image configuration
        /// values</a> that override the values in the container image Dockerfile.</p>
        pub fn image_config(mut self, inp: crate::model::ImageConfig) -> Self {
            self.inner = self.inner.image_config(inp);
            self
        }
        pub fn set_image_config(
            mut self,
            inp: std::option::Option<crate::model::ImageConfig>,
        ) -> Self {
            self.inner = self.inner.set_image_config(inp);
            self
        }
        /// <p>To enable code signing for this function, specify the ARN of a code-signing configuration. A code-signing configuration
        /// includes a set of signing profiles, which define the trusted publishers for this function.</p>
        pub fn code_signing_config_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.code_signing_config_arn(inp);
            self
        }
        pub fn set_code_signing_config_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_code_signing_config_arn(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteAlias<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_alias_input::Builder,
    }
    impl<C> DeleteAlias<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteAliasOutput,
            smithy_http::result::SdkError<crate::error::DeleteAliasError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Lambda function.</p>
        /// <p class="title">
        /// <b>Name formats</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function name</b> - <code>MyFunction</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Partial ARN</b> - <code>123456789012:function:MyFunction</code>.</p>
        /// </li>
        /// </ul>
        /// <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
        /// characters in length.</p>
        pub fn function_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(inp);
            self
        }
        pub fn set_function_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_function_name(inp);
            self
        }
        /// <p>The name of the alias.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteCodeSigningConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_code_signing_config_input::Builder,
    }
    impl<C> DeleteCodeSigningConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteCodeSigningConfigOutput,
            smithy_http::result::SdkError<crate::error::DeleteCodeSigningConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The The Amazon Resource Name (ARN) of the code signing configuration.</p>
        pub fn code_signing_config_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.code_signing_config_arn(inp);
            self
        }
        pub fn set_code_signing_config_arn(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_code_signing_config_arn(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteEventSourceMapping<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_event_source_mapping_input::Builder,
    }
    impl<C> DeleteEventSourceMapping<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteEventSourceMappingOutput,
            smithy_http::result::SdkError<crate::error::DeleteEventSourceMappingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the event source mapping.</p>
        pub fn uuid(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.uuid(inp);
            self
        }
        pub fn set_uuid(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_uuid(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteFunction<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_function_input::Builder,
    }
    impl<C> DeleteFunction<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteFunctionOutput,
            smithy_http::result::SdkError<crate::error::DeleteFunctionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Lambda function or version.</p>
        /// <p class="title">
        /// <b>Name formats</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function name</b> - <code>my-function</code> (name-only), <code>my-function:1</code> (with version).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
        /// </li>
        /// </ul>
        /// <p>You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN.
        /// If you specify only the function name, it is limited to 64 characters in length.</p>
        pub fn function_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(inp);
            self
        }
        pub fn set_function_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_function_name(inp);
            self
        }
        /// <p>Specify a version to delete. You can't delete a version that's referenced by an alias.</p>
        pub fn qualifier(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.qualifier(inp);
            self
        }
        pub fn set_qualifier(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_qualifier(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteFunctionCodeSigningConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_function_code_signing_config_input::Builder,
    }
    impl<C> DeleteFunctionCodeSigningConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteFunctionCodeSigningConfigOutput,
            smithy_http::result::SdkError<crate::error::DeleteFunctionCodeSigningConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Lambda function.</p>
        /// <p class="title">
        /// <b>Name formats</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function name</b> - <code>MyFunction</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Partial ARN</b> - <code>123456789012:function:MyFunction</code>.</p>
        /// </li>
        /// </ul>
        /// <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
        /// characters in length.</p>
        pub fn function_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(inp);
            self
        }
        pub fn set_function_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_function_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteFunctionConcurrency<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_function_concurrency_input::Builder,
    }
    impl<C> DeleteFunctionConcurrency<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteFunctionConcurrencyOutput,
            smithy_http::result::SdkError<crate::error::DeleteFunctionConcurrencyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Lambda function.</p>
        /// <p class="title">
        /// <b>Name formats</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function name</b> - <code>my-function</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
        /// </li>
        /// </ul>
        /// <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
        /// characters in length.</p>
        pub fn function_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(inp);
            self
        }
        pub fn set_function_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_function_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteFunctionEventInvokeConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_function_event_invoke_config_input::Builder,
    }
    impl<C> DeleteFunctionEventInvokeConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteFunctionEventInvokeConfigOutput,
            smithy_http::result::SdkError<crate::error::DeleteFunctionEventInvokeConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Lambda function, version, or alias.</p>
        /// <p class="title">
        /// <b>Name formats</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function name</b> - <code>my-function</code> (name-only), <code>my-function:v1</code> (with alias).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
        /// </li>
        /// </ul>
        /// <p>You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN.
        /// If you specify only the function name, it is limited to 64 characters in length.</p>
        pub fn function_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(inp);
            self
        }
        pub fn set_function_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_function_name(inp);
            self
        }
        /// <p>A version number or alias name.</p>
        pub fn qualifier(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.qualifier(inp);
            self
        }
        pub fn set_qualifier(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_qualifier(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteLayerVersion<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_layer_version_input::Builder,
    }
    impl<C> DeleteLayerVersion<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteLayerVersionOutput,
            smithy_http::result::SdkError<crate::error::DeleteLayerVersionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name or Amazon Resource Name (ARN) of the layer.</p>
        pub fn layer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.layer_name(inp);
            self
        }
        pub fn set_layer_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_layer_name(inp);
            self
        }
        /// <p>The version number.</p>
        pub fn version_number(mut self, inp: i64) -> Self {
            self.inner = self.inner.version_number(inp);
            self
        }
        pub fn set_version_number(mut self, inp: i64) -> Self {
            self.inner = self.inner.set_version_number(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteProvisionedConcurrencyConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_provisioned_concurrency_config_input::Builder,
    }
    impl<C> DeleteProvisionedConcurrencyConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteProvisionedConcurrencyConfigOutput,
            smithy_http::result::SdkError<crate::error::DeleteProvisionedConcurrencyConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Lambda function.</p>
        /// <p class="title">
        /// <b>Name formats</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function name</b> - <code>my-function</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
        /// </li>
        /// </ul>
        /// <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
        /// characters in length.</p>
        pub fn function_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(inp);
            self
        }
        pub fn set_function_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_function_name(inp);
            self
        }
        /// <p>The version number or alias name.</p>
        pub fn qualifier(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.qualifier(inp);
            self
        }
        pub fn set_qualifier(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_qualifier(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetAccountSettings<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_account_settings_input::Builder,
    }
    impl<C> GetAccountSettings<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetAccountSettingsOutput,
            smithy_http::result::SdkError<crate::error::GetAccountSettingsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetAlias<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_alias_input::Builder,
    }
    impl<C> GetAlias<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetAliasOutput,
            smithy_http::result::SdkError<crate::error::GetAliasError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Lambda function.</p>
        /// <p class="title">
        /// <b>Name formats</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function name</b> - <code>MyFunction</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Partial ARN</b> - <code>123456789012:function:MyFunction</code>.</p>
        /// </li>
        /// </ul>
        /// <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
        /// characters in length.</p>
        pub fn function_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(inp);
            self
        }
        pub fn set_function_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_function_name(inp);
            self
        }
        /// <p>The name of the alias.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetCodeSigningConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_code_signing_config_input::Builder,
    }
    impl<C> GetCodeSigningConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetCodeSigningConfigOutput,
            smithy_http::result::SdkError<crate::error::GetCodeSigningConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The The Amazon Resource Name (ARN) of the code signing configuration. </p>
        pub fn code_signing_config_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.code_signing_config_arn(inp);
            self
        }
        pub fn set_code_signing_config_arn(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_code_signing_config_arn(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetEventSourceMapping<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_event_source_mapping_input::Builder,
    }
    impl<C> GetEventSourceMapping<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetEventSourceMappingOutput,
            smithy_http::result::SdkError<crate::error::GetEventSourceMappingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the event source mapping.</p>
        pub fn uuid(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.uuid(inp);
            self
        }
        pub fn set_uuid(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_uuid(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetFunction<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_function_input::Builder,
    }
    impl<C> GetFunction<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetFunctionOutput,
            smithy_http::result::SdkError<crate::error::GetFunctionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Lambda function, version, or alias.</p>
        /// <p class="title">
        /// <b>Name formats</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function name</b> - <code>my-function</code> (name-only), <code>my-function:v1</code> (with alias).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
        /// </li>
        /// </ul>
        /// <p>You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN.
        /// If you specify only the function name, it is limited to 64 characters in length.</p>
        pub fn function_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(inp);
            self
        }
        pub fn set_function_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_function_name(inp);
            self
        }
        /// <p>Specify a version or alias to get details about a published version of the function.</p>
        pub fn qualifier(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.qualifier(inp);
            self
        }
        pub fn set_qualifier(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_qualifier(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetFunctionCodeSigningConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_function_code_signing_config_input::Builder,
    }
    impl<C> GetFunctionCodeSigningConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetFunctionCodeSigningConfigOutput,
            smithy_http::result::SdkError<crate::error::GetFunctionCodeSigningConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Lambda function.</p>
        /// <p class="title">
        /// <b>Name formats</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function name</b> - <code>MyFunction</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Partial ARN</b> - <code>123456789012:function:MyFunction</code>.</p>
        /// </li>
        /// </ul>
        /// <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
        /// characters in length.</p>
        pub fn function_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(inp);
            self
        }
        pub fn set_function_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_function_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetFunctionConcurrency<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_function_concurrency_input::Builder,
    }
    impl<C> GetFunctionConcurrency<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetFunctionConcurrencyOutput,
            smithy_http::result::SdkError<crate::error::GetFunctionConcurrencyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Lambda function.</p>
        /// <p class="title">
        /// <b>Name formats</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function name</b> - <code>my-function</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
        /// </li>
        /// </ul>
        /// <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
        /// characters in length.</p>
        pub fn function_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(inp);
            self
        }
        pub fn set_function_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_function_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetFunctionConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_function_configuration_input::Builder,
    }
    impl<C> GetFunctionConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetFunctionConfigurationOutput,
            smithy_http::result::SdkError<crate::error::GetFunctionConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Lambda function, version, or alias.</p>
        /// <p class="title">
        /// <b>Name formats</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function name</b> - <code>my-function</code> (name-only), <code>my-function:v1</code> (with alias).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
        /// </li>
        /// </ul>
        /// <p>You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN.
        /// If you specify only the function name, it is limited to 64 characters in length.</p>
        pub fn function_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(inp);
            self
        }
        pub fn set_function_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_function_name(inp);
            self
        }
        /// <p>Specify a version or alias to get details about a published version of the function.</p>
        pub fn qualifier(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.qualifier(inp);
            self
        }
        pub fn set_qualifier(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_qualifier(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetFunctionEventInvokeConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_function_event_invoke_config_input::Builder,
    }
    impl<C> GetFunctionEventInvokeConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetFunctionEventInvokeConfigOutput,
            smithy_http::result::SdkError<crate::error::GetFunctionEventInvokeConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Lambda function, version, or alias.</p>
        /// <p class="title">
        /// <b>Name formats</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function name</b> - <code>my-function</code> (name-only), <code>my-function:v1</code> (with alias).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
        /// </li>
        /// </ul>
        /// <p>You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN.
        /// If you specify only the function name, it is limited to 64 characters in length.</p>
        pub fn function_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(inp);
            self
        }
        pub fn set_function_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_function_name(inp);
            self
        }
        /// <p>A version number or alias name.</p>
        pub fn qualifier(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.qualifier(inp);
            self
        }
        pub fn set_qualifier(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_qualifier(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetLayerVersion<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_layer_version_input::Builder,
    }
    impl<C> GetLayerVersion<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetLayerVersionOutput,
            smithy_http::result::SdkError<crate::error::GetLayerVersionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name or Amazon Resource Name (ARN) of the layer.</p>
        pub fn layer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.layer_name(inp);
            self
        }
        pub fn set_layer_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_layer_name(inp);
            self
        }
        /// <p>The version number.</p>
        pub fn version_number(mut self, inp: i64) -> Self {
            self.inner = self.inner.version_number(inp);
            self
        }
        pub fn set_version_number(mut self, inp: i64) -> Self {
            self.inner = self.inner.set_version_number(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetLayerVersionByArn<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_layer_version_by_arn_input::Builder,
    }
    impl<C> GetLayerVersionByArn<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetLayerVersionByArnOutput,
            smithy_http::result::SdkError<crate::error::GetLayerVersionByArnError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the layer version.</p>
        pub fn arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(inp);
            self
        }
        pub fn set_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetLayerVersionPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_layer_version_policy_input::Builder,
    }
    impl<C> GetLayerVersionPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetLayerVersionPolicyOutput,
            smithy_http::result::SdkError<crate::error::GetLayerVersionPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name or Amazon Resource Name (ARN) of the layer.</p>
        pub fn layer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.layer_name(inp);
            self
        }
        pub fn set_layer_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_layer_name(inp);
            self
        }
        /// <p>The version number.</p>
        pub fn version_number(mut self, inp: i64) -> Self {
            self.inner = self.inner.version_number(inp);
            self
        }
        pub fn set_version_number(mut self, inp: i64) -> Self {
            self.inner = self.inner.set_version_number(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_policy_input::Builder,
    }
    impl<C> GetPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetPolicyOutput,
            smithy_http::result::SdkError<crate::error::GetPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Lambda function, version, or alias.</p>
        /// <p class="title">
        /// <b>Name formats</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function name</b> - <code>my-function</code> (name-only), <code>my-function:v1</code> (with alias).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
        /// </li>
        /// </ul>
        /// <p>You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN.
        /// If you specify only the function name, it is limited to 64 characters in length.</p>
        pub fn function_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(inp);
            self
        }
        pub fn set_function_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_function_name(inp);
            self
        }
        /// <p>Specify a version or alias to get the policy for that resource.</p>
        pub fn qualifier(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.qualifier(inp);
            self
        }
        pub fn set_qualifier(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_qualifier(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetProvisionedConcurrencyConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_provisioned_concurrency_config_input::Builder,
    }
    impl<C> GetProvisionedConcurrencyConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetProvisionedConcurrencyConfigOutput,
            smithy_http::result::SdkError<crate::error::GetProvisionedConcurrencyConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Lambda function.</p>
        /// <p class="title">
        /// <b>Name formats</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function name</b> - <code>my-function</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
        /// </li>
        /// </ul>
        /// <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
        /// characters in length.</p>
        pub fn function_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(inp);
            self
        }
        pub fn set_function_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_function_name(inp);
            self
        }
        /// <p>The version number or alias name.</p>
        pub fn qualifier(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.qualifier(inp);
            self
        }
        pub fn set_qualifier(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_qualifier(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct Invoke<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::invoke_input::Builder,
    }
    impl<C> Invoke<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::InvokeOutput,
            smithy_http::result::SdkError<crate::error::InvokeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Lambda function, version, or alias.</p>
        /// <p class="title">
        /// <b>Name formats</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function name</b> - <code>my-function</code> (name-only), <code>my-function:v1</code> (with alias).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
        /// </li>
        /// </ul>
        /// <p>You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN.
        /// If you specify only the function name, it is limited to 64 characters in length.</p>
        pub fn function_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(inp);
            self
        }
        pub fn set_function_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_function_name(inp);
            self
        }
        /// <p>Choose from the following options.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>RequestResponse</code> (default) - Invoke the function synchronously. Keep the connection open until
        /// the function returns a response or times out. The API response includes the function response and additional
        /// data.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Event</code> - Invoke the function asynchronously. Send events that fail multiple times to the
        /// function's dead-letter queue (if it's configured). The API response only includes a status code.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DryRun</code> - Validate parameter values and verify that the user or role has permission to invoke
        /// the function.</p>
        /// </li>
        /// </ul>
        pub fn invocation_type(mut self, inp: crate::model::InvocationType) -> Self {
            self.inner = self.inner.invocation_type(inp);
            self
        }
        pub fn set_invocation_type(
            mut self,
            inp: std::option::Option<crate::model::InvocationType>,
        ) -> Self {
            self.inner = self.inner.set_invocation_type(inp);
            self
        }
        /// <p>Set to <code>Tail</code> to include the execution log in the response.</p>
        pub fn log_type(mut self, inp: crate::model::LogType) -> Self {
            self.inner = self.inner.log_type(inp);
            self
        }
        pub fn set_log_type(mut self, inp: std::option::Option<crate::model::LogType>) -> Self {
            self.inner = self.inner.set_log_type(inp);
            self
        }
        /// <p>Up to 3583 bytes of base64-encoded data about the invoking client to pass to the function in the context
        /// object.</p>
        pub fn client_context(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_context(inp);
            self
        }
        pub fn set_client_context(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_context(inp);
            self
        }
        /// <p>The JSON that you want to provide to your Lambda function as input.</p>
        pub fn payload(mut self, inp: smithy_types::Blob) -> Self {
            self.inner = self.inner.payload(inp);
            self
        }
        pub fn set_payload(mut self, inp: std::option::Option<smithy_types::Blob>) -> Self {
            self.inner = self.inner.set_payload(inp);
            self
        }
        /// <p>Specify a version or alias to invoke a published version of the function.</p>
        pub fn qualifier(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.qualifier(inp);
            self
        }
        pub fn set_qualifier(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_qualifier(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct InvokeAsync<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::invoke_async_input::Builder,
    }
    impl<C> InvokeAsync<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::InvokeAsyncOutput,
            smithy_http::result::SdkError<crate::error::InvokeAsyncError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Lambda function.</p>
        /// <p class="title">
        /// <b>Name formats</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function name</b> - <code>my-function</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
        /// </li>
        /// </ul>
        /// <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
        /// characters in length.</p>
        pub fn function_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(inp);
            self
        }
        pub fn set_function_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_function_name(inp);
            self
        }
        /// <p>The JSON that you want to provide to your Lambda function as input.</p>
        pub fn invoke_args(mut self, inp: smithy_http::byte_stream::ByteStream) -> Self {
            self.inner = self.inner.invoke_args(inp);
            self
        }
        pub fn set_invoke_args(mut self, inp: smithy_http::byte_stream::ByteStream) -> Self {
            self.inner = self.inner.set_invoke_args(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListAliases<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_aliases_input::Builder,
    }
    impl<C> ListAliases<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListAliasesOutput,
            smithy_http::result::SdkError<crate::error::ListAliasesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Lambda function.</p>
        /// <p class="title">
        /// <b>Name formats</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function name</b> - <code>MyFunction</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Partial ARN</b> - <code>123456789012:function:MyFunction</code>.</p>
        /// </li>
        /// </ul>
        /// <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
        /// characters in length.</p>
        pub fn function_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(inp);
            self
        }
        pub fn set_function_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_function_name(inp);
            self
        }
        /// <p>Specify a function version to only list aliases that invoke that version.</p>
        pub fn function_version(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_version(inp);
            self
        }
        pub fn set_function_version(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_function_version(inp);
            self
        }
        /// <p>Specify the pagination token that's returned by a previous request to retrieve the next page of results.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>Limit the number of aliases returned.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListCodeSigningConfigs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_code_signing_configs_input::Builder,
    }
    impl<C> ListCodeSigningConfigs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListCodeSigningConfigsOutput,
            smithy_http::result::SdkError<crate::error::ListCodeSigningConfigsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specify the pagination token that's returned by a previous request to retrieve the next page of results.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>Maximum number of items to return.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListEventSourceMappings<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_event_source_mappings_input::Builder,
    }
    impl<C> ListEventSourceMappings<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListEventSourceMappingsOutput,
            smithy_http::result::SdkError<crate::error::ListEventSourceMappingsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the event source.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Amazon Kinesis</b> - The ARN of the data stream or a stream consumer.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Amazon DynamoDB Streams</b> - The ARN of the stream.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Amazon Simple Queue Service</b> - The ARN of the queue.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Amazon Managed Streaming for Apache Kafka</b> - The ARN of the cluster.</p>
        /// </li>
        /// </ul>
        pub fn event_source_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.event_source_arn(inp);
            self
        }
        pub fn set_event_source_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_event_source_arn(inp);
            self
        }
        /// <p>The name of the Lambda function.</p>
        /// <p class="title">
        /// <b>Name formats</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function name</b> - <code>MyFunction</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Version or Alias ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction:PROD</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Partial ARN</b> - <code>123456789012:function:MyFunction</code>.</p>
        /// </li>
        /// </ul>
        /// <p>The length constraint applies only to the full ARN. If you specify only the function name, it's limited to 64
        /// characters in length.</p>
        pub fn function_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(inp);
            self
        }
        pub fn set_function_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_function_name(inp);
            self
        }
        /// <p>A pagination token returned by a previous call.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>The maximum number of event source mappings to return.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListFunctionEventInvokeConfigs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_function_event_invoke_configs_input::Builder,
    }
    impl<C> ListFunctionEventInvokeConfigs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListFunctionEventInvokeConfigsOutput,
            smithy_http::result::SdkError<crate::error::ListFunctionEventInvokeConfigsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Lambda function.</p>
        /// <p class="title">
        /// <b>Name formats</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function name</b> - <code>my-function</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
        /// </li>
        /// </ul>
        /// <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
        /// characters in length.</p>
        pub fn function_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(inp);
            self
        }
        pub fn set_function_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_function_name(inp);
            self
        }
        /// <p>Specify the pagination token that's returned by a previous request to retrieve the next page of results.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>The maximum number of configurations to return.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListFunctions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_functions_input::Builder,
    }
    impl<C> ListFunctions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListFunctionsOutput,
            smithy_http::result::SdkError<crate::error::ListFunctionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>For Lambda@Edge functions, the AWS Region of the master function. For example, <code>us-east-1</code> filters
        /// the list of functions to only include Lambda@Edge functions replicated from a master function in US East (N.
        /// Virginia). If specified, you must set <code>FunctionVersion</code> to <code>ALL</code>.</p>
        pub fn master_region(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.master_region(inp);
            self
        }
        pub fn set_master_region(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_master_region(inp);
            self
        }
        /// <p>Set to <code>ALL</code> to include entries for all published versions of each function.</p>
        pub fn function_version(mut self, inp: crate::model::FunctionVersion) -> Self {
            self.inner = self.inner.function_version(inp);
            self
        }
        pub fn set_function_version(
            mut self,
            inp: std::option::Option<crate::model::FunctionVersion>,
        ) -> Self {
            self.inner = self.inner.set_function_version(inp);
            self
        }
        /// <p>Specify the pagination token that's returned by a previous request to retrieve the next page of results.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>The maximum number of functions to return in the response. Note that <code>ListFunctions</code> returns a maximum of 50 items in each response,
        /// even if you set the number higher.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListFunctionsByCodeSigningConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_functions_by_code_signing_config_input::Builder,
    }
    impl<C> ListFunctionsByCodeSigningConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListFunctionsByCodeSigningConfigOutput,
            smithy_http::result::SdkError<crate::error::ListFunctionsByCodeSigningConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The The Amazon Resource Name (ARN) of the code signing configuration.</p>
        pub fn code_signing_config_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.code_signing_config_arn(inp);
            self
        }
        pub fn set_code_signing_config_arn(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_code_signing_config_arn(inp);
            self
        }
        /// <p>Specify the pagination token that's returned by a previous request to retrieve the next page of results.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>Maximum number of items to return.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListLayers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_layers_input::Builder,
    }
    impl<C> ListLayers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListLayersOutput,
            smithy_http::result::SdkError<crate::error::ListLayersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A runtime identifier. For example, <code>go1.x</code>.</p>
        pub fn compatible_runtime(mut self, inp: crate::model::Runtime) -> Self {
            self.inner = self.inner.compatible_runtime(inp);
            self
        }
        pub fn set_compatible_runtime(
            mut self,
            inp: std::option::Option<crate::model::Runtime>,
        ) -> Self {
            self.inner = self.inner.set_compatible_runtime(inp);
            self
        }
        /// <p>A pagination token returned by a previous call.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>The maximum number of layers to return.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListLayerVersions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_layer_versions_input::Builder,
    }
    impl<C> ListLayerVersions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListLayerVersionsOutput,
            smithy_http::result::SdkError<crate::error::ListLayerVersionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A runtime identifier. For example, <code>go1.x</code>.</p>
        pub fn compatible_runtime(mut self, inp: crate::model::Runtime) -> Self {
            self.inner = self.inner.compatible_runtime(inp);
            self
        }
        pub fn set_compatible_runtime(
            mut self,
            inp: std::option::Option<crate::model::Runtime>,
        ) -> Self {
            self.inner = self.inner.set_compatible_runtime(inp);
            self
        }
        /// <p>The name or Amazon Resource Name (ARN) of the layer.</p>
        pub fn layer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.layer_name(inp);
            self
        }
        pub fn set_layer_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_layer_name(inp);
            self
        }
        /// <p>A pagination token returned by a previous call.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>The maximum number of versions to return.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListProvisionedConcurrencyConfigs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_provisioned_concurrency_configs_input::Builder,
    }
    impl<C> ListProvisionedConcurrencyConfigs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListProvisionedConcurrencyConfigsOutput,
            smithy_http::result::SdkError<crate::error::ListProvisionedConcurrencyConfigsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Lambda function.</p>
        /// <p class="title">
        /// <b>Name formats</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function name</b> - <code>my-function</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
        /// </li>
        /// </ul>
        /// <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
        /// characters in length.</p>
        pub fn function_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(inp);
            self
        }
        pub fn set_function_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_function_name(inp);
            self
        }
        /// <p>Specify the pagination token that's returned by a previous request to retrieve the next page of results.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>Specify a number to limit the number of configurations returned.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTags<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_input::Builder,
    }
    impl<C> ListTags<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListTagsOutput,
            smithy_http::result::SdkError<crate::error::ListTagsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The function's Amazon Resource Name (ARN).</p>
        pub fn resource(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource(inp);
            self
        }
        pub fn set_resource(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_resource(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListVersionsByFunction<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_versions_by_function_input::Builder,
    }
    impl<C> ListVersionsByFunction<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListVersionsByFunctionOutput,
            smithy_http::result::SdkError<crate::error::ListVersionsByFunctionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Lambda function.</p>
        /// <p class="title">
        /// <b>Name formats</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function name</b> - <code>MyFunction</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Partial ARN</b> - <code>123456789012:function:MyFunction</code>.</p>
        /// </li>
        /// </ul>
        /// <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
        /// characters in length.</p>
        pub fn function_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(inp);
            self
        }
        pub fn set_function_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_function_name(inp);
            self
        }
        /// <p>Specify the pagination token that's returned by a previous request to retrieve the next page of results.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>The maximum number of versions to return.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PublishLayerVersion<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::publish_layer_version_input::Builder,
    }
    impl<C> PublishLayerVersion<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PublishLayerVersionOutput,
            smithy_http::result::SdkError<crate::error::PublishLayerVersionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name or Amazon Resource Name (ARN) of the layer.</p>
        pub fn layer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.layer_name(inp);
            self
        }
        pub fn set_layer_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_layer_name(inp);
            self
        }
        /// <p>The description of the version.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(inp);
            self
        }
        /// <p>The function layer archive.</p>
        pub fn content(mut self, inp: crate::model::LayerVersionContentInput) -> Self {
            self.inner = self.inner.content(inp);
            self
        }
        pub fn set_content(
            mut self,
            inp: std::option::Option<crate::model::LayerVersionContentInput>,
        ) -> Self {
            self.inner = self.inner.set_content(inp);
            self
        }
        /// <p>A list of compatible <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html">function
        /// runtimes</a>. Used for filtering with <a>ListLayers</a> and <a>ListLayerVersions</a>.</p>
        pub fn compatible_runtimes(mut self, inp: impl Into<crate::model::Runtime>) -> Self {
            self.inner = self.inner.compatible_runtimes(inp);
            self
        }
        pub fn set_compatible_runtimes(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Runtime>>,
        ) -> Self {
            self.inner = self.inner.set_compatible_runtimes(inp);
            self
        }
        /// <p>The layer's software license. It can be any of the following:</p>
        /// <ul>
        /// <li>
        /// <p>An <a href="https://spdx.org/licenses/">SPDX license identifier</a>. For example,
        /// <code>MIT</code>.</p>
        /// </li>
        /// <li>
        /// <p>The URL of a license hosted on the internet. For example,
        /// <code>https://opensource.org/licenses/MIT</code>.</p>
        /// </li>
        /// <li>
        /// <p>The full text of the license.</p>
        /// </li>
        /// </ul>
        pub fn license_info(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.license_info(inp);
            self
        }
        pub fn set_license_info(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_license_info(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PublishVersion<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::publish_version_input::Builder,
    }
    impl<C> PublishVersion<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PublishVersionOutput,
            smithy_http::result::SdkError<crate::error::PublishVersionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Lambda function.</p>
        /// <p class="title">
        /// <b>Name formats</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function name</b> - <code>MyFunction</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Partial ARN</b> - <code>123456789012:function:MyFunction</code>.</p>
        /// </li>
        /// </ul>
        /// <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
        /// characters in length.</p>
        pub fn function_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(inp);
            self
        }
        pub fn set_function_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_function_name(inp);
            self
        }
        /// <p>Only publish a version if the hash value matches the value that's specified. Use this option to avoid
        /// publishing a version if the function code has changed since you last updated it. You can get the hash for the
        /// version that you uploaded from the output of <a>UpdateFunctionCode</a>.</p>
        pub fn code_sha256(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.code_sha256(inp);
            self
        }
        pub fn set_code_sha256(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_code_sha256(inp);
            self
        }
        /// <p>A description for the version to override the description in the function configuration.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(inp);
            self
        }
        /// <p>Only update the function if the revision ID matches the ID that's specified. Use this option to avoid
        /// publishing a version if the function configuration has changed since you last updated it.</p>
        pub fn revision_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.revision_id(inp);
            self
        }
        pub fn set_revision_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_revision_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutFunctionCodeSigningConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_function_code_signing_config_input::Builder,
    }
    impl<C> PutFunctionCodeSigningConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutFunctionCodeSigningConfigOutput,
            smithy_http::result::SdkError<crate::error::PutFunctionCodeSigningConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The The Amazon Resource Name (ARN) of the code signing configuration.</p>
        pub fn code_signing_config_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.code_signing_config_arn(inp);
            self
        }
        pub fn set_code_signing_config_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_code_signing_config_arn(inp);
            self
        }
        /// <p>The name of the Lambda function.</p>
        /// <p class="title">
        /// <b>Name formats</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function name</b> - <code>MyFunction</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Partial ARN</b> - <code>123456789012:function:MyFunction</code>.</p>
        /// </li>
        /// </ul>
        /// <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
        /// characters in length.</p>
        pub fn function_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(inp);
            self
        }
        pub fn set_function_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_function_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutFunctionConcurrency<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_function_concurrency_input::Builder,
    }
    impl<C> PutFunctionConcurrency<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutFunctionConcurrencyOutput,
            smithy_http::result::SdkError<crate::error::PutFunctionConcurrencyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Lambda function.</p>
        /// <p class="title">
        /// <b>Name formats</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function name</b> - <code>my-function</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
        /// </li>
        /// </ul>
        /// <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
        /// characters in length.</p>
        pub fn function_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(inp);
            self
        }
        pub fn set_function_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_function_name(inp);
            self
        }
        /// <p>The number of simultaneous executions to reserve for the function.</p>
        pub fn reserved_concurrent_executions(mut self, inp: i32) -> Self {
            self.inner = self.inner.reserved_concurrent_executions(inp);
            self
        }
        pub fn set_reserved_concurrent_executions(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_reserved_concurrent_executions(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutFunctionEventInvokeConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_function_event_invoke_config_input::Builder,
    }
    impl<C> PutFunctionEventInvokeConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutFunctionEventInvokeConfigOutput,
            smithy_http::result::SdkError<crate::error::PutFunctionEventInvokeConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Lambda function, version, or alias.</p>
        /// <p class="title">
        /// <b>Name formats</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function name</b> - <code>my-function</code> (name-only), <code>my-function:v1</code> (with alias).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
        /// </li>
        /// </ul>
        /// <p>You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN.
        /// If you specify only the function name, it is limited to 64 characters in length.</p>
        pub fn function_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(inp);
            self
        }
        pub fn set_function_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_function_name(inp);
            self
        }
        /// <p>A version number or alias name.</p>
        pub fn qualifier(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.qualifier(inp);
            self
        }
        pub fn set_qualifier(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_qualifier(inp);
            self
        }
        /// <p>The maximum number of times to retry when the function returns an error.</p>
        pub fn maximum_retry_attempts(mut self, inp: i32) -> Self {
            self.inner = self.inner.maximum_retry_attempts(inp);
            self
        }
        pub fn set_maximum_retry_attempts(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_maximum_retry_attempts(inp);
            self
        }
        /// <p>The maximum age of a request that Lambda sends to a function for processing.</p>
        pub fn maximum_event_age_in_seconds(mut self, inp: i32) -> Self {
            self.inner = self.inner.maximum_event_age_in_seconds(inp);
            self
        }
        pub fn set_maximum_event_age_in_seconds(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_maximum_event_age_in_seconds(inp);
            self
        }
        /// <p>A destination for events after they have been sent to a function for processing.</p>
        /// <p class="title">
        /// <b>Destinations</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function</b> - The Amazon Resource Name (ARN) of a Lambda function.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Queue</b> - The ARN of an SQS queue.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Topic</b> - The ARN of an SNS topic.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Event Bus</b> - The ARN of an Amazon EventBridge event bus.</p>
        /// </li>
        /// </ul>
        pub fn destination_config(mut self, inp: crate::model::DestinationConfig) -> Self {
            self.inner = self.inner.destination_config(inp);
            self
        }
        pub fn set_destination_config(
            mut self,
            inp: std::option::Option<crate::model::DestinationConfig>,
        ) -> Self {
            self.inner = self.inner.set_destination_config(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutProvisionedConcurrencyConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_provisioned_concurrency_config_input::Builder,
    }
    impl<C> PutProvisionedConcurrencyConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutProvisionedConcurrencyConfigOutput,
            smithy_http::result::SdkError<crate::error::PutProvisionedConcurrencyConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Lambda function.</p>
        /// <p class="title">
        /// <b>Name formats</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function name</b> - <code>my-function</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
        /// </li>
        /// </ul>
        /// <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
        /// characters in length.</p>
        pub fn function_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(inp);
            self
        }
        pub fn set_function_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_function_name(inp);
            self
        }
        /// <p>The version number or alias name.</p>
        pub fn qualifier(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.qualifier(inp);
            self
        }
        pub fn set_qualifier(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_qualifier(inp);
            self
        }
        /// <p>The amount of provisioned concurrency to allocate for the version or alias.</p>
        pub fn provisioned_concurrent_executions(mut self, inp: i32) -> Self {
            self.inner = self.inner.provisioned_concurrent_executions(inp);
            self
        }
        pub fn set_provisioned_concurrent_executions(
            mut self,
            inp: std::option::Option<i32>,
        ) -> Self {
            self.inner = self.inner.set_provisioned_concurrent_executions(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RemoveLayerVersionPermission<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::remove_layer_version_permission_input::Builder,
    }
    impl<C> RemoveLayerVersionPermission<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::RemoveLayerVersionPermissionOutput,
            smithy_http::result::SdkError<crate::error::RemoveLayerVersionPermissionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name or Amazon Resource Name (ARN) of the layer.</p>
        pub fn layer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.layer_name(inp);
            self
        }
        pub fn set_layer_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_layer_name(inp);
            self
        }
        /// <p>The version number.</p>
        pub fn version_number(mut self, inp: i64) -> Self {
            self.inner = self.inner.version_number(inp);
            self
        }
        pub fn set_version_number(mut self, inp: i64) -> Self {
            self.inner = self.inner.set_version_number(inp);
            self
        }
        /// <p>The identifier that was specified when the statement was added.</p>
        pub fn statement_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.statement_id(inp);
            self
        }
        pub fn set_statement_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_statement_id(inp);
            self
        }
        /// <p>Only update the policy if the revision ID matches the ID specified. Use this option to avoid modifying a
        /// policy that has changed since you last read it.</p>
        pub fn revision_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.revision_id(inp);
            self
        }
        pub fn set_revision_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_revision_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RemovePermission<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::remove_permission_input::Builder,
    }
    impl<C> RemovePermission<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::RemovePermissionOutput,
            smithy_http::result::SdkError<crate::error::RemovePermissionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Lambda function, version, or alias.</p>
        /// <p class="title">
        /// <b>Name formats</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function name</b> - <code>my-function</code> (name-only), <code>my-function:v1</code> (with alias).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
        /// </li>
        /// </ul>
        /// <p>You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN.
        /// If you specify only the function name, it is limited to 64 characters in length.</p>
        pub fn function_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(inp);
            self
        }
        pub fn set_function_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_function_name(inp);
            self
        }
        /// <p>Statement ID of the permission to remove.</p>
        pub fn statement_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.statement_id(inp);
            self
        }
        pub fn set_statement_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_statement_id(inp);
            self
        }
        /// <p>Specify a version or alias to remove permissions from a published version of the function.</p>
        pub fn qualifier(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.qualifier(inp);
            self
        }
        pub fn set_qualifier(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_qualifier(inp);
            self
        }
        /// <p>Only update the policy if the revision ID matches the ID that's specified. Use this option to avoid modifying a
        /// policy that has changed since you last read it.</p>
        pub fn revision_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.revision_id(inp);
            self
        }
        pub fn set_revision_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_revision_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The function's Amazon Resource Name (ARN).</p>
        pub fn resource(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource(inp);
            self
        }
        pub fn set_resource(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_resource(inp);
            self
        }
        /// <p>A list of tags to apply to the function.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The function's Amazon Resource Name (ARN).</p>
        pub fn resource(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource(inp);
            self
        }
        pub fn set_resource(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_resource(inp);
            self
        }
        /// <p>A list of tag keys to remove from the function.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateAlias<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_alias_input::Builder,
    }
    impl<C> UpdateAlias<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateAliasOutput,
            smithy_http::result::SdkError<crate::error::UpdateAliasError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Lambda function.</p>
        /// <p class="title">
        /// <b>Name formats</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function name</b> - <code>MyFunction</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Partial ARN</b> - <code>123456789012:function:MyFunction</code>.</p>
        /// </li>
        /// </ul>
        /// <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
        /// characters in length.</p>
        pub fn function_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(inp);
            self
        }
        pub fn set_function_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_function_name(inp);
            self
        }
        /// <p>The name of the alias.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>The function version that the alias invokes.</p>
        pub fn function_version(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_version(inp);
            self
        }
        pub fn set_function_version(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_function_version(inp);
            self
        }
        /// <p>A description of the alias.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(inp);
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html#configuring-alias-routing">routing
        /// configuration</a> of the alias.</p>
        pub fn routing_config(mut self, inp: crate::model::AliasRoutingConfiguration) -> Self {
            self.inner = self.inner.routing_config(inp);
            self
        }
        pub fn set_routing_config(
            mut self,
            inp: std::option::Option<crate::model::AliasRoutingConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_routing_config(inp);
            self
        }
        /// <p>Only update the alias if the revision ID matches the ID that's specified. Use this option to avoid modifying
        /// an alias that has changed since you last read it.</p>
        pub fn revision_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.revision_id(inp);
            self
        }
        pub fn set_revision_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_revision_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateCodeSigningConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_code_signing_config_input::Builder,
    }
    impl<C> UpdateCodeSigningConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateCodeSigningConfigOutput,
            smithy_http::result::SdkError<crate::error::UpdateCodeSigningConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The The Amazon Resource Name (ARN) of the code signing configuration.</p>
        pub fn code_signing_config_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.code_signing_config_arn(inp);
            self
        }
        pub fn set_code_signing_config_arn(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_code_signing_config_arn(inp);
            self
        }
        /// <p>Descriptive name for this code signing configuration.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(inp);
            self
        }
        /// <p>Signing profiles for this code signing configuration.</p>
        pub fn allowed_publishers(mut self, inp: crate::model::AllowedPublishers) -> Self {
            self.inner = self.inner.allowed_publishers(inp);
            self
        }
        pub fn set_allowed_publishers(
            mut self,
            inp: std::option::Option<crate::model::AllowedPublishers>,
        ) -> Self {
            self.inner = self.inner.set_allowed_publishers(inp);
            self
        }
        /// <p>The code signing policy.</p>
        pub fn code_signing_policies(mut self, inp: crate::model::CodeSigningPolicies) -> Self {
            self.inner = self.inner.code_signing_policies(inp);
            self
        }
        pub fn set_code_signing_policies(
            mut self,
            inp: std::option::Option<crate::model::CodeSigningPolicies>,
        ) -> Self {
            self.inner = self.inner.set_code_signing_policies(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateEventSourceMapping<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_event_source_mapping_input::Builder,
    }
    impl<C> UpdateEventSourceMapping<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateEventSourceMappingOutput,
            smithy_http::result::SdkError<crate::error::UpdateEventSourceMappingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the event source mapping.</p>
        pub fn uuid(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.uuid(inp);
            self
        }
        pub fn set_uuid(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_uuid(inp);
            self
        }
        /// <p>The name of the Lambda function.</p>
        /// <p class="title">
        /// <b>Name formats</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function name</b> - <code>MyFunction</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Version or Alias ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction:PROD</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Partial ARN</b> - <code>123456789012:function:MyFunction</code>.</p>
        /// </li>
        /// </ul>
        /// <p>The length constraint applies only to the full ARN. If you specify only the function name, it's limited to 64
        /// characters in length.</p>
        pub fn function_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(inp);
            self
        }
        pub fn set_function_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_function_name(inp);
            self
        }
        /// <p>If true, the event source mapping is active. Set to false to pause polling and invocation.</p>
        pub fn enabled(mut self, inp: bool) -> Self {
            self.inner = self.inner.enabled(inp);
            self
        }
        pub fn set_enabled(mut self, inp: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_enabled(inp);
            self
        }
        /// <p>The maximum number of items to retrieve in a single batch.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Amazon Kinesis</b> - Default 100. Max 10,000.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Amazon DynamoDB Streams</b> - Default 100. Max 1,000.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Amazon Simple Queue Service</b> - Default 10. For standard queues the max is 10,000. For FIFO queues the max is 10.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Amazon Managed Streaming for Apache Kafka</b> - Default 100. Max 10,000.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Self-Managed Apache Kafka</b> - Default 100. Max 10,000.</p>
        /// </li>
        /// </ul>
        pub fn batch_size(mut self, inp: i32) -> Self {
            self.inner = self.inner.batch_size(inp);
            self
        }
        pub fn set_batch_size(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_batch_size(inp);
            self
        }
        /// <p>(Streams and SQS standard queues) The maximum amount of time to gather records before invoking the function, in seconds.</p>
        pub fn maximum_batching_window_in_seconds(mut self, inp: i32) -> Self {
            self.inner = self.inner.maximum_batching_window_in_seconds(inp);
            self
        }
        pub fn set_maximum_batching_window_in_seconds(
            mut self,
            inp: std::option::Option<i32>,
        ) -> Self {
            self.inner = self.inner.set_maximum_batching_window_in_seconds(inp);
            self
        }
        /// <p>(Streams) An Amazon SQS queue or Amazon SNS topic destination for discarded records.</p>
        pub fn destination_config(mut self, inp: crate::model::DestinationConfig) -> Self {
            self.inner = self.inner.destination_config(inp);
            self
        }
        pub fn set_destination_config(
            mut self,
            inp: std::option::Option<crate::model::DestinationConfig>,
        ) -> Self {
            self.inner = self.inner.set_destination_config(inp);
            self
        }
        /// <p>(Streams) Discard records older than the specified age. The default value is infinite (-1).</p>
        pub fn maximum_record_age_in_seconds(mut self, inp: i32) -> Self {
            self.inner = self.inner.maximum_record_age_in_seconds(inp);
            self
        }
        pub fn set_maximum_record_age_in_seconds(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_maximum_record_age_in_seconds(inp);
            self
        }
        /// <p>(Streams) If the function returns an error, split the batch in two and retry.</p>
        pub fn bisect_batch_on_function_error(mut self, inp: bool) -> Self {
            self.inner = self.inner.bisect_batch_on_function_error(inp);
            self
        }
        pub fn set_bisect_batch_on_function_error(
            mut self,
            inp: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_bisect_batch_on_function_error(inp);
            self
        }
        /// <p>(Streams) Discard records after the specified number of retries. The default value is infinite (-1). When set to infinite (-1), failed records will be retried until the record expires.</p>
        pub fn maximum_retry_attempts(mut self, inp: i32) -> Self {
            self.inner = self.inner.maximum_retry_attempts(inp);
            self
        }
        pub fn set_maximum_retry_attempts(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_maximum_retry_attempts(inp);
            self
        }
        /// <p>(Streams) The number of batches to process from each shard concurrently.</p>
        pub fn parallelization_factor(mut self, inp: i32) -> Self {
            self.inner = self.inner.parallelization_factor(inp);
            self
        }
        pub fn set_parallelization_factor(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_parallelization_factor(inp);
            self
        }
        /// <p>An array of the authentication protocol, or the VPC components to secure your event source.</p>
        pub fn source_access_configurations(
            mut self,
            inp: impl Into<crate::model::SourceAccessConfiguration>,
        ) -> Self {
            self.inner = self.inner.source_access_configurations(inp);
            self
        }
        pub fn set_source_access_configurations(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::SourceAccessConfiguration>>,
        ) -> Self {
            self.inner = self.inner.set_source_access_configurations(inp);
            self
        }
        /// <p>(Streams) The duration in seconds of a processing window. The range is between 1 second up to 900 seconds.</p>
        pub fn tumbling_window_in_seconds(mut self, inp: i32) -> Self {
            self.inner = self.inner.tumbling_window_in_seconds(inp);
            self
        }
        pub fn set_tumbling_window_in_seconds(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_tumbling_window_in_seconds(inp);
            self
        }
        /// <p>(Streams) A list of current response type enums applied to the event source mapping.</p>
        pub fn function_response_types(
            mut self,
            inp: impl Into<crate::model::FunctionResponseType>,
        ) -> Self {
            self.inner = self.inner.function_response_types(inp);
            self
        }
        pub fn set_function_response_types(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::FunctionResponseType>>,
        ) -> Self {
            self.inner = self.inner.set_function_response_types(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateFunctionCode<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_function_code_input::Builder,
    }
    impl<C> UpdateFunctionCode<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateFunctionCodeOutput,
            smithy_http::result::SdkError<crate::error::UpdateFunctionCodeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Lambda function.</p>
        /// <p class="title">
        /// <b>Name formats</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function name</b> - <code>my-function</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
        /// </li>
        /// </ul>
        /// <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
        /// characters in length.</p>
        pub fn function_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(inp);
            self
        }
        pub fn set_function_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_function_name(inp);
            self
        }
        /// <p>The base64-encoded contents of the deployment package. AWS SDK and AWS CLI clients handle the encoding for
        /// you.</p>
        pub fn zip_file(mut self, inp: smithy_types::Blob) -> Self {
            self.inner = self.inner.zip_file(inp);
            self
        }
        pub fn set_zip_file(mut self, inp: std::option::Option<smithy_types::Blob>) -> Self {
            self.inner = self.inner.set_zip_file(inp);
            self
        }
        /// <p>An Amazon S3 bucket in the same AWS Region as your function. The bucket can be in a different AWS account.</p>
        pub fn s3_bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.s3_bucket(inp);
            self
        }
        pub fn set_s3_bucket(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_s3_bucket(inp);
            self
        }
        /// <p>The Amazon S3 key of the deployment package.</p>
        pub fn s3_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.s3_key(inp);
            self
        }
        pub fn set_s3_key(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_s3_key(inp);
            self
        }
        /// <p>For versioned objects, the version of the deployment package object to use.</p>
        pub fn s3_object_version(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.s3_object_version(inp);
            self
        }
        pub fn set_s3_object_version(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_s3_object_version(inp);
            self
        }
        /// <p>URI of a container image in the Amazon ECR registry.</p>
        pub fn image_uri(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.image_uri(inp);
            self
        }
        pub fn set_image_uri(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_image_uri(inp);
            self
        }
        /// <p>Set to true to publish a new version of the function after updating the code. This has the same effect as
        /// calling <a>PublishVersion</a> separately.</p>
        pub fn publish(mut self, inp: bool) -> Self {
            self.inner = self.inner.publish(inp);
            self
        }
        pub fn set_publish(mut self, inp: bool) -> Self {
            self.inner = self.inner.set_publish(inp);
            self
        }
        /// <p>Set to true to validate the request parameters and access permissions without modifying the function
        /// code.</p>
        pub fn dry_run(mut self, inp: bool) -> Self {
            self.inner = self.inner.dry_run(inp);
            self
        }
        pub fn set_dry_run(mut self, inp: bool) -> Self {
            self.inner = self.inner.set_dry_run(inp);
            self
        }
        /// <p>Only update the function if the revision ID matches the ID that's specified. Use this option to avoid modifying a
        /// function that has changed since you last read it.</p>
        pub fn revision_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.revision_id(inp);
            self
        }
        pub fn set_revision_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_revision_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateFunctionConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_function_configuration_input::Builder,
    }
    impl<C> UpdateFunctionConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateFunctionConfigurationOutput,
            smithy_http::result::SdkError<crate::error::UpdateFunctionConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Lambda function.</p>
        /// <p class="title">
        /// <b>Name formats</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function name</b> - <code>my-function</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
        /// </li>
        /// </ul>
        /// <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
        /// characters in length.</p>
        pub fn function_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(inp);
            self
        }
        pub fn set_function_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_function_name(inp);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the function's execution role.</p>
        pub fn role(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role(inp);
            self
        }
        pub fn set_role(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role(inp);
            self
        }
        /// <p>The name of the method within your code that Lambda calls to execute your function. The format includes the
        /// file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information,
        /// see <a href="https://docs.aws.amazon.com/lambda/latest/dg/programming-model-v2.html">Programming Model</a>.</p>
        pub fn handler(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.handler(inp);
            self
        }
        pub fn set_handler(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_handler(inp);
            self
        }
        /// <p>A description of the function.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(inp);
            self
        }
        /// <p>The amount of time that Lambda allows a function to run before stopping it. The default is 3 seconds. The
        /// maximum allowed value is 900 seconds.</p>
        pub fn timeout(mut self, inp: i32) -> Self {
            self.inner = self.inner.timeout(inp);
            self
        }
        pub fn set_timeout(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_timeout(inp);
            self
        }
        /// <p>The amount of memory available to the function at runtime. Increasing the function's memory also increases its CPU
        /// allocation. The default value is 128 MB. The value can be any multiple of 1 MB.</p>
        pub fn memory_size(mut self, inp: i32) -> Self {
            self.inner = self.inner.memory_size(inp);
            self
        }
        pub fn set_memory_size(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_memory_size(inp);
            self
        }
        /// <p>For network connectivity to AWS resources in a VPC, specify a list of security groups and subnets in the VPC.
        /// When you connect a function to a VPC, it can only access resources and the internet through that VPC. For more
        /// information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html">VPC Settings</a>.</p>
        pub fn vpc_config(mut self, inp: crate::model::VpcConfig) -> Self {
            self.inner = self.inner.vpc_config(inp);
            self
        }
        pub fn set_vpc_config(mut self, inp: std::option::Option<crate::model::VpcConfig>) -> Self {
            self.inner = self.inner.set_vpc_config(inp);
            self
        }
        /// <p>Environment variables that are accessible from function code during execution.</p>
        pub fn environment(mut self, inp: crate::model::Environment) -> Self {
            self.inner = self.inner.environment(inp);
            self
        }
        pub fn set_environment(
            mut self,
            inp: std::option::Option<crate::model::Environment>,
        ) -> Self {
            self.inner = self.inner.set_environment(inp);
            self
        }
        /// <p>The identifier of the function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html">runtime</a>.</p>
        pub fn runtime(mut self, inp: crate::model::Runtime) -> Self {
            self.inner = self.inner.runtime(inp);
            self
        }
        pub fn set_runtime(mut self, inp: std::option::Option<crate::model::Runtime>) -> Self {
            self.inner = self.inner.set_runtime(inp);
            self
        }
        /// <p>A dead letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events
        /// when they fail processing. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#dlq">Dead Letter Queues</a>.</p>
        pub fn dead_letter_config(mut self, inp: crate::model::DeadLetterConfig) -> Self {
            self.inner = self.inner.dead_letter_config(inp);
            self
        }
        pub fn set_dead_letter_config(
            mut self,
            inp: std::option::Option<crate::model::DeadLetterConfig>,
        ) -> Self {
            self.inner = self.inner.set_dead_letter_config(inp);
            self
        }
        /// <p>The ARN of the AWS Key Management Service (AWS KMS) key that's used to encrypt your function's environment
        /// variables. If it's not provided, AWS Lambda uses a default service key.</p>
        pub fn kms_key_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key_arn(inp);
            self
        }
        pub fn set_kms_key_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key_arn(inp);
            self
        }
        /// <p>Set <code>Mode</code> to <code>Active</code> to sample and trace a subset of incoming requests with AWS
        /// X-Ray.</p>
        pub fn tracing_config(mut self, inp: crate::model::TracingConfig) -> Self {
            self.inner = self.inner.tracing_config(inp);
            self
        }
        pub fn set_tracing_config(
            mut self,
            inp: std::option::Option<crate::model::TracingConfig>,
        ) -> Self {
            self.inner = self.inner.set_tracing_config(inp);
            self
        }
        /// <p>Only update the function if the revision ID matches the ID that's specified. Use this option to avoid modifying a
        /// function that has changed since you last read it.</p>
        pub fn revision_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.revision_id(inp);
            self
        }
        pub fn set_revision_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_revision_id(inp);
            self
        }
        /// <p>A list of <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">function layers</a>
        /// to add to the function's execution environment. Specify each layer by its ARN, including the version.</p>
        pub fn layers(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.layers(inp);
            self
        }
        pub fn set_layers(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_layers(inp);
            self
        }
        /// <p>Connection settings for an Amazon EFS file system.</p>
        pub fn file_system_configs(
            mut self,
            inp: impl Into<crate::model::FileSystemConfig>,
        ) -> Self {
            self.inner = self.inner.file_system_configs(inp);
            self
        }
        pub fn set_file_system_configs(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::FileSystemConfig>>,
        ) -> Self {
            self.inner = self.inner.set_file_system_configs(inp);
            self
        }
        /// <p>
        /// <a href="https://docs.aws.amazon.com/lambda/latest/dg/images-parms.html">Container image configuration
        /// values</a> that override the values in the container image Dockerfile.</p>
        pub fn image_config(mut self, inp: crate::model::ImageConfig) -> Self {
            self.inner = self.inner.image_config(inp);
            self
        }
        pub fn set_image_config(
            mut self,
            inp: std::option::Option<crate::model::ImageConfig>,
        ) -> Self {
            self.inner = self.inner.set_image_config(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateFunctionEventInvokeConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_function_event_invoke_config_input::Builder,
    }
    impl<C> UpdateFunctionEventInvokeConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateFunctionEventInvokeConfigOutput,
            smithy_http::result::SdkError<crate::error::UpdateFunctionEventInvokeConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Lambda function, version, or alias.</p>
        /// <p class="title">
        /// <b>Name formats</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function name</b> - <code>my-function</code> (name-only), <code>my-function:v1</code> (with alias).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
        /// </li>
        /// </ul>
        /// <p>You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN.
        /// If you specify only the function name, it is limited to 64 characters in length.</p>
        pub fn function_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_name(inp);
            self
        }
        pub fn set_function_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_function_name(inp);
            self
        }
        /// <p>A version number or alias name.</p>
        pub fn qualifier(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.qualifier(inp);
            self
        }
        pub fn set_qualifier(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_qualifier(inp);
            self
        }
        /// <p>The maximum number of times to retry when the function returns an error.</p>
        pub fn maximum_retry_attempts(mut self, inp: i32) -> Self {
            self.inner = self.inner.maximum_retry_attempts(inp);
            self
        }
        pub fn set_maximum_retry_attempts(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_maximum_retry_attempts(inp);
            self
        }
        /// <p>The maximum age of a request that Lambda sends to a function for processing.</p>
        pub fn maximum_event_age_in_seconds(mut self, inp: i32) -> Self {
            self.inner = self.inner.maximum_event_age_in_seconds(inp);
            self
        }
        pub fn set_maximum_event_age_in_seconds(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_maximum_event_age_in_seconds(inp);
            self
        }
        /// <p>A destination for events after they have been sent to a function for processing.</p>
        /// <p class="title">
        /// <b>Destinations</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Function</b> - The Amazon Resource Name (ARN) of a Lambda function.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Queue</b> - The ARN of an SQS queue.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Topic</b> - The ARN of an SNS topic.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Event Bus</b> - The ARN of an Amazon EventBridge event bus.</p>
        /// </li>
        /// </ul>
        pub fn destination_config(mut self, inp: crate::model::DestinationConfig) -> Self {
            self.inner = self.inner.destination_config(inp);
            self
        }
        pub fn set_destination_config(
            mut self,
            inp: std::option::Option<crate::model::DestinationConfig>,
        ) -> Self {
            self.inner = self.inner.set_destination_config(inp);
            self
        }
    }
}
