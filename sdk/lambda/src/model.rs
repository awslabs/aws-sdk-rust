// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// When writing a match expression against `ThrottleReason`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let throttlereason = unimplemented!();
/// match throttlereason {
///     ThrottleReason::CallerRateLimitExceeded => { /* ... */ },
///     ThrottleReason::ConcurrentInvocationLimitExceeded => { /* ... */ },
///     ThrottleReason::ConcurrentSnapshotCreateLimitExceeded => { /* ... */ },
///     ThrottleReason::FunctionInvocationRateLimitExceeded => { /* ... */ },
///     ThrottleReason::ReservedFunctionConcurrentInvocationLimitExceeded => { /* ... */ },
///     ThrottleReason::ReservedFunctionInvocationRateLimitExceeded => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `throttlereason` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ThrottleReason::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ThrottleReason::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ThrottleReason::NewFeature` is defined.
/// Specifically, when `throttlereason` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ThrottleReason::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ThrottleReason {
    #[allow(missing_docs)] // documentation missing in model
    CallerRateLimitExceeded,
    #[allow(missing_docs)] // documentation missing in model
    ConcurrentInvocationLimitExceeded,
    #[allow(missing_docs)] // documentation missing in model
    ConcurrentSnapshotCreateLimitExceeded,
    #[allow(missing_docs)] // documentation missing in model
    FunctionInvocationRateLimitExceeded,
    #[allow(missing_docs)] // documentation missing in model
    ReservedFunctionConcurrentInvocationLimitExceeded,
    #[allow(missing_docs)] // documentation missing in model
    ReservedFunctionInvocationRateLimitExceeded,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ThrottleReason {
    fn from(s: &str) -> Self {
        match s {
            "CallerRateLimitExceeded" => ThrottleReason::CallerRateLimitExceeded,
            "ConcurrentInvocationLimitExceeded" => {
                ThrottleReason::ConcurrentInvocationLimitExceeded
            }
            "ConcurrentSnapshotCreateLimitExceeded" => {
                ThrottleReason::ConcurrentSnapshotCreateLimitExceeded
            }
            "FunctionInvocationRateLimitExceeded" => {
                ThrottleReason::FunctionInvocationRateLimitExceeded
            }
            "ReservedFunctionConcurrentInvocationLimitExceeded" => {
                ThrottleReason::ReservedFunctionConcurrentInvocationLimitExceeded
            }
            "ReservedFunctionInvocationRateLimitExceeded" => {
                ThrottleReason::ReservedFunctionInvocationRateLimitExceeded
            }
            other => ThrottleReason::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ThrottleReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ThrottleReason::from(s))
    }
}
impl ThrottleReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ThrottleReason::CallerRateLimitExceeded => "CallerRateLimitExceeded",
            ThrottleReason::ConcurrentInvocationLimitExceeded => {
                "ConcurrentInvocationLimitExceeded"
            }
            ThrottleReason::ConcurrentSnapshotCreateLimitExceeded => {
                "ConcurrentSnapshotCreateLimitExceeded"
            }
            ThrottleReason::FunctionInvocationRateLimitExceeded => {
                "FunctionInvocationRateLimitExceeded"
            }
            ThrottleReason::ReservedFunctionConcurrentInvocationLimitExceeded => {
                "ReservedFunctionConcurrentInvocationLimitExceeded"
            }
            ThrottleReason::ReservedFunctionInvocationRateLimitExceeded => {
                "ReservedFunctionInvocationRateLimitExceeded"
            }
            ThrottleReason::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CallerRateLimitExceeded",
            "ConcurrentInvocationLimitExceeded",
            "ConcurrentSnapshotCreateLimitExceeded",
            "FunctionInvocationRateLimitExceeded",
            "ReservedFunctionConcurrentInvocationLimitExceeded",
            "ReservedFunctionInvocationRateLimitExceeded",
        ]
    }
}
impl AsRef<str> for ThrottleReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">cross-origin resource sharing (CORS)</a> settings for your Lambda function URL. Use CORS to grant access to your function URL from any origin. You can also use CORS to control access for specific HTTP headers and methods in requests to your function URL.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Cors {
    /// <p>Whether to allow cookies or other credentials in requests to your function URL. The default is <code>false</code>.</p>
    #[doc(hidden)]
    pub allow_credentials: std::option::Option<bool>,
    /// <p>The HTTP headers that origins can include in requests to your function URL. For example: <code>Date</code>, <code>Keep-Alive</code>, <code>X-Custom-Header</code>.</p>
    #[doc(hidden)]
    pub allow_headers: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The HTTP methods that are allowed when calling your function URL. For example: <code>GET</code>, <code>POST</code>, <code>DELETE</code>, or the wildcard character (<code>*</code>).</p>
    #[doc(hidden)]
    pub allow_methods: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The origins that can access your function URL. You can list any number of specific origins, separated by a comma. For example: <code>https://www.example.com</code>, <code>http://localhost:60905</code>.</p>
    /// <p>Alternatively, you can grant access to all origins using the wildcard character (<code>*</code>).</p>
    #[doc(hidden)]
    pub allow_origins: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The HTTP headers in your function response that you want to expose to origins that call your function URL. For example: <code>Date</code>, <code>Keep-Alive</code>, <code>X-Custom-Header</code>.</p>
    #[doc(hidden)]
    pub expose_headers: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The maximum amount of time, in seconds, that web browsers can cache results of a preflight request. By default, this is set to <code>0</code>, which means that the browser doesn't cache results.</p>
    #[doc(hidden)]
    pub max_age: std::option::Option<i32>,
}
impl Cors {
    /// <p>Whether to allow cookies or other credentials in requests to your function URL. The default is <code>false</code>.</p>
    pub fn allow_credentials(&self) -> std::option::Option<bool> {
        self.allow_credentials
    }
    /// <p>The HTTP headers that origins can include in requests to your function URL. For example: <code>Date</code>, <code>Keep-Alive</code>, <code>X-Custom-Header</code>.</p>
    pub fn allow_headers(&self) -> std::option::Option<&[std::string::String]> {
        self.allow_headers.as_deref()
    }
    /// <p>The HTTP methods that are allowed when calling your function URL. For example: <code>GET</code>, <code>POST</code>, <code>DELETE</code>, or the wildcard character (<code>*</code>).</p>
    pub fn allow_methods(&self) -> std::option::Option<&[std::string::String]> {
        self.allow_methods.as_deref()
    }
    /// <p>The origins that can access your function URL. You can list any number of specific origins, separated by a comma. For example: <code>https://www.example.com</code>, <code>http://localhost:60905</code>.</p>
    /// <p>Alternatively, you can grant access to all origins using the wildcard character (<code>*</code>).</p>
    pub fn allow_origins(&self) -> std::option::Option<&[std::string::String]> {
        self.allow_origins.as_deref()
    }
    /// <p>The HTTP headers in your function response that you want to expose to origins that call your function URL. For example: <code>Date</code>, <code>Keep-Alive</code>, <code>X-Custom-Header</code>.</p>
    pub fn expose_headers(&self) -> std::option::Option<&[std::string::String]> {
        self.expose_headers.as_deref()
    }
    /// <p>The maximum amount of time, in seconds, that web browsers can cache results of a preflight request. By default, this is set to <code>0</code>, which means that the browser doesn't cache results.</p>
    pub fn max_age(&self) -> std::option::Option<i32> {
        self.max_age
    }
}
/// See [`Cors`](crate::model::Cors).
pub mod cors {

    /// A builder for [`Cors`](crate::model::Cors).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) allow_credentials: std::option::Option<bool>,
        pub(crate) allow_headers: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) allow_methods: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) allow_origins: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) expose_headers: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) max_age: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Whether to allow cookies or other credentials in requests to your function URL. The default is <code>false</code>.</p>
        pub fn allow_credentials(mut self, input: bool) -> Self {
            self.allow_credentials = Some(input);
            self
        }
        /// <p>Whether to allow cookies or other credentials in requests to your function URL. The default is <code>false</code>.</p>
        pub fn set_allow_credentials(mut self, input: std::option::Option<bool>) -> Self {
            self.allow_credentials = input;
            self
        }
        /// Appends an item to `allow_headers`.
        ///
        /// To override the contents of this collection use [`set_allow_headers`](Self::set_allow_headers).
        ///
        /// <p>The HTTP headers that origins can include in requests to your function URL. For example: <code>Date</code>, <code>Keep-Alive</code>, <code>X-Custom-Header</code>.</p>
        pub fn allow_headers(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.allow_headers.unwrap_or_default();
            v.push(input.into());
            self.allow_headers = Some(v);
            self
        }
        /// <p>The HTTP headers that origins can include in requests to your function URL. For example: <code>Date</code>, <code>Keep-Alive</code>, <code>X-Custom-Header</code>.</p>
        pub fn set_allow_headers(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.allow_headers = input;
            self
        }
        /// Appends an item to `allow_methods`.
        ///
        /// To override the contents of this collection use [`set_allow_methods`](Self::set_allow_methods).
        ///
        /// <p>The HTTP methods that are allowed when calling your function URL. For example: <code>GET</code>, <code>POST</code>, <code>DELETE</code>, or the wildcard character (<code>*</code>).</p>
        pub fn allow_methods(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.allow_methods.unwrap_or_default();
            v.push(input.into());
            self.allow_methods = Some(v);
            self
        }
        /// <p>The HTTP methods that are allowed when calling your function URL. For example: <code>GET</code>, <code>POST</code>, <code>DELETE</code>, or the wildcard character (<code>*</code>).</p>
        pub fn set_allow_methods(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.allow_methods = input;
            self
        }
        /// Appends an item to `allow_origins`.
        ///
        /// To override the contents of this collection use [`set_allow_origins`](Self::set_allow_origins).
        ///
        /// <p>The origins that can access your function URL. You can list any number of specific origins, separated by a comma. For example: <code>https://www.example.com</code>, <code>http://localhost:60905</code>.</p>
        /// <p>Alternatively, you can grant access to all origins using the wildcard character (<code>*</code>).</p>
        pub fn allow_origins(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.allow_origins.unwrap_or_default();
            v.push(input.into());
            self.allow_origins = Some(v);
            self
        }
        /// <p>The origins that can access your function URL. You can list any number of specific origins, separated by a comma. For example: <code>https://www.example.com</code>, <code>http://localhost:60905</code>.</p>
        /// <p>Alternatively, you can grant access to all origins using the wildcard character (<code>*</code>).</p>
        pub fn set_allow_origins(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.allow_origins = input;
            self
        }
        /// Appends an item to `expose_headers`.
        ///
        /// To override the contents of this collection use [`set_expose_headers`](Self::set_expose_headers).
        ///
        /// <p>The HTTP headers in your function response that you want to expose to origins that call your function URL. For example: <code>Date</code>, <code>Keep-Alive</code>, <code>X-Custom-Header</code>.</p>
        pub fn expose_headers(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.expose_headers.unwrap_or_default();
            v.push(input.into());
            self.expose_headers = Some(v);
            self
        }
        /// <p>The HTTP headers in your function response that you want to expose to origins that call your function URL. For example: <code>Date</code>, <code>Keep-Alive</code>, <code>X-Custom-Header</code>.</p>
        pub fn set_expose_headers(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.expose_headers = input;
            self
        }
        /// <p>The maximum amount of time, in seconds, that web browsers can cache results of a preflight request. By default, this is set to <code>0</code>, which means that the browser doesn't cache results.</p>
        pub fn max_age(mut self, input: i32) -> Self {
            self.max_age = Some(input);
            self
        }
        /// <p>The maximum amount of time, in seconds, that web browsers can cache results of a preflight request. By default, this is set to <code>0</code>, which means that the browser doesn't cache results.</p>
        pub fn set_max_age(mut self, input: std::option::Option<i32>) -> Self {
            self.max_age = input;
            self
        }
        /// Consumes the builder and constructs a [`Cors`](crate::model::Cors).
        pub fn build(self) -> crate::model::Cors {
            crate::model::Cors {
                allow_credentials: self.allow_credentials,
                allow_headers: self.allow_headers,
                allow_methods: self.allow_methods,
                allow_origins: self.allow_origins,
                expose_headers: self.expose_headers,
                max_age: self.max_age,
            }
        }
    }
}
impl Cors {
    /// Creates a new builder-style object to manufacture [`Cors`](crate::model::Cors).
    pub fn builder() -> crate::model::cors::Builder {
        crate::model::cors::Builder::default()
    }
}

/// When writing a match expression against `FunctionUrlAuthType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let functionurlauthtype = unimplemented!();
/// match functionurlauthtype {
///     FunctionUrlAuthType::AwsIam => { /* ... */ },
///     FunctionUrlAuthType::None => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `functionurlauthtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FunctionUrlAuthType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FunctionUrlAuthType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FunctionUrlAuthType::NewFeature` is defined.
/// Specifically, when `functionurlauthtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FunctionUrlAuthType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FunctionUrlAuthType {
    #[allow(missing_docs)] // documentation missing in model
    AwsIam,
    #[allow(missing_docs)] // documentation missing in model
    None,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FunctionUrlAuthType {
    fn from(s: &str) -> Self {
        match s {
            "AWS_IAM" => FunctionUrlAuthType::AwsIam,
            "NONE" => FunctionUrlAuthType::None,
            other => {
                FunctionUrlAuthType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for FunctionUrlAuthType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FunctionUrlAuthType::from(s))
    }
}
impl FunctionUrlAuthType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FunctionUrlAuthType::AwsIam => "AWS_IAM",
            FunctionUrlAuthType::None => "NONE",
            FunctionUrlAuthType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AWS_IAM", "NONE"]
    }
}
impl AsRef<str> for FunctionUrlAuthType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A configuration object that specifies the destination of an event after Lambda processes it.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DestinationConfig {
    /// <p>The destination configuration for successful invocations.</p>
    #[doc(hidden)]
    pub on_success: std::option::Option<crate::model::OnSuccess>,
    /// <p>The destination configuration for failed invocations.</p>
    #[doc(hidden)]
    pub on_failure: std::option::Option<crate::model::OnFailure>,
}
impl DestinationConfig {
    /// <p>The destination configuration for successful invocations.</p>
    pub fn on_success(&self) -> std::option::Option<&crate::model::OnSuccess> {
        self.on_success.as_ref()
    }
    /// <p>The destination configuration for failed invocations.</p>
    pub fn on_failure(&self) -> std::option::Option<&crate::model::OnFailure> {
        self.on_failure.as_ref()
    }
}
/// See [`DestinationConfig`](crate::model::DestinationConfig).
pub mod destination_config {

    /// A builder for [`DestinationConfig`](crate::model::DestinationConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) on_success: std::option::Option<crate::model::OnSuccess>,
        pub(crate) on_failure: std::option::Option<crate::model::OnFailure>,
    }
    impl Builder {
        /// <p>The destination configuration for successful invocations.</p>
        pub fn on_success(mut self, input: crate::model::OnSuccess) -> Self {
            self.on_success = Some(input);
            self
        }
        /// <p>The destination configuration for successful invocations.</p>
        pub fn set_on_success(
            mut self,
            input: std::option::Option<crate::model::OnSuccess>,
        ) -> Self {
            self.on_success = input;
            self
        }
        /// <p>The destination configuration for failed invocations.</p>
        pub fn on_failure(mut self, input: crate::model::OnFailure) -> Self {
            self.on_failure = Some(input);
            self
        }
        /// <p>The destination configuration for failed invocations.</p>
        pub fn set_on_failure(
            mut self,
            input: std::option::Option<crate::model::OnFailure>,
        ) -> Self {
            self.on_failure = input;
            self
        }
        /// Consumes the builder and constructs a [`DestinationConfig`](crate::model::DestinationConfig).
        pub fn build(self) -> crate::model::DestinationConfig {
            crate::model::DestinationConfig {
                on_success: self.on_success,
                on_failure: self.on_failure,
            }
        }
    }
}
impl DestinationConfig {
    /// Creates a new builder-style object to manufacture [`DestinationConfig`](crate::model::DestinationConfig).
    pub fn builder() -> crate::model::destination_config::Builder {
        crate::model::destination_config::Builder::default()
    }
}

/// <p>A destination for events that failed processing.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OnFailure {
    /// <p>The Amazon Resource Name (ARN) of the destination resource.</p>
    #[doc(hidden)]
    pub destination: std::option::Option<std::string::String>,
}
impl OnFailure {
    /// <p>The Amazon Resource Name (ARN) of the destination resource.</p>
    pub fn destination(&self) -> std::option::Option<&str> {
        self.destination.as_deref()
    }
}
/// See [`OnFailure`](crate::model::OnFailure).
pub mod on_failure {

    /// A builder for [`OnFailure`](crate::model::OnFailure).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) destination: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the destination resource.</p>
        pub fn destination(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the destination resource.</p>
        pub fn set_destination(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.destination = input;
            self
        }
        /// Consumes the builder and constructs a [`OnFailure`](crate::model::OnFailure).
        pub fn build(self) -> crate::model::OnFailure {
            crate::model::OnFailure {
                destination: self.destination,
            }
        }
    }
}
impl OnFailure {
    /// Creates a new builder-style object to manufacture [`OnFailure`](crate::model::OnFailure).
    pub fn builder() -> crate::model::on_failure::Builder {
        crate::model::on_failure::Builder::default()
    }
}

/// <p>A destination for events that were processed successfully.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OnSuccess {
    /// <p>The Amazon Resource Name (ARN) of the destination resource.</p>
    #[doc(hidden)]
    pub destination: std::option::Option<std::string::String>,
}
impl OnSuccess {
    /// <p>The Amazon Resource Name (ARN) of the destination resource.</p>
    pub fn destination(&self) -> std::option::Option<&str> {
        self.destination.as_deref()
    }
}
/// See [`OnSuccess`](crate::model::OnSuccess).
pub mod on_success {

    /// A builder for [`OnSuccess`](crate::model::OnSuccess).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) destination: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the destination resource.</p>
        pub fn destination(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the destination resource.</p>
        pub fn set_destination(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.destination = input;
            self
        }
        /// Consumes the builder and constructs a [`OnSuccess`](crate::model::OnSuccess).
        pub fn build(self) -> crate::model::OnSuccess {
            crate::model::OnSuccess {
                destination: self.destination,
            }
        }
    }
}
impl OnSuccess {
    /// Creates a new builder-style object to manufacture [`OnSuccess`](crate::model::OnSuccess).
    pub fn builder() -> crate::model::on_success::Builder {
        crate::model::on_success::Builder::default()
    }
}

/// <p>The ARN of the runtime and any errors that occured.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RuntimeVersionConfig {
    /// <p>The ARN of the runtime version you want the function to use.</p>
    #[doc(hidden)]
    pub runtime_version_arn: std::option::Option<std::string::String>,
    /// <p>Error response when Lambda is unable to retrieve the runtime version for a function.</p>
    #[doc(hidden)]
    pub error: std::option::Option<crate::model::RuntimeVersionError>,
}
impl RuntimeVersionConfig {
    /// <p>The ARN of the runtime version you want the function to use.</p>
    pub fn runtime_version_arn(&self) -> std::option::Option<&str> {
        self.runtime_version_arn.as_deref()
    }
    /// <p>Error response when Lambda is unable to retrieve the runtime version for a function.</p>
    pub fn error(&self) -> std::option::Option<&crate::model::RuntimeVersionError> {
        self.error.as_ref()
    }
}
/// See [`RuntimeVersionConfig`](crate::model::RuntimeVersionConfig).
pub mod runtime_version_config {

    /// A builder for [`RuntimeVersionConfig`](crate::model::RuntimeVersionConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) runtime_version_arn: std::option::Option<std::string::String>,
        pub(crate) error: std::option::Option<crate::model::RuntimeVersionError>,
    }
    impl Builder {
        /// <p>The ARN of the runtime version you want the function to use.</p>
        pub fn runtime_version_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.runtime_version_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the runtime version you want the function to use.</p>
        pub fn set_runtime_version_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.runtime_version_arn = input;
            self
        }
        /// <p>Error response when Lambda is unable to retrieve the runtime version for a function.</p>
        pub fn error(mut self, input: crate::model::RuntimeVersionError) -> Self {
            self.error = Some(input);
            self
        }
        /// <p>Error response when Lambda is unable to retrieve the runtime version for a function.</p>
        pub fn set_error(
            mut self,
            input: std::option::Option<crate::model::RuntimeVersionError>,
        ) -> Self {
            self.error = input;
            self
        }
        /// Consumes the builder and constructs a [`RuntimeVersionConfig`](crate::model::RuntimeVersionConfig).
        pub fn build(self) -> crate::model::RuntimeVersionConfig {
            crate::model::RuntimeVersionConfig {
                runtime_version_arn: self.runtime_version_arn,
                error: self.error,
            }
        }
    }
}
impl RuntimeVersionConfig {
    /// Creates a new builder-style object to manufacture [`RuntimeVersionConfig`](crate::model::RuntimeVersionConfig).
    pub fn builder() -> crate::model::runtime_version_config::Builder {
        crate::model::runtime_version_config::Builder::default()
    }
}

/// <p>Any error returned when the runtime version information for the function could not be retrieved.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RuntimeVersionError {
    /// <p>The error code.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<std::string::String>,
    /// <p>The error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl RuntimeVersionError {
    /// <p>The error code.</p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p>The error message.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Debug for RuntimeVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RuntimeVersionError");
        formatter.field("error_code", &self.error_code);
        formatter.field("message", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`RuntimeVersionError`](crate::model::RuntimeVersionError).
pub mod runtime_version_error {

    /// A builder for [`RuntimeVersionError`](crate::model::RuntimeVersionError).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The error code.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>The error code.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>The error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RuntimeVersionError`](crate::model::RuntimeVersionError).
        pub fn build(self) -> crate::model::RuntimeVersionError {
            crate::model::RuntimeVersionError {
                error_code: self.error_code,
                message: self.message,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("error_code", &self.error_code);
            formatter.field("message", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl RuntimeVersionError {
    /// Creates a new builder-style object to manufacture [`RuntimeVersionError`](crate::model::RuntimeVersionError).
    pub fn builder() -> crate::model::runtime_version_error::Builder {
        crate::model::runtime_version_error::Builder::default()
    }
}

/// <p>The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html">SnapStart</a> setting.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SnapStartResponse {
    /// <p>When set to <code>PublishedVersions</code>, Lambda creates a snapshot of the execution environment when you publish a function version.</p>
    #[doc(hidden)]
    pub apply_on: std::option::Option<crate::model::SnapStartApplyOn>,
    /// <p>When you provide a <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-versions.html#versioning-versions-using">qualified Amazon Resource Name (ARN)</a>, this response element indicates whether SnapStart is activated for the specified function version.</p>
    #[doc(hidden)]
    pub optimization_status: std::option::Option<crate::model::SnapStartOptimizationStatus>,
}
impl SnapStartResponse {
    /// <p>When set to <code>PublishedVersions</code>, Lambda creates a snapshot of the execution environment when you publish a function version.</p>
    pub fn apply_on(&self) -> std::option::Option<&crate::model::SnapStartApplyOn> {
        self.apply_on.as_ref()
    }
    /// <p>When you provide a <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-versions.html#versioning-versions-using">qualified Amazon Resource Name (ARN)</a>, this response element indicates whether SnapStart is activated for the specified function version.</p>
    pub fn optimization_status(
        &self,
    ) -> std::option::Option<&crate::model::SnapStartOptimizationStatus> {
        self.optimization_status.as_ref()
    }
}
/// See [`SnapStartResponse`](crate::model::SnapStartResponse).
pub mod snap_start_response {

    /// A builder for [`SnapStartResponse`](crate::model::SnapStartResponse).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) apply_on: std::option::Option<crate::model::SnapStartApplyOn>,
        pub(crate) optimization_status:
            std::option::Option<crate::model::SnapStartOptimizationStatus>,
    }
    impl Builder {
        /// <p>When set to <code>PublishedVersions</code>, Lambda creates a snapshot of the execution environment when you publish a function version.</p>
        pub fn apply_on(mut self, input: crate::model::SnapStartApplyOn) -> Self {
            self.apply_on = Some(input);
            self
        }
        /// <p>When set to <code>PublishedVersions</code>, Lambda creates a snapshot of the execution environment when you publish a function version.</p>
        pub fn set_apply_on(
            mut self,
            input: std::option::Option<crate::model::SnapStartApplyOn>,
        ) -> Self {
            self.apply_on = input;
            self
        }
        /// <p>When you provide a <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-versions.html#versioning-versions-using">qualified Amazon Resource Name (ARN)</a>, this response element indicates whether SnapStart is activated for the specified function version.</p>
        pub fn optimization_status(
            mut self,
            input: crate::model::SnapStartOptimizationStatus,
        ) -> Self {
            self.optimization_status = Some(input);
            self
        }
        /// <p>When you provide a <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-versions.html#versioning-versions-using">qualified Amazon Resource Name (ARN)</a>, this response element indicates whether SnapStart is activated for the specified function version.</p>
        pub fn set_optimization_status(
            mut self,
            input: std::option::Option<crate::model::SnapStartOptimizationStatus>,
        ) -> Self {
            self.optimization_status = input;
            self
        }
        /// Consumes the builder and constructs a [`SnapStartResponse`](crate::model::SnapStartResponse).
        pub fn build(self) -> crate::model::SnapStartResponse {
            crate::model::SnapStartResponse {
                apply_on: self.apply_on,
                optimization_status: self.optimization_status,
            }
        }
    }
}
impl SnapStartResponse {
    /// Creates a new builder-style object to manufacture [`SnapStartResponse`](crate::model::SnapStartResponse).
    pub fn builder() -> crate::model::snap_start_response::Builder {
        crate::model::snap_start_response::Builder::default()
    }
}

/// When writing a match expression against `SnapStartOptimizationStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let snapstartoptimizationstatus = unimplemented!();
/// match snapstartoptimizationstatus {
///     SnapStartOptimizationStatus::Off => { /* ... */ },
///     SnapStartOptimizationStatus::On => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `snapstartoptimizationstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SnapStartOptimizationStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SnapStartOptimizationStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SnapStartOptimizationStatus::NewFeature` is defined.
/// Specifically, when `snapstartoptimizationstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SnapStartOptimizationStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SnapStartOptimizationStatus {
    #[allow(missing_docs)] // documentation missing in model
    Off,
    #[allow(missing_docs)] // documentation missing in model
    On,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SnapStartOptimizationStatus {
    fn from(s: &str) -> Self {
        match s {
            "Off" => SnapStartOptimizationStatus::Off,
            "On" => SnapStartOptimizationStatus::On,
            other => SnapStartOptimizationStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for SnapStartOptimizationStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SnapStartOptimizationStatus::from(s))
    }
}
impl SnapStartOptimizationStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SnapStartOptimizationStatus::Off => "Off",
            SnapStartOptimizationStatus::On => "On",
            SnapStartOptimizationStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Off", "On"]
    }
}
impl AsRef<str> for SnapStartOptimizationStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `SnapStartApplyOn`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let snapstartapplyon = unimplemented!();
/// match snapstartapplyon {
///     SnapStartApplyOn::None => { /* ... */ },
///     SnapStartApplyOn::PublishedVersions => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `snapstartapplyon` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SnapStartApplyOn::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SnapStartApplyOn::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SnapStartApplyOn::NewFeature` is defined.
/// Specifically, when `snapstartapplyon` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SnapStartApplyOn::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SnapStartApplyOn {
    #[allow(missing_docs)] // documentation missing in model
    None,
    #[allow(missing_docs)] // documentation missing in model
    PublishedVersions,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SnapStartApplyOn {
    fn from(s: &str) -> Self {
        match s {
            "None" => SnapStartApplyOn::None,
            "PublishedVersions" => SnapStartApplyOn::PublishedVersions,
            other => SnapStartApplyOn::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SnapStartApplyOn {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SnapStartApplyOn::from(s))
    }
}
impl SnapStartApplyOn {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SnapStartApplyOn::None => "None",
            SnapStartApplyOn::PublishedVersions => "PublishedVersions",
            SnapStartApplyOn::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["None", "PublishedVersions"]
    }
}
impl AsRef<str> for SnapStartApplyOn {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The size of the function's <code>/tmp</code> directory in MB. The default value is 512, but it can be any whole number between 512 and 10,240 MB.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EphemeralStorage {
    /// <p>The size of the function's <code>/tmp</code> directory.</p>
    #[doc(hidden)]
    pub size: std::option::Option<i32>,
}
impl EphemeralStorage {
    /// <p>The size of the function's <code>/tmp</code> directory.</p>
    pub fn size(&self) -> std::option::Option<i32> {
        self.size
    }
}
/// See [`EphemeralStorage`](crate::model::EphemeralStorage).
pub mod ephemeral_storage {

    /// A builder for [`EphemeralStorage`](crate::model::EphemeralStorage).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) size: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The size of the function's <code>/tmp</code> directory.</p>
        pub fn size(mut self, input: i32) -> Self {
            self.size = Some(input);
            self
        }
        /// <p>The size of the function's <code>/tmp</code> directory.</p>
        pub fn set_size(mut self, input: std::option::Option<i32>) -> Self {
            self.size = input;
            self
        }
        /// Consumes the builder and constructs a [`EphemeralStorage`](crate::model::EphemeralStorage).
        pub fn build(self) -> crate::model::EphemeralStorage {
            crate::model::EphemeralStorage { size: self.size }
        }
    }
}
impl EphemeralStorage {
    /// Creates a new builder-style object to manufacture [`EphemeralStorage`](crate::model::EphemeralStorage).
    pub fn builder() -> crate::model::ephemeral_storage::Builder {
        crate::model::ephemeral_storage::Builder::default()
    }
}

/// When writing a match expression against `Architecture`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let architecture = unimplemented!();
/// match architecture {
///     Architecture::Arm64 => { /* ... */ },
///     Architecture::X8664 => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `architecture` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Architecture::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Architecture::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Architecture::NewFeature` is defined.
/// Specifically, when `architecture` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Architecture::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Architecture {
    #[allow(missing_docs)] // documentation missing in model
    Arm64,
    #[allow(missing_docs)] // documentation missing in model
    X8664,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Architecture {
    fn from(s: &str) -> Self {
        match s {
            "arm64" => Architecture::Arm64,
            "x86_64" => Architecture::X8664,
            other => Architecture::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Architecture {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Architecture::from(s))
    }
}
impl Architecture {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Architecture::Arm64 => "arm64",
            Architecture::X8664 => "x86_64",
            Architecture::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["arm64", "x86_64"]
    }
}
impl AsRef<str> for Architecture {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Response to a <code>GetFunctionConfiguration</code> request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ImageConfigResponse {
    /// <p>Configuration values that override the container image Dockerfile.</p>
    #[doc(hidden)]
    pub image_config: std::option::Option<crate::model::ImageConfig>,
    /// <p>Error response to <code>GetFunctionConfiguration</code>.</p>
    #[doc(hidden)]
    pub error: std::option::Option<crate::model::ImageConfigError>,
}
impl ImageConfigResponse {
    /// <p>Configuration values that override the container image Dockerfile.</p>
    pub fn image_config(&self) -> std::option::Option<&crate::model::ImageConfig> {
        self.image_config.as_ref()
    }
    /// <p>Error response to <code>GetFunctionConfiguration</code>.</p>
    pub fn error(&self) -> std::option::Option<&crate::model::ImageConfigError> {
        self.error.as_ref()
    }
}
/// See [`ImageConfigResponse`](crate::model::ImageConfigResponse).
pub mod image_config_response {

    /// A builder for [`ImageConfigResponse`](crate::model::ImageConfigResponse).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) image_config: std::option::Option<crate::model::ImageConfig>,
        pub(crate) error: std::option::Option<crate::model::ImageConfigError>,
    }
    impl Builder {
        /// <p>Configuration values that override the container image Dockerfile.</p>
        pub fn image_config(mut self, input: crate::model::ImageConfig) -> Self {
            self.image_config = Some(input);
            self
        }
        /// <p>Configuration values that override the container image Dockerfile.</p>
        pub fn set_image_config(
            mut self,
            input: std::option::Option<crate::model::ImageConfig>,
        ) -> Self {
            self.image_config = input;
            self
        }
        /// <p>Error response to <code>GetFunctionConfiguration</code>.</p>
        pub fn error(mut self, input: crate::model::ImageConfigError) -> Self {
            self.error = Some(input);
            self
        }
        /// <p>Error response to <code>GetFunctionConfiguration</code>.</p>
        pub fn set_error(
            mut self,
            input: std::option::Option<crate::model::ImageConfigError>,
        ) -> Self {
            self.error = input;
            self
        }
        /// Consumes the builder and constructs a [`ImageConfigResponse`](crate::model::ImageConfigResponse).
        pub fn build(self) -> crate::model::ImageConfigResponse {
            crate::model::ImageConfigResponse {
                image_config: self.image_config,
                error: self.error,
            }
        }
    }
}
impl ImageConfigResponse {
    /// Creates a new builder-style object to manufacture [`ImageConfigResponse`](crate::model::ImageConfigResponse).
    pub fn builder() -> crate::model::image_config_response::Builder {
        crate::model::image_config_response::Builder::default()
    }
}

/// <p>Error response to <code>GetFunctionConfiguration</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ImageConfigError {
    /// <p>Error code.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<std::string::String>,
    /// <p>Error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ImageConfigError {
    /// <p>Error code.</p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p>Error message.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Debug for ImageConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ImageConfigError");
        formatter.field("error_code", &self.error_code);
        formatter.field("message", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`ImageConfigError`](crate::model::ImageConfigError).
pub mod image_config_error {

    /// A builder for [`ImageConfigError`](crate::model::ImageConfigError).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error code.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>Error code.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>Error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ImageConfigError`](crate::model::ImageConfigError).
        pub fn build(self) -> crate::model::ImageConfigError {
            crate::model::ImageConfigError {
                error_code: self.error_code,
                message: self.message,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("error_code", &self.error_code);
            formatter.field("message", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl ImageConfigError {
    /// Creates a new builder-style object to manufacture [`ImageConfigError`](crate::model::ImageConfigError).
    pub fn builder() -> crate::model::image_config_error::Builder {
        crate::model::image_config_error::Builder::default()
    }
}

/// <p>Configuration values that override the container image Dockerfile settings. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-parms">Container image settings</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ImageConfig {
    /// <p>Specifies the entry point to their application, which is typically the location of the runtime executable.</p>
    #[doc(hidden)]
    pub entry_point: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies parameters that you want to pass in with ENTRYPOINT.</p>
    #[doc(hidden)]
    pub command: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies the working directory.</p>
    #[doc(hidden)]
    pub working_directory: std::option::Option<std::string::String>,
}
impl ImageConfig {
    /// <p>Specifies the entry point to their application, which is typically the location of the runtime executable.</p>
    pub fn entry_point(&self) -> std::option::Option<&[std::string::String]> {
        self.entry_point.as_deref()
    }
    /// <p>Specifies parameters that you want to pass in with ENTRYPOINT.</p>
    pub fn command(&self) -> std::option::Option<&[std::string::String]> {
        self.command.as_deref()
    }
    /// <p>Specifies the working directory.</p>
    pub fn working_directory(&self) -> std::option::Option<&str> {
        self.working_directory.as_deref()
    }
}
/// See [`ImageConfig`](crate::model::ImageConfig).
pub mod image_config {

    /// A builder for [`ImageConfig`](crate::model::ImageConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entry_point: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) command: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) working_directory: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `entry_point`.
        ///
        /// To override the contents of this collection use [`set_entry_point`](Self::set_entry_point).
        ///
        /// <p>Specifies the entry point to their application, which is typically the location of the runtime executable.</p>
        pub fn entry_point(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.entry_point.unwrap_or_default();
            v.push(input.into());
            self.entry_point = Some(v);
            self
        }
        /// <p>Specifies the entry point to their application, which is typically the location of the runtime executable.</p>
        pub fn set_entry_point(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.entry_point = input;
            self
        }
        /// Appends an item to `command`.
        ///
        /// To override the contents of this collection use [`set_command`](Self::set_command).
        ///
        /// <p>Specifies parameters that you want to pass in with ENTRYPOINT.</p>
        pub fn command(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.command.unwrap_or_default();
            v.push(input.into());
            self.command = Some(v);
            self
        }
        /// <p>Specifies parameters that you want to pass in with ENTRYPOINT.</p>
        pub fn set_command(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.command = input;
            self
        }
        /// <p>Specifies the working directory.</p>
        pub fn working_directory(mut self, input: impl Into<std::string::String>) -> Self {
            self.working_directory = Some(input.into());
            self
        }
        /// <p>Specifies the working directory.</p>
        pub fn set_working_directory(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.working_directory = input;
            self
        }
        /// Consumes the builder and constructs a [`ImageConfig`](crate::model::ImageConfig).
        pub fn build(self) -> crate::model::ImageConfig {
            crate::model::ImageConfig {
                entry_point: self.entry_point,
                command: self.command,
                working_directory: self.working_directory,
            }
        }
    }
}
impl ImageConfig {
    /// Creates a new builder-style object to manufacture [`ImageConfig`](crate::model::ImageConfig).
    pub fn builder() -> crate::model::image_config::Builder {
        crate::model::image_config::Builder::default()
    }
}

/// When writing a match expression against `PackageType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let packagetype = unimplemented!();
/// match packagetype {
///     PackageType::Image => { /* ... */ },
///     PackageType::Zip => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `packagetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PackageType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PackageType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PackageType::NewFeature` is defined.
/// Specifically, when `packagetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PackageType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PackageType {
    #[allow(missing_docs)] // documentation missing in model
    Image,
    #[allow(missing_docs)] // documentation missing in model
    Zip,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PackageType {
    fn from(s: &str) -> Self {
        match s {
            "Image" => PackageType::Image,
            "Zip" => PackageType::Zip,
            other => PackageType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PackageType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PackageType::from(s))
    }
}
impl PackageType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PackageType::Image => "Image",
            PackageType::Zip => "Zip",
            PackageType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Image", "Zip"]
    }
}
impl AsRef<str> for PackageType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Details about the connection between a Lambda function and an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html">Amazon EFS file system</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FileSystemConfig {
    /// <p>The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The path where the function can access the file system, starting with <code>/mnt/</code>.</p>
    #[doc(hidden)]
    pub local_mount_path: std::option::Option<std::string::String>,
}
impl FileSystemConfig {
    /// <p>The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The path where the function can access the file system, starting with <code>/mnt/</code>.</p>
    pub fn local_mount_path(&self) -> std::option::Option<&str> {
        self.local_mount_path.as_deref()
    }
}
/// See [`FileSystemConfig`](crate::model::FileSystemConfig).
pub mod file_system_config {

    /// A builder for [`FileSystemConfig`](crate::model::FileSystemConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) local_mount_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The path where the function can access the file system, starting with <code>/mnt/</code>.</p>
        pub fn local_mount_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.local_mount_path = Some(input.into());
            self
        }
        /// <p>The path where the function can access the file system, starting with <code>/mnt/</code>.</p>
        pub fn set_local_mount_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.local_mount_path = input;
            self
        }
        /// Consumes the builder and constructs a [`FileSystemConfig`](crate::model::FileSystemConfig).
        pub fn build(self) -> crate::model::FileSystemConfig {
            crate::model::FileSystemConfig {
                arn: self.arn,
                local_mount_path: self.local_mount_path,
            }
        }
    }
}
impl FileSystemConfig {
    /// Creates a new builder-style object to manufacture [`FileSystemConfig`](crate::model::FileSystemConfig).
    pub fn builder() -> crate::model::file_system_config::Builder {
        crate::model::file_system_config::Builder::default()
    }
}

/// When writing a match expression against `LastUpdateStatusReasonCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let lastupdatestatusreasoncode = unimplemented!();
/// match lastupdatestatusreasoncode {
///     LastUpdateStatusReasonCode::DisabledKmsKey => { /* ... */ },
///     LastUpdateStatusReasonCode::EfsioError => { /* ... */ },
///     LastUpdateStatusReasonCode::EfsMountConnectivityError => { /* ... */ },
///     LastUpdateStatusReasonCode::EfsMountFailure => { /* ... */ },
///     LastUpdateStatusReasonCode::EfsMountTimeout => { /* ... */ },
///     LastUpdateStatusReasonCode::EniLimitExceeded => { /* ... */ },
///     LastUpdateStatusReasonCode::FunctionError => { /* ... */ },
///     LastUpdateStatusReasonCode::ImageAccessDenied => { /* ... */ },
///     LastUpdateStatusReasonCode::ImageDeleted => { /* ... */ },
///     LastUpdateStatusReasonCode::InsufficientRolePermissions => { /* ... */ },
///     LastUpdateStatusReasonCode::InternalError => { /* ... */ },
///     LastUpdateStatusReasonCode::InvalidConfiguration => { /* ... */ },
///     LastUpdateStatusReasonCode::InvalidImage => { /* ... */ },
///     LastUpdateStatusReasonCode::InvalidRuntime => { /* ... */ },
///     LastUpdateStatusReasonCode::InvalidSecurityGroup => { /* ... */ },
///     LastUpdateStatusReasonCode::InvalidStateKmsKey => { /* ... */ },
///     LastUpdateStatusReasonCode::InvalidSubnet => { /* ... */ },
///     LastUpdateStatusReasonCode::InvalidZipFileException => { /* ... */ },
///     LastUpdateStatusReasonCode::KmsKeyAccessDenied => { /* ... */ },
///     LastUpdateStatusReasonCode::KmsKeyNotFound => { /* ... */ },
///     LastUpdateStatusReasonCode::SubnetOutOfIpAddresses => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `lastupdatestatusreasoncode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LastUpdateStatusReasonCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LastUpdateStatusReasonCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LastUpdateStatusReasonCode::NewFeature` is defined.
/// Specifically, when `lastupdatestatusreasoncode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LastUpdateStatusReasonCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LastUpdateStatusReasonCode {
    #[allow(missing_docs)] // documentation missing in model
    DisabledKmsKey,
    #[allow(missing_docs)] // documentation missing in model
    EfsioError,
    #[allow(missing_docs)] // documentation missing in model
    EfsMountConnectivityError,
    #[allow(missing_docs)] // documentation missing in model
    EfsMountFailure,
    #[allow(missing_docs)] // documentation missing in model
    EfsMountTimeout,
    #[allow(missing_docs)] // documentation missing in model
    EniLimitExceeded,
    #[allow(missing_docs)] // documentation missing in model
    FunctionError,
    #[allow(missing_docs)] // documentation missing in model
    ImageAccessDenied,
    #[allow(missing_docs)] // documentation missing in model
    ImageDeleted,
    #[allow(missing_docs)] // documentation missing in model
    InsufficientRolePermissions,
    #[allow(missing_docs)] // documentation missing in model
    InternalError,
    #[allow(missing_docs)] // documentation missing in model
    InvalidConfiguration,
    #[allow(missing_docs)] // documentation missing in model
    InvalidImage,
    #[allow(missing_docs)] // documentation missing in model
    InvalidRuntime,
    #[allow(missing_docs)] // documentation missing in model
    InvalidSecurityGroup,
    #[allow(missing_docs)] // documentation missing in model
    InvalidStateKmsKey,
    #[allow(missing_docs)] // documentation missing in model
    InvalidSubnet,
    #[allow(missing_docs)] // documentation missing in model
    InvalidZipFileException,
    #[allow(missing_docs)] // documentation missing in model
    KmsKeyAccessDenied,
    #[allow(missing_docs)] // documentation missing in model
    KmsKeyNotFound,
    #[allow(missing_docs)] // documentation missing in model
    SubnetOutOfIpAddresses,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LastUpdateStatusReasonCode {
    fn from(s: &str) -> Self {
        match s {
            "DisabledKMSKey" => LastUpdateStatusReasonCode::DisabledKmsKey,
            "EFSIOError" => LastUpdateStatusReasonCode::EfsioError,
            "EFSMountConnectivityError" => LastUpdateStatusReasonCode::EfsMountConnectivityError,
            "EFSMountFailure" => LastUpdateStatusReasonCode::EfsMountFailure,
            "EFSMountTimeout" => LastUpdateStatusReasonCode::EfsMountTimeout,
            "EniLimitExceeded" => LastUpdateStatusReasonCode::EniLimitExceeded,
            "FunctionError" => LastUpdateStatusReasonCode::FunctionError,
            "ImageAccessDenied" => LastUpdateStatusReasonCode::ImageAccessDenied,
            "ImageDeleted" => LastUpdateStatusReasonCode::ImageDeleted,
            "InsufficientRolePermissions" => {
                LastUpdateStatusReasonCode::InsufficientRolePermissions
            }
            "InternalError" => LastUpdateStatusReasonCode::InternalError,
            "InvalidConfiguration" => LastUpdateStatusReasonCode::InvalidConfiguration,
            "InvalidImage" => LastUpdateStatusReasonCode::InvalidImage,
            "InvalidRuntime" => LastUpdateStatusReasonCode::InvalidRuntime,
            "InvalidSecurityGroup" => LastUpdateStatusReasonCode::InvalidSecurityGroup,
            "InvalidStateKMSKey" => LastUpdateStatusReasonCode::InvalidStateKmsKey,
            "InvalidSubnet" => LastUpdateStatusReasonCode::InvalidSubnet,
            "InvalidZipFileException" => LastUpdateStatusReasonCode::InvalidZipFileException,
            "KMSKeyAccessDenied" => LastUpdateStatusReasonCode::KmsKeyAccessDenied,
            "KMSKeyNotFound" => LastUpdateStatusReasonCode::KmsKeyNotFound,
            "SubnetOutOfIPAddresses" => LastUpdateStatusReasonCode::SubnetOutOfIpAddresses,
            other => LastUpdateStatusReasonCode::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for LastUpdateStatusReasonCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LastUpdateStatusReasonCode::from(s))
    }
}
impl LastUpdateStatusReasonCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LastUpdateStatusReasonCode::DisabledKmsKey => "DisabledKMSKey",
            LastUpdateStatusReasonCode::EfsioError => "EFSIOError",
            LastUpdateStatusReasonCode::EfsMountConnectivityError => "EFSMountConnectivityError",
            LastUpdateStatusReasonCode::EfsMountFailure => "EFSMountFailure",
            LastUpdateStatusReasonCode::EfsMountTimeout => "EFSMountTimeout",
            LastUpdateStatusReasonCode::EniLimitExceeded => "EniLimitExceeded",
            LastUpdateStatusReasonCode::FunctionError => "FunctionError",
            LastUpdateStatusReasonCode::ImageAccessDenied => "ImageAccessDenied",
            LastUpdateStatusReasonCode::ImageDeleted => "ImageDeleted",
            LastUpdateStatusReasonCode::InsufficientRolePermissions => {
                "InsufficientRolePermissions"
            }
            LastUpdateStatusReasonCode::InternalError => "InternalError",
            LastUpdateStatusReasonCode::InvalidConfiguration => "InvalidConfiguration",
            LastUpdateStatusReasonCode::InvalidImage => "InvalidImage",
            LastUpdateStatusReasonCode::InvalidRuntime => "InvalidRuntime",
            LastUpdateStatusReasonCode::InvalidSecurityGroup => "InvalidSecurityGroup",
            LastUpdateStatusReasonCode::InvalidStateKmsKey => "InvalidStateKMSKey",
            LastUpdateStatusReasonCode::InvalidSubnet => "InvalidSubnet",
            LastUpdateStatusReasonCode::InvalidZipFileException => "InvalidZipFileException",
            LastUpdateStatusReasonCode::KmsKeyAccessDenied => "KMSKeyAccessDenied",
            LastUpdateStatusReasonCode::KmsKeyNotFound => "KMSKeyNotFound",
            LastUpdateStatusReasonCode::SubnetOutOfIpAddresses => "SubnetOutOfIPAddresses",
            LastUpdateStatusReasonCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "DisabledKMSKey",
            "EFSIOError",
            "EFSMountConnectivityError",
            "EFSMountFailure",
            "EFSMountTimeout",
            "EniLimitExceeded",
            "FunctionError",
            "ImageAccessDenied",
            "ImageDeleted",
            "InsufficientRolePermissions",
            "InternalError",
            "InvalidConfiguration",
            "InvalidImage",
            "InvalidRuntime",
            "InvalidSecurityGroup",
            "InvalidStateKMSKey",
            "InvalidSubnet",
            "InvalidZipFileException",
            "KMSKeyAccessDenied",
            "KMSKeyNotFound",
            "SubnetOutOfIPAddresses",
        ]
    }
}
impl AsRef<str> for LastUpdateStatusReasonCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `LastUpdateStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let lastupdatestatus = unimplemented!();
/// match lastupdatestatus {
///     LastUpdateStatus::Failed => { /* ... */ },
///     LastUpdateStatus::InProgress => { /* ... */ },
///     LastUpdateStatus::Successful => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `lastupdatestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LastUpdateStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LastUpdateStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LastUpdateStatus::NewFeature` is defined.
/// Specifically, when `lastupdatestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LastUpdateStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LastUpdateStatus {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Successful,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LastUpdateStatus {
    fn from(s: &str) -> Self {
        match s {
            "Failed" => LastUpdateStatus::Failed,
            "InProgress" => LastUpdateStatus::InProgress,
            "Successful" => LastUpdateStatus::Successful,
            other => LastUpdateStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for LastUpdateStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LastUpdateStatus::from(s))
    }
}
impl LastUpdateStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LastUpdateStatus::Failed => "Failed",
            LastUpdateStatus::InProgress => "InProgress",
            LastUpdateStatus::Successful => "Successful",
            LastUpdateStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Failed", "InProgress", "Successful"]
    }
}
impl AsRef<str> for LastUpdateStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `StateReasonCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let statereasoncode = unimplemented!();
/// match statereasoncode {
///     StateReasonCode::Creating => { /* ... */ },
///     StateReasonCode::DisabledKmsKey => { /* ... */ },
///     StateReasonCode::EfsioError => { /* ... */ },
///     StateReasonCode::EfsMountConnectivityError => { /* ... */ },
///     StateReasonCode::EfsMountFailure => { /* ... */ },
///     StateReasonCode::EfsMountTimeout => { /* ... */ },
///     StateReasonCode::EniLimitExceeded => { /* ... */ },
///     StateReasonCode::FunctionError => { /* ... */ },
///     StateReasonCode::Idle => { /* ... */ },
///     StateReasonCode::ImageAccessDenied => { /* ... */ },
///     StateReasonCode::ImageDeleted => { /* ... */ },
///     StateReasonCode::InsufficientRolePermissions => { /* ... */ },
///     StateReasonCode::InternalError => { /* ... */ },
///     StateReasonCode::InvalidConfiguration => { /* ... */ },
///     StateReasonCode::InvalidImage => { /* ... */ },
///     StateReasonCode::InvalidRuntime => { /* ... */ },
///     StateReasonCode::InvalidSecurityGroup => { /* ... */ },
///     StateReasonCode::InvalidStateKmsKey => { /* ... */ },
///     StateReasonCode::InvalidSubnet => { /* ... */ },
///     StateReasonCode::InvalidZipFileException => { /* ... */ },
///     StateReasonCode::KmsKeyAccessDenied => { /* ... */ },
///     StateReasonCode::KmsKeyNotFound => { /* ... */ },
///     StateReasonCode::Restoring => { /* ... */ },
///     StateReasonCode::SubnetOutOfIpAddresses => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `statereasoncode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StateReasonCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StateReasonCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StateReasonCode::NewFeature` is defined.
/// Specifically, when `statereasoncode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StateReasonCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StateReasonCode {
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    DisabledKmsKey,
    #[allow(missing_docs)] // documentation missing in model
    EfsioError,
    #[allow(missing_docs)] // documentation missing in model
    EfsMountConnectivityError,
    #[allow(missing_docs)] // documentation missing in model
    EfsMountFailure,
    #[allow(missing_docs)] // documentation missing in model
    EfsMountTimeout,
    #[allow(missing_docs)] // documentation missing in model
    EniLimitExceeded,
    #[allow(missing_docs)] // documentation missing in model
    FunctionError,
    #[allow(missing_docs)] // documentation missing in model
    Idle,
    #[allow(missing_docs)] // documentation missing in model
    ImageAccessDenied,
    #[allow(missing_docs)] // documentation missing in model
    ImageDeleted,
    #[allow(missing_docs)] // documentation missing in model
    InsufficientRolePermissions,
    #[allow(missing_docs)] // documentation missing in model
    InternalError,
    #[allow(missing_docs)] // documentation missing in model
    InvalidConfiguration,
    #[allow(missing_docs)] // documentation missing in model
    InvalidImage,
    #[allow(missing_docs)] // documentation missing in model
    InvalidRuntime,
    #[allow(missing_docs)] // documentation missing in model
    InvalidSecurityGroup,
    #[allow(missing_docs)] // documentation missing in model
    InvalidStateKmsKey,
    #[allow(missing_docs)] // documentation missing in model
    InvalidSubnet,
    #[allow(missing_docs)] // documentation missing in model
    InvalidZipFileException,
    #[allow(missing_docs)] // documentation missing in model
    KmsKeyAccessDenied,
    #[allow(missing_docs)] // documentation missing in model
    KmsKeyNotFound,
    #[allow(missing_docs)] // documentation missing in model
    Restoring,
    #[allow(missing_docs)] // documentation missing in model
    SubnetOutOfIpAddresses,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StateReasonCode {
    fn from(s: &str) -> Self {
        match s {
            "Creating" => StateReasonCode::Creating,
            "DisabledKMSKey" => StateReasonCode::DisabledKmsKey,
            "EFSIOError" => StateReasonCode::EfsioError,
            "EFSMountConnectivityError" => StateReasonCode::EfsMountConnectivityError,
            "EFSMountFailure" => StateReasonCode::EfsMountFailure,
            "EFSMountTimeout" => StateReasonCode::EfsMountTimeout,
            "EniLimitExceeded" => StateReasonCode::EniLimitExceeded,
            "FunctionError" => StateReasonCode::FunctionError,
            "Idle" => StateReasonCode::Idle,
            "ImageAccessDenied" => StateReasonCode::ImageAccessDenied,
            "ImageDeleted" => StateReasonCode::ImageDeleted,
            "InsufficientRolePermissions" => StateReasonCode::InsufficientRolePermissions,
            "InternalError" => StateReasonCode::InternalError,
            "InvalidConfiguration" => StateReasonCode::InvalidConfiguration,
            "InvalidImage" => StateReasonCode::InvalidImage,
            "InvalidRuntime" => StateReasonCode::InvalidRuntime,
            "InvalidSecurityGroup" => StateReasonCode::InvalidSecurityGroup,
            "InvalidStateKMSKey" => StateReasonCode::InvalidStateKmsKey,
            "InvalidSubnet" => StateReasonCode::InvalidSubnet,
            "InvalidZipFileException" => StateReasonCode::InvalidZipFileException,
            "KMSKeyAccessDenied" => StateReasonCode::KmsKeyAccessDenied,
            "KMSKeyNotFound" => StateReasonCode::KmsKeyNotFound,
            "Restoring" => StateReasonCode::Restoring,
            "SubnetOutOfIPAddresses" => StateReasonCode::SubnetOutOfIpAddresses,
            other => StateReasonCode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for StateReasonCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StateReasonCode::from(s))
    }
}
impl StateReasonCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StateReasonCode::Creating => "Creating",
            StateReasonCode::DisabledKmsKey => "DisabledKMSKey",
            StateReasonCode::EfsioError => "EFSIOError",
            StateReasonCode::EfsMountConnectivityError => "EFSMountConnectivityError",
            StateReasonCode::EfsMountFailure => "EFSMountFailure",
            StateReasonCode::EfsMountTimeout => "EFSMountTimeout",
            StateReasonCode::EniLimitExceeded => "EniLimitExceeded",
            StateReasonCode::FunctionError => "FunctionError",
            StateReasonCode::Idle => "Idle",
            StateReasonCode::ImageAccessDenied => "ImageAccessDenied",
            StateReasonCode::ImageDeleted => "ImageDeleted",
            StateReasonCode::InsufficientRolePermissions => "InsufficientRolePermissions",
            StateReasonCode::InternalError => "InternalError",
            StateReasonCode::InvalidConfiguration => "InvalidConfiguration",
            StateReasonCode::InvalidImage => "InvalidImage",
            StateReasonCode::InvalidRuntime => "InvalidRuntime",
            StateReasonCode::InvalidSecurityGroup => "InvalidSecurityGroup",
            StateReasonCode::InvalidStateKmsKey => "InvalidStateKMSKey",
            StateReasonCode::InvalidSubnet => "InvalidSubnet",
            StateReasonCode::InvalidZipFileException => "InvalidZipFileException",
            StateReasonCode::KmsKeyAccessDenied => "KMSKeyAccessDenied",
            StateReasonCode::KmsKeyNotFound => "KMSKeyNotFound",
            StateReasonCode::Restoring => "Restoring",
            StateReasonCode::SubnetOutOfIpAddresses => "SubnetOutOfIPAddresses",
            StateReasonCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "Creating",
            "DisabledKMSKey",
            "EFSIOError",
            "EFSMountConnectivityError",
            "EFSMountFailure",
            "EFSMountTimeout",
            "EniLimitExceeded",
            "FunctionError",
            "Idle",
            "ImageAccessDenied",
            "ImageDeleted",
            "InsufficientRolePermissions",
            "InternalError",
            "InvalidConfiguration",
            "InvalidImage",
            "InvalidRuntime",
            "InvalidSecurityGroup",
            "InvalidStateKMSKey",
            "InvalidSubnet",
            "InvalidZipFileException",
            "KMSKeyAccessDenied",
            "KMSKeyNotFound",
            "Restoring",
            "SubnetOutOfIPAddresses",
        ]
    }
}
impl AsRef<str> for StateReasonCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `State`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let state = unimplemented!();
/// match state {
///     State::Active => { /* ... */ },
///     State::Failed => { /* ... */ },
///     State::Inactive => { /* ... */ },
///     State::Pending => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `state` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `State::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `State::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `State::NewFeature` is defined.
/// Specifically, when `state` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `State::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum State {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Inactive,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for State {
    fn from(s: &str) -> Self {
        match s {
            "Active" => State::Active,
            "Failed" => State::Failed,
            "Inactive" => State::Inactive,
            "Pending" => State::Pending,
            other => State::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for State {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(State::from(s))
    }
}
impl State {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            State::Active => "Active",
            State::Failed => "Failed",
            State::Inactive => "Inactive",
            State::Pending => "Pending",
            State::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Active", "Failed", "Inactive", "Pending"]
    }
}
impl AsRef<str> for State {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">Lambda layer</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Layer {
    /// <p>The Amazon Resource Name (ARN) of the function layer.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The size of the layer archive in bytes.</p>
    #[doc(hidden)]
    pub code_size: i64,
    /// <p>The Amazon Resource Name (ARN) for a signing profile version.</p>
    #[doc(hidden)]
    pub signing_profile_version_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of a signing job.</p>
    #[doc(hidden)]
    pub signing_job_arn: std::option::Option<std::string::String>,
}
impl Layer {
    /// <p>The Amazon Resource Name (ARN) of the function layer.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The size of the layer archive in bytes.</p>
    pub fn code_size(&self) -> i64 {
        self.code_size
    }
    /// <p>The Amazon Resource Name (ARN) for a signing profile version.</p>
    pub fn signing_profile_version_arn(&self) -> std::option::Option<&str> {
        self.signing_profile_version_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of a signing job.</p>
    pub fn signing_job_arn(&self) -> std::option::Option<&str> {
        self.signing_job_arn.as_deref()
    }
}
/// See [`Layer`](crate::model::Layer).
pub mod layer {

    /// A builder for [`Layer`](crate::model::Layer).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) code_size: std::option::Option<i64>,
        pub(crate) signing_profile_version_arn: std::option::Option<std::string::String>,
        pub(crate) signing_job_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the function layer.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the function layer.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The size of the layer archive in bytes.</p>
        pub fn code_size(mut self, input: i64) -> Self {
            self.code_size = Some(input);
            self
        }
        /// <p>The size of the layer archive in bytes.</p>
        pub fn set_code_size(mut self, input: std::option::Option<i64>) -> Self {
            self.code_size = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for a signing profile version.</p>
        pub fn signing_profile_version_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.signing_profile_version_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for a signing profile version.</p>
        pub fn set_signing_profile_version_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.signing_profile_version_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a signing job.</p>
        pub fn signing_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.signing_job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a signing job.</p>
        pub fn set_signing_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.signing_job_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`Layer`](crate::model::Layer).
        pub fn build(self) -> crate::model::Layer {
            crate::model::Layer {
                arn: self.arn,
                code_size: self.code_size.unwrap_or_default(),
                signing_profile_version_arn: self.signing_profile_version_arn,
                signing_job_arn: self.signing_job_arn,
            }
        }
    }
}
impl Layer {
    /// Creates a new builder-style object to manufacture [`Layer`](crate::model::Layer).
    pub fn builder() -> crate::model::layer::Builder {
        crate::model::layer::Builder::default()
    }
}

/// <p>The function's X-Ray tracing configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TracingConfigResponse {
    /// <p>The tracing mode.</p>
    #[doc(hidden)]
    pub mode: std::option::Option<crate::model::TracingMode>,
}
impl TracingConfigResponse {
    /// <p>The tracing mode.</p>
    pub fn mode(&self) -> std::option::Option<&crate::model::TracingMode> {
        self.mode.as_ref()
    }
}
/// See [`TracingConfigResponse`](crate::model::TracingConfigResponse).
pub mod tracing_config_response {

    /// A builder for [`TracingConfigResponse`](crate::model::TracingConfigResponse).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) mode: std::option::Option<crate::model::TracingMode>,
    }
    impl Builder {
        /// <p>The tracing mode.</p>
        pub fn mode(mut self, input: crate::model::TracingMode) -> Self {
            self.mode = Some(input);
            self
        }
        /// <p>The tracing mode.</p>
        pub fn set_mode(mut self, input: std::option::Option<crate::model::TracingMode>) -> Self {
            self.mode = input;
            self
        }
        /// Consumes the builder and constructs a [`TracingConfigResponse`](crate::model::TracingConfigResponse).
        pub fn build(self) -> crate::model::TracingConfigResponse {
            crate::model::TracingConfigResponse { mode: self.mode }
        }
    }
}
impl TracingConfigResponse {
    /// Creates a new builder-style object to manufacture [`TracingConfigResponse`](crate::model::TracingConfigResponse).
    pub fn builder() -> crate::model::tracing_config_response::Builder {
        crate::model::tracing_config_response::Builder::default()
    }
}

/// When writing a match expression against `TracingMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let tracingmode = unimplemented!();
/// match tracingmode {
///     TracingMode::Active => { /* ... */ },
///     TracingMode::PassThrough => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `tracingmode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TracingMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TracingMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TracingMode::NewFeature` is defined.
/// Specifically, when `tracingmode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TracingMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TracingMode {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    PassThrough,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TracingMode {
    fn from(s: &str) -> Self {
        match s {
            "Active" => TracingMode::Active,
            "PassThrough" => TracingMode::PassThrough,
            other => TracingMode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for TracingMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TracingMode::from(s))
    }
}
impl TracingMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TracingMode::Active => "Active",
            TracingMode::PassThrough => "PassThrough",
            TracingMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Active", "PassThrough"]
    }
}
impl AsRef<str> for TracingMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The results of an operation to update or read environment variables. If the operation succeeds, the response contains the environment variables. If it fails, the response contains details about the error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EnvironmentResponse {
    /// <p>Environment variable key-value pairs. Omitted from CloudTrail logs.</p>
    #[doc(hidden)]
    pub variables:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Error messages for environment variables that couldn't be applied.</p>
    #[doc(hidden)]
    pub error: std::option::Option<crate::model::EnvironmentError>,
}
impl EnvironmentResponse {
    /// <p>Environment variable key-value pairs. Omitted from CloudTrail logs.</p>
    pub fn variables(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.variables.as_ref()
    }
    /// <p>Error messages for environment variables that couldn't be applied.</p>
    pub fn error(&self) -> std::option::Option<&crate::model::EnvironmentError> {
        self.error.as_ref()
    }
}
impl std::fmt::Debug for EnvironmentResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EnvironmentResponse");
        formatter.field("variables", &"*** Sensitive Data Redacted ***");
        formatter.field("error", &self.error);
        formatter.finish()
    }
}
/// See [`EnvironmentResponse`](crate::model::EnvironmentResponse).
pub mod environment_response {

    /// A builder for [`EnvironmentResponse`](crate::model::EnvironmentResponse).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) variables: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) error: std::option::Option<crate::model::EnvironmentError>,
    }
    impl Builder {
        /// Adds a key-value pair to `variables`.
        ///
        /// To override the contents of this collection use [`set_variables`](Self::set_variables).
        ///
        /// <p>Environment variable key-value pairs. Omitted from CloudTrail logs.</p>
        pub fn variables(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.variables.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.variables = Some(hash_map);
            self
        }
        /// <p>Environment variable key-value pairs. Omitted from CloudTrail logs.</p>
        pub fn set_variables(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.variables = input;
            self
        }
        /// <p>Error messages for environment variables that couldn't be applied.</p>
        pub fn error(mut self, input: crate::model::EnvironmentError) -> Self {
            self.error = Some(input);
            self
        }
        /// <p>Error messages for environment variables that couldn't be applied.</p>
        pub fn set_error(
            mut self,
            input: std::option::Option<crate::model::EnvironmentError>,
        ) -> Self {
            self.error = input;
            self
        }
        /// Consumes the builder and constructs a [`EnvironmentResponse`](crate::model::EnvironmentResponse).
        pub fn build(self) -> crate::model::EnvironmentResponse {
            crate::model::EnvironmentResponse {
                variables: self.variables,
                error: self.error,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("variables", &"*** Sensitive Data Redacted ***");
            formatter.field("error", &self.error);
            formatter.finish()
        }
    }
}
impl EnvironmentResponse {
    /// Creates a new builder-style object to manufacture [`EnvironmentResponse`](crate::model::EnvironmentResponse).
    pub fn builder() -> crate::model::environment_response::Builder {
        crate::model::environment_response::Builder::default()
    }
}

/// <p>Error messages for environment variables that couldn't be applied.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EnvironmentError {
    /// <p>The error code.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<std::string::String>,
    /// <p>The error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl EnvironmentError {
    /// <p>The error code.</p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p>The error message.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Debug for EnvironmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EnvironmentError");
        formatter.field("error_code", &self.error_code);
        formatter.field("message", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`EnvironmentError`](crate::model::EnvironmentError).
pub mod environment_error {

    /// A builder for [`EnvironmentError`](crate::model::EnvironmentError).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The error code.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>The error code.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>The error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`EnvironmentError`](crate::model::EnvironmentError).
        pub fn build(self) -> crate::model::EnvironmentError {
            crate::model::EnvironmentError {
                error_code: self.error_code,
                message: self.message,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("error_code", &self.error_code);
            formatter.field("message", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl EnvironmentError {
    /// Creates a new builder-style object to manufacture [`EnvironmentError`](crate::model::EnvironmentError).
    pub fn builder() -> crate::model::environment_error::Builder {
        crate::model::environment_error::Builder::default()
    }
}

/// <p>The <a href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#dlq">dead-letter queue</a> for failed asynchronous invocations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeadLetterConfig {
    /// <p>The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.</p>
    #[doc(hidden)]
    pub target_arn: std::option::Option<std::string::String>,
}
impl DeadLetterConfig {
    /// <p>The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.</p>
    pub fn target_arn(&self) -> std::option::Option<&str> {
        self.target_arn.as_deref()
    }
}
/// See [`DeadLetterConfig`](crate::model::DeadLetterConfig).
pub mod dead_letter_config {

    /// A builder for [`DeadLetterConfig`](crate::model::DeadLetterConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) target_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.</p>
        pub fn target_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.</p>
        pub fn set_target_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DeadLetterConfig`](crate::model::DeadLetterConfig).
        pub fn build(self) -> crate::model::DeadLetterConfig {
            crate::model::DeadLetterConfig {
                target_arn: self.target_arn,
            }
        }
    }
}
impl DeadLetterConfig {
    /// Creates a new builder-style object to manufacture [`DeadLetterConfig`](crate::model::DeadLetterConfig).
    pub fn builder() -> crate::model::dead_letter_config::Builder {
        crate::model::dead_letter_config::Builder::default()
    }
}

/// <p>The VPC security groups and subnets that are attached to a Lambda function.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VpcConfigResponse {
    /// <p>A list of VPC subnet IDs.</p>
    #[doc(hidden)]
    pub subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of VPC security group IDs.</p>
    #[doc(hidden)]
    pub security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ID of the VPC.</p>
    #[doc(hidden)]
    pub vpc_id: std::option::Option<std::string::String>,
}
impl VpcConfigResponse {
    /// <p>A list of VPC subnet IDs.</p>
    pub fn subnet_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.subnet_ids.as_deref()
    }
    /// <p>A list of VPC security group IDs.</p>
    pub fn security_group_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.security_group_ids.as_deref()
    }
    /// <p>The ID of the VPC.</p>
    pub fn vpc_id(&self) -> std::option::Option<&str> {
        self.vpc_id.as_deref()
    }
}
/// See [`VpcConfigResponse`](crate::model::VpcConfigResponse).
pub mod vpc_config_response {

    /// A builder for [`VpcConfigResponse`](crate::model::VpcConfigResponse).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `subnet_ids`.
        ///
        /// To override the contents of this collection use [`set_subnet_ids`](Self::set_subnet_ids).
        ///
        /// <p>A list of VPC subnet IDs.</p>
        pub fn subnet_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnet_ids.unwrap_or_default();
            v.push(input.into());
            self.subnet_ids = Some(v);
            self
        }
        /// <p>A list of VPC subnet IDs.</p>
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnet_ids = input;
            self
        }
        /// Appends an item to `security_group_ids`.
        ///
        /// To override the contents of this collection use [`set_security_group_ids`](Self::set_security_group_ids).
        ///
        /// <p>A list of VPC security group IDs.</p>
        pub fn security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.security_group_ids = Some(v);
            self
        }
        /// <p>A list of VPC security group IDs.</p>
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_ids = input;
            self
        }
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        /// <p>The ID of the VPC.</p>
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcConfigResponse`](crate::model::VpcConfigResponse).
        pub fn build(self) -> crate::model::VpcConfigResponse {
            crate::model::VpcConfigResponse {
                subnet_ids: self.subnet_ids,
                security_group_ids: self.security_group_ids,
                vpc_id: self.vpc_id,
            }
        }
    }
}
impl VpcConfigResponse {
    /// Creates a new builder-style object to manufacture [`VpcConfigResponse`](crate::model::VpcConfigResponse).
    pub fn builder() -> crate::model::vpc_config_response::Builder {
        crate::model::vpc_config_response::Builder::default()
    }
}

/// When writing a match expression against `Runtime`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let runtime = unimplemented!();
/// match runtime {
///     Runtime::Dotnet6 => { /* ... */ },
///     Runtime::Dotnetcore10 => { /* ... */ },
///     Runtime::Dotnetcore20 => { /* ... */ },
///     Runtime::Dotnetcore21 => { /* ... */ },
///     Runtime::Dotnetcore31 => { /* ... */ },
///     Runtime::Go1x => { /* ... */ },
///     Runtime::Java11 => { /* ... */ },
///     Runtime::Java8 => { /* ... */ },
///     Runtime::Java8al2 => { /* ... */ },
///     Runtime::Nodejs => { /* ... */ },
///     Runtime::Nodejs10x => { /* ... */ },
///     Runtime::Nodejs12x => { /* ... */ },
///     Runtime::Nodejs14x => { /* ... */ },
///     Runtime::Nodejs16x => { /* ... */ },
///     Runtime::Nodejs18x => { /* ... */ },
///     Runtime::Nodejs43 => { /* ... */ },
///     Runtime::Nodejs43edge => { /* ... */ },
///     Runtime::Nodejs610 => { /* ... */ },
///     Runtime::Nodejs810 => { /* ... */ },
///     Runtime::Provided => { /* ... */ },
///     Runtime::Providedal2 => { /* ... */ },
///     Runtime::Python27 => { /* ... */ },
///     Runtime::Python36 => { /* ... */ },
///     Runtime::Python37 => { /* ... */ },
///     Runtime::Python38 => { /* ... */ },
///     Runtime::Python39 => { /* ... */ },
///     Runtime::Ruby25 => { /* ... */ },
///     Runtime::Ruby27 => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `runtime` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Runtime::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Runtime::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Runtime::NewFeature` is defined.
/// Specifically, when `runtime` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Runtime::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Runtime {
    #[allow(missing_docs)] // documentation missing in model
    Dotnet6,
    #[allow(missing_docs)] // documentation missing in model
    Dotnetcore10,
    #[allow(missing_docs)] // documentation missing in model
    Dotnetcore20,
    #[allow(missing_docs)] // documentation missing in model
    Dotnetcore21,
    #[allow(missing_docs)] // documentation missing in model
    Dotnetcore31,
    #[allow(missing_docs)] // documentation missing in model
    Go1x,
    #[allow(missing_docs)] // documentation missing in model
    Java11,
    #[allow(missing_docs)] // documentation missing in model
    Java8,
    #[allow(missing_docs)] // documentation missing in model
    Java8al2,
    #[allow(missing_docs)] // documentation missing in model
    Nodejs,
    #[allow(missing_docs)] // documentation missing in model
    Nodejs10x,
    #[allow(missing_docs)] // documentation missing in model
    Nodejs12x,
    #[allow(missing_docs)] // documentation missing in model
    Nodejs14x,
    #[allow(missing_docs)] // documentation missing in model
    Nodejs16x,
    #[allow(missing_docs)] // documentation missing in model
    Nodejs18x,
    #[allow(missing_docs)] // documentation missing in model
    Nodejs43,
    #[allow(missing_docs)] // documentation missing in model
    Nodejs43edge,
    #[allow(missing_docs)] // documentation missing in model
    Nodejs610,
    #[allow(missing_docs)] // documentation missing in model
    Nodejs810,
    #[allow(missing_docs)] // documentation missing in model
    Provided,
    #[allow(missing_docs)] // documentation missing in model
    Providedal2,
    #[allow(missing_docs)] // documentation missing in model
    Python27,
    #[allow(missing_docs)] // documentation missing in model
    Python36,
    #[allow(missing_docs)] // documentation missing in model
    Python37,
    #[allow(missing_docs)] // documentation missing in model
    Python38,
    #[allow(missing_docs)] // documentation missing in model
    Python39,
    #[allow(missing_docs)] // documentation missing in model
    Ruby25,
    #[allow(missing_docs)] // documentation missing in model
    Ruby27,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Runtime {
    fn from(s: &str) -> Self {
        match s {
            "dotnet6" => Runtime::Dotnet6,
            "dotnetcore1.0" => Runtime::Dotnetcore10,
            "dotnetcore2.0" => Runtime::Dotnetcore20,
            "dotnetcore2.1" => Runtime::Dotnetcore21,
            "dotnetcore3.1" => Runtime::Dotnetcore31,
            "go1.x" => Runtime::Go1x,
            "java11" => Runtime::Java11,
            "java8" => Runtime::Java8,
            "java8.al2" => Runtime::Java8al2,
            "nodejs" => Runtime::Nodejs,
            "nodejs10.x" => Runtime::Nodejs10x,
            "nodejs12.x" => Runtime::Nodejs12x,
            "nodejs14.x" => Runtime::Nodejs14x,
            "nodejs16.x" => Runtime::Nodejs16x,
            "nodejs18.x" => Runtime::Nodejs18x,
            "nodejs4.3" => Runtime::Nodejs43,
            "nodejs4.3-edge" => Runtime::Nodejs43edge,
            "nodejs6.10" => Runtime::Nodejs610,
            "nodejs8.10" => Runtime::Nodejs810,
            "provided" => Runtime::Provided,
            "provided.al2" => Runtime::Providedal2,
            "python2.7" => Runtime::Python27,
            "python3.6" => Runtime::Python36,
            "python3.7" => Runtime::Python37,
            "python3.8" => Runtime::Python38,
            "python3.9" => Runtime::Python39,
            "ruby2.5" => Runtime::Ruby25,
            "ruby2.7" => Runtime::Ruby27,
            other => Runtime::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Runtime {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Runtime::from(s))
    }
}
impl Runtime {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Runtime::Dotnet6 => "dotnet6",
            Runtime::Dotnetcore10 => "dotnetcore1.0",
            Runtime::Dotnetcore20 => "dotnetcore2.0",
            Runtime::Dotnetcore21 => "dotnetcore2.1",
            Runtime::Dotnetcore31 => "dotnetcore3.1",
            Runtime::Go1x => "go1.x",
            Runtime::Java11 => "java11",
            Runtime::Java8 => "java8",
            Runtime::Java8al2 => "java8.al2",
            Runtime::Nodejs => "nodejs",
            Runtime::Nodejs10x => "nodejs10.x",
            Runtime::Nodejs12x => "nodejs12.x",
            Runtime::Nodejs14x => "nodejs14.x",
            Runtime::Nodejs16x => "nodejs16.x",
            Runtime::Nodejs18x => "nodejs18.x",
            Runtime::Nodejs43 => "nodejs4.3",
            Runtime::Nodejs43edge => "nodejs4.3-edge",
            Runtime::Nodejs610 => "nodejs6.10",
            Runtime::Nodejs810 => "nodejs8.10",
            Runtime::Provided => "provided",
            Runtime::Providedal2 => "provided.al2",
            Runtime::Python27 => "python2.7",
            Runtime::Python36 => "python3.6",
            Runtime::Python37 => "python3.7",
            Runtime::Python38 => "python3.8",
            Runtime::Python39 => "python3.9",
            Runtime::Ruby25 => "ruby2.5",
            Runtime::Ruby27 => "ruby2.7",
            Runtime::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "dotnet6",
            "dotnetcore1.0",
            "dotnetcore2.0",
            "dotnetcore2.1",
            "dotnetcore3.1",
            "go1.x",
            "java11",
            "java8",
            "java8.al2",
            "nodejs",
            "nodejs10.x",
            "nodejs12.x",
            "nodejs14.x",
            "nodejs16.x",
            "nodejs18.x",
            "nodejs4.3",
            "nodejs4.3-edge",
            "nodejs6.10",
            "nodejs8.10",
            "provided",
            "provided.al2",
            "python2.7",
            "python3.6",
            "python3.7",
            "python3.8",
            "python3.9",
            "ruby2.5",
            "ruby2.7",
        ]
    }
}
impl AsRef<str> for Runtime {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The function's Lambda SnapStart setting. Set <code>ApplyOn</code> to <code>PublishedVersions</code> to create a snapshot of the initialized execution environment when you publish a function version.</p>
/// <p>SnapStart is supported with the <code>java11</code> runtime. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html">Improving startup performance with Lambda SnapStart</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SnapStart {
    /// <p>Set to <code>PublishedVersions</code> to create a snapshot of the initialized execution environment when you publish a function version.</p>
    #[doc(hidden)]
    pub apply_on: std::option::Option<crate::model::SnapStartApplyOn>,
}
impl SnapStart {
    /// <p>Set to <code>PublishedVersions</code> to create a snapshot of the initialized execution environment when you publish a function version.</p>
    pub fn apply_on(&self) -> std::option::Option<&crate::model::SnapStartApplyOn> {
        self.apply_on.as_ref()
    }
}
/// See [`SnapStart`](crate::model::SnapStart).
pub mod snap_start {

    /// A builder for [`SnapStart`](crate::model::SnapStart).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) apply_on: std::option::Option<crate::model::SnapStartApplyOn>,
    }
    impl Builder {
        /// <p>Set to <code>PublishedVersions</code> to create a snapshot of the initialized execution environment when you publish a function version.</p>
        pub fn apply_on(mut self, input: crate::model::SnapStartApplyOn) -> Self {
            self.apply_on = Some(input);
            self
        }
        /// <p>Set to <code>PublishedVersions</code> to create a snapshot of the initialized execution environment when you publish a function version.</p>
        pub fn set_apply_on(
            mut self,
            input: std::option::Option<crate::model::SnapStartApplyOn>,
        ) -> Self {
            self.apply_on = input;
            self
        }
        /// Consumes the builder and constructs a [`SnapStart`](crate::model::SnapStart).
        pub fn build(self) -> crate::model::SnapStart {
            crate::model::SnapStart {
                apply_on: self.apply_on,
            }
        }
    }
}
impl SnapStart {
    /// Creates a new builder-style object to manufacture [`SnapStart`](crate::model::SnapStart).
    pub fn builder() -> crate::model::snap_start::Builder {
        crate::model::snap_start::Builder::default()
    }
}

/// <p>The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html">X-Ray</a> tracing configuration. To sample and record incoming requests, set <code>Mode</code> to <code>Active</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TracingConfig {
    /// <p>The tracing mode.</p>
    #[doc(hidden)]
    pub mode: std::option::Option<crate::model::TracingMode>,
}
impl TracingConfig {
    /// <p>The tracing mode.</p>
    pub fn mode(&self) -> std::option::Option<&crate::model::TracingMode> {
        self.mode.as_ref()
    }
}
/// See [`TracingConfig`](crate::model::TracingConfig).
pub mod tracing_config {

    /// A builder for [`TracingConfig`](crate::model::TracingConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) mode: std::option::Option<crate::model::TracingMode>,
    }
    impl Builder {
        /// <p>The tracing mode.</p>
        pub fn mode(mut self, input: crate::model::TracingMode) -> Self {
            self.mode = Some(input);
            self
        }
        /// <p>The tracing mode.</p>
        pub fn set_mode(mut self, input: std::option::Option<crate::model::TracingMode>) -> Self {
            self.mode = input;
            self
        }
        /// Consumes the builder and constructs a [`TracingConfig`](crate::model::TracingConfig).
        pub fn build(self) -> crate::model::TracingConfig {
            crate::model::TracingConfig { mode: self.mode }
        }
    }
}
impl TracingConfig {
    /// Creates a new builder-style object to manufacture [`TracingConfig`](crate::model::TracingConfig).
    pub fn builder() -> crate::model::tracing_config::Builder {
        crate::model::tracing_config::Builder::default()
    }
}

/// <p>A function's environment variable settings. You can use environment variables to adjust your function's behavior without updating code. An environment variable is a pair of strings that are stored in a function's version-specific configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Environment {
    /// <p>Environment variable key-value pairs. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html">Using Lambda environment variables</a>.</p>
    #[doc(hidden)]
    pub variables:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl Environment {
    /// <p>Environment variable key-value pairs. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html">Using Lambda environment variables</a>.</p>
    pub fn variables(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.variables.as_ref()
    }
}
impl std::fmt::Debug for Environment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Environment");
        formatter.field("variables", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`Environment`](crate::model::Environment).
pub mod environment {

    /// A builder for [`Environment`](crate::model::Environment).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) variables: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// Adds a key-value pair to `variables`.
        ///
        /// To override the contents of this collection use [`set_variables`](Self::set_variables).
        ///
        /// <p>Environment variable key-value pairs. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html">Using Lambda environment variables</a>.</p>
        pub fn variables(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.variables.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.variables = Some(hash_map);
            self
        }
        /// <p>Environment variable key-value pairs. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html">Using Lambda environment variables</a>.</p>
        pub fn set_variables(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.variables = input;
            self
        }
        /// Consumes the builder and constructs a [`Environment`](crate::model::Environment).
        pub fn build(self) -> crate::model::Environment {
            crate::model::Environment {
                variables: self.variables,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("variables", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl Environment {
    /// Creates a new builder-style object to manufacture [`Environment`](crate::model::Environment).
    pub fn builder() -> crate::model::environment::Builder {
        crate::model::environment::Builder::default()
    }
}

/// <p>The VPC security groups and subnets that are attached to a Lambda function. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html">Configuring a Lambda function to access resources in a VPC</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VpcConfig {
    /// <p>A list of VPC subnet IDs.</p>
    #[doc(hidden)]
    pub subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of VPC security group IDs.</p>
    #[doc(hidden)]
    pub security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl VpcConfig {
    /// <p>A list of VPC subnet IDs.</p>
    pub fn subnet_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.subnet_ids.as_deref()
    }
    /// <p>A list of VPC security group IDs.</p>
    pub fn security_group_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.security_group_ids.as_deref()
    }
}
/// See [`VpcConfig`](crate::model::VpcConfig).
pub mod vpc_config {

    /// A builder for [`VpcConfig`](crate::model::VpcConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `subnet_ids`.
        ///
        /// To override the contents of this collection use [`set_subnet_ids`](Self::set_subnet_ids).
        ///
        /// <p>A list of VPC subnet IDs.</p>
        pub fn subnet_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnet_ids.unwrap_or_default();
            v.push(input.into());
            self.subnet_ids = Some(v);
            self
        }
        /// <p>A list of VPC subnet IDs.</p>
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnet_ids = input;
            self
        }
        /// Appends an item to `security_group_ids`.
        ///
        /// To override the contents of this collection use [`set_security_group_ids`](Self::set_security_group_ids).
        ///
        /// <p>A list of VPC security group IDs.</p>
        pub fn security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.security_group_ids = Some(v);
            self
        }
        /// <p>A list of VPC security group IDs.</p>
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcConfig`](crate::model::VpcConfig).
        pub fn build(self) -> crate::model::VpcConfig {
            crate::model::VpcConfig {
                subnet_ids: self.subnet_ids,
                security_group_ids: self.security_group_ids,
            }
        }
    }
}
impl VpcConfig {
    /// Creates a new builder-style object to manufacture [`VpcConfig`](crate::model::VpcConfig).
    pub fn builder() -> crate::model::vpc_config::Builder {
        crate::model::vpc_config::Builder::default()
    }
}

/// <p>(Amazon SQS only) The scaling configuration for the event source. To remove the configuration, pass an empty value.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ScalingConfig {
    /// <p>Limits the number of concurrent instances that the Amazon SQS event source can invoke.</p>
    #[doc(hidden)]
    pub maximum_concurrency: std::option::Option<i32>,
}
impl ScalingConfig {
    /// <p>Limits the number of concurrent instances that the Amazon SQS event source can invoke.</p>
    pub fn maximum_concurrency(&self) -> std::option::Option<i32> {
        self.maximum_concurrency
    }
}
/// See [`ScalingConfig`](crate::model::ScalingConfig).
pub mod scaling_config {

    /// A builder for [`ScalingConfig`](crate::model::ScalingConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) maximum_concurrency: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Limits the number of concurrent instances that the Amazon SQS event source can invoke.</p>
        pub fn maximum_concurrency(mut self, input: i32) -> Self {
            self.maximum_concurrency = Some(input);
            self
        }
        /// <p>Limits the number of concurrent instances that the Amazon SQS event source can invoke.</p>
        pub fn set_maximum_concurrency(mut self, input: std::option::Option<i32>) -> Self {
            self.maximum_concurrency = input;
            self
        }
        /// Consumes the builder and constructs a [`ScalingConfig`](crate::model::ScalingConfig).
        pub fn build(self) -> crate::model::ScalingConfig {
            crate::model::ScalingConfig {
                maximum_concurrency: self.maximum_concurrency,
            }
        }
    }
}
impl ScalingConfig {
    /// Creates a new builder-style object to manufacture [`ScalingConfig`](crate::model::ScalingConfig).
    pub fn builder() -> crate::model::scaling_config::Builder {
        crate::model::scaling_config::Builder::default()
    }
}

/// <p>Specific configuration settings for a self-managed Apache Kafka event source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SelfManagedKafkaEventSourceConfig {
    /// <p>The identifier for the Kafka consumer group to join. The consumer group ID must be unique among all your Kafka event sources. After creating a Kafka event source mapping with the consumer group ID specified, you cannot update this value. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/with-msk.html#services-msk-consumer-group-id">Customizable consumer group ID</a>.</p>
    #[doc(hidden)]
    pub consumer_group_id: std::option::Option<std::string::String>,
}
impl SelfManagedKafkaEventSourceConfig {
    /// <p>The identifier for the Kafka consumer group to join. The consumer group ID must be unique among all your Kafka event sources. After creating a Kafka event source mapping with the consumer group ID specified, you cannot update this value. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/with-msk.html#services-msk-consumer-group-id">Customizable consumer group ID</a>.</p>
    pub fn consumer_group_id(&self) -> std::option::Option<&str> {
        self.consumer_group_id.as_deref()
    }
}
/// See [`SelfManagedKafkaEventSourceConfig`](crate::model::SelfManagedKafkaEventSourceConfig).
pub mod self_managed_kafka_event_source_config {

    /// A builder for [`SelfManagedKafkaEventSourceConfig`](crate::model::SelfManagedKafkaEventSourceConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) consumer_group_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the Kafka consumer group to join. The consumer group ID must be unique among all your Kafka event sources. After creating a Kafka event source mapping with the consumer group ID specified, you cannot update this value. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/with-msk.html#services-msk-consumer-group-id">Customizable consumer group ID</a>.</p>
        pub fn consumer_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.consumer_group_id = Some(input.into());
            self
        }
        /// <p>The identifier for the Kafka consumer group to join. The consumer group ID must be unique among all your Kafka event sources. After creating a Kafka event source mapping with the consumer group ID specified, you cannot update this value. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/with-msk.html#services-msk-consumer-group-id">Customizable consumer group ID</a>.</p>
        pub fn set_consumer_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.consumer_group_id = input;
            self
        }
        /// Consumes the builder and constructs a [`SelfManagedKafkaEventSourceConfig`](crate::model::SelfManagedKafkaEventSourceConfig).
        pub fn build(self) -> crate::model::SelfManagedKafkaEventSourceConfig {
            crate::model::SelfManagedKafkaEventSourceConfig {
                consumer_group_id: self.consumer_group_id,
            }
        }
    }
}
impl SelfManagedKafkaEventSourceConfig {
    /// Creates a new builder-style object to manufacture [`SelfManagedKafkaEventSourceConfig`](crate::model::SelfManagedKafkaEventSourceConfig).
    pub fn builder() -> crate::model::self_managed_kafka_event_source_config::Builder {
        crate::model::self_managed_kafka_event_source_config::Builder::default()
    }
}

/// <p>Specific configuration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) event source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AmazonManagedKafkaEventSourceConfig {
    /// <p>The identifier for the Kafka consumer group to join. The consumer group ID must be unique among all your Kafka event sources. After creating a Kafka event source mapping with the consumer group ID specified, you cannot update this value. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/with-msk.html#services-msk-consumer-group-id">Customizable consumer group ID</a>.</p>
    #[doc(hidden)]
    pub consumer_group_id: std::option::Option<std::string::String>,
}
impl AmazonManagedKafkaEventSourceConfig {
    /// <p>The identifier for the Kafka consumer group to join. The consumer group ID must be unique among all your Kafka event sources. After creating a Kafka event source mapping with the consumer group ID specified, you cannot update this value. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/with-msk.html#services-msk-consumer-group-id">Customizable consumer group ID</a>.</p>
    pub fn consumer_group_id(&self) -> std::option::Option<&str> {
        self.consumer_group_id.as_deref()
    }
}
/// See [`AmazonManagedKafkaEventSourceConfig`](crate::model::AmazonManagedKafkaEventSourceConfig).
pub mod amazon_managed_kafka_event_source_config {

    /// A builder for [`AmazonManagedKafkaEventSourceConfig`](crate::model::AmazonManagedKafkaEventSourceConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) consumer_group_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the Kafka consumer group to join. The consumer group ID must be unique among all your Kafka event sources. After creating a Kafka event source mapping with the consumer group ID specified, you cannot update this value. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/with-msk.html#services-msk-consumer-group-id">Customizable consumer group ID</a>.</p>
        pub fn consumer_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.consumer_group_id = Some(input.into());
            self
        }
        /// <p>The identifier for the Kafka consumer group to join. The consumer group ID must be unique among all your Kafka event sources. After creating a Kafka event source mapping with the consumer group ID specified, you cannot update this value. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/with-msk.html#services-msk-consumer-group-id">Customizable consumer group ID</a>.</p>
        pub fn set_consumer_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.consumer_group_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AmazonManagedKafkaEventSourceConfig`](crate::model::AmazonManagedKafkaEventSourceConfig).
        pub fn build(self) -> crate::model::AmazonManagedKafkaEventSourceConfig {
            crate::model::AmazonManagedKafkaEventSourceConfig {
                consumer_group_id: self.consumer_group_id,
            }
        }
    }
}
impl AmazonManagedKafkaEventSourceConfig {
    /// Creates a new builder-style object to manufacture [`AmazonManagedKafkaEventSourceConfig`](crate::model::AmazonManagedKafkaEventSourceConfig).
    pub fn builder() -> crate::model::amazon_managed_kafka_event_source_config::Builder {
        crate::model::amazon_managed_kafka_event_source_config::Builder::default()
    }
}

/// When writing a match expression against `FunctionResponseType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let functionresponsetype = unimplemented!();
/// match functionresponsetype {
///     FunctionResponseType::ReportBatchItemFailures => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `functionresponsetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FunctionResponseType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FunctionResponseType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FunctionResponseType::NewFeature` is defined.
/// Specifically, when `functionresponsetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FunctionResponseType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FunctionResponseType {
    #[allow(missing_docs)] // documentation missing in model
    ReportBatchItemFailures,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FunctionResponseType {
    fn from(s: &str) -> Self {
        match s {
            "ReportBatchItemFailures" => FunctionResponseType::ReportBatchItemFailures,
            other => {
                FunctionResponseType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for FunctionResponseType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FunctionResponseType::from(s))
    }
}
impl FunctionResponseType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FunctionResponseType::ReportBatchItemFailures => "ReportBatchItemFailures",
            FunctionResponseType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ReportBatchItemFailures"]
    }
}
impl AsRef<str> for FunctionResponseType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The self-managed Apache Kafka cluster for your event source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SelfManagedEventSource {
    /// <p>The list of bootstrap servers for your Kafka brokers in the following format: <code>"KAFKA_BOOTSTRAP_SERVERS": ["abc.xyz.com:xxxx","abc2.xyz.com:xxxx"]</code>.</p>
    #[doc(hidden)]
    pub endpoints: std::option::Option<
        std::collections::HashMap<crate::model::EndPointType, std::vec::Vec<std::string::String>>,
    >,
}
impl SelfManagedEventSource {
    /// <p>The list of bootstrap servers for your Kafka brokers in the following format: <code>"KAFKA_BOOTSTRAP_SERVERS": ["abc.xyz.com:xxxx","abc2.xyz.com:xxxx"]</code>.</p>
    pub fn endpoints(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<crate::model::EndPointType, std::vec::Vec<std::string::String>>,
    > {
        self.endpoints.as_ref()
    }
}
/// See [`SelfManagedEventSource`](crate::model::SelfManagedEventSource).
pub mod self_managed_event_source {

    /// A builder for [`SelfManagedEventSource`](crate::model::SelfManagedEventSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoints: std::option::Option<
            std::collections::HashMap<
                crate::model::EndPointType,
                std::vec::Vec<std::string::String>,
            >,
        >,
    }
    impl Builder {
        /// Adds a key-value pair to `endpoints`.
        ///
        /// To override the contents of this collection use [`set_endpoints`](Self::set_endpoints).
        ///
        /// <p>The list of bootstrap servers for your Kafka brokers in the following format: <code>"KAFKA_BOOTSTRAP_SERVERS": ["abc.xyz.com:xxxx","abc2.xyz.com:xxxx"]</code>.</p>
        pub fn endpoints(
            mut self,
            k: crate::model::EndPointType,
            v: std::vec::Vec<std::string::String>,
        ) -> Self {
            let mut hash_map = self.endpoints.unwrap_or_default();
            hash_map.insert(k, v);
            self.endpoints = Some(hash_map);
            self
        }
        /// <p>The list of bootstrap servers for your Kafka brokers in the following format: <code>"KAFKA_BOOTSTRAP_SERVERS": ["abc.xyz.com:xxxx","abc2.xyz.com:xxxx"]</code>.</p>
        pub fn set_endpoints(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    crate::model::EndPointType,
                    std::vec::Vec<std::string::String>,
                >,
            >,
        ) -> Self {
            self.endpoints = input;
            self
        }
        /// Consumes the builder and constructs a [`SelfManagedEventSource`](crate::model::SelfManagedEventSource).
        pub fn build(self) -> crate::model::SelfManagedEventSource {
            crate::model::SelfManagedEventSource {
                endpoints: self.endpoints,
            }
        }
    }
}
impl SelfManagedEventSource {
    /// Creates a new builder-style object to manufacture [`SelfManagedEventSource`](crate::model::SelfManagedEventSource).
    pub fn builder() -> crate::model::self_managed_event_source::Builder {
        crate::model::self_managed_event_source::Builder::default()
    }
}

/// When writing a match expression against `EndPointType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let endpointtype = unimplemented!();
/// match endpointtype {
///     EndPointType::KafkaBootstrapServers => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `endpointtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EndPointType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EndPointType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EndPointType::NewFeature` is defined.
/// Specifically, when `endpointtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EndPointType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EndPointType {
    #[allow(missing_docs)] // documentation missing in model
    KafkaBootstrapServers,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EndPointType {
    fn from(s: &str) -> Self {
        match s {
            "KAFKA_BOOTSTRAP_SERVERS" => EndPointType::KafkaBootstrapServers,
            other => EndPointType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for EndPointType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EndPointType::from(s))
    }
}
impl EndPointType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EndPointType::KafkaBootstrapServers => "KAFKA_BOOTSTRAP_SERVERS",
            EndPointType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["KAFKA_BOOTSTRAP_SERVERS"]
    }
}
impl AsRef<str> for EndPointType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>To secure and define access to your event source, you can specify the authentication protocol, VPC components, or virtual host.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SourceAccessConfiguration {
    /// <p>The type of authentication protocol, VPC components, or virtual host for your event source. For example: <code>"Type":"SASL_SCRAM_512_AUTH"</code>.</p>
    /// <ul>
    /// <li> <p> <code>BASIC_AUTH</code> – (Amazon MQ) The Secrets Manager secret that stores your broker credentials.</p> </li>
    /// <li> <p> <code>BASIC_AUTH</code> – (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL/PLAIN authentication of your Apache Kafka brokers.</p> </li>
    /// <li> <p> <code>VPC_SUBNET</code> – (Self-managed Apache Kafka) The subnets associated with your VPC. Lambda connects to these subnets to fetch data from your self-managed Apache Kafka cluster.</p> </li>
    /// <li> <p> <code>VPC_SECURITY_GROUP</code> – (Self-managed Apache Kafka) The VPC security group used to manage access to your self-managed Apache Kafka brokers.</p> </li>
    /// <li> <p> <code>SASL_SCRAM_256_AUTH</code> – (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL SCRAM-256 authentication of your self-managed Apache Kafka brokers.</p> </li>
    /// <li> <p> <code>SASL_SCRAM_512_AUTH</code> – (Amazon MSK, Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL SCRAM-512 authentication of your self-managed Apache Kafka brokers.</p> </li>
    /// <li> <p> <code>VIRTUAL_HOST</code> –- (RabbitMQ) The name of the virtual host in your RabbitMQ broker. Lambda uses this RabbitMQ host as the event source. This property cannot be specified in an UpdateEventSourceMapping API call.</p> </li>
    /// <li> <p> <code>CLIENT_CERTIFICATE_TLS_AUTH</code> – (Amazon MSK, self-managed Apache Kafka) The Secrets Manager ARN of your secret key containing the certificate chain (X.509 PEM), private key (PKCS#8 PEM), and private key password (optional) used for mutual TLS authentication of your MSK/Apache Kafka brokers.</p> </li>
    /// <li> <p> <code>SERVER_ROOT_CA_CERTIFICATE</code> – (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key containing the root CA certificate (X.509 PEM) used for TLS encryption of your Apache Kafka brokers. </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::SourceAccessType>,
    /// <p>The value for your chosen configuration in <code>Type</code>. For example: <code>"URI": "arn:aws:secretsmanager:us-east-1:01234567890:secret:MyBrokerSecretName"</code>.</p>
    #[doc(hidden)]
    pub uri: std::option::Option<std::string::String>,
}
impl SourceAccessConfiguration {
    /// <p>The type of authentication protocol, VPC components, or virtual host for your event source. For example: <code>"Type":"SASL_SCRAM_512_AUTH"</code>.</p>
    /// <ul>
    /// <li> <p> <code>BASIC_AUTH</code> – (Amazon MQ) The Secrets Manager secret that stores your broker credentials.</p> </li>
    /// <li> <p> <code>BASIC_AUTH</code> – (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL/PLAIN authentication of your Apache Kafka brokers.</p> </li>
    /// <li> <p> <code>VPC_SUBNET</code> – (Self-managed Apache Kafka) The subnets associated with your VPC. Lambda connects to these subnets to fetch data from your self-managed Apache Kafka cluster.</p> </li>
    /// <li> <p> <code>VPC_SECURITY_GROUP</code> – (Self-managed Apache Kafka) The VPC security group used to manage access to your self-managed Apache Kafka brokers.</p> </li>
    /// <li> <p> <code>SASL_SCRAM_256_AUTH</code> – (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL SCRAM-256 authentication of your self-managed Apache Kafka brokers.</p> </li>
    /// <li> <p> <code>SASL_SCRAM_512_AUTH</code> – (Amazon MSK, Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL SCRAM-512 authentication of your self-managed Apache Kafka brokers.</p> </li>
    /// <li> <p> <code>VIRTUAL_HOST</code> –- (RabbitMQ) The name of the virtual host in your RabbitMQ broker. Lambda uses this RabbitMQ host as the event source. This property cannot be specified in an UpdateEventSourceMapping API call.</p> </li>
    /// <li> <p> <code>CLIENT_CERTIFICATE_TLS_AUTH</code> – (Amazon MSK, self-managed Apache Kafka) The Secrets Manager ARN of your secret key containing the certificate chain (X.509 PEM), private key (PKCS#8 PEM), and private key password (optional) used for mutual TLS authentication of your MSK/Apache Kafka brokers.</p> </li>
    /// <li> <p> <code>SERVER_ROOT_CA_CERTIFICATE</code> – (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key containing the root CA certificate (X.509 PEM) used for TLS encryption of your Apache Kafka brokers. </p> </li>
    /// </ul>
    pub fn r#type(&self) -> std::option::Option<&crate::model::SourceAccessType> {
        self.r#type.as_ref()
    }
    /// <p>The value for your chosen configuration in <code>Type</code>. For example: <code>"URI": "arn:aws:secretsmanager:us-east-1:01234567890:secret:MyBrokerSecretName"</code>.</p>
    pub fn uri(&self) -> std::option::Option<&str> {
        self.uri.as_deref()
    }
}
/// See [`SourceAccessConfiguration`](crate::model::SourceAccessConfiguration).
pub mod source_access_configuration {

    /// A builder for [`SourceAccessConfiguration`](crate::model::SourceAccessConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::SourceAccessType>,
        pub(crate) uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of authentication protocol, VPC components, or virtual host for your event source. For example: <code>"Type":"SASL_SCRAM_512_AUTH"</code>.</p>
        /// <ul>
        /// <li> <p> <code>BASIC_AUTH</code> – (Amazon MQ) The Secrets Manager secret that stores your broker credentials.</p> </li>
        /// <li> <p> <code>BASIC_AUTH</code> – (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL/PLAIN authentication of your Apache Kafka brokers.</p> </li>
        /// <li> <p> <code>VPC_SUBNET</code> – (Self-managed Apache Kafka) The subnets associated with your VPC. Lambda connects to these subnets to fetch data from your self-managed Apache Kafka cluster.</p> </li>
        /// <li> <p> <code>VPC_SECURITY_GROUP</code> – (Self-managed Apache Kafka) The VPC security group used to manage access to your self-managed Apache Kafka brokers.</p> </li>
        /// <li> <p> <code>SASL_SCRAM_256_AUTH</code> – (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL SCRAM-256 authentication of your self-managed Apache Kafka brokers.</p> </li>
        /// <li> <p> <code>SASL_SCRAM_512_AUTH</code> – (Amazon MSK, Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL SCRAM-512 authentication of your self-managed Apache Kafka brokers.</p> </li>
        /// <li> <p> <code>VIRTUAL_HOST</code> –- (RabbitMQ) The name of the virtual host in your RabbitMQ broker. Lambda uses this RabbitMQ host as the event source. This property cannot be specified in an UpdateEventSourceMapping API call.</p> </li>
        /// <li> <p> <code>CLIENT_CERTIFICATE_TLS_AUTH</code> – (Amazon MSK, self-managed Apache Kafka) The Secrets Manager ARN of your secret key containing the certificate chain (X.509 PEM), private key (PKCS#8 PEM), and private key password (optional) used for mutual TLS authentication of your MSK/Apache Kafka brokers.</p> </li>
        /// <li> <p> <code>SERVER_ROOT_CA_CERTIFICATE</code> – (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key containing the root CA certificate (X.509 PEM) used for TLS encryption of your Apache Kafka brokers. </p> </li>
        /// </ul>
        pub fn r#type(mut self, input: crate::model::SourceAccessType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of authentication protocol, VPC components, or virtual host for your event source. For example: <code>"Type":"SASL_SCRAM_512_AUTH"</code>.</p>
        /// <ul>
        /// <li> <p> <code>BASIC_AUTH</code> – (Amazon MQ) The Secrets Manager secret that stores your broker credentials.</p> </li>
        /// <li> <p> <code>BASIC_AUTH</code> – (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL/PLAIN authentication of your Apache Kafka brokers.</p> </li>
        /// <li> <p> <code>VPC_SUBNET</code> – (Self-managed Apache Kafka) The subnets associated with your VPC. Lambda connects to these subnets to fetch data from your self-managed Apache Kafka cluster.</p> </li>
        /// <li> <p> <code>VPC_SECURITY_GROUP</code> – (Self-managed Apache Kafka) The VPC security group used to manage access to your self-managed Apache Kafka brokers.</p> </li>
        /// <li> <p> <code>SASL_SCRAM_256_AUTH</code> – (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL SCRAM-256 authentication of your self-managed Apache Kafka brokers.</p> </li>
        /// <li> <p> <code>SASL_SCRAM_512_AUTH</code> – (Amazon MSK, Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL SCRAM-512 authentication of your self-managed Apache Kafka brokers.</p> </li>
        /// <li> <p> <code>VIRTUAL_HOST</code> –- (RabbitMQ) The name of the virtual host in your RabbitMQ broker. Lambda uses this RabbitMQ host as the event source. This property cannot be specified in an UpdateEventSourceMapping API call.</p> </li>
        /// <li> <p> <code>CLIENT_CERTIFICATE_TLS_AUTH</code> – (Amazon MSK, self-managed Apache Kafka) The Secrets Manager ARN of your secret key containing the certificate chain (X.509 PEM), private key (PKCS#8 PEM), and private key password (optional) used for mutual TLS authentication of your MSK/Apache Kafka brokers.</p> </li>
        /// <li> <p> <code>SERVER_ROOT_CA_CERTIFICATE</code> – (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key containing the root CA certificate (X.509 PEM) used for TLS encryption of your Apache Kafka brokers. </p> </li>
        /// </ul>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::SourceAccessType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The value for your chosen configuration in <code>Type</code>. For example: <code>"URI": "arn:aws:secretsmanager:us-east-1:01234567890:secret:MyBrokerSecretName"</code>.</p>
        pub fn uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.uri = Some(input.into());
            self
        }
        /// <p>The value for your chosen configuration in <code>Type</code>. For example: <code>"URI": "arn:aws:secretsmanager:us-east-1:01234567890:secret:MyBrokerSecretName"</code>.</p>
        pub fn set_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.uri = input;
            self
        }
        /// Consumes the builder and constructs a [`SourceAccessConfiguration`](crate::model::SourceAccessConfiguration).
        pub fn build(self) -> crate::model::SourceAccessConfiguration {
            crate::model::SourceAccessConfiguration {
                r#type: self.r#type,
                uri: self.uri,
            }
        }
    }
}
impl SourceAccessConfiguration {
    /// Creates a new builder-style object to manufacture [`SourceAccessConfiguration`](crate::model::SourceAccessConfiguration).
    pub fn builder() -> crate::model::source_access_configuration::Builder {
        crate::model::source_access_configuration::Builder::default()
    }
}

/// When writing a match expression against `SourceAccessType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let sourceaccesstype = unimplemented!();
/// match sourceaccesstype {
///     SourceAccessType::BasicAuth => { /* ... */ },
///     SourceAccessType::ClientCertificateTlsAuth => { /* ... */ },
///     SourceAccessType::SaslScram256Auth => { /* ... */ },
///     SourceAccessType::SaslScram512Auth => { /* ... */ },
///     SourceAccessType::ServerRootCaCertificate => { /* ... */ },
///     SourceAccessType::VirtualHost => { /* ... */ },
///     SourceAccessType::VpcSecurityGroup => { /* ... */ },
///     SourceAccessType::VpcSubnet => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `sourceaccesstype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SourceAccessType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SourceAccessType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SourceAccessType::NewFeature` is defined.
/// Specifically, when `sourceaccesstype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SourceAccessType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SourceAccessType {
    #[allow(missing_docs)] // documentation missing in model
    BasicAuth,
    #[allow(missing_docs)] // documentation missing in model
    ClientCertificateTlsAuth,
    #[allow(missing_docs)] // documentation missing in model
    SaslScram256Auth,
    #[allow(missing_docs)] // documentation missing in model
    SaslScram512Auth,
    #[allow(missing_docs)] // documentation missing in model
    ServerRootCaCertificate,
    #[allow(missing_docs)] // documentation missing in model
    VirtualHost,
    #[allow(missing_docs)] // documentation missing in model
    VpcSecurityGroup,
    #[allow(missing_docs)] // documentation missing in model
    VpcSubnet,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SourceAccessType {
    fn from(s: &str) -> Self {
        match s {
            "BASIC_AUTH" => SourceAccessType::BasicAuth,
            "CLIENT_CERTIFICATE_TLS_AUTH" => SourceAccessType::ClientCertificateTlsAuth,
            "SASL_SCRAM_256_AUTH" => SourceAccessType::SaslScram256Auth,
            "SASL_SCRAM_512_AUTH" => SourceAccessType::SaslScram512Auth,
            "SERVER_ROOT_CA_CERTIFICATE" => SourceAccessType::ServerRootCaCertificate,
            "VIRTUAL_HOST" => SourceAccessType::VirtualHost,
            "VPC_SECURITY_GROUP" => SourceAccessType::VpcSecurityGroup,
            "VPC_SUBNET" => SourceAccessType::VpcSubnet,
            other => SourceAccessType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SourceAccessType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SourceAccessType::from(s))
    }
}
impl SourceAccessType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SourceAccessType::BasicAuth => "BASIC_AUTH",
            SourceAccessType::ClientCertificateTlsAuth => "CLIENT_CERTIFICATE_TLS_AUTH",
            SourceAccessType::SaslScram256Auth => "SASL_SCRAM_256_AUTH",
            SourceAccessType::SaslScram512Auth => "SASL_SCRAM_512_AUTH",
            SourceAccessType::ServerRootCaCertificate => "SERVER_ROOT_CA_CERTIFICATE",
            SourceAccessType::VirtualHost => "VIRTUAL_HOST",
            SourceAccessType::VpcSecurityGroup => "VPC_SECURITY_GROUP",
            SourceAccessType::VpcSubnet => "VPC_SUBNET",
            SourceAccessType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "BASIC_AUTH",
            "CLIENT_CERTIFICATE_TLS_AUTH",
            "SASL_SCRAM_256_AUTH",
            "SASL_SCRAM_512_AUTH",
            "SERVER_ROOT_CA_CERTIFICATE",
            "VIRTUAL_HOST",
            "VPC_SECURITY_GROUP",
            "VPC_SUBNET",
        ]
    }
}
impl AsRef<str> for SourceAccessType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> An object that contains the filters for an event source. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FilterCriteria {
    /// <p> A list of filters. </p>
    #[doc(hidden)]
    pub filters: std::option::Option<std::vec::Vec<crate::model::Filter>>,
}
impl FilterCriteria {
    /// <p> A list of filters. </p>
    pub fn filters(&self) -> std::option::Option<&[crate::model::Filter]> {
        self.filters.as_deref()
    }
}
/// See [`FilterCriteria`](crate::model::FilterCriteria).
pub mod filter_criteria {

    /// A builder for [`FilterCriteria`](crate::model::FilterCriteria).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) filters: std::option::Option<std::vec::Vec<crate::model::Filter>>,
    }
    impl Builder {
        /// Appends an item to `filters`.
        ///
        /// To override the contents of this collection use [`set_filters`](Self::set_filters).
        ///
        /// <p> A list of filters. </p>
        pub fn filters(mut self, input: crate::model::Filter) -> Self {
            let mut v = self.filters.unwrap_or_default();
            v.push(input);
            self.filters = Some(v);
            self
        }
        /// <p> A list of filters. </p>
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.filters = input;
            self
        }
        /// Consumes the builder and constructs a [`FilterCriteria`](crate::model::FilterCriteria).
        pub fn build(self) -> crate::model::FilterCriteria {
            crate::model::FilterCriteria {
                filters: self.filters,
            }
        }
    }
}
impl FilterCriteria {
    /// Creates a new builder-style object to manufacture [`FilterCriteria`](crate::model::FilterCriteria).
    pub fn builder() -> crate::model::filter_criteria::Builder {
        crate::model::filter_criteria::Builder::default()
    }
}

/// <p> A structure within a <code>FilterCriteria</code> object that defines an event filtering pattern. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Filter {
    /// <p> A filter pattern. For more information on the syntax of a filter pattern, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-syntax"> Filter rule syntax</a>. </p>
    #[doc(hidden)]
    pub pattern: std::option::Option<std::string::String>,
}
impl Filter {
    /// <p> A filter pattern. For more information on the syntax of a filter pattern, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-syntax"> Filter rule syntax</a>. </p>
    pub fn pattern(&self) -> std::option::Option<&str> {
        self.pattern.as_deref()
    }
}
/// See [`Filter`](crate::model::Filter).
pub mod filter {

    /// A builder for [`Filter`](crate::model::Filter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pattern: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> A filter pattern. For more information on the syntax of a filter pattern, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-syntax"> Filter rule syntax</a>. </p>
        pub fn pattern(mut self, input: impl Into<std::string::String>) -> Self {
            self.pattern = Some(input.into());
            self
        }
        /// <p> A filter pattern. For more information on the syntax of a filter pattern, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-syntax"> Filter rule syntax</a>. </p>
        pub fn set_pattern(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.pattern = input;
            self
        }
        /// Consumes the builder and constructs a [`Filter`](crate::model::Filter).
        pub fn build(self) -> crate::model::Filter {
            crate::model::Filter {
                pattern: self.pattern,
            }
        }
    }
}
impl Filter {
    /// Creates a new builder-style object to manufacture [`Filter`](crate::model::Filter).
    pub fn builder() -> crate::model::filter::Builder {
        crate::model::filter::Builder::default()
    }
}

/// When writing a match expression against `EventSourcePosition`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let eventsourceposition = unimplemented!();
/// match eventsourceposition {
///     EventSourcePosition::AtTimestamp => { /* ... */ },
///     EventSourcePosition::Latest => { /* ... */ },
///     EventSourcePosition::TrimHorizon => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `eventsourceposition` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EventSourcePosition::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EventSourcePosition::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EventSourcePosition::NewFeature` is defined.
/// Specifically, when `eventsourceposition` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EventSourcePosition::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EventSourcePosition {
    #[allow(missing_docs)] // documentation missing in model
    AtTimestamp,
    #[allow(missing_docs)] // documentation missing in model
    Latest,
    #[allow(missing_docs)] // documentation missing in model
    TrimHorizon,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EventSourcePosition {
    fn from(s: &str) -> Self {
        match s {
            "AT_TIMESTAMP" => EventSourcePosition::AtTimestamp,
            "LATEST" => EventSourcePosition::Latest,
            "TRIM_HORIZON" => EventSourcePosition::TrimHorizon,
            other => {
                EventSourcePosition::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for EventSourcePosition {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EventSourcePosition::from(s))
    }
}
impl EventSourcePosition {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EventSourcePosition::AtTimestamp => "AT_TIMESTAMP",
            EventSourcePosition::Latest => "LATEST",
            EventSourcePosition::TrimHorizon => "TRIM_HORIZON",
            EventSourcePosition::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AT_TIMESTAMP", "LATEST", "TRIM_HORIZON"]
    }
}
impl AsRef<str> for EventSourcePosition {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Details about a <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-codesigning.html">Code signing configuration</a>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CodeSigningConfig {
    /// <p>Unique identifer for the Code signing configuration.</p>
    #[doc(hidden)]
    pub code_signing_config_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Code signing configuration.</p>
    #[doc(hidden)]
    pub code_signing_config_arn: std::option::Option<std::string::String>,
    /// <p>Code signing configuration description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>List of allowed publishers.</p>
    #[doc(hidden)]
    pub allowed_publishers: std::option::Option<crate::model::AllowedPublishers>,
    /// <p>The code signing policy controls the validation failure action for signature mismatch or expiry.</p>
    #[doc(hidden)]
    pub code_signing_policies: std::option::Option<crate::model::CodeSigningPolicies>,
    /// <p>The date and time that the Code signing configuration was last modified, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD). </p>
    #[doc(hidden)]
    pub last_modified: std::option::Option<std::string::String>,
}
impl CodeSigningConfig {
    /// <p>Unique identifer for the Code signing configuration.</p>
    pub fn code_signing_config_id(&self) -> std::option::Option<&str> {
        self.code_signing_config_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the Code signing configuration.</p>
    pub fn code_signing_config_arn(&self) -> std::option::Option<&str> {
        self.code_signing_config_arn.as_deref()
    }
    /// <p>Code signing configuration description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>List of allowed publishers.</p>
    pub fn allowed_publishers(&self) -> std::option::Option<&crate::model::AllowedPublishers> {
        self.allowed_publishers.as_ref()
    }
    /// <p>The code signing policy controls the validation failure action for signature mismatch or expiry.</p>
    pub fn code_signing_policies(&self) -> std::option::Option<&crate::model::CodeSigningPolicies> {
        self.code_signing_policies.as_ref()
    }
    /// <p>The date and time that the Code signing configuration was last modified, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD). </p>
    pub fn last_modified(&self) -> std::option::Option<&str> {
        self.last_modified.as_deref()
    }
}
/// See [`CodeSigningConfig`](crate::model::CodeSigningConfig).
pub mod code_signing_config {

    /// A builder for [`CodeSigningConfig`](crate::model::CodeSigningConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code_signing_config_id: std::option::Option<std::string::String>,
        pub(crate) code_signing_config_arn: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) allowed_publishers: std::option::Option<crate::model::AllowedPublishers>,
        pub(crate) code_signing_policies: std::option::Option<crate::model::CodeSigningPolicies>,
        pub(crate) last_modified: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Unique identifer for the Code signing configuration.</p>
        pub fn code_signing_config_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.code_signing_config_id = Some(input.into());
            self
        }
        /// <p>Unique identifer for the Code signing configuration.</p>
        pub fn set_code_signing_config_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.code_signing_config_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Code signing configuration.</p>
        pub fn code_signing_config_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.code_signing_config_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Code signing configuration.</p>
        pub fn set_code_signing_config_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.code_signing_config_arn = input;
            self
        }
        /// <p>Code signing configuration description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>Code signing configuration description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>List of allowed publishers.</p>
        pub fn allowed_publishers(mut self, input: crate::model::AllowedPublishers) -> Self {
            self.allowed_publishers = Some(input);
            self
        }
        /// <p>List of allowed publishers.</p>
        pub fn set_allowed_publishers(
            mut self,
            input: std::option::Option<crate::model::AllowedPublishers>,
        ) -> Self {
            self.allowed_publishers = input;
            self
        }
        /// <p>The code signing policy controls the validation failure action for signature mismatch or expiry.</p>
        pub fn code_signing_policies(mut self, input: crate::model::CodeSigningPolicies) -> Self {
            self.code_signing_policies = Some(input);
            self
        }
        /// <p>The code signing policy controls the validation failure action for signature mismatch or expiry.</p>
        pub fn set_code_signing_policies(
            mut self,
            input: std::option::Option<crate::model::CodeSigningPolicies>,
        ) -> Self {
            self.code_signing_policies = input;
            self
        }
        /// <p>The date and time that the Code signing configuration was last modified, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD). </p>
        pub fn last_modified(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified = Some(input.into());
            self
        }
        /// <p>The date and time that the Code signing configuration was last modified, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD). </p>
        pub fn set_last_modified(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified = input;
            self
        }
        /// Consumes the builder and constructs a [`CodeSigningConfig`](crate::model::CodeSigningConfig).
        pub fn build(self) -> crate::model::CodeSigningConfig {
            crate::model::CodeSigningConfig {
                code_signing_config_id: self.code_signing_config_id,
                code_signing_config_arn: self.code_signing_config_arn,
                description: self.description,
                allowed_publishers: self.allowed_publishers,
                code_signing_policies: self.code_signing_policies,
                last_modified: self.last_modified,
            }
        }
    }
}
impl CodeSigningConfig {
    /// Creates a new builder-style object to manufacture [`CodeSigningConfig`](crate::model::CodeSigningConfig).
    pub fn builder() -> crate::model::code_signing_config::Builder {
        crate::model::code_signing_config::Builder::default()
    }
}

/// <p>Code signing configuration <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-codesigning.html#config-codesigning-policies">policies</a> specify the validation failure action for signature mismatch or expiry.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CodeSigningPolicies {
    /// <p>Code signing configuration policy for deployment validation failure. If you set the policy to <code>Enforce</code>, Lambda blocks the deployment request if signature validation checks fail. If you set the policy to <code>Warn</code>, Lambda allows the deployment and creates a CloudWatch log. </p>
    /// <p>Default value: <code>Warn</code> </p>
    #[doc(hidden)]
    pub untrusted_artifact_on_deployment: std::option::Option<crate::model::CodeSigningPolicy>,
}
impl CodeSigningPolicies {
    /// <p>Code signing configuration policy for deployment validation failure. If you set the policy to <code>Enforce</code>, Lambda blocks the deployment request if signature validation checks fail. If you set the policy to <code>Warn</code>, Lambda allows the deployment and creates a CloudWatch log. </p>
    /// <p>Default value: <code>Warn</code> </p>
    pub fn untrusted_artifact_on_deployment(
        &self,
    ) -> std::option::Option<&crate::model::CodeSigningPolicy> {
        self.untrusted_artifact_on_deployment.as_ref()
    }
}
/// See [`CodeSigningPolicies`](crate::model::CodeSigningPolicies).
pub mod code_signing_policies {

    /// A builder for [`CodeSigningPolicies`](crate::model::CodeSigningPolicies).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) untrusted_artifact_on_deployment:
            std::option::Option<crate::model::CodeSigningPolicy>,
    }
    impl Builder {
        /// <p>Code signing configuration policy for deployment validation failure. If you set the policy to <code>Enforce</code>, Lambda blocks the deployment request if signature validation checks fail. If you set the policy to <code>Warn</code>, Lambda allows the deployment and creates a CloudWatch log. </p>
        /// <p>Default value: <code>Warn</code> </p>
        pub fn untrusted_artifact_on_deployment(
            mut self,
            input: crate::model::CodeSigningPolicy,
        ) -> Self {
            self.untrusted_artifact_on_deployment = Some(input);
            self
        }
        /// <p>Code signing configuration policy for deployment validation failure. If you set the policy to <code>Enforce</code>, Lambda blocks the deployment request if signature validation checks fail. If you set the policy to <code>Warn</code>, Lambda allows the deployment and creates a CloudWatch log. </p>
        /// <p>Default value: <code>Warn</code> </p>
        pub fn set_untrusted_artifact_on_deployment(
            mut self,
            input: std::option::Option<crate::model::CodeSigningPolicy>,
        ) -> Self {
            self.untrusted_artifact_on_deployment = input;
            self
        }
        /// Consumes the builder and constructs a [`CodeSigningPolicies`](crate::model::CodeSigningPolicies).
        pub fn build(self) -> crate::model::CodeSigningPolicies {
            crate::model::CodeSigningPolicies {
                untrusted_artifact_on_deployment: self.untrusted_artifact_on_deployment,
            }
        }
    }
}
impl CodeSigningPolicies {
    /// Creates a new builder-style object to manufacture [`CodeSigningPolicies`](crate::model::CodeSigningPolicies).
    pub fn builder() -> crate::model::code_signing_policies::Builder {
        crate::model::code_signing_policies::Builder::default()
    }
}

/// When writing a match expression against `CodeSigningPolicy`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let codesigningpolicy = unimplemented!();
/// match codesigningpolicy {
///     CodeSigningPolicy::Enforce => { /* ... */ },
///     CodeSigningPolicy::Warn => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `codesigningpolicy` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CodeSigningPolicy::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CodeSigningPolicy::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CodeSigningPolicy::NewFeature` is defined.
/// Specifically, when `codesigningpolicy` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CodeSigningPolicy::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CodeSigningPolicy {
    #[allow(missing_docs)] // documentation missing in model
    Enforce,
    #[allow(missing_docs)] // documentation missing in model
    Warn,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CodeSigningPolicy {
    fn from(s: &str) -> Self {
        match s {
            "Enforce" => CodeSigningPolicy::Enforce,
            "Warn" => CodeSigningPolicy::Warn,
            other => {
                CodeSigningPolicy::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for CodeSigningPolicy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CodeSigningPolicy::from(s))
    }
}
impl CodeSigningPolicy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CodeSigningPolicy::Enforce => "Enforce",
            CodeSigningPolicy::Warn => "Warn",
            CodeSigningPolicy::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Enforce", "Warn"]
    }
}
impl AsRef<str> for CodeSigningPolicy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>List of signing profiles that can sign a code package. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AllowedPublishers {
    /// <p>The Amazon Resource Name (ARN) for each of the signing profiles. A signing profile defines a trusted user who can sign a code package. </p>
    #[doc(hidden)]
    pub signing_profile_version_arns: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl AllowedPublishers {
    /// <p>The Amazon Resource Name (ARN) for each of the signing profiles. A signing profile defines a trusted user who can sign a code package. </p>
    pub fn signing_profile_version_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.signing_profile_version_arns.as_deref()
    }
}
/// See [`AllowedPublishers`](crate::model::AllowedPublishers).
pub mod allowed_publishers {

    /// A builder for [`AllowedPublishers`](crate::model::AllowedPublishers).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) signing_profile_version_arns:
            std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `signing_profile_version_arns`.
        ///
        /// To override the contents of this collection use [`set_signing_profile_version_arns`](Self::set_signing_profile_version_arns).
        ///
        /// <p>The Amazon Resource Name (ARN) for each of the signing profiles. A signing profile defines a trusted user who can sign a code package. </p>
        pub fn signing_profile_version_arns(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.signing_profile_version_arns.unwrap_or_default();
            v.push(input.into());
            self.signing_profile_version_arns = Some(v);
            self
        }
        /// <p>The Amazon Resource Name (ARN) for each of the signing profiles. A signing profile defines a trusted user who can sign a code package. </p>
        pub fn set_signing_profile_version_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.signing_profile_version_arns = input;
            self
        }
        /// Consumes the builder and constructs a [`AllowedPublishers`](crate::model::AllowedPublishers).
        pub fn build(self) -> crate::model::AllowedPublishers {
            crate::model::AllowedPublishers {
                signing_profile_version_arns: self.signing_profile_version_arns,
            }
        }
    }
}
impl AllowedPublishers {
    /// Creates a new builder-style object to manufacture [`AllowedPublishers`](crate::model::AllowedPublishers).
    pub fn builder() -> crate::model::allowed_publishers::Builder {
        crate::model::allowed_publishers::Builder::default()
    }
}

/// <p>The <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html">traffic-shifting</a> configuration of a Lambda function alias.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AliasRoutingConfiguration {
    /// <p>The second version, and the percentage of traffic that's routed to it.</p>
    #[doc(hidden)]
    pub additional_version_weights:
        std::option::Option<std::collections::HashMap<std::string::String, f64>>,
}
impl AliasRoutingConfiguration {
    /// <p>The second version, and the percentage of traffic that's routed to it.</p>
    pub fn additional_version_weights(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, f64>> {
        self.additional_version_weights.as_ref()
    }
}
/// See [`AliasRoutingConfiguration`](crate::model::AliasRoutingConfiguration).
pub mod alias_routing_configuration {

    /// A builder for [`AliasRoutingConfiguration`](crate::model::AliasRoutingConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) additional_version_weights:
            std::option::Option<std::collections::HashMap<std::string::String, f64>>,
    }
    impl Builder {
        /// Adds a key-value pair to `additional_version_weights`.
        ///
        /// To override the contents of this collection use [`set_additional_version_weights`](Self::set_additional_version_weights).
        ///
        /// <p>The second version, and the percentage of traffic that's routed to it.</p>
        pub fn additional_version_weights(
            mut self,
            k: impl Into<std::string::String>,
            v: f64,
        ) -> Self {
            let mut hash_map = self.additional_version_weights.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.additional_version_weights = Some(hash_map);
            self
        }
        /// <p>The second version, and the percentage of traffic that's routed to it.</p>
        pub fn set_additional_version_weights(
            mut self,
            input: std::option::Option<std::collections::HashMap<std::string::String, f64>>,
        ) -> Self {
            self.additional_version_weights = input;
            self
        }
        /// Consumes the builder and constructs a [`AliasRoutingConfiguration`](crate::model::AliasRoutingConfiguration).
        pub fn build(self) -> crate::model::AliasRoutingConfiguration {
            crate::model::AliasRoutingConfiguration {
                additional_version_weights: self.additional_version_weights,
            }
        }
    }
}
impl AliasRoutingConfiguration {
    /// Creates a new builder-style object to manufacture [`AliasRoutingConfiguration`](crate::model::AliasRoutingConfiguration).
    pub fn builder() -> crate::model::alias_routing_configuration::Builder {
        crate::model::alias_routing_configuration::Builder::default()
    }
}

/// When writing a match expression against `UpdateRuntimeOn`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let updateruntimeon = unimplemented!();
/// match updateruntimeon {
///     UpdateRuntimeOn::Auto => { /* ... */ },
///     UpdateRuntimeOn::FunctionUpdate => { /* ... */ },
///     UpdateRuntimeOn::Manual => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `updateruntimeon` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `UpdateRuntimeOn::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `UpdateRuntimeOn::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `UpdateRuntimeOn::NewFeature` is defined.
/// Specifically, when `updateruntimeon` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `UpdateRuntimeOn::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UpdateRuntimeOn {
    #[allow(missing_docs)] // documentation missing in model
    Auto,
    #[allow(missing_docs)] // documentation missing in model
    FunctionUpdate,
    #[allow(missing_docs)] // documentation missing in model
    Manual,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for UpdateRuntimeOn {
    fn from(s: &str) -> Self {
        match s {
            "Auto" => UpdateRuntimeOn::Auto,
            "FunctionUpdate" => UpdateRuntimeOn::FunctionUpdate,
            "Manual" => UpdateRuntimeOn::Manual,
            other => UpdateRuntimeOn::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for UpdateRuntimeOn {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UpdateRuntimeOn::from(s))
    }
}
impl UpdateRuntimeOn {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UpdateRuntimeOn::Auto => "Auto",
            UpdateRuntimeOn::FunctionUpdate => "FunctionUpdate",
            UpdateRuntimeOn::Manual => "Manual",
            UpdateRuntimeOn::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Auto", "FunctionUpdate", "Manual"]
    }
}
impl AsRef<str> for UpdateRuntimeOn {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ProvisionedConcurrencyStatusEnum`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let provisionedconcurrencystatusenum = unimplemented!();
/// match provisionedconcurrencystatusenum {
///     ProvisionedConcurrencyStatusEnum::Failed => { /* ... */ },
///     ProvisionedConcurrencyStatusEnum::InProgress => { /* ... */ },
///     ProvisionedConcurrencyStatusEnum::Ready => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `provisionedconcurrencystatusenum` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ProvisionedConcurrencyStatusEnum::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ProvisionedConcurrencyStatusEnum::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ProvisionedConcurrencyStatusEnum::NewFeature` is defined.
/// Specifically, when `provisionedconcurrencystatusenum` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ProvisionedConcurrencyStatusEnum::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProvisionedConcurrencyStatusEnum {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Ready,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ProvisionedConcurrencyStatusEnum {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => ProvisionedConcurrencyStatusEnum::Failed,
            "IN_PROGRESS" => ProvisionedConcurrencyStatusEnum::InProgress,
            "READY" => ProvisionedConcurrencyStatusEnum::Ready,
            other => ProvisionedConcurrencyStatusEnum::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ProvisionedConcurrencyStatusEnum {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProvisionedConcurrencyStatusEnum::from(s))
    }
}
impl ProvisionedConcurrencyStatusEnum {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ProvisionedConcurrencyStatusEnum::Failed => "FAILED",
            ProvisionedConcurrencyStatusEnum::InProgress => "IN_PROGRESS",
            ProvisionedConcurrencyStatusEnum::Ready => "READY",
            ProvisionedConcurrencyStatusEnum::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FAILED", "IN_PROGRESS", "READY"]
    }
}
impl AsRef<str> for ProvisionedConcurrencyStatusEnum {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Details about a version of an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">Lambda layer</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LayerVersionContentOutput {
    /// <p>A link to the layer archive in Amazon S3 that is valid for 10 minutes.</p>
    #[doc(hidden)]
    pub location: std::option::Option<std::string::String>,
    /// <p>The SHA-256 hash of the layer archive.</p>
    #[doc(hidden)]
    pub code_sha256: std::option::Option<std::string::String>,
    /// <p>The size of the layer archive in bytes.</p>
    #[doc(hidden)]
    pub code_size: i64,
    /// <p>The Amazon Resource Name (ARN) for a signing profile version.</p>
    #[doc(hidden)]
    pub signing_profile_version_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of a signing job.</p>
    #[doc(hidden)]
    pub signing_job_arn: std::option::Option<std::string::String>,
}
impl LayerVersionContentOutput {
    /// <p>A link to the layer archive in Amazon S3 that is valid for 10 minutes.</p>
    pub fn location(&self) -> std::option::Option<&str> {
        self.location.as_deref()
    }
    /// <p>The SHA-256 hash of the layer archive.</p>
    pub fn code_sha256(&self) -> std::option::Option<&str> {
        self.code_sha256.as_deref()
    }
    /// <p>The size of the layer archive in bytes.</p>
    pub fn code_size(&self) -> i64 {
        self.code_size
    }
    /// <p>The Amazon Resource Name (ARN) for a signing profile version.</p>
    pub fn signing_profile_version_arn(&self) -> std::option::Option<&str> {
        self.signing_profile_version_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of a signing job.</p>
    pub fn signing_job_arn(&self) -> std::option::Option<&str> {
        self.signing_job_arn.as_deref()
    }
}
/// See [`LayerVersionContentOutput`](crate::model::LayerVersionContentOutput).
pub mod layer_version_content_output {

    /// A builder for [`LayerVersionContentOutput`](crate::model::LayerVersionContentOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) location: std::option::Option<std::string::String>,
        pub(crate) code_sha256: std::option::Option<std::string::String>,
        pub(crate) code_size: std::option::Option<i64>,
        pub(crate) signing_profile_version_arn: std::option::Option<std::string::String>,
        pub(crate) signing_job_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A link to the layer archive in Amazon S3 that is valid for 10 minutes.</p>
        pub fn location(mut self, input: impl Into<std::string::String>) -> Self {
            self.location = Some(input.into());
            self
        }
        /// <p>A link to the layer archive in Amazon S3 that is valid for 10 minutes.</p>
        pub fn set_location(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.location = input;
            self
        }
        /// <p>The SHA-256 hash of the layer archive.</p>
        pub fn code_sha256(mut self, input: impl Into<std::string::String>) -> Self {
            self.code_sha256 = Some(input.into());
            self
        }
        /// <p>The SHA-256 hash of the layer archive.</p>
        pub fn set_code_sha256(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code_sha256 = input;
            self
        }
        /// <p>The size of the layer archive in bytes.</p>
        pub fn code_size(mut self, input: i64) -> Self {
            self.code_size = Some(input);
            self
        }
        /// <p>The size of the layer archive in bytes.</p>
        pub fn set_code_size(mut self, input: std::option::Option<i64>) -> Self {
            self.code_size = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for a signing profile version.</p>
        pub fn signing_profile_version_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.signing_profile_version_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for a signing profile version.</p>
        pub fn set_signing_profile_version_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.signing_profile_version_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a signing job.</p>
        pub fn signing_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.signing_job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a signing job.</p>
        pub fn set_signing_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.signing_job_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`LayerVersionContentOutput`](crate::model::LayerVersionContentOutput).
        pub fn build(self) -> crate::model::LayerVersionContentOutput {
            crate::model::LayerVersionContentOutput {
                location: self.location,
                code_sha256: self.code_sha256,
                code_size: self.code_size.unwrap_or_default(),
                signing_profile_version_arn: self.signing_profile_version_arn,
                signing_job_arn: self.signing_job_arn,
            }
        }
    }
}
impl LayerVersionContentOutput {
    /// Creates a new builder-style object to manufacture [`LayerVersionContentOutput`](crate::model::LayerVersionContentOutput).
    pub fn builder() -> crate::model::layer_version_content_output::Builder {
        crate::model::layer_version_content_output::Builder::default()
    }
}

/// <p>A ZIP archive that contains the contents of an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">Lambda layer</a>. You can specify either an Amazon S3 location, or upload a layer archive directly.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LayerVersionContentInput {
    /// <p>The Amazon S3 bucket of the layer archive.</p>
    #[doc(hidden)]
    pub s3_bucket: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 key of the layer archive.</p>
    #[doc(hidden)]
    pub s3_key: std::option::Option<std::string::String>,
    /// <p>For versioned objects, the version of the layer archive object to use.</p>
    #[doc(hidden)]
    pub s3_object_version: std::option::Option<std::string::String>,
    /// <p>The base64-encoded contents of the layer archive. Amazon Web Services SDK and Amazon Web Services CLI clients handle the encoding for you.</p>
    #[doc(hidden)]
    pub zip_file: std::option::Option<aws_smithy_types::Blob>,
}
impl LayerVersionContentInput {
    /// <p>The Amazon S3 bucket of the layer archive.</p>
    pub fn s3_bucket(&self) -> std::option::Option<&str> {
        self.s3_bucket.as_deref()
    }
    /// <p>The Amazon S3 key of the layer archive.</p>
    pub fn s3_key(&self) -> std::option::Option<&str> {
        self.s3_key.as_deref()
    }
    /// <p>For versioned objects, the version of the layer archive object to use.</p>
    pub fn s3_object_version(&self) -> std::option::Option<&str> {
        self.s3_object_version.as_deref()
    }
    /// <p>The base64-encoded contents of the layer archive. Amazon Web Services SDK and Amazon Web Services CLI clients handle the encoding for you.</p>
    pub fn zip_file(&self) -> std::option::Option<&aws_smithy_types::Blob> {
        self.zip_file.as_ref()
    }
}
impl std::fmt::Debug for LayerVersionContentInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LayerVersionContentInput");
        formatter.field("s3_bucket", &self.s3_bucket);
        formatter.field("s3_key", &self.s3_key);
        formatter.field("s3_object_version", &self.s3_object_version);
        formatter.field("zip_file", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`LayerVersionContentInput`](crate::model::LayerVersionContentInput).
pub mod layer_version_content_input {

    /// A builder for [`LayerVersionContentInput`](crate::model::LayerVersionContentInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) s3_bucket: std::option::Option<std::string::String>,
        pub(crate) s3_key: std::option::Option<std::string::String>,
        pub(crate) s3_object_version: std::option::Option<std::string::String>,
        pub(crate) zip_file: std::option::Option<aws_smithy_types::Blob>,
    }
    impl Builder {
        /// <p>The Amazon S3 bucket of the layer archive.</p>
        pub fn s3_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_bucket = Some(input.into());
            self
        }
        /// <p>The Amazon S3 bucket of the layer archive.</p>
        pub fn set_s3_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_bucket = input;
            self
        }
        /// <p>The Amazon S3 key of the layer archive.</p>
        pub fn s3_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_key = Some(input.into());
            self
        }
        /// <p>The Amazon S3 key of the layer archive.</p>
        pub fn set_s3_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_key = input;
            self
        }
        /// <p>For versioned objects, the version of the layer archive object to use.</p>
        pub fn s3_object_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_object_version = Some(input.into());
            self
        }
        /// <p>For versioned objects, the version of the layer archive object to use.</p>
        pub fn set_s3_object_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_object_version = input;
            self
        }
        /// <p>The base64-encoded contents of the layer archive. Amazon Web Services SDK and Amazon Web Services CLI clients handle the encoding for you.</p>
        pub fn zip_file(mut self, input: aws_smithy_types::Blob) -> Self {
            self.zip_file = Some(input);
            self
        }
        /// <p>The base64-encoded contents of the layer archive. Amazon Web Services SDK and Amazon Web Services CLI clients handle the encoding for you.</p>
        pub fn set_zip_file(mut self, input: std::option::Option<aws_smithy_types::Blob>) -> Self {
            self.zip_file = input;
            self
        }
        /// Consumes the builder and constructs a [`LayerVersionContentInput`](crate::model::LayerVersionContentInput).
        pub fn build(self) -> crate::model::LayerVersionContentInput {
            crate::model::LayerVersionContentInput {
                s3_bucket: self.s3_bucket,
                s3_key: self.s3_key,
                s3_object_version: self.s3_object_version,
                zip_file: self.zip_file,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("s3_bucket", &self.s3_bucket);
            formatter.field("s3_key", &self.s3_key);
            formatter.field("s3_object_version", &self.s3_object_version);
            formatter.field("zip_file", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl LayerVersionContentInput {
    /// Creates a new builder-style object to manufacture [`LayerVersionContentInput`](crate::model::LayerVersionContentInput).
    pub fn builder() -> crate::model::layer_version_content_input::Builder {
        crate::model::layer_version_content_input::Builder::default()
    }
}

/// <p>Details about a function's configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FunctionConfiguration {
    /// <p>The name of the function.</p>
    #[doc(hidden)]
    pub function_name: std::option::Option<std::string::String>,
    /// <p>The function's Amazon Resource Name (ARN).</p>
    #[doc(hidden)]
    pub function_arn: std::option::Option<std::string::String>,
    /// <p>The runtime environment for the Lambda function.</p>
    #[doc(hidden)]
    pub runtime: std::option::Option<crate::model::Runtime>,
    /// <p>The function's execution role.</p>
    #[doc(hidden)]
    pub role: std::option::Option<std::string::String>,
    /// <p>The function that Lambda calls to begin running your function.</p>
    #[doc(hidden)]
    pub handler: std::option::Option<std::string::String>,
    /// <p>The size of the function's deployment package, in bytes.</p>
    #[doc(hidden)]
    pub code_size: i64,
    /// <p>The function's description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The amount of time in seconds that Lambda allows a function to run before stopping it.</p>
    #[doc(hidden)]
    pub timeout: std::option::Option<i32>,
    /// <p>The amount of memory available to the function at runtime.</p>
    #[doc(hidden)]
    pub memory_size: std::option::Option<i32>,
    /// <p>The date and time that the function was last updated, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format</a> (YYYY-MM-DDThh:mm:ss.sTZD).</p>
    #[doc(hidden)]
    pub last_modified: std::option::Option<std::string::String>,
    /// <p>The SHA256 hash of the function's deployment package.</p>
    #[doc(hidden)]
    pub code_sha256: std::option::Option<std::string::String>,
    /// <p>The version of the Lambda function.</p>
    #[doc(hidden)]
    pub version: std::option::Option<std::string::String>,
    /// <p>The function's networking configuration.</p>
    #[doc(hidden)]
    pub vpc_config: std::option::Option<crate::model::VpcConfigResponse>,
    /// <p>The function's dead letter queue.</p>
    #[doc(hidden)]
    pub dead_letter_config: std::option::Option<crate::model::DeadLetterConfig>,
    /// <p>The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html">environment variables</a>. Omitted from CloudTrail logs.</p>
    #[doc(hidden)]
    pub environment: std::option::Option<crate::model::EnvironmentResponse>,
    /// <p>The KMS key that's used to encrypt the function's environment variables. This key is returned only if you've configured a customer managed key.</p>
    #[doc(hidden)]
    pub kms_key_arn: std::option::Option<std::string::String>,
    /// <p>The function's X-Ray tracing configuration.</p>
    #[doc(hidden)]
    pub tracing_config: std::option::Option<crate::model::TracingConfigResponse>,
    /// <p>For Lambda@Edge functions, the ARN of the main function.</p>
    #[doc(hidden)]
    pub master_arn: std::option::Option<std::string::String>,
    /// <p>The latest updated revision of the function or alias.</p>
    #[doc(hidden)]
    pub revision_id: std::option::Option<std::string::String>,
    /// <p>The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">layers</a>.</p>
    #[doc(hidden)]
    pub layers: std::option::Option<std::vec::Vec<crate::model::Layer>>,
    /// <p>The current state of the function. When the state is <code>Inactive</code>, you can reactivate the function by invoking it.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::State>,
    /// <p>The reason for the function's current state.</p>
    #[doc(hidden)]
    pub state_reason: std::option::Option<std::string::String>,
    /// <p>The reason code for the function's current state. When the code is <code>Creating</code>, you can't invoke or modify the function.</p>
    #[doc(hidden)]
    pub state_reason_code: std::option::Option<crate::model::StateReasonCode>,
    /// <p>The status of the last update that was performed on the function. This is first set to <code>Successful</code> after function creation completes.</p>
    #[doc(hidden)]
    pub last_update_status: std::option::Option<crate::model::LastUpdateStatus>,
    /// <p>The reason for the last update that was performed on the function.</p>
    #[doc(hidden)]
    pub last_update_status_reason: std::option::Option<std::string::String>,
    /// <p>The reason code for the last update that was performed on the function.</p>
    #[doc(hidden)]
    pub last_update_status_reason_code:
        std::option::Option<crate::model::LastUpdateStatusReasonCode>,
    /// <p>Connection settings for an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html">Amazon EFS file system</a>.</p>
    #[doc(hidden)]
    pub file_system_configs: std::option::Option<std::vec::Vec<crate::model::FileSystemConfig>>,
    /// <p>The type of deployment package. Set to <code>Image</code> for container image and set <code>Zip</code> for .zip file archive.</p>
    #[doc(hidden)]
    pub package_type: std::option::Option<crate::model::PackageType>,
    /// <p>The function's image configuration values.</p>
    #[doc(hidden)]
    pub image_config_response: std::option::Option<crate::model::ImageConfigResponse>,
    /// <p>The ARN of the signing profile version.</p>
    #[doc(hidden)]
    pub signing_profile_version_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the signing job.</p>
    #[doc(hidden)]
    pub signing_job_arn: std::option::Option<std::string::String>,
    /// <p>The instruction set architecture that the function supports. Architecture is a string array with one of the valid values. The default architecture value is <code>x86_64</code>.</p>
    #[doc(hidden)]
    pub architectures: std::option::Option<std::vec::Vec<crate::model::Architecture>>,
    /// <p>The size of the function’s <code>/tmp</code> directory in MB. The default value is 512, but it can be any whole number between 512 and 10,240 MB.</p>
    #[doc(hidden)]
    pub ephemeral_storage: std::option::Option<crate::model::EphemeralStorage>,
    /// <p>Set <code>ApplyOn</code> to <code>PublishedVersions</code> to create a snapshot of the initialized execution environment when you publish a function version. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html">Improving startup performance with Lambda SnapStart</a>.</p>
    #[doc(hidden)]
    pub snap_start: std::option::Option<crate::model::SnapStartResponse>,
    /// <p>The ARN of the runtime and any errors that occured.</p>
    #[doc(hidden)]
    pub runtime_version_config: std::option::Option<crate::model::RuntimeVersionConfig>,
}
impl FunctionConfiguration {
    /// <p>The name of the function.</p>
    pub fn function_name(&self) -> std::option::Option<&str> {
        self.function_name.as_deref()
    }
    /// <p>The function's Amazon Resource Name (ARN).</p>
    pub fn function_arn(&self) -> std::option::Option<&str> {
        self.function_arn.as_deref()
    }
    /// <p>The runtime environment for the Lambda function.</p>
    pub fn runtime(&self) -> std::option::Option<&crate::model::Runtime> {
        self.runtime.as_ref()
    }
    /// <p>The function's execution role.</p>
    pub fn role(&self) -> std::option::Option<&str> {
        self.role.as_deref()
    }
    /// <p>The function that Lambda calls to begin running your function.</p>
    pub fn handler(&self) -> std::option::Option<&str> {
        self.handler.as_deref()
    }
    /// <p>The size of the function's deployment package, in bytes.</p>
    pub fn code_size(&self) -> i64 {
        self.code_size
    }
    /// <p>The function's description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The amount of time in seconds that Lambda allows a function to run before stopping it.</p>
    pub fn timeout(&self) -> std::option::Option<i32> {
        self.timeout
    }
    /// <p>The amount of memory available to the function at runtime.</p>
    pub fn memory_size(&self) -> std::option::Option<i32> {
        self.memory_size
    }
    /// <p>The date and time that the function was last updated, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format</a> (YYYY-MM-DDThh:mm:ss.sTZD).</p>
    pub fn last_modified(&self) -> std::option::Option<&str> {
        self.last_modified.as_deref()
    }
    /// <p>The SHA256 hash of the function's deployment package.</p>
    pub fn code_sha256(&self) -> std::option::Option<&str> {
        self.code_sha256.as_deref()
    }
    /// <p>The version of the Lambda function.</p>
    pub fn version(&self) -> std::option::Option<&str> {
        self.version.as_deref()
    }
    /// <p>The function's networking configuration.</p>
    pub fn vpc_config(&self) -> std::option::Option<&crate::model::VpcConfigResponse> {
        self.vpc_config.as_ref()
    }
    /// <p>The function's dead letter queue.</p>
    pub fn dead_letter_config(&self) -> std::option::Option<&crate::model::DeadLetterConfig> {
        self.dead_letter_config.as_ref()
    }
    /// <p>The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html">environment variables</a>. Omitted from CloudTrail logs.</p>
    pub fn environment(&self) -> std::option::Option<&crate::model::EnvironmentResponse> {
        self.environment.as_ref()
    }
    /// <p>The KMS key that's used to encrypt the function's environment variables. This key is returned only if you've configured a customer managed key.</p>
    pub fn kms_key_arn(&self) -> std::option::Option<&str> {
        self.kms_key_arn.as_deref()
    }
    /// <p>The function's X-Ray tracing configuration.</p>
    pub fn tracing_config(&self) -> std::option::Option<&crate::model::TracingConfigResponse> {
        self.tracing_config.as_ref()
    }
    /// <p>For Lambda@Edge functions, the ARN of the main function.</p>
    pub fn master_arn(&self) -> std::option::Option<&str> {
        self.master_arn.as_deref()
    }
    /// <p>The latest updated revision of the function or alias.</p>
    pub fn revision_id(&self) -> std::option::Option<&str> {
        self.revision_id.as_deref()
    }
    /// <p>The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">layers</a>.</p>
    pub fn layers(&self) -> std::option::Option<&[crate::model::Layer]> {
        self.layers.as_deref()
    }
    /// <p>The current state of the function. When the state is <code>Inactive</code>, you can reactivate the function by invoking it.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::State> {
        self.state.as_ref()
    }
    /// <p>The reason for the function's current state.</p>
    pub fn state_reason(&self) -> std::option::Option<&str> {
        self.state_reason.as_deref()
    }
    /// <p>The reason code for the function's current state. When the code is <code>Creating</code>, you can't invoke or modify the function.</p>
    pub fn state_reason_code(&self) -> std::option::Option<&crate::model::StateReasonCode> {
        self.state_reason_code.as_ref()
    }
    /// <p>The status of the last update that was performed on the function. This is first set to <code>Successful</code> after function creation completes.</p>
    pub fn last_update_status(&self) -> std::option::Option<&crate::model::LastUpdateStatus> {
        self.last_update_status.as_ref()
    }
    /// <p>The reason for the last update that was performed on the function.</p>
    pub fn last_update_status_reason(&self) -> std::option::Option<&str> {
        self.last_update_status_reason.as_deref()
    }
    /// <p>The reason code for the last update that was performed on the function.</p>
    pub fn last_update_status_reason_code(
        &self,
    ) -> std::option::Option<&crate::model::LastUpdateStatusReasonCode> {
        self.last_update_status_reason_code.as_ref()
    }
    /// <p>Connection settings for an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html">Amazon EFS file system</a>.</p>
    pub fn file_system_configs(&self) -> std::option::Option<&[crate::model::FileSystemConfig]> {
        self.file_system_configs.as_deref()
    }
    /// <p>The type of deployment package. Set to <code>Image</code> for container image and set <code>Zip</code> for .zip file archive.</p>
    pub fn package_type(&self) -> std::option::Option<&crate::model::PackageType> {
        self.package_type.as_ref()
    }
    /// <p>The function's image configuration values.</p>
    pub fn image_config_response(&self) -> std::option::Option<&crate::model::ImageConfigResponse> {
        self.image_config_response.as_ref()
    }
    /// <p>The ARN of the signing profile version.</p>
    pub fn signing_profile_version_arn(&self) -> std::option::Option<&str> {
        self.signing_profile_version_arn.as_deref()
    }
    /// <p>The ARN of the signing job.</p>
    pub fn signing_job_arn(&self) -> std::option::Option<&str> {
        self.signing_job_arn.as_deref()
    }
    /// <p>The instruction set architecture that the function supports. Architecture is a string array with one of the valid values. The default architecture value is <code>x86_64</code>.</p>
    pub fn architectures(&self) -> std::option::Option<&[crate::model::Architecture]> {
        self.architectures.as_deref()
    }
    /// <p>The size of the function’s <code>/tmp</code> directory in MB. The default value is 512, but it can be any whole number between 512 and 10,240 MB.</p>
    pub fn ephemeral_storage(&self) -> std::option::Option<&crate::model::EphemeralStorage> {
        self.ephemeral_storage.as_ref()
    }
    /// <p>Set <code>ApplyOn</code> to <code>PublishedVersions</code> to create a snapshot of the initialized execution environment when you publish a function version. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html">Improving startup performance with Lambda SnapStart</a>.</p>
    pub fn snap_start(&self) -> std::option::Option<&crate::model::SnapStartResponse> {
        self.snap_start.as_ref()
    }
    /// <p>The ARN of the runtime and any errors that occured.</p>
    pub fn runtime_version_config(
        &self,
    ) -> std::option::Option<&crate::model::RuntimeVersionConfig> {
        self.runtime_version_config.as_ref()
    }
}
/// See [`FunctionConfiguration`](crate::model::FunctionConfiguration).
pub mod function_configuration {

    /// A builder for [`FunctionConfiguration`](crate::model::FunctionConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) function_name: std::option::Option<std::string::String>,
        pub(crate) function_arn: std::option::Option<std::string::String>,
        pub(crate) runtime: std::option::Option<crate::model::Runtime>,
        pub(crate) role: std::option::Option<std::string::String>,
        pub(crate) handler: std::option::Option<std::string::String>,
        pub(crate) code_size: std::option::Option<i64>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) timeout: std::option::Option<i32>,
        pub(crate) memory_size: std::option::Option<i32>,
        pub(crate) last_modified: std::option::Option<std::string::String>,
        pub(crate) code_sha256: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<std::string::String>,
        pub(crate) vpc_config: std::option::Option<crate::model::VpcConfigResponse>,
        pub(crate) dead_letter_config: std::option::Option<crate::model::DeadLetterConfig>,
        pub(crate) environment: std::option::Option<crate::model::EnvironmentResponse>,
        pub(crate) kms_key_arn: std::option::Option<std::string::String>,
        pub(crate) tracing_config: std::option::Option<crate::model::TracingConfigResponse>,
        pub(crate) master_arn: std::option::Option<std::string::String>,
        pub(crate) revision_id: std::option::Option<std::string::String>,
        pub(crate) layers: std::option::Option<std::vec::Vec<crate::model::Layer>>,
        pub(crate) state: std::option::Option<crate::model::State>,
        pub(crate) state_reason: std::option::Option<std::string::String>,
        pub(crate) state_reason_code: std::option::Option<crate::model::StateReasonCode>,
        pub(crate) last_update_status: std::option::Option<crate::model::LastUpdateStatus>,
        pub(crate) last_update_status_reason: std::option::Option<std::string::String>,
        pub(crate) last_update_status_reason_code:
            std::option::Option<crate::model::LastUpdateStatusReasonCode>,
        pub(crate) file_system_configs:
            std::option::Option<std::vec::Vec<crate::model::FileSystemConfig>>,
        pub(crate) package_type: std::option::Option<crate::model::PackageType>,
        pub(crate) image_config_response: std::option::Option<crate::model::ImageConfigResponse>,
        pub(crate) signing_profile_version_arn: std::option::Option<std::string::String>,
        pub(crate) signing_job_arn: std::option::Option<std::string::String>,
        pub(crate) architectures: std::option::Option<std::vec::Vec<crate::model::Architecture>>,
        pub(crate) ephemeral_storage: std::option::Option<crate::model::EphemeralStorage>,
        pub(crate) snap_start: std::option::Option<crate::model::SnapStartResponse>,
        pub(crate) runtime_version_config: std::option::Option<crate::model::RuntimeVersionConfig>,
    }
    impl Builder {
        /// <p>The name of the function.</p>
        pub fn function_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.function_name = Some(input.into());
            self
        }
        /// <p>The name of the function.</p>
        pub fn set_function_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.function_name = input;
            self
        }
        /// <p>The function's Amazon Resource Name (ARN).</p>
        pub fn function_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.function_arn = Some(input.into());
            self
        }
        /// <p>The function's Amazon Resource Name (ARN).</p>
        pub fn set_function_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.function_arn = input;
            self
        }
        /// <p>The runtime environment for the Lambda function.</p>
        pub fn runtime(mut self, input: crate::model::Runtime) -> Self {
            self.runtime = Some(input);
            self
        }
        /// <p>The runtime environment for the Lambda function.</p>
        pub fn set_runtime(mut self, input: std::option::Option<crate::model::Runtime>) -> Self {
            self.runtime = input;
            self
        }
        /// <p>The function's execution role.</p>
        pub fn role(mut self, input: impl Into<std::string::String>) -> Self {
            self.role = Some(input.into());
            self
        }
        /// <p>The function's execution role.</p>
        pub fn set_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role = input;
            self
        }
        /// <p>The function that Lambda calls to begin running your function.</p>
        pub fn handler(mut self, input: impl Into<std::string::String>) -> Self {
            self.handler = Some(input.into());
            self
        }
        /// <p>The function that Lambda calls to begin running your function.</p>
        pub fn set_handler(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.handler = input;
            self
        }
        /// <p>The size of the function's deployment package, in bytes.</p>
        pub fn code_size(mut self, input: i64) -> Self {
            self.code_size = Some(input);
            self
        }
        /// <p>The size of the function's deployment package, in bytes.</p>
        pub fn set_code_size(mut self, input: std::option::Option<i64>) -> Self {
            self.code_size = input;
            self
        }
        /// <p>The function's description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The function's description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The amount of time in seconds that Lambda allows a function to run before stopping it.</p>
        pub fn timeout(mut self, input: i32) -> Self {
            self.timeout = Some(input);
            self
        }
        /// <p>The amount of time in seconds that Lambda allows a function to run before stopping it.</p>
        pub fn set_timeout(mut self, input: std::option::Option<i32>) -> Self {
            self.timeout = input;
            self
        }
        /// <p>The amount of memory available to the function at runtime.</p>
        pub fn memory_size(mut self, input: i32) -> Self {
            self.memory_size = Some(input);
            self
        }
        /// <p>The amount of memory available to the function at runtime.</p>
        pub fn set_memory_size(mut self, input: std::option::Option<i32>) -> Self {
            self.memory_size = input;
            self
        }
        /// <p>The date and time that the function was last updated, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format</a> (YYYY-MM-DDThh:mm:ss.sTZD).</p>
        pub fn last_modified(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified = Some(input.into());
            self
        }
        /// <p>The date and time that the function was last updated, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format</a> (YYYY-MM-DDThh:mm:ss.sTZD).</p>
        pub fn set_last_modified(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified = input;
            self
        }
        /// <p>The SHA256 hash of the function's deployment package.</p>
        pub fn code_sha256(mut self, input: impl Into<std::string::String>) -> Self {
            self.code_sha256 = Some(input.into());
            self
        }
        /// <p>The SHA256 hash of the function's deployment package.</p>
        pub fn set_code_sha256(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code_sha256 = input;
            self
        }
        /// <p>The version of the Lambda function.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>The version of the Lambda function.</p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// <p>The function's networking configuration.</p>
        pub fn vpc_config(mut self, input: crate::model::VpcConfigResponse) -> Self {
            self.vpc_config = Some(input);
            self
        }
        /// <p>The function's networking configuration.</p>
        pub fn set_vpc_config(
            mut self,
            input: std::option::Option<crate::model::VpcConfigResponse>,
        ) -> Self {
            self.vpc_config = input;
            self
        }
        /// <p>The function's dead letter queue.</p>
        pub fn dead_letter_config(mut self, input: crate::model::DeadLetterConfig) -> Self {
            self.dead_letter_config = Some(input);
            self
        }
        /// <p>The function's dead letter queue.</p>
        pub fn set_dead_letter_config(
            mut self,
            input: std::option::Option<crate::model::DeadLetterConfig>,
        ) -> Self {
            self.dead_letter_config = input;
            self
        }
        /// <p>The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html">environment variables</a>. Omitted from CloudTrail logs.</p>
        pub fn environment(mut self, input: crate::model::EnvironmentResponse) -> Self {
            self.environment = Some(input);
            self
        }
        /// <p>The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html">environment variables</a>. Omitted from CloudTrail logs.</p>
        pub fn set_environment(
            mut self,
            input: std::option::Option<crate::model::EnvironmentResponse>,
        ) -> Self {
            self.environment = input;
            self
        }
        /// <p>The KMS key that's used to encrypt the function's environment variables. This key is returned only if you've configured a customer managed key.</p>
        pub fn kms_key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_arn = Some(input.into());
            self
        }
        /// <p>The KMS key that's used to encrypt the function's environment variables. This key is returned only if you've configured a customer managed key.</p>
        pub fn set_kms_key_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_arn = input;
            self
        }
        /// <p>The function's X-Ray tracing configuration.</p>
        pub fn tracing_config(mut self, input: crate::model::TracingConfigResponse) -> Self {
            self.tracing_config = Some(input);
            self
        }
        /// <p>The function's X-Ray tracing configuration.</p>
        pub fn set_tracing_config(
            mut self,
            input: std::option::Option<crate::model::TracingConfigResponse>,
        ) -> Self {
            self.tracing_config = input;
            self
        }
        /// <p>For Lambda@Edge functions, the ARN of the main function.</p>
        pub fn master_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.master_arn = Some(input.into());
            self
        }
        /// <p>For Lambda@Edge functions, the ARN of the main function.</p>
        pub fn set_master_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.master_arn = input;
            self
        }
        /// <p>The latest updated revision of the function or alias.</p>
        pub fn revision_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.revision_id = Some(input.into());
            self
        }
        /// <p>The latest updated revision of the function or alias.</p>
        pub fn set_revision_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.revision_id = input;
            self
        }
        /// Appends an item to `layers`.
        ///
        /// To override the contents of this collection use [`set_layers`](Self::set_layers).
        ///
        /// <p>The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">layers</a>.</p>
        pub fn layers(mut self, input: crate::model::Layer) -> Self {
            let mut v = self.layers.unwrap_or_default();
            v.push(input);
            self.layers = Some(v);
            self
        }
        /// <p>The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">layers</a>.</p>
        pub fn set_layers(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Layer>>,
        ) -> Self {
            self.layers = input;
            self
        }
        /// <p>The current state of the function. When the state is <code>Inactive</code>, you can reactivate the function by invoking it.</p>
        pub fn state(mut self, input: crate::model::State) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current state of the function. When the state is <code>Inactive</code>, you can reactivate the function by invoking it.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::State>) -> Self {
            self.state = input;
            self
        }
        /// <p>The reason for the function's current state.</p>
        pub fn state_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.state_reason = Some(input.into());
            self
        }
        /// <p>The reason for the function's current state.</p>
        pub fn set_state_reason(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.state_reason = input;
            self
        }
        /// <p>The reason code for the function's current state. When the code is <code>Creating</code>, you can't invoke or modify the function.</p>
        pub fn state_reason_code(mut self, input: crate::model::StateReasonCode) -> Self {
            self.state_reason_code = Some(input);
            self
        }
        /// <p>The reason code for the function's current state. When the code is <code>Creating</code>, you can't invoke or modify the function.</p>
        pub fn set_state_reason_code(
            mut self,
            input: std::option::Option<crate::model::StateReasonCode>,
        ) -> Self {
            self.state_reason_code = input;
            self
        }
        /// <p>The status of the last update that was performed on the function. This is first set to <code>Successful</code> after function creation completes.</p>
        pub fn last_update_status(mut self, input: crate::model::LastUpdateStatus) -> Self {
            self.last_update_status = Some(input);
            self
        }
        /// <p>The status of the last update that was performed on the function. This is first set to <code>Successful</code> after function creation completes.</p>
        pub fn set_last_update_status(
            mut self,
            input: std::option::Option<crate::model::LastUpdateStatus>,
        ) -> Self {
            self.last_update_status = input;
            self
        }
        /// <p>The reason for the last update that was performed on the function.</p>
        pub fn last_update_status_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_update_status_reason = Some(input.into());
            self
        }
        /// <p>The reason for the last update that was performed on the function.</p>
        pub fn set_last_update_status_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_update_status_reason = input;
            self
        }
        /// <p>The reason code for the last update that was performed on the function.</p>
        pub fn last_update_status_reason_code(
            mut self,
            input: crate::model::LastUpdateStatusReasonCode,
        ) -> Self {
            self.last_update_status_reason_code = Some(input);
            self
        }
        /// <p>The reason code for the last update that was performed on the function.</p>
        pub fn set_last_update_status_reason_code(
            mut self,
            input: std::option::Option<crate::model::LastUpdateStatusReasonCode>,
        ) -> Self {
            self.last_update_status_reason_code = input;
            self
        }
        /// Appends an item to `file_system_configs`.
        ///
        /// To override the contents of this collection use [`set_file_system_configs`](Self::set_file_system_configs).
        ///
        /// <p>Connection settings for an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html">Amazon EFS file system</a>.</p>
        pub fn file_system_configs(mut self, input: crate::model::FileSystemConfig) -> Self {
            let mut v = self.file_system_configs.unwrap_or_default();
            v.push(input);
            self.file_system_configs = Some(v);
            self
        }
        /// <p>Connection settings for an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html">Amazon EFS file system</a>.</p>
        pub fn set_file_system_configs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FileSystemConfig>>,
        ) -> Self {
            self.file_system_configs = input;
            self
        }
        /// <p>The type of deployment package. Set to <code>Image</code> for container image and set <code>Zip</code> for .zip file archive.</p>
        pub fn package_type(mut self, input: crate::model::PackageType) -> Self {
            self.package_type = Some(input);
            self
        }
        /// <p>The type of deployment package. Set to <code>Image</code> for container image and set <code>Zip</code> for .zip file archive.</p>
        pub fn set_package_type(
            mut self,
            input: std::option::Option<crate::model::PackageType>,
        ) -> Self {
            self.package_type = input;
            self
        }
        /// <p>The function's image configuration values.</p>
        pub fn image_config_response(mut self, input: crate::model::ImageConfigResponse) -> Self {
            self.image_config_response = Some(input);
            self
        }
        /// <p>The function's image configuration values.</p>
        pub fn set_image_config_response(
            mut self,
            input: std::option::Option<crate::model::ImageConfigResponse>,
        ) -> Self {
            self.image_config_response = input;
            self
        }
        /// <p>The ARN of the signing profile version.</p>
        pub fn signing_profile_version_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.signing_profile_version_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the signing profile version.</p>
        pub fn set_signing_profile_version_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.signing_profile_version_arn = input;
            self
        }
        /// <p>The ARN of the signing job.</p>
        pub fn signing_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.signing_job_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the signing job.</p>
        pub fn set_signing_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.signing_job_arn = input;
            self
        }
        /// Appends an item to `architectures`.
        ///
        /// To override the contents of this collection use [`set_architectures`](Self::set_architectures).
        ///
        /// <p>The instruction set architecture that the function supports. Architecture is a string array with one of the valid values. The default architecture value is <code>x86_64</code>.</p>
        pub fn architectures(mut self, input: crate::model::Architecture) -> Self {
            let mut v = self.architectures.unwrap_or_default();
            v.push(input);
            self.architectures = Some(v);
            self
        }
        /// <p>The instruction set architecture that the function supports. Architecture is a string array with one of the valid values. The default architecture value is <code>x86_64</code>.</p>
        pub fn set_architectures(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Architecture>>,
        ) -> Self {
            self.architectures = input;
            self
        }
        /// <p>The size of the function’s <code>/tmp</code> directory in MB. The default value is 512, but it can be any whole number between 512 and 10,240 MB.</p>
        pub fn ephemeral_storage(mut self, input: crate::model::EphemeralStorage) -> Self {
            self.ephemeral_storage = Some(input);
            self
        }
        /// <p>The size of the function’s <code>/tmp</code> directory in MB. The default value is 512, but it can be any whole number between 512 and 10,240 MB.</p>
        pub fn set_ephemeral_storage(
            mut self,
            input: std::option::Option<crate::model::EphemeralStorage>,
        ) -> Self {
            self.ephemeral_storage = input;
            self
        }
        /// <p>Set <code>ApplyOn</code> to <code>PublishedVersions</code> to create a snapshot of the initialized execution environment when you publish a function version. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html">Improving startup performance with Lambda SnapStart</a>.</p>
        pub fn snap_start(mut self, input: crate::model::SnapStartResponse) -> Self {
            self.snap_start = Some(input);
            self
        }
        /// <p>Set <code>ApplyOn</code> to <code>PublishedVersions</code> to create a snapshot of the initialized execution environment when you publish a function version. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html">Improving startup performance with Lambda SnapStart</a>.</p>
        pub fn set_snap_start(
            mut self,
            input: std::option::Option<crate::model::SnapStartResponse>,
        ) -> Self {
            self.snap_start = input;
            self
        }
        /// <p>The ARN of the runtime and any errors that occured.</p>
        pub fn runtime_version_config(mut self, input: crate::model::RuntimeVersionConfig) -> Self {
            self.runtime_version_config = Some(input);
            self
        }
        /// <p>The ARN of the runtime and any errors that occured.</p>
        pub fn set_runtime_version_config(
            mut self,
            input: std::option::Option<crate::model::RuntimeVersionConfig>,
        ) -> Self {
            self.runtime_version_config = input;
            self
        }
        /// Consumes the builder and constructs a [`FunctionConfiguration`](crate::model::FunctionConfiguration).
        pub fn build(self) -> crate::model::FunctionConfiguration {
            crate::model::FunctionConfiguration {
                function_name: self.function_name,
                function_arn: self.function_arn,
                runtime: self.runtime,
                role: self.role,
                handler: self.handler,
                code_size: self.code_size.unwrap_or_default(),
                description: self.description,
                timeout: self.timeout,
                memory_size: self.memory_size,
                last_modified: self.last_modified,
                code_sha256: self.code_sha256,
                version: self.version,
                vpc_config: self.vpc_config,
                dead_letter_config: self.dead_letter_config,
                environment: self.environment,
                kms_key_arn: self.kms_key_arn,
                tracing_config: self.tracing_config,
                master_arn: self.master_arn,
                revision_id: self.revision_id,
                layers: self.layers,
                state: self.state,
                state_reason: self.state_reason,
                state_reason_code: self.state_reason_code,
                last_update_status: self.last_update_status,
                last_update_status_reason: self.last_update_status_reason,
                last_update_status_reason_code: self.last_update_status_reason_code,
                file_system_configs: self.file_system_configs,
                package_type: self.package_type,
                image_config_response: self.image_config_response,
                signing_profile_version_arn: self.signing_profile_version_arn,
                signing_job_arn: self.signing_job_arn,
                architectures: self.architectures,
                ephemeral_storage: self.ephemeral_storage,
                snap_start: self.snap_start,
                runtime_version_config: self.runtime_version_config,
            }
        }
    }
}
impl FunctionConfiguration {
    /// Creates a new builder-style object to manufacture [`FunctionConfiguration`](crate::model::FunctionConfiguration).
    pub fn builder() -> crate::model::function_configuration::Builder {
        crate::model::function_configuration::Builder::default()
    }
}

/// <p>Details about the provisioned concurrency configuration for a function alias or version.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProvisionedConcurrencyConfigListItem {
    /// <p>The Amazon Resource Name (ARN) of the alias or version.</p>
    #[doc(hidden)]
    pub function_arn: std::option::Option<std::string::String>,
    /// <p>The amount of provisioned concurrency requested.</p>
    #[doc(hidden)]
    pub requested_provisioned_concurrent_executions: std::option::Option<i32>,
    /// <p>The amount of provisioned concurrency available.</p>
    #[doc(hidden)]
    pub available_provisioned_concurrent_executions: std::option::Option<i32>,
    /// <p>The amount of provisioned concurrency allocated. When a weighted alias is used during linear and canary deployments, this value fluctuates depending on the amount of concurrency that is provisioned for the function versions.</p>
    #[doc(hidden)]
    pub allocated_provisioned_concurrent_executions: std::option::Option<i32>,
    /// <p>The status of the allocation process.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ProvisionedConcurrencyStatusEnum>,
    /// <p>For failed allocations, the reason that provisioned concurrency could not be allocated.</p>
    #[doc(hidden)]
    pub status_reason: std::option::Option<std::string::String>,
    /// <p>The date and time that a user last updated the configuration, in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601 format</a>.</p>
    #[doc(hidden)]
    pub last_modified: std::option::Option<std::string::String>,
}
impl ProvisionedConcurrencyConfigListItem {
    /// <p>The Amazon Resource Name (ARN) of the alias or version.</p>
    pub fn function_arn(&self) -> std::option::Option<&str> {
        self.function_arn.as_deref()
    }
    /// <p>The amount of provisioned concurrency requested.</p>
    pub fn requested_provisioned_concurrent_executions(&self) -> std::option::Option<i32> {
        self.requested_provisioned_concurrent_executions
    }
    /// <p>The amount of provisioned concurrency available.</p>
    pub fn available_provisioned_concurrent_executions(&self) -> std::option::Option<i32> {
        self.available_provisioned_concurrent_executions
    }
    /// <p>The amount of provisioned concurrency allocated. When a weighted alias is used during linear and canary deployments, this value fluctuates depending on the amount of concurrency that is provisioned for the function versions.</p>
    pub fn allocated_provisioned_concurrent_executions(&self) -> std::option::Option<i32> {
        self.allocated_provisioned_concurrent_executions
    }
    /// <p>The status of the allocation process.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ProvisionedConcurrencyStatusEnum> {
        self.status.as_ref()
    }
    /// <p>For failed allocations, the reason that provisioned concurrency could not be allocated.</p>
    pub fn status_reason(&self) -> std::option::Option<&str> {
        self.status_reason.as_deref()
    }
    /// <p>The date and time that a user last updated the configuration, in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601 format</a>.</p>
    pub fn last_modified(&self) -> std::option::Option<&str> {
        self.last_modified.as_deref()
    }
}
/// See [`ProvisionedConcurrencyConfigListItem`](crate::model::ProvisionedConcurrencyConfigListItem).
pub mod provisioned_concurrency_config_list_item {

    /// A builder for [`ProvisionedConcurrencyConfigListItem`](crate::model::ProvisionedConcurrencyConfigListItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) function_arn: std::option::Option<std::string::String>,
        pub(crate) requested_provisioned_concurrent_executions: std::option::Option<i32>,
        pub(crate) available_provisioned_concurrent_executions: std::option::Option<i32>,
        pub(crate) allocated_provisioned_concurrent_executions: std::option::Option<i32>,
        pub(crate) status: std::option::Option<crate::model::ProvisionedConcurrencyStatusEnum>,
        pub(crate) status_reason: std::option::Option<std::string::String>,
        pub(crate) last_modified: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the alias or version.</p>
        pub fn function_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.function_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the alias or version.</p>
        pub fn set_function_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.function_arn = input;
            self
        }
        /// <p>The amount of provisioned concurrency requested.</p>
        pub fn requested_provisioned_concurrent_executions(mut self, input: i32) -> Self {
            self.requested_provisioned_concurrent_executions = Some(input);
            self
        }
        /// <p>The amount of provisioned concurrency requested.</p>
        pub fn set_requested_provisioned_concurrent_executions(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.requested_provisioned_concurrent_executions = input;
            self
        }
        /// <p>The amount of provisioned concurrency available.</p>
        pub fn available_provisioned_concurrent_executions(mut self, input: i32) -> Self {
            self.available_provisioned_concurrent_executions = Some(input);
            self
        }
        /// <p>The amount of provisioned concurrency available.</p>
        pub fn set_available_provisioned_concurrent_executions(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.available_provisioned_concurrent_executions = input;
            self
        }
        /// <p>The amount of provisioned concurrency allocated. When a weighted alias is used during linear and canary deployments, this value fluctuates depending on the amount of concurrency that is provisioned for the function versions.</p>
        pub fn allocated_provisioned_concurrent_executions(mut self, input: i32) -> Self {
            self.allocated_provisioned_concurrent_executions = Some(input);
            self
        }
        /// <p>The amount of provisioned concurrency allocated. When a weighted alias is used during linear and canary deployments, this value fluctuates depending on the amount of concurrency that is provisioned for the function versions.</p>
        pub fn set_allocated_provisioned_concurrent_executions(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.allocated_provisioned_concurrent_executions = input;
            self
        }
        /// <p>The status of the allocation process.</p>
        pub fn status(mut self, input: crate::model::ProvisionedConcurrencyStatusEnum) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the allocation process.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ProvisionedConcurrencyStatusEnum>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>For failed allocations, the reason that provisioned concurrency could not be allocated.</p>
        pub fn status_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_reason = Some(input.into());
            self
        }
        /// <p>For failed allocations, the reason that provisioned concurrency could not be allocated.</p>
        pub fn set_status_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_reason = input;
            self
        }
        /// <p>The date and time that a user last updated the configuration, in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601 format</a>.</p>
        pub fn last_modified(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified = Some(input.into());
            self
        }
        /// <p>The date and time that a user last updated the configuration, in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601 format</a>.</p>
        pub fn set_last_modified(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified = input;
            self
        }
        /// Consumes the builder and constructs a [`ProvisionedConcurrencyConfigListItem`](crate::model::ProvisionedConcurrencyConfigListItem).
        pub fn build(self) -> crate::model::ProvisionedConcurrencyConfigListItem {
            crate::model::ProvisionedConcurrencyConfigListItem {
                function_arn: self.function_arn,
                requested_provisioned_concurrent_executions: self
                    .requested_provisioned_concurrent_executions,
                available_provisioned_concurrent_executions: self
                    .available_provisioned_concurrent_executions,
                allocated_provisioned_concurrent_executions: self
                    .allocated_provisioned_concurrent_executions,
                status: self.status,
                status_reason: self.status_reason,
                last_modified: self.last_modified,
            }
        }
    }
}
impl ProvisionedConcurrencyConfigListItem {
    /// Creates a new builder-style object to manufacture [`ProvisionedConcurrencyConfigListItem`](crate::model::ProvisionedConcurrencyConfigListItem).
    pub fn builder() -> crate::model::provisioned_concurrency_config_list_item::Builder {
        crate::model::provisioned_concurrency_config_list_item::Builder::default()
    }
}

/// <p>Details about a version of an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">Lambda layer</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LayerVersionsListItem {
    /// <p>The ARN of the layer version.</p>
    #[doc(hidden)]
    pub layer_version_arn: std::option::Option<std::string::String>,
    /// <p>The version number.</p>
    #[doc(hidden)]
    pub version: i64,
    /// <p>The description of the version.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The date that the version was created, in ISO 8601 format. For example, <code>2018-11-27T15:10:45.123+0000</code>.</p>
    #[doc(hidden)]
    pub created_date: std::option::Option<std::string::String>,
    /// <p>The layer's compatible runtimes.</p>
    #[doc(hidden)]
    pub compatible_runtimes: std::option::Option<std::vec::Vec<crate::model::Runtime>>,
    /// <p>The layer's open-source license.</p>
    #[doc(hidden)]
    pub license_info: std::option::Option<std::string::String>,
    /// <p>A list of compatible <a href="https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html">instruction set architectures</a>.</p>
    #[doc(hidden)]
    pub compatible_architectures: std::option::Option<std::vec::Vec<crate::model::Architecture>>,
}
impl LayerVersionsListItem {
    /// <p>The ARN of the layer version.</p>
    pub fn layer_version_arn(&self) -> std::option::Option<&str> {
        self.layer_version_arn.as_deref()
    }
    /// <p>The version number.</p>
    pub fn version(&self) -> i64 {
        self.version
    }
    /// <p>The description of the version.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The date that the version was created, in ISO 8601 format. For example, <code>2018-11-27T15:10:45.123+0000</code>.</p>
    pub fn created_date(&self) -> std::option::Option<&str> {
        self.created_date.as_deref()
    }
    /// <p>The layer's compatible runtimes.</p>
    pub fn compatible_runtimes(&self) -> std::option::Option<&[crate::model::Runtime]> {
        self.compatible_runtimes.as_deref()
    }
    /// <p>The layer's open-source license.</p>
    pub fn license_info(&self) -> std::option::Option<&str> {
        self.license_info.as_deref()
    }
    /// <p>A list of compatible <a href="https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html">instruction set architectures</a>.</p>
    pub fn compatible_architectures(&self) -> std::option::Option<&[crate::model::Architecture]> {
        self.compatible_architectures.as_deref()
    }
}
/// See [`LayerVersionsListItem`](crate::model::LayerVersionsListItem).
pub mod layer_versions_list_item {

    /// A builder for [`LayerVersionsListItem`](crate::model::LayerVersionsListItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) layer_version_arn: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<i64>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) created_date: std::option::Option<std::string::String>,
        pub(crate) compatible_runtimes: std::option::Option<std::vec::Vec<crate::model::Runtime>>,
        pub(crate) license_info: std::option::Option<std::string::String>,
        pub(crate) compatible_architectures:
            std::option::Option<std::vec::Vec<crate::model::Architecture>>,
    }
    impl Builder {
        /// <p>The ARN of the layer version.</p>
        pub fn layer_version_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.layer_version_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the layer version.</p>
        pub fn set_layer_version_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.layer_version_arn = input;
            self
        }
        /// <p>The version number.</p>
        pub fn version(mut self, input: i64) -> Self {
            self.version = Some(input);
            self
        }
        /// <p>The version number.</p>
        pub fn set_version(mut self, input: std::option::Option<i64>) -> Self {
            self.version = input;
            self
        }
        /// <p>The description of the version.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the version.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The date that the version was created, in ISO 8601 format. For example, <code>2018-11-27T15:10:45.123+0000</code>.</p>
        pub fn created_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_date = Some(input.into());
            self
        }
        /// <p>The date that the version was created, in ISO 8601 format. For example, <code>2018-11-27T15:10:45.123+0000</code>.</p>
        pub fn set_created_date(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_date = input;
            self
        }
        /// Appends an item to `compatible_runtimes`.
        ///
        /// To override the contents of this collection use [`set_compatible_runtimes`](Self::set_compatible_runtimes).
        ///
        /// <p>The layer's compatible runtimes.</p>
        pub fn compatible_runtimes(mut self, input: crate::model::Runtime) -> Self {
            let mut v = self.compatible_runtimes.unwrap_or_default();
            v.push(input);
            self.compatible_runtimes = Some(v);
            self
        }
        /// <p>The layer's compatible runtimes.</p>
        pub fn set_compatible_runtimes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Runtime>>,
        ) -> Self {
            self.compatible_runtimes = input;
            self
        }
        /// <p>The layer's open-source license.</p>
        pub fn license_info(mut self, input: impl Into<std::string::String>) -> Self {
            self.license_info = Some(input.into());
            self
        }
        /// <p>The layer's open-source license.</p>
        pub fn set_license_info(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.license_info = input;
            self
        }
        /// Appends an item to `compatible_architectures`.
        ///
        /// To override the contents of this collection use [`set_compatible_architectures`](Self::set_compatible_architectures).
        ///
        /// <p>A list of compatible <a href="https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html">instruction set architectures</a>.</p>
        pub fn compatible_architectures(mut self, input: crate::model::Architecture) -> Self {
            let mut v = self.compatible_architectures.unwrap_or_default();
            v.push(input);
            self.compatible_architectures = Some(v);
            self
        }
        /// <p>A list of compatible <a href="https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html">instruction set architectures</a>.</p>
        pub fn set_compatible_architectures(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Architecture>>,
        ) -> Self {
            self.compatible_architectures = input;
            self
        }
        /// Consumes the builder and constructs a [`LayerVersionsListItem`](crate::model::LayerVersionsListItem).
        pub fn build(self) -> crate::model::LayerVersionsListItem {
            crate::model::LayerVersionsListItem {
                layer_version_arn: self.layer_version_arn,
                version: self.version.unwrap_or_default(),
                description: self.description,
                created_date: self.created_date,
                compatible_runtimes: self.compatible_runtimes,
                license_info: self.license_info,
                compatible_architectures: self.compatible_architectures,
            }
        }
    }
}
impl LayerVersionsListItem {
    /// Creates a new builder-style object to manufacture [`LayerVersionsListItem`](crate::model::LayerVersionsListItem).
    pub fn builder() -> crate::model::layer_versions_list_item::Builder {
        crate::model::layer_versions_list_item::Builder::default()
    }
}

/// <p>Details about an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">Lambda layer</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LayersListItem {
    /// <p>The name of the layer.</p>
    #[doc(hidden)]
    pub layer_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the function layer.</p>
    #[doc(hidden)]
    pub layer_arn: std::option::Option<std::string::String>,
    /// <p>The newest version of the layer.</p>
    #[doc(hidden)]
    pub latest_matching_version: std::option::Option<crate::model::LayerVersionsListItem>,
}
impl LayersListItem {
    /// <p>The name of the layer.</p>
    pub fn layer_name(&self) -> std::option::Option<&str> {
        self.layer_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the function layer.</p>
    pub fn layer_arn(&self) -> std::option::Option<&str> {
        self.layer_arn.as_deref()
    }
    /// <p>The newest version of the layer.</p>
    pub fn latest_matching_version(
        &self,
    ) -> std::option::Option<&crate::model::LayerVersionsListItem> {
        self.latest_matching_version.as_ref()
    }
}
/// See [`LayersListItem`](crate::model::LayersListItem).
pub mod layers_list_item {

    /// A builder for [`LayersListItem`](crate::model::LayersListItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) layer_name: std::option::Option<std::string::String>,
        pub(crate) layer_arn: std::option::Option<std::string::String>,
        pub(crate) latest_matching_version:
            std::option::Option<crate::model::LayerVersionsListItem>,
    }
    impl Builder {
        /// <p>The name of the layer.</p>
        pub fn layer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.layer_name = Some(input.into());
            self
        }
        /// <p>The name of the layer.</p>
        pub fn set_layer_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.layer_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the function layer.</p>
        pub fn layer_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.layer_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the function layer.</p>
        pub fn set_layer_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.layer_arn = input;
            self
        }
        /// <p>The newest version of the layer.</p>
        pub fn latest_matching_version(
            mut self,
            input: crate::model::LayerVersionsListItem,
        ) -> Self {
            self.latest_matching_version = Some(input);
            self
        }
        /// <p>The newest version of the layer.</p>
        pub fn set_latest_matching_version(
            mut self,
            input: std::option::Option<crate::model::LayerVersionsListItem>,
        ) -> Self {
            self.latest_matching_version = input;
            self
        }
        /// Consumes the builder and constructs a [`LayersListItem`](crate::model::LayersListItem).
        pub fn build(self) -> crate::model::LayersListItem {
            crate::model::LayersListItem {
                layer_name: self.layer_name,
                layer_arn: self.layer_arn,
                latest_matching_version: self.latest_matching_version,
            }
        }
    }
}
impl LayersListItem {
    /// Creates a new builder-style object to manufacture [`LayersListItem`](crate::model::LayersListItem).
    pub fn builder() -> crate::model::layers_list_item::Builder {
        crate::model::layers_list_item::Builder::default()
    }
}

/// <p>Details about a Lambda function URL.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FunctionUrlConfig {
    /// <p>The HTTP URL endpoint for your function.</p>
    #[doc(hidden)]
    pub function_url: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of your function.</p>
    #[doc(hidden)]
    pub function_arn: std::option::Option<std::string::String>,
    /// <p>When the function URL was created, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format</a> (YYYY-MM-DDThh:mm:ss.sTZD).</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<std::string::String>,
    /// <p>When the function URL configuration was last updated, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format</a> (YYYY-MM-DDThh:mm:ss.sTZD).</p>
    #[doc(hidden)]
    pub last_modified_time: std::option::Option<std::string::String>,
    /// <p>The <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">cross-origin resource sharing (CORS)</a> settings for your function URL.</p>
    #[doc(hidden)]
    pub cors: std::option::Option<crate::model::Cors>,
    /// <p>The type of authentication that your function URL uses. Set to <code>AWS_IAM</code> if you want to restrict access to authenticated IAM users only. Set to <code>NONE</code> if you want to bypass IAM authentication to create a public endpoint. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/urls-auth.html">Security and auth model for Lambda function URLs</a>.</p>
    #[doc(hidden)]
    pub auth_type: std::option::Option<crate::model::FunctionUrlAuthType>,
}
impl FunctionUrlConfig {
    /// <p>The HTTP URL endpoint for your function.</p>
    pub fn function_url(&self) -> std::option::Option<&str> {
        self.function_url.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of your function.</p>
    pub fn function_arn(&self) -> std::option::Option<&str> {
        self.function_arn.as_deref()
    }
    /// <p>When the function URL was created, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format</a> (YYYY-MM-DDThh:mm:ss.sTZD).</p>
    pub fn creation_time(&self) -> std::option::Option<&str> {
        self.creation_time.as_deref()
    }
    /// <p>When the function URL configuration was last updated, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format</a> (YYYY-MM-DDThh:mm:ss.sTZD).</p>
    pub fn last_modified_time(&self) -> std::option::Option<&str> {
        self.last_modified_time.as_deref()
    }
    /// <p>The <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">cross-origin resource sharing (CORS)</a> settings for your function URL.</p>
    pub fn cors(&self) -> std::option::Option<&crate::model::Cors> {
        self.cors.as_ref()
    }
    /// <p>The type of authentication that your function URL uses. Set to <code>AWS_IAM</code> if you want to restrict access to authenticated IAM users only. Set to <code>NONE</code> if you want to bypass IAM authentication to create a public endpoint. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/urls-auth.html">Security and auth model for Lambda function URLs</a>.</p>
    pub fn auth_type(&self) -> std::option::Option<&crate::model::FunctionUrlAuthType> {
        self.auth_type.as_ref()
    }
}
/// See [`FunctionUrlConfig`](crate::model::FunctionUrlConfig).
pub mod function_url_config {

    /// A builder for [`FunctionUrlConfig`](crate::model::FunctionUrlConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) function_url: std::option::Option<std::string::String>,
        pub(crate) function_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<std::string::String>,
        pub(crate) last_modified_time: std::option::Option<std::string::String>,
        pub(crate) cors: std::option::Option<crate::model::Cors>,
        pub(crate) auth_type: std::option::Option<crate::model::FunctionUrlAuthType>,
    }
    impl Builder {
        /// <p>The HTTP URL endpoint for your function.</p>
        pub fn function_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.function_url = Some(input.into());
            self
        }
        /// <p>The HTTP URL endpoint for your function.</p>
        pub fn set_function_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.function_url = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of your function.</p>
        pub fn function_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.function_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of your function.</p>
        pub fn set_function_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.function_arn = input;
            self
        }
        /// <p>When the function URL was created, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format</a> (YYYY-MM-DDThh:mm:ss.sTZD).</p>
        pub fn creation_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_time = Some(input.into());
            self
        }
        /// <p>When the function URL was created, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format</a> (YYYY-MM-DDThh:mm:ss.sTZD).</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>When the function URL configuration was last updated, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format</a> (YYYY-MM-DDThh:mm:ss.sTZD).</p>
        pub fn last_modified_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_time = Some(input.into());
            self
        }
        /// <p>When the function URL configuration was last updated, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format</a> (YYYY-MM-DDThh:mm:ss.sTZD).</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">cross-origin resource sharing (CORS)</a> settings for your function URL.</p>
        pub fn cors(mut self, input: crate::model::Cors) -> Self {
            self.cors = Some(input);
            self
        }
        /// <p>The <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">cross-origin resource sharing (CORS)</a> settings for your function URL.</p>
        pub fn set_cors(mut self, input: std::option::Option<crate::model::Cors>) -> Self {
            self.cors = input;
            self
        }
        /// <p>The type of authentication that your function URL uses. Set to <code>AWS_IAM</code> if you want to restrict access to authenticated IAM users only. Set to <code>NONE</code> if you want to bypass IAM authentication to create a public endpoint. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/urls-auth.html">Security and auth model for Lambda function URLs</a>.</p>
        pub fn auth_type(mut self, input: crate::model::FunctionUrlAuthType) -> Self {
            self.auth_type = Some(input);
            self
        }
        /// <p>The type of authentication that your function URL uses. Set to <code>AWS_IAM</code> if you want to restrict access to authenticated IAM users only. Set to <code>NONE</code> if you want to bypass IAM authentication to create a public endpoint. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/urls-auth.html">Security and auth model for Lambda function URLs</a>.</p>
        pub fn set_auth_type(
            mut self,
            input: std::option::Option<crate::model::FunctionUrlAuthType>,
        ) -> Self {
            self.auth_type = input;
            self
        }
        /// Consumes the builder and constructs a [`FunctionUrlConfig`](crate::model::FunctionUrlConfig).
        pub fn build(self) -> crate::model::FunctionUrlConfig {
            crate::model::FunctionUrlConfig {
                function_url: self.function_url,
                function_arn: self.function_arn,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
                cors: self.cors,
                auth_type: self.auth_type,
            }
        }
    }
}
impl FunctionUrlConfig {
    /// Creates a new builder-style object to manufacture [`FunctionUrlConfig`](crate::model::FunctionUrlConfig).
    pub fn builder() -> crate::model::function_url_config::Builder {
        crate::model::function_url_config::Builder::default()
    }
}

/// When writing a match expression against `FunctionVersion`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let functionversion = unimplemented!();
/// match functionversion {
///     FunctionVersion::All => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `functionversion` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FunctionVersion::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FunctionVersion::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FunctionVersion::NewFeature` is defined.
/// Specifically, when `functionversion` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FunctionVersion::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FunctionVersion {
    #[allow(missing_docs)] // documentation missing in model
    All,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FunctionVersion {
    fn from(s: &str) -> Self {
        match s {
            "ALL" => FunctionVersion::All,
            other => FunctionVersion::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for FunctionVersion {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FunctionVersion::from(s))
    }
}
impl FunctionVersion {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FunctionVersion::All => "ALL",
            FunctionVersion::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALL"]
    }
}
impl AsRef<str> for FunctionVersion {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FunctionEventInvokeConfig {
    /// <p>The date and time that the configuration was last updated.</p>
    #[doc(hidden)]
    pub last_modified: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The Amazon Resource Name (ARN) of the function.</p>
    #[doc(hidden)]
    pub function_arn: std::option::Option<std::string::String>,
    /// <p>The maximum number of times to retry when the function returns an error.</p>
    #[doc(hidden)]
    pub maximum_retry_attempts: std::option::Option<i32>,
    /// <p>The maximum age of a request that Lambda sends to a function for processing.</p>
    #[doc(hidden)]
    pub maximum_event_age_in_seconds: std::option::Option<i32>,
    /// <p>A destination for events after they have been sent to a function for processing.</p>
    /// <p class="title"> <b>Destinations</b> </p>
    /// <ul>
    /// <li> <p> <b>Function</b> - The Amazon Resource Name (ARN) of a Lambda function.</p> </li>
    /// <li> <p> <b>Queue</b> - The ARN of an SQS queue.</p> </li>
    /// <li> <p> <b>Topic</b> - The ARN of an SNS topic.</p> </li>
    /// <li> <p> <b>Event Bus</b> - The ARN of an Amazon EventBridge event bus.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub destination_config: std::option::Option<crate::model::DestinationConfig>,
}
impl FunctionEventInvokeConfig {
    /// <p>The date and time that the configuration was last updated.</p>
    pub fn last_modified(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the function.</p>
    pub fn function_arn(&self) -> std::option::Option<&str> {
        self.function_arn.as_deref()
    }
    /// <p>The maximum number of times to retry when the function returns an error.</p>
    pub fn maximum_retry_attempts(&self) -> std::option::Option<i32> {
        self.maximum_retry_attempts
    }
    /// <p>The maximum age of a request that Lambda sends to a function for processing.</p>
    pub fn maximum_event_age_in_seconds(&self) -> std::option::Option<i32> {
        self.maximum_event_age_in_seconds
    }
    /// <p>A destination for events after they have been sent to a function for processing.</p>
    /// <p class="title"> <b>Destinations</b> </p>
    /// <ul>
    /// <li> <p> <b>Function</b> - The Amazon Resource Name (ARN) of a Lambda function.</p> </li>
    /// <li> <p> <b>Queue</b> - The ARN of an SQS queue.</p> </li>
    /// <li> <p> <b>Topic</b> - The ARN of an SNS topic.</p> </li>
    /// <li> <p> <b>Event Bus</b> - The ARN of an Amazon EventBridge event bus.</p> </li>
    /// </ul>
    pub fn destination_config(&self) -> std::option::Option<&crate::model::DestinationConfig> {
        self.destination_config.as_ref()
    }
}
/// See [`FunctionEventInvokeConfig`](crate::model::FunctionEventInvokeConfig).
pub mod function_event_invoke_config {

    /// A builder for [`FunctionEventInvokeConfig`](crate::model::FunctionEventInvokeConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) last_modified: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) function_arn: std::option::Option<std::string::String>,
        pub(crate) maximum_retry_attempts: std::option::Option<i32>,
        pub(crate) maximum_event_age_in_seconds: std::option::Option<i32>,
        pub(crate) destination_config: std::option::Option<crate::model::DestinationConfig>,
    }
    impl Builder {
        /// <p>The date and time that the configuration was last updated.</p>
        pub fn last_modified(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified = Some(input);
            self
        }
        /// <p>The date and time that the configuration was last updated.</p>
        pub fn set_last_modified(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the function.</p>
        pub fn function_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.function_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the function.</p>
        pub fn set_function_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.function_arn = input;
            self
        }
        /// <p>The maximum number of times to retry when the function returns an error.</p>
        pub fn maximum_retry_attempts(mut self, input: i32) -> Self {
            self.maximum_retry_attempts = Some(input);
            self
        }
        /// <p>The maximum number of times to retry when the function returns an error.</p>
        pub fn set_maximum_retry_attempts(mut self, input: std::option::Option<i32>) -> Self {
            self.maximum_retry_attempts = input;
            self
        }
        /// <p>The maximum age of a request that Lambda sends to a function for processing.</p>
        pub fn maximum_event_age_in_seconds(mut self, input: i32) -> Self {
            self.maximum_event_age_in_seconds = Some(input);
            self
        }
        /// <p>The maximum age of a request that Lambda sends to a function for processing.</p>
        pub fn set_maximum_event_age_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.maximum_event_age_in_seconds = input;
            self
        }
        /// <p>A destination for events after they have been sent to a function for processing.</p>
        /// <p class="title"> <b>Destinations</b> </p>
        /// <ul>
        /// <li> <p> <b>Function</b> - The Amazon Resource Name (ARN) of a Lambda function.</p> </li>
        /// <li> <p> <b>Queue</b> - The ARN of an SQS queue.</p> </li>
        /// <li> <p> <b>Topic</b> - The ARN of an SNS topic.</p> </li>
        /// <li> <p> <b>Event Bus</b> - The ARN of an Amazon EventBridge event bus.</p> </li>
        /// </ul>
        pub fn destination_config(mut self, input: crate::model::DestinationConfig) -> Self {
            self.destination_config = Some(input);
            self
        }
        /// <p>A destination for events after they have been sent to a function for processing.</p>
        /// <p class="title"> <b>Destinations</b> </p>
        /// <ul>
        /// <li> <p> <b>Function</b> - The Amazon Resource Name (ARN) of a Lambda function.</p> </li>
        /// <li> <p> <b>Queue</b> - The ARN of an SQS queue.</p> </li>
        /// <li> <p> <b>Topic</b> - The ARN of an SNS topic.</p> </li>
        /// <li> <p> <b>Event Bus</b> - The ARN of an Amazon EventBridge event bus.</p> </li>
        /// </ul>
        pub fn set_destination_config(
            mut self,
            input: std::option::Option<crate::model::DestinationConfig>,
        ) -> Self {
            self.destination_config = input;
            self
        }
        /// Consumes the builder and constructs a [`FunctionEventInvokeConfig`](crate::model::FunctionEventInvokeConfig).
        pub fn build(self) -> crate::model::FunctionEventInvokeConfig {
            crate::model::FunctionEventInvokeConfig {
                last_modified: self.last_modified,
                function_arn: self.function_arn,
                maximum_retry_attempts: self.maximum_retry_attempts,
                maximum_event_age_in_seconds: self.maximum_event_age_in_seconds,
                destination_config: self.destination_config,
            }
        }
    }
}
impl FunctionEventInvokeConfig {
    /// Creates a new builder-style object to manufacture [`FunctionEventInvokeConfig`](crate::model::FunctionEventInvokeConfig).
    pub fn builder() -> crate::model::function_event_invoke_config::Builder {
        crate::model::function_event_invoke_config::Builder::default()
    }
}

/// <p>A mapping between an Amazon Web Services resource and a Lambda function. For details, see <code>CreateEventSourceMapping</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EventSourceMappingConfiguration {
    /// <p>The identifier of the event source mapping.</p>
    #[doc(hidden)]
    pub uuid: std::option::Option<std::string::String>,
    /// <p>The position in a stream from which to start reading. Required for Amazon Kinesis, Amazon DynamoDB, and Amazon MSK stream sources. <code>AT_TIMESTAMP</code> is supported only for Amazon Kinesis streams.</p>
    #[doc(hidden)]
    pub starting_position: std::option::Option<crate::model::EventSourcePosition>,
    /// <p>With <code>StartingPosition</code> set to <code>AT_TIMESTAMP</code>, the time from which to start reading.</p>
    #[doc(hidden)]
    pub starting_position_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB).</p>
    /// <p>Default value: Varies by service. For Amazon SQS, the default is 10. For all other services, the default is 100.</p>
    /// <p>Related setting: When you set <code>BatchSize</code> to a value greater than 10, you must set <code>MaximumBatchingWindowInSeconds</code> to at least 1.</p>
    #[doc(hidden)]
    pub batch_size: std::option::Option<i32>,
    /// <p>The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. You can configure <code>MaximumBatchingWindowInSeconds</code> to any value from 0 seconds to 300 seconds in increments of seconds.</p>
    /// <p>For streams and Amazon SQS event sources, the default batching window is 0 seconds. For Amazon MSK, Self-managed Apache Kafka, and Amazon MQ event sources, the default batching window is 500 ms. Note that because you can only change <code>MaximumBatchingWindowInSeconds</code> in increments of seconds, you cannot revert back to the 500 ms default batching window after you have changed it. To restore the default batching window, you must create a new event source mapping.</p>
    /// <p>Related setting: For streams and Amazon SQS event sources, when you set <code>BatchSize</code> to a value greater than 10, you must set <code>MaximumBatchingWindowInSeconds</code> to at least 1.</p>
    #[doc(hidden)]
    pub maximum_batching_window_in_seconds: std::option::Option<i32>,
    /// <p>(Streams only) The number of batches to process concurrently from each shard. The default value is 1.</p>
    #[doc(hidden)]
    pub parallelization_factor: std::option::Option<i32>,
    /// <p>The Amazon Resource Name (ARN) of the event source.</p>
    #[doc(hidden)]
    pub event_source_arn: std::option::Option<std::string::String>,
    /// <p>An object that defines the filter criteria that determine whether Lambda should process an event. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html">Lambda event filtering</a>.</p>
    #[doc(hidden)]
    pub filter_criteria: std::option::Option<crate::model::FilterCriteria>,
    /// <p>The ARN of the Lambda function.</p>
    #[doc(hidden)]
    pub function_arn: std::option::Option<std::string::String>,
    /// <p>The date that the event source mapping was last updated or that its state changed.</p>
    #[doc(hidden)]
    pub last_modified: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The result of the last Lambda invocation of your function.</p>
    #[doc(hidden)]
    pub last_processing_result: std::option::Option<std::string::String>,
    /// <p>The state of the event source mapping. It can be one of the following: <code>Creating</code>, <code>Enabling</code>, <code>Enabled</code>, <code>Disabling</code>, <code>Disabled</code>, <code>Updating</code>, or <code>Deleting</code>.</p>
    #[doc(hidden)]
    pub state: std::option::Option<std::string::String>,
    /// <p>Indicates whether a user or Lambda made the last change to the event source mapping.</p>
    #[doc(hidden)]
    pub state_transition_reason: std::option::Option<std::string::String>,
    /// <p>(Streams only) An Amazon SQS queue or Amazon SNS topic destination for discarded records.</p>
    #[doc(hidden)]
    pub destination_config: std::option::Option<crate::model::DestinationConfig>,
    /// <p>The name of the Kafka topic.</p>
    #[doc(hidden)]
    pub topics: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p> (Amazon MQ) The name of the Amazon MQ broker destination queue to consume.</p>
    #[doc(hidden)]
    pub queues: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>An array of the authentication protocol, VPC components, or virtual host to secure and define your event source.</p>
    #[doc(hidden)]
    pub source_access_configurations:
        std::option::Option<std::vec::Vec<crate::model::SourceAccessConfiguration>>,
    /// <p>The self-managed Apache Kafka cluster for your event source.</p>
    #[doc(hidden)]
    pub self_managed_event_source: std::option::Option<crate::model::SelfManagedEventSource>,
    /// <p>(Streams only) Discard records older than the specified age. The default value is -1, which sets the maximum age to infinite. When the value is set to infinite, Lambda never discards old records. </p>
    #[doc(hidden)]
    pub maximum_record_age_in_seconds: std::option::Option<i32>,
    /// <p>(Streams only) If the function returns an error, split the batch in two and retry. The default value is false.</p>
    #[doc(hidden)]
    pub bisect_batch_on_function_error: std::option::Option<bool>,
    /// <p>(Streams only) Discard records after the specified number of retries. The default value is -1, which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, Lambda retries failed records until the record expires in the event source.</p>
    #[doc(hidden)]
    pub maximum_retry_attempts: std::option::Option<i32>,
    /// <p>(Streams only) The duration in seconds of a processing window. The range is 1–900 seconds.</p>
    #[doc(hidden)]
    pub tumbling_window_in_seconds: std::option::Option<i32>,
    /// <p>(Streams and Amazon SQS) A list of current response type enums applied to the event source mapping.</p>
    #[doc(hidden)]
    pub function_response_types:
        std::option::Option<std::vec::Vec<crate::model::FunctionResponseType>>,
    /// <p>Specific configuration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) event source.</p>
    #[doc(hidden)]
    pub amazon_managed_kafka_event_source_config:
        std::option::Option<crate::model::AmazonManagedKafkaEventSourceConfig>,
    /// <p>Specific configuration settings for a self-managed Apache Kafka event source.</p>
    #[doc(hidden)]
    pub self_managed_kafka_event_source_config:
        std::option::Option<crate::model::SelfManagedKafkaEventSourceConfig>,
    /// <p>(Amazon SQS only) The scaling configuration for the event source. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency">Configuring maximum concurrency for Amazon SQS event sources</a>.</p>
    #[doc(hidden)]
    pub scaling_config: std::option::Option<crate::model::ScalingConfig>,
}
impl EventSourceMappingConfiguration {
    /// <p>The identifier of the event source mapping.</p>
    pub fn uuid(&self) -> std::option::Option<&str> {
        self.uuid.as_deref()
    }
    /// <p>The position in a stream from which to start reading. Required for Amazon Kinesis, Amazon DynamoDB, and Amazon MSK stream sources. <code>AT_TIMESTAMP</code> is supported only for Amazon Kinesis streams.</p>
    pub fn starting_position(&self) -> std::option::Option<&crate::model::EventSourcePosition> {
        self.starting_position.as_ref()
    }
    /// <p>With <code>StartingPosition</code> set to <code>AT_TIMESTAMP</code>, the time from which to start reading.</p>
    pub fn starting_position_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.starting_position_timestamp.as_ref()
    }
    /// <p>The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB).</p>
    /// <p>Default value: Varies by service. For Amazon SQS, the default is 10. For all other services, the default is 100.</p>
    /// <p>Related setting: When you set <code>BatchSize</code> to a value greater than 10, you must set <code>MaximumBatchingWindowInSeconds</code> to at least 1.</p>
    pub fn batch_size(&self) -> std::option::Option<i32> {
        self.batch_size
    }
    /// <p>The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. You can configure <code>MaximumBatchingWindowInSeconds</code> to any value from 0 seconds to 300 seconds in increments of seconds.</p>
    /// <p>For streams and Amazon SQS event sources, the default batching window is 0 seconds. For Amazon MSK, Self-managed Apache Kafka, and Amazon MQ event sources, the default batching window is 500 ms. Note that because you can only change <code>MaximumBatchingWindowInSeconds</code> in increments of seconds, you cannot revert back to the 500 ms default batching window after you have changed it. To restore the default batching window, you must create a new event source mapping.</p>
    /// <p>Related setting: For streams and Amazon SQS event sources, when you set <code>BatchSize</code> to a value greater than 10, you must set <code>MaximumBatchingWindowInSeconds</code> to at least 1.</p>
    pub fn maximum_batching_window_in_seconds(&self) -> std::option::Option<i32> {
        self.maximum_batching_window_in_seconds
    }
    /// <p>(Streams only) The number of batches to process concurrently from each shard. The default value is 1.</p>
    pub fn parallelization_factor(&self) -> std::option::Option<i32> {
        self.parallelization_factor
    }
    /// <p>The Amazon Resource Name (ARN) of the event source.</p>
    pub fn event_source_arn(&self) -> std::option::Option<&str> {
        self.event_source_arn.as_deref()
    }
    /// <p>An object that defines the filter criteria that determine whether Lambda should process an event. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html">Lambda event filtering</a>.</p>
    pub fn filter_criteria(&self) -> std::option::Option<&crate::model::FilterCriteria> {
        self.filter_criteria.as_ref()
    }
    /// <p>The ARN of the Lambda function.</p>
    pub fn function_arn(&self) -> std::option::Option<&str> {
        self.function_arn.as_deref()
    }
    /// <p>The date that the event source mapping was last updated or that its state changed.</p>
    pub fn last_modified(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified.as_ref()
    }
    /// <p>The result of the last Lambda invocation of your function.</p>
    pub fn last_processing_result(&self) -> std::option::Option<&str> {
        self.last_processing_result.as_deref()
    }
    /// <p>The state of the event source mapping. It can be one of the following: <code>Creating</code>, <code>Enabling</code>, <code>Enabled</code>, <code>Disabling</code>, <code>Disabled</code>, <code>Updating</code>, or <code>Deleting</code>.</p>
    pub fn state(&self) -> std::option::Option<&str> {
        self.state.as_deref()
    }
    /// <p>Indicates whether a user or Lambda made the last change to the event source mapping.</p>
    pub fn state_transition_reason(&self) -> std::option::Option<&str> {
        self.state_transition_reason.as_deref()
    }
    /// <p>(Streams only) An Amazon SQS queue or Amazon SNS topic destination for discarded records.</p>
    pub fn destination_config(&self) -> std::option::Option<&crate::model::DestinationConfig> {
        self.destination_config.as_ref()
    }
    /// <p>The name of the Kafka topic.</p>
    pub fn topics(&self) -> std::option::Option<&[std::string::String]> {
        self.topics.as_deref()
    }
    /// <p> (Amazon MQ) The name of the Amazon MQ broker destination queue to consume.</p>
    pub fn queues(&self) -> std::option::Option<&[std::string::String]> {
        self.queues.as_deref()
    }
    /// <p>An array of the authentication protocol, VPC components, or virtual host to secure and define your event source.</p>
    pub fn source_access_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::SourceAccessConfiguration]> {
        self.source_access_configurations.as_deref()
    }
    /// <p>The self-managed Apache Kafka cluster for your event source.</p>
    pub fn self_managed_event_source(
        &self,
    ) -> std::option::Option<&crate::model::SelfManagedEventSource> {
        self.self_managed_event_source.as_ref()
    }
    /// <p>(Streams only) Discard records older than the specified age. The default value is -1, which sets the maximum age to infinite. When the value is set to infinite, Lambda never discards old records. </p>
    pub fn maximum_record_age_in_seconds(&self) -> std::option::Option<i32> {
        self.maximum_record_age_in_seconds
    }
    /// <p>(Streams only) If the function returns an error, split the batch in two and retry. The default value is false.</p>
    pub fn bisect_batch_on_function_error(&self) -> std::option::Option<bool> {
        self.bisect_batch_on_function_error
    }
    /// <p>(Streams only) Discard records after the specified number of retries. The default value is -1, which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, Lambda retries failed records until the record expires in the event source.</p>
    pub fn maximum_retry_attempts(&self) -> std::option::Option<i32> {
        self.maximum_retry_attempts
    }
    /// <p>(Streams only) The duration in seconds of a processing window. The range is 1–900 seconds.</p>
    pub fn tumbling_window_in_seconds(&self) -> std::option::Option<i32> {
        self.tumbling_window_in_seconds
    }
    /// <p>(Streams and Amazon SQS) A list of current response type enums applied to the event source mapping.</p>
    pub fn function_response_types(
        &self,
    ) -> std::option::Option<&[crate::model::FunctionResponseType]> {
        self.function_response_types.as_deref()
    }
    /// <p>Specific configuration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) event source.</p>
    pub fn amazon_managed_kafka_event_source_config(
        &self,
    ) -> std::option::Option<&crate::model::AmazonManagedKafkaEventSourceConfig> {
        self.amazon_managed_kafka_event_source_config.as_ref()
    }
    /// <p>Specific configuration settings for a self-managed Apache Kafka event source.</p>
    pub fn self_managed_kafka_event_source_config(
        &self,
    ) -> std::option::Option<&crate::model::SelfManagedKafkaEventSourceConfig> {
        self.self_managed_kafka_event_source_config.as_ref()
    }
    /// <p>(Amazon SQS only) The scaling configuration for the event source. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency">Configuring maximum concurrency for Amazon SQS event sources</a>.</p>
    pub fn scaling_config(&self) -> std::option::Option<&crate::model::ScalingConfig> {
        self.scaling_config.as_ref()
    }
}
/// See [`EventSourceMappingConfiguration`](crate::model::EventSourceMappingConfiguration).
pub mod event_source_mapping_configuration {

    /// A builder for [`EventSourceMappingConfiguration`](crate::model::EventSourceMappingConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) uuid: std::option::Option<std::string::String>,
        pub(crate) starting_position: std::option::Option<crate::model::EventSourcePosition>,
        pub(crate) starting_position_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) batch_size: std::option::Option<i32>,
        pub(crate) maximum_batching_window_in_seconds: std::option::Option<i32>,
        pub(crate) parallelization_factor: std::option::Option<i32>,
        pub(crate) event_source_arn: std::option::Option<std::string::String>,
        pub(crate) filter_criteria: std::option::Option<crate::model::FilterCriteria>,
        pub(crate) function_arn: std::option::Option<std::string::String>,
        pub(crate) last_modified: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_processing_result: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<std::string::String>,
        pub(crate) state_transition_reason: std::option::Option<std::string::String>,
        pub(crate) destination_config: std::option::Option<crate::model::DestinationConfig>,
        pub(crate) topics: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) queues: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) source_access_configurations:
            std::option::Option<std::vec::Vec<crate::model::SourceAccessConfiguration>>,
        pub(crate) self_managed_event_source:
            std::option::Option<crate::model::SelfManagedEventSource>,
        pub(crate) maximum_record_age_in_seconds: std::option::Option<i32>,
        pub(crate) bisect_batch_on_function_error: std::option::Option<bool>,
        pub(crate) maximum_retry_attempts: std::option::Option<i32>,
        pub(crate) tumbling_window_in_seconds: std::option::Option<i32>,
        pub(crate) function_response_types:
            std::option::Option<std::vec::Vec<crate::model::FunctionResponseType>>,
        pub(crate) amazon_managed_kafka_event_source_config:
            std::option::Option<crate::model::AmazonManagedKafkaEventSourceConfig>,
        pub(crate) self_managed_kafka_event_source_config:
            std::option::Option<crate::model::SelfManagedKafkaEventSourceConfig>,
        pub(crate) scaling_config: std::option::Option<crate::model::ScalingConfig>,
    }
    impl Builder {
        /// <p>The identifier of the event source mapping.</p>
        pub fn uuid(mut self, input: impl Into<std::string::String>) -> Self {
            self.uuid = Some(input.into());
            self
        }
        /// <p>The identifier of the event source mapping.</p>
        pub fn set_uuid(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.uuid = input;
            self
        }
        /// <p>The position in a stream from which to start reading. Required for Amazon Kinesis, Amazon DynamoDB, and Amazon MSK stream sources. <code>AT_TIMESTAMP</code> is supported only for Amazon Kinesis streams.</p>
        pub fn starting_position(mut self, input: crate::model::EventSourcePosition) -> Self {
            self.starting_position = Some(input);
            self
        }
        /// <p>The position in a stream from which to start reading. Required for Amazon Kinesis, Amazon DynamoDB, and Amazon MSK stream sources. <code>AT_TIMESTAMP</code> is supported only for Amazon Kinesis streams.</p>
        pub fn set_starting_position(
            mut self,
            input: std::option::Option<crate::model::EventSourcePosition>,
        ) -> Self {
            self.starting_position = input;
            self
        }
        /// <p>With <code>StartingPosition</code> set to <code>AT_TIMESTAMP</code>, the time from which to start reading.</p>
        pub fn starting_position_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.starting_position_timestamp = Some(input);
            self
        }
        /// <p>With <code>StartingPosition</code> set to <code>AT_TIMESTAMP</code>, the time from which to start reading.</p>
        pub fn set_starting_position_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.starting_position_timestamp = input;
            self
        }
        /// <p>The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB).</p>
        /// <p>Default value: Varies by service. For Amazon SQS, the default is 10. For all other services, the default is 100.</p>
        /// <p>Related setting: When you set <code>BatchSize</code> to a value greater than 10, you must set <code>MaximumBatchingWindowInSeconds</code> to at least 1.</p>
        pub fn batch_size(mut self, input: i32) -> Self {
            self.batch_size = Some(input);
            self
        }
        /// <p>The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB).</p>
        /// <p>Default value: Varies by service. For Amazon SQS, the default is 10. For all other services, the default is 100.</p>
        /// <p>Related setting: When you set <code>BatchSize</code> to a value greater than 10, you must set <code>MaximumBatchingWindowInSeconds</code> to at least 1.</p>
        pub fn set_batch_size(mut self, input: std::option::Option<i32>) -> Self {
            self.batch_size = input;
            self
        }
        /// <p>The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. You can configure <code>MaximumBatchingWindowInSeconds</code> to any value from 0 seconds to 300 seconds in increments of seconds.</p>
        /// <p>For streams and Amazon SQS event sources, the default batching window is 0 seconds. For Amazon MSK, Self-managed Apache Kafka, and Amazon MQ event sources, the default batching window is 500 ms. Note that because you can only change <code>MaximumBatchingWindowInSeconds</code> in increments of seconds, you cannot revert back to the 500 ms default batching window after you have changed it. To restore the default batching window, you must create a new event source mapping.</p>
        /// <p>Related setting: For streams and Amazon SQS event sources, when you set <code>BatchSize</code> to a value greater than 10, you must set <code>MaximumBatchingWindowInSeconds</code> to at least 1.</p>
        pub fn maximum_batching_window_in_seconds(mut self, input: i32) -> Self {
            self.maximum_batching_window_in_seconds = Some(input);
            self
        }
        /// <p>The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. You can configure <code>MaximumBatchingWindowInSeconds</code> to any value from 0 seconds to 300 seconds in increments of seconds.</p>
        /// <p>For streams and Amazon SQS event sources, the default batching window is 0 seconds. For Amazon MSK, Self-managed Apache Kafka, and Amazon MQ event sources, the default batching window is 500 ms. Note that because you can only change <code>MaximumBatchingWindowInSeconds</code> in increments of seconds, you cannot revert back to the 500 ms default batching window after you have changed it. To restore the default batching window, you must create a new event source mapping.</p>
        /// <p>Related setting: For streams and Amazon SQS event sources, when you set <code>BatchSize</code> to a value greater than 10, you must set <code>MaximumBatchingWindowInSeconds</code> to at least 1.</p>
        pub fn set_maximum_batching_window_in_seconds(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.maximum_batching_window_in_seconds = input;
            self
        }
        /// <p>(Streams only) The number of batches to process concurrently from each shard. The default value is 1.</p>
        pub fn parallelization_factor(mut self, input: i32) -> Self {
            self.parallelization_factor = Some(input);
            self
        }
        /// <p>(Streams only) The number of batches to process concurrently from each shard. The default value is 1.</p>
        pub fn set_parallelization_factor(mut self, input: std::option::Option<i32>) -> Self {
            self.parallelization_factor = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the event source.</p>
        pub fn event_source_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_source_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the event source.</p>
        pub fn set_event_source_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.event_source_arn = input;
            self
        }
        /// <p>An object that defines the filter criteria that determine whether Lambda should process an event. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html">Lambda event filtering</a>.</p>
        pub fn filter_criteria(mut self, input: crate::model::FilterCriteria) -> Self {
            self.filter_criteria = Some(input);
            self
        }
        /// <p>An object that defines the filter criteria that determine whether Lambda should process an event. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html">Lambda event filtering</a>.</p>
        pub fn set_filter_criteria(
            mut self,
            input: std::option::Option<crate::model::FilterCriteria>,
        ) -> Self {
            self.filter_criteria = input;
            self
        }
        /// <p>The ARN of the Lambda function.</p>
        pub fn function_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.function_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the Lambda function.</p>
        pub fn set_function_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.function_arn = input;
            self
        }
        /// <p>The date that the event source mapping was last updated or that its state changed.</p>
        pub fn last_modified(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified = Some(input);
            self
        }
        /// <p>The date that the event source mapping was last updated or that its state changed.</p>
        pub fn set_last_modified(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified = input;
            self
        }
        /// <p>The result of the last Lambda invocation of your function.</p>
        pub fn last_processing_result(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_processing_result = Some(input.into());
            self
        }
        /// <p>The result of the last Lambda invocation of your function.</p>
        pub fn set_last_processing_result(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_processing_result = input;
            self
        }
        /// <p>The state of the event source mapping. It can be one of the following: <code>Creating</code>, <code>Enabling</code>, <code>Enabled</code>, <code>Disabling</code>, <code>Disabled</code>, <code>Updating</code>, or <code>Deleting</code>.</p>
        pub fn state(mut self, input: impl Into<std::string::String>) -> Self {
            self.state = Some(input.into());
            self
        }
        /// <p>The state of the event source mapping. It can be one of the following: <code>Creating</code>, <code>Enabling</code>, <code>Enabled</code>, <code>Disabling</code>, <code>Disabled</code>, <code>Updating</code>, or <code>Deleting</code>.</p>
        pub fn set_state(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.state = input;
            self
        }
        /// <p>Indicates whether a user or Lambda made the last change to the event source mapping.</p>
        pub fn state_transition_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.state_transition_reason = Some(input.into());
            self
        }
        /// <p>Indicates whether a user or Lambda made the last change to the event source mapping.</p>
        pub fn set_state_transition_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.state_transition_reason = input;
            self
        }
        /// <p>(Streams only) An Amazon SQS queue or Amazon SNS topic destination for discarded records.</p>
        pub fn destination_config(mut self, input: crate::model::DestinationConfig) -> Self {
            self.destination_config = Some(input);
            self
        }
        /// <p>(Streams only) An Amazon SQS queue or Amazon SNS topic destination for discarded records.</p>
        pub fn set_destination_config(
            mut self,
            input: std::option::Option<crate::model::DestinationConfig>,
        ) -> Self {
            self.destination_config = input;
            self
        }
        /// Appends an item to `topics`.
        ///
        /// To override the contents of this collection use [`set_topics`](Self::set_topics).
        ///
        /// <p>The name of the Kafka topic.</p>
        pub fn topics(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.topics.unwrap_or_default();
            v.push(input.into());
            self.topics = Some(v);
            self
        }
        /// <p>The name of the Kafka topic.</p>
        pub fn set_topics(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.topics = input;
            self
        }
        /// Appends an item to `queues`.
        ///
        /// To override the contents of this collection use [`set_queues`](Self::set_queues).
        ///
        /// <p> (Amazon MQ) The name of the Amazon MQ broker destination queue to consume.</p>
        pub fn queues(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.queues.unwrap_or_default();
            v.push(input.into());
            self.queues = Some(v);
            self
        }
        /// <p> (Amazon MQ) The name of the Amazon MQ broker destination queue to consume.</p>
        pub fn set_queues(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.queues = input;
            self
        }
        /// Appends an item to `source_access_configurations`.
        ///
        /// To override the contents of this collection use [`set_source_access_configurations`](Self::set_source_access_configurations).
        ///
        /// <p>An array of the authentication protocol, VPC components, or virtual host to secure and define your event source.</p>
        pub fn source_access_configurations(
            mut self,
            input: crate::model::SourceAccessConfiguration,
        ) -> Self {
            let mut v = self.source_access_configurations.unwrap_or_default();
            v.push(input);
            self.source_access_configurations = Some(v);
            self
        }
        /// <p>An array of the authentication protocol, VPC components, or virtual host to secure and define your event source.</p>
        pub fn set_source_access_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SourceAccessConfiguration>>,
        ) -> Self {
            self.source_access_configurations = input;
            self
        }
        /// <p>The self-managed Apache Kafka cluster for your event source.</p>
        pub fn self_managed_event_source(
            mut self,
            input: crate::model::SelfManagedEventSource,
        ) -> Self {
            self.self_managed_event_source = Some(input);
            self
        }
        /// <p>The self-managed Apache Kafka cluster for your event source.</p>
        pub fn set_self_managed_event_source(
            mut self,
            input: std::option::Option<crate::model::SelfManagedEventSource>,
        ) -> Self {
            self.self_managed_event_source = input;
            self
        }
        /// <p>(Streams only) Discard records older than the specified age. The default value is -1, which sets the maximum age to infinite. When the value is set to infinite, Lambda never discards old records. </p>
        pub fn maximum_record_age_in_seconds(mut self, input: i32) -> Self {
            self.maximum_record_age_in_seconds = Some(input);
            self
        }
        /// <p>(Streams only) Discard records older than the specified age. The default value is -1, which sets the maximum age to infinite. When the value is set to infinite, Lambda never discards old records. </p>
        pub fn set_maximum_record_age_in_seconds(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.maximum_record_age_in_seconds = input;
            self
        }
        /// <p>(Streams only) If the function returns an error, split the batch in two and retry. The default value is false.</p>
        pub fn bisect_batch_on_function_error(mut self, input: bool) -> Self {
            self.bisect_batch_on_function_error = Some(input);
            self
        }
        /// <p>(Streams only) If the function returns an error, split the batch in two and retry. The default value is false.</p>
        pub fn set_bisect_batch_on_function_error(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.bisect_batch_on_function_error = input;
            self
        }
        /// <p>(Streams only) Discard records after the specified number of retries. The default value is -1, which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, Lambda retries failed records until the record expires in the event source.</p>
        pub fn maximum_retry_attempts(mut self, input: i32) -> Self {
            self.maximum_retry_attempts = Some(input);
            self
        }
        /// <p>(Streams only) Discard records after the specified number of retries. The default value is -1, which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, Lambda retries failed records until the record expires in the event source.</p>
        pub fn set_maximum_retry_attempts(mut self, input: std::option::Option<i32>) -> Self {
            self.maximum_retry_attempts = input;
            self
        }
        /// <p>(Streams only) The duration in seconds of a processing window. The range is 1–900 seconds.</p>
        pub fn tumbling_window_in_seconds(mut self, input: i32) -> Self {
            self.tumbling_window_in_seconds = Some(input);
            self
        }
        /// <p>(Streams only) The duration in seconds of a processing window. The range is 1–900 seconds.</p>
        pub fn set_tumbling_window_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.tumbling_window_in_seconds = input;
            self
        }
        /// Appends an item to `function_response_types`.
        ///
        /// To override the contents of this collection use [`set_function_response_types`](Self::set_function_response_types).
        ///
        /// <p>(Streams and Amazon SQS) A list of current response type enums applied to the event source mapping.</p>
        pub fn function_response_types(
            mut self,
            input: crate::model::FunctionResponseType,
        ) -> Self {
            let mut v = self.function_response_types.unwrap_or_default();
            v.push(input);
            self.function_response_types = Some(v);
            self
        }
        /// <p>(Streams and Amazon SQS) A list of current response type enums applied to the event source mapping.</p>
        pub fn set_function_response_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FunctionResponseType>>,
        ) -> Self {
            self.function_response_types = input;
            self
        }
        /// <p>Specific configuration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) event source.</p>
        pub fn amazon_managed_kafka_event_source_config(
            mut self,
            input: crate::model::AmazonManagedKafkaEventSourceConfig,
        ) -> Self {
            self.amazon_managed_kafka_event_source_config = Some(input);
            self
        }
        /// <p>Specific configuration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) event source.</p>
        pub fn set_amazon_managed_kafka_event_source_config(
            mut self,
            input: std::option::Option<crate::model::AmazonManagedKafkaEventSourceConfig>,
        ) -> Self {
            self.amazon_managed_kafka_event_source_config = input;
            self
        }
        /// <p>Specific configuration settings for a self-managed Apache Kafka event source.</p>
        pub fn self_managed_kafka_event_source_config(
            mut self,
            input: crate::model::SelfManagedKafkaEventSourceConfig,
        ) -> Self {
            self.self_managed_kafka_event_source_config = Some(input);
            self
        }
        /// <p>Specific configuration settings for a self-managed Apache Kafka event source.</p>
        pub fn set_self_managed_kafka_event_source_config(
            mut self,
            input: std::option::Option<crate::model::SelfManagedKafkaEventSourceConfig>,
        ) -> Self {
            self.self_managed_kafka_event_source_config = input;
            self
        }
        /// <p>(Amazon SQS only) The scaling configuration for the event source. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency">Configuring maximum concurrency for Amazon SQS event sources</a>.</p>
        pub fn scaling_config(mut self, input: crate::model::ScalingConfig) -> Self {
            self.scaling_config = Some(input);
            self
        }
        /// <p>(Amazon SQS only) The scaling configuration for the event source. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency">Configuring maximum concurrency for Amazon SQS event sources</a>.</p>
        pub fn set_scaling_config(
            mut self,
            input: std::option::Option<crate::model::ScalingConfig>,
        ) -> Self {
            self.scaling_config = input;
            self
        }
        /// Consumes the builder and constructs a [`EventSourceMappingConfiguration`](crate::model::EventSourceMappingConfiguration).
        pub fn build(self) -> crate::model::EventSourceMappingConfiguration {
            crate::model::EventSourceMappingConfiguration {
                uuid: self.uuid,
                starting_position: self.starting_position,
                starting_position_timestamp: self.starting_position_timestamp,
                batch_size: self.batch_size,
                maximum_batching_window_in_seconds: self.maximum_batching_window_in_seconds,
                parallelization_factor: self.parallelization_factor,
                event_source_arn: self.event_source_arn,
                filter_criteria: self.filter_criteria,
                function_arn: self.function_arn,
                last_modified: self.last_modified,
                last_processing_result: self.last_processing_result,
                state: self.state,
                state_transition_reason: self.state_transition_reason,
                destination_config: self.destination_config,
                topics: self.topics,
                queues: self.queues,
                source_access_configurations: self.source_access_configurations,
                self_managed_event_source: self.self_managed_event_source,
                maximum_record_age_in_seconds: self.maximum_record_age_in_seconds,
                bisect_batch_on_function_error: self.bisect_batch_on_function_error,
                maximum_retry_attempts: self.maximum_retry_attempts,
                tumbling_window_in_seconds: self.tumbling_window_in_seconds,
                function_response_types: self.function_response_types,
                amazon_managed_kafka_event_source_config: self
                    .amazon_managed_kafka_event_source_config,
                self_managed_kafka_event_source_config: self.self_managed_kafka_event_source_config,
                scaling_config: self.scaling_config,
            }
        }
    }
}
impl EventSourceMappingConfiguration {
    /// Creates a new builder-style object to manufacture [`EventSourceMappingConfiguration`](crate::model::EventSourceMappingConfiguration).
    pub fn builder() -> crate::model::event_source_mapping_configuration::Builder {
        crate::model::event_source_mapping_configuration::Builder::default()
    }
}

/// <p>Provides configuration information about a Lambda function <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html">alias</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AliasConfiguration {
    /// <p>The Amazon Resource Name (ARN) of the alias.</p>
    #[doc(hidden)]
    pub alias_arn: std::option::Option<std::string::String>,
    /// <p>The name of the alias.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The function version that the alias invokes.</p>
    #[doc(hidden)]
    pub function_version: std::option::Option<std::string::String>,
    /// <p>A description of the alias.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html">routing configuration</a> of the alias.</p>
    #[doc(hidden)]
    pub routing_config: std::option::Option<crate::model::AliasRoutingConfiguration>,
    /// <p>A unique identifier that changes when you update the alias.</p>
    #[doc(hidden)]
    pub revision_id: std::option::Option<std::string::String>,
}
impl AliasConfiguration {
    /// <p>The Amazon Resource Name (ARN) of the alias.</p>
    pub fn alias_arn(&self) -> std::option::Option<&str> {
        self.alias_arn.as_deref()
    }
    /// <p>The name of the alias.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The function version that the alias invokes.</p>
    pub fn function_version(&self) -> std::option::Option<&str> {
        self.function_version.as_deref()
    }
    /// <p>A description of the alias.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html">routing configuration</a> of the alias.</p>
    pub fn routing_config(&self) -> std::option::Option<&crate::model::AliasRoutingConfiguration> {
        self.routing_config.as_ref()
    }
    /// <p>A unique identifier that changes when you update the alias.</p>
    pub fn revision_id(&self) -> std::option::Option<&str> {
        self.revision_id.as_deref()
    }
}
/// See [`AliasConfiguration`](crate::model::AliasConfiguration).
pub mod alias_configuration {

    /// A builder for [`AliasConfiguration`](crate::model::AliasConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) alias_arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) function_version: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) routing_config: std::option::Option<crate::model::AliasRoutingConfiguration>,
        pub(crate) revision_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the alias.</p>
        pub fn alias_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.alias_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the alias.</p>
        pub fn set_alias_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alias_arn = input;
            self
        }
        /// <p>The name of the alias.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the alias.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The function version that the alias invokes.</p>
        pub fn function_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.function_version = Some(input.into());
            self
        }
        /// <p>The function version that the alias invokes.</p>
        pub fn set_function_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.function_version = input;
            self
        }
        /// <p>A description of the alias.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the alias.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html">routing configuration</a> of the alias.</p>
        pub fn routing_config(mut self, input: crate::model::AliasRoutingConfiguration) -> Self {
            self.routing_config = Some(input);
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html">routing configuration</a> of the alias.</p>
        pub fn set_routing_config(
            mut self,
            input: std::option::Option<crate::model::AliasRoutingConfiguration>,
        ) -> Self {
            self.routing_config = input;
            self
        }
        /// <p>A unique identifier that changes when you update the alias.</p>
        pub fn revision_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.revision_id = Some(input.into());
            self
        }
        /// <p>A unique identifier that changes when you update the alias.</p>
        pub fn set_revision_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.revision_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AliasConfiguration`](crate::model::AliasConfiguration).
        pub fn build(self) -> crate::model::AliasConfiguration {
            crate::model::AliasConfiguration {
                alias_arn: self.alias_arn,
                name: self.name,
                function_version: self.function_version,
                description: self.description,
                routing_config: self.routing_config,
                revision_id: self.revision_id,
            }
        }
    }
}
impl AliasConfiguration {
    /// Creates a new builder-style object to manufacture [`AliasConfiguration`](crate::model::AliasConfiguration).
    pub fn builder() -> crate::model::alias_configuration::Builder {
        crate::model::alias_configuration::Builder::default()
    }
}

/// When writing a match expression against `LogType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let logtype = unimplemented!();
/// match logtype {
///     LogType::None => { /* ... */ },
///     LogType::Tail => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `logtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LogType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LogType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LogType::NewFeature` is defined.
/// Specifically, when `logtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LogType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LogType {
    #[allow(missing_docs)] // documentation missing in model
    None,
    #[allow(missing_docs)] // documentation missing in model
    Tail,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LogType {
    fn from(s: &str) -> Self {
        match s {
            "None" => LogType::None,
            "Tail" => LogType::Tail,
            other => LogType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for LogType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LogType::from(s))
    }
}
impl LogType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LogType::None => "None",
            LogType::Tail => "Tail",
            LogType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["None", "Tail"]
    }
}
impl AsRef<str> for LogType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `InvocationType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let invocationtype = unimplemented!();
/// match invocationtype {
///     InvocationType::DryRun => { /* ... */ },
///     InvocationType::Event => { /* ... */ },
///     InvocationType::RequestResponse => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `invocationtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `InvocationType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `InvocationType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `InvocationType::NewFeature` is defined.
/// Specifically, when `invocationtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `InvocationType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InvocationType {
    #[allow(missing_docs)] // documentation missing in model
    DryRun,
    #[allow(missing_docs)] // documentation missing in model
    Event,
    #[allow(missing_docs)] // documentation missing in model
    RequestResponse,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for InvocationType {
    fn from(s: &str) -> Self {
        match s {
            "DryRun" => InvocationType::DryRun,
            "Event" => InvocationType::Event,
            "RequestResponse" => InvocationType::RequestResponse,
            other => InvocationType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for InvocationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InvocationType::from(s))
    }
}
impl InvocationType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            InvocationType::DryRun => "DryRun",
            InvocationType::Event => "Event",
            InvocationType::RequestResponse => "RequestResponse",
            InvocationType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DryRun", "Event", "RequestResponse"]
    }
}
impl AsRef<str> for InvocationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Concurrency {
    /// <p>The number of concurrent executions that are reserved for this function. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-concurrency.html">Managing Lambda reserved concurrency</a>.</p>
    #[doc(hidden)]
    pub reserved_concurrent_executions: std::option::Option<i32>,
}
impl Concurrency {
    /// <p>The number of concurrent executions that are reserved for this function. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-concurrency.html">Managing Lambda reserved concurrency</a>.</p>
    pub fn reserved_concurrent_executions(&self) -> std::option::Option<i32> {
        self.reserved_concurrent_executions
    }
}
/// See [`Concurrency`](crate::model::Concurrency).
pub mod concurrency {

    /// A builder for [`Concurrency`](crate::model::Concurrency).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) reserved_concurrent_executions: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The number of concurrent executions that are reserved for this function. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-concurrency.html">Managing Lambda reserved concurrency</a>.</p>
        pub fn reserved_concurrent_executions(mut self, input: i32) -> Self {
            self.reserved_concurrent_executions = Some(input);
            self
        }
        /// <p>The number of concurrent executions that are reserved for this function. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-concurrency.html">Managing Lambda reserved concurrency</a>.</p>
        pub fn set_reserved_concurrent_executions(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.reserved_concurrent_executions = input;
            self
        }
        /// Consumes the builder and constructs a [`Concurrency`](crate::model::Concurrency).
        pub fn build(self) -> crate::model::Concurrency {
            crate::model::Concurrency {
                reserved_concurrent_executions: self.reserved_concurrent_executions,
            }
        }
    }
}
impl Concurrency {
    /// Creates a new builder-style object to manufacture [`Concurrency`](crate::model::Concurrency).
    pub fn builder() -> crate::model::concurrency::Builder {
        crate::model::concurrency::Builder::default()
    }
}

/// <p>Details about a function's deployment package.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FunctionCodeLocation {
    /// <p>The service that's hosting the file.</p>
    #[doc(hidden)]
    pub repository_type: std::option::Option<std::string::String>,
    /// <p>A presigned URL that you can use to download the deployment package.</p>
    #[doc(hidden)]
    pub location: std::option::Option<std::string::String>,
    /// <p>URI of a container image in the Amazon ECR registry.</p>
    #[doc(hidden)]
    pub image_uri: std::option::Option<std::string::String>,
    /// <p>The resolved URI for the image.</p>
    #[doc(hidden)]
    pub resolved_image_uri: std::option::Option<std::string::String>,
}
impl FunctionCodeLocation {
    /// <p>The service that's hosting the file.</p>
    pub fn repository_type(&self) -> std::option::Option<&str> {
        self.repository_type.as_deref()
    }
    /// <p>A presigned URL that you can use to download the deployment package.</p>
    pub fn location(&self) -> std::option::Option<&str> {
        self.location.as_deref()
    }
    /// <p>URI of a container image in the Amazon ECR registry.</p>
    pub fn image_uri(&self) -> std::option::Option<&str> {
        self.image_uri.as_deref()
    }
    /// <p>The resolved URI for the image.</p>
    pub fn resolved_image_uri(&self) -> std::option::Option<&str> {
        self.resolved_image_uri.as_deref()
    }
}
/// See [`FunctionCodeLocation`](crate::model::FunctionCodeLocation).
pub mod function_code_location {

    /// A builder for [`FunctionCodeLocation`](crate::model::FunctionCodeLocation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) repository_type: std::option::Option<std::string::String>,
        pub(crate) location: std::option::Option<std::string::String>,
        pub(crate) image_uri: std::option::Option<std::string::String>,
        pub(crate) resolved_image_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The service that's hosting the file.</p>
        pub fn repository_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository_type = Some(input.into());
            self
        }
        /// <p>The service that's hosting the file.</p>
        pub fn set_repository_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.repository_type = input;
            self
        }
        /// <p>A presigned URL that you can use to download the deployment package.</p>
        pub fn location(mut self, input: impl Into<std::string::String>) -> Self {
            self.location = Some(input.into());
            self
        }
        /// <p>A presigned URL that you can use to download the deployment package.</p>
        pub fn set_location(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.location = input;
            self
        }
        /// <p>URI of a container image in the Amazon ECR registry.</p>
        pub fn image_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_uri = Some(input.into());
            self
        }
        /// <p>URI of a container image in the Amazon ECR registry.</p>
        pub fn set_image_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_uri = input;
            self
        }
        /// <p>The resolved URI for the image.</p>
        pub fn resolved_image_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.resolved_image_uri = Some(input.into());
            self
        }
        /// <p>The resolved URI for the image.</p>
        pub fn set_resolved_image_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resolved_image_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`FunctionCodeLocation`](crate::model::FunctionCodeLocation).
        pub fn build(self) -> crate::model::FunctionCodeLocation {
            crate::model::FunctionCodeLocation {
                repository_type: self.repository_type,
                location: self.location,
                image_uri: self.image_uri,
                resolved_image_uri: self.resolved_image_uri,
            }
        }
    }
}
impl FunctionCodeLocation {
    /// Creates a new builder-style object to manufacture [`FunctionCodeLocation`](crate::model::FunctionCodeLocation).
    pub fn builder() -> crate::model::function_code_location::Builder {
        crate::model::function_code_location::Builder::default()
    }
}

/// <p>The number of functions and amount of storage in use.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AccountUsage {
    /// <p>The amount of storage space, in bytes, that's being used by deployment packages and layer archives.</p>
    #[doc(hidden)]
    pub total_code_size: i64,
    /// <p>The number of Lambda functions.</p>
    #[doc(hidden)]
    pub function_count: i64,
}
impl AccountUsage {
    /// <p>The amount of storage space, in bytes, that's being used by deployment packages and layer archives.</p>
    pub fn total_code_size(&self) -> i64 {
        self.total_code_size
    }
    /// <p>The number of Lambda functions.</p>
    pub fn function_count(&self) -> i64 {
        self.function_count
    }
}
/// See [`AccountUsage`](crate::model::AccountUsage).
pub mod account_usage {

    /// A builder for [`AccountUsage`](crate::model::AccountUsage).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) total_code_size: std::option::Option<i64>,
        pub(crate) function_count: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The amount of storage space, in bytes, that's being used by deployment packages and layer archives.</p>
        pub fn total_code_size(mut self, input: i64) -> Self {
            self.total_code_size = Some(input);
            self
        }
        /// <p>The amount of storage space, in bytes, that's being used by deployment packages and layer archives.</p>
        pub fn set_total_code_size(mut self, input: std::option::Option<i64>) -> Self {
            self.total_code_size = input;
            self
        }
        /// <p>The number of Lambda functions.</p>
        pub fn function_count(mut self, input: i64) -> Self {
            self.function_count = Some(input);
            self
        }
        /// <p>The number of Lambda functions.</p>
        pub fn set_function_count(mut self, input: std::option::Option<i64>) -> Self {
            self.function_count = input;
            self
        }
        /// Consumes the builder and constructs a [`AccountUsage`](crate::model::AccountUsage).
        pub fn build(self) -> crate::model::AccountUsage {
            crate::model::AccountUsage {
                total_code_size: self.total_code_size.unwrap_or_default(),
                function_count: self.function_count.unwrap_or_default(),
            }
        }
    }
}
impl AccountUsage {
    /// Creates a new builder-style object to manufacture [`AccountUsage`](crate::model::AccountUsage).
    pub fn builder() -> crate::model::account_usage::Builder {
        crate::model::account_usage::Builder::default()
    }
}

/// <p>Limits that are related to concurrency and storage. All file and storage sizes are in bytes.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AccountLimit {
    /// <p>The amount of storage space that you can use for all deployment packages and layer archives.</p>
    #[doc(hidden)]
    pub total_code_size: i64,
    /// <p>The maximum size of a function's deployment package and layers when they're extracted.</p>
    #[doc(hidden)]
    pub code_size_unzipped: i64,
    /// <p>The maximum size of a deployment package when it's uploaded directly to Lambda. Use Amazon S3 for larger files.</p>
    #[doc(hidden)]
    pub code_size_zipped: i64,
    /// <p>The maximum number of simultaneous function executions.</p>
    #[doc(hidden)]
    pub concurrent_executions: i32,
    /// <p>The maximum number of simultaneous function executions, minus the capacity that's reserved for individual functions with <code>PutFunctionConcurrency</code>.</p>
    #[doc(hidden)]
    pub unreserved_concurrent_executions: std::option::Option<i32>,
}
impl AccountLimit {
    /// <p>The amount of storage space that you can use for all deployment packages and layer archives.</p>
    pub fn total_code_size(&self) -> i64 {
        self.total_code_size
    }
    /// <p>The maximum size of a function's deployment package and layers when they're extracted.</p>
    pub fn code_size_unzipped(&self) -> i64 {
        self.code_size_unzipped
    }
    /// <p>The maximum size of a deployment package when it's uploaded directly to Lambda. Use Amazon S3 for larger files.</p>
    pub fn code_size_zipped(&self) -> i64 {
        self.code_size_zipped
    }
    /// <p>The maximum number of simultaneous function executions.</p>
    pub fn concurrent_executions(&self) -> i32 {
        self.concurrent_executions
    }
    /// <p>The maximum number of simultaneous function executions, minus the capacity that's reserved for individual functions with <code>PutFunctionConcurrency</code>.</p>
    pub fn unreserved_concurrent_executions(&self) -> std::option::Option<i32> {
        self.unreserved_concurrent_executions
    }
}
/// See [`AccountLimit`](crate::model::AccountLimit).
pub mod account_limit {

    /// A builder for [`AccountLimit`](crate::model::AccountLimit).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) total_code_size: std::option::Option<i64>,
        pub(crate) code_size_unzipped: std::option::Option<i64>,
        pub(crate) code_size_zipped: std::option::Option<i64>,
        pub(crate) concurrent_executions: std::option::Option<i32>,
        pub(crate) unreserved_concurrent_executions: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The amount of storage space that you can use for all deployment packages and layer archives.</p>
        pub fn total_code_size(mut self, input: i64) -> Self {
            self.total_code_size = Some(input);
            self
        }
        /// <p>The amount of storage space that you can use for all deployment packages and layer archives.</p>
        pub fn set_total_code_size(mut self, input: std::option::Option<i64>) -> Self {
            self.total_code_size = input;
            self
        }
        /// <p>The maximum size of a function's deployment package and layers when they're extracted.</p>
        pub fn code_size_unzipped(mut self, input: i64) -> Self {
            self.code_size_unzipped = Some(input);
            self
        }
        /// <p>The maximum size of a function's deployment package and layers when they're extracted.</p>
        pub fn set_code_size_unzipped(mut self, input: std::option::Option<i64>) -> Self {
            self.code_size_unzipped = input;
            self
        }
        /// <p>The maximum size of a deployment package when it's uploaded directly to Lambda. Use Amazon S3 for larger files.</p>
        pub fn code_size_zipped(mut self, input: i64) -> Self {
            self.code_size_zipped = Some(input);
            self
        }
        /// <p>The maximum size of a deployment package when it's uploaded directly to Lambda. Use Amazon S3 for larger files.</p>
        pub fn set_code_size_zipped(mut self, input: std::option::Option<i64>) -> Self {
            self.code_size_zipped = input;
            self
        }
        /// <p>The maximum number of simultaneous function executions.</p>
        pub fn concurrent_executions(mut self, input: i32) -> Self {
            self.concurrent_executions = Some(input);
            self
        }
        /// <p>The maximum number of simultaneous function executions.</p>
        pub fn set_concurrent_executions(mut self, input: std::option::Option<i32>) -> Self {
            self.concurrent_executions = input;
            self
        }
        /// <p>The maximum number of simultaneous function executions, minus the capacity that's reserved for individual functions with <code>PutFunctionConcurrency</code>.</p>
        pub fn unreserved_concurrent_executions(mut self, input: i32) -> Self {
            self.unreserved_concurrent_executions = Some(input);
            self
        }
        /// <p>The maximum number of simultaneous function executions, minus the capacity that's reserved for individual functions with <code>PutFunctionConcurrency</code>.</p>
        pub fn set_unreserved_concurrent_executions(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.unreserved_concurrent_executions = input;
            self
        }
        /// Consumes the builder and constructs a [`AccountLimit`](crate::model::AccountLimit).
        pub fn build(self) -> crate::model::AccountLimit {
            crate::model::AccountLimit {
                total_code_size: self.total_code_size.unwrap_or_default(),
                code_size_unzipped: self.code_size_unzipped.unwrap_or_default(),
                code_size_zipped: self.code_size_zipped.unwrap_or_default(),
                concurrent_executions: self.concurrent_executions.unwrap_or_default(),
                unreserved_concurrent_executions: self.unreserved_concurrent_executions,
            }
        }
    }
}
impl AccountLimit {
    /// Creates a new builder-style object to manufacture [`AccountLimit`](crate::model::AccountLimit).
    pub fn builder() -> crate::model::account_limit::Builder {
        crate::model::account_limit::Builder::default()
    }
}

/// <p>The code for the Lambda function. You can either specify an object in Amazon S3, upload a .zip file archive deployment package directly, or specify the URI of a container image.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FunctionCode {
    /// <p>The base64-encoded contents of the deployment package. Amazon Web Services SDK and CLI clients handle the encoding for you.</p>
    #[doc(hidden)]
    pub zip_file: std::option::Option<aws_smithy_types::Blob>,
    /// <p>An Amazon S3 bucket in the same Amazon Web Services Region as your function. The bucket can be in a different Amazon Web Services account.</p>
    #[doc(hidden)]
    pub s3_bucket: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 key of the deployment package.</p>
    #[doc(hidden)]
    pub s3_key: std::option::Option<std::string::String>,
    /// <p>For versioned objects, the version of the deployment package object to use.</p>
    #[doc(hidden)]
    pub s3_object_version: std::option::Option<std::string::String>,
    /// <p>URI of a <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-images.html">container image</a> in the Amazon ECR registry.</p>
    #[doc(hidden)]
    pub image_uri: std::option::Option<std::string::String>,
}
impl FunctionCode {
    /// <p>The base64-encoded contents of the deployment package. Amazon Web Services SDK and CLI clients handle the encoding for you.</p>
    pub fn zip_file(&self) -> std::option::Option<&aws_smithy_types::Blob> {
        self.zip_file.as_ref()
    }
    /// <p>An Amazon S3 bucket in the same Amazon Web Services Region as your function. The bucket can be in a different Amazon Web Services account.</p>
    pub fn s3_bucket(&self) -> std::option::Option<&str> {
        self.s3_bucket.as_deref()
    }
    /// <p>The Amazon S3 key of the deployment package.</p>
    pub fn s3_key(&self) -> std::option::Option<&str> {
        self.s3_key.as_deref()
    }
    /// <p>For versioned objects, the version of the deployment package object to use.</p>
    pub fn s3_object_version(&self) -> std::option::Option<&str> {
        self.s3_object_version.as_deref()
    }
    /// <p>URI of a <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-images.html">container image</a> in the Amazon ECR registry.</p>
    pub fn image_uri(&self) -> std::option::Option<&str> {
        self.image_uri.as_deref()
    }
}
impl std::fmt::Debug for FunctionCode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FunctionCode");
        formatter.field("zip_file", &"*** Sensitive Data Redacted ***");
        formatter.field("s3_bucket", &self.s3_bucket);
        formatter.field("s3_key", &self.s3_key);
        formatter.field("s3_object_version", &self.s3_object_version);
        formatter.field("image_uri", &self.image_uri);
        formatter.finish()
    }
}
/// See [`FunctionCode`](crate::model::FunctionCode).
pub mod function_code {

    /// A builder for [`FunctionCode`](crate::model::FunctionCode).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) zip_file: std::option::Option<aws_smithy_types::Blob>,
        pub(crate) s3_bucket: std::option::Option<std::string::String>,
        pub(crate) s3_key: std::option::Option<std::string::String>,
        pub(crate) s3_object_version: std::option::Option<std::string::String>,
        pub(crate) image_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The base64-encoded contents of the deployment package. Amazon Web Services SDK and CLI clients handle the encoding for you.</p>
        pub fn zip_file(mut self, input: aws_smithy_types::Blob) -> Self {
            self.zip_file = Some(input);
            self
        }
        /// <p>The base64-encoded contents of the deployment package. Amazon Web Services SDK and CLI clients handle the encoding for you.</p>
        pub fn set_zip_file(mut self, input: std::option::Option<aws_smithy_types::Blob>) -> Self {
            self.zip_file = input;
            self
        }
        /// <p>An Amazon S3 bucket in the same Amazon Web Services Region as your function. The bucket can be in a different Amazon Web Services account.</p>
        pub fn s3_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_bucket = Some(input.into());
            self
        }
        /// <p>An Amazon S3 bucket in the same Amazon Web Services Region as your function. The bucket can be in a different Amazon Web Services account.</p>
        pub fn set_s3_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_bucket = input;
            self
        }
        /// <p>The Amazon S3 key of the deployment package.</p>
        pub fn s3_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_key = Some(input.into());
            self
        }
        /// <p>The Amazon S3 key of the deployment package.</p>
        pub fn set_s3_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_key = input;
            self
        }
        /// <p>For versioned objects, the version of the deployment package object to use.</p>
        pub fn s3_object_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_object_version = Some(input.into());
            self
        }
        /// <p>For versioned objects, the version of the deployment package object to use.</p>
        pub fn set_s3_object_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_object_version = input;
            self
        }
        /// <p>URI of a <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-images.html">container image</a> in the Amazon ECR registry.</p>
        pub fn image_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_uri = Some(input.into());
            self
        }
        /// <p>URI of a <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-images.html">container image</a> in the Amazon ECR registry.</p>
        pub fn set_image_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`FunctionCode`](crate::model::FunctionCode).
        pub fn build(self) -> crate::model::FunctionCode {
            crate::model::FunctionCode {
                zip_file: self.zip_file,
                s3_bucket: self.s3_bucket,
                s3_key: self.s3_key,
                s3_object_version: self.s3_object_version,
                image_uri: self.image_uri,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("zip_file", &"*** Sensitive Data Redacted ***");
            formatter.field("s3_bucket", &self.s3_bucket);
            formatter.field("s3_key", &self.s3_key);
            formatter.field("s3_object_version", &self.s3_object_version);
            formatter.field("image_uri", &self.image_uri);
            formatter.finish()
        }
    }
}
impl FunctionCode {
    /// Creates a new builder-style object to manufacture [`FunctionCode`](crate::model::FunctionCode).
    pub fn builder() -> crate::model::function_code::Builder {
        crate::model::function_code::Builder::default()
    }
}
