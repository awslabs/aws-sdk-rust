// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub fn parse_generic_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<smithy_types::Error, serde_json::Error> {
    let body =
        serde_json::from_slice(response.body().as_ref()).unwrap_or_else(|_| serde_json::json!({}));
    Ok(crate::aws_json_errors::parse_generic_error(
        &response, &body,
    ))
}

pub fn invalid_parameter_value_exception(
    input: &[u8],
    mut builder: crate::error::invalid_parameter_value_error::Builder,
) -> std::result::Result<crate::error::invalid_parameter_value_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::InvalidParameterValueError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn policy_length_exceeded_exception(
    input: &[u8],
    mut builder: crate::error::policy_length_exceeded_error::Builder,
) -> std::result::Result<crate::error::policy_length_exceeded_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::PolicyLengthExceededError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn precondition_failed_exception(
    input: &[u8],
    mut builder: crate::error::precondition_failed_error::Builder,
) -> std::result::Result<crate::error::precondition_failed_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::PreconditionFailedError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn resource_conflict_exception(
    input: &[u8],
    mut builder: crate::error::resource_conflict_error::Builder,
) -> std::result::Result<crate::error::resource_conflict_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::ResourceConflictError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn resource_not_found_exception(
    input: &[u8],
    mut builder: crate::error::resource_not_found_error::Builder,
) -> std::result::Result<crate::error::resource_not_found_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::ResourceNotFoundError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn service_exception(
    input: &[u8],
    mut builder: crate::error::service_error::Builder,
) -> std::result::Result<crate::error::service_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::ServiceError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn too_many_requests_exception(
    input: &[u8],
    mut builder: crate::error::too_many_requests_error::Builder,
) -> std::result::Result<crate::error::too_many_requests_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::TooManyRequestsError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_retry_after_seconds(parsed_body.retry_after_seconds);
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_message(parsed_body.message);
    builder = builder.set_reason(parsed_body.reason);
    Ok(builder)
}

pub fn add_layer_version_permission_deser_operation(
    input: &[u8],
    mut builder: crate::output::add_layer_version_permission_output::Builder,
) -> std::result::Result<
    crate::output::add_layer_version_permission_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::AddLayerVersionPermissionOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_statement(parsed_body.statement);
    builder = builder.set_revision_id(parsed_body.revision_id);
    Ok(builder)
}

pub fn add_permission_deser_operation(
    input: &[u8],
    mut builder: crate::output::add_permission_output::Builder,
) -> std::result::Result<crate::output::add_permission_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::AddPermissionOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_statement(parsed_body.statement);
    Ok(builder)
}

pub fn create_alias_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_alias_output::Builder,
) -> std::result::Result<crate::output::create_alias_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateAliasOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_alias_arn(parsed_body.alias_arn);
    builder = builder.set_name(parsed_body.name);
    builder = builder.set_function_version(parsed_body.function_version);
    builder = builder.set_description(parsed_body.description);
    builder = builder.set_routing_config(parsed_body.routing_config);
    builder = builder.set_revision_id(parsed_body.revision_id);
    Ok(builder)
}

pub fn create_code_signing_config_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_code_signing_config_output::Builder,
) -> std::result::Result<crate::output::create_code_signing_config_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::CreateCodeSigningConfigOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_code_signing_config(parsed_body.code_signing_config);
    Ok(builder)
}

pub fn create_event_source_mapping_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_event_source_mapping_output::Builder,
) -> std::result::Result<
    crate::output::create_event_source_mapping_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::CreateEventSourceMappingOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_uuid(parsed_body.uuid);
    builder = builder.set_starting_position(parsed_body.starting_position);
    builder = builder.set_starting_position_timestamp(parsed_body.starting_position_timestamp);
    builder = builder.set_batch_size(parsed_body.batch_size);
    builder = builder
        .set_maximum_batching_window_in_seconds(parsed_body.maximum_batching_window_in_seconds);
    builder = builder.set_parallelization_factor(parsed_body.parallelization_factor);
    builder = builder.set_event_source_arn(parsed_body.event_source_arn);
    builder = builder.set_function_arn(parsed_body.function_arn);
    builder = builder.set_last_modified(parsed_body.last_modified);
    builder = builder.set_last_processing_result(parsed_body.last_processing_result);
    builder = builder.set_state(parsed_body.state);
    builder = builder.set_state_transition_reason(parsed_body.state_transition_reason);
    builder = builder.set_destination_config(parsed_body.destination_config);
    builder = builder.set_topics(parsed_body.topics);
    builder = builder.set_queues(parsed_body.queues);
    builder = builder.set_source_access_configurations(parsed_body.source_access_configurations);
    builder = builder.set_self_managed_event_source(parsed_body.self_managed_event_source);
    builder = builder.set_maximum_record_age_in_seconds(parsed_body.maximum_record_age_in_seconds);
    builder =
        builder.set_bisect_batch_on_function_error(parsed_body.bisect_batch_on_function_error);
    builder = builder.set_maximum_retry_attempts(parsed_body.maximum_retry_attempts);
    builder = builder.set_tumbling_window_in_seconds(parsed_body.tumbling_window_in_seconds);
    builder = builder.set_function_response_types(parsed_body.function_response_types);
    Ok(builder)
}

pub fn code_signing_config_not_found_exception(
    input: &[u8],
    mut builder: crate::error::code_signing_config_not_found_error::Builder,
) -> std::result::Result<
    crate::error::code_signing_config_not_found_error::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::error::CodeSigningConfigNotFoundError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn code_storage_exceeded_exception(
    input: &[u8],
    mut builder: crate::error::code_storage_exceeded_error::Builder,
) -> std::result::Result<crate::error::code_storage_exceeded_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::CodeStorageExceededError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn code_verification_failed_exception(
    input: &[u8],
    mut builder: crate::error::code_verification_failed_error::Builder,
) -> std::result::Result<crate::error::code_verification_failed_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::CodeVerificationFailedError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn invalid_code_signature_exception(
    input: &[u8],
    mut builder: crate::error::invalid_code_signature_error::Builder,
) -> std::result::Result<crate::error::invalid_code_signature_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::InvalidCodeSignatureError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn create_function_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_function_output::Builder,
) -> std::result::Result<crate::output::create_function_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateFunctionOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_function_name(parsed_body.function_name);
    builder = builder.set_function_arn(parsed_body.function_arn);
    builder = builder.set_runtime(parsed_body.runtime);
    builder = builder.set_role(parsed_body.role);
    builder = builder.set_handler(parsed_body.handler);
    builder = builder.set_code_size(Some(parsed_body.code_size));
    builder = builder.set_description(parsed_body.description);
    builder = builder.set_timeout(parsed_body.timeout);
    builder = builder.set_memory_size(parsed_body.memory_size);
    builder = builder.set_last_modified(parsed_body.last_modified);
    builder = builder.set_code_sha256(parsed_body.code_sha256);
    builder = builder.set_version(parsed_body.version);
    builder = builder.set_vpc_config(parsed_body.vpc_config);
    builder = builder.set_dead_letter_config(parsed_body.dead_letter_config);
    builder = builder.set_environment(parsed_body.environment);
    builder = builder.set_kms_key_arn(parsed_body.kms_key_arn);
    builder = builder.set_tracing_config(parsed_body.tracing_config);
    builder = builder.set_master_arn(parsed_body.master_arn);
    builder = builder.set_revision_id(parsed_body.revision_id);
    builder = builder.set_layers(parsed_body.layers);
    builder = builder.set_state(parsed_body.state);
    builder = builder.set_state_reason(parsed_body.state_reason);
    builder = builder.set_state_reason_code(parsed_body.state_reason_code);
    builder = builder.set_last_update_status(parsed_body.last_update_status);
    builder = builder.set_last_update_status_reason(parsed_body.last_update_status_reason);
    builder =
        builder.set_last_update_status_reason_code(parsed_body.last_update_status_reason_code);
    builder = builder.set_file_system_configs(parsed_body.file_system_configs);
    builder = builder.set_package_type(parsed_body.package_type);
    builder = builder.set_image_config_response(parsed_body.image_config_response);
    builder = builder.set_signing_profile_version_arn(parsed_body.signing_profile_version_arn);
    builder = builder.set_signing_job_arn(parsed_body.signing_job_arn);
    Ok(builder)
}

pub fn resource_in_use_exception(
    input: &[u8],
    mut builder: crate::error::resource_in_use_error::Builder,
) -> std::result::Result<crate::error::resource_in_use_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::ResourceInUseError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn delete_event_source_mapping_deser_operation(
    input: &[u8],
    mut builder: crate::output::delete_event_source_mapping_output::Builder,
) -> std::result::Result<
    crate::output::delete_event_source_mapping_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DeleteEventSourceMappingOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_uuid(parsed_body.uuid);
    builder = builder.set_starting_position(parsed_body.starting_position);
    builder = builder.set_starting_position_timestamp(parsed_body.starting_position_timestamp);
    builder = builder.set_batch_size(parsed_body.batch_size);
    builder = builder
        .set_maximum_batching_window_in_seconds(parsed_body.maximum_batching_window_in_seconds);
    builder = builder.set_parallelization_factor(parsed_body.parallelization_factor);
    builder = builder.set_event_source_arn(parsed_body.event_source_arn);
    builder = builder.set_function_arn(parsed_body.function_arn);
    builder = builder.set_last_modified(parsed_body.last_modified);
    builder = builder.set_last_processing_result(parsed_body.last_processing_result);
    builder = builder.set_state(parsed_body.state);
    builder = builder.set_state_transition_reason(parsed_body.state_transition_reason);
    builder = builder.set_destination_config(parsed_body.destination_config);
    builder = builder.set_topics(parsed_body.topics);
    builder = builder.set_queues(parsed_body.queues);
    builder = builder.set_source_access_configurations(parsed_body.source_access_configurations);
    builder = builder.set_self_managed_event_source(parsed_body.self_managed_event_source);
    builder = builder.set_maximum_record_age_in_seconds(parsed_body.maximum_record_age_in_seconds);
    builder =
        builder.set_bisect_batch_on_function_error(parsed_body.bisect_batch_on_function_error);
    builder = builder.set_maximum_retry_attempts(parsed_body.maximum_retry_attempts);
    builder = builder.set_tumbling_window_in_seconds(parsed_body.tumbling_window_in_seconds);
    builder = builder.set_function_response_types(parsed_body.function_response_types);
    Ok(builder)
}

pub fn get_account_settings_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_account_settings_output::Builder,
) -> std::result::Result<crate::output::get_account_settings_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::GetAccountSettingsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_account_limit(parsed_body.account_limit);
    builder = builder.set_account_usage(parsed_body.account_usage);
    Ok(builder)
}

pub fn get_alias_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_alias_output::Builder,
) -> std::result::Result<crate::output::get_alias_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::GetAliasOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_alias_arn(parsed_body.alias_arn);
    builder = builder.set_name(parsed_body.name);
    builder = builder.set_function_version(parsed_body.function_version);
    builder = builder.set_description(parsed_body.description);
    builder = builder.set_routing_config(parsed_body.routing_config);
    builder = builder.set_revision_id(parsed_body.revision_id);
    Ok(builder)
}

pub fn get_code_signing_config_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_code_signing_config_output::Builder,
) -> std::result::Result<crate::output::get_code_signing_config_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::GetCodeSigningConfigOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_code_signing_config(parsed_body.code_signing_config);
    Ok(builder)
}

pub fn get_event_source_mapping_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_event_source_mapping_output::Builder,
) -> std::result::Result<crate::output::get_event_source_mapping_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::GetEventSourceMappingOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_uuid(parsed_body.uuid);
    builder = builder.set_starting_position(parsed_body.starting_position);
    builder = builder.set_starting_position_timestamp(parsed_body.starting_position_timestamp);
    builder = builder.set_batch_size(parsed_body.batch_size);
    builder = builder
        .set_maximum_batching_window_in_seconds(parsed_body.maximum_batching_window_in_seconds);
    builder = builder.set_parallelization_factor(parsed_body.parallelization_factor);
    builder = builder.set_event_source_arn(parsed_body.event_source_arn);
    builder = builder.set_function_arn(parsed_body.function_arn);
    builder = builder.set_last_modified(parsed_body.last_modified);
    builder = builder.set_last_processing_result(parsed_body.last_processing_result);
    builder = builder.set_state(parsed_body.state);
    builder = builder.set_state_transition_reason(parsed_body.state_transition_reason);
    builder = builder.set_destination_config(parsed_body.destination_config);
    builder = builder.set_topics(parsed_body.topics);
    builder = builder.set_queues(parsed_body.queues);
    builder = builder.set_source_access_configurations(parsed_body.source_access_configurations);
    builder = builder.set_self_managed_event_source(parsed_body.self_managed_event_source);
    builder = builder.set_maximum_record_age_in_seconds(parsed_body.maximum_record_age_in_seconds);
    builder =
        builder.set_bisect_batch_on_function_error(parsed_body.bisect_batch_on_function_error);
    builder = builder.set_maximum_retry_attempts(parsed_body.maximum_retry_attempts);
    builder = builder.set_tumbling_window_in_seconds(parsed_body.tumbling_window_in_seconds);
    builder = builder.set_function_response_types(parsed_body.function_response_types);
    Ok(builder)
}

pub fn get_function_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_function_output::Builder,
) -> std::result::Result<crate::output::get_function_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::GetFunctionOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_configuration(parsed_body.configuration);
    builder = builder.set_code(parsed_body.code);
    builder = builder.set_tags(parsed_body.tags);
    builder = builder.set_concurrency(parsed_body.concurrency);
    Ok(builder)
}

pub fn get_function_code_signing_config_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_function_code_signing_config_output::Builder,
) -> std::result::Result<
    crate::output::get_function_code_signing_config_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::GetFunctionCodeSigningConfigOutputBody = if input.is_empty()
    {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_code_signing_config_arn(parsed_body.code_signing_config_arn);
    builder = builder.set_function_name(parsed_body.function_name);
    Ok(builder)
}

pub fn get_function_concurrency_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_function_concurrency_output::Builder,
) -> std::result::Result<crate::output::get_function_concurrency_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::GetFunctionConcurrencyOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder =
        builder.set_reserved_concurrent_executions(parsed_body.reserved_concurrent_executions);
    Ok(builder)
}

pub fn get_function_configuration_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_function_configuration_output::Builder,
) -> std::result::Result<crate::output::get_function_configuration_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::GetFunctionConfigurationOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_function_name(parsed_body.function_name);
    builder = builder.set_function_arn(parsed_body.function_arn);
    builder = builder.set_runtime(parsed_body.runtime);
    builder = builder.set_role(parsed_body.role);
    builder = builder.set_handler(parsed_body.handler);
    builder = builder.set_code_size(Some(parsed_body.code_size));
    builder = builder.set_description(parsed_body.description);
    builder = builder.set_timeout(parsed_body.timeout);
    builder = builder.set_memory_size(parsed_body.memory_size);
    builder = builder.set_last_modified(parsed_body.last_modified);
    builder = builder.set_code_sha256(parsed_body.code_sha256);
    builder = builder.set_version(parsed_body.version);
    builder = builder.set_vpc_config(parsed_body.vpc_config);
    builder = builder.set_dead_letter_config(parsed_body.dead_letter_config);
    builder = builder.set_environment(parsed_body.environment);
    builder = builder.set_kms_key_arn(parsed_body.kms_key_arn);
    builder = builder.set_tracing_config(parsed_body.tracing_config);
    builder = builder.set_master_arn(parsed_body.master_arn);
    builder = builder.set_revision_id(parsed_body.revision_id);
    builder = builder.set_layers(parsed_body.layers);
    builder = builder.set_state(parsed_body.state);
    builder = builder.set_state_reason(parsed_body.state_reason);
    builder = builder.set_state_reason_code(parsed_body.state_reason_code);
    builder = builder.set_last_update_status(parsed_body.last_update_status);
    builder = builder.set_last_update_status_reason(parsed_body.last_update_status_reason);
    builder =
        builder.set_last_update_status_reason_code(parsed_body.last_update_status_reason_code);
    builder = builder.set_file_system_configs(parsed_body.file_system_configs);
    builder = builder.set_package_type(parsed_body.package_type);
    builder = builder.set_image_config_response(parsed_body.image_config_response);
    builder = builder.set_signing_profile_version_arn(parsed_body.signing_profile_version_arn);
    builder = builder.set_signing_job_arn(parsed_body.signing_job_arn);
    Ok(builder)
}

pub fn get_function_event_invoke_config_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_function_event_invoke_config_output::Builder,
) -> std::result::Result<
    crate::output::get_function_event_invoke_config_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::GetFunctionEventInvokeConfigOutputBody = if input.is_empty()
    {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_last_modified(parsed_body.last_modified);
    builder = builder.set_function_arn(parsed_body.function_arn);
    builder = builder.set_maximum_retry_attempts(parsed_body.maximum_retry_attempts);
    builder = builder.set_maximum_event_age_in_seconds(parsed_body.maximum_event_age_in_seconds);
    builder = builder.set_destination_config(parsed_body.destination_config);
    Ok(builder)
}

pub fn get_layer_version_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_layer_version_output::Builder,
) -> std::result::Result<crate::output::get_layer_version_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::GetLayerVersionOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_content(parsed_body.content);
    builder = builder.set_layer_arn(parsed_body.layer_arn);
    builder = builder.set_layer_version_arn(parsed_body.layer_version_arn);
    builder = builder.set_description(parsed_body.description);
    builder = builder.set_created_date(parsed_body.created_date);
    builder = builder.set_version(Some(parsed_body.version));
    builder = builder.set_compatible_runtimes(parsed_body.compatible_runtimes);
    builder = builder.set_license_info(parsed_body.license_info);
    Ok(builder)
}

pub fn get_layer_version_by_arn_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_layer_version_by_arn_output::Builder,
) -> std::result::Result<crate::output::get_layer_version_by_arn_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::GetLayerVersionByArnOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_content(parsed_body.content);
    builder = builder.set_layer_arn(parsed_body.layer_arn);
    builder = builder.set_layer_version_arn(parsed_body.layer_version_arn);
    builder = builder.set_description(parsed_body.description);
    builder = builder.set_created_date(parsed_body.created_date);
    builder = builder.set_version(Some(parsed_body.version));
    builder = builder.set_compatible_runtimes(parsed_body.compatible_runtimes);
    builder = builder.set_license_info(parsed_body.license_info);
    Ok(builder)
}

pub fn get_layer_version_policy_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_layer_version_policy_output::Builder,
) -> std::result::Result<crate::output::get_layer_version_policy_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::GetLayerVersionPolicyOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_policy(parsed_body.policy);
    builder = builder.set_revision_id(parsed_body.revision_id);
    Ok(builder)
}

pub fn get_policy_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_policy_output::Builder,
) -> std::result::Result<crate::output::get_policy_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::GetPolicyOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_policy(parsed_body.policy);
    builder = builder.set_revision_id(parsed_body.revision_id);
    Ok(builder)
}

pub fn provisioned_concurrency_config_not_found_exception(
    input: &[u8],
    mut builder: crate::error::provisioned_concurrency_config_not_found_error::Builder,
) -> std::result::Result<
    crate::error::provisioned_concurrency_config_not_found_error::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::error::ProvisionedConcurrencyConfigNotFoundError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn get_provisioned_concurrency_config_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_provisioned_concurrency_config_output::Builder,
) -> std::result::Result<
    crate::output::get_provisioned_concurrency_config_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::GetProvisionedConcurrencyConfigOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_requested_provisioned_concurrent_executions(
        parsed_body.requested_provisioned_concurrent_executions,
    );
    builder = builder.set_available_provisioned_concurrent_executions(
        parsed_body.available_provisioned_concurrent_executions,
    );
    builder = builder.set_allocated_provisioned_concurrent_executions(
        parsed_body.allocated_provisioned_concurrent_executions,
    );
    builder = builder.set_status(parsed_body.status);
    builder = builder.set_status_reason(parsed_body.status_reason);
    builder = builder.set_last_modified(parsed_body.last_modified);
    Ok(builder)
}

pub fn ec2_access_denied_exception(
    input: &[u8],
    mut builder: crate::error::ec2_access_denied_error::Builder,
) -> std::result::Result<crate::error::ec2_access_denied_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::EC2AccessDeniedError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn ec2_throttled_exception(
    input: &[u8],
    mut builder: crate::error::ec2_throttled_error::Builder,
) -> std::result::Result<crate::error::ec2_throttled_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::EC2ThrottledError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn ec2_unexpected_exception(
    input: &[u8],
    mut builder: crate::error::ec2_unexpected_error::Builder,
) -> std::result::Result<crate::error::ec2_unexpected_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::EC2UnexpectedError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_message(parsed_body.message);
    builder = builder.set_ec2_error_code(parsed_body.ec2_error_code);
    Ok(builder)
}

pub fn efsio_exception(
    input: &[u8],
    mut builder: crate::error::efsio_error::Builder,
) -> std::result::Result<crate::error::efsio_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::EFSIOError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn efs_mount_connectivity_exception(
    input: &[u8],
    mut builder: crate::error::efs_mount_connectivity_error::Builder,
) -> std::result::Result<crate::error::efs_mount_connectivity_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::EFSMountConnectivityError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn efs_mount_failure_exception(
    input: &[u8],
    mut builder: crate::error::efs_mount_failure_error::Builder,
) -> std::result::Result<crate::error::efs_mount_failure_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::EFSMountFailureError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn efs_mount_timeout_exception(
    input: &[u8],
    mut builder: crate::error::efs_mount_timeout_error::Builder,
) -> std::result::Result<crate::error::efs_mount_timeout_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::EFSMountTimeoutError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn eni_limit_reached_exception(
    input: &[u8],
    mut builder: crate::error::eni_limit_reached_error::Builder,
) -> std::result::Result<crate::error::eni_limit_reached_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::ENILimitReachedError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn invalid_request_content_exception(
    input: &[u8],
    mut builder: crate::error::invalid_request_content_error::Builder,
) -> std::result::Result<crate::error::invalid_request_content_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::InvalidRequestContentError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn invalid_runtime_exception(
    input: &[u8],
    mut builder: crate::error::invalid_runtime_error::Builder,
) -> std::result::Result<crate::error::invalid_runtime_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::InvalidRuntimeError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn invalid_security_group_id_exception(
    input: &[u8],
    mut builder: crate::error::invalid_security_group_id_error::Builder,
) -> std::result::Result<crate::error::invalid_security_group_id_error::Builder, serde_json::Error>
{
    let parsed_body: crate::error::InvalidSecurityGroupIDError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn invalid_subnet_id_exception(
    input: &[u8],
    mut builder: crate::error::invalid_subnet_id_error::Builder,
) -> std::result::Result<crate::error::invalid_subnet_id_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::InvalidSubnetIDError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn invalid_zip_file_exception(
    input: &[u8],
    mut builder: crate::error::invalid_zip_file_error::Builder,
) -> std::result::Result<crate::error::invalid_zip_file_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::InvalidZipFileError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn kms_access_denied_exception(
    input: &[u8],
    mut builder: crate::error::kms_access_denied_error::Builder,
) -> std::result::Result<crate::error::kms_access_denied_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::KMSAccessDeniedError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn kms_disabled_exception(
    input: &[u8],
    mut builder: crate::error::kms_disabled_error::Builder,
) -> std::result::Result<crate::error::kms_disabled_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::KMSDisabledError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn kms_invalid_state_exception(
    input: &[u8],
    mut builder: crate::error::kms_invalid_state_error::Builder,
) -> std::result::Result<crate::error::kms_invalid_state_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::KMSInvalidStateError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn kms_not_found_exception(
    input: &[u8],
    mut builder: crate::error::kms_not_found_error::Builder,
) -> std::result::Result<crate::error::kms_not_found_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::KMSNotFoundError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn request_too_large_exception(
    input: &[u8],
    mut builder: crate::error::request_too_large_error::Builder,
) -> std::result::Result<crate::error::request_too_large_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::RequestTooLargeError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn resource_not_ready_exception(
    input: &[u8],
    mut builder: crate::error::resource_not_ready_error::Builder,
) -> std::result::Result<crate::error::resource_not_ready_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::ResourceNotReadyError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn subnet_ip_address_limit_reached_exception(
    input: &[u8],
    mut builder: crate::error::subnet_ip_address_limit_reached_error::Builder,
) -> std::result::Result<
    crate::error::subnet_ip_address_limit_reached_error::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::error::SubnetIPAddressLimitReachedError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn unsupported_media_type_exception(
    input: &[u8],
    mut builder: crate::error::unsupported_media_type_error::Builder,
) -> std::result::Result<crate::error::unsupported_media_type_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::UnsupportedMediaTypeError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_type(parsed_body.r#type);
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn list_aliases_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_aliases_output::Builder,
) -> std::result::Result<crate::output::list_aliases_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListAliasesOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_next_marker(parsed_body.next_marker);
    builder = builder.set_aliases(parsed_body.aliases);
    Ok(builder)
}

pub fn list_code_signing_configs_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_code_signing_configs_output::Builder,
) -> std::result::Result<crate::output::list_code_signing_configs_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::ListCodeSigningConfigsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_next_marker(parsed_body.next_marker);
    builder = builder.set_code_signing_configs(parsed_body.code_signing_configs);
    Ok(builder)
}

pub fn list_event_source_mappings_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_event_source_mappings_output::Builder,
) -> std::result::Result<crate::output::list_event_source_mappings_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::ListEventSourceMappingsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_next_marker(parsed_body.next_marker);
    builder = builder.set_event_source_mappings(parsed_body.event_source_mappings);
    Ok(builder)
}

pub fn list_function_event_invoke_configs_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_function_event_invoke_configs_output::Builder,
) -> std::result::Result<
    crate::output::list_function_event_invoke_configs_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::ListFunctionEventInvokeConfigsOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_function_event_invoke_configs(parsed_body.function_event_invoke_configs);
    builder = builder.set_next_marker(parsed_body.next_marker);
    Ok(builder)
}

pub fn list_functions_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_functions_output::Builder,
) -> std::result::Result<crate::output::list_functions_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListFunctionsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_next_marker(parsed_body.next_marker);
    builder = builder.set_functions(parsed_body.functions);
    Ok(builder)
}

pub fn list_functions_by_code_signing_config_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_functions_by_code_signing_config_output::Builder,
) -> std::result::Result<
    crate::output::list_functions_by_code_signing_config_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::ListFunctionsByCodeSigningConfigOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_next_marker(parsed_body.next_marker);
    builder = builder.set_function_arns(parsed_body.function_arns);
    Ok(builder)
}

pub fn list_layers_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_layers_output::Builder,
) -> std::result::Result<crate::output::list_layers_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListLayersOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_next_marker(parsed_body.next_marker);
    builder = builder.set_layers(parsed_body.layers);
    Ok(builder)
}

pub fn list_layer_versions_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_layer_versions_output::Builder,
) -> std::result::Result<crate::output::list_layer_versions_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListLayerVersionsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_next_marker(parsed_body.next_marker);
    builder = builder.set_layer_versions(parsed_body.layer_versions);
    Ok(builder)
}

pub fn list_provisioned_concurrency_configs_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_provisioned_concurrency_configs_output::Builder,
) -> std::result::Result<
    crate::output::list_provisioned_concurrency_configs_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::ListProvisionedConcurrencyConfigsOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder =
        builder.set_provisioned_concurrency_configs(parsed_body.provisioned_concurrency_configs);
    builder = builder.set_next_marker(parsed_body.next_marker);
    Ok(builder)
}

pub fn list_tags_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_tags_output::Builder,
) -> std::result::Result<crate::output::list_tags_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListTagsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_tags(parsed_body.tags);
    Ok(builder)
}

pub fn list_versions_by_function_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_versions_by_function_output::Builder,
) -> std::result::Result<crate::output::list_versions_by_function_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::ListVersionsByFunctionOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_next_marker(parsed_body.next_marker);
    builder = builder.set_versions(parsed_body.versions);
    Ok(builder)
}

pub fn publish_layer_version_deser_operation(
    input: &[u8],
    mut builder: crate::output::publish_layer_version_output::Builder,
) -> std::result::Result<crate::output::publish_layer_version_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::PublishLayerVersionOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_content(parsed_body.content);
    builder = builder.set_layer_arn(parsed_body.layer_arn);
    builder = builder.set_layer_version_arn(parsed_body.layer_version_arn);
    builder = builder.set_description(parsed_body.description);
    builder = builder.set_created_date(parsed_body.created_date);
    builder = builder.set_version(Some(parsed_body.version));
    builder = builder.set_compatible_runtimes(parsed_body.compatible_runtimes);
    builder = builder.set_license_info(parsed_body.license_info);
    Ok(builder)
}

pub fn publish_version_deser_operation(
    input: &[u8],
    mut builder: crate::output::publish_version_output::Builder,
) -> std::result::Result<crate::output::publish_version_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::PublishVersionOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_function_name(parsed_body.function_name);
    builder = builder.set_function_arn(parsed_body.function_arn);
    builder = builder.set_runtime(parsed_body.runtime);
    builder = builder.set_role(parsed_body.role);
    builder = builder.set_handler(parsed_body.handler);
    builder = builder.set_code_size(Some(parsed_body.code_size));
    builder = builder.set_description(parsed_body.description);
    builder = builder.set_timeout(parsed_body.timeout);
    builder = builder.set_memory_size(parsed_body.memory_size);
    builder = builder.set_last_modified(parsed_body.last_modified);
    builder = builder.set_code_sha256(parsed_body.code_sha256);
    builder = builder.set_version(parsed_body.version);
    builder = builder.set_vpc_config(parsed_body.vpc_config);
    builder = builder.set_dead_letter_config(parsed_body.dead_letter_config);
    builder = builder.set_environment(parsed_body.environment);
    builder = builder.set_kms_key_arn(parsed_body.kms_key_arn);
    builder = builder.set_tracing_config(parsed_body.tracing_config);
    builder = builder.set_master_arn(parsed_body.master_arn);
    builder = builder.set_revision_id(parsed_body.revision_id);
    builder = builder.set_layers(parsed_body.layers);
    builder = builder.set_state(parsed_body.state);
    builder = builder.set_state_reason(parsed_body.state_reason);
    builder = builder.set_state_reason_code(parsed_body.state_reason_code);
    builder = builder.set_last_update_status(parsed_body.last_update_status);
    builder = builder.set_last_update_status_reason(parsed_body.last_update_status_reason);
    builder =
        builder.set_last_update_status_reason_code(parsed_body.last_update_status_reason_code);
    builder = builder.set_file_system_configs(parsed_body.file_system_configs);
    builder = builder.set_package_type(parsed_body.package_type);
    builder = builder.set_image_config_response(parsed_body.image_config_response);
    builder = builder.set_signing_profile_version_arn(parsed_body.signing_profile_version_arn);
    builder = builder.set_signing_job_arn(parsed_body.signing_job_arn);
    Ok(builder)
}

pub fn put_function_code_signing_config_deser_operation(
    input: &[u8],
    mut builder: crate::output::put_function_code_signing_config_output::Builder,
) -> std::result::Result<
    crate::output::put_function_code_signing_config_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::PutFunctionCodeSigningConfigOutputBody = if input.is_empty()
    {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_code_signing_config_arn(parsed_body.code_signing_config_arn);
    builder = builder.set_function_name(parsed_body.function_name);
    Ok(builder)
}

pub fn put_function_concurrency_deser_operation(
    input: &[u8],
    mut builder: crate::output::put_function_concurrency_output::Builder,
) -> std::result::Result<crate::output::put_function_concurrency_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::PutFunctionConcurrencyOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder =
        builder.set_reserved_concurrent_executions(parsed_body.reserved_concurrent_executions);
    Ok(builder)
}

pub fn put_function_event_invoke_config_deser_operation(
    input: &[u8],
    mut builder: crate::output::put_function_event_invoke_config_output::Builder,
) -> std::result::Result<
    crate::output::put_function_event_invoke_config_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::PutFunctionEventInvokeConfigOutputBody = if input.is_empty()
    {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_last_modified(parsed_body.last_modified);
    builder = builder.set_function_arn(parsed_body.function_arn);
    builder = builder.set_maximum_retry_attempts(parsed_body.maximum_retry_attempts);
    builder = builder.set_maximum_event_age_in_seconds(parsed_body.maximum_event_age_in_seconds);
    builder = builder.set_destination_config(parsed_body.destination_config);
    Ok(builder)
}

pub fn put_provisioned_concurrency_config_deser_operation(
    input: &[u8],
    mut builder: crate::output::put_provisioned_concurrency_config_output::Builder,
) -> std::result::Result<
    crate::output::put_provisioned_concurrency_config_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::PutProvisionedConcurrencyConfigOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_requested_provisioned_concurrent_executions(
        parsed_body.requested_provisioned_concurrent_executions,
    );
    builder = builder.set_available_provisioned_concurrent_executions(
        parsed_body.available_provisioned_concurrent_executions,
    );
    builder = builder.set_allocated_provisioned_concurrent_executions(
        parsed_body.allocated_provisioned_concurrent_executions,
    );
    builder = builder.set_status(parsed_body.status);
    builder = builder.set_status_reason(parsed_body.status_reason);
    builder = builder.set_last_modified(parsed_body.last_modified);
    Ok(builder)
}

pub fn update_alias_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_alias_output::Builder,
) -> std::result::Result<crate::output::update_alias_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateAliasOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_alias_arn(parsed_body.alias_arn);
    builder = builder.set_name(parsed_body.name);
    builder = builder.set_function_version(parsed_body.function_version);
    builder = builder.set_description(parsed_body.description);
    builder = builder.set_routing_config(parsed_body.routing_config);
    builder = builder.set_revision_id(parsed_body.revision_id);
    Ok(builder)
}

pub fn update_code_signing_config_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_code_signing_config_output::Builder,
) -> std::result::Result<crate::output::update_code_signing_config_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::UpdateCodeSigningConfigOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_code_signing_config(parsed_body.code_signing_config);
    Ok(builder)
}

pub fn update_event_source_mapping_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_event_source_mapping_output::Builder,
) -> std::result::Result<
    crate::output::update_event_source_mapping_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::UpdateEventSourceMappingOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_uuid(parsed_body.uuid);
    builder = builder.set_starting_position(parsed_body.starting_position);
    builder = builder.set_starting_position_timestamp(parsed_body.starting_position_timestamp);
    builder = builder.set_batch_size(parsed_body.batch_size);
    builder = builder
        .set_maximum_batching_window_in_seconds(parsed_body.maximum_batching_window_in_seconds);
    builder = builder.set_parallelization_factor(parsed_body.parallelization_factor);
    builder = builder.set_event_source_arn(parsed_body.event_source_arn);
    builder = builder.set_function_arn(parsed_body.function_arn);
    builder = builder.set_last_modified(parsed_body.last_modified);
    builder = builder.set_last_processing_result(parsed_body.last_processing_result);
    builder = builder.set_state(parsed_body.state);
    builder = builder.set_state_transition_reason(parsed_body.state_transition_reason);
    builder = builder.set_destination_config(parsed_body.destination_config);
    builder = builder.set_topics(parsed_body.topics);
    builder = builder.set_queues(parsed_body.queues);
    builder = builder.set_source_access_configurations(parsed_body.source_access_configurations);
    builder = builder.set_self_managed_event_source(parsed_body.self_managed_event_source);
    builder = builder.set_maximum_record_age_in_seconds(parsed_body.maximum_record_age_in_seconds);
    builder =
        builder.set_bisect_batch_on_function_error(parsed_body.bisect_batch_on_function_error);
    builder = builder.set_maximum_retry_attempts(parsed_body.maximum_retry_attempts);
    builder = builder.set_tumbling_window_in_seconds(parsed_body.tumbling_window_in_seconds);
    builder = builder.set_function_response_types(parsed_body.function_response_types);
    Ok(builder)
}

pub fn update_function_code_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_function_code_output::Builder,
) -> std::result::Result<crate::output::update_function_code_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateFunctionCodeOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_function_name(parsed_body.function_name);
    builder = builder.set_function_arn(parsed_body.function_arn);
    builder = builder.set_runtime(parsed_body.runtime);
    builder = builder.set_role(parsed_body.role);
    builder = builder.set_handler(parsed_body.handler);
    builder = builder.set_code_size(Some(parsed_body.code_size));
    builder = builder.set_description(parsed_body.description);
    builder = builder.set_timeout(parsed_body.timeout);
    builder = builder.set_memory_size(parsed_body.memory_size);
    builder = builder.set_last_modified(parsed_body.last_modified);
    builder = builder.set_code_sha256(parsed_body.code_sha256);
    builder = builder.set_version(parsed_body.version);
    builder = builder.set_vpc_config(parsed_body.vpc_config);
    builder = builder.set_dead_letter_config(parsed_body.dead_letter_config);
    builder = builder.set_environment(parsed_body.environment);
    builder = builder.set_kms_key_arn(parsed_body.kms_key_arn);
    builder = builder.set_tracing_config(parsed_body.tracing_config);
    builder = builder.set_master_arn(parsed_body.master_arn);
    builder = builder.set_revision_id(parsed_body.revision_id);
    builder = builder.set_layers(parsed_body.layers);
    builder = builder.set_state(parsed_body.state);
    builder = builder.set_state_reason(parsed_body.state_reason);
    builder = builder.set_state_reason_code(parsed_body.state_reason_code);
    builder = builder.set_last_update_status(parsed_body.last_update_status);
    builder = builder.set_last_update_status_reason(parsed_body.last_update_status_reason);
    builder =
        builder.set_last_update_status_reason_code(parsed_body.last_update_status_reason_code);
    builder = builder.set_file_system_configs(parsed_body.file_system_configs);
    builder = builder.set_package_type(parsed_body.package_type);
    builder = builder.set_image_config_response(parsed_body.image_config_response);
    builder = builder.set_signing_profile_version_arn(parsed_body.signing_profile_version_arn);
    builder = builder.set_signing_job_arn(parsed_body.signing_job_arn);
    Ok(builder)
}

pub fn update_function_configuration_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_function_configuration_output::Builder,
) -> std::result::Result<
    crate::output::update_function_configuration_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::UpdateFunctionConfigurationOutputBody = if input.is_empty()
    {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_function_name(parsed_body.function_name);
    builder = builder.set_function_arn(parsed_body.function_arn);
    builder = builder.set_runtime(parsed_body.runtime);
    builder = builder.set_role(parsed_body.role);
    builder = builder.set_handler(parsed_body.handler);
    builder = builder.set_code_size(Some(parsed_body.code_size));
    builder = builder.set_description(parsed_body.description);
    builder = builder.set_timeout(parsed_body.timeout);
    builder = builder.set_memory_size(parsed_body.memory_size);
    builder = builder.set_last_modified(parsed_body.last_modified);
    builder = builder.set_code_sha256(parsed_body.code_sha256);
    builder = builder.set_version(parsed_body.version);
    builder = builder.set_vpc_config(parsed_body.vpc_config);
    builder = builder.set_dead_letter_config(parsed_body.dead_letter_config);
    builder = builder.set_environment(parsed_body.environment);
    builder = builder.set_kms_key_arn(parsed_body.kms_key_arn);
    builder = builder.set_tracing_config(parsed_body.tracing_config);
    builder = builder.set_master_arn(parsed_body.master_arn);
    builder = builder.set_revision_id(parsed_body.revision_id);
    builder = builder.set_layers(parsed_body.layers);
    builder = builder.set_state(parsed_body.state);
    builder = builder.set_state_reason(parsed_body.state_reason);
    builder = builder.set_state_reason_code(parsed_body.state_reason_code);
    builder = builder.set_last_update_status(parsed_body.last_update_status);
    builder = builder.set_last_update_status_reason(parsed_body.last_update_status_reason);
    builder =
        builder.set_last_update_status_reason_code(parsed_body.last_update_status_reason_code);
    builder = builder.set_file_system_configs(parsed_body.file_system_configs);
    builder = builder.set_package_type(parsed_body.package_type);
    builder = builder.set_image_config_response(parsed_body.image_config_response);
    builder = builder.set_signing_profile_version_arn(parsed_body.signing_profile_version_arn);
    builder = builder.set_signing_job_arn(parsed_body.signing_job_arn);
    Ok(builder)
}

pub fn update_function_event_invoke_config_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_function_event_invoke_config_output::Builder,
) -> std::result::Result<
    crate::output::update_function_event_invoke_config_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::UpdateFunctionEventInvokeConfigOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_last_modified(parsed_body.last_modified);
    builder = builder.set_function_arn(parsed_body.function_arn);
    builder = builder.set_maximum_retry_attempts(parsed_body.maximum_retry_attempts);
    builder = builder.set_maximum_event_age_in_seconds(parsed_body.maximum_event_age_in_seconds);
    builder = builder.set_destination_config(parsed_body.destination_config);
    Ok(builder)
}
