// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Adds permissions to the resource-based policy of a version of an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">AWS Lambda
/// layer</a>. Use this action to grant layer
/// usage permission to other accounts. You can grant permission to a single account, all AWS accounts, or all
/// accounts in an organization.</p>
/// <p>To revoke permission, call <a>RemoveLayerVersionPermission</a> with the statement ID that you
/// specified when you added it.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AddLayerVersionPermission {
    _private: (),
}
impl AddLayerVersionPermission {
    /// Creates a new builder-style object to manufacture [`AddLayerVersionPermissionInput`](crate::input::AddLayerVersionPermissionInput)
    pub fn builder() -> crate::input::add_layer_version_permission_input::Builder {
        crate::input::add_layer_version_permission_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AddLayerVersionPermission {
    type Output = Result<
        crate::output::AddLayerVersionPermissionOutput,
        crate::error::AddLayerVersionPermissionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_deser::parse_add_layer_version_permission_error(response)
        } else {
            crate::operation_deser::parse_add_layer_version_permission_response(response)
        }
    }
}

/// <p>Grants an AWS service or another account permission to use a function. You can apply the policy at the
/// function level, or specify a qualifier to restrict access to a single version or alias. If you use a qualifier,
/// the invoker must use the full Amazon Resource Name (ARN) of that version or alias to invoke the function.</p>
/// <p>To grant permission to another account, specify the account ID as the <code>Principal</code>. For AWS
/// services, the principal is a domain-style identifier defined by the service, like <code>s3.amazonaws.com</code> or
/// <code>sns.amazonaws.com</code>. For AWS services, you can also specify the ARN of the associated resource as the
/// <code>SourceArn</code>. If you grant permission to a service principal without specifying the source, other
/// accounts could potentially configure resources in their account to invoke your Lambda function.</p>
/// <p>This action adds a statement to a resource-based permissions policy for the function. For more information
/// about function policies, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/access-control-resource-based.html">Lambda Function Policies</a>. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AddPermission {
    _private: (),
}
impl AddPermission {
    /// Creates a new builder-style object to manufacture [`AddPermissionInput`](crate::input::AddPermissionInput)
    pub fn builder() -> crate::input::add_permission_input::Builder {
        crate::input::add_permission_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AddPermission {
    type Output = Result<crate::output::AddPermissionOutput, crate::error::AddPermissionError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_deser::parse_add_permission_error(response)
        } else {
            crate::operation_deser::parse_add_permission_response(response)
        }
    }
}

/// <p>Creates an <a href="https://docs.aws.amazon.com/lambda/latest/dg/versioning-aliases.html">alias</a> for a
/// Lambda function version. Use aliases to provide clients with a function identifier that you can update to invoke a
/// different version.</p>
/// <p>You can also map an alias to split invocation requests between two versions. Use the
/// <code>RoutingConfig</code> parameter to specify a second version and the percentage of invocation requests that
/// it receives.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateAlias {
    _private: (),
}
impl CreateAlias {
    /// Creates a new builder-style object to manufacture [`CreateAliasInput`](crate::input::CreateAliasInput)
    pub fn builder() -> crate::input::create_alias_input::Builder {
        crate::input::create_alias_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateAlias {
    type Output = Result<crate::output::CreateAliasOutput, crate::error::CreateAliasError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_deser::parse_create_alias_error(response)
        } else {
            crate::operation_deser::parse_create_alias_response(response)
        }
    }
}

/// <p>Creates a code signing configuration. A <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-trustedcode.html">code signing configuration</a> defines a list of
/// allowed signing profiles and defines the code-signing validation policy (action to be taken if deployment
/// validation checks fail). </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateCodeSigningConfig {
    _private: (),
}
impl CreateCodeSigningConfig {
    /// Creates a new builder-style object to manufacture [`CreateCodeSigningConfigInput`](crate::input::CreateCodeSigningConfigInput)
    pub fn builder() -> crate::input::create_code_signing_config_input::Builder {
        crate::input::create_code_signing_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateCodeSigningConfig {
    type Output = Result<
        crate::output::CreateCodeSigningConfigOutput,
        crate::error::CreateCodeSigningConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_deser::parse_create_code_signing_config_error(response)
        } else {
            crate::operation_deser::parse_create_code_signing_config_response(response)
        }
    }
}

/// <p>Creates a mapping between an event source and an AWS Lambda function. Lambda reads items from the event source
/// and triggers the function.</p>
/// <p>For details about each event source type, see the following topics.</p>
/// <ul>
/// <li>
/// <p>
/// <a href="https://docs.aws.amazon.com/lambda/latest/dg/with-ddb.html">Using AWS Lambda with Amazon
/// DynamoDB</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a href="https://docs.aws.amazon.com/lambda/latest/dg/with-kinesis.html">Using AWS Lambda with Amazon
/// Kinesis</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a href="https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html">Using AWS Lambda with Amazon
/// SQS</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a href="https://docs.aws.amazon.com/lambda/latest/dg/with-mq.html">Using AWS Lambda with Amazon
/// MQ</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a href="https://docs.aws.amazon.com/lambda/latest/dg/with-msk.html">Using AWS Lambda with Amazon MSK</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a href="https://docs.aws.amazon.com/lambda/latest/dg/kafka-smaa.html">Using AWS Lambda with Self-Managed Apache Kafka</a>
/// </p>
/// </li>
/// </ul>
/// <p>The following error handling options are only available for stream sources (DynamoDB and Kinesis):</p>
/// <ul>
/// <li>
/// <p>
/// <code>BisectBatchOnFunctionError</code> - If the function returns an error, split the batch in two and retry.</p>
/// </li>
/// <li>
/// <p>
/// <code>DestinationConfig</code> - Send discarded records to an Amazon SQS queue or Amazon SNS topic.</p>
/// </li>
/// <li>
/// <p>
/// <code>MaximumRecordAgeInSeconds</code> - Discard records older than the specified age. The default value is infinite (-1). When set to infinite (-1), failed records are retried until the record expires</p>
/// </li>
/// <li>
/// <p>
/// <code>MaximumRetryAttempts</code> - Discard records after the specified number of retries. The default value is infinite (-1). When set to infinite (-1), failed records are retried until the record expires.</p>
/// </li>
/// <li>
/// <p>
/// <code>ParallelizationFactor</code> - Process multiple batches from each shard concurrently.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateEventSourceMapping {
    _private: (),
}
impl CreateEventSourceMapping {
    /// Creates a new builder-style object to manufacture [`CreateEventSourceMappingInput`](crate::input::CreateEventSourceMappingInput)
    pub fn builder() -> crate::input::create_event_source_mapping_input::Builder {
        crate::input::create_event_source_mapping_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateEventSourceMapping {
    type Output = Result<
        crate::output::CreateEventSourceMappingOutput,
        crate::error::CreateEventSourceMappingError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 202 {
            crate::operation_deser::parse_create_event_source_mapping_error(response)
        } else {
            crate::operation_deser::parse_create_event_source_mapping_response(response)
        }
    }
}

/// <p>Creates a Lambda function. To create a function, you need a <a href="https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-package.html">deployment package</a> and an <a href="https://docs.aws.amazon.com/lambda/latest/dg/intro-permission-model.html#lambda-intro-execution-role">execution role</a>. The
/// deployment package is a .zip file  archive or container image that contains your function code. The execution role grants the function permission to use AWS
/// services, such as Amazon CloudWatch Logs for log streaming and AWS X-Ray for request tracing.</p>
/// <p>When you create a function, Lambda provisions an instance of the function and its supporting resources. If
/// your function connects to a VPC, this process can take a minute or so. During this time, you can't invoke or
/// modify the function. The <code>State</code>, <code>StateReason</code>, and <code>StateReasonCode</code> fields in
/// the response from <a>GetFunctionConfiguration</a> indicate when the function is ready to invoke. For
/// more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/functions-states.html">Function
/// States</a>.</p>
/// <p>A function has an unpublished version, and can have published versions and aliases. The unpublished version
/// changes when you update your function's code and configuration. A published version is a snapshot of your function
/// code and configuration that can't be changed. An alias is a named resource that maps to a version, and can be
/// changed to map to a different version. Use the <code>Publish</code> parameter to create version <code>1</code> of
/// your function from its initial configuration.</p>
/// <p>The other parameters let you configure version-specific and function-level settings. You can modify
/// version-specific settings later with <a>UpdateFunctionConfiguration</a>. Function-level settings apply
/// to both the unpublished and published versions of the function, and include tags (<a>TagResource</a>)
/// and per-function concurrency limits (<a>PutFunctionConcurrency</a>).</p>
/// <p>You can use code signing if your deployment package is a .zip file archive. To enable code signing for this function,
/// specify the ARN of a code-signing configuration. When a user
/// attempts to deploy a code package with <a>UpdateFunctionCode</a>, Lambda checks that the code
/// package has a valid signature from a trusted publisher. The code-signing configuration
/// includes set set of signing profiles, which define the trusted publishers for this function.</p>
/// <p>If another account or an AWS service invokes your function, use <a>AddPermission</a> to grant
/// permission by creating a resource-based IAM policy. You can grant permissions at the function level, on a version,
/// or on an alias.</p>
/// <p>To invoke your function directly, use <a>Invoke</a>. To invoke your function in response to events
/// in other AWS services, create an event source mapping (<a>CreateEventSourceMapping</a>), or configure a
/// function trigger in the other service. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-invocation.html">Invoking Functions</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateFunction {
    _private: (),
}
impl CreateFunction {
    /// Creates a new builder-style object to manufacture [`CreateFunctionInput`](crate::input::CreateFunctionInput)
    pub fn builder() -> crate::input::create_function_input::Builder {
        crate::input::create_function_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateFunction {
    type Output = Result<crate::output::CreateFunctionOutput, crate::error::CreateFunctionError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_deser::parse_create_function_error(response)
        } else {
            crate::operation_deser::parse_create_function_response(response)
        }
    }
}

/// <p>Deletes a Lambda function <a href="https://docs.aws.amazon.com/lambda/latest/dg/versioning-aliases.html">alias</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteAlias {
    _private: (),
}
impl DeleteAlias {
    /// Creates a new builder-style object to manufacture [`DeleteAliasInput`](crate::input::DeleteAliasInput)
    pub fn builder() -> crate::input::delete_alias_input::Builder {
        crate::input::delete_alias_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteAlias {
    type Output = Result<crate::output::DeleteAliasOutput, crate::error::DeleteAliasError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_alias_error(response)
        } else {
            crate::operation_deser::parse_delete_alias_response(response)
        }
    }
}

/// <p>Deletes the code signing configuration. You can delete the code signing configuration only if no function is
/// using it. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteCodeSigningConfig {
    _private: (),
}
impl DeleteCodeSigningConfig {
    /// Creates a new builder-style object to manufacture [`DeleteCodeSigningConfigInput`](crate::input::DeleteCodeSigningConfigInput)
    pub fn builder() -> crate::input::delete_code_signing_config_input::Builder {
        crate::input::delete_code_signing_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteCodeSigningConfig {
    type Output = Result<
        crate::output::DeleteCodeSigningConfigOutput,
        crate::error::DeleteCodeSigningConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_code_signing_config_error(response)
        } else {
            crate::operation_deser::parse_delete_code_signing_config_response(response)
        }
    }
}

/// <p>Deletes an <a href="https://docs.aws.amazon.com/lambda/latest/dg/intro-invocation-modes.html">event source
/// mapping</a>. You can get the identifier of a mapping from the output of <a>ListEventSourceMappings</a>.</p>
/// <p>When you delete an event source mapping, it enters a <code>Deleting</code> state and might not be completely deleted for several seconds.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteEventSourceMapping {
    _private: (),
}
impl DeleteEventSourceMapping {
    /// Creates a new builder-style object to manufacture [`DeleteEventSourceMappingInput`](crate::input::DeleteEventSourceMappingInput)
    pub fn builder() -> crate::input::delete_event_source_mapping_input::Builder {
        crate::input::delete_event_source_mapping_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteEventSourceMapping {
    type Output = Result<
        crate::output::DeleteEventSourceMappingOutput,
        crate::error::DeleteEventSourceMappingError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 202 {
            crate::operation_deser::parse_delete_event_source_mapping_error(response)
        } else {
            crate::operation_deser::parse_delete_event_source_mapping_response(response)
        }
    }
}

/// <p>Deletes a Lambda function. To delete a specific function version, use the <code>Qualifier</code> parameter.
/// Otherwise, all versions and aliases are deleted.</p>
/// <p>To delete Lambda event source mappings that invoke a function, use <a>DeleteEventSourceMapping</a>.
/// For AWS services and resources that invoke your function directly, delete the trigger in the service where you
/// originally configured it.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteFunction {
    _private: (),
}
impl DeleteFunction {
    /// Creates a new builder-style object to manufacture [`DeleteFunctionInput`](crate::input::DeleteFunctionInput)
    pub fn builder() -> crate::input::delete_function_input::Builder {
        crate::input::delete_function_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteFunction {
    type Output = Result<crate::output::DeleteFunctionOutput, crate::error::DeleteFunctionError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_function_error(response)
        } else {
            crate::operation_deser::parse_delete_function_response(response)
        }
    }
}

/// <p>Removes the code signing configuration from the function.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteFunctionCodeSigningConfig {
    _private: (),
}
impl DeleteFunctionCodeSigningConfig {
    /// Creates a new builder-style object to manufacture [`DeleteFunctionCodeSigningConfigInput`](crate::input::DeleteFunctionCodeSigningConfigInput)
    pub fn builder() -> crate::input::delete_function_code_signing_config_input::Builder {
        crate::input::delete_function_code_signing_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteFunctionCodeSigningConfig {
    type Output = Result<
        crate::output::DeleteFunctionCodeSigningConfigOutput,
        crate::error::DeleteFunctionCodeSigningConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_function_code_signing_config_error(response)
        } else {
            crate::operation_deser::parse_delete_function_code_signing_config_response(response)
        }
    }
}

/// <p>Removes a concurrent execution limit from a function.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteFunctionConcurrency {
    _private: (),
}
impl DeleteFunctionConcurrency {
    /// Creates a new builder-style object to manufacture [`DeleteFunctionConcurrencyInput`](crate::input::DeleteFunctionConcurrencyInput)
    pub fn builder() -> crate::input::delete_function_concurrency_input::Builder {
        crate::input::delete_function_concurrency_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteFunctionConcurrency {
    type Output = Result<
        crate::output::DeleteFunctionConcurrencyOutput,
        crate::error::DeleteFunctionConcurrencyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_function_concurrency_error(response)
        } else {
            crate::operation_deser::parse_delete_function_concurrency_response(response)
        }
    }
}

/// <p>Deletes the configuration for asynchronous invocation for a function, version, or alias.</p>
/// <p>To configure options for asynchronous invocation, use <a>PutFunctionEventInvokeConfig</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteFunctionEventInvokeConfig {
    _private: (),
}
impl DeleteFunctionEventInvokeConfig {
    /// Creates a new builder-style object to manufacture [`DeleteFunctionEventInvokeConfigInput`](crate::input::DeleteFunctionEventInvokeConfigInput)
    pub fn builder() -> crate::input::delete_function_event_invoke_config_input::Builder {
        crate::input::delete_function_event_invoke_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteFunctionEventInvokeConfig {
    type Output = Result<
        crate::output::DeleteFunctionEventInvokeConfigOutput,
        crate::error::DeleteFunctionEventInvokeConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_function_event_invoke_config_error(response)
        } else {
            crate::operation_deser::parse_delete_function_event_invoke_config_response(response)
        }
    }
}

/// <p>Deletes a version of an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">AWS Lambda
/// layer</a>. Deleted versions can no longer be viewed or added to functions. To avoid
/// breaking functions, a copy of the version remains in Lambda until no functions refer to it.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteLayerVersion {
    _private: (),
}
impl DeleteLayerVersion {
    /// Creates a new builder-style object to manufacture [`DeleteLayerVersionInput`](crate::input::DeleteLayerVersionInput)
    pub fn builder() -> crate::input::delete_layer_version_input::Builder {
        crate::input::delete_layer_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteLayerVersion {
    type Output =
        Result<crate::output::DeleteLayerVersionOutput, crate::error::DeleteLayerVersionError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_layer_version_error(response)
        } else {
            crate::operation_deser::parse_delete_layer_version_response(response)
        }
    }
}

/// <p>Deletes the provisioned concurrency configuration for a function.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteProvisionedConcurrencyConfig {
    _private: (),
}
impl DeleteProvisionedConcurrencyConfig {
    /// Creates a new builder-style object to manufacture [`DeleteProvisionedConcurrencyConfigInput`](crate::input::DeleteProvisionedConcurrencyConfigInput)
    pub fn builder() -> crate::input::delete_provisioned_concurrency_config_input::Builder {
        crate::input::delete_provisioned_concurrency_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteProvisionedConcurrencyConfig {
    type Output = Result<
        crate::output::DeleteProvisionedConcurrencyConfigOutput,
        crate::error::DeleteProvisionedConcurrencyConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_provisioned_concurrency_config_error(response)
        } else {
            crate::operation_deser::parse_delete_provisioned_concurrency_config_response(response)
        }
    }
}

/// <p>Retrieves details about your account's <a href="https://docs.aws.amazon.com/lambda/latest/dg/limits.html">limits</a> and usage in an AWS Region.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetAccountSettings {
    _private: (),
}
impl GetAccountSettings {
    /// Creates a new builder-style object to manufacture [`GetAccountSettingsInput`](crate::input::GetAccountSettingsInput)
    pub fn builder() -> crate::input::get_account_settings_input::Builder {
        crate::input::get_account_settings_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetAccountSettings {
    type Output =
        Result<crate::output::GetAccountSettingsOutput, crate::error::GetAccountSettingsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_account_settings_error(response)
        } else {
            crate::operation_deser::parse_get_account_settings_response(response)
        }
    }
}

/// <p>Returns details about a Lambda function <a href="https://docs.aws.amazon.com/lambda/latest/dg/versioning-aliases.html">alias</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetAlias {
    _private: (),
}
impl GetAlias {
    /// Creates a new builder-style object to manufacture [`GetAliasInput`](crate::input::GetAliasInput)
    pub fn builder() -> crate::input::get_alias_input::Builder {
        crate::input::get_alias_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetAlias {
    type Output = Result<crate::output::GetAliasOutput, crate::error::GetAliasError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_alias_error(response)
        } else {
            crate::operation_deser::parse_get_alias_response(response)
        }
    }
}

/// <p>Returns information about the specified code signing configuration.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetCodeSigningConfig {
    _private: (),
}
impl GetCodeSigningConfig {
    /// Creates a new builder-style object to manufacture [`GetCodeSigningConfigInput`](crate::input::GetCodeSigningConfigInput)
    pub fn builder() -> crate::input::get_code_signing_config_input::Builder {
        crate::input::get_code_signing_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetCodeSigningConfig {
    type Output =
        Result<crate::output::GetCodeSigningConfigOutput, crate::error::GetCodeSigningConfigError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_code_signing_config_error(response)
        } else {
            crate::operation_deser::parse_get_code_signing_config_response(response)
        }
    }
}

/// <p>Returns details about an event source mapping. You can get the identifier of a mapping from the output of <a>ListEventSourceMappings</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetEventSourceMapping {
    _private: (),
}
impl GetEventSourceMapping {
    /// Creates a new builder-style object to manufacture [`GetEventSourceMappingInput`](crate::input::GetEventSourceMappingInput)
    pub fn builder() -> crate::input::get_event_source_mapping_input::Builder {
        crate::input::get_event_source_mapping_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetEventSourceMapping {
    type Output = Result<
        crate::output::GetEventSourceMappingOutput,
        crate::error::GetEventSourceMappingError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_event_source_mapping_error(response)
        } else {
            crate::operation_deser::parse_get_event_source_mapping_response(response)
        }
    }
}

/// <p>Returns information about the function or function version, with a link to download the deployment package
/// that's valid for 10 minutes. If you specify a function version, only details that are specific to that version are
/// returned.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetFunction {
    _private: (),
}
impl GetFunction {
    /// Creates a new builder-style object to manufacture [`GetFunctionInput`](crate::input::GetFunctionInput)
    pub fn builder() -> crate::input::get_function_input::Builder {
        crate::input::get_function_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetFunction {
    type Output = Result<crate::output::GetFunctionOutput, crate::error::GetFunctionError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_function_error(response)
        } else {
            crate::operation_deser::parse_get_function_response(response)
        }
    }
}

/// <p>Returns the code signing configuration for the specified function.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetFunctionCodeSigningConfig {
    _private: (),
}
impl GetFunctionCodeSigningConfig {
    /// Creates a new builder-style object to manufacture [`GetFunctionCodeSigningConfigInput`](crate::input::GetFunctionCodeSigningConfigInput)
    pub fn builder() -> crate::input::get_function_code_signing_config_input::Builder {
        crate::input::get_function_code_signing_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetFunctionCodeSigningConfig {
    type Output = Result<
        crate::output::GetFunctionCodeSigningConfigOutput,
        crate::error::GetFunctionCodeSigningConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_function_code_signing_config_error(response)
        } else {
            crate::operation_deser::parse_get_function_code_signing_config_response(response)
        }
    }
}

/// <p>Returns details about the reserved concurrency configuration for a function. To set a concurrency limit for a
/// function, use <a>PutFunctionConcurrency</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetFunctionConcurrency {
    _private: (),
}
impl GetFunctionConcurrency {
    /// Creates a new builder-style object to manufacture [`GetFunctionConcurrencyInput`](crate::input::GetFunctionConcurrencyInput)
    pub fn builder() -> crate::input::get_function_concurrency_input::Builder {
        crate::input::get_function_concurrency_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetFunctionConcurrency {
    type Output = Result<
        crate::output::GetFunctionConcurrencyOutput,
        crate::error::GetFunctionConcurrencyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_function_concurrency_error(response)
        } else {
            crate::operation_deser::parse_get_function_concurrency_response(response)
        }
    }
}

/// <p>Returns the version-specific settings of a Lambda function or version. The output includes only options that
/// can vary between versions of a function. To modify these settings, use <a>UpdateFunctionConfiguration</a>.</p>
/// <p>To get all of a function's details, including function-level settings, use <a>GetFunction</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetFunctionConfiguration {
    _private: (),
}
impl GetFunctionConfiguration {
    /// Creates a new builder-style object to manufacture [`GetFunctionConfigurationInput`](crate::input::GetFunctionConfigurationInput)
    pub fn builder() -> crate::input::get_function_configuration_input::Builder {
        crate::input::get_function_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetFunctionConfiguration {
    type Output = Result<
        crate::output::GetFunctionConfigurationOutput,
        crate::error::GetFunctionConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_function_configuration_error(response)
        } else {
            crate::operation_deser::parse_get_function_configuration_response(response)
        }
    }
}

/// <p>Retrieves the configuration for asynchronous invocation for a function, version, or alias.</p>
/// <p>To configure options for asynchronous invocation, use <a>PutFunctionEventInvokeConfig</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetFunctionEventInvokeConfig {
    _private: (),
}
impl GetFunctionEventInvokeConfig {
    /// Creates a new builder-style object to manufacture [`GetFunctionEventInvokeConfigInput`](crate::input::GetFunctionEventInvokeConfigInput)
    pub fn builder() -> crate::input::get_function_event_invoke_config_input::Builder {
        crate::input::get_function_event_invoke_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetFunctionEventInvokeConfig {
    type Output = Result<
        crate::output::GetFunctionEventInvokeConfigOutput,
        crate::error::GetFunctionEventInvokeConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_function_event_invoke_config_error(response)
        } else {
            crate::operation_deser::parse_get_function_event_invoke_config_response(response)
        }
    }
}

/// <p>Returns information about a version of an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">AWS Lambda
/// layer</a>, with a link to download the layer archive
/// that's valid for 10 minutes.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetLayerVersion {
    _private: (),
}
impl GetLayerVersion {
    /// Creates a new builder-style object to manufacture [`GetLayerVersionInput`](crate::input::GetLayerVersionInput)
    pub fn builder() -> crate::input::get_layer_version_input::Builder {
        crate::input::get_layer_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetLayerVersion {
    type Output = Result<crate::output::GetLayerVersionOutput, crate::error::GetLayerVersionError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_layer_version_error(response)
        } else {
            crate::operation_deser::parse_get_layer_version_response(response)
        }
    }
}

/// <p>Returns information about a version of an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">AWS Lambda
/// layer</a>, with a link to download the layer archive
/// that's valid for 10 minutes.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetLayerVersionByArn {
    _private: (),
}
impl GetLayerVersionByArn {
    /// Creates a new builder-style object to manufacture [`GetLayerVersionByArnInput`](crate::input::GetLayerVersionByArnInput)
    pub fn builder() -> crate::input::get_layer_version_by_arn_input::Builder {
        crate::input::get_layer_version_by_arn_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetLayerVersionByArn {
    type Output =
        Result<crate::output::GetLayerVersionByArnOutput, crate::error::GetLayerVersionByArnError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_layer_version_by_arn_error(response)
        } else {
            crate::operation_deser::parse_get_layer_version_by_arn_response(response)
        }
    }
}

/// <p>Returns the permission policy for a version of an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">AWS Lambda
/// layer</a>. For more information, see <a>AddLayerVersionPermission</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetLayerVersionPolicy {
    _private: (),
}
impl GetLayerVersionPolicy {
    /// Creates a new builder-style object to manufacture [`GetLayerVersionPolicyInput`](crate::input::GetLayerVersionPolicyInput)
    pub fn builder() -> crate::input::get_layer_version_policy_input::Builder {
        crate::input::get_layer_version_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetLayerVersionPolicy {
    type Output = Result<
        crate::output::GetLayerVersionPolicyOutput,
        crate::error::GetLayerVersionPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_layer_version_policy_error(response)
        } else {
            crate::operation_deser::parse_get_layer_version_policy_response(response)
        }
    }
}

/// <p>Returns the <a href="https://docs.aws.amazon.com/lambda/latest/dg/access-control-resource-based.html">resource-based IAM policy</a> for a function, version, or alias.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetPolicy {
    _private: (),
}
impl GetPolicy {
    /// Creates a new builder-style object to manufacture [`GetPolicyInput`](crate::input::GetPolicyInput)
    pub fn builder() -> crate::input::get_policy_input::Builder {
        crate::input::get_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetPolicy {
    type Output = Result<crate::output::GetPolicyOutput, crate::error::GetPolicyError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_policy_error(response)
        } else {
            crate::operation_deser::parse_get_policy_response(response)
        }
    }
}

/// <p>Retrieves the provisioned concurrency configuration for a function's alias or version.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetProvisionedConcurrencyConfig {
    _private: (),
}
impl GetProvisionedConcurrencyConfig {
    /// Creates a new builder-style object to manufacture [`GetProvisionedConcurrencyConfigInput`](crate::input::GetProvisionedConcurrencyConfigInput)
    pub fn builder() -> crate::input::get_provisioned_concurrency_config_input::Builder {
        crate::input::get_provisioned_concurrency_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetProvisionedConcurrencyConfig {
    type Output = Result<
        crate::output::GetProvisionedConcurrencyConfigOutput,
        crate::error::GetProvisionedConcurrencyConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_provisioned_concurrency_config_error(response)
        } else {
            crate::operation_deser::parse_get_provisioned_concurrency_config_response(response)
        }
    }
}

/// <p>Invokes a Lambda function. You can invoke a function synchronously (and wait for the response), or
/// asynchronously. To invoke a function asynchronously, set <code>InvocationType</code> to <code>Event</code>.</p>
/// <p>For <a href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-sync.html">synchronous invocation</a>,
/// details about the function response, including errors, are included in the response body and headers. For either
/// invocation type, you can find more information in the <a href="https://docs.aws.amazon.com/lambda/latest/dg/monitoring-functions.html">execution log</a> and <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-x-ray.html">trace</a>.</p>
/// <p>When an error occurs, your function may be invoked multiple times. Retry behavior varies by error type,
/// client, event source, and invocation type. For example, if you invoke a function asynchronously and it returns an
/// error, Lambda executes the function up to two more times. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/retries-on-errors.html">Retry Behavior</a>.</p>
/// <p>For <a href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html">asynchronous invocation</a>,
/// Lambda adds events to a queue before sending them to your function. If your function does not have enough capacity
/// to keep up with the queue, events may be lost. Occasionally, your function may receive the same event multiple
/// times, even if no error occurs. To retain events that were not processed, configure your function with a <a href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#dlq">dead-letter queue</a>.</p>
/// <p>The status code in the API response doesn't reflect function errors. Error codes are reserved for errors that
/// prevent your function from executing, such as permissions errors, <a href="https://docs.aws.amazon.com/lambda/latest/dg/limits.html">limit errors</a>, or issues with your function's code and configuration.
/// For example, Lambda returns <code>TooManyRequestsException</code> if executing the function would cause you to
/// exceed a concurrency limit at either the account level (<code>ConcurrentInvocationLimitExceeded</code>) or
/// function level (<code>ReservedFunctionConcurrentInvocationLimitExceeded</code>).</p>
/// <p>For functions with a long timeout, your client might be disconnected during synchronous invocation while it
/// waits for a response. Configure your HTTP client, SDK, firewall, proxy, or operating system to allow for long
/// connections with timeout or keep-alive settings.</p>
/// <p>This operation requires permission for the <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/list_awslambda.html">lambda:InvokeFunction</a> action.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct Invoke {
    _private: (),
}
impl Invoke {
    /// Creates a new builder-style object to manufacture [`InvokeInput`](crate::input::InvokeInput)
    pub fn builder() -> crate::input::invoke_input::Builder {
        crate::input::invoke_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for Invoke {
    type Output = Result<crate::output::InvokeOutput, crate::error::InvokeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_invoke_error(response)
        } else {
            crate::operation_deser::parse_invoke_response(response)
        }
    }
}

/// <important>
/// <p>For asynchronous function invocation, use <a>Invoke</a>.</p>
/// </important>
/// <p>Invokes a function asynchronously.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct InvokeAsync {
    _private: (),
}
impl InvokeAsync {
    /// Creates a new builder-style object to manufacture [`InvokeAsyncInput`](crate::input::InvokeAsyncInput)
    pub fn builder() -> crate::input::invoke_async_input::Builder {
        crate::input::invoke_async_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for InvokeAsync {
    type Output = Result<crate::output::InvokeAsyncOutput, crate::error::InvokeAsyncError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 202 {
            crate::operation_deser::parse_invoke_async_error(response)
        } else {
            crate::operation_deser::parse_invoke_async_response(response)
        }
    }
}

/// <p>Returns a list of <a href="https://docs.aws.amazon.com/lambda/latest/dg/versioning-aliases.html">aliases</a>
/// for a Lambda function.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListAliases {
    _private: (),
}
impl ListAliases {
    /// Creates a new builder-style object to manufacture [`ListAliasesInput`](crate::input::ListAliasesInput)
    pub fn builder() -> crate::input::list_aliases_input::Builder {
        crate::input::list_aliases_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListAliases {
    type Output = Result<crate::output::ListAliasesOutput, crate::error::ListAliasesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_aliases_error(response)
        } else {
            crate::operation_deser::parse_list_aliases_response(response)
        }
    }
}

/// <p>Returns a list of <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuring-codesigning.html">code
/// signing configurations</a>. A request returns up to 10,000 configurations per
/// call. You can use the <code>MaxItems</code> parameter to return fewer configurations per call. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListCodeSigningConfigs {
    _private: (),
}
impl ListCodeSigningConfigs {
    /// Creates a new builder-style object to manufacture [`ListCodeSigningConfigsInput`](crate::input::ListCodeSigningConfigsInput)
    pub fn builder() -> crate::input::list_code_signing_configs_input::Builder {
        crate::input::list_code_signing_configs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListCodeSigningConfigs {
    type Output = Result<
        crate::output::ListCodeSigningConfigsOutput,
        crate::error::ListCodeSigningConfigsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_code_signing_configs_error(response)
        } else {
            crate::operation_deser::parse_list_code_signing_configs_response(response)
        }
    }
}

/// <p>Lists event source mappings. Specify an <code>EventSourceArn</code> to only show event source mappings for a
/// single event source.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListEventSourceMappings {
    _private: (),
}
impl ListEventSourceMappings {
    /// Creates a new builder-style object to manufacture [`ListEventSourceMappingsInput`](crate::input::ListEventSourceMappingsInput)
    pub fn builder() -> crate::input::list_event_source_mappings_input::Builder {
        crate::input::list_event_source_mappings_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListEventSourceMappings {
    type Output = Result<
        crate::output::ListEventSourceMappingsOutput,
        crate::error::ListEventSourceMappingsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_event_source_mappings_error(response)
        } else {
            crate::operation_deser::parse_list_event_source_mappings_response(response)
        }
    }
}

/// <p>Retrieves a list of configurations for asynchronous invocation for a function.</p>
/// <p>To configure options for asynchronous invocation, use <a>PutFunctionEventInvokeConfig</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListFunctionEventInvokeConfigs {
    _private: (),
}
impl ListFunctionEventInvokeConfigs {
    /// Creates a new builder-style object to manufacture [`ListFunctionEventInvokeConfigsInput`](crate::input::ListFunctionEventInvokeConfigsInput)
    pub fn builder() -> crate::input::list_function_event_invoke_configs_input::Builder {
        crate::input::list_function_event_invoke_configs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListFunctionEventInvokeConfigs {
    type Output = Result<
        crate::output::ListFunctionEventInvokeConfigsOutput,
        crate::error::ListFunctionEventInvokeConfigsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_function_event_invoke_configs_error(response)
        } else {
            crate::operation_deser::parse_list_function_event_invoke_configs_response(response)
        }
    }
}

/// <p>Returns a list of Lambda functions, with the version-specific configuration of each. Lambda returns up to 50
/// functions per call.</p>
/// <p>Set <code>FunctionVersion</code> to <code>ALL</code> to include all published versions of each function in
/// addition to the unpublished version. </p>
/// <note>
/// <p>The <code>ListFunctions</code> action returns a subset of the <a>FunctionConfiguration</a> fields.   
/// To get the additional fields (State, StateReasonCode, StateReason, LastUpdateStatus, LastUpdateStatusReason, LastUpdateStatusReasonCode)
/// for a function or version, use <a>GetFunction</a>.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListFunctions {
    _private: (),
}
impl ListFunctions {
    /// Creates a new builder-style object to manufacture [`ListFunctionsInput`](crate::input::ListFunctionsInput)
    pub fn builder() -> crate::input::list_functions_input::Builder {
        crate::input::list_functions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListFunctions {
    type Output = Result<crate::output::ListFunctionsOutput, crate::error::ListFunctionsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_functions_error(response)
        } else {
            crate::operation_deser::parse_list_functions_response(response)
        }
    }
}

/// <p>List the functions that use the specified code signing configuration. You can use this method prior to deleting a
/// code signing configuration, to verify that no functions are using it.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListFunctionsByCodeSigningConfig {
    _private: (),
}
impl ListFunctionsByCodeSigningConfig {
    /// Creates a new builder-style object to manufacture [`ListFunctionsByCodeSigningConfigInput`](crate::input::ListFunctionsByCodeSigningConfigInput)
    pub fn builder() -> crate::input::list_functions_by_code_signing_config_input::Builder {
        crate::input::list_functions_by_code_signing_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListFunctionsByCodeSigningConfig {
    type Output = Result<
        crate::output::ListFunctionsByCodeSigningConfigOutput,
        crate::error::ListFunctionsByCodeSigningConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_functions_by_code_signing_config_error(response)
        } else {
            crate::operation_deser::parse_list_functions_by_code_signing_config_response(response)
        }
    }
}

/// <p>Lists <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">AWS Lambda
/// layers</a> and shows information about the latest version of each. Specify a <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html">runtime identifier</a> to list only layers
/// that indicate that they're compatible with that runtime.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListLayers {
    _private: (),
}
impl ListLayers {
    /// Creates a new builder-style object to manufacture [`ListLayersInput`](crate::input::ListLayersInput)
    pub fn builder() -> crate::input::list_layers_input::Builder {
        crate::input::list_layers_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListLayers {
    type Output = Result<crate::output::ListLayersOutput, crate::error::ListLayersError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_layers_error(response)
        } else {
            crate::operation_deser::parse_list_layers_response(response)
        }
    }
}

/// <p>Lists the versions of an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">AWS Lambda
/// layer</a>. Versions that have been deleted aren't listed. Specify a <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html">runtime identifier</a> to list only
/// versions that indicate that they're compatible with that runtime.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListLayerVersions {
    _private: (),
}
impl ListLayerVersions {
    /// Creates a new builder-style object to manufacture [`ListLayerVersionsInput`](crate::input::ListLayerVersionsInput)
    pub fn builder() -> crate::input::list_layer_versions_input::Builder {
        crate::input::list_layer_versions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListLayerVersions {
    type Output =
        Result<crate::output::ListLayerVersionsOutput, crate::error::ListLayerVersionsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_layer_versions_error(response)
        } else {
            crate::operation_deser::parse_list_layer_versions_response(response)
        }
    }
}

/// <p>Retrieves a list of provisioned concurrency configurations for a function.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListProvisionedConcurrencyConfigs {
    _private: (),
}
impl ListProvisionedConcurrencyConfigs {
    /// Creates a new builder-style object to manufacture [`ListProvisionedConcurrencyConfigsInput`](crate::input::ListProvisionedConcurrencyConfigsInput)
    pub fn builder() -> crate::input::list_provisioned_concurrency_configs_input::Builder {
        crate::input::list_provisioned_concurrency_configs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListProvisionedConcurrencyConfigs {
    type Output = Result<
        crate::output::ListProvisionedConcurrencyConfigsOutput,
        crate::error::ListProvisionedConcurrencyConfigsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_provisioned_concurrency_configs_error(response)
        } else {
            crate::operation_deser::parse_list_provisioned_concurrency_configs_response(response)
        }
    }
}

/// <p>Returns a function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/tagging.html">tags</a>. You can
/// also view tags with <a>GetFunction</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTags {
    _private: (),
}
impl ListTags {
    /// Creates a new builder-style object to manufacture [`ListTagsInput`](crate::input::ListTagsInput)
    pub fn builder() -> crate::input::list_tags_input::Builder {
        crate::input::list_tags_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTags {
    type Output = Result<crate::output::ListTagsOutput, crate::error::ListTagsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_error(response)
        } else {
            crate::operation_deser::parse_list_tags_response(response)
        }
    }
}

/// <p>Returns a list of <a href="https://docs.aws.amazon.com/lambda/latest/dg/versioning-aliases.html">versions</a>,
/// with the version-specific configuration of each. Lambda returns up to 50 versions per call.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListVersionsByFunction {
    _private: (),
}
impl ListVersionsByFunction {
    /// Creates a new builder-style object to manufacture [`ListVersionsByFunctionInput`](crate::input::ListVersionsByFunctionInput)
    pub fn builder() -> crate::input::list_versions_by_function_input::Builder {
        crate::input::list_versions_by_function_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListVersionsByFunction {
    type Output = Result<
        crate::output::ListVersionsByFunctionOutput,
        crate::error::ListVersionsByFunctionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_versions_by_function_error(response)
        } else {
            crate::operation_deser::parse_list_versions_by_function_response(response)
        }
    }
}

/// <p>Creates an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">AWS Lambda
/// layer</a> from a ZIP archive. Each time you call <code>PublishLayerVersion</code> with the same
/// layer name, a new version is created.</p>
/// <p>Add layers to your function with <a>CreateFunction</a> or <a>UpdateFunctionConfiguration</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PublishLayerVersion {
    _private: (),
}
impl PublishLayerVersion {
    /// Creates a new builder-style object to manufacture [`PublishLayerVersionInput`](crate::input::PublishLayerVersionInput)
    pub fn builder() -> crate::input::publish_layer_version_input::Builder {
        crate::input::publish_layer_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PublishLayerVersion {
    type Output =
        Result<crate::output::PublishLayerVersionOutput, crate::error::PublishLayerVersionError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_deser::parse_publish_layer_version_error(response)
        } else {
            crate::operation_deser::parse_publish_layer_version_response(response)
        }
    }
}

/// <p>Creates a <a href="https://docs.aws.amazon.com/lambda/latest/dg/versioning-aliases.html">version</a> from the
/// current code and configuration of a function. Use versions to create a snapshot of your function code and
/// configuration that doesn't change.</p>
/// <p>AWS Lambda doesn't publish a version if the function's configuration and code haven't changed since the last
/// version. Use <a>UpdateFunctionCode</a> or <a>UpdateFunctionConfiguration</a> to update the
/// function before publishing a version.</p>
/// <p>Clients can invoke versions directly or with an alias. To create an alias, use <a>CreateAlias</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PublishVersion {
    _private: (),
}
impl PublishVersion {
    /// Creates a new builder-style object to manufacture [`PublishVersionInput`](crate::input::PublishVersionInput)
    pub fn builder() -> crate::input::publish_version_input::Builder {
        crate::input::publish_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PublishVersion {
    type Output = Result<crate::output::PublishVersionOutput, crate::error::PublishVersionError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_deser::parse_publish_version_error(response)
        } else {
            crate::operation_deser::parse_publish_version_response(response)
        }
    }
}

/// <p>Update the code signing configuration for the function. Changes to the code signing configuration take effect the
/// next time a user tries to deploy a code package to the function. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutFunctionCodeSigningConfig {
    _private: (),
}
impl PutFunctionCodeSigningConfig {
    /// Creates a new builder-style object to manufacture [`PutFunctionCodeSigningConfigInput`](crate::input::PutFunctionCodeSigningConfigInput)
    pub fn builder() -> crate::input::put_function_code_signing_config_input::Builder {
        crate::input::put_function_code_signing_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutFunctionCodeSigningConfig {
    type Output = Result<
        crate::output::PutFunctionCodeSigningConfigOutput,
        crate::error::PutFunctionCodeSigningConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_function_code_signing_config_error(response)
        } else {
            crate::operation_deser::parse_put_function_code_signing_config_response(response)
        }
    }
}

/// <p>Sets the maximum number of simultaneous executions for a function, and reserves capacity for that concurrency
/// level.</p>
/// <p>Concurrency settings apply to the function as a whole, including all published versions and the unpublished
/// version. Reserving concurrency both ensures that your function has capacity to process the specified number of
/// events simultaneously, and prevents it from scaling beyond that level. Use <a>GetFunction</a> to see
/// the current setting for a function.</p>
/// <p>Use <a>GetAccountSettings</a> to see your Regional concurrency limit. You can reserve concurrency
/// for as many functions as you like, as long as you leave at least 100 simultaneous executions unreserved for
/// functions that aren't configured with a per-function limit. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/concurrent-executions.html">Managing Concurrency</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutFunctionConcurrency {
    _private: (),
}
impl PutFunctionConcurrency {
    /// Creates a new builder-style object to manufacture [`PutFunctionConcurrencyInput`](crate::input::PutFunctionConcurrencyInput)
    pub fn builder() -> crate::input::put_function_concurrency_input::Builder {
        crate::input::put_function_concurrency_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutFunctionConcurrency {
    type Output = Result<
        crate::output::PutFunctionConcurrencyOutput,
        crate::error::PutFunctionConcurrencyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_function_concurrency_error(response)
        } else {
            crate::operation_deser::parse_put_function_concurrency_response(response)
        }
    }
}

/// <p>Configures options for <a href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html">asynchronous
/// invocation</a> on a function, version, or alias. If a configuration already exists for a function, version,
/// or alias, this operation overwrites it. If you exclude any settings, they are removed. To set one option without
/// affecting existing settings for other options, use <a>UpdateFunctionEventInvokeConfig</a>.</p>
/// <p>By default, Lambda retries an asynchronous invocation twice if the function returns an error. It retains
/// events in a queue for up to six hours. When an event fails all processing attempts or stays in the asynchronous
/// invocation queue for too long, Lambda discards it. To retain discarded events, configure a dead-letter queue with
/// <a>UpdateFunctionConfiguration</a>.</p>
/// <p>To send an invocation record to a queue, topic, function, or event bus, specify a <a href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations">destination</a>. You can configure separate destinations for successful invocations (on-success) and events
/// that fail all processing attempts (on-failure). You can configure destinations in addition to or instead of a
/// dead-letter queue.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutFunctionEventInvokeConfig {
    _private: (),
}
impl PutFunctionEventInvokeConfig {
    /// Creates a new builder-style object to manufacture [`PutFunctionEventInvokeConfigInput`](crate::input::PutFunctionEventInvokeConfigInput)
    pub fn builder() -> crate::input::put_function_event_invoke_config_input::Builder {
        crate::input::put_function_event_invoke_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutFunctionEventInvokeConfig {
    type Output = Result<
        crate::output::PutFunctionEventInvokeConfigOutput,
        crate::error::PutFunctionEventInvokeConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_function_event_invoke_config_error(response)
        } else {
            crate::operation_deser::parse_put_function_event_invoke_config_response(response)
        }
    }
}

/// <p>Adds a provisioned concurrency configuration to a function's alias or version.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutProvisionedConcurrencyConfig {
    _private: (),
}
impl PutProvisionedConcurrencyConfig {
    /// Creates a new builder-style object to manufacture [`PutProvisionedConcurrencyConfigInput`](crate::input::PutProvisionedConcurrencyConfigInput)
    pub fn builder() -> crate::input::put_provisioned_concurrency_config_input::Builder {
        crate::input::put_provisioned_concurrency_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutProvisionedConcurrencyConfig {
    type Output = Result<
        crate::output::PutProvisionedConcurrencyConfigOutput,
        crate::error::PutProvisionedConcurrencyConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 202 {
            crate::operation_deser::parse_put_provisioned_concurrency_config_error(response)
        } else {
            crate::operation_deser::parse_put_provisioned_concurrency_config_response(response)
        }
    }
}

/// <p>Removes a statement from the permissions policy for a version of an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">AWS Lambda
/// layer</a>. For more information, see
/// <a>AddLayerVersionPermission</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RemoveLayerVersionPermission {
    _private: (),
}
impl RemoveLayerVersionPermission {
    /// Creates a new builder-style object to manufacture [`RemoveLayerVersionPermissionInput`](crate::input::RemoveLayerVersionPermissionInput)
    pub fn builder() -> crate::input::remove_layer_version_permission_input::Builder {
        crate::input::remove_layer_version_permission_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RemoveLayerVersionPermission {
    type Output = Result<
        crate::output::RemoveLayerVersionPermissionOutput,
        crate::error::RemoveLayerVersionPermissionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_remove_layer_version_permission_error(response)
        } else {
            crate::operation_deser::parse_remove_layer_version_permission_response(response)
        }
    }
}

/// <p>Revokes function-use permission from an AWS service or another account. You can get the ID of the statement
/// from the output of <a>GetPolicy</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RemovePermission {
    _private: (),
}
impl RemovePermission {
    /// Creates a new builder-style object to manufacture [`RemovePermissionInput`](crate::input::RemovePermissionInput)
    pub fn builder() -> crate::input::remove_permission_input::Builder {
        crate::input::remove_permission_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RemovePermission {
    type Output =
        Result<crate::output::RemovePermissionOutput, crate::error::RemovePermissionError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_remove_permission_error(response)
        } else {
            crate::operation_deser::parse_remove_permission_response(response)
        }
    }
}

/// <p>Adds <a href="https://docs.aws.amazon.com/lambda/latest/dg/tagging.html">tags</a> to a function.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output = Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p>Removes <a href="https://docs.aws.amazon.com/lambda/latest/dg/tagging.html">tags</a> from a function.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output = Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}

/// <p>Updates the configuration of a Lambda function <a href="https://docs.aws.amazon.com/lambda/latest/dg/versioning-aliases.html">alias</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateAlias {
    _private: (),
}
impl UpdateAlias {
    /// Creates a new builder-style object to manufacture [`UpdateAliasInput`](crate::input::UpdateAliasInput)
    pub fn builder() -> crate::input::update_alias_input::Builder {
        crate::input::update_alias_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateAlias {
    type Output = Result<crate::output::UpdateAliasOutput, crate::error::UpdateAliasError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_alias_error(response)
        } else {
            crate::operation_deser::parse_update_alias_response(response)
        }
    }
}

/// <p>Update the code signing configuration. Changes to the code signing configuration take effect the next time a
/// user tries to deploy a code package to the function. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateCodeSigningConfig {
    _private: (),
}
impl UpdateCodeSigningConfig {
    /// Creates a new builder-style object to manufacture [`UpdateCodeSigningConfigInput`](crate::input::UpdateCodeSigningConfigInput)
    pub fn builder() -> crate::input::update_code_signing_config_input::Builder {
        crate::input::update_code_signing_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateCodeSigningConfig {
    type Output = Result<
        crate::output::UpdateCodeSigningConfigOutput,
        crate::error::UpdateCodeSigningConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_code_signing_config_error(response)
        } else {
            crate::operation_deser::parse_update_code_signing_config_response(response)
        }
    }
}

/// <p>Updates an event source mapping. You can change the function that AWS Lambda invokes, or pause invocation and resume later from the same location.</p>
/// <p>The following error handling options are only available for stream sources (DynamoDB and Kinesis):</p>
/// <ul>
/// <li>
/// <p>
/// <code>BisectBatchOnFunctionError</code> - If the function returns an error, split the batch in two and retry.</p>
/// </li>
/// <li>
/// <p>
/// <code>DestinationConfig</code> - Send discarded records to an Amazon SQS queue or Amazon SNS topic.</p>
/// </li>
/// <li>
/// <p>
/// <code>MaximumRecordAgeInSeconds</code> - Discard records older than the specified age. The default value is infinite (-1). When set to infinite (-1), failed records are retried until the record expires</p>
/// </li>
/// <li>
/// <p>
/// <code>MaximumRetryAttempts</code> - Discard records after the specified number of retries. The default value is infinite (-1). When set to infinite (-1), failed records are retried until the record expires.</p>
/// </li>
/// <li>
/// <p>
/// <code>ParallelizationFactor</code> - Process multiple batches from each shard concurrently.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateEventSourceMapping {
    _private: (),
}
impl UpdateEventSourceMapping {
    /// Creates a new builder-style object to manufacture [`UpdateEventSourceMappingInput`](crate::input::UpdateEventSourceMappingInput)
    pub fn builder() -> crate::input::update_event_source_mapping_input::Builder {
        crate::input::update_event_source_mapping_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateEventSourceMapping {
    type Output = Result<
        crate::output::UpdateEventSourceMappingOutput,
        crate::error::UpdateEventSourceMappingError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 202 {
            crate::operation_deser::parse_update_event_source_mapping_error(response)
        } else {
            crate::operation_deser::parse_update_event_source_mapping_response(response)
        }
    }
}

/// <p>Updates a Lambda function's code. If code signing is enabled for the function, the code package must be signed
/// by a trusted publisher. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-trustedcode.html">Configuring code signing</a>.</p>
/// <p>The function's code is locked when you publish a version. You can't modify the code of a published version,
/// only the unpublished version.</p>
/// <note>
/// <p>For a function defined as a container image, Lambda resolves the image tag to an image digest. In Amazon ECR, if
/// you update the image tag to a new image, Lambda does not automatically update the function.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateFunctionCode {
    _private: (),
}
impl UpdateFunctionCode {
    /// Creates a new builder-style object to manufacture [`UpdateFunctionCodeInput`](crate::input::UpdateFunctionCodeInput)
    pub fn builder() -> crate::input::update_function_code_input::Builder {
        crate::input::update_function_code_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateFunctionCode {
    type Output =
        Result<crate::output::UpdateFunctionCodeOutput, crate::error::UpdateFunctionCodeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_function_code_error(response)
        } else {
            crate::operation_deser::parse_update_function_code_response(response)
        }
    }
}

/// <p>Modify the version-specific settings of a Lambda function.</p>
/// <p>When you update a function, Lambda provisions an instance of the function and its supporting resources. If
/// your function connects to a VPC, this process can take a minute. During this time, you can't modify the function,
/// but you can still invoke it. The <code>LastUpdateStatus</code>, <code>LastUpdateStatusReason</code>, and
/// <code>LastUpdateStatusReasonCode</code> fields in the response from <a>GetFunctionConfiguration</a>
/// indicate when the update is complete and the function is processing events with the new configuration. For more
/// information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/functions-states.html">Function
/// States</a>.</p>
/// <p>These settings can vary between versions of a function and are locked when you publish a version. You can't
/// modify the configuration of a published version, only the unpublished version.</p>
/// <p>To configure function concurrency, use <a>PutFunctionConcurrency</a>. To grant invoke permissions
/// to an account or AWS service, use <a>AddPermission</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateFunctionConfiguration {
    _private: (),
}
impl UpdateFunctionConfiguration {
    /// Creates a new builder-style object to manufacture [`UpdateFunctionConfigurationInput`](crate::input::UpdateFunctionConfigurationInput)
    pub fn builder() -> crate::input::update_function_configuration_input::Builder {
        crate::input::update_function_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateFunctionConfiguration {
    type Output = Result<
        crate::output::UpdateFunctionConfigurationOutput,
        crate::error::UpdateFunctionConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_function_configuration_error(response)
        } else {
            crate::operation_deser::parse_update_function_configuration_response(response)
        }
    }
}

/// <p>Updates the configuration for asynchronous invocation for a function, version, or alias.</p>
/// <p>To configure options for asynchronous invocation, use <a>PutFunctionEventInvokeConfig</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateFunctionEventInvokeConfig {
    _private: (),
}
impl UpdateFunctionEventInvokeConfig {
    /// Creates a new builder-style object to manufacture [`UpdateFunctionEventInvokeConfigInput`](crate::input::UpdateFunctionEventInvokeConfigInput)
    pub fn builder() -> crate::input::update_function_event_invoke_config_input::Builder {
        crate::input::update_function_event_invoke_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateFunctionEventInvokeConfig {
    type Output = Result<
        crate::output::UpdateFunctionEventInvokeConfigOutput,
        crate::error::UpdateFunctionEventInvokeConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_function_event_invoke_config_error(response)
        } else {
            crate::operation_deser::parse_update_function_event_invoke_config_response(response)
        }
    }
}
