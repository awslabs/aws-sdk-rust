// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn delete_scaling_policy(&self) -> fluent_builders::DeleteScalingPolicy<C> {
        fluent_builders::DeleteScalingPolicy::new(self.handle.clone())
    }
    pub fn delete_scheduled_action(&self) -> fluent_builders::DeleteScheduledAction<C> {
        fluent_builders::DeleteScheduledAction::new(self.handle.clone())
    }
    pub fn deregister_scalable_target(&self) -> fluent_builders::DeregisterScalableTarget<C> {
        fluent_builders::DeregisterScalableTarget::new(self.handle.clone())
    }
    pub fn describe_scalable_targets(&self) -> fluent_builders::DescribeScalableTargets<C> {
        fluent_builders::DescribeScalableTargets::new(self.handle.clone())
    }
    pub fn describe_scaling_activities(&self) -> fluent_builders::DescribeScalingActivities<C> {
        fluent_builders::DescribeScalingActivities::new(self.handle.clone())
    }
    pub fn describe_scaling_policies(&self) -> fluent_builders::DescribeScalingPolicies<C> {
        fluent_builders::DescribeScalingPolicies::new(self.handle.clone())
    }
    pub fn describe_scheduled_actions(&self) -> fluent_builders::DescribeScheduledActions<C> {
        fluent_builders::DescribeScheduledActions::new(self.handle.clone())
    }
    pub fn put_scaling_policy(&self) -> fluent_builders::PutScalingPolicy<C> {
        fluent_builders::PutScalingPolicy::new(self.handle.clone())
    }
    pub fn put_scheduled_action(&self) -> fluent_builders::PutScheduledAction<C> {
        fluent_builders::PutScheduledAction::new(self.handle.clone())
    }
    pub fn register_scalable_target(&self) -> fluent_builders::RegisterScalableTarget<C> {
        fluent_builders::RegisterScalableTarget::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct DeleteScalingPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_scaling_policy_input::Builder,
    }
    impl<C> DeleteScalingPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteScalingPolicyOutput,
            smithy_http::result::SdkError<crate::error::DeleteScalingPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the scaling policy.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(input);
            self
        }
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(input);
            self
        }
        /// <p>The namespace of the AWS service that provides the resource. For a resource provided
        /// by your own application or service, use <code>custom-resource</code> instead.</p>
        pub fn service_namespace(mut self, input: crate::model::ServiceNamespace) -> Self {
            self.inner = self.inner.service_namespace(input);
            self
        }
        pub fn set_service_namespace(
            mut self,
            input: std::option::Option<crate::model::ServiceNamespace>,
        ) -> Self {
            self.inner = self.inner.set_service_namespace(input);
            self
        }
        /// <p>The identifier of the resource associated with the scalable target.
        /// This string consists of the resource type and unique identifier.</p>
        /// <ul>
        /// <li>
        /// <p>ECS service - The resource type is <code>service</code> and the unique identifier is the cluster name  
        /// and service name. Example: <code>service/default/sample-webapp</code>.</p>
        /// </li>
        /// <li>
        /// <p>Spot Fleet request - The resource type is <code>spot-fleet-request</code> and the unique identifier is the
        /// Spot Fleet request ID. Example: <code>spot-fleet-request/sfr-73fbd2ce-aa30-494c-8788-1cee4EXAMPLE</code>.</p>
        /// </li>
        /// <li>
        /// <p>EMR cluster - The resource type is <code>instancegroup</code> and the unique identifier is the cluster ID and instance group ID.
        /// Example: <code>instancegroup/j-2EEZNYKUA1NTV/ig-1791Y4E1L8YI0</code>.</p>
        /// </li>
        /// <li>
        /// <p>AppStream 2.0 fleet - The resource type is <code>fleet</code> and the unique identifier is the fleet name.
        /// Example: <code>fleet/sample-fleet</code>.</p>
        /// </li>
        /// <li>
        /// <p>DynamoDB table - The resource type is <code>table</code> and the unique identifier is the table name.
        /// Example: <code>table/my-table</code>.</p>
        /// </li>
        /// <li>
        /// <p>DynamoDB global secondary index - The resource type is <code>index</code> and the unique identifier is the index name.
        /// Example: <code>table/my-table/index/my-table-index</code>.</p>
        /// </li>
        /// <li>
        /// <p>Aurora DB cluster - The resource type is <code>cluster</code> and the unique identifier is the cluster name.
        /// Example: <code>cluster:my-db-cluster</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon SageMaker endpoint variant - The resource type is <code>variant</code> and the unique identifier is the resource ID.
        /// Example: <code>endpoint/my-end-point/variant/KMeansClustering</code>.</p>
        /// </li>
        /// <li>
        /// <p>Custom resources are not supported with a resource type. This parameter must specify the <code>OutputValue</code> from the CloudFormation template stack used to access the resources. The unique identifier is defined by the service provider. More information
        /// is available in our <a href="https://github.com/aws/aws-auto-scaling-custom-resource">GitHub
        /// repository</a>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon Comprehend document classification endpoint - The resource type and unique identifier are specified using the endpoint ARN. Example: <code>arn:aws:comprehend:us-west-2:123456789012:document-classifier-endpoint/EXAMPLE</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon Comprehend entity recognizer endpoint - The resource type and unique identifier are specified using the endpoint ARN. Example: <code>arn:aws:comprehend:us-west-2:123456789012:entity-recognizer-endpoint/EXAMPLE</code>.</p>
        /// </li>
        /// <li>
        /// <p>Lambda provisioned concurrency - The resource type is <code>function</code> and the unique identifier is the function name with a function version or alias name suffix that is not <code>$LATEST</code>.
        /// Example: <code>function:my-function:prod</code> or <code>function:my-function:1</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon Keyspaces table - The resource type is <code>table</code> and the unique identifier is the table name.
        /// Example: <code>keyspace/mykeyspace/table/mytable</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon MSK cluster - The resource type and unique identifier are specified using the cluster ARN.
        /// Example: <code>arn:aws:kafka:us-east-1:123456789012:cluster/demo-cluster-1/6357e0b2-0e6a-4b86-a0b4-70df934c2e31-5</code>.</p>
        /// </li>
        /// </ul>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_id(input);
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_id(input);
            self
        }
        /// <p>The scalable dimension. This string consists of the service namespace, resource type, and scaling property.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ecs:service:DesiredCount</code> - The desired task count of an ECS service.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ec2:spot-fleet-request:TargetCapacity</code> - The target capacity of a Spot Fleet request.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>elasticmapreduce:instancegroup:InstanceCount</code> - The instance count of an EMR Instance Group.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>appstream:fleet:DesiredCapacity</code> - The desired capacity of an AppStream 2.0 fleet.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:table:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:table:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:index:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB global secondary index.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:index:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB global secondary index.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>rds:cluster:ReadReplicaCount</code> - The count of Aurora Replicas in an Aurora DB cluster. Available for Aurora MySQL-compatible edition and Aurora PostgreSQL-compatible edition.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>sagemaker:variant:DesiredInstanceCount</code> - The number of EC2 instances for an Amazon SageMaker model endpoint variant.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>custom-resource:ResourceType:Property</code> - The scalable dimension for a custom resource provided by your own application or service.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>comprehend:document-classifier-endpoint:DesiredInferenceUnits</code> - The number of inference units for an Amazon Comprehend document classification endpoint.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>comprehend:entity-recognizer-endpoint:DesiredInferenceUnits</code> - The number of inference units for an Amazon Comprehend entity recognizer endpoint.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>lambda:function:ProvisionedConcurrency</code> - The provisioned concurrency for a Lambda function.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>cassandra:table:ReadCapacityUnits</code> - The provisioned read capacity for an Amazon Keyspaces table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>cassandra:table:WriteCapacityUnits</code> -  The provisioned write capacity for an Amazon Keyspaces table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>kafka:broker-storage:VolumeSize</code> - The provisioned volume size (in GiB) for brokers in an Amazon MSK cluster.</p>
        /// </li>
        /// </ul>
        pub fn scalable_dimension(mut self, input: crate::model::ScalableDimension) -> Self {
            self.inner = self.inner.scalable_dimension(input);
            self
        }
        pub fn set_scalable_dimension(
            mut self,
            input: std::option::Option<crate::model::ScalableDimension>,
        ) -> Self {
            self.inner = self.inner.set_scalable_dimension(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteScheduledAction<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_scheduled_action_input::Builder,
    }
    impl<C> DeleteScheduledAction<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteScheduledActionOutput,
            smithy_http::result::SdkError<crate::error::DeleteScheduledActionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The namespace of the AWS service that provides the resource. For a resource provided
        /// by your own application or service, use <code>custom-resource</code> instead.</p>
        pub fn service_namespace(mut self, input: crate::model::ServiceNamespace) -> Self {
            self.inner = self.inner.service_namespace(input);
            self
        }
        pub fn set_service_namespace(
            mut self,
            input: std::option::Option<crate::model::ServiceNamespace>,
        ) -> Self {
            self.inner = self.inner.set_service_namespace(input);
            self
        }
        /// <p>The name of the scheduled action.</p>
        pub fn scheduled_action_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.scheduled_action_name(input);
            self
        }
        pub fn set_scheduled_action_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_scheduled_action_name(input);
            self
        }
        /// <p>The identifier of the resource associated with the scheduled action.
        /// This string consists of the resource type and unique identifier.</p>
        /// <ul>
        /// <li>
        /// <p>ECS service - The resource type is <code>service</code> and the unique identifier is the cluster name  
        /// and service name. Example: <code>service/default/sample-webapp</code>.</p>
        /// </li>
        /// <li>
        /// <p>Spot Fleet request - The resource type is <code>spot-fleet-request</code> and the unique identifier is the
        /// Spot Fleet request ID. Example: <code>spot-fleet-request/sfr-73fbd2ce-aa30-494c-8788-1cee4EXAMPLE</code>.</p>
        /// </li>
        /// <li>
        /// <p>EMR cluster - The resource type is <code>instancegroup</code> and the unique identifier is the cluster ID and instance group ID.
        /// Example: <code>instancegroup/j-2EEZNYKUA1NTV/ig-1791Y4E1L8YI0</code>.</p>
        /// </li>
        /// <li>
        /// <p>AppStream 2.0 fleet - The resource type is <code>fleet</code> and the unique identifier is the fleet name.
        /// Example: <code>fleet/sample-fleet</code>.</p>
        /// </li>
        /// <li>
        /// <p>DynamoDB table - The resource type is <code>table</code> and the unique identifier is the table name.
        /// Example: <code>table/my-table</code>.</p>
        /// </li>
        /// <li>
        /// <p>DynamoDB global secondary index - The resource type is <code>index</code> and the unique identifier is the index name.
        /// Example: <code>table/my-table/index/my-table-index</code>.</p>
        /// </li>
        /// <li>
        /// <p>Aurora DB cluster - The resource type is <code>cluster</code> and the unique identifier is the cluster name.
        /// Example: <code>cluster:my-db-cluster</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon SageMaker endpoint variant - The resource type is <code>variant</code> and the unique identifier is the resource ID.
        /// Example: <code>endpoint/my-end-point/variant/KMeansClustering</code>.</p>
        /// </li>
        /// <li>
        /// <p>Custom resources are not supported with a resource type. This parameter must specify the <code>OutputValue</code> from the CloudFormation template stack used to access the resources. The unique identifier is defined by the service provider. More information
        /// is available in our <a href="https://github.com/aws/aws-auto-scaling-custom-resource">GitHub
        /// repository</a>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon Comprehend document classification endpoint - The resource type and unique identifier are specified using the endpoint ARN. Example: <code>arn:aws:comprehend:us-west-2:123456789012:document-classifier-endpoint/EXAMPLE</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon Comprehend entity recognizer endpoint - The resource type and unique identifier are specified using the endpoint ARN. Example: <code>arn:aws:comprehend:us-west-2:123456789012:entity-recognizer-endpoint/EXAMPLE</code>.</p>
        /// </li>
        /// <li>
        /// <p>Lambda provisioned concurrency - The resource type is <code>function</code> and the unique identifier is the function name with a function version or alias name suffix that is not <code>$LATEST</code>.
        /// Example: <code>function:my-function:prod</code> or <code>function:my-function:1</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon Keyspaces table - The resource type is <code>table</code> and the unique identifier is the table name.
        /// Example: <code>keyspace/mykeyspace/table/mytable</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon MSK cluster - The resource type and unique identifier are specified using the cluster ARN.
        /// Example: <code>arn:aws:kafka:us-east-1:123456789012:cluster/demo-cluster-1/6357e0b2-0e6a-4b86-a0b4-70df934c2e31-5</code>.</p>
        /// </li>
        /// </ul>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_id(input);
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_id(input);
            self
        }
        /// <p>The scalable dimension. This string consists of the service namespace, resource type, and scaling property.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ecs:service:DesiredCount</code> - The desired task count of an ECS service.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ec2:spot-fleet-request:TargetCapacity</code> - The target capacity of a Spot Fleet request.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>elasticmapreduce:instancegroup:InstanceCount</code> - The instance count of an EMR Instance Group.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>appstream:fleet:DesiredCapacity</code> - The desired capacity of an AppStream 2.0 fleet.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:table:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:table:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:index:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB global secondary index.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:index:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB global secondary index.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>rds:cluster:ReadReplicaCount</code> - The count of Aurora Replicas in an Aurora DB cluster. Available for Aurora MySQL-compatible edition and Aurora PostgreSQL-compatible edition.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>sagemaker:variant:DesiredInstanceCount</code> - The number of EC2 instances for an Amazon SageMaker model endpoint variant.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>custom-resource:ResourceType:Property</code> - The scalable dimension for a custom resource provided by your own application or service.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>comprehend:document-classifier-endpoint:DesiredInferenceUnits</code> - The number of inference units for an Amazon Comprehend document classification endpoint.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>comprehend:entity-recognizer-endpoint:DesiredInferenceUnits</code> - The number of inference units for an Amazon Comprehend entity recognizer endpoint.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>lambda:function:ProvisionedConcurrency</code> - The provisioned concurrency for a Lambda function.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>cassandra:table:ReadCapacityUnits</code> - The provisioned read capacity for an Amazon Keyspaces table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>cassandra:table:WriteCapacityUnits</code> -  The provisioned write capacity for an Amazon Keyspaces table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>kafka:broker-storage:VolumeSize</code> - The provisioned volume size (in GiB) for brokers in an Amazon MSK cluster.</p>
        /// </li>
        /// </ul>
        pub fn scalable_dimension(mut self, input: crate::model::ScalableDimension) -> Self {
            self.inner = self.inner.scalable_dimension(input);
            self
        }
        pub fn set_scalable_dimension(
            mut self,
            input: std::option::Option<crate::model::ScalableDimension>,
        ) -> Self {
            self.inner = self.inner.set_scalable_dimension(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeregisterScalableTarget<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::deregister_scalable_target_input::Builder,
    }
    impl<C> DeregisterScalableTarget<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeregisterScalableTargetOutput,
            smithy_http::result::SdkError<crate::error::DeregisterScalableTargetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The namespace of the AWS service that provides the resource. For a resource provided
        /// by your own application or service, use <code>custom-resource</code> instead.</p>
        pub fn service_namespace(mut self, input: crate::model::ServiceNamespace) -> Self {
            self.inner = self.inner.service_namespace(input);
            self
        }
        pub fn set_service_namespace(
            mut self,
            input: std::option::Option<crate::model::ServiceNamespace>,
        ) -> Self {
            self.inner = self.inner.set_service_namespace(input);
            self
        }
        /// <p>The identifier of the resource associated with the scalable target.
        /// This string consists of the resource type and unique identifier.</p>
        /// <ul>
        /// <li>
        /// <p>ECS service - The resource type is <code>service</code> and the unique identifier is the cluster name  
        /// and service name. Example: <code>service/default/sample-webapp</code>.</p>
        /// </li>
        /// <li>
        /// <p>Spot Fleet request - The resource type is <code>spot-fleet-request</code> and the unique identifier is the
        /// Spot Fleet request ID. Example: <code>spot-fleet-request/sfr-73fbd2ce-aa30-494c-8788-1cee4EXAMPLE</code>.</p>
        /// </li>
        /// <li>
        /// <p>EMR cluster - The resource type is <code>instancegroup</code> and the unique identifier is the cluster ID and instance group ID.
        /// Example: <code>instancegroup/j-2EEZNYKUA1NTV/ig-1791Y4E1L8YI0</code>.</p>
        /// </li>
        /// <li>
        /// <p>AppStream 2.0 fleet - The resource type is <code>fleet</code> and the unique identifier is the fleet name.
        /// Example: <code>fleet/sample-fleet</code>.</p>
        /// </li>
        /// <li>
        /// <p>DynamoDB table - The resource type is <code>table</code> and the unique identifier is the table name.
        /// Example: <code>table/my-table</code>.</p>
        /// </li>
        /// <li>
        /// <p>DynamoDB global secondary index - The resource type is <code>index</code> and the unique identifier is the index name.
        /// Example: <code>table/my-table/index/my-table-index</code>.</p>
        /// </li>
        /// <li>
        /// <p>Aurora DB cluster - The resource type is <code>cluster</code> and the unique identifier is the cluster name.
        /// Example: <code>cluster:my-db-cluster</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon SageMaker endpoint variant - The resource type is <code>variant</code> and the unique identifier is the resource ID.
        /// Example: <code>endpoint/my-end-point/variant/KMeansClustering</code>.</p>
        /// </li>
        /// <li>
        /// <p>Custom resources are not supported with a resource type. This parameter must specify the <code>OutputValue</code> from the CloudFormation template stack used to access the resources. The unique identifier is defined by the service provider. More information
        /// is available in our <a href="https://github.com/aws/aws-auto-scaling-custom-resource">GitHub
        /// repository</a>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon Comprehend document classification endpoint - The resource type and unique identifier are specified using the endpoint ARN. Example: <code>arn:aws:comprehend:us-west-2:123456789012:document-classifier-endpoint/EXAMPLE</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon Comprehend entity recognizer endpoint - The resource type and unique identifier are specified using the endpoint ARN. Example: <code>arn:aws:comprehend:us-west-2:123456789012:entity-recognizer-endpoint/EXAMPLE</code>.</p>
        /// </li>
        /// <li>
        /// <p>Lambda provisioned concurrency - The resource type is <code>function</code> and the unique identifier is the function name with a function version or alias name suffix that is not <code>$LATEST</code>.
        /// Example: <code>function:my-function:prod</code> or <code>function:my-function:1</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon Keyspaces table - The resource type is <code>table</code> and the unique identifier is the table name.
        /// Example: <code>keyspace/mykeyspace/table/mytable</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon MSK cluster - The resource type and unique identifier are specified using the cluster ARN.
        /// Example: <code>arn:aws:kafka:us-east-1:123456789012:cluster/demo-cluster-1/6357e0b2-0e6a-4b86-a0b4-70df934c2e31-5</code>.</p>
        /// </li>
        /// </ul>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_id(input);
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_id(input);
            self
        }
        /// <p>The scalable dimension associated with the scalable target.
        /// This string consists of the service namespace, resource type, and scaling property.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ecs:service:DesiredCount</code> - The desired task count of an ECS service.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ec2:spot-fleet-request:TargetCapacity</code> - The target capacity of a Spot Fleet request.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>elasticmapreduce:instancegroup:InstanceCount</code> - The instance count of an EMR Instance Group.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>appstream:fleet:DesiredCapacity</code> - The desired capacity of an AppStream 2.0 fleet.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:table:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:table:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:index:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB global secondary index.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:index:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB global secondary index.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>rds:cluster:ReadReplicaCount</code> - The count of Aurora Replicas in an Aurora DB cluster. Available for Aurora MySQL-compatible edition and Aurora PostgreSQL-compatible edition.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>sagemaker:variant:DesiredInstanceCount</code> - The number of EC2 instances for an Amazon SageMaker model endpoint variant.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>custom-resource:ResourceType:Property</code> - The scalable dimension for a custom resource provided by your own application or service.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>comprehend:document-classifier-endpoint:DesiredInferenceUnits</code> - The number of inference units for an Amazon Comprehend document classification endpoint.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>comprehend:entity-recognizer-endpoint:DesiredInferenceUnits</code> - The number of inference units for an Amazon Comprehend entity recognizer endpoint.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>lambda:function:ProvisionedConcurrency</code> - The provisioned concurrency for a Lambda function.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>cassandra:table:ReadCapacityUnits</code> - The provisioned read capacity for an Amazon Keyspaces table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>cassandra:table:WriteCapacityUnits</code> -  The provisioned write capacity for an Amazon Keyspaces table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>kafka:broker-storage:VolumeSize</code> - The provisioned volume size (in GiB) for brokers in an Amazon MSK cluster.</p>
        /// </li>
        /// </ul>
        pub fn scalable_dimension(mut self, input: crate::model::ScalableDimension) -> Self {
            self.inner = self.inner.scalable_dimension(input);
            self
        }
        pub fn set_scalable_dimension(
            mut self,
            input: std::option::Option<crate::model::ScalableDimension>,
        ) -> Self {
            self.inner = self.inner.set_scalable_dimension(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeScalableTargets<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_scalable_targets_input::Builder,
    }
    impl<C> DescribeScalableTargets<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeScalableTargetsOutput,
            smithy_http::result::SdkError<crate::error::DescribeScalableTargetsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The namespace of the AWS service that provides the resource. For a resource provided
        /// by your own application or service, use <code>custom-resource</code> instead.</p>
        pub fn service_namespace(mut self, input: crate::model::ServiceNamespace) -> Self {
            self.inner = self.inner.service_namespace(input);
            self
        }
        pub fn set_service_namespace(
            mut self,
            input: std::option::Option<crate::model::ServiceNamespace>,
        ) -> Self {
            self.inner = self.inner.set_service_namespace(input);
            self
        }
        /// <p>The identifier of the resource associated with the scalable target.
        /// This string consists of the resource type and unique identifier.</p>
        /// <ul>
        /// <li>
        /// <p>ECS service - The resource type is <code>service</code> and the unique identifier is the cluster name  
        /// and service name. Example: <code>service/default/sample-webapp</code>.</p>
        /// </li>
        /// <li>
        /// <p>Spot Fleet request - The resource type is <code>spot-fleet-request</code> and the unique identifier is the
        /// Spot Fleet request ID. Example: <code>spot-fleet-request/sfr-73fbd2ce-aa30-494c-8788-1cee4EXAMPLE</code>.</p>
        /// </li>
        /// <li>
        /// <p>EMR cluster - The resource type is <code>instancegroup</code> and the unique identifier is the cluster ID and instance group ID.
        /// Example: <code>instancegroup/j-2EEZNYKUA1NTV/ig-1791Y4E1L8YI0</code>.</p>
        /// </li>
        /// <li>
        /// <p>AppStream 2.0 fleet - The resource type is <code>fleet</code> and the unique identifier is the fleet name.
        /// Example: <code>fleet/sample-fleet</code>.</p>
        /// </li>
        /// <li>
        /// <p>DynamoDB table - The resource type is <code>table</code> and the unique identifier is the table name.
        /// Example: <code>table/my-table</code>.</p>
        /// </li>
        /// <li>
        /// <p>DynamoDB global secondary index - The resource type is <code>index</code> and the unique identifier is the index name.
        /// Example: <code>table/my-table/index/my-table-index</code>.</p>
        /// </li>
        /// <li>
        /// <p>Aurora DB cluster - The resource type is <code>cluster</code> and the unique identifier is the cluster name.
        /// Example: <code>cluster:my-db-cluster</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon SageMaker endpoint variant - The resource type is <code>variant</code> and the unique identifier is the resource ID.
        /// Example: <code>endpoint/my-end-point/variant/KMeansClustering</code>.</p>
        /// </li>
        /// <li>
        /// <p>Custom resources are not supported with a resource type. This parameter must specify the <code>OutputValue</code> from the CloudFormation template stack used to access the resources. The unique identifier is defined by the service provider. More information
        /// is available in our <a href="https://github.com/aws/aws-auto-scaling-custom-resource">GitHub
        /// repository</a>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon Comprehend document classification endpoint - The resource type and unique identifier are specified using the endpoint ARN. Example: <code>arn:aws:comprehend:us-west-2:123456789012:document-classifier-endpoint/EXAMPLE</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon Comprehend entity recognizer endpoint - The resource type and unique identifier are specified using the endpoint ARN. Example: <code>arn:aws:comprehend:us-west-2:123456789012:entity-recognizer-endpoint/EXAMPLE</code>.</p>
        /// </li>
        /// <li>
        /// <p>Lambda provisioned concurrency - The resource type is <code>function</code> and the unique identifier is the function name with a function version or alias name suffix that is not <code>$LATEST</code>.
        /// Example: <code>function:my-function:prod</code> or <code>function:my-function:1</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon Keyspaces table - The resource type is <code>table</code> and the unique identifier is the table name.
        /// Example: <code>keyspace/mykeyspace/table/mytable</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon MSK cluster - The resource type and unique identifier are specified using the cluster ARN.
        /// Example: <code>arn:aws:kafka:us-east-1:123456789012:cluster/demo-cluster-1/6357e0b2-0e6a-4b86-a0b4-70df934c2e31-5</code>.</p>
        /// </li>
        /// </ul>
        pub fn resource_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_ids(inp);
            self
        }
        pub fn set_resource_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_resource_ids(input);
            self
        }
        /// <p>The scalable dimension associated with the scalable target.
        /// This string consists of the service namespace, resource type, and scaling property. If you specify a scalable dimension, you must also specify a resource ID.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ecs:service:DesiredCount</code> - The desired task count of an ECS service.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ec2:spot-fleet-request:TargetCapacity</code> - The target capacity of a Spot Fleet request.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>elasticmapreduce:instancegroup:InstanceCount</code> - The instance count of an EMR Instance Group.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>appstream:fleet:DesiredCapacity</code> - The desired capacity of an AppStream 2.0 fleet.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:table:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:table:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:index:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB global secondary index.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:index:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB global secondary index.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>rds:cluster:ReadReplicaCount</code> - The count of Aurora Replicas in an Aurora DB cluster. Available for Aurora MySQL-compatible edition and Aurora PostgreSQL-compatible edition.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>sagemaker:variant:DesiredInstanceCount</code> - The number of EC2 instances for an Amazon SageMaker model endpoint variant.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>custom-resource:ResourceType:Property</code> - The scalable dimension for a custom resource provided by your own application or service.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>comprehend:document-classifier-endpoint:DesiredInferenceUnits</code> - The number of inference units for an Amazon Comprehend document classification endpoint.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>comprehend:entity-recognizer-endpoint:DesiredInferenceUnits</code> - The number of inference units for an Amazon Comprehend entity recognizer endpoint.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>lambda:function:ProvisionedConcurrency</code> - The provisioned concurrency for a Lambda function.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>cassandra:table:ReadCapacityUnits</code> - The provisioned read capacity for an Amazon Keyspaces table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>cassandra:table:WriteCapacityUnits</code> -  The provisioned write capacity for an Amazon Keyspaces table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>kafka:broker-storage:VolumeSize</code> - The provisioned volume size (in GiB) for brokers in an Amazon MSK cluster.</p>
        /// </li>
        /// </ul>
        pub fn scalable_dimension(mut self, input: crate::model::ScalableDimension) -> Self {
            self.inner = self.inner.scalable_dimension(input);
            self
        }
        pub fn set_scalable_dimension(
            mut self,
            input: std::option::Option<crate::model::ScalableDimension>,
        ) -> Self {
            self.inner = self.inner.set_scalable_dimension(input);
            self
        }
        /// <p>The maximum number of scalable targets. This value can be between 1 and
        /// 50. The default value is 50.</p>
        /// <p>If this parameter is used, the operation returns up to <code>MaxResults</code> results
        /// at a time, along with a <code>NextToken</code> value. To get the next set of results,
        /// include the <code>NextToken</code> value in a subsequent call. If this parameter is not
        /// used, the operation returns up to 50 results and a
        /// <code>NextToken</code> value, if applicable.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeScalingActivities<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_scaling_activities_input::Builder,
    }
    impl<C> DescribeScalingActivities<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeScalingActivitiesOutput,
            smithy_http::result::SdkError<crate::error::DescribeScalingActivitiesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The namespace of the AWS service that provides the resource. For a resource provided
        /// by your own application or service, use <code>custom-resource</code> instead.</p>
        pub fn service_namespace(mut self, input: crate::model::ServiceNamespace) -> Self {
            self.inner = self.inner.service_namespace(input);
            self
        }
        pub fn set_service_namespace(
            mut self,
            input: std::option::Option<crate::model::ServiceNamespace>,
        ) -> Self {
            self.inner = self.inner.set_service_namespace(input);
            self
        }
        /// <p>The identifier of the resource associated with the scaling activity.
        /// This string consists of the resource type and unique identifier.</p>
        /// <ul>
        /// <li>
        /// <p>ECS service - The resource type is <code>service</code> and the unique identifier is the cluster name  
        /// and service name. Example: <code>service/default/sample-webapp</code>.</p>
        /// </li>
        /// <li>
        /// <p>Spot Fleet request - The resource type is <code>spot-fleet-request</code> and the unique identifier is the
        /// Spot Fleet request ID. Example: <code>spot-fleet-request/sfr-73fbd2ce-aa30-494c-8788-1cee4EXAMPLE</code>.</p>
        /// </li>
        /// <li>
        /// <p>EMR cluster - The resource type is <code>instancegroup</code> and the unique identifier is the cluster ID and instance group ID.
        /// Example: <code>instancegroup/j-2EEZNYKUA1NTV/ig-1791Y4E1L8YI0</code>.</p>
        /// </li>
        /// <li>
        /// <p>AppStream 2.0 fleet - The resource type is <code>fleet</code> and the unique identifier is the fleet name.
        /// Example: <code>fleet/sample-fleet</code>.</p>
        /// </li>
        /// <li>
        /// <p>DynamoDB table - The resource type is <code>table</code> and the unique identifier is the table name.
        /// Example: <code>table/my-table</code>.</p>
        /// </li>
        /// <li>
        /// <p>DynamoDB global secondary index - The resource type is <code>index</code> and the unique identifier is the index name.
        /// Example: <code>table/my-table/index/my-table-index</code>.</p>
        /// </li>
        /// <li>
        /// <p>Aurora DB cluster - The resource type is <code>cluster</code> and the unique identifier is the cluster name.
        /// Example: <code>cluster:my-db-cluster</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon SageMaker endpoint variant - The resource type is <code>variant</code> and the unique identifier is the resource ID.
        /// Example: <code>endpoint/my-end-point/variant/KMeansClustering</code>.</p>
        /// </li>
        /// <li>
        /// <p>Custom resources are not supported with a resource type. This parameter must specify the <code>OutputValue</code> from the CloudFormation template stack used to access the resources. The unique identifier is defined by the service provider. More information
        /// is available in our <a href="https://github.com/aws/aws-auto-scaling-custom-resource">GitHub
        /// repository</a>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon Comprehend document classification endpoint - The resource type and unique identifier are specified using the endpoint ARN. Example: <code>arn:aws:comprehend:us-west-2:123456789012:document-classifier-endpoint/EXAMPLE</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon Comprehend entity recognizer endpoint - The resource type and unique identifier are specified using the endpoint ARN. Example: <code>arn:aws:comprehend:us-west-2:123456789012:entity-recognizer-endpoint/EXAMPLE</code>.</p>
        /// </li>
        /// <li>
        /// <p>Lambda provisioned concurrency - The resource type is <code>function</code> and the unique identifier is the function name with a function version or alias name suffix that is not <code>$LATEST</code>.
        /// Example: <code>function:my-function:prod</code> or <code>function:my-function:1</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon Keyspaces table - The resource type is <code>table</code> and the unique identifier is the table name.
        /// Example: <code>keyspace/mykeyspace/table/mytable</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon MSK cluster - The resource type and unique identifier are specified using the cluster ARN.
        /// Example: <code>arn:aws:kafka:us-east-1:123456789012:cluster/demo-cluster-1/6357e0b2-0e6a-4b86-a0b4-70df934c2e31-5</code>.</p>
        /// </li>
        /// </ul>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_id(input);
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_id(input);
            self
        }
        /// <p>The scalable dimension. This string consists of the service namespace, resource type, and scaling property.
        /// If you specify a scalable dimension, you must also specify a resource ID.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ecs:service:DesiredCount</code> - The desired task count of an ECS service.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ec2:spot-fleet-request:TargetCapacity</code> - The target capacity of a Spot Fleet request.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>elasticmapreduce:instancegroup:InstanceCount</code> - The instance count of an EMR Instance Group.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>appstream:fleet:DesiredCapacity</code> - The desired capacity of an AppStream 2.0 fleet.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:table:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:table:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:index:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB global secondary index.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:index:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB global secondary index.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>rds:cluster:ReadReplicaCount</code> - The count of Aurora Replicas in an Aurora DB cluster. Available for Aurora MySQL-compatible edition and Aurora PostgreSQL-compatible edition.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>sagemaker:variant:DesiredInstanceCount</code> - The number of EC2 instances for an Amazon SageMaker model endpoint variant.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>custom-resource:ResourceType:Property</code> - The scalable dimension for a custom resource provided by your own application or service.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>comprehend:document-classifier-endpoint:DesiredInferenceUnits</code> - The number of inference units for an Amazon Comprehend document classification endpoint.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>comprehend:entity-recognizer-endpoint:DesiredInferenceUnits</code> - The number of inference units for an Amazon Comprehend entity recognizer endpoint.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>lambda:function:ProvisionedConcurrency</code> - The provisioned concurrency for a Lambda function.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>cassandra:table:ReadCapacityUnits</code> - The provisioned read capacity for an Amazon Keyspaces table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>cassandra:table:WriteCapacityUnits</code> -  The provisioned write capacity for an Amazon Keyspaces table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>kafka:broker-storage:VolumeSize</code> - The provisioned volume size (in GiB) for brokers in an Amazon MSK cluster.</p>
        /// </li>
        /// </ul>
        pub fn scalable_dimension(mut self, input: crate::model::ScalableDimension) -> Self {
            self.inner = self.inner.scalable_dimension(input);
            self
        }
        pub fn set_scalable_dimension(
            mut self,
            input: std::option::Option<crate::model::ScalableDimension>,
        ) -> Self {
            self.inner = self.inner.set_scalable_dimension(input);
            self
        }
        /// <p>The maximum number of scalable targets. This value can be between 1 and
        /// 50. The default value is 50.</p>
        /// <p>If this parameter is used, the operation returns up to <code>MaxResults</code> results
        /// at a time, along with a <code>NextToken</code> value. To get the next set of results,
        /// include the <code>NextToken</code> value in a subsequent call. If this parameter is not
        /// used, the operation returns up to 50 results and a
        /// <code>NextToken</code> value, if applicable.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeScalingPolicies<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_scaling_policies_input::Builder,
    }
    impl<C> DescribeScalingPolicies<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeScalingPoliciesOutput,
            smithy_http::result::SdkError<crate::error::DescribeScalingPoliciesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The names of the scaling policies to describe.</p>
        pub fn policy_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_names(inp);
            self
        }
        pub fn set_policy_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_policy_names(input);
            self
        }
        /// <p>The namespace of the AWS service that provides the resource. For a resource provided
        /// by your own application or service, use <code>custom-resource</code> instead.</p>
        pub fn service_namespace(mut self, input: crate::model::ServiceNamespace) -> Self {
            self.inner = self.inner.service_namespace(input);
            self
        }
        pub fn set_service_namespace(
            mut self,
            input: std::option::Option<crate::model::ServiceNamespace>,
        ) -> Self {
            self.inner = self.inner.set_service_namespace(input);
            self
        }
        /// <p>The identifier of the resource associated with the scaling policy.
        /// This string consists of the resource type and unique identifier.</p>
        /// <ul>
        /// <li>
        /// <p>ECS service - The resource type is <code>service</code> and the unique identifier is the cluster name  
        /// and service name. Example: <code>service/default/sample-webapp</code>.</p>
        /// </li>
        /// <li>
        /// <p>Spot Fleet request - The resource type is <code>spot-fleet-request</code> and the unique identifier is the
        /// Spot Fleet request ID. Example: <code>spot-fleet-request/sfr-73fbd2ce-aa30-494c-8788-1cee4EXAMPLE</code>.</p>
        /// </li>
        /// <li>
        /// <p>EMR cluster - The resource type is <code>instancegroup</code> and the unique identifier is the cluster ID and instance group ID.
        /// Example: <code>instancegroup/j-2EEZNYKUA1NTV/ig-1791Y4E1L8YI0</code>.</p>
        /// </li>
        /// <li>
        /// <p>AppStream 2.0 fleet - The resource type is <code>fleet</code> and the unique identifier is the fleet name.
        /// Example: <code>fleet/sample-fleet</code>.</p>
        /// </li>
        /// <li>
        /// <p>DynamoDB table - The resource type is <code>table</code> and the unique identifier is the table name.
        /// Example: <code>table/my-table</code>.</p>
        /// </li>
        /// <li>
        /// <p>DynamoDB global secondary index - The resource type is <code>index</code> and the unique identifier is the index name.
        /// Example: <code>table/my-table/index/my-table-index</code>.</p>
        /// </li>
        /// <li>
        /// <p>Aurora DB cluster - The resource type is <code>cluster</code> and the unique identifier is the cluster name.
        /// Example: <code>cluster:my-db-cluster</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon SageMaker endpoint variant - The resource type is <code>variant</code> and the unique identifier is the resource ID.
        /// Example: <code>endpoint/my-end-point/variant/KMeansClustering</code>.</p>
        /// </li>
        /// <li>
        /// <p>Custom resources are not supported with a resource type. This parameter must specify the <code>OutputValue</code> from the CloudFormation template stack used to access the resources. The unique identifier is defined by the service provider. More information
        /// is available in our <a href="https://github.com/aws/aws-auto-scaling-custom-resource">GitHub
        /// repository</a>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon Comprehend document classification endpoint - The resource type and unique identifier are specified using the endpoint ARN. Example: <code>arn:aws:comprehend:us-west-2:123456789012:document-classifier-endpoint/EXAMPLE</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon Comprehend entity recognizer endpoint - The resource type and unique identifier are specified using the endpoint ARN. Example: <code>arn:aws:comprehend:us-west-2:123456789012:entity-recognizer-endpoint/EXAMPLE</code>.</p>
        /// </li>
        /// <li>
        /// <p>Lambda provisioned concurrency - The resource type is <code>function</code> and the unique identifier is the function name with a function version or alias name suffix that is not <code>$LATEST</code>.
        /// Example: <code>function:my-function:prod</code> or <code>function:my-function:1</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon Keyspaces table - The resource type is <code>table</code> and the unique identifier is the table name.
        /// Example: <code>keyspace/mykeyspace/table/mytable</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon MSK cluster - The resource type and unique identifier are specified using the cluster ARN.
        /// Example: <code>arn:aws:kafka:us-east-1:123456789012:cluster/demo-cluster-1/6357e0b2-0e6a-4b86-a0b4-70df934c2e31-5</code>.</p>
        /// </li>
        /// </ul>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_id(input);
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_id(input);
            self
        }
        /// <p>The scalable dimension. This string consists of the service namespace, resource type, and scaling property.
        /// If you specify a scalable dimension, you must also specify a resource ID.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ecs:service:DesiredCount</code> - The desired task count of an ECS service.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ec2:spot-fleet-request:TargetCapacity</code> - The target capacity of a Spot Fleet request.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>elasticmapreduce:instancegroup:InstanceCount</code> - The instance count of an EMR Instance Group.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>appstream:fleet:DesiredCapacity</code> - The desired capacity of an AppStream 2.0 fleet.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:table:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:table:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:index:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB global secondary index.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:index:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB global secondary index.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>rds:cluster:ReadReplicaCount</code> - The count of Aurora Replicas in an Aurora DB cluster. Available for Aurora MySQL-compatible edition and Aurora PostgreSQL-compatible edition.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>sagemaker:variant:DesiredInstanceCount</code> - The number of EC2 instances for an Amazon SageMaker model endpoint variant.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>custom-resource:ResourceType:Property</code> - The scalable dimension for a custom resource provided by your own application or service.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>comprehend:document-classifier-endpoint:DesiredInferenceUnits</code> - The number of inference units for an Amazon Comprehend document classification endpoint.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>comprehend:entity-recognizer-endpoint:DesiredInferenceUnits</code> - The number of inference units for an Amazon Comprehend entity recognizer endpoint.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>lambda:function:ProvisionedConcurrency</code> - The provisioned concurrency for a Lambda function.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>cassandra:table:ReadCapacityUnits</code> - The provisioned read capacity for an Amazon Keyspaces table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>cassandra:table:WriteCapacityUnits</code> -  The provisioned write capacity for an Amazon Keyspaces table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>kafka:broker-storage:VolumeSize</code> - The provisioned volume size (in GiB) for brokers in an Amazon MSK cluster.</p>
        /// </li>
        /// </ul>
        pub fn scalable_dimension(mut self, input: crate::model::ScalableDimension) -> Self {
            self.inner = self.inner.scalable_dimension(input);
            self
        }
        pub fn set_scalable_dimension(
            mut self,
            input: std::option::Option<crate::model::ScalableDimension>,
        ) -> Self {
            self.inner = self.inner.set_scalable_dimension(input);
            self
        }
        /// <p>The maximum number of scalable targets. This value can be between 1 and
        /// 50. The default value is 50.</p>
        /// <p>If this parameter is used, the operation returns up to <code>MaxResults</code> results
        /// at a time, along with a <code>NextToken</code> value. To get the next set of results,
        /// include the <code>NextToken</code> value in a subsequent call. If this parameter is not
        /// used, the operation returns up to 50 results and a
        /// <code>NextToken</code> value, if applicable.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeScheduledActions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_scheduled_actions_input::Builder,
    }
    impl<C> DescribeScheduledActions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeScheduledActionsOutput,
            smithy_http::result::SdkError<crate::error::DescribeScheduledActionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The names of the scheduled actions to describe.</p>
        pub fn scheduled_action_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.scheduled_action_names(inp);
            self
        }
        pub fn set_scheduled_action_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_scheduled_action_names(input);
            self
        }
        /// <p>The namespace of the AWS service that provides the resource. For a resource provided
        /// by your own application or service, use <code>custom-resource</code> instead.</p>
        pub fn service_namespace(mut self, input: crate::model::ServiceNamespace) -> Self {
            self.inner = self.inner.service_namespace(input);
            self
        }
        pub fn set_service_namespace(
            mut self,
            input: std::option::Option<crate::model::ServiceNamespace>,
        ) -> Self {
            self.inner = self.inner.set_service_namespace(input);
            self
        }
        /// <p>The identifier of the resource associated with the scheduled action.
        /// This string consists of the resource type and unique identifier.</p>
        /// <ul>
        /// <li>
        /// <p>ECS service - The resource type is <code>service</code> and the unique identifier is the cluster name  
        /// and service name. Example: <code>service/default/sample-webapp</code>.</p>
        /// </li>
        /// <li>
        /// <p>Spot Fleet request - The resource type is <code>spot-fleet-request</code> and the unique identifier is the
        /// Spot Fleet request ID. Example: <code>spot-fleet-request/sfr-73fbd2ce-aa30-494c-8788-1cee4EXAMPLE</code>.</p>
        /// </li>
        /// <li>
        /// <p>EMR cluster - The resource type is <code>instancegroup</code> and the unique identifier is the cluster ID and instance group ID.
        /// Example: <code>instancegroup/j-2EEZNYKUA1NTV/ig-1791Y4E1L8YI0</code>.</p>
        /// </li>
        /// <li>
        /// <p>AppStream 2.0 fleet - The resource type is <code>fleet</code> and the unique identifier is the fleet name.
        /// Example: <code>fleet/sample-fleet</code>.</p>
        /// </li>
        /// <li>
        /// <p>DynamoDB table - The resource type is <code>table</code> and the unique identifier is the table name.
        /// Example: <code>table/my-table</code>.</p>
        /// </li>
        /// <li>
        /// <p>DynamoDB global secondary index - The resource type is <code>index</code> and the unique identifier is the index name.
        /// Example: <code>table/my-table/index/my-table-index</code>.</p>
        /// </li>
        /// <li>
        /// <p>Aurora DB cluster - The resource type is <code>cluster</code> and the unique identifier is the cluster name.
        /// Example: <code>cluster:my-db-cluster</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon SageMaker endpoint variant - The resource type is <code>variant</code> and the unique identifier is the resource ID.
        /// Example: <code>endpoint/my-end-point/variant/KMeansClustering</code>.</p>
        /// </li>
        /// <li>
        /// <p>Custom resources are not supported with a resource type. This parameter must specify the <code>OutputValue</code> from the CloudFormation template stack used to access the resources. The unique identifier is defined by the service provider. More information
        /// is available in our <a href="https://github.com/aws/aws-auto-scaling-custom-resource">GitHub
        /// repository</a>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon Comprehend document classification endpoint - The resource type and unique identifier are specified using the endpoint ARN. Example: <code>arn:aws:comprehend:us-west-2:123456789012:document-classifier-endpoint/EXAMPLE</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon Comprehend entity recognizer endpoint - The resource type and unique identifier are specified using the endpoint ARN. Example: <code>arn:aws:comprehend:us-west-2:123456789012:entity-recognizer-endpoint/EXAMPLE</code>.</p>
        /// </li>
        /// <li>
        /// <p>Lambda provisioned concurrency - The resource type is <code>function</code> and the unique identifier is the function name with a function version or alias name suffix that is not <code>$LATEST</code>.
        /// Example: <code>function:my-function:prod</code> or <code>function:my-function:1</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon Keyspaces table - The resource type is <code>table</code> and the unique identifier is the table name.
        /// Example: <code>keyspace/mykeyspace/table/mytable</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon MSK cluster - The resource type and unique identifier are specified using the cluster ARN.
        /// Example: <code>arn:aws:kafka:us-east-1:123456789012:cluster/demo-cluster-1/6357e0b2-0e6a-4b86-a0b4-70df934c2e31-5</code>.</p>
        /// </li>
        /// </ul>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_id(input);
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_id(input);
            self
        }
        /// <p>The scalable dimension. This string consists of the service namespace, resource type, and scaling property.
        /// If you specify a scalable dimension, you must also specify a resource ID.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ecs:service:DesiredCount</code> - The desired task count of an ECS service.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ec2:spot-fleet-request:TargetCapacity</code> - The target capacity of a Spot Fleet request.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>elasticmapreduce:instancegroup:InstanceCount</code> - The instance count of an EMR Instance Group.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>appstream:fleet:DesiredCapacity</code> - The desired capacity of an AppStream 2.0 fleet.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:table:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:table:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:index:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB global secondary index.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:index:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB global secondary index.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>rds:cluster:ReadReplicaCount</code> - The count of Aurora Replicas in an Aurora DB cluster. Available for Aurora MySQL-compatible edition and Aurora PostgreSQL-compatible edition.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>sagemaker:variant:DesiredInstanceCount</code> - The number of EC2 instances for an Amazon SageMaker model endpoint variant.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>custom-resource:ResourceType:Property</code> - The scalable dimension for a custom resource provided by your own application or service.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>comprehend:document-classifier-endpoint:DesiredInferenceUnits</code> - The number of inference units for an Amazon Comprehend document classification endpoint.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>comprehend:entity-recognizer-endpoint:DesiredInferenceUnits</code> - The number of inference units for an Amazon Comprehend entity recognizer endpoint.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>lambda:function:ProvisionedConcurrency</code> - The provisioned concurrency for a Lambda function.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>cassandra:table:ReadCapacityUnits</code> - The provisioned read capacity for an Amazon Keyspaces table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>cassandra:table:WriteCapacityUnits</code> -  The provisioned write capacity for an Amazon Keyspaces table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>kafka:broker-storage:VolumeSize</code> - The provisioned volume size (in GiB) for brokers in an Amazon MSK cluster.</p>
        /// </li>
        /// </ul>
        pub fn scalable_dimension(mut self, input: crate::model::ScalableDimension) -> Self {
            self.inner = self.inner.scalable_dimension(input);
            self
        }
        pub fn set_scalable_dimension(
            mut self,
            input: std::option::Option<crate::model::ScalableDimension>,
        ) -> Self {
            self.inner = self.inner.set_scalable_dimension(input);
            self
        }
        /// <p>The maximum number of scheduled action results. This value can be between
        /// 1 and 50. The default value is 50.</p>
        /// <p>If this parameter is used, the operation returns up to <code>MaxResults</code> results
        /// at a time, along with a <code>NextToken</code> value. To get the next set of results,
        /// include the <code>NextToken</code> value in a subsequent call. If this parameter is not
        /// used, the operation returns up to 50 results and a
        /// <code>NextToken</code> value, if applicable.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutScalingPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_scaling_policy_input::Builder,
    }
    impl<C> PutScalingPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutScalingPolicyOutput,
            smithy_http::result::SdkError<crate::error::PutScalingPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the scaling policy.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(input);
            self
        }
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(input);
            self
        }
        /// <p>The namespace of the AWS service that provides the resource. For a resource provided
        /// by your own application or service, use <code>custom-resource</code> instead.</p>
        pub fn service_namespace(mut self, input: crate::model::ServiceNamespace) -> Self {
            self.inner = self.inner.service_namespace(input);
            self
        }
        pub fn set_service_namespace(
            mut self,
            input: std::option::Option<crate::model::ServiceNamespace>,
        ) -> Self {
            self.inner = self.inner.set_service_namespace(input);
            self
        }
        /// <p>The identifier of the resource associated with the scaling policy.
        /// This string consists of the resource type and unique identifier.</p>
        /// <ul>
        /// <li>
        /// <p>ECS service - The resource type is <code>service</code> and the unique identifier is the cluster name  
        /// and service name. Example: <code>service/default/sample-webapp</code>.</p>
        /// </li>
        /// <li>
        /// <p>Spot Fleet request - The resource type is <code>spot-fleet-request</code> and the unique identifier is the
        /// Spot Fleet request ID. Example: <code>spot-fleet-request/sfr-73fbd2ce-aa30-494c-8788-1cee4EXAMPLE</code>.</p>
        /// </li>
        /// <li>
        /// <p>EMR cluster - The resource type is <code>instancegroup</code> and the unique identifier is the cluster ID and instance group ID.
        /// Example: <code>instancegroup/j-2EEZNYKUA1NTV/ig-1791Y4E1L8YI0</code>.</p>
        /// </li>
        /// <li>
        /// <p>AppStream 2.0 fleet - The resource type is <code>fleet</code> and the unique identifier is the fleet name.
        /// Example: <code>fleet/sample-fleet</code>.</p>
        /// </li>
        /// <li>
        /// <p>DynamoDB table - The resource type is <code>table</code> and the unique identifier is the table name.
        /// Example: <code>table/my-table</code>.</p>
        /// </li>
        /// <li>
        /// <p>DynamoDB global secondary index - The resource type is <code>index</code> and the unique identifier is the index name.
        /// Example: <code>table/my-table/index/my-table-index</code>.</p>
        /// </li>
        /// <li>
        /// <p>Aurora DB cluster - The resource type is <code>cluster</code> and the unique identifier is the cluster name.
        /// Example: <code>cluster:my-db-cluster</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon SageMaker endpoint variant - The resource type is <code>variant</code> and the unique identifier is the resource ID.
        /// Example: <code>endpoint/my-end-point/variant/KMeansClustering</code>.</p>
        /// </li>
        /// <li>
        /// <p>Custom resources are not supported with a resource type. This parameter must specify the <code>OutputValue</code> from the CloudFormation template stack used to access the resources. The unique identifier is defined by the service provider. More information
        /// is available in our <a href="https://github.com/aws/aws-auto-scaling-custom-resource">GitHub
        /// repository</a>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon Comprehend document classification endpoint - The resource type and unique identifier are specified using the endpoint ARN. Example: <code>arn:aws:comprehend:us-west-2:123456789012:document-classifier-endpoint/EXAMPLE</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon Comprehend entity recognizer endpoint - The resource type and unique identifier are specified using the endpoint ARN. Example: <code>arn:aws:comprehend:us-west-2:123456789012:entity-recognizer-endpoint/EXAMPLE</code>.</p>
        /// </li>
        /// <li>
        /// <p>Lambda provisioned concurrency - The resource type is <code>function</code> and the unique identifier is the function name with a function version or alias name suffix that is not <code>$LATEST</code>.
        /// Example: <code>function:my-function:prod</code> or <code>function:my-function:1</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon Keyspaces table - The resource type is <code>table</code> and the unique identifier is the table name.
        /// Example: <code>keyspace/mykeyspace/table/mytable</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon MSK cluster - The resource type and unique identifier are specified using the cluster ARN.
        /// Example: <code>arn:aws:kafka:us-east-1:123456789012:cluster/demo-cluster-1/6357e0b2-0e6a-4b86-a0b4-70df934c2e31-5</code>.</p>
        /// </li>
        /// </ul>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_id(input);
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_id(input);
            self
        }
        /// <p>The scalable dimension. This string consists of the service namespace, resource type, and scaling property.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ecs:service:DesiredCount</code> - The desired task count of an ECS service.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ec2:spot-fleet-request:TargetCapacity</code> - The target capacity of a Spot Fleet request.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>elasticmapreduce:instancegroup:InstanceCount</code> - The instance count of an EMR Instance Group.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>appstream:fleet:DesiredCapacity</code> - The desired capacity of an AppStream 2.0 fleet.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:table:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:table:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:index:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB global secondary index.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:index:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB global secondary index.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>rds:cluster:ReadReplicaCount</code> - The count of Aurora Replicas in an Aurora DB cluster. Available for Aurora MySQL-compatible edition and Aurora PostgreSQL-compatible edition.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>sagemaker:variant:DesiredInstanceCount</code> - The number of EC2 instances for an Amazon SageMaker model endpoint variant.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>custom-resource:ResourceType:Property</code> - The scalable dimension for a custom resource provided by your own application or service.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>comprehend:document-classifier-endpoint:DesiredInferenceUnits</code> - The number of inference units for an Amazon Comprehend document classification endpoint.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>comprehend:entity-recognizer-endpoint:DesiredInferenceUnits</code> - The number of inference units for an Amazon Comprehend entity recognizer endpoint.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>lambda:function:ProvisionedConcurrency</code> - The provisioned concurrency for a Lambda function.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>cassandra:table:ReadCapacityUnits</code> - The provisioned read capacity for an Amazon Keyspaces table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>cassandra:table:WriteCapacityUnits</code> -  The provisioned write capacity for an Amazon Keyspaces table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>kafka:broker-storage:VolumeSize</code> - The provisioned volume size (in GiB) for brokers in an Amazon MSK cluster.</p>
        /// </li>
        /// </ul>
        pub fn scalable_dimension(mut self, input: crate::model::ScalableDimension) -> Self {
            self.inner = self.inner.scalable_dimension(input);
            self
        }
        pub fn set_scalable_dimension(
            mut self,
            input: std::option::Option<crate::model::ScalableDimension>,
        ) -> Self {
            self.inner = self.inner.set_scalable_dimension(input);
            self
        }
        /// <p>The policy type. This parameter is required if you are creating a scaling policy.</p>
        /// <p>The following policy types are supported: </p>
        /// <p>
        /// <code>TargetTrackingScaling</code>Not supported for Amazon EMR</p>
        /// <p>
        /// <code>StepScaling</code>Not supported for DynamoDB, Amazon Comprehend, Lambda, Amazon Keyspaces (for
        /// Apache Cassandra), or Amazon MSK.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/application/userguide/application-auto-scaling-target-tracking.html">Target
        /// tracking scaling policies</a> and <a href="https://docs.aws.amazon.com/autoscaling/application/userguide/application-auto-scaling-step-scaling-policies.html">Step scaling policies</a> in the <i>Application Auto Scaling User Guide</i>.</p>
        pub fn policy_type(mut self, input: crate::model::PolicyType) -> Self {
            self.inner = self.inner.policy_type(input);
            self
        }
        pub fn set_policy_type(
            mut self,
            input: std::option::Option<crate::model::PolicyType>,
        ) -> Self {
            self.inner = self.inner.set_policy_type(input);
            self
        }
        /// <p>A step scaling policy.</p>
        /// <p>This parameter is required if you are creating a policy and the policy type is
        /// <code>StepScaling</code>.</p>
        pub fn step_scaling_policy_configuration(
            mut self,
            input: crate::model::StepScalingPolicyConfiguration,
        ) -> Self {
            self.inner = self.inner.step_scaling_policy_configuration(input);
            self
        }
        pub fn set_step_scaling_policy_configuration(
            mut self,
            input: std::option::Option<crate::model::StepScalingPolicyConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_step_scaling_policy_configuration(input);
            self
        }
        /// <p>A target tracking scaling policy. Includes support for predefined or customized
        /// metrics.</p>
        /// <p>This parameter is required if you are creating a policy and the policy type is
        /// <code>TargetTrackingScaling</code>.</p>
        pub fn target_tracking_scaling_policy_configuration(
            mut self,
            input: crate::model::TargetTrackingScalingPolicyConfiguration,
        ) -> Self {
            self.inner = self
                .inner
                .target_tracking_scaling_policy_configuration(input);
            self
        }
        pub fn set_target_tracking_scaling_policy_configuration(
            mut self,
            input: std::option::Option<crate::model::TargetTrackingScalingPolicyConfiguration>,
        ) -> Self {
            self.inner = self
                .inner
                .set_target_tracking_scaling_policy_configuration(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutScheduledAction<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_scheduled_action_input::Builder,
    }
    impl<C> PutScheduledAction<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutScheduledActionOutput,
            smithy_http::result::SdkError<crate::error::PutScheduledActionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The namespace of the AWS service that provides the resource. For a resource provided
        /// by your own application or service, use <code>custom-resource</code> instead.</p>
        pub fn service_namespace(mut self, input: crate::model::ServiceNamespace) -> Self {
            self.inner = self.inner.service_namespace(input);
            self
        }
        pub fn set_service_namespace(
            mut self,
            input: std::option::Option<crate::model::ServiceNamespace>,
        ) -> Self {
            self.inner = self.inner.set_service_namespace(input);
            self
        }
        /// <p>The schedule for this action. The following formats are supported:</p>
        /// <ul>
        /// <li>
        /// <p>At expressions - "<code>at(<i>yyyy</i>-<i>mm</i>-<i>dd</i>T<i>hh</i>:<i>mm</i>:<i>ss</i>)</code>"</p>
        /// </li>
        /// <li>
        /// <p>Rate expressions - "<code>rate(<i>value</i>
        /// <i>unit</i>)</code>"</p>
        /// </li>
        /// <li>
        /// <p>Cron expressions - "<code>cron(<i>fields</i>)</code>"</p>
        /// </li>
        /// </ul>
        /// <p>At expressions are useful for one-time schedules. Cron expressions are useful for
        /// scheduled actions that run periodically at a specified date and time, and rate expressions
        /// are useful for scheduled actions that run at a regular interval.</p>
        /// <p>At and cron expressions use Universal Coordinated Time (UTC) by
        /// default.</p>
        /// <p>The cron format consists of six fields separated by white spaces: [Minutes] [Hours] [Day_of_Month] [Month] [Day_of_Week] [Year].</p>
        /// <p>For rate expressions, <i>value</i> is a positive integer and <i>unit</i> is
        /// <code>minute</code> | <code>minutes</code> | <code>hour</code> | <code>hours</code> | <code>day</code> | <code>days</code>.</p>
        /// <p>For more information and examples, see <a href="https://docs.aws.amazon.com/autoscaling/application/userguide/examples-scheduled-actions.html">Example scheduled actions for Application Auto Scaling</a> in the <i>Application Auto Scaling User Guide</i>.</p>
        pub fn schedule(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.schedule(input);
            self
        }
        pub fn set_schedule(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_schedule(input);
            self
        }
        /// <p>Specifies the time zone used when setting a scheduled action by using an at or cron
        /// expression. If a time zone is not provided, UTC is used by default.</p>
        /// <p>Valid values are the canonical names of the IANA time zones supported by Joda-Time (such
        /// as <code>Etc/GMT+9</code> or <code>Pacific/Tahiti</code>). For more information, see <a href="https://www.joda.org/joda-time/timezones.html">https://www.joda.org/joda-time/timezones.html</a>.</p>
        pub fn timezone(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.timezone(input);
            self
        }
        pub fn set_timezone(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_timezone(input);
            self
        }
        /// <p>The name of the scheduled action. This name must be unique among all other scheduled
        /// actions on the specified scalable target. </p>
        pub fn scheduled_action_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.scheduled_action_name(input);
            self
        }
        pub fn set_scheduled_action_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_scheduled_action_name(input);
            self
        }
        /// <p>The identifier of the resource associated with the scheduled action.
        /// This string consists of the resource type and unique identifier.</p>
        /// <ul>
        /// <li>
        /// <p>ECS service - The resource type is <code>service</code> and the unique identifier is the cluster name  
        /// and service name. Example: <code>service/default/sample-webapp</code>.</p>
        /// </li>
        /// <li>
        /// <p>Spot Fleet request - The resource type is <code>spot-fleet-request</code> and the unique identifier is the
        /// Spot Fleet request ID. Example: <code>spot-fleet-request/sfr-73fbd2ce-aa30-494c-8788-1cee4EXAMPLE</code>.</p>
        /// </li>
        /// <li>
        /// <p>EMR cluster - The resource type is <code>instancegroup</code> and the unique identifier is the cluster ID and instance group ID.
        /// Example: <code>instancegroup/j-2EEZNYKUA1NTV/ig-1791Y4E1L8YI0</code>.</p>
        /// </li>
        /// <li>
        /// <p>AppStream 2.0 fleet - The resource type is <code>fleet</code> and the unique identifier is the fleet name.
        /// Example: <code>fleet/sample-fleet</code>.</p>
        /// </li>
        /// <li>
        /// <p>DynamoDB table - The resource type is <code>table</code> and the unique identifier is the table name.
        /// Example: <code>table/my-table</code>.</p>
        /// </li>
        /// <li>
        /// <p>DynamoDB global secondary index - The resource type is <code>index</code> and the unique identifier is the index name.
        /// Example: <code>table/my-table/index/my-table-index</code>.</p>
        /// </li>
        /// <li>
        /// <p>Aurora DB cluster - The resource type is <code>cluster</code> and the unique identifier is the cluster name.
        /// Example: <code>cluster:my-db-cluster</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon SageMaker endpoint variant - The resource type is <code>variant</code> and the unique identifier is the resource ID.
        /// Example: <code>endpoint/my-end-point/variant/KMeansClustering</code>.</p>
        /// </li>
        /// <li>
        /// <p>Custom resources are not supported with a resource type. This parameter must specify the <code>OutputValue</code> from the CloudFormation template stack used to access the resources. The unique identifier is defined by the service provider. More information
        /// is available in our <a href="https://github.com/aws/aws-auto-scaling-custom-resource">GitHub
        /// repository</a>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon Comprehend document classification endpoint - The resource type and unique identifier are specified using the endpoint ARN. Example: <code>arn:aws:comprehend:us-west-2:123456789012:document-classifier-endpoint/EXAMPLE</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon Comprehend entity recognizer endpoint - The resource type and unique identifier are specified using the endpoint ARN. Example: <code>arn:aws:comprehend:us-west-2:123456789012:entity-recognizer-endpoint/EXAMPLE</code>.</p>
        /// </li>
        /// <li>
        /// <p>Lambda provisioned concurrency - The resource type is <code>function</code> and the unique identifier is the function name with a function version or alias name suffix that is not <code>$LATEST</code>.
        /// Example: <code>function:my-function:prod</code> or <code>function:my-function:1</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon Keyspaces table - The resource type is <code>table</code> and the unique identifier is the table name.
        /// Example: <code>keyspace/mykeyspace/table/mytable</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon MSK cluster - The resource type and unique identifier are specified using the cluster ARN.
        /// Example: <code>arn:aws:kafka:us-east-1:123456789012:cluster/demo-cluster-1/6357e0b2-0e6a-4b86-a0b4-70df934c2e31-5</code>.</p>
        /// </li>
        /// </ul>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_id(input);
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_id(input);
            self
        }
        /// <p>The scalable dimension. This string consists of the service namespace, resource type, and scaling property.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ecs:service:DesiredCount</code> - The desired task count of an ECS service.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ec2:spot-fleet-request:TargetCapacity</code> - The target capacity of a Spot Fleet request.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>elasticmapreduce:instancegroup:InstanceCount</code> - The instance count of an EMR Instance Group.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>appstream:fleet:DesiredCapacity</code> - The desired capacity of an AppStream 2.0 fleet.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:table:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:table:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:index:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB global secondary index.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:index:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB global secondary index.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>rds:cluster:ReadReplicaCount</code> - The count of Aurora Replicas in an Aurora DB cluster. Available for Aurora MySQL-compatible edition and Aurora PostgreSQL-compatible edition.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>sagemaker:variant:DesiredInstanceCount</code> - The number of EC2 instances for an Amazon SageMaker model endpoint variant.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>custom-resource:ResourceType:Property</code> - The scalable dimension for a custom resource provided by your own application or service.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>comprehend:document-classifier-endpoint:DesiredInferenceUnits</code> - The number of inference units for an Amazon Comprehend document classification endpoint.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>comprehend:entity-recognizer-endpoint:DesiredInferenceUnits</code> - The number of inference units for an Amazon Comprehend entity recognizer endpoint.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>lambda:function:ProvisionedConcurrency</code> - The provisioned concurrency for a Lambda function.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>cassandra:table:ReadCapacityUnits</code> - The provisioned read capacity for an Amazon Keyspaces table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>cassandra:table:WriteCapacityUnits</code> -  The provisioned write capacity for an Amazon Keyspaces table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>kafka:broker-storage:VolumeSize</code> - The provisioned volume size (in GiB) for brokers in an Amazon MSK cluster.</p>
        /// </li>
        /// </ul>
        pub fn scalable_dimension(mut self, input: crate::model::ScalableDimension) -> Self {
            self.inner = self.inner.scalable_dimension(input);
            self
        }
        pub fn set_scalable_dimension(
            mut self,
            input: std::option::Option<crate::model::ScalableDimension>,
        ) -> Self {
            self.inner = self.inner.set_scalable_dimension(input);
            self
        }
        /// <p>The date and time for this scheduled action to start, in UTC.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_time(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>The date and time for the recurring schedule to end, in UTC.</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_time(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
        /// <p>The new minimum and maximum capacity. You can set both values or just one. At the
        /// scheduled time, if the current capacity is below the minimum capacity, Application Auto Scaling scales out
        /// to the minimum capacity. If the current capacity is above the maximum capacity, Application Auto Scaling
        /// scales in to the maximum capacity.</p>
        pub fn scalable_target_action(mut self, input: crate::model::ScalableTargetAction) -> Self {
            self.inner = self.inner.scalable_target_action(input);
            self
        }
        pub fn set_scalable_target_action(
            mut self,
            input: std::option::Option<crate::model::ScalableTargetAction>,
        ) -> Self {
            self.inner = self.inner.set_scalable_target_action(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RegisterScalableTarget<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::register_scalable_target_input::Builder,
    }
    impl<C> RegisterScalableTarget<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RegisterScalableTargetOutput,
            smithy_http::result::SdkError<crate::error::RegisterScalableTargetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The namespace of the AWS service that provides the resource. For a resource provided
        /// by your own application or service, use <code>custom-resource</code> instead.</p>
        pub fn service_namespace(mut self, input: crate::model::ServiceNamespace) -> Self {
            self.inner = self.inner.service_namespace(input);
            self
        }
        pub fn set_service_namespace(
            mut self,
            input: std::option::Option<crate::model::ServiceNamespace>,
        ) -> Self {
            self.inner = self.inner.set_service_namespace(input);
            self
        }
        /// <p>The identifier of the resource that is associated with the scalable target.
        /// This string consists of the resource type and unique identifier.</p>
        /// <ul>
        /// <li>
        /// <p>ECS service - The resource type is <code>service</code> and the unique identifier is the cluster name  
        /// and service name. Example: <code>service/default/sample-webapp</code>.</p>
        /// </li>
        /// <li>
        /// <p>Spot Fleet request - The resource type is <code>spot-fleet-request</code> and the unique identifier is the
        /// Spot Fleet request ID. Example: <code>spot-fleet-request/sfr-73fbd2ce-aa30-494c-8788-1cee4EXAMPLE</code>.</p>
        /// </li>
        /// <li>
        /// <p>EMR cluster - The resource type is <code>instancegroup</code> and the unique identifier is the cluster ID and instance group ID.
        /// Example: <code>instancegroup/j-2EEZNYKUA1NTV/ig-1791Y4E1L8YI0</code>.</p>
        /// </li>
        /// <li>
        /// <p>AppStream 2.0 fleet - The resource type is <code>fleet</code> and the unique identifier is the fleet name.
        /// Example: <code>fleet/sample-fleet</code>.</p>
        /// </li>
        /// <li>
        /// <p>DynamoDB table - The resource type is <code>table</code> and the unique identifier is the table name.
        /// Example: <code>table/my-table</code>.</p>
        /// </li>
        /// <li>
        /// <p>DynamoDB global secondary index - The resource type is <code>index</code> and the unique identifier is the index name.
        /// Example: <code>table/my-table/index/my-table-index</code>.</p>
        /// </li>
        /// <li>
        /// <p>Aurora DB cluster - The resource type is <code>cluster</code> and the unique identifier is the cluster name.
        /// Example: <code>cluster:my-db-cluster</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon SageMaker endpoint variant - The resource type is <code>variant</code> and the unique identifier is the resource ID.
        /// Example: <code>endpoint/my-end-point/variant/KMeansClustering</code>.</p>
        /// </li>
        /// <li>
        /// <p>Custom resources are not supported with a resource type. This parameter must specify the <code>OutputValue</code> from the CloudFormation template stack used to access the resources. The unique identifier is defined by the service provider. More information
        /// is available in our <a href="https://github.com/aws/aws-auto-scaling-custom-resource">GitHub
        /// repository</a>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon Comprehend document classification endpoint - The resource type and unique identifier are specified using the endpoint ARN. Example: <code>arn:aws:comprehend:us-west-2:123456789012:document-classifier-endpoint/EXAMPLE</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon Comprehend entity recognizer endpoint - The resource type and unique identifier are specified using the endpoint ARN. Example: <code>arn:aws:comprehend:us-west-2:123456789012:entity-recognizer-endpoint/EXAMPLE</code>.</p>
        /// </li>
        /// <li>
        /// <p>Lambda provisioned concurrency - The resource type is <code>function</code> and the unique identifier is the function name with a function version or alias name suffix that is not <code>$LATEST</code>.
        /// Example: <code>function:my-function:prod</code> or <code>function:my-function:1</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon Keyspaces table - The resource type is <code>table</code> and the unique identifier is the table name.
        /// Example: <code>keyspace/mykeyspace/table/mytable</code>.</p>
        /// </li>
        /// <li>
        /// <p>Amazon MSK cluster - The resource type and unique identifier are specified using the cluster ARN.
        /// Example: <code>arn:aws:kafka:us-east-1:123456789012:cluster/demo-cluster-1/6357e0b2-0e6a-4b86-a0b4-70df934c2e31-5</code>.</p>
        /// </li>
        /// </ul>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_id(input);
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_id(input);
            self
        }
        /// <p>The scalable dimension associated with the scalable target.
        /// This string consists of the service namespace, resource type, and scaling property.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ecs:service:DesiredCount</code> - The desired task count of an ECS service.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ec2:spot-fleet-request:TargetCapacity</code> - The target capacity of a Spot Fleet request.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>elasticmapreduce:instancegroup:InstanceCount</code> - The instance count of an EMR Instance Group.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>appstream:fleet:DesiredCapacity</code> - The desired capacity of an AppStream 2.0 fleet.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:table:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:table:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:index:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB global secondary index.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:index:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB global secondary index.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>rds:cluster:ReadReplicaCount</code> - The count of Aurora Replicas in an Aurora DB cluster. Available for Aurora MySQL-compatible edition and Aurora PostgreSQL-compatible edition.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>sagemaker:variant:DesiredInstanceCount</code> - The number of EC2 instances for an Amazon SageMaker model endpoint variant.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>custom-resource:ResourceType:Property</code> - The scalable dimension for a custom resource provided by your own application or service.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>comprehend:document-classifier-endpoint:DesiredInferenceUnits</code> - The number of inference units for an Amazon Comprehend document classification endpoint.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>comprehend:entity-recognizer-endpoint:DesiredInferenceUnits</code> - The number of inference units for an Amazon Comprehend entity recognizer endpoint.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>lambda:function:ProvisionedConcurrency</code> - The provisioned concurrency for a Lambda function.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>cassandra:table:ReadCapacityUnits</code> - The provisioned read capacity for an Amazon Keyspaces table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>cassandra:table:WriteCapacityUnits</code> -  The provisioned write capacity for an Amazon Keyspaces table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>kafka:broker-storage:VolumeSize</code> - The provisioned volume size (in GiB) for brokers in an Amazon MSK cluster.</p>
        /// </li>
        /// </ul>
        pub fn scalable_dimension(mut self, input: crate::model::ScalableDimension) -> Self {
            self.inner = self.inner.scalable_dimension(input);
            self
        }
        pub fn set_scalable_dimension(
            mut self,
            input: std::option::Option<crate::model::ScalableDimension>,
        ) -> Self {
            self.inner = self.inner.set_scalable_dimension(input);
            self
        }
        /// <p>The minimum value that you plan to scale in to. When a scaling policy is in effect,
        /// Application Auto Scaling can scale in (contract) as needed to the minimum capacity limit in response to
        /// changing demand. This property is required when registering a new scalable target.</p>
        /// <p>For certain resources, the minimum value allowed is 0. This includes Lambda provisioned
        /// concurrency, Spot Fleet, ECS services, Aurora DB clusters, EMR clusters, and custom resources.
        /// For all other resources, the minimum value allowed is 1.</p>
        pub fn min_capacity(mut self, input: i32) -> Self {
            self.inner = self.inner.min_capacity(input);
            self
        }
        pub fn set_min_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_min_capacity(input);
            self
        }
        /// <p>The maximum value that you plan to scale out to. When a scaling policy is in effect,
        /// Application Auto Scaling can scale out (expand) as needed to the maximum capacity limit in response to
        /// changing demand. This property is required when registering a new scalable target.</p>
        /// <p>Although you can specify a large maximum capacity, note that service quotas may impose
        /// lower limits. Each service has its own default quotas for the maximum capacity of the
        /// resource. If you want to specify a higher limit, you can request an increase. For more
        /// information, consult the documentation for that service. For information about the default
        /// quotas for each service, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-service-information.html">Service Endpoints and
        /// Quotas</a> in the <i>Amazon Web Services General Reference</i>.</p>
        pub fn max_capacity(mut self, input: i32) -> Self {
            self.inner = self.inner.max_capacity(input);
            self
        }
        pub fn set_max_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_capacity(input);
            self
        }
        /// <p>This parameter is required for services that do not support service-linked roles (such as
        /// Amazon EMR), and it must specify the ARN of an IAM role that allows Application Auto Scaling to modify the scalable
        /// target on your behalf. </p>
        /// <p>If the service supports service-linked roles, Application Auto Scaling uses a service-linked role, which
        /// it creates if it does not yet exist. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/application/userguide/security_iam_service-with-iam.html#security_iam_service-with-iam-roles">Application Auto Scaling IAM roles</a>.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(input);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// <p>An embedded object that contains attributes and attribute values that are used to
        /// suspend and resume automatic scaling. Setting the value of an attribute to
        /// <code>true</code> suspends the specified scaling activities. Setting it to
        /// <code>false</code> (default) resumes the specified scaling activities. </p>
        /// <p>
        /// <b>Suspension Outcomes</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>For <code>DynamicScalingInSuspended</code>, while a suspension is in effect, all
        /// scale-in activities that are triggered by a scaling policy are suspended.</p>
        /// </li>
        /// <li>
        /// <p>For <code>DynamicScalingOutSuspended</code>, while a suspension is in effect, all
        /// scale-out activities that are triggered by a scaling policy are suspended.</p>
        /// </li>
        /// <li>
        /// <p>For <code>ScheduledScalingSuspended</code>, while a suspension is in effect, all
        /// scaling activities that involve scheduled actions are suspended. </p>
        /// </li>
        /// </ul>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/application/userguide/application-auto-scaling-suspend-resume-scaling.html">Suspending and resuming scaling</a> in the <i>Application Auto Scaling User
        /// Guide</i>.</p>
        pub fn suspended_state(mut self, input: crate::model::SuspendedState) -> Self {
            self.inner = self.inner.suspended_state(input);
            self
        }
        pub fn set_suspended_state(
            mut self,
            input: std::option::Option<crate::model::SuspendedState>,
        ) -> Self {
            self.inner = self.inner.set_suspended_state(input);
            self
        }
    }
}
