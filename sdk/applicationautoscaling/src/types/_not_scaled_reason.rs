// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Describes the reason for an activity that isn't scaled (<i>not scaled activity</i>), in machine-readable format. For help interpreting the not scaled reason details, see <a href="https://docs.aws.amazon.com/autoscaling/application/userguide/application-auto-scaling-scaling-activities.html">Scaling activities for Application Auto Scaling</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NotScaledReason {
    /// <p>A code that represents the reason for not scaling.</p>
    /// <p>Valid values:</p>
    /// <ul>
    /// <li> <p>AutoScalingAnticipatedFlapping</p> </li>
    /// <li> <p>TargetServicePutResourceAsUnscalable</p> </li>
    /// <li> <p>AlreadyAtMaxCapacity</p> </li>
    /// <li> <p>AlreadyAtMinCapacity</p> </li>
    /// <li> <p>AlreadyAtDesiredCapacity</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub code: std::option::Option<std::string::String>,
    /// <p>The maximum capacity.</p>
    #[doc(hidden)]
    pub max_capacity: std::option::Option<i32>,
    /// <p>The minimum capacity.</p>
    #[doc(hidden)]
    pub min_capacity: std::option::Option<i32>,
    /// <p>The current capacity.</p>
    #[doc(hidden)]
    pub current_capacity: std::option::Option<i32>,
}
impl NotScaledReason {
    /// <p>A code that represents the reason for not scaling.</p>
    /// <p>Valid values:</p>
    /// <ul>
    /// <li> <p>AutoScalingAnticipatedFlapping</p> </li>
    /// <li> <p>TargetServicePutResourceAsUnscalable</p> </li>
    /// <li> <p>AlreadyAtMaxCapacity</p> </li>
    /// <li> <p>AlreadyAtMinCapacity</p> </li>
    /// <li> <p>AlreadyAtDesiredCapacity</p> </li>
    /// </ul>
    pub fn code(&self) -> std::option::Option<&str> {
        self.code.as_deref()
    }
    /// <p>The maximum capacity.</p>
    pub fn max_capacity(&self) -> std::option::Option<i32> {
        self.max_capacity
    }
    /// <p>The minimum capacity.</p>
    pub fn min_capacity(&self) -> std::option::Option<i32> {
        self.min_capacity
    }
    /// <p>The current capacity.</p>
    pub fn current_capacity(&self) -> std::option::Option<i32> {
        self.current_capacity
    }
}
impl NotScaledReason {
    /// Creates a new builder-style object to manufacture [`NotScaledReason`](crate::types::NotScaledReason).
    pub fn builder() -> crate::types::builders::NotScaledReasonBuilder {
        crate::types::builders::NotScaledReasonBuilder::default()
    }
}

/// A builder for [`NotScaledReason`](crate::types::NotScaledReason).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct NotScaledReasonBuilder {
    pub(crate) code: std::option::Option<std::string::String>,
    pub(crate) max_capacity: std::option::Option<i32>,
    pub(crate) min_capacity: std::option::Option<i32>,
    pub(crate) current_capacity: std::option::Option<i32>,
}
impl NotScaledReasonBuilder {
    /// <p>A code that represents the reason for not scaling.</p>
    /// <p>Valid values:</p>
    /// <ul>
    /// <li> <p>AutoScalingAnticipatedFlapping</p> </li>
    /// <li> <p>TargetServicePutResourceAsUnscalable</p> </li>
    /// <li> <p>AlreadyAtMaxCapacity</p> </li>
    /// <li> <p>AlreadyAtMinCapacity</p> </li>
    /// <li> <p>AlreadyAtDesiredCapacity</p> </li>
    /// </ul>
    pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
        self.code = Some(input.into());
        self
    }
    /// <p>A code that represents the reason for not scaling.</p>
    /// <p>Valid values:</p>
    /// <ul>
    /// <li> <p>AutoScalingAnticipatedFlapping</p> </li>
    /// <li> <p>TargetServicePutResourceAsUnscalable</p> </li>
    /// <li> <p>AlreadyAtMaxCapacity</p> </li>
    /// <li> <p>AlreadyAtMinCapacity</p> </li>
    /// <li> <p>AlreadyAtDesiredCapacity</p> </li>
    /// </ul>
    pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.code = input;
        self
    }
    /// <p>The maximum capacity.</p>
    pub fn max_capacity(mut self, input: i32) -> Self {
        self.max_capacity = Some(input);
        self
    }
    /// <p>The maximum capacity.</p>
    pub fn set_max_capacity(mut self, input: std::option::Option<i32>) -> Self {
        self.max_capacity = input;
        self
    }
    /// <p>The minimum capacity.</p>
    pub fn min_capacity(mut self, input: i32) -> Self {
        self.min_capacity = Some(input);
        self
    }
    /// <p>The minimum capacity.</p>
    pub fn set_min_capacity(mut self, input: std::option::Option<i32>) -> Self {
        self.min_capacity = input;
        self
    }
    /// <p>The current capacity.</p>
    pub fn current_capacity(mut self, input: i32) -> Self {
        self.current_capacity = Some(input);
        self
    }
    /// <p>The current capacity.</p>
    pub fn set_current_capacity(mut self, input: std::option::Option<i32>) -> Self {
        self.current_capacity = input;
        self
    }
    /// Consumes the builder and constructs a [`NotScaledReason`](crate::types::NotScaledReason).
    pub fn build(self) -> crate::types::NotScaledReason {
        crate::types::NotScaledReason {
            code: self.code,
            max_capacity: self.max_capacity,
            min_capacity: self.min_capacity,
            current_capacity: self.current_capacity,
        }
    }
}
