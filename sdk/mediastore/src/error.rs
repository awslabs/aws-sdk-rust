// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateContainerError {
    pub kind: CreateContainerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateContainerErrorKind {
    ContainerInUseException(crate::error::ContainerInUseException),
    InternalServerError(crate::error::InternalServerError),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateContainerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateContainerErrorKind::ContainerInUseException(_inner) => _inner.fmt(f),
            CreateContainerErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CreateContainerErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateContainerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateContainerError {
    fn code(&self) -> Option<&str> {
        CreateContainerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateContainerError {
    pub fn new(kind: CreateContainerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateContainerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateContainerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_container_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContainerErrorKind::ContainerInUseException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, CreateContainerErrorKind::InternalServerError(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContainerErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for CreateContainerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateContainerErrorKind::ContainerInUseException(_inner) => Some(_inner),
            CreateContainerErrorKind::InternalServerError(_inner) => Some(_inner),
            CreateContainerErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateContainerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteContainerError {
    pub kind: DeleteContainerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteContainerErrorKind {
    ContainerInUseException(crate::error::ContainerInUseException),
    ContainerNotFoundException(crate::error::ContainerNotFoundException),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteContainerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteContainerErrorKind::ContainerInUseException(_inner) => _inner.fmt(f),
            DeleteContainerErrorKind::ContainerNotFoundException(_inner) => _inner.fmt(f),
            DeleteContainerErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteContainerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteContainerError {
    fn code(&self) -> Option<&str> {
        DeleteContainerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteContainerError {
    pub fn new(kind: DeleteContainerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteContainerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteContainerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_container_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteContainerErrorKind::ContainerInUseException(_)
        )
    }
    pub fn is_container_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteContainerErrorKind::ContainerNotFoundException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, DeleteContainerErrorKind::InternalServerError(_))
    }
}
impl std::error::Error for DeleteContainerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteContainerErrorKind::ContainerInUseException(_inner) => Some(_inner),
            DeleteContainerErrorKind::ContainerNotFoundException(_inner) => Some(_inner),
            DeleteContainerErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteContainerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteContainerPolicyError {
    pub kind: DeleteContainerPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteContainerPolicyErrorKind {
    ContainerInUseException(crate::error::ContainerInUseException),
    ContainerNotFoundException(crate::error::ContainerNotFoundException),
    InternalServerError(crate::error::InternalServerError),
    PolicyNotFoundException(crate::error::PolicyNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteContainerPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteContainerPolicyErrorKind::ContainerInUseException(_inner) => _inner.fmt(f),
            DeleteContainerPolicyErrorKind::ContainerNotFoundException(_inner) => _inner.fmt(f),
            DeleteContainerPolicyErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteContainerPolicyErrorKind::PolicyNotFoundException(_inner) => _inner.fmt(f),
            DeleteContainerPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteContainerPolicyError {
    fn code(&self) -> Option<&str> {
        DeleteContainerPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteContainerPolicyError {
    pub fn new(kind: DeleteContainerPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteContainerPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteContainerPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_container_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteContainerPolicyErrorKind::ContainerInUseException(_)
        )
    }
    pub fn is_container_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteContainerPolicyErrorKind::ContainerNotFoundException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteContainerPolicyErrorKind::InternalServerError(_)
        )
    }
    pub fn is_policy_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteContainerPolicyErrorKind::PolicyNotFoundException(_)
        )
    }
}
impl std::error::Error for DeleteContainerPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteContainerPolicyErrorKind::ContainerInUseException(_inner) => Some(_inner),
            DeleteContainerPolicyErrorKind::ContainerNotFoundException(_inner) => Some(_inner),
            DeleteContainerPolicyErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteContainerPolicyErrorKind::PolicyNotFoundException(_inner) => Some(_inner),
            DeleteContainerPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteCorsPolicyError {
    pub kind: DeleteCorsPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCorsPolicyErrorKind {
    ContainerInUseException(crate::error::ContainerInUseException),
    ContainerNotFoundException(crate::error::ContainerNotFoundException),
    CorsPolicyNotFoundException(crate::error::CorsPolicyNotFoundException),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteCorsPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteCorsPolicyErrorKind::ContainerInUseException(_inner) => _inner.fmt(f),
            DeleteCorsPolicyErrorKind::ContainerNotFoundException(_inner) => _inner.fmt(f),
            DeleteCorsPolicyErrorKind::CorsPolicyNotFoundException(_inner) => _inner.fmt(f),
            DeleteCorsPolicyErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteCorsPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteCorsPolicyError {
    fn code(&self) -> Option<&str> {
        DeleteCorsPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteCorsPolicyError {
    pub fn new(kind: DeleteCorsPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteCorsPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteCorsPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_container_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCorsPolicyErrorKind::ContainerInUseException(_)
        )
    }
    pub fn is_container_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCorsPolicyErrorKind::ContainerNotFoundException(_)
        )
    }
    pub fn is_cors_policy_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCorsPolicyErrorKind::CorsPolicyNotFoundException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCorsPolicyErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for DeleteCorsPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteCorsPolicyErrorKind::ContainerInUseException(_inner) => Some(_inner),
            DeleteCorsPolicyErrorKind::ContainerNotFoundException(_inner) => Some(_inner),
            DeleteCorsPolicyErrorKind::CorsPolicyNotFoundException(_inner) => Some(_inner),
            DeleteCorsPolicyErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteCorsPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteLifecyclePolicyError {
    pub kind: DeleteLifecyclePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteLifecyclePolicyErrorKind {
    ContainerInUseException(crate::error::ContainerInUseException),
    ContainerNotFoundException(crate::error::ContainerNotFoundException),
    InternalServerError(crate::error::InternalServerError),
    PolicyNotFoundException(crate::error::PolicyNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteLifecyclePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteLifecyclePolicyErrorKind::ContainerInUseException(_inner) => _inner.fmt(f),
            DeleteLifecyclePolicyErrorKind::ContainerNotFoundException(_inner) => _inner.fmt(f),
            DeleteLifecyclePolicyErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteLifecyclePolicyErrorKind::PolicyNotFoundException(_inner) => _inner.fmt(f),
            DeleteLifecyclePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteLifecyclePolicyError {
    fn code(&self) -> Option<&str> {
        DeleteLifecyclePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteLifecyclePolicyError {
    pub fn new(kind: DeleteLifecyclePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteLifecyclePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteLifecyclePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_container_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLifecyclePolicyErrorKind::ContainerInUseException(_)
        )
    }
    pub fn is_container_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLifecyclePolicyErrorKind::ContainerNotFoundException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLifecyclePolicyErrorKind::InternalServerError(_)
        )
    }
    pub fn is_policy_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLifecyclePolicyErrorKind::PolicyNotFoundException(_)
        )
    }
}
impl std::error::Error for DeleteLifecyclePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteLifecyclePolicyErrorKind::ContainerInUseException(_inner) => Some(_inner),
            DeleteLifecyclePolicyErrorKind::ContainerNotFoundException(_inner) => Some(_inner),
            DeleteLifecyclePolicyErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteLifecyclePolicyErrorKind::PolicyNotFoundException(_inner) => Some(_inner),
            DeleteLifecyclePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteMetricPolicyError {
    pub kind: DeleteMetricPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteMetricPolicyErrorKind {
    ContainerInUseException(crate::error::ContainerInUseException),
    ContainerNotFoundException(crate::error::ContainerNotFoundException),
    InternalServerError(crate::error::InternalServerError),
    PolicyNotFoundException(crate::error::PolicyNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteMetricPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteMetricPolicyErrorKind::ContainerInUseException(_inner) => _inner.fmt(f),
            DeleteMetricPolicyErrorKind::ContainerNotFoundException(_inner) => _inner.fmt(f),
            DeleteMetricPolicyErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteMetricPolicyErrorKind::PolicyNotFoundException(_inner) => _inner.fmt(f),
            DeleteMetricPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteMetricPolicyError {
    fn code(&self) -> Option<&str> {
        DeleteMetricPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteMetricPolicyError {
    pub fn new(kind: DeleteMetricPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteMetricPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteMetricPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_container_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMetricPolicyErrorKind::ContainerInUseException(_)
        )
    }
    pub fn is_container_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMetricPolicyErrorKind::ContainerNotFoundException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMetricPolicyErrorKind::InternalServerError(_)
        )
    }
    pub fn is_policy_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMetricPolicyErrorKind::PolicyNotFoundException(_)
        )
    }
}
impl std::error::Error for DeleteMetricPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteMetricPolicyErrorKind::ContainerInUseException(_inner) => Some(_inner),
            DeleteMetricPolicyErrorKind::ContainerNotFoundException(_inner) => Some(_inner),
            DeleteMetricPolicyErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteMetricPolicyErrorKind::PolicyNotFoundException(_inner) => Some(_inner),
            DeleteMetricPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeContainerError {
    pub kind: DescribeContainerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeContainerErrorKind {
    ContainerNotFoundException(crate::error::ContainerNotFoundException),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeContainerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeContainerErrorKind::ContainerNotFoundException(_inner) => _inner.fmt(f),
            DescribeContainerErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeContainerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeContainerError {
    fn code(&self) -> Option<&str> {
        DescribeContainerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeContainerError {
    pub fn new(kind: DescribeContainerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeContainerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeContainerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_container_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeContainerErrorKind::ContainerNotFoundException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeContainerErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for DescribeContainerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeContainerErrorKind::ContainerNotFoundException(_inner) => Some(_inner),
            DescribeContainerErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeContainerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetContainerPolicyError {
    pub kind: GetContainerPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetContainerPolicyErrorKind {
    ContainerInUseException(crate::error::ContainerInUseException),
    ContainerNotFoundException(crate::error::ContainerNotFoundException),
    InternalServerError(crate::error::InternalServerError),
    PolicyNotFoundException(crate::error::PolicyNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetContainerPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetContainerPolicyErrorKind::ContainerInUseException(_inner) => _inner.fmt(f),
            GetContainerPolicyErrorKind::ContainerNotFoundException(_inner) => _inner.fmt(f),
            GetContainerPolicyErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetContainerPolicyErrorKind::PolicyNotFoundException(_inner) => _inner.fmt(f),
            GetContainerPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetContainerPolicyError {
    fn code(&self) -> Option<&str> {
        GetContainerPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetContainerPolicyError {
    pub fn new(kind: GetContainerPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetContainerPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetContainerPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_container_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContainerPolicyErrorKind::ContainerInUseException(_)
        )
    }
    pub fn is_container_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContainerPolicyErrorKind::ContainerNotFoundException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            GetContainerPolicyErrorKind::InternalServerError(_)
        )
    }
    pub fn is_policy_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContainerPolicyErrorKind::PolicyNotFoundException(_)
        )
    }
}
impl std::error::Error for GetContainerPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetContainerPolicyErrorKind::ContainerInUseException(_inner) => Some(_inner),
            GetContainerPolicyErrorKind::ContainerNotFoundException(_inner) => Some(_inner),
            GetContainerPolicyErrorKind::InternalServerError(_inner) => Some(_inner),
            GetContainerPolicyErrorKind::PolicyNotFoundException(_inner) => Some(_inner),
            GetContainerPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCorsPolicyError {
    pub kind: GetCorsPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCorsPolicyErrorKind {
    ContainerInUseException(crate::error::ContainerInUseException),
    ContainerNotFoundException(crate::error::ContainerNotFoundException),
    CorsPolicyNotFoundException(crate::error::CorsPolicyNotFoundException),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCorsPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCorsPolicyErrorKind::ContainerInUseException(_inner) => _inner.fmt(f),
            GetCorsPolicyErrorKind::ContainerNotFoundException(_inner) => _inner.fmt(f),
            GetCorsPolicyErrorKind::CorsPolicyNotFoundException(_inner) => _inner.fmt(f),
            GetCorsPolicyErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetCorsPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetCorsPolicyError {
    fn code(&self) -> Option<&str> {
        GetCorsPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCorsPolicyError {
    pub fn new(kind: GetCorsPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCorsPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCorsPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_container_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCorsPolicyErrorKind::ContainerInUseException(_)
        )
    }
    pub fn is_container_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCorsPolicyErrorKind::ContainerNotFoundException(_)
        )
    }
    pub fn is_cors_policy_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCorsPolicyErrorKind::CorsPolicyNotFoundException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, GetCorsPolicyErrorKind::InternalServerError(_))
    }
}
impl std::error::Error for GetCorsPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCorsPolicyErrorKind::ContainerInUseException(_inner) => Some(_inner),
            GetCorsPolicyErrorKind::ContainerNotFoundException(_inner) => Some(_inner),
            GetCorsPolicyErrorKind::CorsPolicyNotFoundException(_inner) => Some(_inner),
            GetCorsPolicyErrorKind::InternalServerError(_inner) => Some(_inner),
            GetCorsPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetLifecyclePolicyError {
    pub kind: GetLifecyclePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetLifecyclePolicyErrorKind {
    ContainerInUseException(crate::error::ContainerInUseException),
    ContainerNotFoundException(crate::error::ContainerNotFoundException),
    InternalServerError(crate::error::InternalServerError),
    PolicyNotFoundException(crate::error::PolicyNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetLifecyclePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetLifecyclePolicyErrorKind::ContainerInUseException(_inner) => _inner.fmt(f),
            GetLifecyclePolicyErrorKind::ContainerNotFoundException(_inner) => _inner.fmt(f),
            GetLifecyclePolicyErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetLifecyclePolicyErrorKind::PolicyNotFoundException(_inner) => _inner.fmt(f),
            GetLifecyclePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetLifecyclePolicyError {
    fn code(&self) -> Option<&str> {
        GetLifecyclePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetLifecyclePolicyError {
    pub fn new(kind: GetLifecyclePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetLifecyclePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetLifecyclePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_container_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLifecyclePolicyErrorKind::ContainerInUseException(_)
        )
    }
    pub fn is_container_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLifecyclePolicyErrorKind::ContainerNotFoundException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            GetLifecyclePolicyErrorKind::InternalServerError(_)
        )
    }
    pub fn is_policy_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLifecyclePolicyErrorKind::PolicyNotFoundException(_)
        )
    }
}
impl std::error::Error for GetLifecyclePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetLifecyclePolicyErrorKind::ContainerInUseException(_inner) => Some(_inner),
            GetLifecyclePolicyErrorKind::ContainerNotFoundException(_inner) => Some(_inner),
            GetLifecyclePolicyErrorKind::InternalServerError(_inner) => Some(_inner),
            GetLifecyclePolicyErrorKind::PolicyNotFoundException(_inner) => Some(_inner),
            GetLifecyclePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetMetricPolicyError {
    pub kind: GetMetricPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMetricPolicyErrorKind {
    ContainerInUseException(crate::error::ContainerInUseException),
    ContainerNotFoundException(crate::error::ContainerNotFoundException),
    InternalServerError(crate::error::InternalServerError),
    PolicyNotFoundException(crate::error::PolicyNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetMetricPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetMetricPolicyErrorKind::ContainerInUseException(_inner) => _inner.fmt(f),
            GetMetricPolicyErrorKind::ContainerNotFoundException(_inner) => _inner.fmt(f),
            GetMetricPolicyErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetMetricPolicyErrorKind::PolicyNotFoundException(_inner) => _inner.fmt(f),
            GetMetricPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetMetricPolicyError {
    fn code(&self) -> Option<&str> {
        GetMetricPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMetricPolicyError {
    pub fn new(kind: GetMetricPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetMetricPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetMetricPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_container_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMetricPolicyErrorKind::ContainerInUseException(_)
        )
    }
    pub fn is_container_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMetricPolicyErrorKind::ContainerNotFoundException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, GetMetricPolicyErrorKind::InternalServerError(_))
    }
    pub fn is_policy_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMetricPolicyErrorKind::PolicyNotFoundException(_)
        )
    }
}
impl std::error::Error for GetMetricPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetMetricPolicyErrorKind::ContainerInUseException(_inner) => Some(_inner),
            GetMetricPolicyErrorKind::ContainerNotFoundException(_inner) => Some(_inner),
            GetMetricPolicyErrorKind::InternalServerError(_inner) => Some(_inner),
            GetMetricPolicyErrorKind::PolicyNotFoundException(_inner) => Some(_inner),
            GetMetricPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListContainersError {
    pub kind: ListContainersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListContainersErrorKind {
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListContainersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListContainersErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListContainersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListContainersError {
    fn code(&self) -> Option<&str> {
        ListContainersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListContainersError {
    pub fn new(kind: ListContainersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListContainersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListContainersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, ListContainersErrorKind::InternalServerError(_))
    }
}
impl std::error::Error for ListContainersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListContainersErrorKind::InternalServerError(_inner) => Some(_inner),
            ListContainersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    ContainerInUseException(crate::error::ContainerInUseException),
    ContainerNotFoundException(crate::error::ContainerNotFoundException),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::ContainerInUseException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ContainerNotFoundException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_container_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ContainerInUseException(_)
        )
    }
    pub fn is_container_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ContainerNotFoundException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::ContainerInUseException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ContainerNotFoundException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InternalServerError(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutContainerPolicyError {
    pub kind: PutContainerPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutContainerPolicyErrorKind {
    ContainerInUseException(crate::error::ContainerInUseException),
    ContainerNotFoundException(crate::error::ContainerNotFoundException),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutContainerPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutContainerPolicyErrorKind::ContainerInUseException(_inner) => _inner.fmt(f),
            PutContainerPolicyErrorKind::ContainerNotFoundException(_inner) => _inner.fmt(f),
            PutContainerPolicyErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            PutContainerPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutContainerPolicyError {
    fn code(&self) -> Option<&str> {
        PutContainerPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutContainerPolicyError {
    pub fn new(kind: PutContainerPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutContainerPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutContainerPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_container_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutContainerPolicyErrorKind::ContainerInUseException(_)
        )
    }
    pub fn is_container_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutContainerPolicyErrorKind::ContainerNotFoundException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            PutContainerPolicyErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for PutContainerPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutContainerPolicyErrorKind::ContainerInUseException(_inner) => Some(_inner),
            PutContainerPolicyErrorKind::ContainerNotFoundException(_inner) => Some(_inner),
            PutContainerPolicyErrorKind::InternalServerError(_inner) => Some(_inner),
            PutContainerPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutCorsPolicyError {
    pub kind: PutCorsPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutCorsPolicyErrorKind {
    ContainerInUseException(crate::error::ContainerInUseException),
    ContainerNotFoundException(crate::error::ContainerNotFoundException),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutCorsPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutCorsPolicyErrorKind::ContainerInUseException(_inner) => _inner.fmt(f),
            PutCorsPolicyErrorKind::ContainerNotFoundException(_inner) => _inner.fmt(f),
            PutCorsPolicyErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            PutCorsPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutCorsPolicyError {
    fn code(&self) -> Option<&str> {
        PutCorsPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutCorsPolicyError {
    pub fn new(kind: PutCorsPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutCorsPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutCorsPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_container_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutCorsPolicyErrorKind::ContainerInUseException(_)
        )
    }
    pub fn is_container_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutCorsPolicyErrorKind::ContainerNotFoundException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, PutCorsPolicyErrorKind::InternalServerError(_))
    }
}
impl std::error::Error for PutCorsPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutCorsPolicyErrorKind::ContainerInUseException(_inner) => Some(_inner),
            PutCorsPolicyErrorKind::ContainerNotFoundException(_inner) => Some(_inner),
            PutCorsPolicyErrorKind::InternalServerError(_inner) => Some(_inner),
            PutCorsPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutLifecyclePolicyError {
    pub kind: PutLifecyclePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutLifecyclePolicyErrorKind {
    ContainerInUseException(crate::error::ContainerInUseException),
    ContainerNotFoundException(crate::error::ContainerNotFoundException),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutLifecyclePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutLifecyclePolicyErrorKind::ContainerInUseException(_inner) => _inner.fmt(f),
            PutLifecyclePolicyErrorKind::ContainerNotFoundException(_inner) => _inner.fmt(f),
            PutLifecyclePolicyErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            PutLifecyclePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutLifecyclePolicyError {
    fn code(&self) -> Option<&str> {
        PutLifecyclePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutLifecyclePolicyError {
    pub fn new(kind: PutLifecyclePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutLifecyclePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutLifecyclePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_container_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutLifecyclePolicyErrorKind::ContainerInUseException(_)
        )
    }
    pub fn is_container_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutLifecyclePolicyErrorKind::ContainerNotFoundException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            PutLifecyclePolicyErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for PutLifecyclePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutLifecyclePolicyErrorKind::ContainerInUseException(_inner) => Some(_inner),
            PutLifecyclePolicyErrorKind::ContainerNotFoundException(_inner) => Some(_inner),
            PutLifecyclePolicyErrorKind::InternalServerError(_inner) => Some(_inner),
            PutLifecyclePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutMetricPolicyError {
    pub kind: PutMetricPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutMetricPolicyErrorKind {
    ContainerInUseException(crate::error::ContainerInUseException),
    ContainerNotFoundException(crate::error::ContainerNotFoundException),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutMetricPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutMetricPolicyErrorKind::ContainerInUseException(_inner) => _inner.fmt(f),
            PutMetricPolicyErrorKind::ContainerNotFoundException(_inner) => _inner.fmt(f),
            PutMetricPolicyErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            PutMetricPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutMetricPolicyError {
    fn code(&self) -> Option<&str> {
        PutMetricPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutMetricPolicyError {
    pub fn new(kind: PutMetricPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutMetricPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutMetricPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_container_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutMetricPolicyErrorKind::ContainerInUseException(_)
        )
    }
    pub fn is_container_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutMetricPolicyErrorKind::ContainerNotFoundException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, PutMetricPolicyErrorKind::InternalServerError(_))
    }
}
impl std::error::Error for PutMetricPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutMetricPolicyErrorKind::ContainerInUseException(_inner) => Some(_inner),
            PutMetricPolicyErrorKind::ContainerNotFoundException(_inner) => Some(_inner),
            PutMetricPolicyErrorKind::InternalServerError(_inner) => Some(_inner),
            PutMetricPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartAccessLoggingError {
    pub kind: StartAccessLoggingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartAccessLoggingErrorKind {
    ContainerInUseException(crate::error::ContainerInUseException),
    ContainerNotFoundException(crate::error::ContainerNotFoundException),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartAccessLoggingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartAccessLoggingErrorKind::ContainerInUseException(_inner) => _inner.fmt(f),
            StartAccessLoggingErrorKind::ContainerNotFoundException(_inner) => _inner.fmt(f),
            StartAccessLoggingErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            StartAccessLoggingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartAccessLoggingError {
    fn code(&self) -> Option<&str> {
        StartAccessLoggingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartAccessLoggingError {
    pub fn new(kind: StartAccessLoggingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartAccessLoggingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartAccessLoggingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_container_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartAccessLoggingErrorKind::ContainerInUseException(_)
        )
    }
    pub fn is_container_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartAccessLoggingErrorKind::ContainerNotFoundException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            StartAccessLoggingErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for StartAccessLoggingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartAccessLoggingErrorKind::ContainerInUseException(_inner) => Some(_inner),
            StartAccessLoggingErrorKind::ContainerNotFoundException(_inner) => Some(_inner),
            StartAccessLoggingErrorKind::InternalServerError(_inner) => Some(_inner),
            StartAccessLoggingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopAccessLoggingError {
    pub kind: StopAccessLoggingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopAccessLoggingErrorKind {
    ContainerInUseException(crate::error::ContainerInUseException),
    ContainerNotFoundException(crate::error::ContainerNotFoundException),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopAccessLoggingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopAccessLoggingErrorKind::ContainerInUseException(_inner) => _inner.fmt(f),
            StopAccessLoggingErrorKind::ContainerNotFoundException(_inner) => _inner.fmt(f),
            StopAccessLoggingErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            StopAccessLoggingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopAccessLoggingError {
    fn code(&self) -> Option<&str> {
        StopAccessLoggingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopAccessLoggingError {
    pub fn new(kind: StopAccessLoggingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopAccessLoggingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopAccessLoggingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_container_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopAccessLoggingErrorKind::ContainerInUseException(_)
        )
    }
    pub fn is_container_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopAccessLoggingErrorKind::ContainerNotFoundException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            StopAccessLoggingErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for StopAccessLoggingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopAccessLoggingErrorKind::ContainerInUseException(_inner) => Some(_inner),
            StopAccessLoggingErrorKind::ContainerNotFoundException(_inner) => Some(_inner),
            StopAccessLoggingErrorKind::InternalServerError(_inner) => Some(_inner),
            StopAccessLoggingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    ContainerInUseException(crate::error::ContainerInUseException),
    ContainerNotFoundException(crate::error::ContainerNotFoundException),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::ContainerInUseException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ContainerNotFoundException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_container_in_use_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ContainerInUseException(_))
    }
    pub fn is_container_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ContainerNotFoundException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::InternalServerError(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::ContainerInUseException(_inner) => Some(_inner),
            TagResourceErrorKind::ContainerNotFoundException(_inner) => Some(_inner),
            TagResourceErrorKind::InternalServerError(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    ContainerInUseException(crate::error::ContainerInUseException),
    ContainerNotFoundException(crate::error::ContainerNotFoundException),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::ContainerInUseException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ContainerNotFoundException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_container_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ContainerInUseException(_)
        )
    }
    pub fn is_container_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ContainerNotFoundException(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::InternalServerError(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::ContainerInUseException(_inner) => Some(_inner),
            UntagResourceErrorKind::ContainerNotFoundException(_inner) => Some(_inner),
            UntagResourceErrorKind::InternalServerError(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The service is temporarily unavailable.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalServerError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalServerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalServerError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalServerError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalServerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServerError")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalServerError {}
/// See [`InternalServerError`](crate::error::InternalServerError)
pub mod internal_server_error {
    /// A builder for [`InternalServerError`](crate::error::InternalServerError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalServerError`](crate::error::InternalServerError)
        pub fn build(self) -> crate::error::InternalServerError {
            crate::error::InternalServerError {
                message: self.message,
            }
        }
    }
}
impl InternalServerError {
    /// Creates a new builder-style object to manufacture [`InternalServerError`](crate::error::InternalServerError)
    pub fn builder() -> crate::error::internal_server_error::Builder {
        crate::error::internal_server_error::Builder::default()
    }
}

/// <p>The container that you specified in the request does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ContainerNotFoundException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ContainerNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ContainerNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ContainerNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ContainerNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ContainerNotFoundException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for ContainerNotFoundException {}
/// See [`ContainerNotFoundException`](crate::error::ContainerNotFoundException)
pub mod container_not_found_exception {
    /// A builder for [`ContainerNotFoundException`](crate::error::ContainerNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ContainerNotFoundException`](crate::error::ContainerNotFoundException)
        pub fn build(self) -> crate::error::ContainerNotFoundException {
            crate::error::ContainerNotFoundException {
                message: self.message,
            }
        }
    }
}
impl ContainerNotFoundException {
    /// Creates a new builder-style object to manufacture [`ContainerNotFoundException`](crate::error::ContainerNotFoundException)
    pub fn builder() -> crate::error::container_not_found_exception::Builder {
        crate::error::container_not_found_exception::Builder::default()
    }
}

/// <p>The container that you specified in the request already exists or is being
/// updated.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ContainerInUseException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ContainerInUseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ContainerInUseException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ContainerInUseException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ContainerInUseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ContainerInUseException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for ContainerInUseException {}
/// See [`ContainerInUseException`](crate::error::ContainerInUseException)
pub mod container_in_use_exception {
    /// A builder for [`ContainerInUseException`](crate::error::ContainerInUseException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ContainerInUseException`](crate::error::ContainerInUseException)
        pub fn build(self) -> crate::error::ContainerInUseException {
            crate::error::ContainerInUseException {
                message: self.message,
            }
        }
    }
}
impl ContainerInUseException {
    /// Creates a new builder-style object to manufacture [`ContainerInUseException`](crate::error::ContainerInUseException)
    pub fn builder() -> crate::error::container_in_use_exception::Builder {
        crate::error::container_in_use_exception::Builder::default()
    }
}

/// <p>The policy that you specified in the request does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PolicyNotFoundException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PolicyNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PolicyNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PolicyNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PolicyNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PolicyNotFoundException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for PolicyNotFoundException {}
/// See [`PolicyNotFoundException`](crate::error::PolicyNotFoundException)
pub mod policy_not_found_exception {
    /// A builder for [`PolicyNotFoundException`](crate::error::PolicyNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PolicyNotFoundException`](crate::error::PolicyNotFoundException)
        pub fn build(self) -> crate::error::PolicyNotFoundException {
            crate::error::PolicyNotFoundException {
                message: self.message,
            }
        }
    }
}
impl PolicyNotFoundException {
    /// Creates a new builder-style object to manufacture [`PolicyNotFoundException`](crate::error::PolicyNotFoundException)
    pub fn builder() -> crate::error::policy_not_found_exception::Builder {
        crate::error::policy_not_found_exception::Builder::default()
    }
}

/// <p>The CORS policy that you specified in the request does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CorsPolicyNotFoundException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CorsPolicyNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CorsPolicyNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CorsPolicyNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CorsPolicyNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CorsPolicyNotFoundException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for CorsPolicyNotFoundException {}
/// See [`CorsPolicyNotFoundException`](crate::error::CorsPolicyNotFoundException)
pub mod cors_policy_not_found_exception {
    /// A builder for [`CorsPolicyNotFoundException`](crate::error::CorsPolicyNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CorsPolicyNotFoundException`](crate::error::CorsPolicyNotFoundException)
        pub fn build(self) -> crate::error::CorsPolicyNotFoundException {
            crate::error::CorsPolicyNotFoundException {
                message: self.message,
            }
        }
    }
}
impl CorsPolicyNotFoundException {
    /// Creates a new builder-style object to manufacture [`CorsPolicyNotFoundException`](crate::error::CorsPolicyNotFoundException)
    pub fn builder() -> crate::error::cors_policy_not_found_exception::Builder {
        crate::error::cors_policy_not_found_exception::Builder::default()
    }
}

/// <p>A service limit has been exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededException {}
/// See [`LimitExceededException`](crate::error::LimitExceededException)
pub mod limit_exceeded_exception {
    /// A builder for [`LimitExceededException`](crate::error::LimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededException`](crate::error::LimitExceededException)
        pub fn build(self) -> crate::error::LimitExceededException {
            crate::error::LimitExceededException {
                message: self.message,
            }
        }
    }
}
impl LimitExceededException {
    /// Creates a new builder-style object to manufacture [`LimitExceededException`](crate::error::LimitExceededException)
    pub fn builder() -> crate::error::limit_exceeded_exception::Builder {
        crate::error::limit_exceeded_exception::Builder::default()
    }
}
