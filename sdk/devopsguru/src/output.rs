// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateServiceIntegrationOutput {}
impl std::fmt::Debug for UpdateServiceIntegrationOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateServiceIntegrationOutput");
        formatter.finish()
    }
}
/// See [`UpdateServiceIntegrationOutput`](crate::output::UpdateServiceIntegrationOutput)
pub mod update_service_integration_output {

    /// A builder for [`UpdateServiceIntegrationOutput`](crate::output::UpdateServiceIntegrationOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`UpdateServiceIntegrationOutput`](crate::output::UpdateServiceIntegrationOutput)
        pub fn build(self) -> crate::output::UpdateServiceIntegrationOutput {
            crate::output::UpdateServiceIntegrationOutput {}
        }
    }
}
impl UpdateServiceIntegrationOutput {
    /// Creates a new builder-style object to manufacture [`UpdateServiceIntegrationOutput`](crate::output::UpdateServiceIntegrationOutput)
    pub fn builder() -> crate::output::update_service_integration_output::Builder {
        crate::output::update_service_integration_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateResourceCollectionOutput {}
impl std::fmt::Debug for UpdateResourceCollectionOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateResourceCollectionOutput");
        formatter.finish()
    }
}
/// See [`UpdateResourceCollectionOutput`](crate::output::UpdateResourceCollectionOutput)
pub mod update_resource_collection_output {

    /// A builder for [`UpdateResourceCollectionOutput`](crate::output::UpdateResourceCollectionOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`UpdateResourceCollectionOutput`](crate::output::UpdateResourceCollectionOutput)
        pub fn build(self) -> crate::output::UpdateResourceCollectionOutput {
            crate::output::UpdateResourceCollectionOutput {}
        }
    }
}
impl UpdateResourceCollectionOutput {
    /// Creates a new builder-style object to manufacture [`UpdateResourceCollectionOutput`](crate::output::UpdateResourceCollectionOutput)
    pub fn builder() -> crate::output::update_resource_collection_output::Builder {
        crate::output::update_resource_collection_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateEventSourcesConfigOutput {}
impl std::fmt::Debug for UpdateEventSourcesConfigOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateEventSourcesConfigOutput");
        formatter.finish()
    }
}
/// See [`UpdateEventSourcesConfigOutput`](crate::output::UpdateEventSourcesConfigOutput)
pub mod update_event_sources_config_output {

    /// A builder for [`UpdateEventSourcesConfigOutput`](crate::output::UpdateEventSourcesConfigOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`UpdateEventSourcesConfigOutput`](crate::output::UpdateEventSourcesConfigOutput)
        pub fn build(self) -> crate::output::UpdateEventSourcesConfigOutput {
            crate::output::UpdateEventSourcesConfigOutput {}
        }
    }
}
impl UpdateEventSourcesConfigOutput {
    /// Creates a new builder-style object to manufacture [`UpdateEventSourcesConfigOutput`](crate::output::UpdateEventSourcesConfigOutput)
    pub fn builder() -> crate::output::update_event_sources_config_output::Builder {
        crate::output::update_event_sources_config_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartCostEstimationOutput {}
impl std::fmt::Debug for StartCostEstimationOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartCostEstimationOutput");
        formatter.finish()
    }
}
/// See [`StartCostEstimationOutput`](crate::output::StartCostEstimationOutput)
pub mod start_cost_estimation_output {

    /// A builder for [`StartCostEstimationOutput`](crate::output::StartCostEstimationOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`StartCostEstimationOutput`](crate::output::StartCostEstimationOutput)
        pub fn build(self) -> crate::output::StartCostEstimationOutput {
            crate::output::StartCostEstimationOutput {}
        }
    }
}
impl StartCostEstimationOutput {
    /// Creates a new builder-style object to manufacture [`StartCostEstimationOutput`](crate::output::StartCostEstimationOutput)
    pub fn builder() -> crate::output::start_cost_estimation_output::Builder {
        crate::output::start_cost_estimation_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SearchOrganizationInsightsOutput {
    /// <p>An integer that specifies the number of open proactive insights in your Amazon Web Services account.</p>
    pub proactive_insights:
        std::option::Option<std::vec::Vec<crate::model::ProactiveInsightSummary>>,
    /// <p>An integer that specifies the number of open reactive insights in your Amazon Web Services account.</p>
    pub reactive_insights: std::option::Option<std::vec::Vec<crate::model::ReactiveInsightSummary>>,
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl SearchOrganizationInsightsOutput {
    /// <p>An integer that specifies the number of open proactive insights in your Amazon Web Services account.</p>
    pub fn proactive_insights(
        &self,
    ) -> std::option::Option<&[crate::model::ProactiveInsightSummary]> {
        self.proactive_insights.as_deref()
    }
    /// <p>An integer that specifies the number of open reactive insights in your Amazon Web Services account.</p>
    pub fn reactive_insights(
        &self,
    ) -> std::option::Option<&[crate::model::ReactiveInsightSummary]> {
        self.reactive_insights.as_deref()
    }
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for SearchOrganizationInsightsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SearchOrganizationInsightsOutput");
        formatter.field("proactive_insights", &self.proactive_insights);
        formatter.field("reactive_insights", &self.reactive_insights);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`SearchOrganizationInsightsOutput`](crate::output::SearchOrganizationInsightsOutput)
pub mod search_organization_insights_output {

    /// A builder for [`SearchOrganizationInsightsOutput`](crate::output::SearchOrganizationInsightsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) proactive_insights:
            std::option::Option<std::vec::Vec<crate::model::ProactiveInsightSummary>>,
        pub(crate) reactive_insights:
            std::option::Option<std::vec::Vec<crate::model::ReactiveInsightSummary>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `proactive_insights`.
        ///
        /// To override the contents of this collection use [`set_proactive_insights`](Self::set_proactive_insights).
        ///
        /// <p>An integer that specifies the number of open proactive insights in your Amazon Web Services account.</p>
        pub fn proactive_insights(mut self, input: crate::model::ProactiveInsightSummary) -> Self {
            let mut v = self.proactive_insights.unwrap_or_default();
            v.push(input);
            self.proactive_insights = Some(v);
            self
        }
        /// <p>An integer that specifies the number of open proactive insights in your Amazon Web Services account.</p>
        pub fn set_proactive_insights(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ProactiveInsightSummary>>,
        ) -> Self {
            self.proactive_insights = input;
            self
        }
        /// Appends an item to `reactive_insights`.
        ///
        /// To override the contents of this collection use [`set_reactive_insights`](Self::set_reactive_insights).
        ///
        /// <p>An integer that specifies the number of open reactive insights in your Amazon Web Services account.</p>
        pub fn reactive_insights(mut self, input: crate::model::ReactiveInsightSummary) -> Self {
            let mut v = self.reactive_insights.unwrap_or_default();
            v.push(input);
            self.reactive_insights = Some(v);
            self
        }
        /// <p>An integer that specifies the number of open reactive insights in your Amazon Web Services account.</p>
        pub fn set_reactive_insights(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ReactiveInsightSummary>>,
        ) -> Self {
            self.reactive_insights = input;
            self
        }
        /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`SearchOrganizationInsightsOutput`](crate::output::SearchOrganizationInsightsOutput)
        pub fn build(self) -> crate::output::SearchOrganizationInsightsOutput {
            crate::output::SearchOrganizationInsightsOutput {
                proactive_insights: self.proactive_insights,
                reactive_insights: self.reactive_insights,
                next_token: self.next_token,
            }
        }
    }
}
impl SearchOrganizationInsightsOutput {
    /// Creates a new builder-style object to manufacture [`SearchOrganizationInsightsOutput`](crate::output::SearchOrganizationInsightsOutput)
    pub fn builder() -> crate::output::search_organization_insights_output::Builder {
        crate::output::search_organization_insights_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SearchInsightsOutput {
    /// <p> The returned proactive insights. </p>
    pub proactive_insights:
        std::option::Option<std::vec::Vec<crate::model::ProactiveInsightSummary>>,
    /// <p> The returned reactive insights. </p>
    pub reactive_insights: std::option::Option<std::vec::Vec<crate::model::ReactiveInsightSummary>>,
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl SearchInsightsOutput {
    /// <p> The returned proactive insights. </p>
    pub fn proactive_insights(
        &self,
    ) -> std::option::Option<&[crate::model::ProactiveInsightSummary]> {
        self.proactive_insights.as_deref()
    }
    /// <p> The returned reactive insights. </p>
    pub fn reactive_insights(
        &self,
    ) -> std::option::Option<&[crate::model::ReactiveInsightSummary]> {
        self.reactive_insights.as_deref()
    }
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for SearchInsightsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SearchInsightsOutput");
        formatter.field("proactive_insights", &self.proactive_insights);
        formatter.field("reactive_insights", &self.reactive_insights);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`SearchInsightsOutput`](crate::output::SearchInsightsOutput)
pub mod search_insights_output {

    /// A builder for [`SearchInsightsOutput`](crate::output::SearchInsightsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) proactive_insights:
            std::option::Option<std::vec::Vec<crate::model::ProactiveInsightSummary>>,
        pub(crate) reactive_insights:
            std::option::Option<std::vec::Vec<crate::model::ReactiveInsightSummary>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `proactive_insights`.
        ///
        /// To override the contents of this collection use [`set_proactive_insights`](Self::set_proactive_insights).
        ///
        /// <p> The returned proactive insights. </p>
        pub fn proactive_insights(mut self, input: crate::model::ProactiveInsightSummary) -> Self {
            let mut v = self.proactive_insights.unwrap_or_default();
            v.push(input);
            self.proactive_insights = Some(v);
            self
        }
        /// <p> The returned proactive insights. </p>
        pub fn set_proactive_insights(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ProactiveInsightSummary>>,
        ) -> Self {
            self.proactive_insights = input;
            self
        }
        /// Appends an item to `reactive_insights`.
        ///
        /// To override the contents of this collection use [`set_reactive_insights`](Self::set_reactive_insights).
        ///
        /// <p> The returned reactive insights. </p>
        pub fn reactive_insights(mut self, input: crate::model::ReactiveInsightSummary) -> Self {
            let mut v = self.reactive_insights.unwrap_or_default();
            v.push(input);
            self.reactive_insights = Some(v);
            self
        }
        /// <p> The returned reactive insights. </p>
        pub fn set_reactive_insights(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ReactiveInsightSummary>>,
        ) -> Self {
            self.reactive_insights = input;
            self
        }
        /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`SearchInsightsOutput`](crate::output::SearchInsightsOutput)
        pub fn build(self) -> crate::output::SearchInsightsOutput {
            crate::output::SearchInsightsOutput {
                proactive_insights: self.proactive_insights,
                reactive_insights: self.reactive_insights,
                next_token: self.next_token,
            }
        }
    }
}
impl SearchInsightsOutput {
    /// Creates a new builder-style object to manufacture [`SearchInsightsOutput`](crate::output::SearchInsightsOutput)
    pub fn builder() -> crate::output::search_insights_output::Builder {
        crate::output::search_insights_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RemoveNotificationChannelOutput {}
impl std::fmt::Debug for RemoveNotificationChannelOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RemoveNotificationChannelOutput");
        formatter.finish()
    }
}
/// See [`RemoveNotificationChannelOutput`](crate::output::RemoveNotificationChannelOutput)
pub mod remove_notification_channel_output {

    /// A builder for [`RemoveNotificationChannelOutput`](crate::output::RemoveNotificationChannelOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`RemoveNotificationChannelOutput`](crate::output::RemoveNotificationChannelOutput)
        pub fn build(self) -> crate::output::RemoveNotificationChannelOutput {
            crate::output::RemoveNotificationChannelOutput {}
        }
    }
}
impl RemoveNotificationChannelOutput {
    /// Creates a new builder-style object to manufacture [`RemoveNotificationChannelOutput`](crate::output::RemoveNotificationChannelOutput)
    pub fn builder() -> crate::output::remove_notification_channel_output::Builder {
        crate::output::remove_notification_channel_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutFeedbackOutput {}
impl std::fmt::Debug for PutFeedbackOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutFeedbackOutput");
        formatter.finish()
    }
}
/// See [`PutFeedbackOutput`](crate::output::PutFeedbackOutput)
pub mod put_feedback_output {

    /// A builder for [`PutFeedbackOutput`](crate::output::PutFeedbackOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`PutFeedbackOutput`](crate::output::PutFeedbackOutput)
        pub fn build(self) -> crate::output::PutFeedbackOutput {
            crate::output::PutFeedbackOutput {}
        }
    }
}
impl PutFeedbackOutput {
    /// Creates a new builder-style object to manufacture [`PutFeedbackOutput`](crate::output::PutFeedbackOutput)
    pub fn builder() -> crate::output::put_feedback_output::Builder {
        crate::output::put_feedback_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListRecommendationsOutput {
    /// <p> An array of the requested recommendations. </p>
    pub recommendations: std::option::Option<std::vec::Vec<crate::model::Recommendation>>,
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListRecommendationsOutput {
    /// <p> An array of the requested recommendations. </p>
    pub fn recommendations(&self) -> std::option::Option<&[crate::model::Recommendation]> {
        self.recommendations.as_deref()
    }
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListRecommendationsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListRecommendationsOutput");
        formatter.field("recommendations", &self.recommendations);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListRecommendationsOutput`](crate::output::ListRecommendationsOutput)
pub mod list_recommendations_output {

    /// A builder for [`ListRecommendationsOutput`](crate::output::ListRecommendationsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) recommendations:
            std::option::Option<std::vec::Vec<crate::model::Recommendation>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `recommendations`.
        ///
        /// To override the contents of this collection use [`set_recommendations`](Self::set_recommendations).
        ///
        /// <p> An array of the requested recommendations. </p>
        pub fn recommendations(mut self, input: crate::model::Recommendation) -> Self {
            let mut v = self.recommendations.unwrap_or_default();
            v.push(input);
            self.recommendations = Some(v);
            self
        }
        /// <p> An array of the requested recommendations. </p>
        pub fn set_recommendations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Recommendation>>,
        ) -> Self {
            self.recommendations = input;
            self
        }
        /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListRecommendationsOutput`](crate::output::ListRecommendationsOutput)
        pub fn build(self) -> crate::output::ListRecommendationsOutput {
            crate::output::ListRecommendationsOutput {
                recommendations: self.recommendations,
                next_token: self.next_token,
            }
        }
    }
}
impl ListRecommendationsOutput {
    /// Creates a new builder-style object to manufacture [`ListRecommendationsOutput`](crate::output::ListRecommendationsOutput)
    pub fn builder() -> crate::output::list_recommendations_output::Builder {
        crate::output::list_recommendations_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListOrganizationInsightsOutput {
    /// <p>An integer that specifies the number of open proactive insights in your Amazon Web Services account.</p>
    pub proactive_insights:
        std::option::Option<std::vec::Vec<crate::model::ProactiveOrganizationInsightSummary>>,
    /// <p>An integer that specifies the number of open reactive insights in your Amazon Web Services account.</p>
    pub reactive_insights:
        std::option::Option<std::vec::Vec<crate::model::ReactiveOrganizationInsightSummary>>,
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListOrganizationInsightsOutput {
    /// <p>An integer that specifies the number of open proactive insights in your Amazon Web Services account.</p>
    pub fn proactive_insights(
        &self,
    ) -> std::option::Option<&[crate::model::ProactiveOrganizationInsightSummary]> {
        self.proactive_insights.as_deref()
    }
    /// <p>An integer that specifies the number of open reactive insights in your Amazon Web Services account.</p>
    pub fn reactive_insights(
        &self,
    ) -> std::option::Option<&[crate::model::ReactiveOrganizationInsightSummary]> {
        self.reactive_insights.as_deref()
    }
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListOrganizationInsightsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListOrganizationInsightsOutput");
        formatter.field("proactive_insights", &self.proactive_insights);
        formatter.field("reactive_insights", &self.reactive_insights);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListOrganizationInsightsOutput`](crate::output::ListOrganizationInsightsOutput)
pub mod list_organization_insights_output {

    /// A builder for [`ListOrganizationInsightsOutput`](crate::output::ListOrganizationInsightsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) proactive_insights:
            std::option::Option<std::vec::Vec<crate::model::ProactiveOrganizationInsightSummary>>,
        pub(crate) reactive_insights:
            std::option::Option<std::vec::Vec<crate::model::ReactiveOrganizationInsightSummary>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `proactive_insights`.
        ///
        /// To override the contents of this collection use [`set_proactive_insights`](Self::set_proactive_insights).
        ///
        /// <p>An integer that specifies the number of open proactive insights in your Amazon Web Services account.</p>
        pub fn proactive_insights(
            mut self,
            input: crate::model::ProactiveOrganizationInsightSummary,
        ) -> Self {
            let mut v = self.proactive_insights.unwrap_or_default();
            v.push(input);
            self.proactive_insights = Some(v);
            self
        }
        /// <p>An integer that specifies the number of open proactive insights in your Amazon Web Services account.</p>
        pub fn set_proactive_insights(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ProactiveOrganizationInsightSummary>,
            >,
        ) -> Self {
            self.proactive_insights = input;
            self
        }
        /// Appends an item to `reactive_insights`.
        ///
        /// To override the contents of this collection use [`set_reactive_insights`](Self::set_reactive_insights).
        ///
        /// <p>An integer that specifies the number of open reactive insights in your Amazon Web Services account.</p>
        pub fn reactive_insights(
            mut self,
            input: crate::model::ReactiveOrganizationInsightSummary,
        ) -> Self {
            let mut v = self.reactive_insights.unwrap_or_default();
            v.push(input);
            self.reactive_insights = Some(v);
            self
        }
        /// <p>An integer that specifies the number of open reactive insights in your Amazon Web Services account.</p>
        pub fn set_reactive_insights(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ReactiveOrganizationInsightSummary>,
            >,
        ) -> Self {
            self.reactive_insights = input;
            self
        }
        /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListOrganizationInsightsOutput`](crate::output::ListOrganizationInsightsOutput)
        pub fn build(self) -> crate::output::ListOrganizationInsightsOutput {
            crate::output::ListOrganizationInsightsOutput {
                proactive_insights: self.proactive_insights,
                reactive_insights: self.reactive_insights,
                next_token: self.next_token,
            }
        }
    }
}
impl ListOrganizationInsightsOutput {
    /// Creates a new builder-style object to manufacture [`ListOrganizationInsightsOutput`](crate::output::ListOrganizationInsightsOutput)
    pub fn builder() -> crate::output::list_organization_insights_output::Builder {
        crate::output::list_organization_insights_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListNotificationChannelsOutput {
    /// <p> An array that contains the requested notification channels. </p>
    pub channels: std::option::Option<std::vec::Vec<crate::model::NotificationChannel>>,
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListNotificationChannelsOutput {
    /// <p> An array that contains the requested notification channels. </p>
    pub fn channels(&self) -> std::option::Option<&[crate::model::NotificationChannel]> {
        self.channels.as_deref()
    }
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListNotificationChannelsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListNotificationChannelsOutput");
        formatter.field("channels", &self.channels);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListNotificationChannelsOutput`](crate::output::ListNotificationChannelsOutput)
pub mod list_notification_channels_output {

    /// A builder for [`ListNotificationChannelsOutput`](crate::output::ListNotificationChannelsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channels: std::option::Option<std::vec::Vec<crate::model::NotificationChannel>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `channels`.
        ///
        /// To override the contents of this collection use [`set_channels`](Self::set_channels).
        ///
        /// <p> An array that contains the requested notification channels. </p>
        pub fn channels(mut self, input: crate::model::NotificationChannel) -> Self {
            let mut v = self.channels.unwrap_or_default();
            v.push(input);
            self.channels = Some(v);
            self
        }
        /// <p> An array that contains the requested notification channels. </p>
        pub fn set_channels(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NotificationChannel>>,
        ) -> Self {
            self.channels = input;
            self
        }
        /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListNotificationChannelsOutput`](crate::output::ListNotificationChannelsOutput)
        pub fn build(self) -> crate::output::ListNotificationChannelsOutput {
            crate::output::ListNotificationChannelsOutput {
                channels: self.channels,
                next_token: self.next_token,
            }
        }
    }
}
impl ListNotificationChannelsOutput {
    /// Creates a new builder-style object to manufacture [`ListNotificationChannelsOutput`](crate::output::ListNotificationChannelsOutput)
    pub fn builder() -> crate::output::list_notification_channels_output::Builder {
        crate::output::list_notification_channels_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListInsightsOutput {
    /// <p> The returned list of proactive insights. </p>
    pub proactive_insights:
        std::option::Option<std::vec::Vec<crate::model::ProactiveInsightSummary>>,
    /// <p> The returned list of reactive insights. </p>
    pub reactive_insights: std::option::Option<std::vec::Vec<crate::model::ReactiveInsightSummary>>,
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListInsightsOutput {
    /// <p> The returned list of proactive insights. </p>
    pub fn proactive_insights(
        &self,
    ) -> std::option::Option<&[crate::model::ProactiveInsightSummary]> {
        self.proactive_insights.as_deref()
    }
    /// <p> The returned list of reactive insights. </p>
    pub fn reactive_insights(
        &self,
    ) -> std::option::Option<&[crate::model::ReactiveInsightSummary]> {
        self.reactive_insights.as_deref()
    }
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListInsightsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListInsightsOutput");
        formatter.field("proactive_insights", &self.proactive_insights);
        formatter.field("reactive_insights", &self.reactive_insights);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListInsightsOutput`](crate::output::ListInsightsOutput)
pub mod list_insights_output {

    /// A builder for [`ListInsightsOutput`](crate::output::ListInsightsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) proactive_insights:
            std::option::Option<std::vec::Vec<crate::model::ProactiveInsightSummary>>,
        pub(crate) reactive_insights:
            std::option::Option<std::vec::Vec<crate::model::ReactiveInsightSummary>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `proactive_insights`.
        ///
        /// To override the contents of this collection use [`set_proactive_insights`](Self::set_proactive_insights).
        ///
        /// <p> The returned list of proactive insights. </p>
        pub fn proactive_insights(mut self, input: crate::model::ProactiveInsightSummary) -> Self {
            let mut v = self.proactive_insights.unwrap_or_default();
            v.push(input);
            self.proactive_insights = Some(v);
            self
        }
        /// <p> The returned list of proactive insights. </p>
        pub fn set_proactive_insights(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ProactiveInsightSummary>>,
        ) -> Self {
            self.proactive_insights = input;
            self
        }
        /// Appends an item to `reactive_insights`.
        ///
        /// To override the contents of this collection use [`set_reactive_insights`](Self::set_reactive_insights).
        ///
        /// <p> The returned list of reactive insights. </p>
        pub fn reactive_insights(mut self, input: crate::model::ReactiveInsightSummary) -> Self {
            let mut v = self.reactive_insights.unwrap_or_default();
            v.push(input);
            self.reactive_insights = Some(v);
            self
        }
        /// <p> The returned list of reactive insights. </p>
        pub fn set_reactive_insights(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ReactiveInsightSummary>>,
        ) -> Self {
            self.reactive_insights = input;
            self
        }
        /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListInsightsOutput`](crate::output::ListInsightsOutput)
        pub fn build(self) -> crate::output::ListInsightsOutput {
            crate::output::ListInsightsOutput {
                proactive_insights: self.proactive_insights,
                reactive_insights: self.reactive_insights,
                next_token: self.next_token,
            }
        }
    }
}
impl ListInsightsOutput {
    /// Creates a new builder-style object to manufacture [`ListInsightsOutput`](crate::output::ListInsightsOutput)
    pub fn builder() -> crate::output::list_insights_output::Builder {
        crate::output::list_insights_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListEventsOutput {
    /// <p> A list of the requested events. </p>
    pub events: std::option::Option<std::vec::Vec<crate::model::Event>>,
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListEventsOutput {
    /// <p> A list of the requested events. </p>
    pub fn events(&self) -> std::option::Option<&[crate::model::Event]> {
        self.events.as_deref()
    }
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListEventsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListEventsOutput");
        formatter.field("events", &self.events);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListEventsOutput`](crate::output::ListEventsOutput)
pub mod list_events_output {

    /// A builder for [`ListEventsOutput`](crate::output::ListEventsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) events: std::option::Option<std::vec::Vec<crate::model::Event>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `events`.
        ///
        /// To override the contents of this collection use [`set_events`](Self::set_events).
        ///
        /// <p> A list of the requested events. </p>
        pub fn events(mut self, input: crate::model::Event) -> Self {
            let mut v = self.events.unwrap_or_default();
            v.push(input);
            self.events = Some(v);
            self
        }
        /// <p> A list of the requested events. </p>
        pub fn set_events(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Event>>,
        ) -> Self {
            self.events = input;
            self
        }
        /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListEventsOutput`](crate::output::ListEventsOutput)
        pub fn build(self) -> crate::output::ListEventsOutput {
            crate::output::ListEventsOutput {
                events: self.events,
                next_token: self.next_token,
            }
        }
    }
}
impl ListEventsOutput {
    /// Creates a new builder-style object to manufacture [`ListEventsOutput`](crate::output::ListEventsOutput)
    pub fn builder() -> crate::output::list_events_output::Builder {
        crate::output::list_events_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAnomaliesForInsightOutput {
    /// <p> An array of <code>ProactiveAnomalySummary</code> objects that represent the requested anomalies </p>
    pub proactive_anomalies:
        std::option::Option<std::vec::Vec<crate::model::ProactiveAnomalySummary>>,
    /// <p> An array of <code>ReactiveAnomalySummary</code> objects that represent the requested anomalies </p>
    pub reactive_anomalies:
        std::option::Option<std::vec::Vec<crate::model::ReactiveAnomalySummary>>,
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListAnomaliesForInsightOutput {
    /// <p> An array of <code>ProactiveAnomalySummary</code> objects that represent the requested anomalies </p>
    pub fn proactive_anomalies(
        &self,
    ) -> std::option::Option<&[crate::model::ProactiveAnomalySummary]> {
        self.proactive_anomalies.as_deref()
    }
    /// <p> An array of <code>ReactiveAnomalySummary</code> objects that represent the requested anomalies </p>
    pub fn reactive_anomalies(
        &self,
    ) -> std::option::Option<&[crate::model::ReactiveAnomalySummary]> {
        self.reactive_anomalies.as_deref()
    }
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListAnomaliesForInsightOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAnomaliesForInsightOutput");
        formatter.field("proactive_anomalies", &self.proactive_anomalies);
        formatter.field("reactive_anomalies", &self.reactive_anomalies);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListAnomaliesForInsightOutput`](crate::output::ListAnomaliesForInsightOutput)
pub mod list_anomalies_for_insight_output {

    /// A builder for [`ListAnomaliesForInsightOutput`](crate::output::ListAnomaliesForInsightOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) proactive_anomalies:
            std::option::Option<std::vec::Vec<crate::model::ProactiveAnomalySummary>>,
        pub(crate) reactive_anomalies:
            std::option::Option<std::vec::Vec<crate::model::ReactiveAnomalySummary>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `proactive_anomalies`.
        ///
        /// To override the contents of this collection use [`set_proactive_anomalies`](Self::set_proactive_anomalies).
        ///
        /// <p> An array of <code>ProactiveAnomalySummary</code> objects that represent the requested anomalies </p>
        pub fn proactive_anomalies(mut self, input: crate::model::ProactiveAnomalySummary) -> Self {
            let mut v = self.proactive_anomalies.unwrap_or_default();
            v.push(input);
            self.proactive_anomalies = Some(v);
            self
        }
        /// <p> An array of <code>ProactiveAnomalySummary</code> objects that represent the requested anomalies </p>
        pub fn set_proactive_anomalies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ProactiveAnomalySummary>>,
        ) -> Self {
            self.proactive_anomalies = input;
            self
        }
        /// Appends an item to `reactive_anomalies`.
        ///
        /// To override the contents of this collection use [`set_reactive_anomalies`](Self::set_reactive_anomalies).
        ///
        /// <p> An array of <code>ReactiveAnomalySummary</code> objects that represent the requested anomalies </p>
        pub fn reactive_anomalies(mut self, input: crate::model::ReactiveAnomalySummary) -> Self {
            let mut v = self.reactive_anomalies.unwrap_or_default();
            v.push(input);
            self.reactive_anomalies = Some(v);
            self
        }
        /// <p> An array of <code>ReactiveAnomalySummary</code> objects that represent the requested anomalies </p>
        pub fn set_reactive_anomalies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ReactiveAnomalySummary>>,
        ) -> Self {
            self.reactive_anomalies = input;
            self
        }
        /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListAnomaliesForInsightOutput`](crate::output::ListAnomaliesForInsightOutput)
        pub fn build(self) -> crate::output::ListAnomaliesForInsightOutput {
            crate::output::ListAnomaliesForInsightOutput {
                proactive_anomalies: self.proactive_anomalies,
                reactive_anomalies: self.reactive_anomalies,
                next_token: self.next_token,
            }
        }
    }
}
impl ListAnomaliesForInsightOutput {
    /// Creates a new builder-style object to manufacture [`ListAnomaliesForInsightOutput`](crate::output::ListAnomaliesForInsightOutput)
    pub fn builder() -> crate::output::list_anomalies_for_insight_output::Builder {
        crate::output::list_anomalies_for_insight_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetResourceCollectionOutput {
    /// <p> The requested list of Amazon Web Services resource collections. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag <i>key</i>. You can specify up to 500 Amazon Web Services CloudFormation stacks. </p>
    pub resource_collection: std::option::Option<crate::model::ResourceCollectionFilter>,
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl GetResourceCollectionOutput {
    /// <p> The requested list of Amazon Web Services resource collections. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag <i>key</i>. You can specify up to 500 Amazon Web Services CloudFormation stacks. </p>
    pub fn resource_collection(
        &self,
    ) -> std::option::Option<&crate::model::ResourceCollectionFilter> {
        self.resource_collection.as_ref()
    }
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for GetResourceCollectionOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetResourceCollectionOutput");
        formatter.field("resource_collection", &self.resource_collection);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`GetResourceCollectionOutput`](crate::output::GetResourceCollectionOutput)
pub mod get_resource_collection_output {

    /// A builder for [`GetResourceCollectionOutput`](crate::output::GetResourceCollectionOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_collection: std::option::Option<crate::model::ResourceCollectionFilter>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The requested list of Amazon Web Services resource collections. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag <i>key</i>. You can specify up to 500 Amazon Web Services CloudFormation stacks. </p>
        pub fn resource_collection(
            mut self,
            input: crate::model::ResourceCollectionFilter,
        ) -> Self {
            self.resource_collection = Some(input);
            self
        }
        /// <p> The requested list of Amazon Web Services resource collections. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag <i>key</i>. You can specify up to 500 Amazon Web Services CloudFormation stacks. </p>
        pub fn set_resource_collection(
            mut self,
            input: std::option::Option<crate::model::ResourceCollectionFilter>,
        ) -> Self {
            self.resource_collection = input;
            self
        }
        /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetResourceCollectionOutput`](crate::output::GetResourceCollectionOutput)
        pub fn build(self) -> crate::output::GetResourceCollectionOutput {
            crate::output::GetResourceCollectionOutput {
                resource_collection: self.resource_collection,
                next_token: self.next_token,
            }
        }
    }
}
impl GetResourceCollectionOutput {
    /// Creates a new builder-style object to manufacture [`GetResourceCollectionOutput`](crate::output::GetResourceCollectionOutput)
    pub fn builder() -> crate::output::get_resource_collection_output::Builder {
        crate::output::get_resource_collection_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetCostEstimationOutput {
    /// <p>The collection of the Amazon Web Services resources used to create your monthly DevOps Guru cost estimate.</p>
    pub resource_collection:
        std::option::Option<crate::model::CostEstimationResourceCollectionFilter>,
    /// <p>The status of creating this cost estimate. If it's still in progress, the status <code>ONGOING</code> is returned. If it is finished, the status <code>COMPLETED</code> is returned.</p>
    pub status: std::option::Option<crate::model::CostEstimationStatus>,
    /// <p>An array of <code>ResourceCost</code> objects that each contains details about the monthly cost estimate to analyze one of your Amazon Web Services resources.</p>
    pub costs: std::option::Option<std::vec::Vec<crate::model::ServiceResourceCost>>,
    /// <p>The start and end time of the cost estimation.</p>
    pub time_range: std::option::Option<crate::model::CostEstimationTimeRange>,
    /// <p>The estimated monthly cost to analyze the Amazon Web Services resources. This value is the sum of the estimated costs to analyze each resource in the <code>Costs</code> object in this response.</p>
    pub total_cost: f64,
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl GetCostEstimationOutput {
    /// <p>The collection of the Amazon Web Services resources used to create your monthly DevOps Guru cost estimate.</p>
    pub fn resource_collection(
        &self,
    ) -> std::option::Option<&crate::model::CostEstimationResourceCollectionFilter> {
        self.resource_collection.as_ref()
    }
    /// <p>The status of creating this cost estimate. If it's still in progress, the status <code>ONGOING</code> is returned. If it is finished, the status <code>COMPLETED</code> is returned.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::CostEstimationStatus> {
        self.status.as_ref()
    }
    /// <p>An array of <code>ResourceCost</code> objects that each contains details about the monthly cost estimate to analyze one of your Amazon Web Services resources.</p>
    pub fn costs(&self) -> std::option::Option<&[crate::model::ServiceResourceCost]> {
        self.costs.as_deref()
    }
    /// <p>The start and end time of the cost estimation.</p>
    pub fn time_range(&self) -> std::option::Option<&crate::model::CostEstimationTimeRange> {
        self.time_range.as_ref()
    }
    /// <p>The estimated monthly cost to analyze the Amazon Web Services resources. This value is the sum of the estimated costs to analyze each resource in the <code>Costs</code> object in this response.</p>
    pub fn total_cost(&self) -> f64 {
        self.total_cost
    }
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for GetCostEstimationOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetCostEstimationOutput");
        formatter.field("resource_collection", &self.resource_collection);
        formatter.field("status", &self.status);
        formatter.field("costs", &self.costs);
        formatter.field("time_range", &self.time_range);
        formatter.field("total_cost", &self.total_cost);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`GetCostEstimationOutput`](crate::output::GetCostEstimationOutput)
pub mod get_cost_estimation_output {

    /// A builder for [`GetCostEstimationOutput`](crate::output::GetCostEstimationOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_collection:
            std::option::Option<crate::model::CostEstimationResourceCollectionFilter>,
        pub(crate) status: std::option::Option<crate::model::CostEstimationStatus>,
        pub(crate) costs: std::option::Option<std::vec::Vec<crate::model::ServiceResourceCost>>,
        pub(crate) time_range: std::option::Option<crate::model::CostEstimationTimeRange>,
        pub(crate) total_cost: std::option::Option<f64>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The collection of the Amazon Web Services resources used to create your monthly DevOps Guru cost estimate.</p>
        pub fn resource_collection(
            mut self,
            input: crate::model::CostEstimationResourceCollectionFilter,
        ) -> Self {
            self.resource_collection = Some(input);
            self
        }
        /// <p>The collection of the Amazon Web Services resources used to create your monthly DevOps Guru cost estimate.</p>
        pub fn set_resource_collection(
            mut self,
            input: std::option::Option<crate::model::CostEstimationResourceCollectionFilter>,
        ) -> Self {
            self.resource_collection = input;
            self
        }
        /// <p>The status of creating this cost estimate. If it's still in progress, the status <code>ONGOING</code> is returned. If it is finished, the status <code>COMPLETED</code> is returned.</p>
        pub fn status(mut self, input: crate::model::CostEstimationStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of creating this cost estimate. If it's still in progress, the status <code>ONGOING</code> is returned. If it is finished, the status <code>COMPLETED</code> is returned.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::CostEstimationStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Appends an item to `costs`.
        ///
        /// To override the contents of this collection use [`set_costs`](Self::set_costs).
        ///
        /// <p>An array of <code>ResourceCost</code> objects that each contains details about the monthly cost estimate to analyze one of your Amazon Web Services resources.</p>
        pub fn costs(mut self, input: crate::model::ServiceResourceCost) -> Self {
            let mut v = self.costs.unwrap_or_default();
            v.push(input);
            self.costs = Some(v);
            self
        }
        /// <p>An array of <code>ResourceCost</code> objects that each contains details about the monthly cost estimate to analyze one of your Amazon Web Services resources.</p>
        pub fn set_costs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ServiceResourceCost>>,
        ) -> Self {
            self.costs = input;
            self
        }
        /// <p>The start and end time of the cost estimation.</p>
        pub fn time_range(mut self, input: crate::model::CostEstimationTimeRange) -> Self {
            self.time_range = Some(input);
            self
        }
        /// <p>The start and end time of the cost estimation.</p>
        pub fn set_time_range(
            mut self,
            input: std::option::Option<crate::model::CostEstimationTimeRange>,
        ) -> Self {
            self.time_range = input;
            self
        }
        /// <p>The estimated monthly cost to analyze the Amazon Web Services resources. This value is the sum of the estimated costs to analyze each resource in the <code>Costs</code> object in this response.</p>
        pub fn total_cost(mut self, input: f64) -> Self {
            self.total_cost = Some(input);
            self
        }
        /// <p>The estimated monthly cost to analyze the Amazon Web Services resources. This value is the sum of the estimated costs to analyze each resource in the <code>Costs</code> object in this response.</p>
        pub fn set_total_cost(mut self, input: std::option::Option<f64>) -> Self {
            self.total_cost = input;
            self
        }
        /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetCostEstimationOutput`](crate::output::GetCostEstimationOutput)
        pub fn build(self) -> crate::output::GetCostEstimationOutput {
            crate::output::GetCostEstimationOutput {
                resource_collection: self.resource_collection,
                status: self.status,
                costs: self.costs,
                time_range: self.time_range,
                total_cost: self.total_cost.unwrap_or_default(),
                next_token: self.next_token,
            }
        }
    }
}
impl GetCostEstimationOutput {
    /// Creates a new builder-style object to manufacture [`GetCostEstimationOutput`](crate::output::GetCostEstimationOutput)
    pub fn builder() -> crate::output::get_cost_estimation_output::Builder {
        crate::output::get_cost_estimation_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeServiceIntegrationOutput {
    /// <p> Information about the integration of DevOps Guru with another Amazon Web Services service, such as Amazon Web Services Systems Manager. </p>
    pub service_integration: std::option::Option<crate::model::ServiceIntegrationConfig>,
}
impl DescribeServiceIntegrationOutput {
    /// <p> Information about the integration of DevOps Guru with another Amazon Web Services service, such as Amazon Web Services Systems Manager. </p>
    pub fn service_integration(
        &self,
    ) -> std::option::Option<&crate::model::ServiceIntegrationConfig> {
        self.service_integration.as_ref()
    }
}
impl std::fmt::Debug for DescribeServiceIntegrationOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeServiceIntegrationOutput");
        formatter.field("service_integration", &self.service_integration);
        formatter.finish()
    }
}
/// See [`DescribeServiceIntegrationOutput`](crate::output::DescribeServiceIntegrationOutput)
pub mod describe_service_integration_output {

    /// A builder for [`DescribeServiceIntegrationOutput`](crate::output::DescribeServiceIntegrationOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) service_integration: std::option::Option<crate::model::ServiceIntegrationConfig>,
    }
    impl Builder {
        /// <p> Information about the integration of DevOps Guru with another Amazon Web Services service, such as Amazon Web Services Systems Manager. </p>
        pub fn service_integration(
            mut self,
            input: crate::model::ServiceIntegrationConfig,
        ) -> Self {
            self.service_integration = Some(input);
            self
        }
        /// <p> Information about the integration of DevOps Guru with another Amazon Web Services service, such as Amazon Web Services Systems Manager. </p>
        pub fn set_service_integration(
            mut self,
            input: std::option::Option<crate::model::ServiceIntegrationConfig>,
        ) -> Self {
            self.service_integration = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeServiceIntegrationOutput`](crate::output::DescribeServiceIntegrationOutput)
        pub fn build(self) -> crate::output::DescribeServiceIntegrationOutput {
            crate::output::DescribeServiceIntegrationOutput {
                service_integration: self.service_integration,
            }
        }
    }
}
impl DescribeServiceIntegrationOutput {
    /// Creates a new builder-style object to manufacture [`DescribeServiceIntegrationOutput`](crate::output::DescribeServiceIntegrationOutput)
    pub fn builder() -> crate::output::describe_service_integration_output::Builder {
        crate::output::describe_service_integration_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeResourceCollectionHealthOutput {
    /// <p> The returned <code>CloudFormationHealthOverview</code> object that contains an <code>InsightHealthOverview</code> object with the requested system health information. </p>
    pub cloud_formation: std::option::Option<std::vec::Vec<crate::model::CloudFormationHealth>>,
    /// <p>An array of <code>ServiceHealth</code> objects that describes the health of the Amazon Web Services services associated with the resources in the collection.</p>
    pub service: std::option::Option<std::vec::Vec<crate::model::ServiceHealth>>,
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services tags that are used by resources in the resource collection.</p>
    /// <p>Tags help you identify and organize your Amazon Web Services resources. Many Amazon Web Services services support tagging, so you can assign the same tag to resources from different services to indicate that the resources are related. For example, you can assign the same tag to an Amazon DynamoDB table resource that you assign to an Lambda function. For more information about using tags, see the <a href="https://d1.awsstatic.com/whitepapers/aws-tagging-best-practices.pdf">Tagging best practices</a> whitepaper. </p>
    /// <p>Each Amazon Web Services tag has two parts. </p>
    /// <ul>
    /// <li> <p>A tag <i>key</i> (for example, <code>CostCenter</code>, <code>Environment</code>, <code>Project</code>, or <code>Secret</code>). Tag <i>keys</i> are case-sensitive.</p> </li>
    /// <li> <p>An optional field known as a tag <i>value</i> (for example, <code>111122223333</code>, <code>Production</code>, or a team name). Omitting the tag <i>value</i> is the same as using an empty string. Like tag <i>keys</i>, tag <i>values</i> are case-sensitive.</p> </li>
    /// </ul>
    /// <p>Together these are known as <i>key</i>-<i>value</i> pairs.</p> <important>
    /// <p>The string used for a <i>key</i> in a tag that you use to define your resource coverage must begin with the prefix <code>Devops-guru-</code>. The tag <i>key</i> might be <code>Devops-guru-deployment-application</code> or <code>Devops-guru-rds-application</code>. While <i>keys</i> are case-sensitive, the case of <i>key</i> characters don't matter to DevOps Guru. For example, DevOps Guru works with a <i>key</i> named <code>devops-guru-rds</code> and a <i>key</i> named <code>DevOps-Guru-RDS</code>. Possible <i>key</i>/<i>value</i> pairs in your application might be <code>Devops-Guru-production-application/RDS</code> or <code>Devops-Guru-production-application/containers</code>.</p>
    /// </important>
    pub tags: std::option::Option<std::vec::Vec<crate::model::TagHealth>>,
}
impl DescribeResourceCollectionHealthOutput {
    /// <p> The returned <code>CloudFormationHealthOverview</code> object that contains an <code>InsightHealthOverview</code> object with the requested system health information. </p>
    pub fn cloud_formation(&self) -> std::option::Option<&[crate::model::CloudFormationHealth]> {
        self.cloud_formation.as_deref()
    }
    /// <p>An array of <code>ServiceHealth</code> objects that describes the health of the Amazon Web Services services associated with the resources in the collection.</p>
    pub fn service(&self) -> std::option::Option<&[crate::model::ServiceHealth]> {
        self.service.as_deref()
    }
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The Amazon Web Services tags that are used by resources in the resource collection.</p>
    /// <p>Tags help you identify and organize your Amazon Web Services resources. Many Amazon Web Services services support tagging, so you can assign the same tag to resources from different services to indicate that the resources are related. For example, you can assign the same tag to an Amazon DynamoDB table resource that you assign to an Lambda function. For more information about using tags, see the <a href="https://d1.awsstatic.com/whitepapers/aws-tagging-best-practices.pdf">Tagging best practices</a> whitepaper. </p>
    /// <p>Each Amazon Web Services tag has two parts. </p>
    /// <ul>
    /// <li> <p>A tag <i>key</i> (for example, <code>CostCenter</code>, <code>Environment</code>, <code>Project</code>, or <code>Secret</code>). Tag <i>keys</i> are case-sensitive.</p> </li>
    /// <li> <p>An optional field known as a tag <i>value</i> (for example, <code>111122223333</code>, <code>Production</code>, or a team name). Omitting the tag <i>value</i> is the same as using an empty string. Like tag <i>keys</i>, tag <i>values</i> are case-sensitive.</p> </li>
    /// </ul>
    /// <p>Together these are known as <i>key</i>-<i>value</i> pairs.</p> <important>
    /// <p>The string used for a <i>key</i> in a tag that you use to define your resource coverage must begin with the prefix <code>Devops-guru-</code>. The tag <i>key</i> might be <code>Devops-guru-deployment-application</code> or <code>Devops-guru-rds-application</code>. While <i>keys</i> are case-sensitive, the case of <i>key</i> characters don't matter to DevOps Guru. For example, DevOps Guru works with a <i>key</i> named <code>devops-guru-rds</code> and a <i>key</i> named <code>DevOps-Guru-RDS</code>. Possible <i>key</i>/<i>value</i> pairs in your application might be <code>Devops-Guru-production-application/RDS</code> or <code>Devops-Guru-production-application/containers</code>.</p>
    /// </important>
    pub fn tags(&self) -> std::option::Option<&[crate::model::TagHealth]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for DescribeResourceCollectionHealthOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeResourceCollectionHealthOutput");
        formatter.field("cloud_formation", &self.cloud_formation);
        formatter.field("service", &self.service);
        formatter.field("next_token", &self.next_token);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`DescribeResourceCollectionHealthOutput`](crate::output::DescribeResourceCollectionHealthOutput)
pub mod describe_resource_collection_health_output {

    /// A builder for [`DescribeResourceCollectionHealthOutput`](crate::output::DescribeResourceCollectionHealthOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cloud_formation:
            std::option::Option<std::vec::Vec<crate::model::CloudFormationHealth>>,
        pub(crate) service: std::option::Option<std::vec::Vec<crate::model::ServiceHealth>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::TagHealth>>,
    }
    impl Builder {
        /// Appends an item to `cloud_formation`.
        ///
        /// To override the contents of this collection use [`set_cloud_formation`](Self::set_cloud_formation).
        ///
        /// <p> The returned <code>CloudFormationHealthOverview</code> object that contains an <code>InsightHealthOverview</code> object with the requested system health information. </p>
        pub fn cloud_formation(mut self, input: crate::model::CloudFormationHealth) -> Self {
            let mut v = self.cloud_formation.unwrap_or_default();
            v.push(input);
            self.cloud_formation = Some(v);
            self
        }
        /// <p> The returned <code>CloudFormationHealthOverview</code> object that contains an <code>InsightHealthOverview</code> object with the requested system health information. </p>
        pub fn set_cloud_formation(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CloudFormationHealth>>,
        ) -> Self {
            self.cloud_formation = input;
            self
        }
        /// Appends an item to `service`.
        ///
        /// To override the contents of this collection use [`set_service`](Self::set_service).
        ///
        /// <p>An array of <code>ServiceHealth</code> objects that describes the health of the Amazon Web Services services associated with the resources in the collection.</p>
        pub fn service(mut self, input: crate::model::ServiceHealth) -> Self {
            let mut v = self.service.unwrap_or_default();
            v.push(input);
            self.service = Some(v);
            self
        }
        /// <p>An array of <code>ServiceHealth</code> objects that describes the health of the Amazon Web Services services associated with the resources in the collection.</p>
        pub fn set_service(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ServiceHealth>>,
        ) -> Self {
            self.service = input;
            self
        }
        /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The Amazon Web Services tags that are used by resources in the resource collection.</p>
        /// <p>Tags help you identify and organize your Amazon Web Services resources. Many Amazon Web Services services support tagging, so you can assign the same tag to resources from different services to indicate that the resources are related. For example, you can assign the same tag to an Amazon DynamoDB table resource that you assign to an Lambda function. For more information about using tags, see the <a href="https://d1.awsstatic.com/whitepapers/aws-tagging-best-practices.pdf">Tagging best practices</a> whitepaper. </p>
        /// <p>Each Amazon Web Services tag has two parts. </p>
        /// <ul>
        /// <li> <p>A tag <i>key</i> (for example, <code>CostCenter</code>, <code>Environment</code>, <code>Project</code>, or <code>Secret</code>). Tag <i>keys</i> are case-sensitive.</p> </li>
        /// <li> <p>An optional field known as a tag <i>value</i> (for example, <code>111122223333</code>, <code>Production</code>, or a team name). Omitting the tag <i>value</i> is the same as using an empty string. Like tag <i>keys</i>, tag <i>values</i> are case-sensitive.</p> </li>
        /// </ul>
        /// <p>Together these are known as <i>key</i>-<i>value</i> pairs.</p> <important>
        /// <p>The string used for a <i>key</i> in a tag that you use to define your resource coverage must begin with the prefix <code>Devops-guru-</code>. The tag <i>key</i> might be <code>Devops-guru-deployment-application</code> or <code>Devops-guru-rds-application</code>. While <i>keys</i> are case-sensitive, the case of <i>key</i> characters don't matter to DevOps Guru. For example, DevOps Guru works with a <i>key</i> named <code>devops-guru-rds</code> and a <i>key</i> named <code>DevOps-Guru-RDS</code>. Possible <i>key</i>/<i>value</i> pairs in your application might be <code>Devops-Guru-production-application/RDS</code> or <code>Devops-Guru-production-application/containers</code>.</p>
        /// </important>
        pub fn tags(mut self, input: crate::model::TagHealth) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The Amazon Web Services tags that are used by resources in the resource collection.</p>
        /// <p>Tags help you identify and organize your Amazon Web Services resources. Many Amazon Web Services services support tagging, so you can assign the same tag to resources from different services to indicate that the resources are related. For example, you can assign the same tag to an Amazon DynamoDB table resource that you assign to an Lambda function. For more information about using tags, see the <a href="https://d1.awsstatic.com/whitepapers/aws-tagging-best-practices.pdf">Tagging best practices</a> whitepaper. </p>
        /// <p>Each Amazon Web Services tag has two parts. </p>
        /// <ul>
        /// <li> <p>A tag <i>key</i> (for example, <code>CostCenter</code>, <code>Environment</code>, <code>Project</code>, or <code>Secret</code>). Tag <i>keys</i> are case-sensitive.</p> </li>
        /// <li> <p>An optional field known as a tag <i>value</i> (for example, <code>111122223333</code>, <code>Production</code>, or a team name). Omitting the tag <i>value</i> is the same as using an empty string. Like tag <i>keys</i>, tag <i>values</i> are case-sensitive.</p> </li>
        /// </ul>
        /// <p>Together these are known as <i>key</i>-<i>value</i> pairs.</p> <important>
        /// <p>The string used for a <i>key</i> in a tag that you use to define your resource coverage must begin with the prefix <code>Devops-guru-</code>. The tag <i>key</i> might be <code>Devops-guru-deployment-application</code> or <code>Devops-guru-rds-application</code>. While <i>keys</i> are case-sensitive, the case of <i>key</i> characters don't matter to DevOps Guru. For example, DevOps Guru works with a <i>key</i> named <code>devops-guru-rds</code> and a <i>key</i> named <code>DevOps-Guru-RDS</code>. Possible <i>key</i>/<i>value</i> pairs in your application might be <code>Devops-Guru-production-application/RDS</code> or <code>Devops-Guru-production-application/containers</code>.</p>
        /// </important>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagHealth>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeResourceCollectionHealthOutput`](crate::output::DescribeResourceCollectionHealthOutput)
        pub fn build(self) -> crate::output::DescribeResourceCollectionHealthOutput {
            crate::output::DescribeResourceCollectionHealthOutput {
                cloud_formation: self.cloud_formation,
                service: self.service,
                next_token: self.next_token,
                tags: self.tags,
            }
        }
    }
}
impl DescribeResourceCollectionHealthOutput {
    /// Creates a new builder-style object to manufacture [`DescribeResourceCollectionHealthOutput`](crate::output::DescribeResourceCollectionHealthOutput)
    pub fn builder() -> crate::output::describe_resource_collection_health_output::Builder {
        crate::output::describe_resource_collection_health_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeOrganizationResourceCollectionHealthOutput {
    /// <p>The returned <code>CloudFormationHealthOverview</code> object that contains an <code>InsightHealthOverview</code> object with the requested system health information.</p>
    pub cloud_formation: std::option::Option<std::vec::Vec<crate::model::CloudFormationHealth>>,
    /// <p>An array of <code>ServiceHealth</code> objects that describes the health of the Amazon Web Services services associated with the resources in the collection.</p>
    pub service: std::option::Option<std::vec::Vec<crate::model::ServiceHealth>>,
    /// <p>The name of the organization's account.</p>
    pub account: std::option::Option<std::vec::Vec<crate::model::AccountHealth>>,
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>Tags help you identify and organize your Amazon Web Services resources. Many Amazon Web Services services support tagging, so you can assign the same tag to resources from different services to indicate that the resources are related. For example, you can assign the same tag to an Amazon DynamoDB table resource that you assign to an Lambda function. For more information about using tags, see the <a href="https://d1.awsstatic.com/whitepapers/aws-tagging-best-practices.pdf">Tagging best practices</a> whitepaper. </p>
    /// <p>Each Amazon Web Services tag has two parts. </p>
    /// <ul>
    /// <li> <p>A tag <i>key</i> (for example, <code>CostCenter</code>, <code>Environment</code>, <code>Project</code>, or <code>Secret</code>). Tag <i>keys</i> are case-sensitive.</p> </li>
    /// <li> <p>An optional field known as a tag <i>value</i> (for example, <code>111122223333</code>, <code>Production</code>, or a team name). Omitting the tag <i>value</i> is the same as using an empty string. Like tag <i>keys</i>, tag <i>values</i> are case-sensitive.</p> </li>
    /// </ul>
    /// <p>Together these are known as <i>key</i>-<i>value</i> pairs.</p> <important>
    /// <p>The string used for a <i>key</i> in a tag that you use to define your resource coverage must begin with the prefix <code>Devops-guru-</code>. The tag <i>key</i> might be <code>Devops-guru-deployment-application</code> or <code>Devops-guru-rds-application</code>. While <i>keys</i> are case-sensitive, the case of <i>key</i> characters don't matter to DevOps Guru. For example, DevOps Guru works with a <i>key</i> named <code>devops-guru-rds</code> and a <i>key</i> named <code>DevOps-Guru-RDS</code>. Possible <i>key</i>/<i>value</i> pairs in your application might be <code>Devops-Guru-production-application/RDS</code> or <code>Devops-Guru-production-application/containers</code>.</p>
    /// </important>
    pub tags: std::option::Option<std::vec::Vec<crate::model::TagHealth>>,
}
impl DescribeOrganizationResourceCollectionHealthOutput {
    /// <p>The returned <code>CloudFormationHealthOverview</code> object that contains an <code>InsightHealthOverview</code> object with the requested system health information.</p>
    pub fn cloud_formation(&self) -> std::option::Option<&[crate::model::CloudFormationHealth]> {
        self.cloud_formation.as_deref()
    }
    /// <p>An array of <code>ServiceHealth</code> objects that describes the health of the Amazon Web Services services associated with the resources in the collection.</p>
    pub fn service(&self) -> std::option::Option<&[crate::model::ServiceHealth]> {
        self.service.as_deref()
    }
    /// <p>The name of the organization's account.</p>
    pub fn account(&self) -> std::option::Option<&[crate::model::AccountHealth]> {
        self.account.as_deref()
    }
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>Tags help you identify and organize your Amazon Web Services resources. Many Amazon Web Services services support tagging, so you can assign the same tag to resources from different services to indicate that the resources are related. For example, you can assign the same tag to an Amazon DynamoDB table resource that you assign to an Lambda function. For more information about using tags, see the <a href="https://d1.awsstatic.com/whitepapers/aws-tagging-best-practices.pdf">Tagging best practices</a> whitepaper. </p>
    /// <p>Each Amazon Web Services tag has two parts. </p>
    /// <ul>
    /// <li> <p>A tag <i>key</i> (for example, <code>CostCenter</code>, <code>Environment</code>, <code>Project</code>, or <code>Secret</code>). Tag <i>keys</i> are case-sensitive.</p> </li>
    /// <li> <p>An optional field known as a tag <i>value</i> (for example, <code>111122223333</code>, <code>Production</code>, or a team name). Omitting the tag <i>value</i> is the same as using an empty string. Like tag <i>keys</i>, tag <i>values</i> are case-sensitive.</p> </li>
    /// </ul>
    /// <p>Together these are known as <i>key</i>-<i>value</i> pairs.</p> <important>
    /// <p>The string used for a <i>key</i> in a tag that you use to define your resource coverage must begin with the prefix <code>Devops-guru-</code>. The tag <i>key</i> might be <code>Devops-guru-deployment-application</code> or <code>Devops-guru-rds-application</code>. While <i>keys</i> are case-sensitive, the case of <i>key</i> characters don't matter to DevOps Guru. For example, DevOps Guru works with a <i>key</i> named <code>devops-guru-rds</code> and a <i>key</i> named <code>DevOps-Guru-RDS</code>. Possible <i>key</i>/<i>value</i> pairs in your application might be <code>Devops-Guru-production-application/RDS</code> or <code>Devops-Guru-production-application/containers</code>.</p>
    /// </important>
    pub fn tags(&self) -> std::option::Option<&[crate::model::TagHealth]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for DescribeOrganizationResourceCollectionHealthOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeOrganizationResourceCollectionHealthOutput");
        formatter.field("cloud_formation", &self.cloud_formation);
        formatter.field("service", &self.service);
        formatter.field("account", &self.account);
        formatter.field("next_token", &self.next_token);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`DescribeOrganizationResourceCollectionHealthOutput`](crate::output::DescribeOrganizationResourceCollectionHealthOutput)
pub mod describe_organization_resource_collection_health_output {

    /// A builder for [`DescribeOrganizationResourceCollectionHealthOutput`](crate::output::DescribeOrganizationResourceCollectionHealthOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cloud_formation:
            std::option::Option<std::vec::Vec<crate::model::CloudFormationHealth>>,
        pub(crate) service: std::option::Option<std::vec::Vec<crate::model::ServiceHealth>>,
        pub(crate) account: std::option::Option<std::vec::Vec<crate::model::AccountHealth>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::TagHealth>>,
    }
    impl Builder {
        /// Appends an item to `cloud_formation`.
        ///
        /// To override the contents of this collection use [`set_cloud_formation`](Self::set_cloud_formation).
        ///
        /// <p>The returned <code>CloudFormationHealthOverview</code> object that contains an <code>InsightHealthOverview</code> object with the requested system health information.</p>
        pub fn cloud_formation(mut self, input: crate::model::CloudFormationHealth) -> Self {
            let mut v = self.cloud_formation.unwrap_or_default();
            v.push(input);
            self.cloud_formation = Some(v);
            self
        }
        /// <p>The returned <code>CloudFormationHealthOverview</code> object that contains an <code>InsightHealthOverview</code> object with the requested system health information.</p>
        pub fn set_cloud_formation(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CloudFormationHealth>>,
        ) -> Self {
            self.cloud_formation = input;
            self
        }
        /// Appends an item to `service`.
        ///
        /// To override the contents of this collection use [`set_service`](Self::set_service).
        ///
        /// <p>An array of <code>ServiceHealth</code> objects that describes the health of the Amazon Web Services services associated with the resources in the collection.</p>
        pub fn service(mut self, input: crate::model::ServiceHealth) -> Self {
            let mut v = self.service.unwrap_or_default();
            v.push(input);
            self.service = Some(v);
            self
        }
        /// <p>An array of <code>ServiceHealth</code> objects that describes the health of the Amazon Web Services services associated with the resources in the collection.</p>
        pub fn set_service(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ServiceHealth>>,
        ) -> Self {
            self.service = input;
            self
        }
        /// Appends an item to `account`.
        ///
        /// To override the contents of this collection use [`set_account`](Self::set_account).
        ///
        /// <p>The name of the organization's account.</p>
        pub fn account(mut self, input: crate::model::AccountHealth) -> Self {
            let mut v = self.account.unwrap_or_default();
            v.push(input);
            self.account = Some(v);
            self
        }
        /// <p>The name of the organization's account.</p>
        pub fn set_account(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AccountHealth>>,
        ) -> Self {
            self.account = input;
            self
        }
        /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Tags help you identify and organize your Amazon Web Services resources. Many Amazon Web Services services support tagging, so you can assign the same tag to resources from different services to indicate that the resources are related. For example, you can assign the same tag to an Amazon DynamoDB table resource that you assign to an Lambda function. For more information about using tags, see the <a href="https://d1.awsstatic.com/whitepapers/aws-tagging-best-practices.pdf">Tagging best practices</a> whitepaper. </p>
        /// <p>Each Amazon Web Services tag has two parts. </p>
        /// <ul>
        /// <li> <p>A tag <i>key</i> (for example, <code>CostCenter</code>, <code>Environment</code>, <code>Project</code>, or <code>Secret</code>). Tag <i>keys</i> are case-sensitive.</p> </li>
        /// <li> <p>An optional field known as a tag <i>value</i> (for example, <code>111122223333</code>, <code>Production</code>, or a team name). Omitting the tag <i>value</i> is the same as using an empty string. Like tag <i>keys</i>, tag <i>values</i> are case-sensitive.</p> </li>
        /// </ul>
        /// <p>Together these are known as <i>key</i>-<i>value</i> pairs.</p> <important>
        /// <p>The string used for a <i>key</i> in a tag that you use to define your resource coverage must begin with the prefix <code>Devops-guru-</code>. The tag <i>key</i> might be <code>Devops-guru-deployment-application</code> or <code>Devops-guru-rds-application</code>. While <i>keys</i> are case-sensitive, the case of <i>key</i> characters don't matter to DevOps Guru. For example, DevOps Guru works with a <i>key</i> named <code>devops-guru-rds</code> and a <i>key</i> named <code>DevOps-Guru-RDS</code>. Possible <i>key</i>/<i>value</i> pairs in your application might be <code>Devops-Guru-production-application/RDS</code> or <code>Devops-Guru-production-application/containers</code>.</p>
        /// </important>
        pub fn tags(mut self, input: crate::model::TagHealth) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Tags help you identify and organize your Amazon Web Services resources. Many Amazon Web Services services support tagging, so you can assign the same tag to resources from different services to indicate that the resources are related. For example, you can assign the same tag to an Amazon DynamoDB table resource that you assign to an Lambda function. For more information about using tags, see the <a href="https://d1.awsstatic.com/whitepapers/aws-tagging-best-practices.pdf">Tagging best practices</a> whitepaper. </p>
        /// <p>Each Amazon Web Services tag has two parts. </p>
        /// <ul>
        /// <li> <p>A tag <i>key</i> (for example, <code>CostCenter</code>, <code>Environment</code>, <code>Project</code>, or <code>Secret</code>). Tag <i>keys</i> are case-sensitive.</p> </li>
        /// <li> <p>An optional field known as a tag <i>value</i> (for example, <code>111122223333</code>, <code>Production</code>, or a team name). Omitting the tag <i>value</i> is the same as using an empty string. Like tag <i>keys</i>, tag <i>values</i> are case-sensitive.</p> </li>
        /// </ul>
        /// <p>Together these are known as <i>key</i>-<i>value</i> pairs.</p> <important>
        /// <p>The string used for a <i>key</i> in a tag that you use to define your resource coverage must begin with the prefix <code>Devops-guru-</code>. The tag <i>key</i> might be <code>Devops-guru-deployment-application</code> or <code>Devops-guru-rds-application</code>. While <i>keys</i> are case-sensitive, the case of <i>key</i> characters don't matter to DevOps Guru. For example, DevOps Guru works with a <i>key</i> named <code>devops-guru-rds</code> and a <i>key</i> named <code>DevOps-Guru-RDS</code>. Possible <i>key</i>/<i>value</i> pairs in your application might be <code>Devops-Guru-production-application/RDS</code> or <code>Devops-Guru-production-application/containers</code>.</p>
        /// </important>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagHealth>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeOrganizationResourceCollectionHealthOutput`](crate::output::DescribeOrganizationResourceCollectionHealthOutput)
        pub fn build(self) -> crate::output::DescribeOrganizationResourceCollectionHealthOutput {
            crate::output::DescribeOrganizationResourceCollectionHealthOutput {
                cloud_formation: self.cloud_formation,
                service: self.service,
                account: self.account,
                next_token: self.next_token,
                tags: self.tags,
            }
        }
    }
}
impl DescribeOrganizationResourceCollectionHealthOutput {
    /// Creates a new builder-style object to manufacture [`DescribeOrganizationResourceCollectionHealthOutput`](crate::output::DescribeOrganizationResourceCollectionHealthOutput)
    pub fn builder(
    ) -> crate::output::describe_organization_resource_collection_health_output::Builder {
        crate::output::describe_organization_resource_collection_health_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeOrganizationOverviewOutput {
    /// <p>An integer that specifies the number of open reactive insights in your Amazon Web Services account.</p>
    pub reactive_insights: i32,
    /// <p>An integer that specifies the number of open proactive insights in your Amazon Web Services account.</p>
    pub proactive_insights: i32,
}
impl DescribeOrganizationOverviewOutput {
    /// <p>An integer that specifies the number of open reactive insights in your Amazon Web Services account.</p>
    pub fn reactive_insights(&self) -> i32 {
        self.reactive_insights
    }
    /// <p>An integer that specifies the number of open proactive insights in your Amazon Web Services account.</p>
    pub fn proactive_insights(&self) -> i32 {
        self.proactive_insights
    }
}
impl std::fmt::Debug for DescribeOrganizationOverviewOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeOrganizationOverviewOutput");
        formatter.field("reactive_insights", &self.reactive_insights);
        formatter.field("proactive_insights", &self.proactive_insights);
        formatter.finish()
    }
}
/// See [`DescribeOrganizationOverviewOutput`](crate::output::DescribeOrganizationOverviewOutput)
pub mod describe_organization_overview_output {

    /// A builder for [`DescribeOrganizationOverviewOutput`](crate::output::DescribeOrganizationOverviewOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) reactive_insights: std::option::Option<i32>,
        pub(crate) proactive_insights: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>An integer that specifies the number of open reactive insights in your Amazon Web Services account.</p>
        pub fn reactive_insights(mut self, input: i32) -> Self {
            self.reactive_insights = Some(input);
            self
        }
        /// <p>An integer that specifies the number of open reactive insights in your Amazon Web Services account.</p>
        pub fn set_reactive_insights(mut self, input: std::option::Option<i32>) -> Self {
            self.reactive_insights = input;
            self
        }
        /// <p>An integer that specifies the number of open proactive insights in your Amazon Web Services account.</p>
        pub fn proactive_insights(mut self, input: i32) -> Self {
            self.proactive_insights = Some(input);
            self
        }
        /// <p>An integer that specifies the number of open proactive insights in your Amazon Web Services account.</p>
        pub fn set_proactive_insights(mut self, input: std::option::Option<i32>) -> Self {
            self.proactive_insights = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeOrganizationOverviewOutput`](crate::output::DescribeOrganizationOverviewOutput)
        pub fn build(self) -> crate::output::DescribeOrganizationOverviewOutput {
            crate::output::DescribeOrganizationOverviewOutput {
                reactive_insights: self.reactive_insights.unwrap_or_default(),
                proactive_insights: self.proactive_insights.unwrap_or_default(),
            }
        }
    }
}
impl DescribeOrganizationOverviewOutput {
    /// Creates a new builder-style object to manufacture [`DescribeOrganizationOverviewOutput`](crate::output::DescribeOrganizationOverviewOutput)
    pub fn builder() -> crate::output::describe_organization_overview_output::Builder {
        crate::output::describe_organization_overview_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeOrganizationHealthOutput {
    /// <p>An integer that specifies the number of open reactive insights in your Amazon Web Services account.</p>
    pub open_reactive_insights: i32,
    /// <p>An integer that specifies the number of open proactive insights in your Amazon Web Services account.</p>
    pub open_proactive_insights: i32,
    /// <p>An integer that specifies the number of metrics that have been analyzed in your organization.</p>
    pub metrics_analyzed: i32,
    /// <p>The number of Amazon DevOps Guru resource analysis hours billed to the current Amazon Web Services account in the last hour. </p>
    pub resource_hours: std::option::Option<i64>,
}
impl DescribeOrganizationHealthOutput {
    /// <p>An integer that specifies the number of open reactive insights in your Amazon Web Services account.</p>
    pub fn open_reactive_insights(&self) -> i32 {
        self.open_reactive_insights
    }
    /// <p>An integer that specifies the number of open proactive insights in your Amazon Web Services account.</p>
    pub fn open_proactive_insights(&self) -> i32 {
        self.open_proactive_insights
    }
    /// <p>An integer that specifies the number of metrics that have been analyzed in your organization.</p>
    pub fn metrics_analyzed(&self) -> i32 {
        self.metrics_analyzed
    }
    /// <p>The number of Amazon DevOps Guru resource analysis hours billed to the current Amazon Web Services account in the last hour. </p>
    pub fn resource_hours(&self) -> std::option::Option<i64> {
        self.resource_hours
    }
}
impl std::fmt::Debug for DescribeOrganizationHealthOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeOrganizationHealthOutput");
        formatter.field("open_reactive_insights", &self.open_reactive_insights);
        formatter.field("open_proactive_insights", &self.open_proactive_insights);
        formatter.field("metrics_analyzed", &self.metrics_analyzed);
        formatter.field("resource_hours", &self.resource_hours);
        formatter.finish()
    }
}
/// See [`DescribeOrganizationHealthOutput`](crate::output::DescribeOrganizationHealthOutput)
pub mod describe_organization_health_output {

    /// A builder for [`DescribeOrganizationHealthOutput`](crate::output::DescribeOrganizationHealthOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) open_reactive_insights: std::option::Option<i32>,
        pub(crate) open_proactive_insights: std::option::Option<i32>,
        pub(crate) metrics_analyzed: std::option::Option<i32>,
        pub(crate) resource_hours: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>An integer that specifies the number of open reactive insights in your Amazon Web Services account.</p>
        pub fn open_reactive_insights(mut self, input: i32) -> Self {
            self.open_reactive_insights = Some(input);
            self
        }
        /// <p>An integer that specifies the number of open reactive insights in your Amazon Web Services account.</p>
        pub fn set_open_reactive_insights(mut self, input: std::option::Option<i32>) -> Self {
            self.open_reactive_insights = input;
            self
        }
        /// <p>An integer that specifies the number of open proactive insights in your Amazon Web Services account.</p>
        pub fn open_proactive_insights(mut self, input: i32) -> Self {
            self.open_proactive_insights = Some(input);
            self
        }
        /// <p>An integer that specifies the number of open proactive insights in your Amazon Web Services account.</p>
        pub fn set_open_proactive_insights(mut self, input: std::option::Option<i32>) -> Self {
            self.open_proactive_insights = input;
            self
        }
        /// <p>An integer that specifies the number of metrics that have been analyzed in your organization.</p>
        pub fn metrics_analyzed(mut self, input: i32) -> Self {
            self.metrics_analyzed = Some(input);
            self
        }
        /// <p>An integer that specifies the number of metrics that have been analyzed in your organization.</p>
        pub fn set_metrics_analyzed(mut self, input: std::option::Option<i32>) -> Self {
            self.metrics_analyzed = input;
            self
        }
        /// <p>The number of Amazon DevOps Guru resource analysis hours billed to the current Amazon Web Services account in the last hour. </p>
        pub fn resource_hours(mut self, input: i64) -> Self {
            self.resource_hours = Some(input);
            self
        }
        /// <p>The number of Amazon DevOps Guru resource analysis hours billed to the current Amazon Web Services account in the last hour. </p>
        pub fn set_resource_hours(mut self, input: std::option::Option<i64>) -> Self {
            self.resource_hours = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeOrganizationHealthOutput`](crate::output::DescribeOrganizationHealthOutput)
        pub fn build(self) -> crate::output::DescribeOrganizationHealthOutput {
            crate::output::DescribeOrganizationHealthOutput {
                open_reactive_insights: self.open_reactive_insights.unwrap_or_default(),
                open_proactive_insights: self.open_proactive_insights.unwrap_or_default(),
                metrics_analyzed: self.metrics_analyzed.unwrap_or_default(),
                resource_hours: self.resource_hours,
            }
        }
    }
}
impl DescribeOrganizationHealthOutput {
    /// Creates a new builder-style object to manufacture [`DescribeOrganizationHealthOutput`](crate::output::DescribeOrganizationHealthOutput)
    pub fn builder() -> crate::output::describe_organization_health_output::Builder {
        crate::output::describe_organization_health_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeInsightOutput {
    /// <p> A <code>ProactiveInsight</code> object that represents the requested insight. </p>
    pub proactive_insight: std::option::Option<crate::model::ProactiveInsight>,
    /// <p> A <code>ReactiveInsight</code> object that represents the requested insight. </p>
    pub reactive_insight: std::option::Option<crate::model::ReactiveInsight>,
}
impl DescribeInsightOutput {
    /// <p> A <code>ProactiveInsight</code> object that represents the requested insight. </p>
    pub fn proactive_insight(&self) -> std::option::Option<&crate::model::ProactiveInsight> {
        self.proactive_insight.as_ref()
    }
    /// <p> A <code>ReactiveInsight</code> object that represents the requested insight. </p>
    pub fn reactive_insight(&self) -> std::option::Option<&crate::model::ReactiveInsight> {
        self.reactive_insight.as_ref()
    }
}
impl std::fmt::Debug for DescribeInsightOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeInsightOutput");
        formatter.field("proactive_insight", &self.proactive_insight);
        formatter.field("reactive_insight", &self.reactive_insight);
        formatter.finish()
    }
}
/// See [`DescribeInsightOutput`](crate::output::DescribeInsightOutput)
pub mod describe_insight_output {

    /// A builder for [`DescribeInsightOutput`](crate::output::DescribeInsightOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) proactive_insight: std::option::Option<crate::model::ProactiveInsight>,
        pub(crate) reactive_insight: std::option::Option<crate::model::ReactiveInsight>,
    }
    impl Builder {
        /// <p> A <code>ProactiveInsight</code> object that represents the requested insight. </p>
        pub fn proactive_insight(mut self, input: crate::model::ProactiveInsight) -> Self {
            self.proactive_insight = Some(input);
            self
        }
        /// <p> A <code>ProactiveInsight</code> object that represents the requested insight. </p>
        pub fn set_proactive_insight(
            mut self,
            input: std::option::Option<crate::model::ProactiveInsight>,
        ) -> Self {
            self.proactive_insight = input;
            self
        }
        /// <p> A <code>ReactiveInsight</code> object that represents the requested insight. </p>
        pub fn reactive_insight(mut self, input: crate::model::ReactiveInsight) -> Self {
            self.reactive_insight = Some(input);
            self
        }
        /// <p> A <code>ReactiveInsight</code> object that represents the requested insight. </p>
        pub fn set_reactive_insight(
            mut self,
            input: std::option::Option<crate::model::ReactiveInsight>,
        ) -> Self {
            self.reactive_insight = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeInsightOutput`](crate::output::DescribeInsightOutput)
        pub fn build(self) -> crate::output::DescribeInsightOutput {
            crate::output::DescribeInsightOutput {
                proactive_insight: self.proactive_insight,
                reactive_insight: self.reactive_insight,
            }
        }
    }
}
impl DescribeInsightOutput {
    /// Creates a new builder-style object to manufacture [`DescribeInsightOutput`](crate::output::DescribeInsightOutput)
    pub fn builder() -> crate::output::describe_insight_output::Builder {
        crate::output::describe_insight_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeFeedbackOutput {
    /// <p> Information about insight feedback received from a customer. </p>
    pub insight_feedback: std::option::Option<crate::model::InsightFeedback>,
}
impl DescribeFeedbackOutput {
    /// <p> Information about insight feedback received from a customer. </p>
    pub fn insight_feedback(&self) -> std::option::Option<&crate::model::InsightFeedback> {
        self.insight_feedback.as_ref()
    }
}
impl std::fmt::Debug for DescribeFeedbackOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeFeedbackOutput");
        formatter.field("insight_feedback", &self.insight_feedback);
        formatter.finish()
    }
}
/// See [`DescribeFeedbackOutput`](crate::output::DescribeFeedbackOutput)
pub mod describe_feedback_output {

    /// A builder for [`DescribeFeedbackOutput`](crate::output::DescribeFeedbackOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) insight_feedback: std::option::Option<crate::model::InsightFeedback>,
    }
    impl Builder {
        /// <p> Information about insight feedback received from a customer. </p>
        pub fn insight_feedback(mut self, input: crate::model::InsightFeedback) -> Self {
            self.insight_feedback = Some(input);
            self
        }
        /// <p> Information about insight feedback received from a customer. </p>
        pub fn set_insight_feedback(
            mut self,
            input: std::option::Option<crate::model::InsightFeedback>,
        ) -> Self {
            self.insight_feedback = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeFeedbackOutput`](crate::output::DescribeFeedbackOutput)
        pub fn build(self) -> crate::output::DescribeFeedbackOutput {
            crate::output::DescribeFeedbackOutput {
                insight_feedback: self.insight_feedback,
            }
        }
    }
}
impl DescribeFeedbackOutput {
    /// Creates a new builder-style object to manufacture [`DescribeFeedbackOutput`](crate::output::DescribeFeedbackOutput)
    pub fn builder() -> crate::output::describe_feedback_output::Builder {
        crate::output::describe_feedback_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeEventSourcesConfigOutput {
    /// <p>Lists the event sources in the configuration.</p>
    pub event_sources: std::option::Option<crate::model::EventSourcesConfig>,
}
impl DescribeEventSourcesConfigOutput {
    /// <p>Lists the event sources in the configuration.</p>
    pub fn event_sources(&self) -> std::option::Option<&crate::model::EventSourcesConfig> {
        self.event_sources.as_ref()
    }
}
impl std::fmt::Debug for DescribeEventSourcesConfigOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeEventSourcesConfigOutput");
        formatter.field("event_sources", &self.event_sources);
        formatter.finish()
    }
}
/// See [`DescribeEventSourcesConfigOutput`](crate::output::DescribeEventSourcesConfigOutput)
pub mod describe_event_sources_config_output {

    /// A builder for [`DescribeEventSourcesConfigOutput`](crate::output::DescribeEventSourcesConfigOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) event_sources: std::option::Option<crate::model::EventSourcesConfig>,
    }
    impl Builder {
        /// <p>Lists the event sources in the configuration.</p>
        pub fn event_sources(mut self, input: crate::model::EventSourcesConfig) -> Self {
            self.event_sources = Some(input);
            self
        }
        /// <p>Lists the event sources in the configuration.</p>
        pub fn set_event_sources(
            mut self,
            input: std::option::Option<crate::model::EventSourcesConfig>,
        ) -> Self {
            self.event_sources = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeEventSourcesConfigOutput`](crate::output::DescribeEventSourcesConfigOutput)
        pub fn build(self) -> crate::output::DescribeEventSourcesConfigOutput {
            crate::output::DescribeEventSourcesConfigOutput {
                event_sources: self.event_sources,
            }
        }
    }
}
impl DescribeEventSourcesConfigOutput {
    /// Creates a new builder-style object to manufacture [`DescribeEventSourcesConfigOutput`](crate::output::DescribeEventSourcesConfigOutput)
    pub fn builder() -> crate::output::describe_event_sources_config_output::Builder {
        crate::output::describe_event_sources_config_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAnomalyOutput {
    /// <p> A <code>ProactiveAnomaly</code> object that represents the requested anomaly. </p>
    pub proactive_anomaly: std::option::Option<crate::model::ProactiveAnomaly>,
    /// <p> A <code>ReactiveAnomaly</code> object that represents the requested anomaly. </p>
    pub reactive_anomaly: std::option::Option<crate::model::ReactiveAnomaly>,
}
impl DescribeAnomalyOutput {
    /// <p> A <code>ProactiveAnomaly</code> object that represents the requested anomaly. </p>
    pub fn proactive_anomaly(&self) -> std::option::Option<&crate::model::ProactiveAnomaly> {
        self.proactive_anomaly.as_ref()
    }
    /// <p> A <code>ReactiveAnomaly</code> object that represents the requested anomaly. </p>
    pub fn reactive_anomaly(&self) -> std::option::Option<&crate::model::ReactiveAnomaly> {
        self.reactive_anomaly.as_ref()
    }
}
impl std::fmt::Debug for DescribeAnomalyOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAnomalyOutput");
        formatter.field("proactive_anomaly", &self.proactive_anomaly);
        formatter.field("reactive_anomaly", &self.reactive_anomaly);
        formatter.finish()
    }
}
/// See [`DescribeAnomalyOutput`](crate::output::DescribeAnomalyOutput)
pub mod describe_anomaly_output {

    /// A builder for [`DescribeAnomalyOutput`](crate::output::DescribeAnomalyOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) proactive_anomaly: std::option::Option<crate::model::ProactiveAnomaly>,
        pub(crate) reactive_anomaly: std::option::Option<crate::model::ReactiveAnomaly>,
    }
    impl Builder {
        /// <p> A <code>ProactiveAnomaly</code> object that represents the requested anomaly. </p>
        pub fn proactive_anomaly(mut self, input: crate::model::ProactiveAnomaly) -> Self {
            self.proactive_anomaly = Some(input);
            self
        }
        /// <p> A <code>ProactiveAnomaly</code> object that represents the requested anomaly. </p>
        pub fn set_proactive_anomaly(
            mut self,
            input: std::option::Option<crate::model::ProactiveAnomaly>,
        ) -> Self {
            self.proactive_anomaly = input;
            self
        }
        /// <p> A <code>ReactiveAnomaly</code> object that represents the requested anomaly. </p>
        pub fn reactive_anomaly(mut self, input: crate::model::ReactiveAnomaly) -> Self {
            self.reactive_anomaly = Some(input);
            self
        }
        /// <p> A <code>ReactiveAnomaly</code> object that represents the requested anomaly. </p>
        pub fn set_reactive_anomaly(
            mut self,
            input: std::option::Option<crate::model::ReactiveAnomaly>,
        ) -> Self {
            self.reactive_anomaly = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeAnomalyOutput`](crate::output::DescribeAnomalyOutput)
        pub fn build(self) -> crate::output::DescribeAnomalyOutput {
            crate::output::DescribeAnomalyOutput {
                proactive_anomaly: self.proactive_anomaly,
                reactive_anomaly: self.reactive_anomaly,
            }
        }
    }
}
impl DescribeAnomalyOutput {
    /// Creates a new builder-style object to manufacture [`DescribeAnomalyOutput`](crate::output::DescribeAnomalyOutput)
    pub fn builder() -> crate::output::describe_anomaly_output::Builder {
        crate::output::describe_anomaly_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAccountOverviewOutput {
    /// <p> An integer that specifies the number of open reactive insights in your Amazon Web Services account that were created during the time range passed in. </p>
    pub reactive_insights: i32,
    /// <p> An integer that specifies the number of open proactive insights in your Amazon Web Services account that were created during the time range passed in. </p>
    pub proactive_insights: i32,
    /// <p> The Mean Time to Recover (MTTR) for all closed insights that were created during the time range passed in. </p>
    pub mean_time_to_recover_in_milliseconds: std::option::Option<i64>,
}
impl DescribeAccountOverviewOutput {
    /// <p> An integer that specifies the number of open reactive insights in your Amazon Web Services account that were created during the time range passed in. </p>
    pub fn reactive_insights(&self) -> i32 {
        self.reactive_insights
    }
    /// <p> An integer that specifies the number of open proactive insights in your Amazon Web Services account that were created during the time range passed in. </p>
    pub fn proactive_insights(&self) -> i32 {
        self.proactive_insights
    }
    /// <p> The Mean Time to Recover (MTTR) for all closed insights that were created during the time range passed in. </p>
    pub fn mean_time_to_recover_in_milliseconds(&self) -> std::option::Option<i64> {
        self.mean_time_to_recover_in_milliseconds
    }
}
impl std::fmt::Debug for DescribeAccountOverviewOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAccountOverviewOutput");
        formatter.field("reactive_insights", &self.reactive_insights);
        formatter.field("proactive_insights", &self.proactive_insights);
        formatter.field(
            "mean_time_to_recover_in_milliseconds",
            &self.mean_time_to_recover_in_milliseconds,
        );
        formatter.finish()
    }
}
/// See [`DescribeAccountOverviewOutput`](crate::output::DescribeAccountOverviewOutput)
pub mod describe_account_overview_output {

    /// A builder for [`DescribeAccountOverviewOutput`](crate::output::DescribeAccountOverviewOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) reactive_insights: std::option::Option<i32>,
        pub(crate) proactive_insights: std::option::Option<i32>,
        pub(crate) mean_time_to_recover_in_milliseconds: std::option::Option<i64>,
    }
    impl Builder {
        /// <p> An integer that specifies the number of open reactive insights in your Amazon Web Services account that were created during the time range passed in. </p>
        pub fn reactive_insights(mut self, input: i32) -> Self {
            self.reactive_insights = Some(input);
            self
        }
        /// <p> An integer that specifies the number of open reactive insights in your Amazon Web Services account that were created during the time range passed in. </p>
        pub fn set_reactive_insights(mut self, input: std::option::Option<i32>) -> Self {
            self.reactive_insights = input;
            self
        }
        /// <p> An integer that specifies the number of open proactive insights in your Amazon Web Services account that were created during the time range passed in. </p>
        pub fn proactive_insights(mut self, input: i32) -> Self {
            self.proactive_insights = Some(input);
            self
        }
        /// <p> An integer that specifies the number of open proactive insights in your Amazon Web Services account that were created during the time range passed in. </p>
        pub fn set_proactive_insights(mut self, input: std::option::Option<i32>) -> Self {
            self.proactive_insights = input;
            self
        }
        /// <p> The Mean Time to Recover (MTTR) for all closed insights that were created during the time range passed in. </p>
        pub fn mean_time_to_recover_in_milliseconds(mut self, input: i64) -> Self {
            self.mean_time_to_recover_in_milliseconds = Some(input);
            self
        }
        /// <p> The Mean Time to Recover (MTTR) for all closed insights that were created during the time range passed in. </p>
        pub fn set_mean_time_to_recover_in_milliseconds(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.mean_time_to_recover_in_milliseconds = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeAccountOverviewOutput`](crate::output::DescribeAccountOverviewOutput)
        pub fn build(self) -> crate::output::DescribeAccountOverviewOutput {
            crate::output::DescribeAccountOverviewOutput {
                reactive_insights: self.reactive_insights.unwrap_or_default(),
                proactive_insights: self.proactive_insights.unwrap_or_default(),
                mean_time_to_recover_in_milliseconds: self.mean_time_to_recover_in_milliseconds,
            }
        }
    }
}
impl DescribeAccountOverviewOutput {
    /// Creates a new builder-style object to manufacture [`DescribeAccountOverviewOutput`](crate::output::DescribeAccountOverviewOutput)
    pub fn builder() -> crate::output::describe_account_overview_output::Builder {
        crate::output::describe_account_overview_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAccountHealthOutput {
    /// <p> An integer that specifies the number of open reactive insights in your Amazon Web Services account. </p>
    pub open_reactive_insights: i32,
    /// <p> An integer that specifies the number of open proactive insights in your Amazon Web Services account. </p>
    pub open_proactive_insights: i32,
    /// <p> An integer that specifies the number of metrics that have been analyzed in your Amazon Web Services account. </p>
    pub metrics_analyzed: i32,
    /// <p>The number of Amazon DevOps Guru resource analysis hours billed to the current Amazon Web Services account in the last hour. </p>
    pub resource_hours: std::option::Option<i64>,
}
impl DescribeAccountHealthOutput {
    /// <p> An integer that specifies the number of open reactive insights in your Amazon Web Services account. </p>
    pub fn open_reactive_insights(&self) -> i32 {
        self.open_reactive_insights
    }
    /// <p> An integer that specifies the number of open proactive insights in your Amazon Web Services account. </p>
    pub fn open_proactive_insights(&self) -> i32 {
        self.open_proactive_insights
    }
    /// <p> An integer that specifies the number of metrics that have been analyzed in your Amazon Web Services account. </p>
    pub fn metrics_analyzed(&self) -> i32 {
        self.metrics_analyzed
    }
    /// <p>The number of Amazon DevOps Guru resource analysis hours billed to the current Amazon Web Services account in the last hour. </p>
    pub fn resource_hours(&self) -> std::option::Option<i64> {
        self.resource_hours
    }
}
impl std::fmt::Debug for DescribeAccountHealthOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAccountHealthOutput");
        formatter.field("open_reactive_insights", &self.open_reactive_insights);
        formatter.field("open_proactive_insights", &self.open_proactive_insights);
        formatter.field("metrics_analyzed", &self.metrics_analyzed);
        formatter.field("resource_hours", &self.resource_hours);
        formatter.finish()
    }
}
/// See [`DescribeAccountHealthOutput`](crate::output::DescribeAccountHealthOutput)
pub mod describe_account_health_output {

    /// A builder for [`DescribeAccountHealthOutput`](crate::output::DescribeAccountHealthOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) open_reactive_insights: std::option::Option<i32>,
        pub(crate) open_proactive_insights: std::option::Option<i32>,
        pub(crate) metrics_analyzed: std::option::Option<i32>,
        pub(crate) resource_hours: std::option::Option<i64>,
    }
    impl Builder {
        /// <p> An integer that specifies the number of open reactive insights in your Amazon Web Services account. </p>
        pub fn open_reactive_insights(mut self, input: i32) -> Self {
            self.open_reactive_insights = Some(input);
            self
        }
        /// <p> An integer that specifies the number of open reactive insights in your Amazon Web Services account. </p>
        pub fn set_open_reactive_insights(mut self, input: std::option::Option<i32>) -> Self {
            self.open_reactive_insights = input;
            self
        }
        /// <p> An integer that specifies the number of open proactive insights in your Amazon Web Services account. </p>
        pub fn open_proactive_insights(mut self, input: i32) -> Self {
            self.open_proactive_insights = Some(input);
            self
        }
        /// <p> An integer that specifies the number of open proactive insights in your Amazon Web Services account. </p>
        pub fn set_open_proactive_insights(mut self, input: std::option::Option<i32>) -> Self {
            self.open_proactive_insights = input;
            self
        }
        /// <p> An integer that specifies the number of metrics that have been analyzed in your Amazon Web Services account. </p>
        pub fn metrics_analyzed(mut self, input: i32) -> Self {
            self.metrics_analyzed = Some(input);
            self
        }
        /// <p> An integer that specifies the number of metrics that have been analyzed in your Amazon Web Services account. </p>
        pub fn set_metrics_analyzed(mut self, input: std::option::Option<i32>) -> Self {
            self.metrics_analyzed = input;
            self
        }
        /// <p>The number of Amazon DevOps Guru resource analysis hours billed to the current Amazon Web Services account in the last hour. </p>
        pub fn resource_hours(mut self, input: i64) -> Self {
            self.resource_hours = Some(input);
            self
        }
        /// <p>The number of Amazon DevOps Guru resource analysis hours billed to the current Amazon Web Services account in the last hour. </p>
        pub fn set_resource_hours(mut self, input: std::option::Option<i64>) -> Self {
            self.resource_hours = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeAccountHealthOutput`](crate::output::DescribeAccountHealthOutput)
        pub fn build(self) -> crate::output::DescribeAccountHealthOutput {
            crate::output::DescribeAccountHealthOutput {
                open_reactive_insights: self.open_reactive_insights.unwrap_or_default(),
                open_proactive_insights: self.open_proactive_insights.unwrap_or_default(),
                metrics_analyzed: self.metrics_analyzed.unwrap_or_default(),
                resource_hours: self.resource_hours,
            }
        }
    }
}
impl DescribeAccountHealthOutput {
    /// Creates a new builder-style object to manufacture [`DescribeAccountHealthOutput`](crate::output::DescribeAccountHealthOutput)
    pub fn builder() -> crate::output::describe_account_health_output::Builder {
        crate::output::describe_account_health_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteInsightOutput {}
impl std::fmt::Debug for DeleteInsightOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteInsightOutput");
        formatter.finish()
    }
}
/// See [`DeleteInsightOutput`](crate::output::DeleteInsightOutput)
pub mod delete_insight_output {

    /// A builder for [`DeleteInsightOutput`](crate::output::DeleteInsightOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteInsightOutput`](crate::output::DeleteInsightOutput)
        pub fn build(self) -> crate::output::DeleteInsightOutput {
            crate::output::DeleteInsightOutput {}
        }
    }
}
impl DeleteInsightOutput {
    /// Creates a new builder-style object to manufacture [`DeleteInsightOutput`](crate::output::DeleteInsightOutput)
    pub fn builder() -> crate::output::delete_insight_output::Builder {
        crate::output::delete_insight_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AddNotificationChannelOutput {
    /// <p> The ID of the added notification channel. </p>
    pub id: std::option::Option<std::string::String>,
}
impl AddNotificationChannelOutput {
    /// <p> The ID of the added notification channel. </p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
}
impl std::fmt::Debug for AddNotificationChannelOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AddNotificationChannelOutput");
        formatter.field("id", &self.id);
        formatter.finish()
    }
}
/// See [`AddNotificationChannelOutput`](crate::output::AddNotificationChannelOutput)
pub mod add_notification_channel_output {

    /// A builder for [`AddNotificationChannelOutput`](crate::output::AddNotificationChannelOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The ID of the added notification channel. </p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p> The ID of the added notification channel. </p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`AddNotificationChannelOutput`](crate::output::AddNotificationChannelOutput)
        pub fn build(self) -> crate::output::AddNotificationChannelOutput {
            crate::output::AddNotificationChannelOutput { id: self.id }
        }
    }
}
impl AddNotificationChannelOutput {
    /// Creates a new builder-style object to manufacture [`AddNotificationChannelOutput`](crate::output::AddNotificationChannelOutput)
    pub fn builder() -> crate::output::add_notification_channel_output::Builder {
        crate::output::add_notification_channel_output::Builder::default()
    }
}
