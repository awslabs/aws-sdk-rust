// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// All possible error types for this service.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum Error {
    /// <p>The resource hierarchy is changing.</p>
    ConcurrentModificationException(crate::types::error::ConcurrentModificationException),
    /// <p>Another operation is in progress on the resource that conflicts with the current operation.</p>
    ConflictingOperationException(crate::types::error::ConflictingOperationException),
    /// <p>The limit has been reached on the number of custom properties for the specified resource.</p>
    CustomMetadataLimitExceededException(crate::types::error::CustomMetadataLimitExceededException),
    /// <p>The last user in the organization is being deactivated.</p>
    DeactivatingLastSystemUserException(crate::types::error::DeactivatingLastSystemUserException),
    /// <p>This exception is thrown when the document is locked for comments and user tries to create or delete a comment on that document.</p>
    DocumentLockedForCommentsException(crate::types::error::DocumentLockedForCommentsException),
    /// <p>This exception is thrown when a valid checkout ID is not presented on document version upload calls for a document that has been checked out from Web client.</p>
    DraftUploadOutOfSyncException(crate::types::error::DraftUploadOutOfSyncException),
    /// <p>The resource already exists.</p>
    EntityAlreadyExistsException(crate::types::error::EntityAlreadyExistsException),
    /// <p>The resource does not exist.</p>
    EntityNotExistsException(crate::types::error::EntityNotExistsException),
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::types::error::FailedDependencyException),
    /// <p>The user is undergoing transfer of ownership.</p>
    IllegalUserStateException(crate::types::error::IllegalUserStateException),
    /// <p>The pagination marker or limit fields are not valid.</p>
    InvalidArgumentException(crate::types::error::InvalidArgumentException),
    /// <p>The requested operation is not allowed on the specified comment object.</p>
    InvalidCommentOperationException(crate::types::error::InvalidCommentOperationException),
    /// <p>The operation is invalid.</p>
    InvalidOperationException(crate::types::error::InvalidOperationException),
    /// <p>The password is invalid.</p>
    InvalidPasswordException(crate::types::error::InvalidPasswordException),
    /// <p>The maximum of 100,000 files and folders under the parent folder has been exceeded.</p>
    LimitExceededException(crate::types::error::LimitExceededException),
    /// <p>The specified document version is not in the INITIALIZED state.</p>
    ProhibitedStateException(crate::types::error::ProhibitedStateException),
    /// <p>The response is too large to return. The request must include a filter to reduce the size of the response.</p>
    RequestedEntityTooLargeException(crate::types::error::RequestedEntityTooLargeException),
    /// <p>The resource is already checked out.</p>
    ResourceAlreadyCheckedOutException(crate::types::error::ResourceAlreadyCheckedOutException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::types::error::ServiceUnavailableException),
    /// <p>The storage limit has been exceeded.</p>
    StorageLimitExceededException(crate::types::error::StorageLimitExceededException),
    /// <p>The storage limit will be exceeded.</p>
    StorageLimitWillExceedException(crate::types::error::StorageLimitWillExceedException),
    /// <p>The limit has been reached on the number of labels for the specified resource.</p>
    TooManyLabelsException(crate::types::error::TooManyLabelsException),
    /// <p>You've reached the limit on the number of subscriptions for the WorkDocs instance.</p>
    TooManySubscriptionsException(crate::types::error::TooManySubscriptionsException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::types::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::types::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled)
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::ConcurrentModificationException(inner) => inner.fmt(f),
            Error::ConflictingOperationException(inner) => inner.fmt(f),
            Error::CustomMetadataLimitExceededException(inner) => inner.fmt(f),
            Error::DeactivatingLastSystemUserException(inner) => inner.fmt(f),
            Error::DocumentLockedForCommentsException(inner) => inner.fmt(f),
            Error::DraftUploadOutOfSyncException(inner) => inner.fmt(f),
            Error::EntityAlreadyExistsException(inner) => inner.fmt(f),
            Error::EntityNotExistsException(inner) => inner.fmt(f),
            Error::FailedDependencyException(inner) => inner.fmt(f),
            Error::IllegalUserStateException(inner) => inner.fmt(f),
            Error::InvalidArgumentException(inner) => inner.fmt(f),
            Error::InvalidCommentOperationException(inner) => inner.fmt(f),
            Error::InvalidOperationException(inner) => inner.fmt(f),
            Error::InvalidPasswordException(inner) => inner.fmt(f),
            Error::LimitExceededException(inner) => inner.fmt(f),
            Error::ProhibitedStateException(inner) => inner.fmt(f),
            Error::RequestedEntityTooLargeException(inner) => inner.fmt(f),
            Error::ResourceAlreadyCheckedOutException(inner) => inner.fmt(f),
            Error::ServiceUnavailableException(inner) => inner.fmt(f),
            Error::StorageLimitExceededException(inner) => inner.fmt(f),
            Error::StorageLimitWillExceedException(inner) => inner.fmt(f),
            Error::TooManyLabelsException(inner) => inner.fmt(f),
            Error::TooManySubscriptionsException(inner) => inner.fmt(f),
            Error::UnauthorizedOperationException(inner) => inner.fmt(f),
            Error::UnauthorizedResourceAccessException(inner) => inner.fmt(f),
            Error::Unhandled(inner) => inner.fmt(f)
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::abort_document_version_upload::AbortDocumentVersionUploadError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::abort_document_version_upload::AbortDocumentVersionUploadError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::abort_document_version_upload::AbortDocumentVersionUploadError> for Error {
    fn from(err: crate::operation::abort_document_version_upload::AbortDocumentVersionUploadError) -> Self {
        match err {
            crate::operation::abort_document_version_upload::AbortDocumentVersionUploadError::ConcurrentModificationException(inner) => Error::ConcurrentModificationException(inner),
            crate::operation::abort_document_version_upload::AbortDocumentVersionUploadError::EntityNotExistsException(inner) => Error::EntityNotExistsException(inner),
            crate::operation::abort_document_version_upload::AbortDocumentVersionUploadError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::abort_document_version_upload::AbortDocumentVersionUploadError::ProhibitedStateException(inner) => Error::ProhibitedStateException(inner),
            crate::operation::abort_document_version_upload::AbortDocumentVersionUploadError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::abort_document_version_upload::AbortDocumentVersionUploadError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::abort_document_version_upload::AbortDocumentVersionUploadError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::abort_document_version_upload::AbortDocumentVersionUploadError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::activate_user::ActivateUserError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::activate_user::ActivateUserError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::activate_user::ActivateUserError> for Error {
    fn from(err: crate::operation::activate_user::ActivateUserError) -> Self {
        match err {
            crate::operation::activate_user::ActivateUserError::EntityNotExistsException(inner) => Error::EntityNotExistsException(inner),
            crate::operation::activate_user::ActivateUserError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::activate_user::ActivateUserError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::activate_user::ActivateUserError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::activate_user::ActivateUserError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::activate_user::ActivateUserError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::add_resource_permissions::AddResourcePermissionsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::add_resource_permissions::AddResourcePermissionsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::add_resource_permissions::AddResourcePermissionsError> for Error {
    fn from(err: crate::operation::add_resource_permissions::AddResourcePermissionsError) -> Self {
        match err {
            crate::operation::add_resource_permissions::AddResourcePermissionsError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::add_resource_permissions::AddResourcePermissionsError::ProhibitedStateException(inner) => Error::ProhibitedStateException(inner),
            crate::operation::add_resource_permissions::AddResourcePermissionsError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::add_resource_permissions::AddResourcePermissionsError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::add_resource_permissions::AddResourcePermissionsError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::add_resource_permissions::AddResourcePermissionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::create_comment::CreateCommentError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::create_comment::CreateCommentError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::create_comment::CreateCommentError> for Error {
    fn from(err: crate::operation::create_comment::CreateCommentError) -> Self {
        match err {
            crate::operation::create_comment::CreateCommentError::DocumentLockedForCommentsException(inner) => Error::DocumentLockedForCommentsException(inner),
            crate::operation::create_comment::CreateCommentError::EntityNotExistsException(inner) => Error::EntityNotExistsException(inner),
            crate::operation::create_comment::CreateCommentError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::create_comment::CreateCommentError::InvalidCommentOperationException(inner) => Error::InvalidCommentOperationException(inner),
            crate::operation::create_comment::CreateCommentError::ProhibitedStateException(inner) => Error::ProhibitedStateException(inner),
            crate::operation::create_comment::CreateCommentError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::create_comment::CreateCommentError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::create_comment::CreateCommentError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::create_comment::CreateCommentError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::create_custom_metadata::CreateCustomMetadataError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::create_custom_metadata::CreateCustomMetadataError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::create_custom_metadata::CreateCustomMetadataError> for Error {
    fn from(err: crate::operation::create_custom_metadata::CreateCustomMetadataError) -> Self {
        match err {
            crate::operation::create_custom_metadata::CreateCustomMetadataError::CustomMetadataLimitExceededException(inner) => Error::CustomMetadataLimitExceededException(inner),
            crate::operation::create_custom_metadata::CreateCustomMetadataError::EntityNotExistsException(inner) => Error::EntityNotExistsException(inner),
            crate::operation::create_custom_metadata::CreateCustomMetadataError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::create_custom_metadata::CreateCustomMetadataError::ProhibitedStateException(inner) => Error::ProhibitedStateException(inner),
            crate::operation::create_custom_metadata::CreateCustomMetadataError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::create_custom_metadata::CreateCustomMetadataError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::create_custom_metadata::CreateCustomMetadataError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::create_custom_metadata::CreateCustomMetadataError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::create_folder::CreateFolderError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::create_folder::CreateFolderError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::create_folder::CreateFolderError> for Error {
    fn from(err: crate::operation::create_folder::CreateFolderError) -> Self {
        match err {
            crate::operation::create_folder::CreateFolderError::ConcurrentModificationException(inner) => Error::ConcurrentModificationException(inner),
            crate::operation::create_folder::CreateFolderError::ConflictingOperationException(inner) => Error::ConflictingOperationException(inner),
            crate::operation::create_folder::CreateFolderError::EntityAlreadyExistsException(inner) => Error::EntityAlreadyExistsException(inner),
            crate::operation::create_folder::CreateFolderError::EntityNotExistsException(inner) => Error::EntityNotExistsException(inner),
            crate::operation::create_folder::CreateFolderError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::create_folder::CreateFolderError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::create_folder::CreateFolderError::ProhibitedStateException(inner) => Error::ProhibitedStateException(inner),
            crate::operation::create_folder::CreateFolderError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::create_folder::CreateFolderError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::create_folder::CreateFolderError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::create_folder::CreateFolderError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::create_labels::CreateLabelsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::create_labels::CreateLabelsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::create_labels::CreateLabelsError> for Error {
    fn from(err: crate::operation::create_labels::CreateLabelsError) -> Self {
        match err {
            crate::operation::create_labels::CreateLabelsError::EntityNotExistsException(inner) => Error::EntityNotExistsException(inner),
            crate::operation::create_labels::CreateLabelsError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::create_labels::CreateLabelsError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::create_labels::CreateLabelsError::TooManyLabelsException(inner) => Error::TooManyLabelsException(inner),
            crate::operation::create_labels::CreateLabelsError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::create_labels::CreateLabelsError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::create_labels::CreateLabelsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::create_notification_subscription::CreateNotificationSubscriptionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::create_notification_subscription::CreateNotificationSubscriptionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::create_notification_subscription::CreateNotificationSubscriptionError> for Error {
    fn from(err: crate::operation::create_notification_subscription::CreateNotificationSubscriptionError) -> Self {
        match err {
            crate::operation::create_notification_subscription::CreateNotificationSubscriptionError::InvalidArgumentException(inner) => Error::InvalidArgumentException(inner),
            crate::operation::create_notification_subscription::CreateNotificationSubscriptionError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::create_notification_subscription::CreateNotificationSubscriptionError::TooManySubscriptionsException(inner) => Error::TooManySubscriptionsException(inner),
            crate::operation::create_notification_subscription::CreateNotificationSubscriptionError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::create_notification_subscription::CreateNotificationSubscriptionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::create_user::CreateUserError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::create_user::CreateUserError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::create_user::CreateUserError> for Error {
    fn from(err: crate::operation::create_user::CreateUserError) -> Self {
        match err {
            crate::operation::create_user::CreateUserError::EntityAlreadyExistsException(inner) => Error::EntityAlreadyExistsException(inner),
            crate::operation::create_user::CreateUserError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::create_user::CreateUserError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::create_user::CreateUserError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::create_user::CreateUserError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::create_user::CreateUserError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::deactivate_user::DeactivateUserError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::deactivate_user::DeactivateUserError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::deactivate_user::DeactivateUserError> for Error {
    fn from(err: crate::operation::deactivate_user::DeactivateUserError) -> Self {
        match err {
            crate::operation::deactivate_user::DeactivateUserError::EntityNotExistsException(inner) => Error::EntityNotExistsException(inner),
            crate::operation::deactivate_user::DeactivateUserError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::deactivate_user::DeactivateUserError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::deactivate_user::DeactivateUserError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::deactivate_user::DeactivateUserError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::deactivate_user::DeactivateUserError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::delete_comment::DeleteCommentError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::delete_comment::DeleteCommentError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::delete_comment::DeleteCommentError> for Error {
    fn from(err: crate::operation::delete_comment::DeleteCommentError) -> Self {
        match err {
            crate::operation::delete_comment::DeleteCommentError::DocumentLockedForCommentsException(inner) => Error::DocumentLockedForCommentsException(inner),
            crate::operation::delete_comment::DeleteCommentError::EntityNotExistsException(inner) => Error::EntityNotExistsException(inner),
            crate::operation::delete_comment::DeleteCommentError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::delete_comment::DeleteCommentError::ProhibitedStateException(inner) => Error::ProhibitedStateException(inner),
            crate::operation::delete_comment::DeleteCommentError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::delete_comment::DeleteCommentError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::delete_comment::DeleteCommentError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::delete_comment::DeleteCommentError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::delete_custom_metadata::DeleteCustomMetadataError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::delete_custom_metadata::DeleteCustomMetadataError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::delete_custom_metadata::DeleteCustomMetadataError> for Error {
    fn from(err: crate::operation::delete_custom_metadata::DeleteCustomMetadataError) -> Self {
        match err {
            crate::operation::delete_custom_metadata::DeleteCustomMetadataError::EntityNotExistsException(inner) => Error::EntityNotExistsException(inner),
            crate::operation::delete_custom_metadata::DeleteCustomMetadataError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::delete_custom_metadata::DeleteCustomMetadataError::ProhibitedStateException(inner) => Error::ProhibitedStateException(inner),
            crate::operation::delete_custom_metadata::DeleteCustomMetadataError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::delete_custom_metadata::DeleteCustomMetadataError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::delete_custom_metadata::DeleteCustomMetadataError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::delete_custom_metadata::DeleteCustomMetadataError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::delete_document::DeleteDocumentError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::delete_document::DeleteDocumentError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::delete_document::DeleteDocumentError> for Error {
    fn from(err: crate::operation::delete_document::DeleteDocumentError) -> Self {
        match err {
            crate::operation::delete_document::DeleteDocumentError::ConcurrentModificationException(inner) => Error::ConcurrentModificationException(inner),
            crate::operation::delete_document::DeleteDocumentError::ConflictingOperationException(inner) => Error::ConflictingOperationException(inner),
            crate::operation::delete_document::DeleteDocumentError::EntityNotExistsException(inner) => Error::EntityNotExistsException(inner),
            crate::operation::delete_document::DeleteDocumentError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::delete_document::DeleteDocumentError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::delete_document::DeleteDocumentError::ProhibitedStateException(inner) => Error::ProhibitedStateException(inner),
            crate::operation::delete_document::DeleteDocumentError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::delete_document::DeleteDocumentError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::delete_document::DeleteDocumentError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::delete_document::DeleteDocumentError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::delete_document_version::DeleteDocumentVersionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::delete_document_version::DeleteDocumentVersionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::delete_document_version::DeleteDocumentVersionError> for Error {
    fn from(err: crate::operation::delete_document_version::DeleteDocumentVersionError) -> Self {
        match err {
            crate::operation::delete_document_version::DeleteDocumentVersionError::ConcurrentModificationException(inner) => Error::ConcurrentModificationException(inner),
            crate::operation::delete_document_version::DeleteDocumentVersionError::ConflictingOperationException(inner) => Error::ConflictingOperationException(inner),
            crate::operation::delete_document_version::DeleteDocumentVersionError::EntityNotExistsException(inner) => Error::EntityNotExistsException(inner),
            crate::operation::delete_document_version::DeleteDocumentVersionError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::delete_document_version::DeleteDocumentVersionError::InvalidOperationException(inner) => Error::InvalidOperationException(inner),
            crate::operation::delete_document_version::DeleteDocumentVersionError::ProhibitedStateException(inner) => Error::ProhibitedStateException(inner),
            crate::operation::delete_document_version::DeleteDocumentVersionError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::delete_document_version::DeleteDocumentVersionError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::delete_document_version::DeleteDocumentVersionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::delete_folder::DeleteFolderError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::delete_folder::DeleteFolderError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::delete_folder::DeleteFolderError> for Error {
    fn from(err: crate::operation::delete_folder::DeleteFolderError) -> Self {
        match err {
            crate::operation::delete_folder::DeleteFolderError::ConcurrentModificationException(inner) => Error::ConcurrentModificationException(inner),
            crate::operation::delete_folder::DeleteFolderError::ConflictingOperationException(inner) => Error::ConflictingOperationException(inner),
            crate::operation::delete_folder::DeleteFolderError::EntityNotExistsException(inner) => Error::EntityNotExistsException(inner),
            crate::operation::delete_folder::DeleteFolderError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::delete_folder::DeleteFolderError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::delete_folder::DeleteFolderError::ProhibitedStateException(inner) => Error::ProhibitedStateException(inner),
            crate::operation::delete_folder::DeleteFolderError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::delete_folder::DeleteFolderError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::delete_folder::DeleteFolderError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::delete_folder::DeleteFolderError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::delete_folder_contents::DeleteFolderContentsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::delete_folder_contents::DeleteFolderContentsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::delete_folder_contents::DeleteFolderContentsError> for Error {
    fn from(err: crate::operation::delete_folder_contents::DeleteFolderContentsError) -> Self {
        match err {
            crate::operation::delete_folder_contents::DeleteFolderContentsError::ConflictingOperationException(inner) => Error::ConflictingOperationException(inner),
            crate::operation::delete_folder_contents::DeleteFolderContentsError::EntityNotExistsException(inner) => Error::EntityNotExistsException(inner),
            crate::operation::delete_folder_contents::DeleteFolderContentsError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::delete_folder_contents::DeleteFolderContentsError::ProhibitedStateException(inner) => Error::ProhibitedStateException(inner),
            crate::operation::delete_folder_contents::DeleteFolderContentsError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::delete_folder_contents::DeleteFolderContentsError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::delete_folder_contents::DeleteFolderContentsError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::delete_folder_contents::DeleteFolderContentsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::delete_labels::DeleteLabelsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::delete_labels::DeleteLabelsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::delete_labels::DeleteLabelsError> for Error {
    fn from(err: crate::operation::delete_labels::DeleteLabelsError) -> Self {
        match err {
            crate::operation::delete_labels::DeleteLabelsError::EntityNotExistsException(inner) => Error::EntityNotExistsException(inner),
            crate::operation::delete_labels::DeleteLabelsError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::delete_labels::DeleteLabelsError::ProhibitedStateException(inner) => Error::ProhibitedStateException(inner),
            crate::operation::delete_labels::DeleteLabelsError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::delete_labels::DeleteLabelsError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::delete_labels::DeleteLabelsError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::delete_labels::DeleteLabelsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::delete_notification_subscription::DeleteNotificationSubscriptionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::delete_notification_subscription::DeleteNotificationSubscriptionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::delete_notification_subscription::DeleteNotificationSubscriptionError> for Error {
    fn from(err: crate::operation::delete_notification_subscription::DeleteNotificationSubscriptionError) -> Self {
        match err {
            crate::operation::delete_notification_subscription::DeleteNotificationSubscriptionError::EntityNotExistsException(inner) => Error::EntityNotExistsException(inner),
            crate::operation::delete_notification_subscription::DeleteNotificationSubscriptionError::ProhibitedStateException(inner) => Error::ProhibitedStateException(inner),
            crate::operation::delete_notification_subscription::DeleteNotificationSubscriptionError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::delete_notification_subscription::DeleteNotificationSubscriptionError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::delete_notification_subscription::DeleteNotificationSubscriptionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::delete_user::DeleteUserError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::delete_user::DeleteUserError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::delete_user::DeleteUserError> for Error {
    fn from(err: crate::operation::delete_user::DeleteUserError) -> Self {
        match err {
            crate::operation::delete_user::DeleteUserError::EntityNotExistsException(inner) => Error::EntityNotExistsException(inner),
            crate::operation::delete_user::DeleteUserError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::delete_user::DeleteUserError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::delete_user::DeleteUserError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::delete_user::DeleteUserError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::delete_user::DeleteUserError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::describe_activities::DescribeActivitiesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::describe_activities::DescribeActivitiesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::describe_activities::DescribeActivitiesError> for Error {
    fn from(err: crate::operation::describe_activities::DescribeActivitiesError) -> Self {
        match err {
            crate::operation::describe_activities::DescribeActivitiesError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::describe_activities::DescribeActivitiesError::InvalidArgumentException(inner) => Error::InvalidArgumentException(inner),
            crate::operation::describe_activities::DescribeActivitiesError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::describe_activities::DescribeActivitiesError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::describe_activities::DescribeActivitiesError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::describe_activities::DescribeActivitiesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::describe_comments::DescribeCommentsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::describe_comments::DescribeCommentsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::describe_comments::DescribeCommentsError> for Error {
    fn from(err: crate::operation::describe_comments::DescribeCommentsError) -> Self {
        match err {
            crate::operation::describe_comments::DescribeCommentsError::EntityNotExistsException(inner) => Error::EntityNotExistsException(inner),
            crate::operation::describe_comments::DescribeCommentsError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::describe_comments::DescribeCommentsError::ProhibitedStateException(inner) => Error::ProhibitedStateException(inner),
            crate::operation::describe_comments::DescribeCommentsError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::describe_comments::DescribeCommentsError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::describe_comments::DescribeCommentsError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::describe_comments::DescribeCommentsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::describe_document_versions::DescribeDocumentVersionsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::describe_document_versions::DescribeDocumentVersionsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::describe_document_versions::DescribeDocumentVersionsError> for Error {
    fn from(err: crate::operation::describe_document_versions::DescribeDocumentVersionsError) -> Self {
        match err {
            crate::operation::describe_document_versions::DescribeDocumentVersionsError::EntityNotExistsException(inner) => Error::EntityNotExistsException(inner),
            crate::operation::describe_document_versions::DescribeDocumentVersionsError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::describe_document_versions::DescribeDocumentVersionsError::InvalidArgumentException(inner) => Error::InvalidArgumentException(inner),
            crate::operation::describe_document_versions::DescribeDocumentVersionsError::InvalidPasswordException(inner) => Error::InvalidPasswordException(inner),
            crate::operation::describe_document_versions::DescribeDocumentVersionsError::ProhibitedStateException(inner) => Error::ProhibitedStateException(inner),
            crate::operation::describe_document_versions::DescribeDocumentVersionsError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::describe_document_versions::DescribeDocumentVersionsError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::describe_document_versions::DescribeDocumentVersionsError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::describe_document_versions::DescribeDocumentVersionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::describe_folder_contents::DescribeFolderContentsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::describe_folder_contents::DescribeFolderContentsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::describe_folder_contents::DescribeFolderContentsError> for Error {
    fn from(err: crate::operation::describe_folder_contents::DescribeFolderContentsError) -> Self {
        match err {
            crate::operation::describe_folder_contents::DescribeFolderContentsError::EntityNotExistsException(inner) => Error::EntityNotExistsException(inner),
            crate::operation::describe_folder_contents::DescribeFolderContentsError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::describe_folder_contents::DescribeFolderContentsError::InvalidArgumentException(inner) => Error::InvalidArgumentException(inner),
            crate::operation::describe_folder_contents::DescribeFolderContentsError::ProhibitedStateException(inner) => Error::ProhibitedStateException(inner),
            crate::operation::describe_folder_contents::DescribeFolderContentsError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::describe_folder_contents::DescribeFolderContentsError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::describe_folder_contents::DescribeFolderContentsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::describe_groups::DescribeGroupsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::describe_groups::DescribeGroupsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::describe_groups::DescribeGroupsError> for Error {
    fn from(err: crate::operation::describe_groups::DescribeGroupsError) -> Self {
        match err {
            crate::operation::describe_groups::DescribeGroupsError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::describe_groups::DescribeGroupsError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::describe_groups::DescribeGroupsError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::describe_groups::DescribeGroupsError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::describe_groups::DescribeGroupsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::describe_notification_subscriptions::DescribeNotificationSubscriptionsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::describe_notification_subscriptions::DescribeNotificationSubscriptionsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::describe_notification_subscriptions::DescribeNotificationSubscriptionsError> for Error {
    fn from(err: crate::operation::describe_notification_subscriptions::DescribeNotificationSubscriptionsError) -> Self {
        match err {
            crate::operation::describe_notification_subscriptions::DescribeNotificationSubscriptionsError::EntityNotExistsException(inner) => Error::EntityNotExistsException(inner),
            crate::operation::describe_notification_subscriptions::DescribeNotificationSubscriptionsError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::describe_notification_subscriptions::DescribeNotificationSubscriptionsError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::describe_notification_subscriptions::DescribeNotificationSubscriptionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::describe_resource_permissions::DescribeResourcePermissionsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::describe_resource_permissions::DescribeResourcePermissionsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::describe_resource_permissions::DescribeResourcePermissionsError> for Error {
    fn from(err: crate::operation::describe_resource_permissions::DescribeResourcePermissionsError) -> Self {
        match err {
            crate::operation::describe_resource_permissions::DescribeResourcePermissionsError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::describe_resource_permissions::DescribeResourcePermissionsError::InvalidArgumentException(inner) => Error::InvalidArgumentException(inner),
            crate::operation::describe_resource_permissions::DescribeResourcePermissionsError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::describe_resource_permissions::DescribeResourcePermissionsError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::describe_resource_permissions::DescribeResourcePermissionsError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::describe_resource_permissions::DescribeResourcePermissionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::describe_root_folders::DescribeRootFoldersError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::describe_root_folders::DescribeRootFoldersError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::describe_root_folders::DescribeRootFoldersError> for Error {
    fn from(err: crate::operation::describe_root_folders::DescribeRootFoldersError) -> Self {
        match err {
            crate::operation::describe_root_folders::DescribeRootFoldersError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::describe_root_folders::DescribeRootFoldersError::InvalidArgumentException(inner) => Error::InvalidArgumentException(inner),
            crate::operation::describe_root_folders::DescribeRootFoldersError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::describe_root_folders::DescribeRootFoldersError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::describe_root_folders::DescribeRootFoldersError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::describe_root_folders::DescribeRootFoldersError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::describe_users::DescribeUsersError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::describe_users::DescribeUsersError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::describe_users::DescribeUsersError> for Error {
    fn from(err: crate::operation::describe_users::DescribeUsersError) -> Self {
        match err {
            crate::operation::describe_users::DescribeUsersError::EntityNotExistsException(inner) => Error::EntityNotExistsException(inner),
            crate::operation::describe_users::DescribeUsersError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::describe_users::DescribeUsersError::InvalidArgumentException(inner) => Error::InvalidArgumentException(inner),
            crate::operation::describe_users::DescribeUsersError::RequestedEntityTooLargeException(inner) => Error::RequestedEntityTooLargeException(inner),
            crate::operation::describe_users::DescribeUsersError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::describe_users::DescribeUsersError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::describe_users::DescribeUsersError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::describe_users::DescribeUsersError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_current_user::GetCurrentUserError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_current_user::GetCurrentUserError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_current_user::GetCurrentUserError> for Error {
    fn from(err: crate::operation::get_current_user::GetCurrentUserError) -> Self {
        match err {
            crate::operation::get_current_user::GetCurrentUserError::EntityNotExistsException(inner) => Error::EntityNotExistsException(inner),
            crate::operation::get_current_user::GetCurrentUserError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::get_current_user::GetCurrentUserError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::get_current_user::GetCurrentUserError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::get_current_user::GetCurrentUserError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::get_current_user::GetCurrentUserError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_document::GetDocumentError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_document::GetDocumentError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_document::GetDocumentError> for Error {
    fn from(err: crate::operation::get_document::GetDocumentError) -> Self {
        match err {
            crate::operation::get_document::GetDocumentError::EntityNotExistsException(inner) => Error::EntityNotExistsException(inner),
            crate::operation::get_document::GetDocumentError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::get_document::GetDocumentError::InvalidArgumentException(inner) => Error::InvalidArgumentException(inner),
            crate::operation::get_document::GetDocumentError::InvalidPasswordException(inner) => Error::InvalidPasswordException(inner),
            crate::operation::get_document::GetDocumentError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::get_document::GetDocumentError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::get_document::GetDocumentError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::get_document::GetDocumentError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_document_path::GetDocumentPathError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_document_path::GetDocumentPathError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_document_path::GetDocumentPathError> for Error {
    fn from(err: crate::operation::get_document_path::GetDocumentPathError) -> Self {
        match err {
            crate::operation::get_document_path::GetDocumentPathError::EntityNotExistsException(inner) => Error::EntityNotExistsException(inner),
            crate::operation::get_document_path::GetDocumentPathError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::get_document_path::GetDocumentPathError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::get_document_path::GetDocumentPathError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::get_document_path::GetDocumentPathError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::get_document_path::GetDocumentPathError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_document_version::GetDocumentVersionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_document_version::GetDocumentVersionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_document_version::GetDocumentVersionError> for Error {
    fn from(err: crate::operation::get_document_version::GetDocumentVersionError) -> Self {
        match err {
            crate::operation::get_document_version::GetDocumentVersionError::EntityNotExistsException(inner) => Error::EntityNotExistsException(inner),
            crate::operation::get_document_version::GetDocumentVersionError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::get_document_version::GetDocumentVersionError::InvalidPasswordException(inner) => Error::InvalidPasswordException(inner),
            crate::operation::get_document_version::GetDocumentVersionError::ProhibitedStateException(inner) => Error::ProhibitedStateException(inner),
            crate::operation::get_document_version::GetDocumentVersionError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::get_document_version::GetDocumentVersionError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::get_document_version::GetDocumentVersionError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::get_document_version::GetDocumentVersionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_folder::GetFolderError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_folder::GetFolderError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_folder::GetFolderError> for Error {
    fn from(err: crate::operation::get_folder::GetFolderError) -> Self {
        match err {
            crate::operation::get_folder::GetFolderError::EntityNotExistsException(inner) => Error::EntityNotExistsException(inner),
            crate::operation::get_folder::GetFolderError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::get_folder::GetFolderError::InvalidArgumentException(inner) => Error::InvalidArgumentException(inner),
            crate::operation::get_folder::GetFolderError::ProhibitedStateException(inner) => Error::ProhibitedStateException(inner),
            crate::operation::get_folder::GetFolderError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::get_folder::GetFolderError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::get_folder::GetFolderError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::get_folder::GetFolderError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_folder_path::GetFolderPathError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_folder_path::GetFolderPathError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_folder_path::GetFolderPathError> for Error {
    fn from(err: crate::operation::get_folder_path::GetFolderPathError) -> Self {
        match err {
            crate::operation::get_folder_path::GetFolderPathError::EntityNotExistsException(inner) => Error::EntityNotExistsException(inner),
            crate::operation::get_folder_path::GetFolderPathError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::get_folder_path::GetFolderPathError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::get_folder_path::GetFolderPathError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::get_folder_path::GetFolderPathError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::get_folder_path::GetFolderPathError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_resources::GetResourcesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_resources::GetResourcesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_resources::GetResourcesError> for Error {
    fn from(err: crate::operation::get_resources::GetResourcesError) -> Self {
        match err {
            crate::operation::get_resources::GetResourcesError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::get_resources::GetResourcesError::InvalidArgumentException(inner) => Error::InvalidArgumentException(inner),
            crate::operation::get_resources::GetResourcesError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::get_resources::GetResourcesError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::get_resources::GetResourcesError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::get_resources::GetResourcesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::initiate_document_version_upload::InitiateDocumentVersionUploadError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::initiate_document_version_upload::InitiateDocumentVersionUploadError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::initiate_document_version_upload::InitiateDocumentVersionUploadError> for Error {
    fn from(err: crate::operation::initiate_document_version_upload::InitiateDocumentVersionUploadError) -> Self {
        match err {
            crate::operation::initiate_document_version_upload::InitiateDocumentVersionUploadError::DraftUploadOutOfSyncException(inner) => Error::DraftUploadOutOfSyncException(inner),
            crate::operation::initiate_document_version_upload::InitiateDocumentVersionUploadError::EntityAlreadyExistsException(inner) => Error::EntityAlreadyExistsException(inner),
            crate::operation::initiate_document_version_upload::InitiateDocumentVersionUploadError::EntityNotExistsException(inner) => Error::EntityNotExistsException(inner),
            crate::operation::initiate_document_version_upload::InitiateDocumentVersionUploadError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::initiate_document_version_upload::InitiateDocumentVersionUploadError::InvalidPasswordException(inner) => Error::InvalidPasswordException(inner),
            crate::operation::initiate_document_version_upload::InitiateDocumentVersionUploadError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::initiate_document_version_upload::InitiateDocumentVersionUploadError::ProhibitedStateException(inner) => Error::ProhibitedStateException(inner),
            crate::operation::initiate_document_version_upload::InitiateDocumentVersionUploadError::ResourceAlreadyCheckedOutException(inner) => Error::ResourceAlreadyCheckedOutException(inner),
            crate::operation::initiate_document_version_upload::InitiateDocumentVersionUploadError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::initiate_document_version_upload::InitiateDocumentVersionUploadError::StorageLimitExceededException(inner) => Error::StorageLimitExceededException(inner),
            crate::operation::initiate_document_version_upload::InitiateDocumentVersionUploadError::StorageLimitWillExceedException(inner) => Error::StorageLimitWillExceedException(inner),
            crate::operation::initiate_document_version_upload::InitiateDocumentVersionUploadError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::initiate_document_version_upload::InitiateDocumentVersionUploadError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::initiate_document_version_upload::InitiateDocumentVersionUploadError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::remove_all_resource_permissions::RemoveAllResourcePermissionsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::remove_all_resource_permissions::RemoveAllResourcePermissionsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::remove_all_resource_permissions::RemoveAllResourcePermissionsError> for Error {
    fn from(err: crate::operation::remove_all_resource_permissions::RemoveAllResourcePermissionsError) -> Self {
        match err {
            crate::operation::remove_all_resource_permissions::RemoveAllResourcePermissionsError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::remove_all_resource_permissions::RemoveAllResourcePermissionsError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::remove_all_resource_permissions::RemoveAllResourcePermissionsError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::remove_all_resource_permissions::RemoveAllResourcePermissionsError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::remove_all_resource_permissions::RemoveAllResourcePermissionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::remove_resource_permission::RemoveResourcePermissionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::remove_resource_permission::RemoveResourcePermissionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::remove_resource_permission::RemoveResourcePermissionError> for Error {
    fn from(err: crate::operation::remove_resource_permission::RemoveResourcePermissionError) -> Self {
        match err {
            crate::operation::remove_resource_permission::RemoveResourcePermissionError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::remove_resource_permission::RemoveResourcePermissionError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::remove_resource_permission::RemoveResourcePermissionError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::remove_resource_permission::RemoveResourcePermissionError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::remove_resource_permission::RemoveResourcePermissionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::restore_document_versions::RestoreDocumentVersionsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::restore_document_versions::RestoreDocumentVersionsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::restore_document_versions::RestoreDocumentVersionsError> for Error {
    fn from(err: crate::operation::restore_document_versions::RestoreDocumentVersionsError) -> Self {
        match err {
            crate::operation::restore_document_versions::RestoreDocumentVersionsError::ConcurrentModificationException(inner) => Error::ConcurrentModificationException(inner),
            crate::operation::restore_document_versions::RestoreDocumentVersionsError::ConflictingOperationException(inner) => Error::ConflictingOperationException(inner),
            crate::operation::restore_document_versions::RestoreDocumentVersionsError::EntityNotExistsException(inner) => Error::EntityNotExistsException(inner),
            crate::operation::restore_document_versions::RestoreDocumentVersionsError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::restore_document_versions::RestoreDocumentVersionsError::InvalidOperationException(inner) => Error::InvalidOperationException(inner),
            crate::operation::restore_document_versions::RestoreDocumentVersionsError::ProhibitedStateException(inner) => Error::ProhibitedStateException(inner),
            crate::operation::restore_document_versions::RestoreDocumentVersionsError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::restore_document_versions::RestoreDocumentVersionsError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::restore_document_versions::RestoreDocumentVersionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::update_document::UpdateDocumentError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::update_document::UpdateDocumentError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::update_document::UpdateDocumentError> for Error {
    fn from(err: crate::operation::update_document::UpdateDocumentError) -> Self {
        match err {
            crate::operation::update_document::UpdateDocumentError::ConcurrentModificationException(inner) => Error::ConcurrentModificationException(inner),
            crate::operation::update_document::UpdateDocumentError::ConflictingOperationException(inner) => Error::ConflictingOperationException(inner),
            crate::operation::update_document::UpdateDocumentError::EntityAlreadyExistsException(inner) => Error::EntityAlreadyExistsException(inner),
            crate::operation::update_document::UpdateDocumentError::EntityNotExistsException(inner) => Error::EntityNotExistsException(inner),
            crate::operation::update_document::UpdateDocumentError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::update_document::UpdateDocumentError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::update_document::UpdateDocumentError::ProhibitedStateException(inner) => Error::ProhibitedStateException(inner),
            crate::operation::update_document::UpdateDocumentError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::update_document::UpdateDocumentError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::update_document::UpdateDocumentError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::update_document::UpdateDocumentError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::update_document_version::UpdateDocumentVersionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::update_document_version::UpdateDocumentVersionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::update_document_version::UpdateDocumentVersionError> for Error {
    fn from(err: crate::operation::update_document_version::UpdateDocumentVersionError) -> Self {
        match err {
            crate::operation::update_document_version::UpdateDocumentVersionError::ConcurrentModificationException(inner) => Error::ConcurrentModificationException(inner),
            crate::operation::update_document_version::UpdateDocumentVersionError::EntityNotExistsException(inner) => Error::EntityNotExistsException(inner),
            crate::operation::update_document_version::UpdateDocumentVersionError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::update_document_version::UpdateDocumentVersionError::InvalidOperationException(inner) => Error::InvalidOperationException(inner),
            crate::operation::update_document_version::UpdateDocumentVersionError::ProhibitedStateException(inner) => Error::ProhibitedStateException(inner),
            crate::operation::update_document_version::UpdateDocumentVersionError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::update_document_version::UpdateDocumentVersionError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::update_document_version::UpdateDocumentVersionError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::update_document_version::UpdateDocumentVersionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::update_folder::UpdateFolderError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::update_folder::UpdateFolderError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::update_folder::UpdateFolderError> for Error {
    fn from(err: crate::operation::update_folder::UpdateFolderError) -> Self {
        match err {
            crate::operation::update_folder::UpdateFolderError::ConcurrentModificationException(inner) => Error::ConcurrentModificationException(inner),
            crate::operation::update_folder::UpdateFolderError::ConflictingOperationException(inner) => Error::ConflictingOperationException(inner),
            crate::operation::update_folder::UpdateFolderError::EntityAlreadyExistsException(inner) => Error::EntityAlreadyExistsException(inner),
            crate::operation::update_folder::UpdateFolderError::EntityNotExistsException(inner) => Error::EntityNotExistsException(inner),
            crate::operation::update_folder::UpdateFolderError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::update_folder::UpdateFolderError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::update_folder::UpdateFolderError::ProhibitedStateException(inner) => Error::ProhibitedStateException(inner),
            crate::operation::update_folder::UpdateFolderError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::update_folder::UpdateFolderError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::update_folder::UpdateFolderError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::update_folder::UpdateFolderError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::update_user::UpdateUserError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::update_user::UpdateUserError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::update_user::UpdateUserError> for Error {
    fn from(err: crate::operation::update_user::UpdateUserError) -> Self {
        match err {
            crate::operation::update_user::UpdateUserError::DeactivatingLastSystemUserException(inner) => Error::DeactivatingLastSystemUserException(inner),
            crate::operation::update_user::UpdateUserError::EntityNotExistsException(inner) => Error::EntityNotExistsException(inner),
            crate::operation::update_user::UpdateUserError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::operation::update_user::UpdateUserError::IllegalUserStateException(inner) => Error::IllegalUserStateException(inner),
            crate::operation::update_user::UpdateUserError::InvalidArgumentException(inner) => Error::InvalidArgumentException(inner),
            crate::operation::update_user::UpdateUserError::ProhibitedStateException(inner) => Error::ProhibitedStateException(inner),
            crate::operation::update_user::UpdateUserError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::operation::update_user::UpdateUserError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::operation::update_user::UpdateUserError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::operation::update_user::UpdateUserError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl std::error::Error for Error {}
impl aws_http::request_id::RequestId for Error {
    fn request_id(&self) -> Option<&str> {
        match self {
            Self::ConcurrentModificationException(e) => e.request_id(),
            Self::ConflictingOperationException(e) => e.request_id(),
            Self::CustomMetadataLimitExceededException(e) => e.request_id(),
            Self::DeactivatingLastSystemUserException(e) => e.request_id(),
            Self::DocumentLockedForCommentsException(e) => e.request_id(),
            Self::DraftUploadOutOfSyncException(e) => e.request_id(),
            Self::EntityAlreadyExistsException(e) => e.request_id(),
            Self::EntityNotExistsException(e) => e.request_id(),
            Self::FailedDependencyException(e) => e.request_id(),
            Self::IllegalUserStateException(e) => e.request_id(),
            Self::InvalidArgumentException(e) => e.request_id(),
            Self::InvalidCommentOperationException(e) => e.request_id(),
            Self::InvalidOperationException(e) => e.request_id(),
            Self::InvalidPasswordException(e) => e.request_id(),
            Self::LimitExceededException(e) => e.request_id(),
            Self::ProhibitedStateException(e) => e.request_id(),
            Self::RequestedEntityTooLargeException(e) => e.request_id(),
            Self::ResourceAlreadyCheckedOutException(e) => e.request_id(),
            Self::ServiceUnavailableException(e) => e.request_id(),
            Self::StorageLimitExceededException(e) => e.request_id(),
            Self::StorageLimitWillExceedException(e) => e.request_id(),
            Self::TooManyLabelsException(e) => e.request_id(),
            Self::TooManySubscriptionsException(e) => e.request_id(),
            Self::UnauthorizedOperationException(e) => e.request_id(),
            Self::UnauthorizedResourceAccessException(e) => e.request_id(),
            Self::Unhandled(e) => e.request_id(),
        }
    }
}

