// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// All possible error types for this service.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum Error {
    /// <p>The resource hierarchy is changing.</p>
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    /// <p>Another operation is in progress on the resource that conflicts with the current operation.</p>
    ConflictingOperationException(crate::error::ConflictingOperationException),
    /// <p>The limit has been reached on the number of custom properties for the specified resource.</p>
    CustomMetadataLimitExceededException(crate::error::CustomMetadataLimitExceededException),
    /// <p>The last user in the organization is being deactivated.</p>
    DeactivatingLastSystemUserException(crate::error::DeactivatingLastSystemUserException),
    /// <p>This exception is thrown when the document is locked for comments and user tries to create or delete a comment on that document.</p>
    DocumentLockedForCommentsException(crate::error::DocumentLockedForCommentsException),
    /// <p>This exception is thrown when a valid checkout ID is not presented on document version upload calls for a document that has been checked out from Web client.</p>
    DraftUploadOutOfSyncException(crate::error::DraftUploadOutOfSyncException),
    /// <p>The resource already exists.</p>
    EntityAlreadyExistsException(crate::error::EntityAlreadyExistsException),
    /// <p>The resource does not exist.</p>
    EntityNotExistsException(crate::error::EntityNotExistsException),
    /// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.</p>
    FailedDependencyException(crate::error::FailedDependencyException),
    /// <p>The user is undergoing transfer of ownership.</p>
    IllegalUserStateException(crate::error::IllegalUserStateException),
    /// <p>The pagination marker or limit fields are not valid.</p>
    InvalidArgumentException(crate::error::InvalidArgumentException),
    /// <p>The requested operation is not allowed on the specified comment object.</p>
    InvalidCommentOperationException(crate::error::InvalidCommentOperationException),
    /// <p>The operation is invalid.</p>
    InvalidOperationException(crate::error::InvalidOperationException),
    /// <p>The password is invalid.</p>
    InvalidPasswordException(crate::error::InvalidPasswordException),
    /// <p>The maximum of 100,000 files and folders under the parent folder has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The specified document version is not in the INITIALIZED state.</p>
    ProhibitedStateException(crate::error::ProhibitedStateException),
    /// <p>The response is too large to return. The request must include a filter to reduce the size of the response.</p>
    RequestedEntityTooLargeException(crate::error::RequestedEntityTooLargeException),
    /// <p>The resource is already checked out.</p>
    ResourceAlreadyCheckedOutException(crate::error::ResourceAlreadyCheckedOutException),
    /// <p>One or more of the dependencies is unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The storage limit has been exceeded.</p>
    StorageLimitExceededException(crate::error::StorageLimitExceededException),
    /// <p>The storage limit will be exceeded.</p>
    StorageLimitWillExceedException(crate::error::StorageLimitWillExceedException),
    /// <p>The limit has been reached on the number of labels for the specified resource.</p>
    TooManyLabelsException(crate::error::TooManyLabelsException),
    /// <p>You've reached the limit on the number of subscriptions for the WorkDocs instance.</p>
    TooManySubscriptionsException(crate::error::TooManySubscriptionsException),
    /// <p>The operation is not permitted.</p>
    UnauthorizedOperationException(crate::error::UnauthorizedOperationException),
    /// <p>The caller does not have access to perform the action on the resource.</p>
    UnauthorizedResourceAccessException(crate::error::UnauthorizedResourceAccessException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::ConcurrentModificationException(inner) => inner.fmt(f),
            Error::ConflictingOperationException(inner) => inner.fmt(f),
            Error::CustomMetadataLimitExceededException(inner) => inner.fmt(f),
            Error::DeactivatingLastSystemUserException(inner) => inner.fmt(f),
            Error::DocumentLockedForCommentsException(inner) => inner.fmt(f),
            Error::DraftUploadOutOfSyncException(inner) => inner.fmt(f),
            Error::EntityAlreadyExistsException(inner) => inner.fmt(f),
            Error::EntityNotExistsException(inner) => inner.fmt(f),
            Error::FailedDependencyException(inner) => inner.fmt(f),
            Error::IllegalUserStateException(inner) => inner.fmt(f),
            Error::InvalidArgumentException(inner) => inner.fmt(f),
            Error::InvalidCommentOperationException(inner) => inner.fmt(f),
            Error::InvalidOperationException(inner) => inner.fmt(f),
            Error::InvalidPasswordException(inner) => inner.fmt(f),
            Error::LimitExceededException(inner) => inner.fmt(f),
            Error::ProhibitedStateException(inner) => inner.fmt(f),
            Error::RequestedEntityTooLargeException(inner) => inner.fmt(f),
            Error::ResourceAlreadyCheckedOutException(inner) => inner.fmt(f),
            Error::ServiceUnavailableException(inner) => inner.fmt(f),
            Error::StorageLimitExceededException(inner) => inner.fmt(f),
            Error::StorageLimitWillExceedException(inner) => inner.fmt(f),
            Error::TooManyLabelsException(inner) => inner.fmt(f),
            Error::TooManySubscriptionsException(inner) => inner.fmt(f),
            Error::UnauthorizedOperationException(inner) => inner.fmt(f),
            Error::UnauthorizedResourceAccessException(inner) => inner.fmt(f),
            Error::Unhandled(inner) => inner.fmt(f),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::AbortDocumentVersionUploadError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::AbortDocumentVersionUploadError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::AbortDocumentVersionUploadError> for Error {
    fn from(err: crate::error::AbortDocumentVersionUploadError) -> Self {
        match err {
            crate::error::AbortDocumentVersionUploadError::ConcurrentModificationException(
                inner,
            ) => Error::ConcurrentModificationException(inner),
            crate::error::AbortDocumentVersionUploadError::EntityNotExistsException(inner) => {
                Error::EntityNotExistsException(inner)
            }
            crate::error::AbortDocumentVersionUploadError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::AbortDocumentVersionUploadError::ProhibitedStateException(inner) => {
                Error::ProhibitedStateException(inner)
            }
            crate::error::AbortDocumentVersionUploadError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::AbortDocumentVersionUploadError::UnauthorizedOperationException(
                inner,
            ) => Error::UnauthorizedOperationException(inner),
            crate::error::AbortDocumentVersionUploadError::UnauthorizedResourceAccessException(
                inner,
            ) => Error::UnauthorizedResourceAccessException(inner),
            crate::error::AbortDocumentVersionUploadError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ActivateUserError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ActivateUserError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ActivateUserError> for Error {
    fn from(err: crate::error::ActivateUserError) -> Self {
        match err {
            crate::error::ActivateUserError::EntityNotExistsException(inner) => {
                Error::EntityNotExistsException(inner)
            }
            crate::error::ActivateUserError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::ActivateUserError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::ActivateUserError::UnauthorizedOperationException(inner) => {
                Error::UnauthorizedOperationException(inner)
            }
            crate::error::ActivateUserError::UnauthorizedResourceAccessException(inner) => {
                Error::UnauthorizedResourceAccessException(inner)
            }
            crate::error::ActivateUserError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::AddResourcePermissionsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::AddResourcePermissionsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::AddResourcePermissionsError> for Error {
    fn from(err: crate::error::AddResourcePermissionsError) -> Self {
        match err {
            crate::error::AddResourcePermissionsError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::AddResourcePermissionsError::ProhibitedStateException(inner) => {
                Error::ProhibitedStateException(inner)
            }
            crate::error::AddResourcePermissionsError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::AddResourcePermissionsError::UnauthorizedOperationException(inner) => {
                Error::UnauthorizedOperationException(inner)
            }
            crate::error::AddResourcePermissionsError::UnauthorizedResourceAccessException(
                inner,
            ) => Error::UnauthorizedResourceAccessException(inner),
            crate::error::AddResourcePermissionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateCommentError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateCommentError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateCommentError> for Error {
    fn from(err: crate::error::CreateCommentError) -> Self {
        match err {
            crate::error::CreateCommentError::DocumentLockedForCommentsException(inner) => {
                Error::DocumentLockedForCommentsException(inner)
            }
            crate::error::CreateCommentError::EntityNotExistsException(inner) => {
                Error::EntityNotExistsException(inner)
            }
            crate::error::CreateCommentError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::CreateCommentError::InvalidCommentOperationException(inner) => {
                Error::InvalidCommentOperationException(inner)
            }
            crate::error::CreateCommentError::ProhibitedStateException(inner) => {
                Error::ProhibitedStateException(inner)
            }
            crate::error::CreateCommentError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::CreateCommentError::UnauthorizedOperationException(inner) => {
                Error::UnauthorizedOperationException(inner)
            }
            crate::error::CreateCommentError::UnauthorizedResourceAccessException(inner) => {
                Error::UnauthorizedResourceAccessException(inner)
            }
            crate::error::CreateCommentError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateCustomMetadataError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateCustomMetadataError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateCustomMetadataError> for Error {
    fn from(err: crate::error::CreateCustomMetadataError) -> Self {
        match err {
            crate::error::CreateCustomMetadataError::CustomMetadataLimitExceededException(
                inner,
            ) => Error::CustomMetadataLimitExceededException(inner),
            crate::error::CreateCustomMetadataError::EntityNotExistsException(inner) => {
                Error::EntityNotExistsException(inner)
            }
            crate::error::CreateCustomMetadataError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::CreateCustomMetadataError::ProhibitedStateException(inner) => {
                Error::ProhibitedStateException(inner)
            }
            crate::error::CreateCustomMetadataError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::CreateCustomMetadataError::UnauthorizedOperationException(inner) => {
                Error::UnauthorizedOperationException(inner)
            }
            crate::error::CreateCustomMetadataError::UnauthorizedResourceAccessException(inner) => {
                Error::UnauthorizedResourceAccessException(inner)
            }
            crate::error::CreateCustomMetadataError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateFolderError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateFolderError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateFolderError> for Error {
    fn from(err: crate::error::CreateFolderError) -> Self {
        match err {
            crate::error::CreateFolderError::ConcurrentModificationException(inner) => {
                Error::ConcurrentModificationException(inner)
            }
            crate::error::CreateFolderError::ConflictingOperationException(inner) => {
                Error::ConflictingOperationException(inner)
            }
            crate::error::CreateFolderError::EntityAlreadyExistsException(inner) => {
                Error::EntityAlreadyExistsException(inner)
            }
            crate::error::CreateFolderError::EntityNotExistsException(inner) => {
                Error::EntityNotExistsException(inner)
            }
            crate::error::CreateFolderError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::CreateFolderError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::CreateFolderError::ProhibitedStateException(inner) => {
                Error::ProhibitedStateException(inner)
            }
            crate::error::CreateFolderError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::CreateFolderError::UnauthorizedOperationException(inner) => {
                Error::UnauthorizedOperationException(inner)
            }
            crate::error::CreateFolderError::UnauthorizedResourceAccessException(inner) => {
                Error::UnauthorizedResourceAccessException(inner)
            }
            crate::error::CreateFolderError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateLabelsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateLabelsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateLabelsError> for Error {
    fn from(err: crate::error::CreateLabelsError) -> Self {
        match err {
            crate::error::CreateLabelsError::EntityNotExistsException(inner) => {
                Error::EntityNotExistsException(inner)
            }
            crate::error::CreateLabelsError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::CreateLabelsError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::CreateLabelsError::TooManyLabelsException(inner) => {
                Error::TooManyLabelsException(inner)
            }
            crate::error::CreateLabelsError::UnauthorizedOperationException(inner) => {
                Error::UnauthorizedOperationException(inner)
            }
            crate::error::CreateLabelsError::UnauthorizedResourceAccessException(inner) => {
                Error::UnauthorizedResourceAccessException(inner)
            }
            crate::error::CreateLabelsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::CreateNotificationSubscriptionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::CreateNotificationSubscriptionError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateNotificationSubscriptionError> for Error {
    fn from(err: crate::error::CreateNotificationSubscriptionError) -> Self {
        match err {
            crate::error::CreateNotificationSubscriptionError::InvalidArgumentException(inner) => Error::InvalidArgumentException(inner),
            crate::error::CreateNotificationSubscriptionError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::error::CreateNotificationSubscriptionError::TooManySubscriptionsException(inner) => Error::TooManySubscriptionsException(inner),
            crate::error::CreateNotificationSubscriptionError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::error::CreateNotificationSubscriptionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateUserError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateUserError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateUserError> for Error {
    fn from(err: crate::error::CreateUserError) -> Self {
        match err {
            crate::error::CreateUserError::EntityAlreadyExistsException(inner) => {
                Error::EntityAlreadyExistsException(inner)
            }
            crate::error::CreateUserError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::CreateUserError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::CreateUserError::UnauthorizedOperationException(inner) => {
                Error::UnauthorizedOperationException(inner)
            }
            crate::error::CreateUserError::UnauthorizedResourceAccessException(inner) => {
                Error::UnauthorizedResourceAccessException(inner)
            }
            crate::error::CreateUserError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeactivateUserError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeactivateUserError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeactivateUserError> for Error {
    fn from(err: crate::error::DeactivateUserError) -> Self {
        match err {
            crate::error::DeactivateUserError::EntityNotExistsException(inner) => {
                Error::EntityNotExistsException(inner)
            }
            crate::error::DeactivateUserError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::DeactivateUserError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::DeactivateUserError::UnauthorizedOperationException(inner) => {
                Error::UnauthorizedOperationException(inner)
            }
            crate::error::DeactivateUserError::UnauthorizedResourceAccessException(inner) => {
                Error::UnauthorizedResourceAccessException(inner)
            }
            crate::error::DeactivateUserError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteCommentError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteCommentError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteCommentError> for Error {
    fn from(err: crate::error::DeleteCommentError) -> Self {
        match err {
            crate::error::DeleteCommentError::DocumentLockedForCommentsException(inner) => {
                Error::DocumentLockedForCommentsException(inner)
            }
            crate::error::DeleteCommentError::EntityNotExistsException(inner) => {
                Error::EntityNotExistsException(inner)
            }
            crate::error::DeleteCommentError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::DeleteCommentError::ProhibitedStateException(inner) => {
                Error::ProhibitedStateException(inner)
            }
            crate::error::DeleteCommentError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::DeleteCommentError::UnauthorizedOperationException(inner) => {
                Error::UnauthorizedOperationException(inner)
            }
            crate::error::DeleteCommentError::UnauthorizedResourceAccessException(inner) => {
                Error::UnauthorizedResourceAccessException(inner)
            }
            crate::error::DeleteCommentError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteCustomMetadataError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteCustomMetadataError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteCustomMetadataError> for Error {
    fn from(err: crate::error::DeleteCustomMetadataError) -> Self {
        match err {
            crate::error::DeleteCustomMetadataError::EntityNotExistsException(inner) => {
                Error::EntityNotExistsException(inner)
            }
            crate::error::DeleteCustomMetadataError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::DeleteCustomMetadataError::ProhibitedStateException(inner) => {
                Error::ProhibitedStateException(inner)
            }
            crate::error::DeleteCustomMetadataError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::DeleteCustomMetadataError::UnauthorizedOperationException(inner) => {
                Error::UnauthorizedOperationException(inner)
            }
            crate::error::DeleteCustomMetadataError::UnauthorizedResourceAccessException(inner) => {
                Error::UnauthorizedResourceAccessException(inner)
            }
            crate::error::DeleteCustomMetadataError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteDocumentError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteDocumentError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteDocumentError> for Error {
    fn from(err: crate::error::DeleteDocumentError) -> Self {
        match err {
            crate::error::DeleteDocumentError::ConcurrentModificationException(inner) => {
                Error::ConcurrentModificationException(inner)
            }
            crate::error::DeleteDocumentError::ConflictingOperationException(inner) => {
                Error::ConflictingOperationException(inner)
            }
            crate::error::DeleteDocumentError::EntityNotExistsException(inner) => {
                Error::EntityNotExistsException(inner)
            }
            crate::error::DeleteDocumentError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::DeleteDocumentError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::DeleteDocumentError::ProhibitedStateException(inner) => {
                Error::ProhibitedStateException(inner)
            }
            crate::error::DeleteDocumentError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::DeleteDocumentError::UnauthorizedOperationException(inner) => {
                Error::UnauthorizedOperationException(inner)
            }
            crate::error::DeleteDocumentError::UnauthorizedResourceAccessException(inner) => {
                Error::UnauthorizedResourceAccessException(inner)
            }
            crate::error::DeleteDocumentError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteDocumentVersionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteDocumentVersionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteDocumentVersionError> for Error {
    fn from(err: crate::error::DeleteDocumentVersionError) -> Self {
        match err {
            crate::error::DeleteDocumentVersionError::ConcurrentModificationException(inner) => {
                Error::ConcurrentModificationException(inner)
            }
            crate::error::DeleteDocumentVersionError::ConflictingOperationException(inner) => {
                Error::ConflictingOperationException(inner)
            }
            crate::error::DeleteDocumentVersionError::EntityNotExistsException(inner) => {
                Error::EntityNotExistsException(inner)
            }
            crate::error::DeleteDocumentVersionError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::DeleteDocumentVersionError::InvalidOperationException(inner) => {
                Error::InvalidOperationException(inner)
            }
            crate::error::DeleteDocumentVersionError::ProhibitedStateException(inner) => {
                Error::ProhibitedStateException(inner)
            }
            crate::error::DeleteDocumentVersionError::UnauthorizedOperationException(inner) => {
                Error::UnauthorizedOperationException(inner)
            }
            crate::error::DeleteDocumentVersionError::UnauthorizedResourceAccessException(
                inner,
            ) => Error::UnauthorizedResourceAccessException(inner),
            crate::error::DeleteDocumentVersionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteFolderError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteFolderError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteFolderError> for Error {
    fn from(err: crate::error::DeleteFolderError) -> Self {
        match err {
            crate::error::DeleteFolderError::ConcurrentModificationException(inner) => {
                Error::ConcurrentModificationException(inner)
            }
            crate::error::DeleteFolderError::ConflictingOperationException(inner) => {
                Error::ConflictingOperationException(inner)
            }
            crate::error::DeleteFolderError::EntityNotExistsException(inner) => {
                Error::EntityNotExistsException(inner)
            }
            crate::error::DeleteFolderError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::DeleteFolderError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::DeleteFolderError::ProhibitedStateException(inner) => {
                Error::ProhibitedStateException(inner)
            }
            crate::error::DeleteFolderError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::DeleteFolderError::UnauthorizedOperationException(inner) => {
                Error::UnauthorizedOperationException(inner)
            }
            crate::error::DeleteFolderError::UnauthorizedResourceAccessException(inner) => {
                Error::UnauthorizedResourceAccessException(inner)
            }
            crate::error::DeleteFolderError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteFolderContentsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteFolderContentsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteFolderContentsError> for Error {
    fn from(err: crate::error::DeleteFolderContentsError) -> Self {
        match err {
            crate::error::DeleteFolderContentsError::ConflictingOperationException(inner) => {
                Error::ConflictingOperationException(inner)
            }
            crate::error::DeleteFolderContentsError::EntityNotExistsException(inner) => {
                Error::EntityNotExistsException(inner)
            }
            crate::error::DeleteFolderContentsError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::DeleteFolderContentsError::ProhibitedStateException(inner) => {
                Error::ProhibitedStateException(inner)
            }
            crate::error::DeleteFolderContentsError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::DeleteFolderContentsError::UnauthorizedOperationException(inner) => {
                Error::UnauthorizedOperationException(inner)
            }
            crate::error::DeleteFolderContentsError::UnauthorizedResourceAccessException(inner) => {
                Error::UnauthorizedResourceAccessException(inner)
            }
            crate::error::DeleteFolderContentsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteLabelsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteLabelsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteLabelsError> for Error {
    fn from(err: crate::error::DeleteLabelsError) -> Self {
        match err {
            crate::error::DeleteLabelsError::EntityNotExistsException(inner) => {
                Error::EntityNotExistsException(inner)
            }
            crate::error::DeleteLabelsError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::DeleteLabelsError::ProhibitedStateException(inner) => {
                Error::ProhibitedStateException(inner)
            }
            crate::error::DeleteLabelsError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::DeleteLabelsError::UnauthorizedOperationException(inner) => {
                Error::UnauthorizedOperationException(inner)
            }
            crate::error::DeleteLabelsError::UnauthorizedResourceAccessException(inner) => {
                Error::UnauthorizedResourceAccessException(inner)
            }
            crate::error::DeleteLabelsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::DeleteNotificationSubscriptionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::DeleteNotificationSubscriptionError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteNotificationSubscriptionError> for Error {
    fn from(err: crate::error::DeleteNotificationSubscriptionError) -> Self {
        match err {
            crate::error::DeleteNotificationSubscriptionError::EntityNotExistsException(inner) => Error::EntityNotExistsException(inner),
            crate::error::DeleteNotificationSubscriptionError::ProhibitedStateException(inner) => Error::ProhibitedStateException(inner),
            crate::error::DeleteNotificationSubscriptionError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::error::DeleteNotificationSubscriptionError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::error::DeleteNotificationSubscriptionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteUserError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteUserError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteUserError> for Error {
    fn from(err: crate::error::DeleteUserError) -> Self {
        match err {
            crate::error::DeleteUserError::EntityNotExistsException(inner) => {
                Error::EntityNotExistsException(inner)
            }
            crate::error::DeleteUserError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::DeleteUserError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::DeleteUserError::UnauthorizedOperationException(inner) => {
                Error::UnauthorizedOperationException(inner)
            }
            crate::error::DeleteUserError::UnauthorizedResourceAccessException(inner) => {
                Error::UnauthorizedResourceAccessException(inner)
            }
            crate::error::DeleteUserError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeActivitiesError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeActivitiesError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeActivitiesError> for Error {
    fn from(err: crate::error::DescribeActivitiesError) -> Self {
        match err {
            crate::error::DescribeActivitiesError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::DescribeActivitiesError::InvalidArgumentException(inner) => {
                Error::InvalidArgumentException(inner)
            }
            crate::error::DescribeActivitiesError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::DescribeActivitiesError::UnauthorizedOperationException(inner) => {
                Error::UnauthorizedOperationException(inner)
            }
            crate::error::DescribeActivitiesError::UnauthorizedResourceAccessException(inner) => {
                Error::UnauthorizedResourceAccessException(inner)
            }
            crate::error::DescribeActivitiesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeCommentsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeCommentsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeCommentsError> for Error {
    fn from(err: crate::error::DescribeCommentsError) -> Self {
        match err {
            crate::error::DescribeCommentsError::EntityNotExistsException(inner) => {
                Error::EntityNotExistsException(inner)
            }
            crate::error::DescribeCommentsError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::DescribeCommentsError::ProhibitedStateException(inner) => {
                Error::ProhibitedStateException(inner)
            }
            crate::error::DescribeCommentsError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::DescribeCommentsError::UnauthorizedOperationException(inner) => {
                Error::UnauthorizedOperationException(inner)
            }
            crate::error::DescribeCommentsError::UnauthorizedResourceAccessException(inner) => {
                Error::UnauthorizedResourceAccessException(inner)
            }
            crate::error::DescribeCommentsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeDocumentVersionsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeDocumentVersionsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeDocumentVersionsError> for Error {
    fn from(err: crate::error::DescribeDocumentVersionsError) -> Self {
        match err {
            crate::error::DescribeDocumentVersionsError::EntityNotExistsException(inner) => {
                Error::EntityNotExistsException(inner)
            }
            crate::error::DescribeDocumentVersionsError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::DescribeDocumentVersionsError::InvalidArgumentException(inner) => {
                Error::InvalidArgumentException(inner)
            }
            crate::error::DescribeDocumentVersionsError::InvalidPasswordException(inner) => {
                Error::InvalidPasswordException(inner)
            }
            crate::error::DescribeDocumentVersionsError::ProhibitedStateException(inner) => {
                Error::ProhibitedStateException(inner)
            }
            crate::error::DescribeDocumentVersionsError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::DescribeDocumentVersionsError::UnauthorizedOperationException(inner) => {
                Error::UnauthorizedOperationException(inner)
            }
            crate::error::DescribeDocumentVersionsError::UnauthorizedResourceAccessException(
                inner,
            ) => Error::UnauthorizedResourceAccessException(inner),
            crate::error::DescribeDocumentVersionsError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeFolderContentsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeFolderContentsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeFolderContentsError> for Error {
    fn from(err: crate::error::DescribeFolderContentsError) -> Self {
        match err {
            crate::error::DescribeFolderContentsError::EntityNotExistsException(inner) => {
                Error::EntityNotExistsException(inner)
            }
            crate::error::DescribeFolderContentsError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::DescribeFolderContentsError::InvalidArgumentException(inner) => {
                Error::InvalidArgumentException(inner)
            }
            crate::error::DescribeFolderContentsError::ProhibitedStateException(inner) => {
                Error::ProhibitedStateException(inner)
            }
            crate::error::DescribeFolderContentsError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::DescribeFolderContentsError::UnauthorizedResourceAccessException(
                inner,
            ) => Error::UnauthorizedResourceAccessException(inner),
            crate::error::DescribeFolderContentsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeGroupsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DescribeGroupsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeGroupsError> for Error {
    fn from(err: crate::error::DescribeGroupsError) -> Self {
        match err {
            crate::error::DescribeGroupsError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::DescribeGroupsError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::DescribeGroupsError::UnauthorizedOperationException(inner) => {
                Error::UnauthorizedOperationException(inner)
            }
            crate::error::DescribeGroupsError::UnauthorizedResourceAccessException(inner) => {
                Error::UnauthorizedResourceAccessException(inner)
            }
            crate::error::DescribeGroupsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::DescribeNotificationSubscriptionsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::DescribeNotificationSubscriptionsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeNotificationSubscriptionsError> for Error {
    fn from(err: crate::error::DescribeNotificationSubscriptionsError) -> Self {
        match err {
            crate::error::DescribeNotificationSubscriptionsError::EntityNotExistsException(inner) => Error::EntityNotExistsException(inner),
            crate::error::DescribeNotificationSubscriptionsError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::error::DescribeNotificationSubscriptionsError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::error::DescribeNotificationSubscriptionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeResourcePermissionsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeResourcePermissionsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeResourcePermissionsError> for Error {
    fn from(err: crate::error::DescribeResourcePermissionsError) -> Self {
        match err {
            crate::error::DescribeResourcePermissionsError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::DescribeResourcePermissionsError::InvalidArgumentException(inner) => {
                Error::InvalidArgumentException(inner)
            }
            crate::error::DescribeResourcePermissionsError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::DescribeResourcePermissionsError::UnauthorizedOperationException(
                inner,
            ) => Error::UnauthorizedOperationException(inner),
            crate::error::DescribeResourcePermissionsError::UnauthorizedResourceAccessException(
                inner,
            ) => Error::UnauthorizedResourceAccessException(inner),
            crate::error::DescribeResourcePermissionsError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeRootFoldersError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeRootFoldersError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeRootFoldersError> for Error {
    fn from(err: crate::error::DescribeRootFoldersError) -> Self {
        match err {
            crate::error::DescribeRootFoldersError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::DescribeRootFoldersError::InvalidArgumentException(inner) => {
                Error::InvalidArgumentException(inner)
            }
            crate::error::DescribeRootFoldersError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::DescribeRootFoldersError::UnauthorizedOperationException(inner) => {
                Error::UnauthorizedOperationException(inner)
            }
            crate::error::DescribeRootFoldersError::UnauthorizedResourceAccessException(inner) => {
                Error::UnauthorizedResourceAccessException(inner)
            }
            crate::error::DescribeRootFoldersError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeUsersError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DescribeUsersError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeUsersError> for Error {
    fn from(err: crate::error::DescribeUsersError) -> Self {
        match err {
            crate::error::DescribeUsersError::EntityNotExistsException(inner) => {
                Error::EntityNotExistsException(inner)
            }
            crate::error::DescribeUsersError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::DescribeUsersError::InvalidArgumentException(inner) => {
                Error::InvalidArgumentException(inner)
            }
            crate::error::DescribeUsersError::RequestedEntityTooLargeException(inner) => {
                Error::RequestedEntityTooLargeException(inner)
            }
            crate::error::DescribeUsersError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::DescribeUsersError::UnauthorizedOperationException(inner) => {
                Error::UnauthorizedOperationException(inner)
            }
            crate::error::DescribeUsersError::UnauthorizedResourceAccessException(inner) => {
                Error::UnauthorizedResourceAccessException(inner)
            }
            crate::error::DescribeUsersError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetCurrentUserError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetCurrentUserError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetCurrentUserError> for Error {
    fn from(err: crate::error::GetCurrentUserError) -> Self {
        match err {
            crate::error::GetCurrentUserError::EntityNotExistsException(inner) => {
                Error::EntityNotExistsException(inner)
            }
            crate::error::GetCurrentUserError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::GetCurrentUserError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::GetCurrentUserError::UnauthorizedOperationException(inner) => {
                Error::UnauthorizedOperationException(inner)
            }
            crate::error::GetCurrentUserError::UnauthorizedResourceAccessException(inner) => {
                Error::UnauthorizedResourceAccessException(inner)
            }
            crate::error::GetCurrentUserError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetDocumentError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetDocumentError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetDocumentError> for Error {
    fn from(err: crate::error::GetDocumentError) -> Self {
        match err {
            crate::error::GetDocumentError::EntityNotExistsException(inner) => {
                Error::EntityNotExistsException(inner)
            }
            crate::error::GetDocumentError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::GetDocumentError::InvalidArgumentException(inner) => {
                Error::InvalidArgumentException(inner)
            }
            crate::error::GetDocumentError::InvalidPasswordException(inner) => {
                Error::InvalidPasswordException(inner)
            }
            crate::error::GetDocumentError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::GetDocumentError::UnauthorizedOperationException(inner) => {
                Error::UnauthorizedOperationException(inner)
            }
            crate::error::GetDocumentError::UnauthorizedResourceAccessException(inner) => {
                Error::UnauthorizedResourceAccessException(inner)
            }
            crate::error::GetDocumentError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetDocumentPathError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetDocumentPathError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetDocumentPathError> for Error {
    fn from(err: crate::error::GetDocumentPathError) -> Self {
        match err {
            crate::error::GetDocumentPathError::EntityNotExistsException(inner) => {
                Error::EntityNotExistsException(inner)
            }
            crate::error::GetDocumentPathError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::GetDocumentPathError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::GetDocumentPathError::UnauthorizedOperationException(inner) => {
                Error::UnauthorizedOperationException(inner)
            }
            crate::error::GetDocumentPathError::UnauthorizedResourceAccessException(inner) => {
                Error::UnauthorizedResourceAccessException(inner)
            }
            crate::error::GetDocumentPathError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetDocumentVersionError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetDocumentVersionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetDocumentVersionError> for Error {
    fn from(err: crate::error::GetDocumentVersionError) -> Self {
        match err {
            crate::error::GetDocumentVersionError::EntityNotExistsException(inner) => {
                Error::EntityNotExistsException(inner)
            }
            crate::error::GetDocumentVersionError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::GetDocumentVersionError::InvalidPasswordException(inner) => {
                Error::InvalidPasswordException(inner)
            }
            crate::error::GetDocumentVersionError::ProhibitedStateException(inner) => {
                Error::ProhibitedStateException(inner)
            }
            crate::error::GetDocumentVersionError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::GetDocumentVersionError::UnauthorizedOperationException(inner) => {
                Error::UnauthorizedOperationException(inner)
            }
            crate::error::GetDocumentVersionError::UnauthorizedResourceAccessException(inner) => {
                Error::UnauthorizedResourceAccessException(inner)
            }
            crate::error::GetDocumentVersionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetFolderError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetFolderError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetFolderError> for Error {
    fn from(err: crate::error::GetFolderError) -> Self {
        match err {
            crate::error::GetFolderError::EntityNotExistsException(inner) => {
                Error::EntityNotExistsException(inner)
            }
            crate::error::GetFolderError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::GetFolderError::InvalidArgumentException(inner) => {
                Error::InvalidArgumentException(inner)
            }
            crate::error::GetFolderError::ProhibitedStateException(inner) => {
                Error::ProhibitedStateException(inner)
            }
            crate::error::GetFolderError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::GetFolderError::UnauthorizedOperationException(inner) => {
                Error::UnauthorizedOperationException(inner)
            }
            crate::error::GetFolderError::UnauthorizedResourceAccessException(inner) => {
                Error::UnauthorizedResourceAccessException(inner)
            }
            crate::error::GetFolderError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetFolderPathError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetFolderPathError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetFolderPathError> for Error {
    fn from(err: crate::error::GetFolderPathError) -> Self {
        match err {
            crate::error::GetFolderPathError::EntityNotExistsException(inner) => {
                Error::EntityNotExistsException(inner)
            }
            crate::error::GetFolderPathError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::GetFolderPathError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::GetFolderPathError::UnauthorizedOperationException(inner) => {
                Error::UnauthorizedOperationException(inner)
            }
            crate::error::GetFolderPathError::UnauthorizedResourceAccessException(inner) => {
                Error::UnauthorizedResourceAccessException(inner)
            }
            crate::error::GetFolderPathError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetResourcesError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetResourcesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetResourcesError> for Error {
    fn from(err: crate::error::GetResourcesError) -> Self {
        match err {
            crate::error::GetResourcesError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::GetResourcesError::InvalidArgumentException(inner) => {
                Error::InvalidArgumentException(inner)
            }
            crate::error::GetResourcesError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::GetResourcesError::UnauthorizedOperationException(inner) => {
                Error::UnauthorizedOperationException(inner)
            }
            crate::error::GetResourcesError::UnauthorizedResourceAccessException(inner) => {
                Error::UnauthorizedResourceAccessException(inner)
            }
            crate::error::GetResourcesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::InitiateDocumentVersionUploadError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::InitiateDocumentVersionUploadError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::InitiateDocumentVersionUploadError> for Error {
    fn from(err: crate::error::InitiateDocumentVersionUploadError) -> Self {
        match err {
            crate::error::InitiateDocumentVersionUploadError::DraftUploadOutOfSyncException(inner) => Error::DraftUploadOutOfSyncException(inner),
            crate::error::InitiateDocumentVersionUploadError::EntityAlreadyExistsException(inner) => Error::EntityAlreadyExistsException(inner),
            crate::error::InitiateDocumentVersionUploadError::EntityNotExistsException(inner) => Error::EntityNotExistsException(inner),
            crate::error::InitiateDocumentVersionUploadError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::error::InitiateDocumentVersionUploadError::InvalidPasswordException(inner) => Error::InvalidPasswordException(inner),
            crate::error::InitiateDocumentVersionUploadError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::InitiateDocumentVersionUploadError::ProhibitedStateException(inner) => Error::ProhibitedStateException(inner),
            crate::error::InitiateDocumentVersionUploadError::ResourceAlreadyCheckedOutException(inner) => Error::ResourceAlreadyCheckedOutException(inner),
            crate::error::InitiateDocumentVersionUploadError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::error::InitiateDocumentVersionUploadError::StorageLimitExceededException(inner) => Error::StorageLimitExceededException(inner),
            crate::error::InitiateDocumentVersionUploadError::StorageLimitWillExceedException(inner) => Error::StorageLimitWillExceedException(inner),
            crate::error::InitiateDocumentVersionUploadError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::error::InitiateDocumentVersionUploadError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::error::InitiateDocumentVersionUploadError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::RemoveAllResourcePermissionsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::RemoveAllResourcePermissionsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::RemoveAllResourcePermissionsError> for Error {
    fn from(err: crate::error::RemoveAllResourcePermissionsError) -> Self {
        match err {
            crate::error::RemoveAllResourcePermissionsError::FailedDependencyException(inner) => Error::FailedDependencyException(inner),
            crate::error::RemoveAllResourcePermissionsError::ServiceUnavailableException(inner) => Error::ServiceUnavailableException(inner),
            crate::error::RemoveAllResourcePermissionsError::UnauthorizedOperationException(inner) => Error::UnauthorizedOperationException(inner),
            crate::error::RemoveAllResourcePermissionsError::UnauthorizedResourceAccessException(inner) => Error::UnauthorizedResourceAccessException(inner),
            crate::error::RemoveAllResourcePermissionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::RemoveResourcePermissionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::RemoveResourcePermissionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::RemoveResourcePermissionError> for Error {
    fn from(err: crate::error::RemoveResourcePermissionError) -> Self {
        match err {
            crate::error::RemoveResourcePermissionError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::RemoveResourcePermissionError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::RemoveResourcePermissionError::UnauthorizedOperationException(inner) => {
                Error::UnauthorizedOperationException(inner)
            }
            crate::error::RemoveResourcePermissionError::UnauthorizedResourceAccessException(
                inner,
            ) => Error::UnauthorizedResourceAccessException(inner),
            crate::error::RemoveResourcePermissionError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::RestoreDocumentVersionsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::RestoreDocumentVersionsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::RestoreDocumentVersionsError> for Error {
    fn from(err: crate::error::RestoreDocumentVersionsError) -> Self {
        match err {
            crate::error::RestoreDocumentVersionsError::ConcurrentModificationException(inner) => {
                Error::ConcurrentModificationException(inner)
            }
            crate::error::RestoreDocumentVersionsError::ConflictingOperationException(inner) => {
                Error::ConflictingOperationException(inner)
            }
            crate::error::RestoreDocumentVersionsError::EntityNotExistsException(inner) => {
                Error::EntityNotExistsException(inner)
            }
            crate::error::RestoreDocumentVersionsError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::RestoreDocumentVersionsError::InvalidOperationException(inner) => {
                Error::InvalidOperationException(inner)
            }
            crate::error::RestoreDocumentVersionsError::ProhibitedStateException(inner) => {
                Error::ProhibitedStateException(inner)
            }
            crate::error::RestoreDocumentVersionsError::UnauthorizedOperationException(inner) => {
                Error::UnauthorizedOperationException(inner)
            }
            crate::error::RestoreDocumentVersionsError::UnauthorizedResourceAccessException(
                inner,
            ) => Error::UnauthorizedResourceAccessException(inner),
            crate::error::RestoreDocumentVersionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateDocumentError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdateDocumentError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateDocumentError> for Error {
    fn from(err: crate::error::UpdateDocumentError) -> Self {
        match err {
            crate::error::UpdateDocumentError::ConcurrentModificationException(inner) => {
                Error::ConcurrentModificationException(inner)
            }
            crate::error::UpdateDocumentError::ConflictingOperationException(inner) => {
                Error::ConflictingOperationException(inner)
            }
            crate::error::UpdateDocumentError::EntityAlreadyExistsException(inner) => {
                Error::EntityAlreadyExistsException(inner)
            }
            crate::error::UpdateDocumentError::EntityNotExistsException(inner) => {
                Error::EntityNotExistsException(inner)
            }
            crate::error::UpdateDocumentError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::UpdateDocumentError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::UpdateDocumentError::ProhibitedStateException(inner) => {
                Error::ProhibitedStateException(inner)
            }
            crate::error::UpdateDocumentError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::UpdateDocumentError::UnauthorizedOperationException(inner) => {
                Error::UnauthorizedOperationException(inner)
            }
            crate::error::UpdateDocumentError::UnauthorizedResourceAccessException(inner) => {
                Error::UnauthorizedResourceAccessException(inner)
            }
            crate::error::UpdateDocumentError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateDocumentVersionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdateDocumentVersionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateDocumentVersionError> for Error {
    fn from(err: crate::error::UpdateDocumentVersionError) -> Self {
        match err {
            crate::error::UpdateDocumentVersionError::ConcurrentModificationException(inner) => {
                Error::ConcurrentModificationException(inner)
            }
            crate::error::UpdateDocumentVersionError::EntityNotExistsException(inner) => {
                Error::EntityNotExistsException(inner)
            }
            crate::error::UpdateDocumentVersionError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::UpdateDocumentVersionError::InvalidOperationException(inner) => {
                Error::InvalidOperationException(inner)
            }
            crate::error::UpdateDocumentVersionError::ProhibitedStateException(inner) => {
                Error::ProhibitedStateException(inner)
            }
            crate::error::UpdateDocumentVersionError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::UpdateDocumentVersionError::UnauthorizedOperationException(inner) => {
                Error::UnauthorizedOperationException(inner)
            }
            crate::error::UpdateDocumentVersionError::UnauthorizedResourceAccessException(
                inner,
            ) => Error::UnauthorizedResourceAccessException(inner),
            crate::error::UpdateDocumentVersionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateFolderError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdateFolderError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateFolderError> for Error {
    fn from(err: crate::error::UpdateFolderError) -> Self {
        match err {
            crate::error::UpdateFolderError::ConcurrentModificationException(inner) => {
                Error::ConcurrentModificationException(inner)
            }
            crate::error::UpdateFolderError::ConflictingOperationException(inner) => {
                Error::ConflictingOperationException(inner)
            }
            crate::error::UpdateFolderError::EntityAlreadyExistsException(inner) => {
                Error::EntityAlreadyExistsException(inner)
            }
            crate::error::UpdateFolderError::EntityNotExistsException(inner) => {
                Error::EntityNotExistsException(inner)
            }
            crate::error::UpdateFolderError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::UpdateFolderError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::UpdateFolderError::ProhibitedStateException(inner) => {
                Error::ProhibitedStateException(inner)
            }
            crate::error::UpdateFolderError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::UpdateFolderError::UnauthorizedOperationException(inner) => {
                Error::UnauthorizedOperationException(inner)
            }
            crate::error::UpdateFolderError::UnauthorizedResourceAccessException(inner) => {
                Error::UnauthorizedResourceAccessException(inner)
            }
            crate::error::UpdateFolderError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateUserError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdateUserError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateUserError> for Error {
    fn from(err: crate::error::UpdateUserError) -> Self {
        match err {
            crate::error::UpdateUserError::DeactivatingLastSystemUserException(inner) => {
                Error::DeactivatingLastSystemUserException(inner)
            }
            crate::error::UpdateUserError::EntityNotExistsException(inner) => {
                Error::EntityNotExistsException(inner)
            }
            crate::error::UpdateUserError::FailedDependencyException(inner) => {
                Error::FailedDependencyException(inner)
            }
            crate::error::UpdateUserError::IllegalUserStateException(inner) => {
                Error::IllegalUserStateException(inner)
            }
            crate::error::UpdateUserError::InvalidArgumentException(inner) => {
                Error::InvalidArgumentException(inner)
            }
            crate::error::UpdateUserError::ProhibitedStateException(inner) => {
                Error::ProhibitedStateException(inner)
            }
            crate::error::UpdateUserError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::UpdateUserError::UnauthorizedOperationException(inner) => {
                Error::UnauthorizedOperationException(inner)
            }
            crate::error::UpdateUserError::UnauthorizedResourceAccessException(inner) => {
                Error::UnauthorizedResourceAccessException(inner)
            }
            crate::error::UpdateUserError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl std::error::Error for Error {}
impl aws_http::request_id::RequestId for Error {
    fn request_id(&self) -> Option<&str> {
        match self {
            Self::ConcurrentModificationException(e) => e.request_id(),
            Self::ConflictingOperationException(e) => e.request_id(),
            Self::CustomMetadataLimitExceededException(e) => e.request_id(),
            Self::DeactivatingLastSystemUserException(e) => e.request_id(),
            Self::DocumentLockedForCommentsException(e) => e.request_id(),
            Self::DraftUploadOutOfSyncException(e) => e.request_id(),
            Self::EntityAlreadyExistsException(e) => e.request_id(),
            Self::EntityNotExistsException(e) => e.request_id(),
            Self::FailedDependencyException(e) => e.request_id(),
            Self::IllegalUserStateException(e) => e.request_id(),
            Self::InvalidArgumentException(e) => e.request_id(),
            Self::InvalidCommentOperationException(e) => e.request_id(),
            Self::InvalidOperationException(e) => e.request_id(),
            Self::InvalidPasswordException(e) => e.request_id(),
            Self::LimitExceededException(e) => e.request_id(),
            Self::ProhibitedStateException(e) => e.request_id(),
            Self::RequestedEntityTooLargeException(e) => e.request_id(),
            Self::ResourceAlreadyCheckedOutException(e) => e.request_id(),
            Self::ServiceUnavailableException(e) => e.request_id(),
            Self::StorageLimitExceededException(e) => e.request_id(),
            Self::StorageLimitWillExceedException(e) => e.request_id(),
            Self::TooManyLabelsException(e) => e.request_id(),
            Self::TooManySubscriptionsException(e) => e.request_id(),
            Self::UnauthorizedOperationException(e) => e.request_id(),
            Self::UnauthorizedResourceAccessException(e) => e.request_id(),
            Self::Unhandled(e) => e.request_id(),
        }
    }
}
